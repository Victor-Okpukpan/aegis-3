{
  "category": "Farm",
  "total_findings": 17,
  "fetched_at": "2026-01-29T13:40:50Z",
  "findings": [
    {
      "id": "26171",
      "title": "Use != 0 instead of > 0 for unsigned integer comparison",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n269:         if (_amount > 0) {\n\n299:         if (!petAlive && pet.ownership > 0) {\n\n432:         if (totYield > 0) {\n\n497:             if (_milkAmount > 0) {\n\n541:         if (yieldToWithdraw > 0) {\n\n558:                 require(yieldToWithdraw > 0); // This should never be hit and is maybe not needed, but just in case.\n\n562:                 require(yieldToWithdraw > 0); // This should never be hit and is maybe not needed, but just in case.\n\n709:         if (_totalYieldNoMilk > 0) {\n\n723:         if (s_totalOwnership > 0) {\n\n741:         if (s_totalOwnership > 0) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n129:             if (!stakePetContract.alive(pet.lastProofOfLife) && pet.ownership > 0) {\n\n```\n\n**Client:** Fixed in [9e3d0d0](https://github.com/Ranama/StakePet/commit/9e3d0d0c1b6a324e22e0e3f70453c6d411cd9101)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26170",
      "title": "Use shift Right/Left instead of division/multiplication if possible",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n420:         if (_totalValueWantsClosedown <= totalValue() / 2) {\n\n```\n\n**Client:** Fixed in [540cca1](https://github.com/Ranama/StakePet/commit/540cca16669ee8575806d0f3430723726e3d9c2e)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26169",
      "title": "`++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n127:         for (uint256 i = 1; i <= currentPetId; i++) {\n\n131:                 j++;\n\n137:         for (uint256 i = 0; i < j; i++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [27225c2](https://github.com/Ranama/StakePet/commit/27225c256c3173cc306045949584b66be7f60c0f)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26168",
      "title": "Don't initialize variables with default value",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n128:     uint256 public s_closedAtTimestamp = 0; // The timestamp that the contract was closed down\n\n409:         uint256 _totalValueWantsClosedown = 0;\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n123:         uint256 j = 0;\n\n137:         for (uint256 i = 0; i < j; i++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [970b71c](https://github.com/Ranama/StakePet/commit/970b71cfe73760dc694b0c0e1e5a3a77dc704c8c)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26167",
      "title": "Cache array length outside of loop",
      "impact": "GAS",
      "content": "If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).\n\n```solidity\nFile: StakePet.sol\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [627d09c](https://github.com/Ranama/StakePet/commit/627d09c34bb4853418e8c22ed8ce291efd7ad087)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26166",
      "title": "Using bools for storage incurs overhead",
      "impact": "GAS",
      "content": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).\n\n```solidity\nFile: StakePet.sol\n\n91:     bool public constant TESTING = true; // TODO: Remove this when not testing\n\n107:     bool public immutable HARDCORE; // Whether the initial collateral is taken if failing to proof of life or not\n\n```\n\n**Client:** Fixed in [aea1f74](https://github.com/Ranama/StakePet/commit/aea1f7464339cb16008143440bd427b6f0a14669)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26165",
      "title": "Exit fees implementation is inconsistent with documentation",
      "impact": "LOW",
      "content": "**Severity:** Low\n\n**Description:** Inline comments of `StakePet` contract indicate that exit fee is charged as % of the collateral.\n\n```\nThe contract also has an early exit fee, which is a percentage of the collateral taken if a participant chooses to exit early.\n```\n\nHowever, implementation shows that exit fee is charged as a [percent of yield](https://github.com/Ranama/StakePet/blob/9ba301823b5062d657baa3462224da498dc4bb46/src/StakePet.sol#L559)\n\n```\nuint256 earlyExitFee = (uint256(yieldToWithdraw) * EARLY_EXIT_FEE) / BASIS_POINT\n```\n\n**Recommended Mitigation:** Consider correcting code documentation to reflect actual implementation\n\n**Client:** Fixed in [54a4dcb](https://github.com/Ranama/StakePet/commit/54a4dcbb696da3138dc0fdd8e7032d664d32b7da)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Documentation"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26164",
      "title": "Closedown condition is inconsistent with the stated documentation of majority agreement",
      "impact": "LOW",
      "content": "**Severity:** Low\n\n**Description:** [Documentation](https://hackmd.io/CPINxScvSE2vo-t8mwY_Og#Risks) states the following:\n\n_\"Closing the Contract: If the majority of the pets agree, they can vote to close the contract. Once closed, the remaining funds will be divided among the surviving pets. This is the most beneficial scenario for you, as you’ll earn the base rewards, early withdrawal rewards, and rewards from dead pets.\"_\n\nInline comments for the [`StakePet::closedown`](https://github.com/Ranama/StakePet/blob/9ba301823b5062d657baa3462224da498dc4bb46/src/StakePet.sol#L398C2-L398C2) function state the following\"\n\n```\n    /// @notice Close down the contract if majority wants it, after closedown everyone can withdraw without getting a yield cut and no pet can die.\n    function closedown(uint256[] memory _idsOfMajorityThatWantsClosedown) external {\n...\n}\n```\n\nIn both cases, condition for closedown is for `majority of pets` to agree for a closedown. However, the check used for `closedown` is that the total collateral of pets wanting a closedown should be atleast 50% of the total collateral. This would mean that a single or few pet owners with large collateral deposits can trigger a closedown even if its not something that a majority of pet owners agree to.\n\nHaving 50% of value agreement and having majority agreement could be 2 different things.\n\n**Impact:** The current model can be hijacked by whales who can trigger closedown of contract whenever they wish to. This could create a bad user experience for majority of pet owners who want to stay in the contract\n\n**Recommended Mitigation:** Please make documentation consistent with the vision for stake pets.\n\n**Client:** Fixed in [54a4dcb](https://github.com/Ranama/StakePet/commit/54a4dcbb696da3138dc0fdd8e7032d664d32b7da)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Documentation",
        "Business Logic"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26163",
      "title": "A malicious user can grief a `StakePet` contract by creating massive number of pets",
      "impact": "MEDIUM",
      "content": "**Severity:** Medium\n\n**Description:** The `StakePet::create` function facilitates the minting of a pet NFT by depositing collateral. However, its lack of a minimum deposit requirement for minting exposes it to potential abuse. A malicious user can exploit this by minting an excessive number of NFTs. Notably, this behaviour can strain functions like `StakePetManager::buryAllDeadPets`, which in turn calls `StakePetManager::getDeadNonBuriedPets`. This latter function iterates through all pet IDs to identify pets that are dead but not yet buried.\n\n**Impact:** When a function processes an extensive and potentially unlimited list of pet IDs, there's a risk of it consuming all available gas. Consequently, it can fail, throwing an out-of-gas exception, which negatively affects users trying to interact with the contract.\n\n**Recommended Mitigation:** To deter such griefing attacks, it's advisable to introduce a minimum deposit requirement for the creation of a new pet. Setting this threshold ensures that the mass-minting strategy becomes cost-prohibitive for attackers.\n\n**Client:** Fixed in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report concerns the `StakePet::create` function, which allows for the minting of a pet Non-Fungible Token (NFT) by depositing collateral. The bug arises because the function has no minimum deposit requirement, exposing it to potential abuse. A malicious user can exploit this by minting an excessive number of NFTs. This could strain functions like `StakePetManager::buryAllDeadPets`, which calls `StakePetManager::getDeadNonBuriedPets`. This latter function iterates through all pet IDs to identify dead but not yet buried pets, potentially consuming all available gas and resulting in an out-of-gas exception.\n\nTo mitigate this issue, it's recommended to introduce a minimum deposit requirement for the creation of a new pet. This would make mass-minting cost-prohibitive for attackers. The client has fixed the bug in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764), which has been verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Grief Attack",
        "Gas Limit"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26162",
      "title": "Inflation attack can cause early users to lose their deposit",
      "impact": "HIGH",
      "content": "**Severity:** High\n\n**Description:** A malicious `StakePet` contract creator can steal funds from depositors by launching a typical inflation attack. To execute the attack, the creator can first deposit `1 wei` to get `1 wei` of ownership. Creator can subsequently send a big amount of collateral directly to the `StakePet` contract - this will hugely inflate the value of the single share.\n\nNow, all subsequent pet owners who deposit their collateral will get no ownership in return. The `StakePet::ownershipToMint` function uses `StakePet::totalValue` to calculate the ownership of a new depositor. While the total ownership represented by `s_totalOwnership` remains the same `1 wei`, the `totalValueBefore` is a huge number, thanks to a large direct deposit done by the creator. This ensures that the 1 wei of share represents a huge value of collateral & causes the ownership of new depositors to round to 0.\n\n**Impact:** Potential complete loss of funds for new depositors, given they receive no ownership in exchange for their deposited tokens.\n\n**Proof of Concept:**\n- Bob, a malicious actor, initiates the StakePet contract.\n- By calling `StakePet::create`, Bob creates a pet depositing a mere `1 wei`, which grants him `1 wei` of ownership.\n- Bob then directly transfers a significant amount, like 10 ether, to the `StakePet` contract.\n- Consequently, a single `1 wei` share becomes equivalent to `10 ether`.\n- An innocent user, Pete, tries to create a pet by calling `StakePet::create` and deposits 1 ether.\n- Pete, unfortunately, receives zero ownership while his deposit remains within the contract\n\n**Recommended Mitigation:** Inflation attacks have known defences. A comprehensive discussion can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706).\n\nOne noteworthy method, as implemented by Uniswap V2, involves depositing minimal liquidity into the contract and transferring its ownership to a null address, creating \"dead shares\". This technique protects the subsequent depositor from potential inflation attacks.\n\nIn this case, it might be beneficial to introduce a minimum collateral requirement during contract initiation, and accordingly adjust `s_totalOwnership` to match this preset collateral.\n\n**Client:** Fixed in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764) and [21dd15b](https://github.com/Ranama/StakePet/commit/21dd15b1fceecddb9caf47739b6df1a4d1856367).\n\n**Cyfrin:** Verified.",
      "summary": "\nA malicious `StakePet` contract creator can steal funds from depositors by launching an inflation attack. The creator can deposit a small amount of funds to gain ownership, then send a large amount of collateral directly to the `StakePet` contract. This will cause the single share to represent a huge value of collateral, and any new depositors will receive zero ownership in return for their deposited tokens. This could result in a complete loss of funds for new depositors.\n\nA mitigation to this attack, as implemented by Uniswap V2, is to deposit minimal liquidity into the contract and transfer its ownership to a null address, creating \"dead shares\". This technique protects the subsequent depositor from potential inflation attacks. Another solution is to introduce a minimum collateral requirement during contract initiation, and adjust `s_totalOwnership` to match this preset collateral.\n\nThe bug was fixed in two commits: [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764) and [21dd15b](https://github.com/Ranama/StakePet/commit/21dd15b1fceecddb9caf47739b6df1a4d1856367). The fix was verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Vault",
        "Share Inflation",
        "Initial Deposit",
        "First Depositor Issue"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26161",
      "title": "Attackers can use a malicious yield token to steal funds from users",
      "impact": "HIGH",
      "content": "**Severity:** High\n\n**Description:** According to the documentation and the current implementation, anyone can create a new StakePet contract and feed any address for the `YIELD_TOKEN`. As long as a contract implements `IYieldToken` interface, the contract will be created without problems.\n\nAn attacker can create a malicious `IYieldToken` implementation and use that to steal funds from users.\nThe StakePet contract relies on `YIELD_TOKEN.toToken()` and `YIELD_TOKEN.toValue()` in numerous places for accounting.\nConsider a contract that has implemented different logic in `toToken()` and `toValue()` according to the owner's hidden flag.\nThe attacker is likely to let the malicious token contract work normally till the StakePet contract gets enough deposits.\nThen they can switch the hidden flag as they needed to mess the accounting and take profit from it.\nIn the worst case, they can even manipulate the output of `IYieldToken::ERC20_TOKEN()` (maybe to freeze the user funds permanently).\n\n**Impact:** User funds can be stolen or permanently locked.\n\n**Recommended Mitigation:** Consider maintaining a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.\n\n**Client:** Fixed in commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about a vulnerability in the StakePet contract which allows attackers to create malicious tokens and use them to steal or permanently lock user funds. The bug is caused by the contract allowing any address to be fed as the `YIELD_TOKEN` which can be a malicious token contract. The malicious contract can then manipulate the output of `IYieldToken::ERC20_TOKEN()` to freeze user funds. The bug has been fixed with the commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7) and has been verified. The recommended mitigation is to maintain a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Validation",
        "Access Control"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "11474",
      "title": "[L03] Complicated Code",
      "impact": "LOW",
      "content": "There are cases where the data structure leads to unnecessarily complicated code. In particular the scheduled balances track the `previousBalance` and `lastBalance` separately. However, [the only time the previous balance is updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ScheduledBalance.sol#L67) occurs immediately after the [balance is consolidated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L179), and only when the `currentTimestamp` is after the `lastTimestamp`. In this case, the `previousBalance` will be increased by zero. This implies it will always be zero.\n\n\nThis fact is not obvious, but it is implicitly assumed when the scheduled balances are converted to tokens (since all balances use the same exchange rate, no matter when they were added). While correct, it makes the code harder to reason about.\n\n\nConsider simplifying the scheduled balance data structure to record a single balance with its timestamp.\n\n\n**Update:** *Fixed in [PR#7](https://github.com/pooltogether/pods/pull/7/). The data structure was updated as suggested and the `ScheduledBalance` and `Pod` contracts were updated accordingly.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11473",
      "title": "[L02] Misleading comments",
      "impact": "LOW",
      "content": "Some of the code comments could be clearer.  \n\n– In [line 85 of FixedPoint.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/FixedPoint.sol#L85): `fixed point 18 number` should be `fixed point 18 mantissa` to be consistent with the convention used in the code base.  \n\n– In [line 106](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L106) and [line 119](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L119) of `ExchangeRateTracker.sol`: the phrase `in the past` should be `at the specified timestamp`.  \n\n– In [line 80](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L80) and [line 91](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L91) of `Pod.sol`: `burned` should be `redeemed`  \n\n– In [line 113 of Pod.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L113): `debited` should be `credited`\n\n\n**Update:** *Fixed in [PR#6](https://github.com/pooltogether/pods/pull/6/). The comments were updated appropriately.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11472",
      "title": "[L01] Missing return value",
      "impact": "LOW",
      "content": "The [clearConsolidated function signature](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ScheduledBalance.sol#L160) claims the function returns a `uint256` but it doesn’t return anything. Additionally, its return value is not checked in the [the only place it is used](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L449).\n\n\nConsider removing the return value from the function signature.\n\n\n**Update:** *Fixed in [PR#5](https://github.com/pooltogether/pods/pull/5/). The return value was removed from the `clearConsolidated` function signature.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11471",
      "title": "[M01] Incomplete ERC777 functionality",
      "impact": "MEDIUM",
      "content": "When a user deposits funds into a pod, they are [scheduled to receive Pod tokens](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L185) after the current draw. Conceptually, when the draw is over, they should have full access to the ERC777 functionality of their Pod tokens. In practice, they only receive the tokens once [consolidateBalanceOf](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L459) is called (which occurs on any subsequent state-changing interaction with the Pod-specific functions).\n\n\nIn the mean time, the `send`, `transfer` and `transferFrom` functions do not account for the new tokens.\n\n\nConsider extending these methods to call `consolidateBalanceOf`. Alternatively, consider making `consolidateBalanceOf` a public function so users can manually consolidate their tokens.\n\n\n**Update:** *Fixed in [PR#4](https://github.com/pooltogether/pods/pull/4/). The `Pod` contract extends `send`, `operatorSend`, `transfer` and `transferFrom` to call `consolidateBalanceOf` on the relevant address before calling the corresponding parent method.*",
      "summary": "\nA bug was identified in the PoolTogether Pods system, where users who have deposited funds into a pod were not receiving their Pod tokens after a draw was over. The 'send', 'transfer', and 'transferFrom' functions did not account for the new tokens. \n\nThe bug was fixed by extending the methods to call 'consolidateBalanceOf' or making 'consolidateBalanceOf' a public function so users could manually consolidate their tokens. The fix was implemented in Pull Request #4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11470",
      "title": "[H01] Deposit uses operator collateral",
      "impact": "HIGH",
      "content": "The `_deposit` function of the Pod contract [attempts to take collateral from the `operator`](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L180) but [credits it to the `from` address](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L185).\n\n\nIf successful, this effectively transfers funds from the operator to the `from` address. On the other hand, if the operator has insufficient funds or the Pod contract does not have approval, the [`operatorDeposit` function](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L151) will revert. Either scenario is undesirable.\n\n\nConsider updating the `transferFrom` arguments to retrieve collateral from the `from` address.\n\n\n**Update:** *Fixed in [PR#3](https://github.com/pooltogether/pods/pull/3/). Collateral is correctly taken from the `from` address.*",
      "summary": "\nThis bug report is about the `_deposit` function of the Pod contract, which is used to take collateral from the `operator` address and credit it to the `from` address. This transfer of funds from the operator to the `from` address can be successful, however, if the operator has insufficient funds or the Pod contract does not have approval, the `operatorDeposit` function will revert. The fix for this bug was to update the `transferFrom` arguments to retrieve collateral from the `from` address, which was done in Pull Request #3 and is now fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11469",
      "title": "[C01] Supply is manipulable",
      "impact": "HIGH",
      "content": "When a user deposits collateral, the total supply and their individual balance [are scheduled to be updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L184-L185) in the next draw. However, if the collateral is withdrawn before the next round, [the user’s individual balance is updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L292) but the supply is not.\n\n\nWhen the [supply is consolidated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L444), additional Pod tokens will be minted that are not assigned to any user.\n\n\nSubsequently, when the pod wins a lottery, the new Pool tokens will be spread evenly over all Pod tokens, even the ones that are unassigned. This means that users will receive less than their fair share of the winnings.\n\n\nConsider updating the scheduled supply when withdrawing a pending deposit. More generally, consider abstracting the interaction with scheduled user balances and supply so they are both updated with the same call.\n\n\n**Update:** *Fixed in [PR#2](https://github.com/pooltogether/pods/pull/2/). The supply is updated when withdrawing a pending deposit.*",
      "summary": "\nThis bug report is about an issue with the PoolTogether Pods protocol. When a user deposits collateral, the total supply and their individual balance are scheduled to be updated in the next draw. However, if the user withdraws their collateral before the next round, their individual balance is updated but the supply is not. This means that when the supply is consolidated, additional Pod tokens will be minted that are not assigned to any user. This causes an issue when the pod wins a lottery, as the new Pool tokens will be spread evenly over all Pod tokens, including the unassigned ones. This results in users receiving less than their fair share of the winnings. \n\nThe bug was fixed in PR#2, where the supply is now updated when withdrawing a pending deposit. Additionally, the interaction between scheduled user balances and supply has been abstracted, so they are both updated with the same call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}