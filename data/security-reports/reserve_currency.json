{
  "category": "Reserve Currency",
  "total_findings": 49,
  "fetched_at": "2026-01-29T13:47:47Z",
  "findings": [
    {
      "id": "23862",
      "title": "[N-01] Typo",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L411\n\nsandwich is not correct here.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/42)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "16120",
      "title": "[G-17] RewardThrottle.sol has code that needs to be UNCHECKED in many places",
      "impact": "GAS",
      "content": "\nL117 SHOULD BE UNCHECKED DUE TO L116\n\nL162 AND L146 SHOULD BE UNCHECKED DUE TO L145\n\nL222 SHOULD BE UNCHECKED DUE TO L219\n...\n\n```\n116:        if (balance > remainder) {\n117          balance -= remainder;\n...\n145    if (cashflowAverageApr > targetCashflowApr) {\n146      uint256 delta = cashflowAverageApr - targetCashflowApr;\n...\n162:      uint256 delta = targetCashflowApr - cashflowAverageApr;\n...\n219    if (endEpoch < averagePeriod) {\n      averagePeriod = currentEpoch;\n    } else {\n222:      startEpoch = endEpoch - averagePeriod;\n...\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/19)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-17-rewardthrottlesol-has-code-that-needs-to-be-unchecked-in-many-places",
      "tags": [],
      "finders": []
    },
    {
      "id": "16119",
      "title": "[G-16] LinearDistributor.sol has code that needs to be UNCHECKED in many places",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn’t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: https://docs.soliditylang.org/en/v0.8.7/control-structures.html#checked-or-unchecked-arithmetic\n\n\nL149 SHOULD BE UNCHECKED DUE TO L147\n\n\nL169 SHOULD BE UNCHECKED DUE TO L164\n\n\nL188 SHOULD BE UNCHECKED DUE TO L186\n\n```solidity\n147:    if (balance > bufferRequirement) {\n148:      // We have more than the buffer required. Forfeit the rest\n149:      uint256 net = balance - bufferRequirement;\n150:      _forfeit(net);\n151:    }\n...\n163:    require(\n164:      amount <= declaredBalance,\n165:      \"Can't decrement more than total reward balance\"\n166:    );\n167:\n168:    if (amount > 0) {\n169:      declaredBalance = declaredBalance - amount;\n170:    }\n...\n185:  function _forfeit(uint256 forfeited) internal {\n186:    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n187:\n188:    declaredBalance = declaredBalance - forfeited;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-16-lineardistributorsol-has-code-that-needs-to-be-unchecked-in-many-places",
      "tags": [],
      "finders": []
    },
    {
      "id": "16118",
      "title": "[G-15] `SwingTraderManager.delegateCapital()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];         //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return;\n    }\n\n    uint256 capitalUsed;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];         //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n      uint256 share = (amount * traderCapital[i]) / totalCapital;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-15-swingtradermanagerdelegatecapital-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16117",
      "title": "[G-14] `SwingTraderManager.sellMalt()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];           //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);\n      totalMalt += traderMaltBalance;\n      traderMalt[i] = traderMaltBalance;\n    }\n\n    if (totalMalt == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];          //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n      uint256 share = (maxAmount * traderMalt[i]) / totalMalt;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-14-swingtradermanagersellmalt-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16116",
      "title": "[G-13] `SwingTraderManager.buyMalt()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];          //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];           //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-13-swingtradermanagerbuymalt-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16115",
      "title": "[G-12] `LinearDistributor._forfeit()`: declaredBalance should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function _forfeit(uint256 forfeited) internal {\n    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");  //@audit gas: should cache \"declaredBalance\" (SLOAD 1)\n\n    declaredBalance = declaredBalance - forfeited;                               //@audit gas: should cache \"declaredBalance\" (SLOAD 2)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-12-lineardistributor_forfeit-declaredbalance-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16114",
      "title": "[G-11] `LinearDistributor.decrementRewards()`: declaredBalance should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function decrementRewards(uint256 amount)\n    external\n    onlyRoleMalt(REWARD_MINE_ROLE, \"Only reward mine\")\n  {\n    require(\n      amount <= declaredBalance,                         //@audit gas: should cache \"declaredBalance\" (SLOAD 1)\n      \"Can't decrement more than total reward balance\"\n    );\n\n    if (amount > 0) {\n      declaredBalance = declaredBalance - amount;        //@audit gas: should cache \"declaredBalance\" (SLOAD 2)\n    }\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-11-lineardistributordecrementrewards-declaredbalance-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16113",
      "title": "[G-10] `GlobalImpliedCollateralService.sync()`: existingPool.* should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256 existingCollateral = existingPool.total;\n\n    uint256 total = collateral.total; // gas\n    if (existingCollateral <= total) {\n      total -= existingCollateral; // subtract existing value\n    } else {\n      total = 0;\n    }\n\n    uint256 swingTraderMalt = collateral.swingTraderMalt; // gas  \n    if (existingPool.swingTraderMalt <= swingTraderMalt) {        //@audit gas: should cache \"existingPool.swingTraderMalt\" (SLOAD 1)\n      swingTraderMalt -= existingPool.swingTraderMalt;            //@audit gas: should cache \"existingPool.swingTraderMalt\" (SLOAD 2)\n    } else {\n      swingTraderMalt = 0;\n    }\n\n    uint256 swingTraderCollat = collateral.swingTrader; // gas\n    if (existingPool.swingTrader <= swingTraderCollat) {         //@audit gas: should cache \"existingPool.swingTrader\" (SLOAD 1)\n      swingTraderCollat -= existingPool.swingTrader;             //@audit gas: should cache \"existingPool.swingTrader\" (SLOAD 2)\n    } else {\n      swingTraderCollat = 0;\n    }\n\n    uint256 arb = collateral.arbTokens; // gas\n    if (existingPool.arbTokens <= arb) {                         //@audit gas: should cache \"existingPool.arbTokens\" (SLOAD 1)\n      arb -= existingPool.arbTokens;                             //@audit gas: should cache \"existingPool.arbTokens\" (SLOAD 2)\n    } else {\n      arb = 0;\n    }\n\n    uint256 overflow = collateral.rewardOverflow; // gas\n    if (existingPool.rewardOverflow <= overflow) {               //@audit gas: should cache \"existingPool.rewardOverflow\" (SLOAD 1)\n      overflow -= existingPool.rewardOverflow;                   //@audit gas: should cache \"existingPool.rewardOverflow\" (SLOAD 2)\n    } else {\n      overflow = 0;\n    }\n\n    uint256 liquidityExtension = collateral.liquidityExtension; // gas\n    if (existingPool.liquidityExtension <= liquidityExtension) { //@audit gas: should cache \"existingPool.liquidityExtension\" (SLOAD 1)\n      liquidityExtension -= existingPool.liquidityExtension;     //@audit gas: should cache \"existingPool.liquidityExtension\" (SLOAD 2)\n    } else {\n      liquidityExtension = 0;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-10-globalimpliedcollateralservicesync-existingpool-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16112",
      "title": "[G-09] `SwingTraderManager.deployedCapital()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```\n  function deployedCapital() external view returns (uint256 deployed) {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];    // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-09-swingtradermanagerdeployedcapital-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16111",
      "title": "[G-08] `SwingTraderManager.delegateCapital()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return;\n    }\n\n    uint256 capitalUsed;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];    // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-08-swingtradermanagerdelegatecapital-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16110",
      "title": "[G-07] `SwingTraderManager.getTokenBalances()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];  // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-07-swingtradermanagergettokenbalances-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16109",
      "title": "[G-06] `SwingTraderManager.calculateSwingTraderMaltRatio()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-06-swingtradermanagercalculateswingtradermaltratio-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16108",
      "title": "[G-05] `SwingTraderManager.costBasis()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    decimals = collateralToken.decimals();\n\n    uint256 totalMaltBalance;\n    uint256 totalDeployedCapital;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-05-swingtradermanagercostbasis-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16107",
      "title": "[G-04] `SwingTraderManager.sellMalt()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 profit;\n\n    uint256 totalMalt;\n    uint256[] memory traderMalt = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);\n      totalMalt += traderMaltBalance;\n      traderMalt[i] = traderMaltBalance;\n    }\n\n    if (totalMalt == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-04-swingtradermanagersellmalt-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16106",
      "title": "[G-03] `SwingTraderManager.buyMalt()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];  // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n      uint256 share = (maxCapital * traderCapital[i]) / totalCapital;\n\n      if (share == 0) {\n        continue;\n      }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-03-swingtradermanagerbuymalt-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16105",
      "title": "[G-02] `GlobalImpliedCollateralService.swingTraderCollateralRatio()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function swingTraderCollateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n\n    if (totalSupply == 0) {\n      return 0;\n    }\n\n    return (collateral.swingTrader * (10**decimals)) / malt.totalSupply(); // @audit gas: should use  '... / totalSupply'\n  }\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-02-globalimpliedcollateralserviceswingtradercollateralratio-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16104",
      "title": "[G-01] Increments can be unchecked",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there’s a default overflow check on unsigned integers. It’s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\nhttps://github.com/ethereum/solidity/issues/10695\n\nInstances include:\n\n```\nMaltRepository.grantRoleMultiple()#132:    for (uint256 i; i < length; ++i) {\nMaltRepository._setup()#188:    for (uint256 i; i < length; ++i) {\nRewardThrottle.checkRewardUnderflow()#446:      for (uint256 i = _activeEpoch; i < epoch; ++i) {\nRewardThrottle._sendToDistributor()#590:    for (uint256 i; i < length; ++i) {\nRewardThrottle._fillInEpochGaps()#639:    for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {\nRewardThrottle.populateFromPreviousThrottle()#667:    for (uint256 i = _activeEpoch; i < epoch; ++i) {\nSwingTraderManager.buyMalt()#154:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.buyMalt()#170:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.sellMalt()#208:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.sellMalt()#224:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.costBasis()#269:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.calculateSwingTraderMaltRatio()#300:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.getTokenBalances()#330:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.delegateCapital()#348:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.delegateCapital()#366:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.deployedCapital()#389:    for (uint256 i; i < length; ++i) {\n```\n\nThe code would go from:\n\n```\nfor (uint256 i; i < numIterations; ++i) {  \n // ...  \n}  \n```\n\nto\n\n```\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-01-increments-can-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "16103",
      "title": "[L-09] `priceTarget` seems to be set to wrong value in `_triggerSwingTrader`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L353-L355\n\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L303-L306\n\nIn `StabilizerNode._triggerSwingTrader`, `priceTarget` is set to `icTotal` when `exchangeRate` < `icTotal`.\n\n```solidity\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n```\nIf `icTotal` is slightly greater than `exchangeRate`, `priceTarget` can be `exchangeRate` + dust.\n\nBut in `_shouldAdjustSupply`, `exchangeRate` should be less than some margin of `priceTarget` to proceed actual stabilization.\n\n```solidity\n     return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n```\nSo the `priceTarget` updating logic seems incorrect.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-09-pricetarget-seems-to-be-set-to-wrong-value-in-_triggerswingtrader",
      "tags": [],
      "finders": []
    },
    {
      "id": "16102",
      "title": "[L-08] `swingTraderManager.getTokenBalances` contains inactive swingTrader's balances",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L322-L335\n\n`swingTraderManager.getTokenBalances` doesn't check if swingTrader is active and adds balances regardless of the active status.\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n```\nBut in `buyMalt` and `sellMalt`, they only account for balances of active swing traders. This mismatch might cause wrong calculations where `getTokenBalances` are used.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-08-swingtradermanagergettokenbalances-contains-inactive-swingtraders-balances",
      "tags": [],
      "finders": []
    },
    {
      "id": "16101",
      "title": "[L-07] `_triggerSwingTrader` doesn't try `dexHandler.buyMalt` after `swingTraderManager.buyMalt`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L357-L370\n\n`_triggerSwingTrader` doesn't try `dexHandler.buyMalt` after `swingTraderManager.buyMalt`. If capitalUsed is less than purchaseAmount, we can try `dexHandler.buyMalt` with `purchaseAmount` - `capitalUsed`. But current implementation doesn't try `dexHandler.buyMalt` and it misses possible stabilization.\n\n```solidity\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-07-_triggerswingtrader-doesnt-try-dexhandlerbuymalt-after-swingtradermanagerbuymalt",
      "tags": [],
      "finders": []
    },
    {
      "id": "16100",
      "title": "[L-06] All balance wasn't sent, some dust would be remained in `_sendToDistributor`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L124-L128\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L591-L601\n\nIn `RewardThrottle.handleReward`, `_sendToDistributor` is called for left balance. \n```solidity\n    if (balance > 0) {\n      _sendToDistributor(balance, _activeEpoch);\n    }\n\n    emit HandleReward(epoch, balance);\n```\n\nBut in the implementation of `_sendToDistributor`, balance will be split to distributors.\n\n```solidity\n     uint256 share = (amount * allocations[i]) / 1e18;\n     ...\n     collateralToken.safeTransfer(distributors[i], share);\n```\nSo some dust will remain in `RewardThrottle` and the actual rewarded amount can be slightly less than balance in `handleReward`. And the event amount(=balance) will be slightly larger than actual rewarded amount.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-06-all-balance-wasnt-sent-some-dust-would-be-remained-in-_sendtodistributor",
      "tags": [],
      "finders": []
    },
    {
      "id": "16099",
      "title": "[L-05] `updateDesiredAPR` might revert when `aprFloor` < `maxAdjustment`, so aprFloor(2%) must be greater than maxAdjustment(0.5%)",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L131-L183\n\n\n```solidity\n  function updateDesiredAPR() public onlyActive {\n    ...\n    uint256 newAPR = targetAPR; // gas\n    uint256 adjustmentCap = maxAdjustment; // gas\n    \n    ...\n\n      if (adjustment > adjustmentCap) {\n        adjustment = adjustmentCap;\n      }\n\n      newAPR -= adjustment;\n    }\n\n    uint256 cap = aprCap; // gas\n    uint256 floor = aprFloor; // gas\n    if (newAPR > cap) {\n      newAPR = cap;\n    } else if (newAPR < floor) {\n      newAPR = floor;\n    }\n\n    targetAPR = newAPR;\n    aprLastUpdated = block.timestamp;\n    emit UpdateDesiredAPR(newAPR);\n  }\n```\n\nIf `aprFloor` < `maxAdjustment`, `newAPR` can be `aprFloor` and `adjustment` can be `maxAdjustment`, so \n`newAPR -= adjustment` will revert. So it needs to make sure that `aprFloor` > `maxAdjustment`.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-05-updatedesiredapr-might-revert-when-aprfloor--maxadjustment-so-aprfloor2-must-be-greater-than-maxadjustment05",
      "tags": [],
      "finders": []
    },
    {
      "id": "16098",
      "title": "[L-04] tradeSize will be only 100%, 50%, 33%, ... because of expansionDampingFactor",
      "impact": "LOW",
      "content": "- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L393-L394\n\n\n```solidity\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n```\n\n`tradeSize` will be only 100%, 50%, 33%, ... of minting trade size calculated from `dexHandler`. I think this is intended, but it can be generalized by basis points or 10**18 so it can support other percentages as follows.\n\n```solidity\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) * 10000 / expansionDampingFactorBPS;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-04-tradesize-will-be-only-100-50-33--because-of-expansiondampingfactor",
      "tags": [],
      "finders": []
    },
    {
      "id": "16097",
      "title": "[L-03] `skipAuctionThreshold` < `preferAuctionThreshold` should be checked",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L359-L370\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L437-L439\n\n```solidity\n    if (purchaseAmount > preferAuctionThreshold) {\n        ...\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n```\n```solidity\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n```    \n\n`skipAuctionThreshold` should be less than `preferAuctionThreshold`.\n\nIn `StabilizerNode._triggerSwingTrader`, it starts auction when purchaseAmount <= preferAuctionThreshold.\n\nIf `skipAuctionThreshold` >= `preferAuctionThreshold`, `purchaseAmount` <= `skipAuctionThreshold` always holds.\n\nSo in `_startAuction`, it will never starts an auction and does nothing. So the `stabilize` will not work in this case. It is recommended to check if `skipAuctionThreshold` < `preferAuctionThreshold` when `skipAuctionThreshold` and `preferAuctionThreshold` are set by the admin.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-03-skipauctionthreshold--preferauctionthreshold-should-be-checked",
      "tags": [],
      "finders": []
    },
    {
      "id": "16096",
      "title": "[L-02] `primedBlock` is reset to 0 instead of block.number",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L224\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L321-L326\n\n`primedBlock` is reset to 0 instead of `block.number` in `StabilizerNode.stabilize`. \n```solidity\n    primedBlock = 0; \n```\nIf `primedBlock` = 0, `block.number > primedBlock + primedWindow` holds in most cases and the next caller of `_validateSwingTraderTrigger` will always get default incentive. But this incentive is meaningless.\n```solidity\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n```\nSo it is recommended to reset `primedBlock` to `block.number` instead of 0.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-02-primedblock-is-reset-to-0-instead-of-blocknumber",
      "tags": [],
      "finders": []
    },
    {
      "id": "16095",
      "title": "[L-01] `runwayDays` might be longer than it should be due to possible rounding issue",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L399\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L406\n\n```solidity\n        uint256 epochsPerDay = 86400 / timekeeper.epochLength();\n        ...\n        runwayDays = runwayEpochs / epochsPerDay;\n```\n\nWhen 86400 is not a multiple of `timekeeper.epochLength()`, `runwayDays` might be longer than it should be.\nLet us assume that `timekeeper.epochLength()` = 43201 (about half a day), and `runwayEpochs` = 360 (about 180 days).\n\n`runwayDays` should be `runwayEpochs * timekeeper.epochLength() / 86400` = 180, but in the above implementation, `epochsPerDay` = 1 and `runwayDays` = 360. \n\nIt is recommended to use `runwayDays = runwayEpochs * timekeeper.epochLength() / 86400` directly without the middle variable `epochsPerDay`.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-01-runwaydays-might-be-longer-than-it-should-be-due-to-possible-rounding-issue",
      "tags": [],
      "finders": []
    },
    {
      "id": "16094",
      "title": "[M-16] MaltRepository._revokeRole may not work correctly",
      "impact": "MEDIUM",
      "content": "\nMaltRepository inherits from AccessControl and adds validation of validRoles to the hasRole function, which means that even if super.hasRole(role, account) == true, if validRoles\\[role] == false hasRole will return false, which will cause `\\_revokeRole` to not work correctly.\n\n```solidity\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    // Timelock has all possible permissions\n    return\n      (super.hasRole(role, account) && validRoles[role]) ||\n      super.hasRole(TIMELOCK_ROLE, account);\n  }\n```\n\nConsider the case where Alice is granted ADMIN_ROLE, then ADMIN_ROLE is removed in the removeRole function, validRoles\\[ADMIN_ROLE] == false.\n\n```solidity\n  function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {\n    validRoles[role] = false;\n    emit RemoveRole(role);\n  }\n```\n\nNow if the revokeRole function is called on Alice, in the `\\_revokeRole`, since hasRole returns false, Alice's ADMIN_ROLE will not be revoked.\n\nSince removeRole ends silently, this may actually cause the caller to incorrectly assume that Alice's ADMIN_ROLE has been revoked:\n\n```solidity\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n```\n\nIn addition, the renounceRole and `\\_transferRole` functions will also be affected.\n\nIn particular, the `\\_transferRole` function, if you want to transfer Alice's role to Bob, both Alice and Bob will have the role if validRoles\\[role]==false.\n\n```solidity\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n...\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L99-L102>\n\n### Recommended Mitigation Steps\n\nOverride renounceRole and removeRole in the MaltRepository and modify them as follows:\n\n```diff\n    function renounceRole(bytes32 role, address account) public virtual override {\n+     require(validRoles[role], \"Unknown role\");\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n...\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n+     require(validRoles[role], \"Unknown role\");\n        _revokeRole(role, account);\n    }\n...\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n+  require(validRoles[role], \"Unknown role\");\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/5)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MaltRepository smart contract. The vulnerability is caused by the hasRole function, which is inherited from AccessControl and adds validation of validRoles to the hasRole function. This causes the revokeRole, renounceRole, and _transferRole functions to not work correctly. \n\nThe impact of this vulnerability is that if a user is granted a certain role, then that role is removed in the removeRole function, validRoles[role] will be set to false. When the revokeRole function is called on the user, the user's role will not be revoked since hasRole will return false. This may cause the caller to incorrectly assume that the user's role has been revoked. In addition, the renounceRole and _transferRole functions will also be affected.\n\nThe suggested mitigation steps are to override renounceRole and removeRole in the MaltRepository and modify them to require validRoles[role]. This will ensure that roles are only revoked, renounced, and transferred if validRoles[role] is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/5",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16093",
      "title": "[M-15] LinearDistributor.declareReward: previouslyVested may update incorrectly, which will cause some rewards to be lost",
      "impact": "MEDIUM",
      "content": "\nIn LinearDistributor.declareReward, distributed represents the reward to distribute and is calculated using netVest(currentlyVested - previouslyVested).\n\nAt the same time, distributed cannot exceed balance, which means that `if balance < linearBondedValue /ast netVest / vestingBondedValue`, part of the rewards in netVest will be lost.\n\n```solidity\n    uint256 netVest = currentlyVested - previouslyVested;\n    uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n\n    if (netVest == 0 || vestingBondedValue == 0) {\n      return;\n    }\n\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n    }\n\n```\n\nAt the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution.\n\n```solidity\n    previouslyVested = currentlyVested;\n    previouslyVestedTimestamp = block.timestamp;\n```\n\nAlso, in the next distribution, bufferRequirement will be small because distributed is small, so it may increase the number of forfeits.\n\n        if (netTime < buf) {\n          bufferRequirement = (distributed * buf * 10000) / netTime / 10000;\n        } else {\n          bufferRequirement = distributed;\n        }\n\n        if (balance > bufferRequirement) {\n          // We have more than the buffer required. Forfeit the rest\n          uint256 net = balance - bufferRequirement;\n          _forfeit(net);\n        }\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153>\n\n### Recommended Mitigation Steps\n\nConsider adapting previouslyVested based on distributed:\n\n```diff\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n+    currentlyVested = distributed * vestingBondedValue / linearBondedValue + previouslyVested;\n    }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/6#issuecomment-1447053148):**\n > Finding is correct as stated. I'm not sure how we would ever get into the state required to manifest the bug. Obviously the implementation is incorrect though, so will be fixed.\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the LinearDistributor.declareReward function of the RewardSystem contract. The vulnerability occurs when the reward to distribute, represented by the variable distributed, is calculated using netVest (currentlyVested - previouslyVested). In this case, distributed cannot exceed balance, meaning that if balance is less than linearBondedValue * netVest / vestingBondedValue, part of the rewards in netVest will be lost. \n\nAt the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution. This can lead to a decrease in bufferRequirement, which can increase the number of forfeits. \n\nA proof of concept is provided in the report, as well as a recommended mitigation step. The recommended step is to adapt previouslyVested based on distributed, as shown in the code snippet provided. \n\nOverall, this bug report discusses a vulnerability in the LinearDistributor.declareReward function of the RewardSystem contract, and provides a proof of concept and a recommended mitigation step.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/6",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16092",
      "title": "[M-14] RewardThrottle.populateFromPreviousThrottle may be exposed to front-run attack",
      "impact": "MEDIUM",
      "content": "\nRewardThrottle.populateFromPreviousThrottle allows ADMIN_ROLE to use epochData from previousThrottle to populate state from activeEpoch to epoch in current RewardThrottle.\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nBut since populateFromPreviousThrottle and `\\_fillInEpochGaps` have basically the same function, a malicious user can call fillInEpochGaps to front-run populateFromPreviousThrottle.\n\n```solidity\n  function _fillInEpochGaps(uint256 epoch) internal {\n    uint256 epochsPerYear = timekeeper.epochsPerYear();\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch);\n    state[_activeEpoch].epochsPerYear = epochsPerYear;\n    state[_activeEpoch].desiredAPR = targetAPR;\n\n    if (_activeEpoch > 0) {\n      state[_activeEpoch].cumulativeCashflowApr =\n        state[_activeEpoch - 1].cumulativeCashflowApr +\n        epochCashflowAPR(_activeEpoch - 1);\n      state[_activeEpoch].cumulativeApr =\n        state[_activeEpoch - 1].cumulativeApr +\n        epochAPR(_activeEpoch - 1);\n    }\n\n    // Avoid issues if gap between rewards is greater than one epoch\n    for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {\n      if (!state[i].active) {\n        state[i].bondedValue = bonding.averageBondedValue(i);\n        state[i].profit = 0;\n        state[i].rewarded = 0;\n        state[i].epochsPerYear = epochsPerYear;\n        state[i].desiredAPR = targetAPR;\n        state[i].cumulativeCashflowApr =\n          state[i - 1].cumulativeCashflowApr +\n          epochCashflowAPR(i - 1);\n        state[i].cumulativeApr = state[i - 1].cumulativeApr + epochAPR(i - 1);\n        state[i].active = true;\n      }\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nThe only difference is that it seems that populateFromPreviousThrottle can make epoch and activeEpoch greater than `timekeeper.epoch()`, thereby updating the state for future epochs, but `\\_fillInEpochGaps` makes `activeEpoch = timekeeper.epoch()`, thereby invalidating populateFromPreviousThrottle for future updates. (This usage should be very unlikely).\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688>\n\n### Recommended Mitigation Steps\n\nIf populateFromPreviousThrottle is used to initialize the state in the current RewardThrottle, it should be called on contract setup.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/8#issuecomment-1447048647):**\n > As per [#20](https://github.com/code-423n4/2023-02-malt-findings/issues/20), we will be removing the `fillInEpochGaps` method.\n\n***\n\n",
      "summary": "\nA bug report has been submitted for the RewardThrottle.sol contract in the RewardSystem found on the GitHub repository code-423n4/2023-02-malt. The bug is that the function populateFromPreviousThrottle allows the ADMIN_ROLE to use epochData from a previousThrottle to populate the state from activeEpoch to epoch in the current RewardThrottle. However, a malicious user can call the fillInEpochGaps function to front-run populateFromPreviousThrottle, invalidating it for future updates. This bug is demonstrated in the code provided in the report.\n\nThe impact of this bug is that the malicious user can front-run populateFromPreviousThrottle and invalidate it for future updates.\n\nNo tools were used to identify this bug.\n\nThe recommended mitigation step to avoid this bug is to call populateFromPreviousThrottle on contract setup if it is being used to initialize the state in the current RewardThrottle.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/8",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16091",
      "title": "[M-13] Function `stabilize()` might always revert because of overflow since Malt contract use solidity 0.8",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L326>\n\n### Impact\n\nMaltDataLab fetched `priceCumulative` directly from Uniswap V2 pool to calculate price of Malt token. However, it is noticed that Uniswap V2 pool use Solidity 0.5.16, which does not revert when overflow happen. In addition, it is actually commented in Uniswap code that\n\n> *   never overflows, and + overflow is desired\n\n<https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L77-L81>\n\n```solidity\nif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n    // * never overflows, and + overflow is desired\n    price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n    price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n}\n```\n\nHowever, MaltDataLab contracts use Solidity 0.8 and will revert when overflow. It will break the `stabilize()` function and always revert since `stabilize()` call to MaltDataLab contract to get state.\n\nPlease note that, with Solidity 0.5.16, when result of addition bigger than `max(uint256)`, it will overflow without any errors. For example, `max(uint256) + 2 = 1`.\n\nSo when `price0CumulativeLast` is overflow, the new value of `price0CumulativeLast` will be smaller than old value. As the result, when MaltDataLab doing a subtraction to calculate current price, it might get revert.\n\n### Proof of Concept\n\nFunction `stabilize()` will call to `MaltDataLab.trackPool()` first:\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L163>\n\n```solidity\nfunction stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n    ...\n}\n```\n\nFunction `trackPool()` used a formula that will revert when `priceCumulative` overflow in Uniswap pool. \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L323-L329>\n\n```solidity\nprice = FixedPoint\n    .uq112x112(\n      uint224(  \n        // @audit might overflow with solidity 0.8.0\n        (priceCumulative - maltPriceCumulativeLast) / \n          (blockTimestampLast - maltPriceTimestampLast)\n      )\n    )\n```\n\nScenario:\n\n1.  `maltPriceCumulativeLast = max(uint256 - 10)` and `price = 10, timeElapsed = 10`. So the new `priceCumulative = max(uint256 - 10) + 10 * 10 = 99 (overflow)`\n\n2.  When doing calculation in Malt protocol, `priceCumulative < maltPriceCumulativeLast`, so `priceCumulative - maltPriceCumulativeLast` will revert and fail\n\n### Recommended Mitigation Steps\n\nConsider using `unchecked` block to match handle overflow calculation in Uniswap V2.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/15)**\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the Malt Protocol, which is a decentralized, autonomous, and self-governed platform that provides users with a stable digital asset. The issue is related to overflow when calculating the price of the Malt token.\n\nThe Malt Protocol is built on two contracts, StabilizerNode and MaltDataLab. The StabilizerNode contract calls the MaltDataLab contract to get the state of the token price. The MaltDataLab contract fetches the priceCumulative value directly from the Uniswap V2 pool to calculate the price of Malt token.\n\nHowever, Uniswap V2 pool uses Solidity 0.5.16, which does not revert when an overflow occurs. The MaltDataLab contract, on the other hand, uses Solidity 0.8 and will revert when an overflow occurs. This will break the stabilize() function and always revert since stabilize() calls the MaltDataLab contract to get the state.\n\nThe proof of concept for this issue is that when the priceCumulative value is overflowed, the new value of the priceCumulative will be smaller than the old value. This will cause the subtraction in the MaltDataLab contract to get the current price to revert and fail.\n\nThe recommended mitigation step is to use an unchecked block to handle overflow calculations in the Uniswap V2 pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/15",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "16090",
      "title": "[M-12] Value of `totalProfit` might be wrong because of wrong logic in function `sellMalt()`",
      "impact": "MEDIUM",
      "content": "\nContract `SwingTraderManager` has a `totalProfit` variable. It keeps track of total profit swing traders made during `sellMalt()`. However, the logic for accounting is wrong so it will not have the correct value. As the results, it can affect other contracts that integrate with `SwingTraderManager` and use this `totalProfit` variable.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L258>\n\n```solidity\nif (amountSold + dustThreshold >= maxAmount) {\n  return maxAmount;\n}\n\ntotalProfit += profit; \n// @audit did not update because already return above\n\nemit SellMalt(amountSold, profit);\n```\n\nFunction `sellMalt()` has a dust check before returning result. `totalProfit` should be updated before this check as it returns the value immediately without updating `totalProfit`.\n\n### Recommended Mitigation Steps\n\nUpdating `totalProfit` before the dust check in function `sellMalt()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/16)**\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `SwingTraderManager` contract, which keeps track of total profits made by swing traders. The logic for accounting for this value is incorrect, which can affect other contracts that integrate with `SwingTraderManager` and use the `totalProfit` variable. The proof of concept can be found at the given link. The issue was discovered through manual review, and the recommended mitigation step is to update `totalProfit` before the dust check in the `sellMalt()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/16",
      "tags": [],
      "finders": [
        "minhquanym",
        "cccz  hansfriese"
      ]
    },
    {
      "id": "16089",
      "title": "[M-11] RewardThrottle.setTimekeeper: If changing the timekeeper causes the epoch to change, it will mess up the system",
      "impact": "MEDIUM",
      "content": "\nRewardThrottle.setTimekeeper allows POOL_UPDATER_ROLE to update the timekeeper when RewardThrottle is active:\n\n```solidity\n  function setTimekeeper(address _timekeeper)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_timekeeper != address(0), \"Not address 0\");\n    timekeeper = ITimekeeper(_timekeeper);\n  }\n```\n\nif newTimekeeper.epoch changes, it will cause the following:\n\n1.  The newTimekeeper.epoch increases, and the user can immediately call checkRewardUnderflow to fill the gap epoch, thereby distributing a large amount of rewards.\n2.  The newTimekeeper.epoch decreases, and the contract will use the state of the previous epoch. Since the state.rewarded has reached the upper limit, this will cause the current epoch to be unable to receive rewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696>\n\n### Recommended Mitigation Steps\n\nConsider only allowing setTimekeeper to be called when RewardThrottle is not active.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/21#issuecomment-1447036522):**\n > This is a good find and I think we will just remove the `setTimekeeper` methods. There is no reason for the timekeeper to ever be updated at this point given all it does it track epochs. \n> \n> Historically this method was there because what we now call the timekeeper was called the `MaltDAO` and was earmarked to be used for many other things other than timekeeping. Eventually we realised the timekeeping should be separated into its own thing. These methods were clearly forgotten about and not removed.\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the RewardThrottle.setTimekeeper function in the RewardThrottle.sol contract. This function is used to update the timekeeper when the RewardThrottle is active. If the newTimekeeper.epoch changes, it can cause unexpected results. If the newTimekeeper.epoch increases, the user may be able to call checkRewardUnderflow to fill the gap epoch and distribute a large amount of rewards. If the newTimekeeper.epoch decreases, the contract will use the state of the previous epoch, which may prevent the current epoch from receiving rewards.\n\nTo mitigate this issue, it is recommended that setTimekeeper only be called when RewardThrottle is not active.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/21",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16088",
      "title": "[M-10] StabilizerNode.stabilize may use undistributed rewards in the overflowPool as collateral",
      "impact": "MEDIUM",
      "content": "\nIn StabilizerNode.stabilize, `globalIC.collateralRatio()` is used to calculate SwingTraderEntryPrice and ActualPriceTarget, with collateralRatio indicating the ratio of the current global collateral to the malt supply.\n\n```solidity\n  function collateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n    if (totalSupply == 0) {\n      return 0;\n    }\n    return (collateral.total * (10**decimals)) / totalSupply;\n  }\n```\n\nGlobal collateral includes the balance of collateral tokens in the overflowPool:\n\n```solidity\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget(); // 是否选用  getActualPriceTarget()\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n\n    return\n      PoolCollateral({\n        lpPool: address(stakeToken),\n        // Note that swingTraderBalance also includes the overflowBalance\n        // Therefore the total doesn't need to include overflowBalance explicitly\n        total: maltDataLab.rewardToMaltDecimals(\n            liquidityExtensionBalance + swingTraderBalance\n        ),\n```\n\nIn StabilizerNode.stabilize, since the undistributed rewards in the overflowPool are not distributed, this can cause the actual collateral ratio to be large and thus affect the stabilize process.\n\nA simple example is:\n\n1.  `impliedCollateralService.syncGlobalCollateral()` is called to synchronize the latest data.\n2.  There are some gap epochs in RewardThrottle and their rewards are not distributed from the overflowPool.\n3.  When StabilizerNode.stabilize is called, it treats the undistributed rewards in the overflowPool as collateral, thus making `globalIC.collateralRatio()` large, and the results of maltDataLab. getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.\n\nSince stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L176>\n\n### Recommended Mitigation Steps\n\nCall RewardThrottle.checkRewardUnderflow at the beginning of StabilizerNode.stabilize to distribute the rewards in the overflowPool, then call `impliedCollateralService.syncGlobalCollateral()` to synchronize the latest data.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  RewardThrottle.checkRewardUnderflow();\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n```\n\n**[0xScotch (Malt) disagreed with severity and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/22#issuecomment-1447033033):**\n > By a strict implementation of the protocol this is a bug as it would result in global collateral being slightly misreported and therefore downstream decisions being made on incorrect data. However, in practice, the chances of a big gap in epochs is very low due to the incentivization to upkeep that as well as the degree to which the global IC would be incorrect would be very small. It seems very unlikely this bug would ever lead to a depeg as stated.\n> \n> Let's say 50% of the Malt float is in staked LP and the current APR is 10%. We go for 48 epochs (24 hours) without any call to `checkRewardUnderflow`. This means the global IC will be misreported by 24 hours of APR (10%). \n> \n> The current APR is 10% and 50% of float is staked, therefore the yearly rewards represent 5% of the total float. One day worth of that is 5% / 365 = 0.013%.\n> \n> Therefore we can say that under the above stated circumstances the global IC would be misquoted by 0.02%. Seems very unlikely that discrepancy would be the cause of a depeg.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/22#issuecomment-1455167697):**\n > Downgrading to Medium as it indeed seems that the reporting error would remain low and it is unlikely that this could lead to a depeg.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode.stabilize function of the StabilityPod contract. The vulnerability occurs when globalIC.collateralRatio() is used to calculate SwingTraderEntryPrice and ActualPriceTarget, with collateralRatio indicating the ratio of the current global collateral to the malt supply. Global collateral includes the balance of collateral tokens in the overflowPool, which is not distributed. This can cause the actual collateral radio to be large and thus affect the stabilize process, potentially leading to malt being depegged.\n\nA proof of concept can be found at the given link.\n\nThe recommended mitigation steps are to call RewardThrottle.checkRewardUnderflow at the beginning of StabilizerNode.stabilize to distribute the rewards in the overflowPool, then call impliedCollateralService.syncGlobalCollateral() to synchronize the latest data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/22",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16087",
      "title": "[M-09] `Repository._removeContract()` removes the contract wrongly.",
      "impact": "MEDIUM",
      "content": "\nAfter removing the contract, the `contracts` array would contain the wrong contract names.\n\n### Proof of Concept\n\n`Repository._removeContract()` removes the contract name from `contracts` array.\n\n```solidity\nFile: 2023-02-malt\\contracts\\Repository.sol\n223:   function _removeContract(string memory _name) internal {\n224:     bytes32 hashedName = keccak256(abi.encodePacked(_name));\n225:     Contract storage currentContract = globalContracts[hashedName];\n226:     currentContract.contractAddress = address(0);\n227:     currentContract.index = 0;\n228: \n229:     uint256 index = currentContract.index; //@audit wrong index\n230:     string memory lastContract = contracts[contracts.length - 1];\n231:     contracts[index] = lastContract;\n232:     contracts.pop();\n233:     emit RemoveContract(hashedName);\n234:   }\n```\n\nBut it uses the already changed index(= 0) and replaces the last name with 0 index all the time.\n\nAs a result, the contracts array will still contain the removed name and remove the valid name at index 0.\n\n### Recommended Mitigation Steps\n\nWe should use the original index like below.\n\n```solidity\n  function _removeContract(string memory _name) internal {\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n\n    uint256 index = currentContract.index; //++++++++++++++\n\n    currentContract.contractAddress = address(0);\n    currentContract.index = 0;\n\n    string memory lastContract = contracts[contracts.length - 1];\n    contracts[index] = lastContract;\n    contracts.pop();\n    emit RemoveContract(hashedName);\n  }\n```\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/25)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Repository._removeContract()` function in the `Repository.sol` file. The function is responsible for removing a contract name from the `contracts` array. The bug is that the function uses the already changed index (which is 0) and replaces the last name with 0 index all the time. As a result, the contracts array will still contain the removed name and remove the valid name at index 0. The impact of this bug is that after removing the contract, the `contracts` array would contain the wrong contract names.\n\nThe bug was identified using manual review. The recommended mitigation steps are to use the original index in the `_removeContract()` function. The code for this is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/25",
      "tags": [],
      "finders": [
        "KingNFT",
        "hansfriese"
      ]
    },
    {
      "id": "16086",
      "title": "[M-08] `LinearDistributor.declareReward()` might revert after changing `vestingDistributor`.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L114> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L227>\n\n### Impact\n\n`LinearDistributor.declareReward()` might revert after changing `vestingDistributor` due to uint underflow.\n\n### Proof of Concept\n\nIn `LinearDistributor.sol`, there is a [setVestingDistributor()](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L222-L228) function to update `vestingDistributor`.\n\nAnd in `declareReward()`, it calculates the `netVest` and `netTime` by subtracting the previous amount and time.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol\n112:     uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n113: \n114:     uint256 netVest = currentlyVested - previouslyVested; //@audit revert after change vestingDistributor\n115:     uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n116: \n```\n\nBut there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.\n\nFurthermore, there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor.\n\n### Recommended Mitigation Steps\n\nI think it would resolve the above problem if we change the previous amounts as well while updating the distributor.\n\n```solidity\n  function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    previouslyVested = _previouslyVested;\n    previouslyVestedTimestamp = _previouslyVestedTimestamp;\n  }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/28#issuecomment-1447006469):**\n > Setting `previouslyVested` during the `setVestingDistributor` call seems like a sufficient solution to this.\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on the `LinearDistributor.declareReward()` function in the `LinearDistributor.sol` file of the 2023-02-malt repository on GitHub. The function might revert after changing `vestingDistributor` due to uint underflow. This occurs because the `declareReward()` function calculates the `netVest` and `netTime` by subtracting the previous amount and time, but there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.\n\nThe impact of this bug is that there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor. This was discovered through a manual review.\n\nThe recommended mitigation step is to change the previous amounts as well while updating the distributor. This can be done by adding the following code to the `setVestingDistributor()` function:\n\n```solidity\n  function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    previouslyVested = _previouslyVested;\n    previouslyVestedTimestamp = _previouslyVestedTimestamp;\n  }\n```\n\nBy implementing this code, the bug can be resolved and the `declareReward()` function will no longer revert.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/28",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16085",
      "title": "[M-07] `RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L602> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L101>\n\n### Impact\n\n`RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.\n\n### Proof of Concept\n\n`RewardThrottle._sendToDistributor()` distributes the rewards to several distributors according to their allocation ratios.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n576:     if (amount == 0) {\n577:       return;\n578:     }\n579: \n580:     (\n581:       uint256[] memory poolIds,\n582:       uint256[] memory allocations,\n583:       address[] memory distributors\n584:     ) = bonding.poolAllocations();\n585: \n586:     uint256 length = poolIds.length;ratio\n587:     uint256 balance = collateralToken.balanceOf(address(this));\n588:     uint256 rewarded;\n589: \n590:     for (uint256 i; i < length; ++i) {\n591:       uint256 share = (amount * allocations[i]) / 1e18;\n592: \n593:       if (share == 0) {\n594:         continue;\n595:       }\n596: \n597:       if (share > balance) {\n598:         share = balance;\n599:       }\n600: \n601:       collateralToken.safeTransfer(distributors[i], share);\n602:       IDistributor(distributors[i]).declareReward(share); //@audit will revert if one distributor is inactive\n```\n\nAnd `LinearDistributor.declareReward()` has an `onlyActive` modifier and it will revert in case of `inactive`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol\n098:   function declareReward(uint256 amount)\n099:     external\n100:     onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")\n101:     onlyActive\n102:   {\n```\n\nAs a result, `RewardThrottle._sendToDistributor()` will revert if one distributor is inactive rather than working with active distributors only.\n\n### Recommended Mitigation Steps\n\nI think it's logical to continue to work with active distributors in `_sendToDistributor()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/29)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `RewardThrottle._sendToDistributor()` function in the code-423n4/2023-02-malt repository, which is used to distribute rewards to several distributors according to their allocation ratios. The issue is that this function will revert if one of the distributors is inactive, rather than working with active distributors only. This was discovered through manual review.\n\nThe recommended mitigation step is to ensure that `_sendToDistributor()` only works with active distributors. This can be done by adding the `onlyActive` modifier to the `LinearDistributor.declareReward()` function, which will ensure that the function only works with active distributors.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/29",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16084",
      "title": "[M-06] Average `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()`.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L660> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L139>\n\n### Impact\n\nAverage `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()` and `targetAPR` might be changed unexpectedly.\n\n### Proof of Concept\n\nThe epoch state struct contains `cumulativeCashflowApr` element and `cashflowAverageApr` is used to adjust `targetAPR` in `updateDesiredAPR()` function.\n\nAnd `populateFromPreviousThrottle()` is an admin function to change `activeEpoch` and the relevant epoch state using the previous throttle.\n\nAnd the `activeEpoch` is likely to be increased inside this function.\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nThe problem might occur when `epoch < _activeEpoch + smoothingPeriod` because `state[epoch].cumulativeCashflowApr`and `state[epoch - smoothingPeriod].cumulativeCashflowApr` will be used for `cashflowAverageApr` calculation.\n\nSo `cumulativeCashflowApr` of the original epoch and the newly added epoch will be used together and `cashflowAverageApr` might be calculated wrongly.\n\nAs a result, `targetAPR` might be changed unexpectedly.\n\n### Recommended Mitigation Steps\n\nRecommend checking `epoch - _activeEpoch > smoothingPeriod` in `populateFromPreviousThrottle()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/30)**\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the RewardThrottle.sol contract of the 2023-02-malt repository on GitHub. The vulnerability could cause the Average Annual Percentage Rate (APR) to be calculated incorrectly and the target APR to be changed unexpectedly after calling the populateFromPreviousThrottle() function.\n\nThe issue is caused by the incorrect use of the cumulativeCashflowApr element in the epoch state struct. In the populateFromPreviousThrottle() function, the cumulativeCashflowApr of the original epoch and the newly added epoch are used together to calculate the cashflowAverageApr. If the epoch is less than _activeEpoch + smoothingPeriod, the calculation will be incorrect and the target APR will be changed unexpectedly.\n\nThe bug was found through manual review. The recommended mitigation step is to check that epoch - _activeEpoch > smoothingPeriod in the populateFromPreviousThrottle() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/30",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16083",
      "title": "[M-05] `StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.",
      "impact": "MEDIUM",
      "content": "\n`StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.\n\nCurrent logic pays unnecessary incentives to track the pool.\n\n### Proof of Concept\n\n`trackPool()` pays an incentive per `trackingBackoff` in order to ensure pool consistency.\n\n```solidity\nFile: 2023-02-malt\\contracts\\StabilityPod\\StabilizerNode.sol\n248:   function trackPool() external onlyActive {\n249:     require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\"); //@audit lastTracking should be updated in stabilize() also\n250:     bool success = maltDataLab.trackPool();\n251:     require(success, \"Too early\");\n252:     malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n253:     lastTracking = block.timestamp;\n254:     emit Tracking();\n255:   }\n```\n\nAnd `stabilize()` tracks the pool as well and we don't need to pay an incentive unnecessarily in `trackPool()` if `stabilize()` was called recently.\n\nFor that, we can update `lastTracking` in `stabilize()`.\n\n### Recommended Mitigation Steps\n\nRecommend updating `lastTracking` in `stabilize()`.\n\n```solidity\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n    lastTracking = block.timestamp; //++++++++++++++++\n\n    ...\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/32)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code for the StabilizerNode contract in the 2023-02-malt repository on Github. The vulnerability is that the contract pays an unnecessary incentive to track the pool, as the current logic does not update the 'lastTracking' variable. The proof of concept provided in the report shows that the 'trackPool' function pays an incentive per 'trackingBackoff' in order to ensure pool consistency, but 'stabilize' also tracks the pool and the incentive should not be paid if 'stabilize' was called recently. The tools used for the manual review were manual review. The recommended mitigation step is to update the 'lastTracking' variable in the 'stabilize' function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/32",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16082",
      "title": "[M-04] `SwingTraderManager.swingTraders()` shoudn't contain duplicate `traderContract`s.",
      "impact": "MEDIUM",
      "content": "\nIf `SwingTraderManager.swingTraders()` contains duplicate `traderContract`s, several functions like `buyMalt()` and `sellMalt()` wouldn't work as expected as they work according to traders' balances.\n\n### Proof of Concept\n\nDuring the swing trader addition, there is no validation that each trader should have a unique `traderContract`.\n\n```solidity\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader, //@audit should be unique\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\nSo the same `traderContract` might have 2 or more `traderId`s.\n\nWhen we check `buyMalt()` as an example, it distributes the ratio according to the trader balance and it wouldn't work properly if one trader contract is counted twice and receives more shares that it can't manage.\n\nSimilarly, other functions wouldn't work as expected and return the wrong result.\n\n### Recommended Mitigation Steps\n\nRecommend adding a new mapping like `activeTraderContracts` to check if the contract is added already or not.\n\nThen we can check the trader contract is added only once.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/34)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the StabilityPod/SwingTraderManager.sol file. The vulnerability is that the code does not validate that each trader should have a unique traderContract, which can lead to several functions like buyMalt() and sellMalt() not working as expected. This is because the functions work according to traders' balances, and if a traderContract is duplicated, it will receive more shares than it can manage. The bug was identified through manual review. To mitigate the issue, it is recommended to add a new mapping, such as activeTraderContracts, to check if the contract has already been added. This would ensure that the same traderContract can only be added once.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/34",
      "tags": [],
      "finders": [
        "minhquanym",
        "hansfriese"
      ]
    },
    {
      "id": "16081",
      "title": "[M-03] `LinearDistributor.declareReward` can revert due to dependency of balance",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L147-L151> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L185-L186> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L123-L136>\n\n### Impact\n\n`LinearDistributor.declareReward` will revert and it can cause permanent DOS.\n\n### Proof of Concept\n\nIn `LinearDistributor.declareReward`, if the balance is greater than the bufferRequirement, the rest will be forfeited.\n\n        if (balance > bufferRequirement) {\n          // We have more than the buffer required. Forfeit the rest\n          uint256 net = balance - bufferRequirement;\n          _forfeit(net);\n        }\n\nAnd in `_forfeit`, it requires forfeited (= balance - bufferRequirement) <= declaredBalance.\n\n      function _forfeit(uint256 forfeited) internal {\n        require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n\nSo when an attacker sends some collateral tokens to `LinearDistributor`, the balance will be increased and it can cause revert in `_forfeit` and `declareReward`.\n\nSince `declareReward` sends vested amount before `_forfeit` and the vested amount will be increased by time, so this DOS will be temporary.\n\n        uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n        uint256 balance = collateralToken.balanceOf(address(this));\n\n        if (distributed > balance) {\n          distributed = balance;\n        } \n\n        if (distributed > 0) {\n          // Send vested amount to liquidity mine\n          collateralToken.safeTransfer(address(rewardMine), distributed);\n          rewardMine.releaseReward(distributed);\n        }\n\n        balance = collateralToken.balanceOf(address(this));\n\nBut if the attacker increases the balance enough to cover all reward amount in vesting, `declareReward` will always revert and it can cause permanent DOS.\n\n`decrementRewards` updates `declaredBalance`, but it only decreases `declaredBalance`, so it can't mitigate the DOS.\n\n### Recommended Mitigation Steps\n\nTrack collateral token balance and add sweep logic for unused collateral tokens in `LinearDistributor`.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/35#issuecomment-1443598496):**\n > As this is a DOS scenario where funds are not at risk and the chances that rewards are lost forever are low, downgrading to Medium.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/35#issuecomment-1446998892):**\n > I agree this is a DOS vector but a continued attack would require the attacker to spend more and more capital. Should be fixed but doesn't pose any risk of material loss.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LinearDistributor contract of the RewardSystem. It can cause a permanent Denial of Service (DOS) attack. The attack works by sending some collateral tokens to the LinearDistributor contract which increases the balance, and then calling the declareReward function. This will cause a revert in the _forfeit function, as the balance is greater than the bufferRequirement. The _forfeit function requires that the amount forfeited is less than or equal to the declaredBalance. Since the declareReward function sends vested amount before calling the _forfeit function, and the vested amount will increase over time, this DOS attack will be temporary. However, if the attacker increases the balance enough to cover all reward amount in vesting, the declareReward function will always revert and cause a permanent DOS. The decrementRewards function updates the declaredBalance, but it only decreases it, so it can't mitigate the DOS.\n\nThe recommended mitigation step is to track the collateral token balance and add a sweep logic for unused collateral tokens in the LinearDistributor contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/35",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16080",
      "title": "[M-02] The latest malt price can be less than the actual price target and `StabilizerNode.stabilize` will revert",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L201-L203>\n\n### Impact\n\n`StabilizerNode.stabilize` will revert when `latestSample < priceTarget`.\n\n### Proof of Concept\n\nIn StabilizerNode.stabilize, when `exchangeRate > priceTarget` and `_msgSender` is not an admin and not whitelisted, it asserts `livePrice > minThreshold`.\n\nAnd `minThreshold` is calculated as follows:\n\n        uint256 priceTarget = maltDataLab.getActualPriceTarget();\n\n<!---->\n\n            uint256 latestSample = maltDataLab.maltPriceAverage(0);\n            uint256 minThreshold = latestSample -\n              (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\nThis code snippet assumes that `latestSample >= priceTarget`. Although `exchangeRate > priceTarget`, `exchangeRate` is the malt average price during `priceAveragePeriod`. But `latestSample` is one of those malt prices. So `latestSample` can be less than `exchangeRate` and `priceTarget`, so `stabilize` will revert in this case.\n\n### Recommended Mitigation Steps\n\nUse `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/36#issuecomment-1446996158):**\n > We actually do want the tx to revert when `latestSample < priceTarget` as that means the most recent sample in the price average feed is below peg but we are in the above peg stabilization flow in the code. However, we do not want the revert to be subtraction overflow as that looks like something went wrong. So we should handle with an explicit error.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the code of the StabilizerNode contract, which is part of the StabilityPod project. The code snippet assumes that the latest sample of malt prices is greater than or equal to the price target. However, if the exchange rate is greater than the price target and the sender of the message is not an admin or whitelisted, it will assert that the live price is greater than the minThreshold. The minThreshold is calculated by subtracting the difference between the latest sample and the price target from the latest sample. This could cause the `stabilize` function to revert if the latest sample is less than the price target.\n\nThe bug was found using manual review. To mitigate this issue, the code should use `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/36",
      "tags": [],
      "finders": [
        "minhquanym",
        "hansfriese"
      ]
    },
    {
      "id": "16079",
      "title": "[M-01] `priceTarget` is inconsistent in `StabilizerNode.stabilize`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L178-L182> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L294-L298> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188>\n\n### Impact\n\n`priceTarget` is inconsistent in `StabilizerNode.stabilize` so `stabilize` can do auction instead of selling malt and vice versa.\n\n### Proof of Concept\n\nIn `StabilizerNode.stabilize`, there is an early check using `_shouldAdjustSupply` function.\n\n        if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n          lastStabilize = block.timestamp;\n          impliedCollateralService.syncGlobalCollateral();\n          return;\n        }\n\nIn `_shouldAdjustSupply`, `priceTarget` is calculated by `stabilizeToPeg` and then check if `exchangeRate` is outside of some margin of `priceTarget`.\n\n        if (stabilizeToPeg) {\n          priceTarget = maltDataLab.priceTarget();\n        } else {\n          priceTarget = maltDataLab.getActualPriceTarget();\n        }\n\nBut in `stabilize`, `priceTarget` is always actual price target of `maltDataLab` regardless of `stabilizeToPeg`.\nAnd it decides selling malt or doing auction by the `priceTarget`. So when `stabilizeToPeg` is true, `priceTarget` (= actual price target) can be different from `maltDataLab.priceTarget()` in most cases, and it can cause wrong decision of selling or starting auction after that.\n\n        uint256 priceTarget = maltDataLab.getActualPriceTarget();\n\nSo when `stabilizeToPeg` is true, `stabilize` can do auction instead of selling malt, or vice versa.\n\n### Recommended Mitigation Steps\n\nUse same logic as `_shouldAdjustSupply` for `priceTarget`. `priceTarget` should be `maltDataLab.priceTarget()` in `stabilize` when `stabilizeToPeg` is true.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/40)**\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the code of the StabilityPod/StabilizerNode.sol contract. When the \"stabilizeToPeg\" parameter is set to true, the \"priceTarget\" variable is always set to the actual price target of the maltDataLab, regardless of what the maltDataLab.priceTarget() is. This can lead to incorrect decisions being made by the contract, such as doing an auction instead of selling malt, or vice versa. The recommended mitigation step is to use the same logic as the \"_shouldAdjustSupply\" function for the \"priceTarget\" variable, and to set it to maltDataLab.priceTarget() when \"stabilizeToPeg\" is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/40",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16078",
      "title": "[H-06] StabilizerNode.stabilize uses stale GlobalImpliedCollateralService data, which will make stabilize incorrect",
      "impact": "HIGH",
      "content": "\nIn StabilizerNode.stabilize, `impliedCollateralService.syncGlobalCollateral()` is called only at the end of the function to synchronize the GlobalImpliedCollateralService data.\n\n```solidity\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n...\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n```\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n```solidity\n  function syncGlobalCollateral() public onlyActive {\n    globalIC.sync(getCollateralizedMalt());\n  }\n...\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget();\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n```\n\nSince StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will use `GlobalImpliedCollateralService.collateralRatio`, to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest.\n\n```solidity\n  function getActualPriceTarget() external view returns (uint256) {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n...\n  function getSwingTraderEntryPrice()\n    external\n    view\n    returns (uint256 stEntryPrice)\n  {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n```\n\nBut since `impliedCollateralService.syncGlobalCollateral()` is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.\n\nA simple example would be:\n\n1.  `impliedCollateralService.syncGlobalCollateral()` is called to synchronize the latest data\n2.  SwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make the `GlobalImpliedCollateralService.collateralRatio` larger than the actual collateralRatio.\n\n```solidity\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    collateralToken.safeTransfer(destination, amount);\n    emit Delegation(amount, destination, msg.sender);\n  }\n...\n  function collateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n    if (totalSupply == 0) {\n      return 0;\n    }\n    return (collateral.total * (10**decimals)) / totalSupply; // @audit: collateral.total is larger than the actual\n  }\n```\n\n3.  When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.\n\nSince stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131>\n\n### Recommended Mitigation Steps\n\nCall `impliedCollateralService.syncGlobalCollateral()` before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode contract of the 2023-02-malt project on Github. The vulnerability is caused by the fact that the syncGlobalCollateral() function is called only at the end of the stabilize() function, which means that the GlobalImpliedCollateralService data used in stabilize() may not be the latest. This could lead to incorrect stabilization, which could cause malt to be depegged.\n\nThe proof of concept for this vulnerability is provided in the Github repository, and no tools are required. The recommended mitigation step is to call impliedCollateralService.syncGlobalCollateral() before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget. This would ensure that the latest data is used in the stabilization process.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/9",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16077",
      "title": "[H-05] `_distributeProfit` will use the stale `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()`, which will result in incorrect profit distribution",
      "impact": "HIGH",
      "content": "\nThe `\\_distributeProfit()` (called by handleProfit()) will use `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` when distributing profits, and the latest `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` needs to be used to ensure that profits are distributed correctly.\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n```\n\nHowever, the two calls to handleProfit in the contract do not call syncGlobalCollateral to synchronize the data in globalIC.\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, including the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n      function syncGlobalCollateral() public onlyActive {\n        globalIC.sync(getCollateralizedMalt());\n      }\n\n      function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n        uint256 target = maltDataLab.priceTarget(); // 是否选用  getActualPriceTarget()\n\n        uint256 unity = 10**collateralToken.decimals();\n\n        // Convert all balances to be denominated in units of Malt target price\n        uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n          address(overflowPool)\n        ) * unity) / target);\n        uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n          address(liquidityExtension)\n        ) * unity) / target;\n        (\n          uint256 swingTraderMaltBalance,\n          uint256 swingTraderBalance\n        ) = swingTraderManager.getTokenBalances();\n        swingTraderBalance = (swingTraderBalance * unity) / target;\n\n1.  Before handleProfit is called by StabilizerNode.stabilize.\n\n```solidity\n    profitDistributor.handleProfit(rewards);\n```\n\na. checkAuctionFinalization is called to liquidityExtension.allocateBurnBudget, which transfers the collateralToken from liquidityExtension to swingTrader. The increase of collateralToken in swingTrader will make the data in globalIC stale.\n\n```solidity\nfunction allocateBurnBudget(uint256 amount)\n    external\n    onlyRoleMalt(AUCTION_ROLE, \"Must have auction privs\")\n    onlyActive\n    returns (uint256 purchased)\n  {\n    // Send the burnable amount to the swing trader so it can be used to burn more malt if required\n    require(\n      collateralToken.balanceOf(address(this)) >= amount,\n      \"LE: Insufficient balance\"\n    );\n    collateralToken.safeTransfer(address(swingTrader), amount);\n\n    emit AllocateBurnBudget(amount);\n  }\n```\n\nb. swingTraderManager.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n```\n\n2.  Before SwingTrader.sellMalt is called to handleProfit.\n\n```solidity\n  function _handleProfitDistribution(uint256 profit) internal virtual {\n    if (profit != 0) {\n      collateralToken.safeTransfer(address(profitDistributor), profit);\n      profitDistributor.handleProfit(profit);\n    }\n  }\n```\n\na. dexHandler.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    malt.safeTransfer(address(dexHandler), maxAmount);\n    uint256 rewards = dexHandler.sellMalt(maxAmount, 10000);\n\n```\n\nOne obvious effect is that as the collateralToken in swingTrader increases, collateral.swingTrade will be smaller than it actually is, and the result of `globalIC.swingTraderCollateralDeficit()` will be larger than it should be.\n\n```solidity\n  function swingTraderCollateralDeficit() public view returns (uint256) {\n    // Note that collateral.swingTrader is already denominated in malt.decimals()\n    uint256 maltSupply = malt.totalSupply();\n    uint256 collateral = collateral.swingTrader; // gas\n\n    if (collateral >= maltSupply) {\n      return 0;\n    }\n\n    return maltSupply - collateral;\n  }\n```\n\nthus making lpCut larger:\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n\n        uint256 globalSwingTraderRatio = maltDataLab.maltToRewardDecimals(\n          globalIC.swingTraderCollateralRatio()\n        );\n\n        // Already in collateralToken.decimals\n        uint256 poolSwingTraderRatio = impliedCollateralService\n          .swingTraderCollateralRatio();\n\n        if (poolSwingTraderRatio < globalSwingTraderRatio) {\n          swingTraderCut = (distributeCut * swingTraderPreferenceBps) / 10000;\n          lpCut = distributeCut - swingTraderCut;\n        } else {\n          lpCut =\n            (((distributeCut * runwayDeficit) / totalDeficit) *\n              (10000 - lpThrottleBps)) /\n            10000;\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ProfitDistributor.sol#L164-L184> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L423-L424> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTrader.sol#L176-L181>\n\n### Recommended Mitigation Steps\n\nCall syncGlobalCollateral to synchronize the data in globalIC before calling handleProfit.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ProfitDistributor.sol contract, which affects the distribution of profits. The vulnerability occurs when handleProfit() is called without first calling syncGlobalCollateral() to synchronize the data in globalIC. This is because when collateralToken is transferred to the swingTrader, the data in globalIC becomes stale. This can cause the result of globalIC.swingTraderCollateralDeficit() to be larger than it should be, which can result in lpCut being larger than it should be. \n\nThe proof of concept can be found in the Github links provided in the report. No additional tools were used. \n\nThe recommended mitigation step is to call syncGlobalCollateral to synchronize the data in globalIC before calling handleProfit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/10",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16076",
      "title": "[H-04] SwingTraderManager.addSwingTrader will push traderId with `active = false` to activeTraders",
      "impact": "HIGH",
      "content": "\nIn SwingTraderManager.addSwingTrader, if `active = false`, the traderId is also pushed to activeTraders.\n\n```solidity\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\nAfterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again.\n\n```solidity\n  function toggleTraderActive(uint256 traderId)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(trader.id == traderId, \"Unknown trader\");\n\n    bool active = !trader.active;\n    trader.active = active;\n\n    if (active) {\n      // setting it to active so add to activeTraders\n      trader.index = activeTraders.length;\n      activeTraders.push(traderId);\n    } else {\n```\n\nThis means that in `getTokenBalances()/calculateSwingTraderMaltRatio()`, since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice.\n\nWrong `getTokenBalances()` will result in wrong data when `syncGlobalCollateral()`.\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n```\n\nWrong `calculateSwingTraderMaltRatio()` will cause `MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice()` to be wrong.\n\n```solidity\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      totalMaltBalance += malt.balanceOf(trader.traderContract);\n      totalCollateralBalance += collateralToken.balanceOf(\n        trader.traderContract\n      );\n    }\n\n    totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);\n\n    uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /\n      (10**decimals));\n\n    uint256 netBalance = totalCollateralBalance + stMaltValue;\n\n    if (netBalance > 0) {\n      maltRatio = ((stMaltValue * (10**decimals)) / netBalance);\n    } else {\n      maltRatio = 0;\n    }\n  }\n```\n\nWhat's more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.\n\n```solidity\n    } else {\n      // Becoming inactive so remove from activePools\n      uint256 index = trader.index;\n      uint256 lastTrader = activeTraders[activeTraders.length - 1];\n\n      activeTraders[index] = lastTrader;\n      activeTraders.pop();\n\n      swingTraders[lastTrader].index = index;\n      trader.index = 0;\n    }\n```\n\nThis causes the trade to participate in the calculation of `getTokenBalances()/calculateSwingTraderMaltRatio()` even if the trade is deactive.\n\nConsidering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be High risk.\n\n### Proof of Concept\n\n```solidity\n  function testAddSwingTrader(address newSwingTrader) public {\n    _setupContract();\n    vm.assume(newSwingTrader != address(0));\n    vm.prank(admin);\n    swingTraderManager.addSwingTrader(3, newSwingTrader, false, \"Test\");\n\n    (\n      uint256 id,\n      uint256 index,\n      address traderContract,\n      string memory name,\n      bool active\n    ) = swingTraderManager.swingTraders(3);\n\n    assertEq(id, 3);\n    assertEq(index, 2);\n    assertEq(traderContract, newSwingTrader);\n    assertEq(name, \"Test\");\n    assertEq(active, false);\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n    assertEq(swingTraderManager.activeTraders(3),3); // @audit:activeTraders[2] = activeTraders[3] = 3\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n  }\n```\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447>\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```diff\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n-     index: activeTraders.length,\n+     index: active ? activeTraders.length : 0,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n+  if(active) activeTraders.push(traderId);\n\n-   activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/12)**\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the SwingTraderManager.addSwingTrader() function of the StabilityPod contract. If active is set to false, the traderId is still pushed to the activeTraders array. This means that in getTokenBalances()/calculateSwingTraderMaltRatio(), the data in this trader will be calculated twice. This can lead to wrong data when syncGlobalCollateral() is called, which in turn can cause MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice() to be wrong. Furthermore, if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.\n\nA proof of concept has been provided to demonstrate the issue. The recommended mitigation steps are to change the code of the addSwingTrader() function so that the traderId is only pushed to activeTraders if active is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/12",
      "tags": [],
      "finders": [
        "cccz",
        "hansfriese"
      ]
    },
    {
      "id": "16075",
      "title": "[H-03] Manipulation of `livePrice` to receive `defaultIncentive` in 2 consecutive blocks",
      "impact": "HIGH",
      "content": "\nIn StabilizerNode, the default behaviour when twap is below the lower peg threshold, all transfers to the amm pool are blocked. However when `usePrimedWindow = true`, it will only block transfers for `primedWindow = 10` blocks. After 10 blocks, the block automatically stops and allows free market trading.\n\nThe first call to start this priming will receive `defaultIncentive` Malt and set `primedBlock` to start the priming. However, function `_validateSwingTraderTrigger()` which is used to validate and start the priming using `livePrice` is easy to be manipulated. Attacker can manipulate it to receive `defaultIncentive` in 2 consecutive blocks.\n\n### Proof of Concept\n\nConsider the scenario:\n\n1.  Block i, twap is below the value returned from `maltDataLab.getSwingTraderEntryPrice()`, attacker call `stabilize()` and receive `defaultIncentive`. `primedBlock = block.number`.\n2.  Block i+1, call to `_validateSwingTraderTrigger()` return `true` and trigger swing trader to bring the price back to peg. It's also reset `primedBlock = 0` (stop blocking transfer to AMM pool)\n3.  Since only 1 block pass, let's assume twap is still below the value returned from `maltDataLab.getSwingTraderEntryPrice()` (because twap moves slowly and will not change immediately to current price)\n4.  Now attacker can use flash loan to manipulate the `livePrice` to be larger than `entryPrice` (tranfer to AMM is not blocked) and call `stabilize()` to receive incentive again then repay the flash loan.\n\nAttacker cost is only flash loan fee, since his call will start an auction but not trigger swing trader so the state of AMM pool when he repays the flash loan is still the same (only added flash loan fee).\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L312-L334>\n\n```solidity\nfunction _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider not giving incentives for caller or reset the `primedBlock` at least after `primedWindow` blocks.\n\n**[0xScotch (Malt) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1447044279):**\n > I’m kinda skeptical of this but I think its possible in theory.\n> \n> However:\n> - `stabilize` can only be called via EOA due to `msg.sender == tx.origin` check (in `onlyEOA` modifier)\n> - Size of flashloan required is proportional to the size of the pool (as you have to manipulate price of that pool) while the incentive is fixed. So it seems like this would quickly become unprofitable\n> \n> I would be very curious to see a real PoC of this rather than just a theoretical threat.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455212754):**\n > Regarding the previous comment:\n>  - The `onlyEOA` check can be bypassed using a sandwich attack instead of a flashloan so the possibility of a MEV attack still exists\n>  - We should consider that the cost of capital within a block is 0. For example, Euler already proposes feeless flashloans of up to their TVL. See https://twitter.com/euler_mab/status/1595725665868910595. However there would still be the cost of using the AMM to manipulate the price.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455215172):**\n > Although the possibility of this being implemented depends on the size of the incentives and the cost of manipulating the AMM, it does not seem so unlikely. It could lead to a significant loss for the protocol, so I agree that high severity is appropriate.\n\n**[0xScotch (Malt) acknowledged](https://github.com/code-423n4/2023-02-malt-findings/issues/14)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode contract, which is part of the 2023-02-malt project on GitHub. The code for this contract can be found at the specified link. The vulnerability allows an attacker to manipulate the \"livePrice\" value, which is used to validate and start the priming process, in order to receive a \"defaultIncentive\" of Malt in two consecutive blocks. The attacker can do this by using a flash loan to manipulate the \"livePrice\" value and then calling the `stabilize()` function to receive the incentive. The only cost to the attacker is the flash loan fee, as the state of the AMM pool remains unchanged. The recommended mitigation steps for this vulnerability are to either not give incentives to the caller or to reset the \"primedBlock\" value after the \"primedWindow\" has passed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/14",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "16074",
      "title": "[H-02] RewardThrottle: If an epoch does not have any profit, then there may not be rewards for that epoch at the start of the next epoch.",
      "impact": "HIGH",
      "content": "\nIn RewardThrottle, both checkRewardUnderflow and fillInEpochGaps call `\\_fillInEpochGaps` to fill the state of the previous epoch without profit, the difference being that checkRewardUnderflow will request the reward from the overflowPool and distribute the reward, whereas fillInEpochGaps does not.\n\n```solidity\n  function checkRewardUnderflow() public onlyActive {\n    uint256 epoch = timekeeper.epoch();\n\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    // Fill in gaps so we have a fresh foundation to calculate from\n    _fillInEpochGaps(epoch);\n\n    if (epoch > _activeEpoch) {\n      for (uint256 i = _activeEpoch; i < epoch; ++i) {\n        uint256 underflow = _getRewardUnderflow(i);\n\n        if (underflow > 0) {\n          uint256 balance = overflowPool.requestCapital(underflow);\n\n          _sendToDistributor(balance, i);\n        }\n      }\n    }\n  }\n\n  function fillInEpochGaps() external {\n    uint256 epoch = timekeeper.epoch();\n\n    _fillInEpochGaps(epoch);\n  }\n```\n\nThis results in that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if `fillInEpochGaps` is called.\n\nAccording to the documentation, when an epoch is not profitable enough, the reward should be requested from the overflowPool, so checkRewardUnderflow should be called. And if `fillInEpochGaps` is called first, the epoch will lose its reward.\n\nNote: populateFromPreviousThrottle will also cause epochs without any profit to lose their rewards\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462>\n\n### Recommended Mitigation Steps\n\nConsider removing the `fillInEpochGaps` function, or only allowing it to be called when the contract is not active.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/20#issuecomment-1447038822):**\n > We will be removing both implementations of `fillInEpochGaps`.\n\n***\n\n",
      "summary": "\nThis bug report is about the RewardThrottle contract in the 2023-02-malt repository on Github. It highlights the vulnerability that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if fillInEpochGaps is called. The bug is further compounded by the populateFromPreviousThrottle function, which also causes epochs without any profit to lose their rewards.\n\nThe impact of this vulnerability is that the epochs without any profit will lose their rewards. This could result in a loss of funds for the contract.\n\nThe recommended mitigation step is to consider removing the fillInEpochGaps function, or only allowing it to be called when the contract is not active. This will ensure that the epochs without any profit will not lose their rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/20",
      "tags": [],
      "finders": [
        "cccz",
        "hansfriese"
      ]
    },
    {
      "id": "16073",
      "title": "[H-01] `RewardThrottle.checkRewardUnderflow()` might track the cumulative `APR`s wrongly.",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L445-L455> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L576>\n\n### Impact\n\n`RewardThrottle.checkRewardUnderflow()` might calculate the cumulative `APR`s for epochs wrongly.\n\nAs a result, `cashflowAverageApr` will be calculated incorrectly in `updateDesiredAPR()`, and `targetAPR` would be changed unexpectedly.\n\n### Proof of Concept\n\nIn `checkRewardUnderflow()`, it calls a `_sendToDistributor()` function to update cumulative `APR`s after requesting some capitals from the overflow pool.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n445:     if (epoch > _activeEpoch) {\n446:       for (uint256 i = _activeEpoch; i < epoch; ++i) {\n447:         uint256 underflow = _getRewardUnderflow(i);\n448: \n449:         if (underflow > 0) {\n450:           uint256 balance = overflowPool.requestCapital(underflow);\n451: \n452:           _sendToDistributor(balance, i);  //@audit cumulative apr will be tracked wrongly when epoch > _activeEpoch + 1\n453:         }\n454:       }\n455:     }\n```\n\nThe main reason for this issue is that `_sendToDistributor()` doesn't update the cumulative `APR`s when `amount == 0` and the below scenario would be possible.\n\n1.  Let's assume `activeEpoch = 100` and `epoch = 103`. It's possible if the active epoch wasn't updated for 2 epochs.\n2.  After that, the `checkRewardUnderflow()` function will call `_fillInEpochGaps()` and the cumulative `APR`s will be settled accordingly.\n3.  And it will try to request capitals from the `overflowPool` and increase the rewards for epochs.\n4.  At epoch 100, it requests some positive `balance` from `overflowPool` and increases the cumulative `APR`s for epoch 101 correctly in `_sendToDistributor()`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n611:     state[epoch].rewarded = state[epoch].rewarded + rewarded;\n612:     state[epoch + 1].cumulativeCashflowApr = \n613:       state[epoch].cumulativeCashflowApr +\n614:       epochCashflowAPR(epoch);\n615:     state[epoch + 1].cumulativeApr = \n616:       state[epoch].cumulativeApr +\n617:       epochAPR(epoch);\n618:     state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n```\n\n5.  After that, the `overflowPool` doesn't have any remaining funds and the `balance(At L450)` will be 0 for epochs 101, 102.\n6.  So `_sendToDistributor()` will be terminated right away and won't increase the cumulative `APR`s of epoch 102 according to epoch 101 and this value won't be changed anymore because the `activeEpoch` is 103 already.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal { \n576:     if (amount == 0) {\n577:       return;\n578:     }\n```\n\nAs a result, the cumulative `APR`s will save smaller values from epoch 102 and `cashflowAverageApr` will be smaller also if the `smoothingPeriod` contains such epochs in `updateDesiredAPR()`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n139:     uint256 cashflowAverageApr = averageCashflowAPR(smoothingPeriod);\n```\n\nSo the `updateDesiredAPR()` function will change the `targetAPR` using the smaller average value and the smoothing logic wouldn't work as expected.\n\n### Recommended Mitigation Steps\n\nI think `_sendToDistributor()` should update the cumulative `APR`s as well when `amount == 0`.\n\n```solidity\n  function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n    if (amount == 0) {\n        state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);\n        state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);\n        state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n\n        return;\n    }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/23#issuecomment-1447018581):**\n > Interesting finding. It's valid but the bug would actually result in the protocol retaining more capital due to reporting lower APRs than it should. \n\n\n***\n\n",
      "summary": "\nThis bug report is related to the RewardThrottle.sol contract in the 2023-02-malt GitHub repository. The issue is that the cumulative APRs for epochs may be calculated incorrectly, resulting in the cashflowAverageApr being calculated incorrectly in the updateDesiredAPR() function, and then the targetAPR would be changed unexpectedly. \n\nThe problem lies in the _sendToDistributor() function, which doesn't update the cumulative APRs when the amount is 0. This can happen if the activeEpoch has not been updated for two epochs, and then the checkRewardUnderflow() function calls the _fillInEpochGaps() function to settle the cumulative APRs. When it requests some capital from the overflowPool, if the amount is 0, the _sendToDistributor() function will terminate without updating the cumulative APRs for the next epoch. This means that the cashflowAverageApr will be calculated using a lower value, resulting in the targetAPR being changed unexpectedly.\n\nThe recommended mitigation step is to update the cumulative APRs in _sendToDistributor() when the amount is 0. This can be done by adding the following code to the function:\n\n```solidity\n  function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n    if (amount == 0) {\n        state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);\n        state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);\n        state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n\n        return;\n    }\n```\n\nThis will ensure that the cumulative APRs are updated even when the amount is 0, and the targetAPR will be calculated correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/23",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    }
  ]
}