{
  "category": "Decentralized Stablecoin",
  "total_findings": 60,
  "fetched_at": "2026-01-29T13:30:10Z",
  "findings": [
    {
      "id": "63523",
      "title": "[L-04] Frontrunnable Initialization",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\nThe `initialize` instruction creates the global `fund_pool` PDA (`seed = b\"fund_pool\"`) and sets `initial_admin` to an arbitrary public key supplied by the caller. There is no access control restricting who may invoke this first-use initializer. An attacker can front-run deployment, initialize the pool, and seize control over all admin- and signer-gated operations for the lifetime of the program (until redeploy).\n\n**Recommendations**\n\nImplement a robust access control mechanism that ensures only a trusted entity, such as the program's deployer or a predefined address, can call the `initialize` function. This restriction can be enforced by verifying the caller's identity or using a specific signature during initialization.\n\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [
        "Auction",
        "Gas Limit",
        "Initial Deposit",
        "ERC4626",
        "Sense"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63522",
      "title": "[L-03] Inconsistent usage of seed constants and byte literals",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nWhen checking the `fund_pool` address, the seeds used are inconsistent. Some places use the constant `FUND_POOL_SEED`, while others directly use the literal `b\"fund_pool\"`. \n```rust\n    #[account(\n        mut,\n        seeds = [b\"fund_pool\"],\n        bump = fund_pool.bump,\n        constraint = fund_pool.is_admin(&admin.key()) @ ErrorCode::Unauthorized\n    )]\n    pub fund_pool: Account<'info, FundPoolState>,\n\n    #[account(\n        seeds = [FUND_POOL_SEED],\n        bump = fund_pool.bump\n    )]\n    pub fund_pool: Account<'info, FundPoolState>,\n```\nAlthough both are currently equivalent, accidental modification to one of them during upgrades and maintenance may cause inconsistencies.\n\nIt is recommended to consistently use the `FUND_POOL_SEED` constant to improve maintainability and reduce risks introduced by upgrades.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63521",
      "title": "[L-02] `borrow` lacks `has_one = user` constraint on `user_borrow_state`",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe `Borrow` accounts struct (`programs/solver-fund-pool-anchor/src/instructions/borrow.rs:109-128`) derives the user-specific state PDA with seeds `[USER_BORROW_SEED, user.key().as_ref()]`, but it never enforces that the stored `user` field inside `UserBorrowState` actually matches the `user` account provided in the instruction. If the account data is ever modified (e.g., via unchecked CPI or data corruption), the program will happily accept a mismatched tuple, causing the nonce owner stored on-chain to differ from the receiver used for token transfers and signature verification. This breaks critical assumptions about who owns the borrow nonce and can complicate replay protection or downstream accounting.\n\n**Recommendations**\nAdd `has_one = user` to the `user_borrow_state` account constraint so Anchor verifies the persisted `user` field matches the supplied `user` account, tightening the consistency checks around the PDA.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63520",
      "title": "[L-01] Program does not support `Token-2022` mints",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe program exclusively imports and uses the legacy SPL Token interface:\n\n```rust\nuse anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};\npub token_program: Program<'info, Token>;\n```\n\nIf a Token-2022 mint (owned by `spl_token_2022::ID`) is passed, CPIs will fail because the runtime enforces the correct program ID for each account type.\n\n**Recommendations:**\n\nConsider switching to Anchor’s **token interface** layer, which is compatible with both SPL Token (legacy) and Token-2022 programs.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63519",
      "title": "[C-02] Wrong‑Offset Ed25519 instruction introspection enables forged approvals",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nThe program accepts off‑chain approvals by “verifying” an Ed25519 signature via the instruction sysvar: `borrow` expects the previous instruction in the same transaction to be a native Ed25519 verification and then inspects that instruction’s raw data to decide whether the signature is valid.\n\nHowever, the current verifier does not perform the essential validations that make this pattern sound:\n\n* It does not assert that the previous instruction’s `program_id` is the native Ed25519 program.\n* It does not enforce “inline mode” by requiring the three `*_instruction_index` fields in `Ed25519SignatureOffsets` to be `0xFFFF` (meaning use data from this very Ed25519 instruction).\n* It relies on reading specific byte ranges inside the Ed25519 instruction data, but does not validate that the supplied offsets and sizes actually point to those ranges.\n\nOn Solana, the Ed25519 verifier is flexible: the instruction can specify offsets and instruction indexes for where to read the signature, public key, and message. If a contract does not validate those fields, an attacker can craft a preceding instruction that causes the Ed25519 program to verify a signature over attacker‑controlled data, while placing benign‑looking bytes (the expected signer pubkey, message hash, signature) at the locations your program later checks. Your verifier will then return success even though no signature from an authorized signer was actually validated.\n\nAs a result, any caller can submit a transaction that includes a maliciously constructed “verification” instruction immediately before `borrow` and have the program accept it as valid. That enables unauthorized borrows from the pool and increments the user’s nonce, potentially blocking the legitimate user from later redeeming a genuine approval.\n\n## Recommendations\n\nHarden the Ed25519 verification to treat the previous instruction as valid evidence only if all of the following are true:\n\n* The previous instruction’s `program_id` is the native Ed25519 program.\n* The instruction encodes exactly one signature and carries no auxiliary accounts.\n* All three `*_instruction_index` fields in `Ed25519SignatureOffsets` are `0xFFFF` (inline mode), so the signature, public key, and message are taken from the same Ed25519 instruction.\n* All offsets and sizes are bounds‑checked against the instruction data length before slicing.\n* The inline public key, message, and signature bytes exactly match the expected authorized signer and message.\n* If `borrow` is the first instruction, reject (there is no “previous” verification to inspect).\n\n\n\n",
      "summary": "\nThe report discusses a bug found in a program that accepts off-chain approvals by verifying an Ed25519 signature. The current verifier does not perform essential validations, allowing attackers to craft preceding instructions that cause the program to accept invalid signatures. This can result in unauthorized borrows from the pool and block legitimate users from redeeming their approvals. The recommendation is to harden the verification process by checking the previous instruction's program ID, only allowing one signature and no auxiliary accounts, using inline mode, and checking for matching public key, message, and signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63518",
      "title": "[C-01] Funds can be redirected",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\n```rust\n #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>\n```\n\nIn `programs/solver-fund-pool-anchor/src/instructions/borrow.rs:142-143`, the `user_token_account` is only required to be writable; the program never checks whether `owner == user.key()`. The signed message also omits the `user_token_account`, and the contract does not validate that `user_token_account.owner` equals `user`, nor that it is the user’s associated token account (ATA).\n\nAs a result, an attacker can obtain a legitimate signature (which only binds `user/mint/amount/time window/nonce/...`) but replace `user_token_account` with their own token account, siphoning pool funds directly to themselves.\n\n## Recommendations\n\n```rust\n#[account(\n    mut,\n    constraint = user_token_account.mint == token_mint.key() @ ErrorCode::InvalidTokenAccountMint,\n    constraint = user_token_account.owner == user.key() @ ErrorCode::InvalidTokenAccountOwner,\n)]\npub user_token_account: Account<'info, TokenAccount>,\n```\n\nOr restrict to the user’s ATA:\n\n```rust\nuse anchor_spl::associated_token::get_associated_token_address;\nrequire_keys_eq!(\n    user_token_account.key(),\n    get_associated_token_address(&Pubkey::try_from(user.key())?, &token_mint.key()),\n    ErrorCode::NotUserATA\n);\n```\n\n\n\n",
      "summary": "\nThis bug report describes a problem with a Rust program that can allow an attacker to steal funds from a pool. The program does not properly check the ownership of a user's token account, which means that an attacker can use a legitimate signature to siphon funds directly to themselves. The report recommends adding code to validate the token account and restrict it to the user's associated token account. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63470",
      "title": "[L-03] Merkle Root Is Mutable Mid-Airdrop",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe owner can change `merkleRoot` at any time. Already-registered users remain unaffected (state stored), but future registrations switch to the new root, which can change eligibility without warning.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L160-L163](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L160-L163)\n\n```solidity\nfunction setMerkleRoot(bytes32 root) public onlyOwner {\n    merkleRoot = root;\n    emit MerkleRootSet(root);\n}\n```\n\n## Impact\n\nTrust/governance risk: operator can exclude/replace users mid-campaign; users and integrators cannot assume a stable eligibility set after launch.\n\n## Recommendation\n\nFreeze the root after a start time, or gate changes behind a timelock/multisig and communicate immutability guarantees. Optionally add a phase ID and store it to make root changes explicit on-chain.\n\n## Team Response\n\nAcknowledged.\n\n## [I-01] Hardcoded Token Address Limits Deployment To A Specific Chain\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe contract uses a hardcoded token address `0x133879524DDb38582cf0b93D10aDB789601Ff397` as a constant, which corresponds to the BORNE ERC-20 token on [Avalanche mainnet](https://avascan.info/blockchain/c/token/0x133879524DDb38582cf0b93D10aDB789601Ff397). This implementation prevents the contract from being deployed on other blockchain networks where the BORNE token exists at different addresses.\n\nFor example, the BORNE token address on Abstract chain is [`0xcfd7cfeacc783a0d48ce076922b9d87aab2c4c1b`](https://abscan.org/token/0xcfd7cfeacc783a0d48ce076922b9d87aab2c4c1b), making the current contract incompatible with that network without modifying the contract code.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L93](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L93)\n\n```solidity\naddress private constant TOKEN = address(0x133879524DDb38582cf0b93D10aDB789601Ff397);\n```\n\n## Impact\n\nThe hardcoded token address restricts deployment flexibility and requires separate contract implementations for each blockchain network. However, this configuration is acceptable if the protocol plans to deploy exclusively on the Avalanche mainnet.\n\n## Recommendation\n\nMake the token address configurable by setting it in the constructor as an immutable variable.\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] No Recovery Path for non-`TOKEN` ERC-20s Sent to the Contract\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `withdrawTokens()` only transfers the hardcoded `TOKEN`. Any other ERC-20 sent by mistake is stuck forever; there’s no generic sweep/recovery.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L276-L278](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L276-L278)\n\n```solidity\naddress private constant TOKEN = 0x1338...f397; // Only this token can be withdrawn:\n\nfunction withdrawTokens(address to, uint256 amount) public onlyOwner {\n    SafeTransferLib.safeTransfer(TOKEN, to, amount);\n}\n```\n\n## Impact\n\nPermanent loss of mistakenly sent assets (common operational error during integrations / manual ops).\n\n## Recommendation\n\nAdd an owner-only `recoverERC20(address token, address to, uint256 amount)` guarded by appropriate policy (and events). Keep `TOKEN` logic unchanged for airdrop flows.\n\n## Team Response\n\nAcknowledged.\n\n## [I-03] Missing Dedicated Event for Owner Withdrawals (Monitoring Blind Spot)\n\n## Severity\n\nInformational Risk\n\n## Description\n\nOwner withdrawals emit only the ERC-20 `Transfer` event. There’s no contract-level event to reliably monitor admin outflows.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L276-L278](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L276-L278)\n\n```solidity\nfunction withdrawTokens(address to, uint256 amount) public onlyOwner {\n    SafeTransferLib.safeTransfer(TOKEN, to, amount); // no event\n}\n```\n\n## Recommendation\n\nEmit `event TokensWithdrawn(address indexed to, uint256 amount);` inside `withdrawTokens()` and use it for monitoring and forensics.\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [
        "0x"
      ],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63469",
      "title": "[L-02] Users Can Bypass Vesting During Initialization",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe contract is deployed in an unpaused state by default, with `pausedFlag` initialized to `0` and vesting times (`startTime` and `endTime`) initialized to `0`. This creates a vulnerability window during deployment where users who possess valid Merkle proofs can register and immediately claim their full allocation before vesting parameters are properly configured.\n\nThe typical initialization sequence, as can be seen in `test/S2Airdrop.t.sol`:\n\n1. Deploy the contract (unpaused by default)\n2. Call `setMerkleRoot()` to configure eligible addresses\n3. Call `setTime()` to establish vesting parameters\n\nAfter step 2 completes but before step 3 is executed, users can exploit this window to bypass vesting entirely. The `_vestedAmount()` function returns the full allocation when `startTime` is `0`:\n\n```solidity\nif (block.timestamp < startTime) return 0;\n```\n\nSince `block.timestamp` is never less than `0`, this condition fails, and with `endTime` also being `0`, the function proceeds to calculate vested amounts incorrectly or returns unintended values.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L122-L128](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L122-L128)\n\n```solidity\nconstructor(address _owner, address _treasuryWallet) {\n    if (_owner == address(0) || _treasuryWallet == address(0)) {\n        revert ZeroAddress();\n    }\n    _initializeOwner(_owner);\n    treasuryWallet = _treasuryWallet;\n}\n```\n\nFile: [src/S2Airdrop.sol#L285-L301](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L285-L301)\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n## Impact\n\nUsers who obtain Merkle proofs (legitimately or through information leakage) can register and claim their entire token allocation immediately upon Merkle root deployment, completely bypassing the intended vesting mechanism. However, the likelihood of users obtaining valid Merkle proofs before initialization is complete is very low, as proofs are typically distributed after the contract is fully configured. This low likelihood is the primary reason this issue is rated as Low Risk.\n\nDespite the low probability, exploitation could result in:\n\n1. Premature distribution of tokens meant to vest over time\n2. Loss of control over the token release schedule\n3. Potential market impact from unexpected token circulation\n4. Unfair advantage for users monitoring the mempool who can front-run initialization transactions\n\n## Recommendation\n\n1. Deploy the contract in a paused state by initializing `pausedFlag = 1` in the constructor:\n\n```solidity\nconstructor(address _owner, address _treasuryWallet) {\n    if (_owner == address(0) || _treasuryWallet == address(0)) {\n        revert ZeroAddress();\n    }\n    _initializeOwner(_owner);\n    treasuryWallet = _treasuryWallet;\n    pausedFlag = 1;\n}\n```\n\n2. Add validation checks for zero timestamps in both `claim()` and `_vestedAmount()` functions:\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    if (startTime == 0 || endTime == 0) return 0;\n\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n3. Follow a secure initialization sequence:\n   - Deploy contract (automatically paused)\n   - Set vesting times\n   - Set merkle root\n   - Fund the contract\n   - Unpause to enable user interactions\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63468",
      "title": "[L-01] Vesting Parameters Can Be Changed After Vesting Starts",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `setTime()` function only validates that the new `_startTime` is in the future, but does not check whether vesting has already commenced with the current stored `startTime`. This allows the owner to modify vesting parameters after users have already begun claiming tokens, potentially disrupting user expectations and previously calculated vesting schedules.\n\nThe validation in the function checks:\n\n```solidity\nif (block.timestamp > _startTime) revert VestingAlreadyStarted();\n```\n\nHowever, this only prevents setting a `_startTime` that is already in the past. If the current `startTime` has already passed and vesting is active, the owner can still call `setTime()` with a future timestamp, effectively restarting or extending the vesting period.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L166-L174](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L166-L174)\n\n```solidity\nfunction setTime(uint40 _startTime, uint40 _endTime) public onlyOwner {\n    if (block.timestamp > _startTime) revert VestingAlreadyStarted();\n    if (_startTime >= _endTime) revert VestingEndTimeError();\n\n    startTime = _startTime;\n    endTime = _endTime;\n\n    emit VestingTimeSet(_startTime, _endTime);\n}\n```\n\n## Impact\n\nThe owner can change vesting parameters after vesting has started, leading to:\n\n1. Users who have calculated their vesting schedule based on the original parameters may find their claimable amounts suddenly reduced or locked again\n2. The vesting period can be extended arbitrarily, delaying when users receive their full allocation\n3. Trust in the protocol is undermined if vesting parameters are modified post-deployment without user consent\n\n## Recommendation\n\nAdd a check to ensure the current `startTime` has not yet been reached:\n\n```solidity\nfunction setTime(uint40 _startTime, uint40 _endTime) public onlyOwner {\n    if (block.timestamp > startTime) revert VestingAlreadyStarted();\n    if (block.timestamp > _startTime) revert VestingAlreadyStarted();\n    if (_startTime >= _endTime) revert VestingEndTimeError();\n\n    startTime = _startTime;\n    endTime = _endTime;\n\n    emit VestingTimeSet(_startTime, _endTime);\n}\n```\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63467",
      "title": "[M-01] Unfair Vesting Extension for Users Spending Locked Tokens Before Claiming",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nThe vesting calculation in `_vestedAmount()` creates an inequitable outcome for users who spend locked tokens before claiming vested tokens compared to users who claim first. The function reduces the total allocation by `spendLockedAmount` before applying the vesting percentage, effectively extending the vesting period for users who utilize the in-app purchase feature early.\n\nWhen a user spends locked tokens via `spendLockTokens()`, the `spendLockedAmount` is incremented. Subsequently, `_vestedAmount()` calculates the vested amount as:\n\n```solidity\nuint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\nreturn (leftVestedAmount * elapsed) / duration;\n```\n\nThis means the vesting percentage is applied to the reduced allocation rather than the original amount, penalizing users who spend locked tokens before the vesting period completes.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L285-L301](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L285-L301)\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n## Impact\n\nUsers who spend locked tokens before claiming face a significant disadvantage: their claimable vested amount is calculated on a reduced base, resulting in fewer tokens available for withdrawal at any given point during vesting. Conversely, users who claim vested tokens first can then spend the same amount of locked tokens while retaining their full vested allocation.\n\nThis creates an unfair system where identical users with identical allocations receive different treatment based solely on the order of their interactions with the contract.\n\n## Proof of Concept\n\nBoth User A and User B have 10,000 tokens allocated, with 3 months of vesting passed (50% vested).\n\n**User A (claims first):**\n\n1. Claims 5,000 vested tokens (50% of 10,000)\n   - `details.claimedAmount = 5,000`\n2. Spends 5,000 locked tokens via in-app purchase\n   - `details.spendLockedAmount = 5,000`\n   - Successfully completes the purchase\n\n**User B (spends first):**\n\n1. Spends 5,000 locked tokens via in-app purchase\n   - `details.spendLockedAmount = 5,000`\n2. Attempts to claim 5,000 vested tokens (50% of original 10,000)\n   - `leftVestedAmount = 10,000 - 5,000 = 5,000`\n   - `_vestedAmount = 5,000 * 50% = 2,500`\n   - `availableAmount = 2,500 - 0 = 2,500`\n   - Can only claim 2,500 tokens instead of the expected 5,000\n\nUser B receives 2,500 fewer claimable tokens for the same allocation and timeline simply because they utilized the in-app purchase feature before claiming.\n\n## Recommendation\n\nCalculate the vested amount based on the original allocation first, then subtract spent locked tokens. Alternatively, if the vesting schedule extension is intentional, automatically claim the user's vested tokens before purchase calculations.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report discusses a bug in the calculation of vested tokens for users in a smart contract. This bug is classified as a medium risk and has an impact on users who spend locked tokens before claiming their vested tokens. The calculation reduces the total allocation by the amount spent, resulting in a longer vesting period for these users compared to others who claim first. The affected code is located in a specific file and function in the contract. The bug has been demonstrated with two users who have the same allocation but receive different amounts of claimable tokens due to the order of their interactions with the contract. The recommendation is to either calculate the vested amount based on the original allocation or automatically claim vested tokens before purchase calculations. The team has responded that the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "45275",
      "title": "[L-12] The `_beforeTokenTransfer()` function does not verify whether addresses are whitelisted when `WHITELIST_ENABLED` is set.",
      "impact": "LOW",
      "content": "\nAs noted in line 191, the function only checks if the address `to` is not blacklisted. Consequently, unwhitelisted users can still receive UStb when `WHITELIST_ENABLED` is active. This issue appears in several locations.\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStb.sol#L165-L218\n\n```solidity\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // State 2 - Transfers fully enabled except for blacklisted addresses\n        if (transferState == TransferState.FULLY_ENABLED) {\n\n            ...\n\n        } else if (transferState == TransferState.WHITELIST_ENABLED) {\n            if (hasRole(MINTER_CONTRACT, msg.sender) && !hasRole(BLACKLISTED_ROLE, from) && to == address(0)) {\n                // redeeming\n191         } else if (hasRole(MINTER_CONTRACT, msg.sender) && from == address(0) && !hasRole(BLACKLISTED_ROLE, to)) {\n                // minting\n            } else if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && hasRole(BLACKLISTED_ROLE, from) && to == address(0)) {\n                // redistributing - burn\n            } else if (\n                hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && from == address(0) && !hasRole(BLACKLISTED_ROLE, to)\n            ) {\n                // redistributing - mint\n            } else if (hasRole(WHITELISTED_ROLE, msg.sender) && hasRole(WHITELISTED_ROLE, from) && to == address(0)) {\n                // whitelisted user can burn\n            } else if (\n                hasRole(WHITELISTED_ROLE, msg.sender) &&\n                hasRole(WHITELISTED_ROLE, from) &&\n                hasRole(WHITELISTED_ROLE, to) &&\n                !hasRole(BLACKLISTED_ROLE, msg.sender) &&\n                !hasRole(BLACKLISTED_ROLE, from) &&\n                !hasRole(BLACKLISTED_ROLE, to)\n            ) {\n                // n.b. an address can be whitelisted and blacklisted at the same time\n                // normal case\n            } else {\n                revert OperationNotAllowed();\n            }\n            // State 0 - Fully disabled transfers\n        } else if (transferState == TransferState.FULLY_DISABLED) {\n            revert OperationNotAllowed();\n        }\n    }\n```\n\nInclude checks to ensure that the addresses are whitelisted.\n\n**[iethena (Ethena Labs) acknowledged and commented](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/12#issuecomment-2480339994):**\n > Fixed L-01. L-02, L-08 in ethena-labs/ethena-ustb-contest/pull/2\n\n**EV_om (judge) commented via private message to C4 staff:**\n> L-01 Invalid\n> L-02 Low\n> L-03 Low\n> L-04 Invalid\n> L-05 Non-Critical\n> L-06 Non-Critical\n> L-07 Low\n> L-08 Non-Critical\n> L-09 Invalid\n> L-10 Invalid\n> L-11 Non-Critical\n> L-12 Invalid\n>\n>\n> The judge also highlighted the downgraded issues [#7](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/7) and [#8](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/8) to be linked in this report for completeness.\n\n***\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45274",
      "title": "[L-11] There is no function available to transfer UStb from unwhitelisted users to whitelisted users.",
      "impact": "LOW",
      "content": "\nThe `redistributeLockedAmount()` function facilitates the transfer of UStb from a blacklisted user to an unblacklisted user. However, when the state is `WHITELIST_ENABLED`, there is no mechanism in place to transfer UStb from an unwhitelisted user to a whitelisted user.\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L111-L120\n\n```solidity\n    function redistributeLockedAmount(address from, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n112     if (hasRole(BLACKLISTED_ROLE, from) && !hasRole(BLACKLISTED_ROLE, to)) {\n            uint256 amountToDistribute = balanceOf(from);\n            _burn(from, amountToDistribute);\n            _mint(to, amountToDistribute);\n            emit LockedAmountRedistributed(from, to, amountToDistribute);\n        } else {\n            revert OperationNotAllowed();\n        }\n    }\n```\n\nInclude a function to transfer UStb from an unwhitelisted user to a whitelisted user when the state is `WHITELIST_ENABLED`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45273",
      "title": "[L-10] The `redistributeLockedAmount()` function does not verify if the address `to` possesses the `WHITELISTED_ROLE` when `WHITELIST_ENABLED`.",
      "impact": "LOW",
      "content": "\nWhen the state is `WHITELIST_ENABLED`, only addresses with the `WHITELISTED_ROLE` are permitted to receive UStb. However, in the `redistributeLockedAmount()` function, the only check performed is to ensure that the address to does not have the `BLACKLISTED_ROLE`. Consequently, redistribution to an unwhitelisted address is allowed.\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L111-L120\n\n```solidity\n    function redistributeLockedAmount(address from, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n112     if (hasRole(BLACKLISTED_ROLE, from) && !hasRole(BLACKLISTED_ROLE, to)) {\n            uint256 amountToDistribute = balanceOf(from);\n            _burn(from, amountToDistribute);\n            _mint(to, amountToDistribute);\n            emit LockedAmountRedistributed(from, to, amountToDistribute);\n        } else {\n            revert OperationNotAllowed();\n        }\n    }\n```\n\nVerify whether the address to has the `WHITELISTED_ROLE` when the state is `WHITELIST_ENABLED`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45272",
      "title": "[L-09] Non-blacklisted addresses can't burn `UStb` tokens in a `FULLY_ENABLED` transfer state if `address(0)` is blaklisted",
      "impact": "LOW",
      "content": "\nFrom the [Main invariants](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/README.md):\n> ### Main invariants\n> - Only non-blacklisted addresses can send/receive/burn UStb tokens in a `FULLY_ENABLED` transfer state.\n\nHowever, if `address(0)` is blacklisted, non-blacklisted addresses can't burn their tokens, which violates the main invariants.\n\nIt is recommended to modify the code as follows:\n```diff\nFile: contracts\\ustb\\UStb.sol\n176:             ) {\n177:                 // redistributing - mint\n+                } else if (\n+                    !hasRole(BLACKLISTED_ROLE, msg.sender) && !hasRole(BLACKLISTED_ROLE, from) && to == address(0)\n+                ) {\n+                    // burn\n178:             } else if (\n179:                 !hasRole(BLACKLISTED_ROLE, msg.sender) &&\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45271",
      "title": "[L-08] Unnecessary check of `tokenConfig[asset].isActive` in the `_transferToBeneficiary` function.",
      "impact": "LOW",
      "content": "\nThe `redeem` function has `belowMaxRedeemPerBlock` modifier and it checks `_config.isActive` is true from [L127](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L127).\n\n```solidity\nL127:        if (!_config.isActive) revert UnsupportedAsset();\n```\n\nThe `redeem` function calls `_transferToBeneficiary` and it also checks `tokenConfig[asset].isActive` is true from L594.\n\n```solidity\nL594:            if (!tokenConfig[asset].isActive) revert UnsupportedAsset();\n```\n\nThis is an unnecessary double check. It is recommended to remove the check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45270",
      "title": "[L-07] The`GATEKEEPER_ROLE` shouldn't be allowed to remove the `COLLATERAL_MANAGER_ROLE`",
      "impact": "LOW",
      "content": "\nFrom the [readme](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/README.md), the `GATEKEEPER` has the ability to disable minting and redeeming.\n| Role              | Description                                                                        |\n|-------------------|------------------------------------------------------------------------------------|\n| GATEKEEPER        | has the ability to disable minting and redeeming                                   |\n\nHowever, in the codebase, the `GATEKEEPER_ROLE` can remove the `COLLATERAL_MANAGER_ROLE` from an account.\n```solidity\nFile: contracts\\ustb\\UStbMinting.sol\n379:     function removeCollateralManagerRole(address collateralManager) external onlyRole(GATEKEEPER_ROLE) {\n380:         _revokeRole(`COLLATERAL_MANAGER_ROLE`, collateralManager);\n381:     }\n```\nThe `COLLATERAL_MANAGER_ROLE` can transfer an asset to a custody wallet using the `transferToCustody()` function.\n\nIt means that the `GATEKEEPER_ROLE` can remove the functionality to transfer assets to the custody wallet.\n\nIt is recommended to modify the code as follows:\n```diff\nFile: contracts\\ustb\\UStbMinting.sol\n-        function removeCollateralManagerRole(address collateralManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n+        function removeCollateralManagerRole(address collateralManager) external onlyRole(GATEKEEPER_ROLE) {\n380:         _revokeRole(`COLLATERAL_MANAGER_ROLE`, collateralManager);\n381:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45269",
      "title": "[L-06] Most of the event parameters are of the `uint256` data type, but `uint128` variables are used when emitting them",
      "impact": "LOW",
      "content": "\nThe `collateral_amount` of the `Mint` event are uint256 data type.\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/IUStbMintingEvents.sol#L17\n\n```solidity\n    event Mint(\n        string indexed order_id,\n        address indexed benefactor,\n        address indexed beneficiary,\n        address minter,\n        address collateral_asset,\nL17:    uint256 collateral_amount,\n        uint256 ustb_amount\n    );\n```\n\nHowever `order.collateral_amount` is `uint128` data type in the `mint` function.\n\n```solidity\n        emit Mint(\n            order.order_id,\n            order.benefactor,\n            order.beneficiary,\n            msg.sender,\n            order.collateral_asset,\nL251:       order.collateral_amount,\n            order.ustb_amount\n        );\n```\n\nEnsure that the data types of the events and variables match.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45268",
      "title": "[L-05] If the `collateral_asset` is native token, minting is unavailable even though redeeming is available.",
      "impact": "LOW",
      "content": "\nIn the `_transferCollateral` function, if the `collateral_asset` is native token, it reverts. This causes minting reverts.\n\n```solidity\nFile: contracts\\ustb\\UStbMinting.sol\n608:         if (!tokenConfig[asset].isActive || asset == NATIVE_TOKEN) revert UnsupportedAsset();\n```\n\nHowever, redeeming is available even though the `collateral_asset` is native token.\n\n```solidity\n    function _transferToBeneficiary(address beneficiary, address asset, uint128 amount) internal {\nL:588:  if (asset == NATIVE_TOKEN) {\n            if (address(this).balance < amount) revert InvalidAmount();\n            (bool success, ) = (beneficiary).call{value: amount}(\"\");\n            if (!success) revert TransferFailed();\n        } else {\n            if (!tokenConfig[asset].isActive) revert UnsupportedAsset();\n            IERC20(asset).safeTransfer(beneficiary, amount);\n        }\n    }\n```\n\nImprove the minting mechanism to allow native token.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45267",
      "title": "[L-04] `differenceInBps` is calculated with a precision of 10^4",
      "impact": "LOW",
      "content": "\nSince `STABLES_RATIO_MULTIPLIER` is 10,000, `differenceInBps` is calculated with a precision of 10^4.\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L568\n\n```solidity\nL568:     uint128 differenceInBps = (difference * STABLES_RATIO_MULTIPLIER) / ustbAmount;\n```\n\nIt needs to calculate it with higher precision.\n\nSets the `STABLES_RATIO_MULTIPLIER` as higher value like `1e18`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45266",
      "title": "[L-03] The `_computeDomainSeparator` function incorrectly encodes `bytes32` variable as `string` type",
      "impact": "LOW",
      "content": "\nThe `EIP712_DOMAIN`'s `name` and `version` parameters are `string` type, and `EIP_712_NAME` and `EIP712_REVISION` are `bytes32` type.\n\n```solidity\nL28:    bytes32 private constant EIP712_DOMAIN =\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\nL56:    bytes32 private constant EIP_712_NAME = keccak256(\"EthenaUStbMinting\");\nL59:    bytes32 private constant EIP712_REVISION = keccak256(\"1\");\n```\n\nThe [_computeDomainSeparator](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L665) function encodes with inconsistent data type.\n```solidity\n        function _computeDomainSeparator() internal view returns (bytes32) {\nL665:       return keccak256(abi.encode(EIP712_DOMAIN, EIP_712_NAME, EIP712_REVISION, block.chainid, address(this)));\n        }\n```\nEnsure that the data types of the parameters `EIP712_DOMAIN`, `EIP_712_NAME`, and `EIP712_REVISION` match.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45265",
      "title": "[L-02] In the constructor of `UStbMinting` contract, it does not set `ustb`",
      "impact": "LOW",
      "content": "\nThe constructor of `UStbMinting` contract does not set `ustb`, it checks whether `_assets[k]` is `address(ustb)` from L187\n\nhttps://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStbMinting.sol#L187\n\n```solidity\nL187:   if (tokenConfig[_assets[k]].isActive || _assets[k] == address(0) || _assets[k] == address(ustb)) {\n            revert InvalidAssetAddress();\n        }\n```\n\nBecause initial value `ustb` is 0, `_assets[k] == address(ustb)` is same as `_assets[k] == address(0)`.\nThis means `_assets[k] == address(ustb)` is an unnecessary check.\n\nSets the initial `ustb` in the constructor of the `UStbMinting` contract.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45264",
      "title": "[L-01] The `addBlacklistAddress` and `addWhitelistAddress` functions do not check whether the user has opposite role",
      "impact": "LOW",
      "content": "\nThe [`addBlacklistAddress`](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStb.sol#L73) function does not check whether the user has `WHITELISTED_ROLE`\n\n```solidity\n    function addBlacklistAddress(address[] calldata users) external onlyRole(BLACKLIST_MANAGER_ROLE) {\n        for (uint8 i = 0; i < users.length; i++) {\n            _grantRole(BLACKLISTED_ROLE, users[i]);\n        }\n    }\n```\n\nThe [`addWhitelistAddress`](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStb.sol#L91) function does not check whether the user has `BLACKLISTED_ROLE`\n\n```solidity\n    function addWhitelistAddress(address[] calldata users) external onlyRole(WHITELIST_MANAGER_ROLE) {\n        for (uint8 i = 0; i < users.length; i++) {\n            _grantRole(WHITELISTED_ROLE, users[i]);\n        }\n    }\n```\n\nIf `WHITELIST_MANAGER_ROLE` grants `WHITELISTED_ROLE` to blacklisted user and does not remove BLACKLISTED_ROLE, the user cannot transfer `UStb` token in `WHITELIST_ENABLED` state from [L205](https://github.com/code-423n4/2024-11-ethena-labs/blob/main/contracts/ustb/UStb.sol#L206).\n\n```solidity\n        } else if (\n            hasRole(WHITELISTED_ROLE, msg.sender) &&\n            hasRole(WHITELISTED_ROLE, from) &&\n            hasRole(WHITELISTED_ROLE, to) &&\n            !hasRole(BLACKLISTED_ROLE, msg.sender) &&\nL206:       !hasRole(BLACKLISTED_ROLE, from) &&\n            !hasRole(BLACKLISTED_ROLE, to)\n        ) {\n            // n.b. an address can be whitelisted and blacklisted at the same time\n            // normal case\n        } else {\n            revert OperationNotAllowed();\n        }\n```\n\nIt is recommended to change the code as follows:\n\n```diff\n    function addBlacklistAddress(address[] calldata users) external onlyRole(BLACKLIST_MANAGER_ROLE) {\n        for (uint8 i = 0; i < users.length; i++) {\n+           if (hasRole(WHITELISTED_ROLE, users[i]))\n+               _revokeRole(WHITELISTED_ROLE, users[i]);\n            _grantRole(BLACKLISTED_ROLE, users[i]);\n        }\n    }\n    \n    function addWhitelistAddress(address[] calldata users) external onlyRole(WHITELIST_MANAGER_ROLE) {\n        for (uint8 i = 0; i < users.length; i++) {\n+           if (hasRole(BLACKLISTED_ROLE, users[i]))\n+               _revokeRole(BLACKLISTED_ROLE, users[i]);\n            _grantRole(WHITELISTED_ROLE, users[i]);\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "45263",
      "title": "[M-02] Non-whitelisted users can burn UStb and redeem collateral during WHITELIST_ENABLED state",
      "impact": "MEDIUM",
      "content": "\nNon-whitelisted users can redeem collateral tokens and burn their UStb even when whitelist mode has been enabled on UStb contract. This breaks the main invariant mentioned in the [README](https://github.com/code-423n4/2024-11-ethena-labs/tree/main#additional-context).\n\n### Proof of Concept\n\nThe below code block is from the `\\_beforeTokenTransfer() function()`, which is called at the beginning of the ERC20 \\_burn() internal function. When the transferState is WHITELIST_ENABLED, it should only allow whitelisted users to burn their UStb as mentioned under the main invariants in the [README](https://github.com/code-423n4/2024-11-ethena-labs/tree/main#additional-context). But since the `from` address is not checked to have the `WHITELISTED_ROLE` as well, the call goes through.\n\n```solidity\nFile: UStb.sol\n193:         } else if (transferState == TransferState.WHITELIST_ENABLED) {\n194:            \n195:             if (hasRole(MINTER_CONTRACT, msg.sender) && !hasRole(BLACKLISTED_ROLE, from) && to == address(0)) {\n```\n\n### Recommended Mitigation Steps\n\nAdd ` hasRole(WHITELISTED_ROLE, from)  ` in the check.\n\n**[iethena (Ethena Labs) disputed and commented](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/13#issuecomment-2479259765):**\n > The Redeemer has a special role in the protocol and it is seen as a non-issue that UStb can be redeemed from a non-whitelisted address while whitelist mode is enabled. As specified in [the Overview](https://github.com/code-423n4/2024-11-ethena-labs/tree/main?tab=readme-ov-file#overview) the redeem order is determined by and off-chain RFQ system, in which case the Redeemer will not provide a redemption quote if they chose not to.\n> \n> For clarity, a non-whitelisted user cannot redeem collateral without the involvement of the Redeemer, as it is the Redeemer who submits the settlement transaction on-chain. We therefore argue that the likelihood of this happening is low. In addition, the impact to the protocol is low as the collateralization ratio of the minting contract would not be impacted and other users' positions are not impacted. Although this finding is informationally correct, we view the severity to be based on the fact that a non-whitelisted address can initiate a redemption without the involvement of a trusted party within the protocol which is not the case.\n> \n> We suggest marking this finding as Low severity.\n> \n\n\n**[EV_om (judge) commented](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/13#issuecomment-2481859546):**\n > One of the main invariants here was:\n> \n> > Only whitelisted user can send/receive/burn UStb tokens in a `WHITELIST_ENABLED` transfer state.\n> \n> The warden could not have known whether the off-chain Redeemer would only submit transactions for whitelisted addresses. Besides, the WHITELIST_MANAGER and the REDEEMER being different entities means there can always be race conditions on address (un-)whitelisting and redemption submission.\n> \n> If the contract must enforce the invariant (which seems to not necessarily be the case), this must be done onchain. But for the purpose of the audit, Medium is appropriate.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue where non-whitelisted users can redeem collateral tokens and burn their UStb, even when whitelist mode has been enabled on the UStb contract. This goes against the main rule stated in the README file. The report includes a code block showing where the issue occurs and suggests adding a check to fix it. However, the developer disputes the severity of the issue, stating that it is unlikely to happen and has low impact on the protocol. The judge agrees that the issue is not severe, but suggests that it should still be addressed on-chain for future audits.",
      "quality_score": 3,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/13",
      "tags": [],
      "finders": [
        "MrPotatoMagic"
      ]
    },
    {
      "id": "45262",
      "title": "[M-01] Blacklisted user can burn tokens during WHITELIST_ENABLED state",
      "impact": "MEDIUM",
      "content": "\nBlacklisted user can burn tokens during WHITELIST_ENABLED state. This breaks the main invariant from the [README](https://github.com/code-423n4/2024-11-ethena-labs/tree/main#main-invariants). This could become an issue when the admin tries to redistribute the blacklisted user's UStb balance using `redistributeLockedAmount()` but the blacklisted user frontruns it with a burn.\n\n### Proof of Concept\n\nAccording to the comment [here](https://github.com/code-423n4/2024-11-ethena-labs/blob/e93ee09b10f900bd3be385f392c80920898bf53e/contracts/ustb/UStb.sol#L209), it is possible for an address to be whitelisted and blacklisted at the same.\n\nDuring the WHITELIST_ENABLED state, the code block below is checked when burning tokens to ensure only whitelisted addresses can burn their tokens. But since blacklisted users also have the whitelisted role as per the comment above, the condition evaluates to true and allows the blacklisted address to burn tokens.\n\n```solidity\nFile: UStb.sol\n208:             } else if (hasRole(WHITELISTED_ROLE, msg.sender) && hasRole(WHITELISTED_ROLE, from) && to == address(0)) {\n209:                 // whitelisted user can burn\n\n```\n\n### Recommended Mitigation Steps\n\nAdd the conditions `!hasRole(BLACKLISTED_ROLE, msg.sender)` and `!hasRole(BLACKLISTED_ROLE, from)` to the check.\n\n**[iethena (Ethena Labs) disputed via duplicate issue #3 and commented](https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/3#issuecomment-2479266803):**\n\n> This can happen in 2 different variants:\n> 1. A user is initially blacklisted but is later added to the whitelist without being removed from the blacklist\n> 2. A user is initially whitelisted but is later added to the blacklist without being removed from the whitelist\n>\n> In both cases the user can burn their tokens when whitelist mode is enabled for the transfer state. The likelihood of falling into this state is high because the Blacklist Manager and Whitelist Manager are intended to be different entities and as such we cannot guarantee that they will coordinate to maintain a clean separation of the blacklist/whitelist roles. If a user with a whitelist and blacklist role simultaneously, chose to burn their tokens in whitelist transfer state mode, it would have a positive impact on the protocol overall as there would be excess collateral in the protocol. We therefore believe that this issue should be marked as low as there is no incentive for a user to outright burn their tokens, in fact if a user does so, all other users in the protocol will benefit, without causing a negative impact.\n> \n> \n> Just to note that this was fixed in ethena-labs/ethena-ustb-contest/pull/2 based off of a different qa finding which ensures that whitelist/blacklist roles are mutually exclusive.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue where a user who is both blacklisted and whitelisted can burn tokens during a specific state, despite only whitelisted users being allowed to do so. This can happen if the user is added to one list without being removed from the other. The recommended solution is to add additional conditions to the check to prevent this from happening. However, the team has disputed the severity of the issue, stating that it is unlikely to happen and could even have a positive impact on the protocol. They also mention that this issue has already been fixed in a recent update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2024-11-ethena-labs",
      "github_link": "https://github.com/code-423n4/2024-11-ethena-labs-findings/issues/15",
      "tags": [],
      "finders": [
        "MrPotatoMagic",
        "SpicyMeatball"
      ]
    },
    {
      "id": "29406",
      "title": "[G-10] Emit local variables instead of state variable (Save ~100 Gas)",
      "impact": "GAS",
      "content": "\n### Emit `_maxMintPerBlock` instead of `maxMintPerBlock`\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L436-L440\n```solidity\nFile: /contracts/EthenaMinting.sol\n436:  function _setMaxMintPerBlock(uint256 _maxMintPerBlock) internal {\n437:    uint256 oldMaxMintPerBlock = maxMintPerBlock;\n438:    maxMintPerBlock = _maxMintPerBlock;\n439:    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, maxMintPerBlock);\n440:  }\n```\n\nSince we are setting our state variable `maxRedeemPerBlock` to the function parameter `_maxRedeemPerBlock`, we should emit the function parameter as it is cheaper to read compared to the state variable:\n\n```diff\ndiff --git a/contracts/EthenaMinting.sol b/contracts/EthenaMinting.sol\nindex 32da3a5..f569e40 100644\n--- a/contracts/EthenaMinting.sol\n+++ b/contracts/EthenaMinting.sol\n@@ -436,7 +436,7 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n   function _setMaxMintPerBlock(uint256 _maxMintPerBlock) internal {\n     uint256 oldMaxMintPerBlock = maxMintPerBlock;\n     maxMintPerBlock = _maxMintPerBlock;\n-    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, maxMintPerBlock);\n+    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, _maxMintPerBlock);\n   }\n```\n\n### Emit `_maxMintPerBlock` instead of `maxMintPerBlock`\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L443-L447\n```solidity\nFile: /contracts/EthenaMinting.sol\n443:  function _setMaxRedeemPerBlock(uint256 _maxRedeemPerBlock) internal {\n444:    uint256 oldMaxRedeemPerBlock = maxRedeemPerBlock;\n445:    maxRedeemPerBlock = _maxRedeemPerBlock;\n446:    emit MaxRedeemPerBlockChanged(oldMaxRedeemPerBlock, maxRedeemPerBlock);\n447:  }\n```\nSince we are setting our state variable `maxRedeemPerBlock` to the function parameter `_maxRedeemPerBlock`, we should emit the function parameter as it is cheaper to read compared to the state variable.\n\n```diff\ndiff --git a/contracts/EthenaMinting.sol b/contracts/EthenaMinting.sol\nindex 32da3a5..8198a3e 100644\n--- a/contracts/EthenaMinting.sol\n+++ b/contracts/EthenaMinting.sol\n@@ -443,7 +443,7 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n   function _setMaxRedeemPerBlock(uint256 _maxRedeemPerBlock) internal {\n     uint256 oldMaxRedeemPerBlock = maxRedeemPerBlock;\n     maxRedeemPerBlock = _maxRedeemPerBlock;\n-    emit MaxRedeemPerBlockChanged(oldMaxRedeemPerBlock, maxRedeemPerBlock);\n+    emit MaxRedeemPerBlockChanged(oldMaxRedeemPerBlock, _maxRedeemPerBlock);\n   }\n\n```\n\n### Emit `duration` instead of `cooldownDuration` (Save 1 SLOAD)\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L126-L134\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 2439    | 3110   | 2439 | 9239 |\n| After  | 2425    | 3097   | 2425 | 9225 |\n\n```solidity\nFile: /contracts/StakedUSDeV2.sol\n126:  function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n127:    if (duration > MAX_COOLDOWN_DURATION) {\n128:      revert InvalidCooldown();\n129:    }\n\n131:    uint24 previousDuration = cooldownDuration;\n132:    cooldownDuration = duration;\n133:    emit CooldownDurationUpdated(previousDuration, cooldownDuration);\n134:  }\n```\n\n```diff\ndiff --git a/contracts/StakedUSDeV2.sol b/contracts/StakedUSDeV2.sol\nindex df2bb48..d3f1b29 100644\n--- a/contracts/StakedUSDeV2.sol\n+++ b/contracts/StakedUSDeV2.sol\n@@ -130,6 +130,6 @@ contract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {\n\n     uint24 previousDuration = cooldownDuration;\n     cooldownDuration = duration;\n-    emit CooldownDurationUpdated(previousDuration, cooldownDuration);\n+    emit CooldownDurationUpdated(previousDuration, duration);\n   }\n```\n\n**[FJ-Riveros (Ethena) acknowledged](https://github.com/code-423n4/2023-10-ethena-findings/issues/443#issuecomment-1804479032)**\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29405",
      "title": "[G-09] Validate function parameters before making function calls or reading any state variables",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L339-L348\n```solidity\nFile: /contracts/EthenaMinting.sol\n339:  function verifyOrder(Order calldata order, Signature calldata signature) public view override returns (bool, bytes32) {\n340:    bytes32 taker_order_hash = hashOrder(order);\n341:    address signer = ECDSA.recover(taker_order_hash, signature.signature_bytes);\n342:    if (!(signer == order.benefactor || delegatedSigner[signer][order.benefactor])) revert InvalidSignature();\n343:    if (order.beneficiary == address(0)) revert InvalidAmount();\n344:    if (order.collateral_amount == 0) revert InvalidAmount();\n345:    if (order.usde_amount == 0) revert InvalidAmount();\n346:    if (block.timestamp > order.expiry) revert SignatureExpired();\n347:    return (true, taker_order_hash);\n348:  }\n```\n\n```diff\ndiff --git a/contracts/EthenaMinting.sol b/contracts/EthenaMinting.sol\nindex 32da3a5..cf642d5 100644\n--- a/contracts/EthenaMinting.sol\n+++ b/contracts/EthenaMinting.sol\n@@ -337,13 +337,13 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n\n   /// @notice assert validity of signed order\n   function verifyOrder(Order calldata order, Signature calldata signature) public view override returns (bool, bytes32) {\n-    bytes32 taker_order_hash = hashOrder(order);\n-    address signer = ECDSA.recover(taker_order_hash, signature.signature_bytes);\n-    if (!(signer == order.benefactor || delegatedSigner[signer][order.benefactor])) revert InvalidSignature();\n     if (order.beneficiary == address(0)) revert InvalidAmount();\n     if (order.collateral_amount == 0) revert InvalidAmount();\n     if (order.usde_amount == 0) revert InvalidAmount();\n     if (block.timestamp > order.expiry) revert SignatureExpired();\n+    bytes32 taker_order_hash = hashOrder(order);\n+    address signer = ECDSA.recover(taker_order_hash, signature.signature_bytes);\n+    if (!(signer == order.benefactor || delegatedSigner[signer][order.benefactor])) revert InvalidSignature();\n     return (true, taker_order_hash);\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29404",
      "title": "[G-08] Unnecessary function call (Saves 369 Gas on average)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L89-L99\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4359    | 42190   | 44596 | 66916 |\n| After  | 4359    | 41821   | 44065 | 66385 |\n\n```solidity\nFile: /contracts/StakedUSDe.sol\n89:  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n90:    if (getUnvestedAmount() > 0) revert StillVesting();\n91:    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n93:    vestingAmount = newVestingAmount;\n94:    lastDistributionTimestamp = block.timestamp;\n95:    // transfer assets from rewarder to this contract\n96:    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n98:    emit RewardsReceived(amount, newVestingAmount);\n99:  }\n```\n\nThe function `getUnvestedAmount()` returns `uint256` which means anything greater than or equal to  `0`.\n\nWe revert if the return is greater than 0, which means the only way we get to execute the function `transferInRewards()` is when `getUnvestedAmount()` returns `0`. This begs the question, why do we call the function on the second line if we can only get there when `getUnvestedAmount() == 0`?\n\n\n```diff\ndiff --git a/contracts/StakedUSDe.sol b/contracts/StakedUSDe.sol\nindex 0a56a7d..a378300 100644\n--- a/contracts/StakedUSDe.sol\n+++ b/contracts/StakedUSDe.sol\n@@ -88,7 +88,7 @@ contract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, E\n    */\n   function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n     if (getUnvestedAmount() > 0) revert StillVesting();\n-    uint256 newVestingAmount = amount + getUnvestedAmount();\n+    uint256 newVestingAmount = amount;\n\n     vestingAmount = newVestingAmount;\n     lastDistributionTimestamp = block.timestamp;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29403",
      "title": "[G-07] Cache function calls",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L89-L99\n```solidity\nFile: /contracts/StakedUSDe.sol\n89:  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n90:    if (getUnvestedAmount() > 0) revert StillVesting();\n91:    uint256 newVestingAmount = amount + getUnvestedAmount();\n```\n\nNote, we are calling `getUnvestedAmount()` function two times. If we look at the implementation of that function [here](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L173-L181), we have the following:\n\n```solidity\n173:  function getUnvestedAmount() public view returns (uint256) {\n174:    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;\n\n176:    if (timeSinceLastDistribution >= VESTING_PERIOD) {\n177:      return 0;\n178:    }\n\n180:    return ((VESTING_PERIOD - timeSinceLastDistribution) * vestingAmount) / VESTING_PERIOD;\n181:  }\n```\n\nNote, in this function, we make two state reads(SLOADS) for `lastDistributionTimestamp` and `vestingAmount`. As this is the first SLOAD in this transaction, this means the variables are COLD thus we use 2100 Gas per variable. Ie 4200 Gas for the two variables read.\n\nCalling this function twice would incur a lot of cost (gas). We should cache the results if this call and save them in a local variable as shown below:\n\n```diff\ndiff --git a/contracts/StakedUSDe.sol b/contracts/StakedUSDe.sol\nindex 0a56a7d..0953b2f 100644\n--- a/contracts/StakedUSDe.sol\n+++ b/contracts/StakedUSDe.sol\n@@ -87,8 +87,9 @@ contract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, E\n    * @param amount The amount of rewards to transfer.\n    */\n   function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n-    if (getUnvestedAmount() > 0) revert StillVesting();\n-    uint256 newVestingAmount = amount + getUnvestedAmount();\n+    uint256 _unvestedAmount = getUnvestedAmount();\n+    if (_unvestedAmount > 0) revert StillVesting();\n+    uint256 newVestingAmount = amount + _unvestedAmount;\n\n     vestingAmount = newVestingAmount;\n     lastDistributionTimestamp = block.timestamp;\n```\n\nNote: **The following finding is somehow related to this one, some confusion on why the devs choose to do the calls.** The next finding will show an alternate optimization.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29402",
      "title": "[G-06] We can avoid making a function call here by utilizing the short circuit rules",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L245-L252\n```solidity\nFile: /contracts/StakedUSDe.sol\n245:  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n246:    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n247:      revert OperationNotAllowed();\n248:    }\n249:    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n250:      revert OperationNotAllowed();\n251:    }\n252:  }\n```\n\n```diff\ndiff --git a/contracts/StakedUSDe.sol b/contracts/StakedUSDe.sol\nindex 0a56a7d..8551478 100644\n--- a/contracts/StakedUSDe.sol\n+++ b/contracts/StakedUSDe.sol\n@@ -243,7 +243,7 @@ contract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, E\n    */\n\n   function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n-    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n+    if (to != address(0) && hasRole(FULL_RESTRICTED_STAKER_ROLE, from)) {\n       revert OperationNotAllowed();\n     }\n     if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29401",
      "title": "[G-05] We can save an entire SLOAD (2100 Gas) by short circuiting the operations",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L413-L433\n```solidity\nFile: /contracts/EthenaMinting.sol\n413:  function _transferCollateral(\n\n419:  ) internal {\n420:    // cannot mint using unsupported asset or native ETH even if it is supported for redemptions\n421:    if (!_supportedAssets.contains(asset) || asset == NATIVE_TOKEN) revert UnsupportedAsset();\n```\n\nThe if statement has two checks `!_supportedAssets.contains(asset)` and `asset == NATIVE_TOKEN` where the first check involves making a state read while the second check only compares a constant variable to a function parameter.\n\nAccording to the rules of short circuit, if the first check is true, we do not have to do the second check thus in this case, we should make sure the first check is the cheapest to do.\n\nBy reordering as shown below, we can avoid making the state read if `asset == NATIVE_TOKEN` which would save us ~2100 Gas.\n\n```diff\ndiff --git a/contracts/EthenaMinting.sol b/contracts/EthenaMinting.sol\nindex 32da3a5..35f4613 100644\n--- a/contracts/EthenaMinting.sol\n+++ b/contracts/EthenaMinting.sol\n@@ -418,7 +418,7 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n     uint256[] calldata ratios\n   ) internal {\n     // cannot mint using unsupported asset or native ETH even if it is supported for redemptions\n-    if (!_supportedAssets.contains(asset) || asset == NATIVE_TOKEN) revert UnsupportedAsset();\n+    if (asset == NATIVE_TOKEN || !_supportedAssets.contains(asset) ) revert UnsupportedAsset();\n     IERC20 token = IERC20(asset);\n     uint256 totalTransferred = 0;\n     for (uint256 i = 0; i < addresses.length; ++i) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29400",
      "title": "[G-04] Reading Same state variable twice due to modifier usage (Save 2040 Gas on average from the tests)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L194-L205\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 6349    | 40053   | 27127 | 81127 |\n| After  | 6337    | 38013   | 20962 | 81017 |\n\n```solidity\nFile: /contracts/EthenaMinting.sol\n194:  function redeem(Order calldata order, Signature calldata signature)\n195:    external\n196:    override\n197:    nonReentrant\n198:    onlyRole(REDEEMER_ROLE)\n199:    belowMaxRedeemPerBlock(order.usde_amount)\n200:  {\n201:    if (order.order_type != OrderType.REDEEM) revert InvalidOrder();\n202:    verifyOrder(order, signature);\n203:    if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n204:    // Add to the redeemed amount in this block\n205:    redeemedPerBlock[block.number] += order.usde_amount;\n```\n\nSimilar to our previous finding, the function `redeem()` uses the modifier `belowMaxRedeemPerBlock()` which is implemented as below:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L104-L107\n```solidity\n104:  modifier belowMaxRedeemPerBlock(uint256 redeemAmount) {\n105:    if (redeemedPerBlock[block.number] + redeemAmount > maxRedeemPerBlock) revert MaxRedeemPerBlockExceeded();\n106:    _;\n107:  }\n```\n\nWe read the state variable `redeemedPerBlock[block.number]` which is also read inside the `redeem()` function. We can inline the modifier which would allow us to cache the call which helps avoid making extra sloads.\n\nRefactor the code as shown below.\n```diff\n@@ -196,13 +191,14 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n     override\n     nonReentrant\n     onlyRole(REDEEMER_ROLE)\n-    belowMaxRedeemPerBlock(order.usde_amount)\n   {\n+    uint256 _redeemedPerBlock = redeemedPerBlock[block.number];\n+    if (_redeemedPerBlock + order.usde_amount > maxRedeemPerBlock) revert MaxRedeemPerBlockExceeded();\n     if (order.order_type != OrderType.REDEEM) revert InvalidOrder();\n     verifyOrder(order, signature);\n     if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n     // Add to the redeemed amount in this block\n-    redeemedPerBlock[block.number] += order.usde_amount;\n+    redeemedPerBlock[block.number] = _redeemedPerBlock + order.usde_amount;\n     usde.burnFrom(order.benefactor, order.usde_amount);\n```\n\nSince the modifier was only being used for the function `redeem()`, we can go ahead and delete it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29399",
      "title": "[G-03] Modifier makes it expensive since we end up reading state twice (Saves 1197 Gas on average from the tests)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L162-L174\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4657    | 81745   | 123779 | 195520 |\n| After  | 4645    | 80548   | 123639 | 195380 |\n\n```solidity\nFile: /contracts/EthenaMinting.sol\n162:  function mint(Order calldata order, Route calldata route, Signature calldata signature)\n163:    external\n164:    override\n165:    nonReentrant\n166:    onlyRole(MINTER_ROLE)\n167:    belowMaxMintPerBlock(order.usde_amount)\n168:  {\n169:    if (order.order_type != OrderType.MINT) revert InvalidOrder();\n170:    verifyOrder(order, signature);\n171:    if (!verifyRoute(route, order.order_type)) revert InvalidRoute();\n172:    if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n173:    // Add to the minted amount in this block\n174:    mintedPerBlock[block.number] += order.usde_amount;\n```\n\nThe function `mint()` makes use of the modifier `belowMaxMintPerBlock()` which has the following implementation:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L97-L100\n```solidity\n97:  modifier belowMaxMintPerBlock(uint256 mintAmount) {\n98:    if (mintedPerBlock[block.number] + mintAmount > maxMintPerBlock) revert MaxMintPerBlockExceeded();\n99:    _;\n100:  }\n```\n\nNote, the modifier reads `mintedPerBlock[block.number]` which is a state varible.\n\nOur `mint()` function also does the same SLOAD when adding to the minted amount.\n\nWe can avoid making this two SLOADS by simply in lining this modifier and caching the result of `mintedPerBlock[block.number]` as shown below:\n\n```diff\n@@ -164,14 +164,15 @@ contract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGu\n     override\n     nonReentrant\n     onlyRole(MINTER_ROLE)\n-    belowMaxMintPerBlock(order.usde_amount)\n   {\n+    uint256 _mintedPerBlock = mintedPerBlock[block.number];\n+    if (_mintedPerBlock + order.usde_amount > maxMintPerBlock) revert MaxMintPerBlockExceeded();\n     if (order.order_type != OrderType.MINT) revert InvalidOrder();\n     verifyOrder(order, signature);\n     if (!verifyRoute(route, order.order_type)) revert InvalidRoute();\n     if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n     // Add to the minted amount in this block\n-    mintedPerBlock[block.number] += order.usde_amount;\n+    mintedPerBlock[block.number] = _mintedPerBlock + order.usde_amount;\n     _transferCollateral(\n       order.collateral_amount, order.collateral_asset, order.benefactor, route.addresses, route.ratios\n     );\n```\n\nSince the modifier was only being used for the function `mint()`, we can go ahead and delete it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29398",
      "title": "[G-02] Unnecessary SLOADS inside the constructor (Save 2 SLOADS - 4200 Gas)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L111-L136\n```solidity\nFile: /contracts/EthenaMinting.sol\n111:  constructor(\n112:    IUSDe _usde,\n113:    address[] memory _assets,\n114:    address[] memory _custodians,\n115:    address _admin,\n116:    uint256 _maxMintPerBlock,\n117:    uint256 _maxRedeemPerBlock\n118:  ) {\n  \n\n134:    // Set the max mint/redeem limits per block\n135:    _setMaxMintPerBlock(_maxMintPerBlock);\n136:    _setMaxRedeemPerBlock(_maxRedeemPerBlock);\n```\n\nIn the constructor, we call `_setMaxMintPerBlock()` and `_setMaxRedeemPerBlock()` functions to set `maxMintPerBlock` and `maxRedeemPerBlock` respectively. \nThe functions are defined as follows (we only focus on `_setMaxMintPerBlock()` as they are essentially the same).\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/EthenaMinting.sol#L436-L440\n\n```solidity\n436:  function _setMaxMintPerBlock(uint256 _maxMintPerBlock) internal {\n437:    uint256 oldMaxMintPerBlock = maxMintPerBlock;\n438:    maxMintPerBlock = _maxMintPerBlock;\n439:    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, maxMintPerBlock);\n440:  }\n```\n\nThis function will first read the current value of `maxMintPerBlock` and store in a local variable,however when called inside the constructor, we know the value of `maxMintPerBlock` is `0` so we don't necessarily need to cache it inside the constructor, we just need to set it.\n\nCaching inside the constructor would just mean we are using an SLOAD(2100 gas) to cache value `0`.\n\nI suggest we refactor the constructor as follows which would save us 2 cold SLOADS:\n\n```diff\n     // Set the max mint/redeem limits per block\n-    _setMaxMintPerBlock(_maxMintPerBlock);\n-    _setMaxRedeemPerBlock(_maxRedeemPerBlock);\n+    maxMintPerBlock = _maxMintPerBlock;\n+    maxRedeemPerBlock = _maxRedeemPerBlock;\n```\n\nIf we really need to emit events inside the constructor, we can define a new event that would emit the current set value, i.e. `_maxMintPerBlock` and `_maxRedeemPerBlock`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29397",
      "title": "[G-01] Use constants for variables that don't change (Save a storage SLOT: 2200 Gas)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L22\n```solidity\nFile: /contracts/StakedUSDeV2.sol\n22:  uint24 public MAX_COOLDOWN_DURATION = 90 days;\n```\nThe variable `MAX_COOLDOWN_DURATION` should be declared as a constant variable since it does not change, from the naming, it would seem the intention was to actually make it a constant.\n\n```diff\ndiff --git a/contracts/StakedUSDeV2.sol b/contracts/StakedUSDeV2.sol\nindex df2bb48..f8fa980 100644\n--- a/contracts/StakedUSDeV2.sol\n+++ b/contracts/StakedUSDeV2.sol\n@@ -19,7 +19,7 @@ contract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {\n\n   USDeSilo public silo;\n\n-  uint24 public MAX_COOLDOWN_DURATION = 90 days;\n+  uint24 public constant MAX_COOLDOWN_DURATION = 90 days;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29396",
      "title": "[09] Unneeded function still not removed",
      "impact": "LOW",
      "content": "Per Pashov's audit report, L-04 mentioned that the unused `EthenaMinting::encodeRoute` has been removed by Ethena. However, this erroneous function still exists in EthenaMinting.sol. \n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L334-L336\n\n```diff\n-  function encodeRoute(Route calldata route) public pure returns (bytes memory) {\n-    return abi.encode(ROUTE_TYPE, route.addresses, route.ratios);\n-  }\n```\nConsider removing this controversial function where possible. \n\n**[FJ-Riveros (Ethena) acknowledged](https://github.com/code-423n4/2023-10-ethena-findings/issues/602#issuecomment-1804182947)**\n\n***Note: the following submissions from the same warden were downgraded from Medium to Low/Non-critical and were also considered by the judge in scoring:***\n- [[10] Inconsistent Role-Based Checks in `redistributeLockedAmount` and `_beforeTokenTransfer functions`](https://github.com/code-423n4/2023-10-ethena-findings/issues/367)\n- [[11] Denial-of-Service Vulnerability via Minimum Shares Restriction](https://github.com/code-423n4/2023-10-ethena-findings/issues/371)\n- [[12] Inflexible Withdrawal Management in StakedUSDeV2 Contract](https://github.com/code-423n4/2023-10-ethena-findings/issues/389)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29395",
      "title": "[08] Functions should have fully intended logic",
      "impact": "LOW",
      "content": "The function below is meant to be used only for minting. Hence, redeeming has got nothing to do with this view function. Consider refactoring the first if block so [`mint()`](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L171) could revert earlier if need be:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L351-L374\n\n```diff\n  function verifyRoute(Route calldata route, OrderType orderType) public view override returns (bool) {\n    // routes only used to mint\n-    if (orderType == OrderType.REDEEM) {\n-      return true;\n-    }\n+    if (orderType =! OrderType.MINT) {\n+      return false;\n+    }\n    uint256 totalRatio = 0;\n    if (route.addresses.length != route.ratios.length) {\n      return false;\n    }\n    if (route.addresses.length == 0) {\n      return false;\n    }\n    for (uint256 i = 0; i < route.addresses.length; ++i) {\n      if (!_custodianAddresses.contains(route.addresses[i]) || route.addresses[i] == address(0) || route.ratios[i] == 0)\n      {\n        return false;\n      }\n      totalRatio += route.ratios[i];\n    }\n    if (totalRatio != 10_000) {\n      return false;\n    }\n    return true;\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29394",
      "title": "[07] Typo mistakes",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDeV2.sol#L94<br>\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDeV2.sol#L110\n\n```diff\n-  /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n+  /// @param owner address to redeem and start cooldown, owner must allow caller to perform this action\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29393",
      "title": "[06] Emission of identical values",
      "impact": "LOW",
      "content": "Under the context of the above/preceding recommendation, `transferInRewards()` should also have its `emit` refactored below. Otherwise, you are practically emitting two identical values that defeat the purpose of contrasting the old and the values.\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDe.sol#L89-L99\n\n```diff\n  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n    if (getUnvestedAmount() > 0) revert StillVesting();\n-    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n-    vestingAmount = newVestingAmount;\n+    emit RewardsReceived(vestingAmount, amount);\n+    vestingAmount = amount;\n    lastDistributionTimestamp = block.timestamp;\n    // transfer assets from rewarder to this contract\n    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n-    emit RewardsReceived(amount, newVestingAmount);\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29392",
      "title": "[05] Inexpedient code lines",
      "impact": "LOW",
      "content": "In the function below, the if block already dictates that `getUnvestedAmount() == 0` manages to avoid a revert. Hence, consider refactoring the following code lines as it makes no sense adding 0 value `getUnvestedAmount()` of to the addend, `amount`:   \n      \nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDe.sol#L89-L99\n\n```diff\n  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n    if (getUnvestedAmount() > 0) revert StillVesting();\n-    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n-    vestingAmount = newVestingAmount;\n+    vestingAmount = amount;\n\n    // The rest of the codes\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29391",
      "title": "[04] Easy DoS on big players when minting and redeeming in EthenaMinting.sol",
      "impact": "LOW",
      "content": "As indicated on the audit description, users intending to mint/redeem a large amount will need to mint/redeem over several blocks due to `maxMintPerBlock` or `maxRedeemPerBlock`. However, these RFQ's are prone to DoS because [`mintedPerBlock[block.number] + mintAmount > maxMintPerBlock`](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L98) or [`redeemedPerBlock[block.number] + redeemAmount > maxRedeemPerBlock`](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L105) could revert by only 1 wei in excess.\n\nWhile these issues could be sorted by the backend to make a full use of `maxMintPerBlock` or `maxRedeemPerBlock` per block, it will make the intended logic a lot more efficient by auto reducing the RFQ amount to perfectly fill up the remaining quota for the current block. Better yet, set up a queue system where request amount running in hundreds of thousands or millions may be auto split up with multiple orders via only one signature for batching.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29390",
      "title": "[03] Delta neutrality caution",
      "impact": "LOW",
      "content": "Users should be cautioned about the impermanent losses entailed arising from the delta-neutral stability strategy adopted by the protocol, specifically if the short positions were to encounter hefty losses. Apparently, the users could have held on to their collateral, e.g. `stETH or WETH`, and ended up a lot richer with the equivalent amount of `USDe`. I suggest all minting entries to begin with stable coins like `USDC, DAI etc` that could be converted to `stETH` to generate yield if need be instead of having users depositing `stETH` from their wallet reserves. Psychologically, this will make the users feel better as the mentality has been fostered more on preserving the 1:1 peg of `USDe` at all times. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29389",
      "title": "[02] Be consistent in the code logic when emitting events in setter functions",
      "impact": "LOW",
      "content": "By convention, it's recommended emitting the old value followed by the new one in the same event instead of the other way round.\n\nHere's one instance found:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/USDe.sol#L23-L26\n\n```diff  \n  function setMinter(address newMinter) external onlyOwner {\n-    emit MinterUpdated(newMinter, minter);\n+    emit MinterUpdated(minter, newMinter);\n    minter = newMinter;\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29388",
      "title": "[01] Use an efficient logic in setter functions",
      "impact": "LOW",
      "content": "When intending to emit both the old and new values, there isn't a need to cache the old value that will only be used once. Simply emit both values before assigning a new value to the state variable. For example, the following setter function may be refactored as follows:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L436-L440\n\n```diff\n  function _setMaxMintPerBlock(uint256 _maxMintPerBlock) internal {\n+    emit MaxMintPerBlockChanged(maxMintPerBlock, _maxMintPerBlock);\n-    uint256 oldMaxMintPerBlock = maxMintPerBlock;\n    maxMintPerBlock = _maxMintPerBlock;\n-    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, maxMintPerBlock);\n  }\n```\nAll other instances entailed:\n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L442-L447\n\n```solidity\n  /// @notice Sets the max redeemPerBlock limit\n  function _setMaxRedeemPerBlock(uint256 _maxRedeemPerBlock) internal {\n    uint256 oldMaxRedeemPerBlock = maxRedeemPerBlock;\n    maxRedeemPerBlock = _maxRedeemPerBlock;\n    emit MaxRedeemPerBlockChanged(oldMaxRedeemPerBlock, maxRedeemPerBlock);\n  }\n```\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDeV2.sol#L126-L134\n\n```solidity\n  function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (duration > MAX_COOLDOWN_DURATION) {\n      revert InvalidCooldown();\n    }\n\n    uint24 previousDuration = cooldownDuration;\n    cooldownDuration = duration;\n    emit CooldownDurationUpdated(previousDuration, cooldownDuration);\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29387",
      "title": "[M-04] Malicious users can front-run to cause a denial of service (DoS) for StakedUSDe due to MinShares checks",
      "impact": "MEDIUM",
      "content": "\nMalicious users can transfer `USDe` token to `StakedUSDe` protocol directly lead to a denial of service (DoS) for StakedUSDe due to the limit shares check.\n\n### Proof of Concept\n\nUser deposit `USDe` token to `StakedUSDe` protocol to get share via invoke external `deposit` function. Let's see how share is calculate:\n\n```solidity\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n```\n\nSince `decimalsOffset() == 0` and totalAssets equal the balance of `USDe` in this protocol\n\n```solidity\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n```\n\n$$\nf(share) = (USDeAmount \\ast totalSupply) / (totalUSDeAssets() + 1)\n$$\n\nThe minimum share is set to 1 ether.\n\n```solidity\n  uint256 private constant MIN_SHARES = 1 ether;\n```\n\nAssuming malicious users transfer 1 ether of `USDe` into the protocol and receive ZERO shares, how much tokens does the next user need to pay if they want to exceed the minimum share limit of 1 ether? That would be 1 ether times 1 ether, which is a substantial amount.\n\nI add a test case in `StakedUSDe.t.sol`:\n\n```solidity\n  function testMinSharesViolation() public {\n    address malicious = vm.addr(100);\n\n    usdeToken.mint(malicious, 1 ether);\n    usdeToken.mint(alice, 1000 ether);\n\n    //assume malicious user deposit 1 ether into protocol.\n    vm.startPrank(malicious);\n    usdeToken.transfer(address(stakedUSDe), 1 ether);\n\n    \n    vm.stopPrank();\n    vm.startPrank(alice);\n    usdeToken.approve(address(stakedUSDe), type(uint256).max);\n\n    //1000 ether can't exceed the minimum share limit of 1 ether\n    vm.expectRevert(IStakedUSDe.MinSharesViolation.selector);\n    stakedUSDe.deposit(1000 ether, alice);\n  }\n```\n\nWe can see even Alice deposit a substantial number of tokens but still cannot surpass the 1 ether share limit which will lead to a denial of service (DoS) for StakedUSDe due to MinShares checks.\n\n### Tools Used\n\nvscode\n\n### Recommended Mitigation Steps\n\nWe can solve this issue by setting a minimum deposit amount.\n\n### Assessed type\n\nDoS\n\n**[FJ-Riveros (Ethena) acknowledged, but disagreed with severity and commented via duplicate issue \\#32](https://github.com/code-423n4/2023-10-ethena-findings/issues/32#issuecomment-1805643280):**\n > We acknowledge the potential exploitability of this issue, but we propose marking it as `Medium` severity. Our rationale is based on the fact that this exploit can only occur during deployment. To mitigate this risk, we plan to fund the smart contract in the next block, ensuring that nobody has access to the ABI or contract source code. We could even use flashbots for this purpose. \n\n**[0xDjango (judge) commented via duplicate issue \\#32](https://github.com/code-423n4/2023-10-ethena-findings/issues/88#issuecomment-1828560633):**\n > Agree with medium. Several of the duplicate reports vary in their final impacts but mostly consist of:\n> \n> - Small donation leading to bricked contract\n> - Large donation can eventually lead to blocked withdrawals\n> \n> The small donation impact simply requires a redeploy, though the impact is a valid medium. The large donation has major implications for stakers, but the large amount of capital required downgrades it to medium as well. I will be reviewing each duplicate on a case-by-case basis to ensure that all impacts due to the same bug class fit within medium.\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/88#issuecomment-1806415374)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious user transferring `USDe` token to the `StakedUSDe` protocol, which can lead to a denial of service (DoS) due to the limit shares check. The proof of concept was tested via a test case in `StakedUSDe.t.sol` which showed that even if a user deposits a large amount of tokens, they still cannot surpass the 1 ether share limit. The tools used to identify and investigate the bug were vscode. The recommended mitigation step to solve this issue is to set a minimum deposit amount. The assessed type of the bug is DoS. The severity of the bug was initially high, but was later decreased to medium after further review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/88",
      "tags": [
        "Share Inflation",
        "DOS"
      ],
      "finders": [
        "critical-or-high",
        "ciphermarco",
        "ayden",
        "Yanchuan",
        "pontifex",
        "1",
        "2",
        "Madalad",
        "trachev",
        "peanuts",
        "twcctop",
        "mert\\_eren",
        "cartlex\\_"
      ]
    },
    {
      "id": "29386",
      "title": "[M-03] users still forced to follow previously set cooldownDuration even when cooldown is off (set to zero) before unstaking",
      "impact": "MEDIUM",
      "content": "\nThe `StakedUSDeV2` contract can enforces coolDown periods for users before they are able to unstake/ take out their funds from the silo contract if coolDown is on. Based on the presence of the modifiers `ensureCooldownOff` and `ensureCooldownOn`, it is known that the coolDown state of the `StakedUSDeV2` contract can be toggled on or off.\nIn a scenario where coolDown is on (always turned on by default) and Alice and Bob deposits, two days after Alice wants to withdraw/redeem. Alice is forced to wait for 90 days before completing withdrawal/getting her tokens from the silo contract because Alice must call  coolDownAsset()/coolDownShares() fcns respectively. Bob decides to wait an extra day.\n\nOn the third day, Bob decides to withdraw/redeem. Contract admin also toggles the coolDown off (sets cooldownDuration to 0), meaning there is no longer a coolDown period and all withdrawals should be sent to the users immediately. Bob now calls calls the redeem()/withdraw() fcn to withdraw instantly to his address instead of the silo address since there is no coolDown.\n\nAlice sees Bob has gotten his tokens but Alice cant use the redeem()/withdraw() because her `StakedUSDeV2` were already burned and her underlying assets were sent to the silo contract for storage. Alice cannot sucessfully call `unstake()` because her `userCooldown.cooldownEnd`  value set to \\~ 90 days. Now Alice has to unfairly wait out the 90 days even though coolDowns have been turned off and everyone else has unrestricted access to their assets. Alice only crime is trying to withdraw earlier than Bob. This is a loss to Alice as Alice has no StakedUSDE or the underlying asset for the no longer necessary 90 days as if the assset is volatile, it may lose some fiat value during the unfair and no longer necessary wait period.\n\nIf cooldown is turned off, it should affect all contract processes and as such, withdrawals should become immediate to users. Tokens previously stored in the USDeSilo contract should become accessible to users when the cooldown state is off. Previous withdrawal requests that had a cooldown should no longer be restricted by a coolDown period since coolDown now off and the coolDownDuration of the contract is now 0.\n\n### Proof of Concept\n\n*   Since StakedUSDeV2 is ERC4626, user calls [deposit()](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/94697be8a3f0dfcd95dfb13ffbd39b5973f5c65d/contracts/token/ERC20/extensions/ERC4626.sol#L171C1-L181C6) to deposit the underlying token asset and get minted shares that signify the user's position size in the vault.\n\n*   The coolDown duration is set to 90 days on deployment of the `StakedUSDeV2` contract, meaning coolDown is toggled on by default.\n\n*   User cannot redeem/withdraw his funds via [withdraw()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L52C1-L61C1) and [redeem()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L65C1-L73C4) because coolDown is on. Both functions have the [ensureCooldownOff](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L27C1-L30C4) modifier which reverts if the coolDownDuration value is not 0.\n\n*   User tried to exit position, to withdraw when coolDown is on, user must call coolDownAsset()/coolDownShares(). This will cause :\n\n    *   For the user's underlyingAmount and cooldownEnd timestamp values to be set in the mapping `cooldowns`.  cooldownEnd timestamp values is set to 90 days from the present.\n    *   For the user's `StakedUSDeV2` ERC4626 position shares to be burnt and the positon underlying asset value to be sent to the USDeSilo contract.\n\n```\n\n        /// @notice redeem assets and starts a cooldown to claim the converted underlying asset\n        /// @param assets assets to redeem\n        /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n        function cooldownAssets(uint256 assets, address owner) external ensureCooldownOn returns (uint256) {\n         if (assets > maxWithdraw(owner)) revert ExcessiveWithdrawAmount();\n\n         uint256 shares = previewWithdraw(assets);\n\n         cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n         cooldowns[owner].underlyingAmount += assets;\n\n         _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n         return shares;\n        }\n\n        /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset\n        /// @param shares shares to redeem\n        /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n        function cooldownShares(uint256 shares, address owner) external ensureCooldownOn returns (uint256) {\n         if (shares > maxRedeem(owner)) revert ExcessiveRedeemAmount();\n\n         uint256 assets = previewRedeem(shares);\n\n         cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n         cooldowns[owner].underlyingAmount += assets;\n\n         _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n         return assets;\n        }\n```\n\n*   User can only use unstake() to get the assets from the silo contract. unstake enforces that the block.timestamp (present time) is more than the 90 days cooldown period set during the execution of `cooldownAssets()` and `cooldownShares()` and reverts if 90 days time has not been reached yet.\n\n```\n\n      function unstake(address receiver) external {\n        UserCooldown storage userCooldown = cooldowns[msg.sender];\n        uint256 assets = userCooldown.underlyingAmount;\n\n        if (block.timestamp >= userCooldown.cooldownEnd) {\n          userCooldown.cooldownEnd = 0;\n          userCooldown.underlyingAmount = 0;\n\n          silo.withdraw(receiver, assets);\n        } else {\n          revert InvalidCooldown();\n        }\n      }\n```\n\n*   If contract admin decides to turn the coolDown period off, by setting the cooldownDuration to 0 via [setCooldownDuration()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L126C1-L135C2), user who has his assets under the coolDown in the silo still wont be able to withdraw via [unstake()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L78C1-L90C4) because the logic in `unstake()` doesnt allow for the user's coolDownEnd value which was set under the previous coolDown duration state to be bypassed as coolDowns are now turned off and the StakedUSDeV2 behavior is supposed to be changed to follow ERC4626 standard and allow for the user assets to get to them immediately with no coolDown period still enforced on withdrawals as seen in the comment [here](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L124C38-L124C135).\n\n*   User who initiated withdrawal when the coolDown was toggled on will still continue to be restricted from his tokens/funds even after coolDown is toggled off. This should not be because restrictions are removed, all previous pending withdrawals should be allowed to be completed without wait for 90 days since the coolDownDuration of the contract is now 0.\n\n### Coded Proof of Concept\n\nRun with `forge test --mt test_UnstakeUnallowedAfterCooldownIsTurnedOff`.\n```\n\n    // SPDX-License-Identifier: MIT\n    pragma solidity >=0.8;\n\n    /* solhint-disable private-vars-leading-underscore  */\n    /* solhint-disable var-name-mixedcase  */\n    /* solhint-disable func-name-mixedcase  */\n\n    import \"forge-std/console.sol\";\n    import \"forge-std/Test.sol\";\n    import {SigUtils} from \"forge-std/SigUtils.sol\";\n\n    import \"../../../contracts/USDe.sol\";\n    import \"../../../contracts/StakedUSDeV2.sol\";\n    import \"../../../contracts/interfaces/IUSDe.sol\";\n    import \"../../../contracts/interfaces/IERC20Events.sol\";\n\n    contract StakedUSDeV2CooldownTest is Test, IERC20Events {\n      USDe public usdeToken;\n      StakedUSDeV2 public stakedUSDeV2;\n      SigUtils public sigUtilsUSDe;\n      SigUtils public sigUtilsStakedUSDe;\n      uint256 public _amount = 100 ether;\n\n      address public owner;\n      address public alice;\n      address public bob;\n      address public greg;\n\n      bytes32 SOFT_RESTRICTED_STAKER_ROLE;\n      bytes32 FULL_RESTRICTED_STAKER_ROLE;\n      bytes32 DEFAULT_ADMIN_ROLE;\n      bytes32 BLACKLIST_MANAGER_ROLE;\n      bytes32 REWARDER_ROLE;\n\n      event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n      event Withdraw(\n        address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n      );\n      event LockedAmountRedistributed(address indexed from, address indexed to, uint256 amountToDistribute);\n\n      function setUp() public virtual {\n        usdeToken = new USDe(address(this));\n\n        alice = makeAddr(\"alice\");\n        bob = makeAddr(\"bob\");\n        greg = makeAddr(\"greg\");\n        owner = makeAddr(\"owner\");\n\n        usdeToken.setMinter(address(this));\n\n        vm.startPrank(owner);\n        stakedUSDeV2 = new StakedUSDeV2(IUSDe(address(usdeToken)), makeAddr('rewarder'), owner);\n        vm.stopPrank();\n\n        FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n        SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n        DEFAULT_ADMIN_ROLE = 0x00;\n        BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n        REWARDER_ROLE = keccak256(\"REWARDER_ROLE\");\n      }\n\n      function test_UnstakeUnallowedAfterCooldownIsTurnedOff () public {\n        address staker = address(20);\n        uint usdeTokenAmountToMint = 10000*1e18;\n\n        usdeToken.mint(staker, usdeTokenAmountToMint);\n\n        //at the deposit coolDownDuration is set to 90 days \n        assert(stakedUSDeV2.cooldownDuration() == 90 days);\n\n        vm.startPrank(staker);\n        usdeToken.approve(address(stakedUSDeV2), usdeTokenAmountToMint);\n        \n        stakedUSDeV2.deposit(usdeTokenAmountToMint / 2, staker);\n\n        vm.roll(block.number + 1);\n        uint assets  = stakedUSDeV2.maxWithdraw(staker);\n        stakedUSDeV2.cooldownAssets(assets , staker);\n        \n        vm.stopPrank();\n\n        //assert that cooldown for the staker is now set to 90 days from now \n        ( uint104 cooldownEnd, ) = stakedUSDeV2.cooldowns(staker);\n        assert(cooldownEnd == uint104( block.timestamp + 90 days));\n\n        vm.prank(owner);\n        //toggle coolDown off in the contract \n        stakedUSDeV2.setCooldownDuration(0);\n\n        //now try to unstake, \n        /** since cooldown duration is now 0 and contract is cooldown state is turned off. \n        it should allow unstake immediately but instead it will revert **/\n        vm.expectRevert(IStakedUSDeCooldown.InvalidCooldown.selector);\n        vm.prank(staker);\n        stakedUSDeV2.unstake(staker);\n      }\n    }\n```\n\n### Tools Used\n\nManual review, Foundry\n\n### Recommended Mitigation Steps\n\nModify the code in unstake() fcn to allow for withdrawals from the silo contract when the contract's coolDownDuration has become 0.\n\n### Assessed type\n\nError\n\n**[kayinnnn (Ethena) confirmed and commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/198#issuecomment-1858131607):**\n> Acknowledge the issue, but revise to low severity finding as it causes minor inconvenience in the rare time we change cooldown period. However, it is still fixed - existing per user cooldown is ignored if the global cooldown is `0`.\n\n***\n\n",
      "summary": "\nThis bug report focuses on the `StakedUSDeV2` contract, which is an ERC4626 contract. It enforces coolDown periods for users before they are able to unstake/take out their funds from the silo contract if coolDown is on. The bug is that if coolDown is toggled off and the coolDownDuration of the contract is set to 0, users who initiated withdrawal when the coolDown was toggled on will still be restricted from their tokens/funds even after coolDown is toggled off. This should not be because restrictions are removed, all previous pending withdrawals should be allowed to be completed without waiting for 90 days since the coolDownDuration of the contract is now 0.\n\nProof of concept was provided in the report, which uses the `forge-std/Test.sol` to test the issue. The contract admin is used to toggle coolDown off by setting the cooldownDuration to 0 via `setCooldownDuration()`. Then unstake() is used to try and get the assets from the silo contract but it reverts because the logic in `unstake()` does not allow for the user's coolDownEnd value which was set under the previous coolDown duration state to be bypassed as coolDowns are now turned off and the StakedUSDeV2 behavior is supposed to be changed to follow ERC4626 standard and allow for the user assets to get to them immediately with no coolDown period still enforced on withdrawals.\n\nTo mitigate this issue, the code in unstake() function should be modified to allow for withdrawals from the silo contract when the contract's coolDownDuration has become 0. This bug has been assessed as an Error, as it causes minor inconvenience in the rare time the cooldown period is changed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/198",
      "tags": [
        "Cooldown"
      ],
      "finders": [
        "josephdara",
        "Eeyore",
        "jasonxiale",
        "Mike\\_Bello90",
        "adeolu",
        "Madalad",
        "peanuts",
        "Shubham"
      ]
    },
    {
      "id": "29385",
      "title": "[M-02] Soft Restricted Staker Role can withdraw stUSDe for USDe",
      "impact": "MEDIUM",
      "content": "\nA requirement is stated that a user with the `SOFT_RESTRICTED_STAKER_ROLE` is not allowed to withdraw `USDe` for `stUSDe`.\n\nThe code does not satisfy that condition, when a holder has the `SOFT_RESTRICTED_STAKER_ROLE`, they can exchange their `stUSDe` for `USDe` using `StakedUSDeV2`.\n\n### Description\n\nThe Ethena readme has the following decription of legal requirements for the Soft Restricted Staker Role: <br><https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/README.md?plain=1#L98>\n\n    Due to legal requirements, there's a `SOFT_RESTRICTED_STAKER_ROLE` and `FULL_RESTRICTED_STAKER_ROLE`. \n    The former is for addresses based in countries we are not allowed to provide yield to, for example USA. \n    Addresses under this category will be soft restricted. They cannot deposit USDe to get stUSDe or withdraw stUSDe for USDe. \n    However they can participate in earning yield by buying and selling stUSDe on the open market.\n\nIn summary, legal requires are that a `SOFT_RESTRICTED_STAKER_ROLE`:\n\n*   MUST NOT deposit USDe to get stUSDe\n*   MUST NOT withdraw USDe for USDe\n*   MAY earn yield by trading stUSDe on the open market\n\nAs `StakedUSDeV2` is a `ERC4626`, the `stUSDe` is a share on the underlying `USDe` asset. There are two distinct entrypoints for a user to exchange their share for their claim on the underlying the asset, `withdraw` and `redeem`. Each cater for a different input (`withdraw` being by asset, `redeem` being by share), however both invoked the same internal `_withdraw` function, hence both entrypoints are affected.\n\nThere are two cases where a user with `SOFT_RESTRICTED_STAKER_ROLE` may have acquired `stUSDe`:\n\n*   Brought `stUSDe` on the open market\n*   Deposited `USDe` in `StakedUSDeV2` before being granted the `SOFT_RESTRICTED_STAKER_ROLE`\n\nIn both cases the user can call either withdraw their holding by calling `withdraw` or `redeem` (when cooldown is off), or `unstake` (if cooldown is on) and successfully exchange their `stUSDe` for `USDe`.\n\n### Proof of Concept\n\nThe following two tests demonstrate the use case of a user staking, then being granted the `SOFT_RESTRICTED_STAKER_ROLE`, then exchanging their `stUSDe` for `USDe` (first using `redeem` function, the second using `withdrawm`).\n\nThe use case for acquiring on the open market, only requiring a different setup, however the exchange behaviour is identical and the cooldown enabled `cooldownAssets` and `cooldownShares` function still use the same `_withdraw` as `redeem` and `withdraw`, which leads to the same outcome.\n\n(Place code into `StakedUSDe.t.sol` and run with `forge test`)<br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/test/foundry/staking/StakedUSDe.t.sol>\n\n```Solidity\n  bytes32 public constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n\n  function test_redeem_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe\n    vm.prank(bob);\n    stakedUSDe.redeem(stakeOfBob, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n\n  function test_withdraw_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe (-1 as dust is lost in asset to share rounding in ERC4626)\n    vm.prank(bob);\n    stakedUSDe.withdraw(initialAmount + rewardAmount - 1, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n```\n\n### Tools Used\n\nManual review, Foundry test\n\n### Recommended Mitigation Steps\n\nWith the function overriding present, to prevent the `SOFT_RESTRICTED_STAKER_ROLE` from being able to exchange their `stUSDs` for `USDe`, make the following change in `StakedUSDe`\n\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L232>\n\n```Solidity\n-    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n+    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller)) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1810742469)**\n\n**[kayinnnn (Ethena) disputed and commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1858130415):**\n> For this issue, the docs were incorrect to say withdrawal by soft restricted role is not allowed. Only depositing is not allowed.\n\n***\n\n",
      "summary": "\nA bug report was filed stating that a user with the `SOFT_RESTRICTED_STAKER_ROLE` is not allowed to withdraw `USDe` for `stUSDe`. According to legal requirements, users with the `SOFT_RESTRICTED_STAKER_ROLE` must not deposit `USDe` to get `stUSDe` or withdraw `stUSDe` for `USDe`. However, they can participate in earning yield by buying and selling `stUSDe` on the open market. \n\nThe code does not satisfy that condition, when a holder has the `SOFT_RESTRICTED_STAKER_ROLE`, they can exchange their `stUSDe` for `USDe` using `StakedUSDeV2`. This is because both `withdraw` and `redeem` invoke the same internal `_withdraw` function, hence both entrypoints are affected.\n\nTwo tests were conducted that demonstrate a user with `SOFT_RESTRICTED_STAKER_ROLE` can call either `withdraw` or `redeem` (when cooldown is off), or `unstake` (if cooldown is on) and successfully exchange their `stUSDe` for `USDe`.\n\nTo prevent the `SOFT_RESTRICTED_STAKER_ROLE` from being able to exchange their `stUSDs` for `USDe`, a change should be made to the `StakedUSDe` code. The recommended mitigation steps to fix this bug is to add `hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller)` to the `_withdraw` function.\n\nThe bug was initially classified as High severity, however it was decreased to Medium by 0xDjango. Kayinnnn (Ethena) disputed the finding and commented that for this issue, the documentation was incorrect to say withdrawal by soft restricted role is not allowed. Only depositing is not allowed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/246",
      "tags": [
        "Access Control",
        "Missing Check"
      ],
      "finders": [
        "HChang26",
        "peanuts",
        "SovaSlava",
        "0xAlix2",
        "RamenPeople",
        "squeaky\\_cactus",
        "Kaysoft",
        "Cosine",
        "ast3ros",
        "btk",
        "Yanchuan",
        "Udsen",
        "Oxsadeeq",
        "Arz",
        "Limbooo",
        "pep7siup",
        "Krace",
        "deepkin",
        "dirk\\_y",
        "Shubham"
      ]
    },
    {
      "id": "29384",
      "title": "[M-01] ``FULL_RESTRICTED`` Stakers can bypass restriction through approvals",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L225-L238><br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L245-L248>\n\nThe `StakedUSDe` contract implements a method to `SOFTLY` or `FULLY` restrict user address, and either transfer to another user or burn.\n\nHowever there is an underlying issue. A fully restricted address is supposed to be unable to withdraw/redeem, however this issue can be walked around via the approve mechanism.\n\nThe openzeppelin `ERC4626` contract allows approved address to withdraw and redeem on behalf of another address so far there is an approval.\n\n```solidity\n    function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256) \n```\n\nBlacklisted Users can explore this loophole to redeem their funds fully. This is because in the overridden `_withdraw` function, the token owner is not checked for restriction.\n\n```solidity\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAlso in the overridden `_beforeTokenTransfer` there is a clause added to allow burning from restricted addresses:\n\n```solidity\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAll these issues allows a restricted user to simply approve another address and redeem their usde.\n\n### Proof of Concept\n\nThis is a foundry test that can be run in the `StakedUSDe.blacklist.t.sol` in the `test/foundry/staking` directory.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8;\n\n/* solhint-disable private-vars-leading-underscore  */\n/* solhint-disable func-name-mixedcase  */\n/* solhint-disable var-name-mixedcase  */\n\nimport {console} from \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\nimport {SigUtils} from \"forge-std/SigUtils.sol\";\n\nimport \"../../../contracts/USDe.sol\";\nimport \"../../../contracts/StakedUSDe.sol\";\nimport \"../../../contracts/interfaces/IUSDe.sol\";\nimport \"../../../contracts/interfaces/IERC20Events.sol\";\nimport \"../../../contracts/interfaces/ISingleAdminAccessControl.sol\";\n\ncontract StakedUSDeBlacklistTest is Test, IERC20Events {\n  USDe public usdeToken;\n  StakedUSDe public stakedUSDe;\n  SigUtils public sigUtilsUSDe;\n  SigUtils public sigUtilsStakedUSDe;\n  uint256 public _amount = 100 ether;\n\n  address public owner;\n  address public alice;\n  address public bob;\n  address public greg;\n\n  bytes32 SOFT_RESTRICTED_STAKER_ROLE;\n  bytes32 FULL_RESTRICTED_STAKER_ROLE;\n  bytes32 DEFAULT_ADMIN_ROLE;\n  bytes32 BLACKLIST_MANAGER_ROLE;\n\n  event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n  event Withdraw(\n    address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n  );\n  event LockedAmountRedistributed(address indexed from, address indexed to, uint256 amountToDistribute);\n\n  function setUp() public virtual {\n    usdeToken = new USDe(address(this));\n\n    alice = makeAddr(\"alice\");\n    bob = makeAddr(\"bob\");\n    greg = makeAddr(\"greg\");\n    owner = makeAddr(\"owner\");\n\n    usdeToken.setMinter(address(this));\n\n    vm.startPrank(owner);\n    stakedUSDe = new StakedUSDe(IUSDe(address(usdeToken)), makeAddr('rewarder'), owner);\n    vm.stopPrank();\n\n    FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n    SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n    DEFAULT_ADMIN_ROLE = 0x00;\n    BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  }\n\n  function _mintApproveDeposit(address staker, uint256 amount, bool expectRevert) internal {\n    usdeToken.mint(staker, amount);\n\n    vm.startPrank(staker);\n    usdeToken.approve(address(stakedUSDe), amount);\n\n    uint256 sharesBefore = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      vm.expectRevert(IStakedUSDe.OperationNotAllowed.selector);\n    } else {\n      vm.expectEmit(true, true, true, false);\n      emit Deposit(staker, staker, amount, amount);\n    }\n    stakedUSDe.deposit(amount, staker);\n    uint256 sharesAfter = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      assertEq(sharesAfter, sharesBefore);\n    } else {\n      assertApproxEqAbs(sharesAfter - sharesBefore, amount, 1);\n    }\n    vm.stopPrank();\n  }\n\n \n    function test_fullBlacklist_withdraw_pass() public {\n    _mintApproveDeposit(alice, _amount, false);\n\n    vm.startPrank(owner);\n    stakedUSDe.grantRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n    vm.stopPrank();\n    //@audit-issue assert that alice is blacklisted\n   bool isBlacklisted = stakedUSDe.hasRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n   assertEq(isBlacklisted, true);\n  //@audit-issue The staked balance of Alice\n    uint256 balAliceBefore = stakedUSDe.balanceOf(alice); \n    //@audit-issue The usde balance of address 56\n    uint256 bal56Before = usdeToken.balanceOf(address(56));\n    vm.startPrank(alice);\n    stakedUSDe.approve(address(56), _amount);\n    vm.stopPrank();\n    \n    //@audit-issue address 56 receives approval and can unstake usde for Alice after a blacklist\n    vm.startPrank(address(56));\n    stakedUSDe.redeem(_amount, address(56), alice);\n    vm.stopPrank();\n      //@audit-issue The staked balance of Alice\n     uint256 balAliceAfter = stakedUSDe.balanceOf(alice);\n     //@audit-issue The usde balance of address 56\n     uint256 bal56After = usdeToken.balanceOf(address(56));\n\n      assertEq(bal56Before, 0);\n      assertEq(balAliceAfter, 0);\n      console.log(balAliceBefore);\n      console.log(bal56Before);\n      console.log(balAliceAfter);\n      console.log(bal56After);\n\n  }\n}\n```\n\nHere we use `address(56)` as the second address, and we see that the user can withdraw their `100000000000000000000` tokens that was restricted.\n\nThis is my test result showing the  balances.\n\n```shell\n[PASS] test_fullBlacklist_withdraw_pass() (gas: 239624)\nLogs:\n  100000000000000000000 // Alice staked balance before\n  0 // address(56) USDe balance before\n  0 // Alice staked balance after\n  100000000000000000000 // address(56) USDe balance after\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.68ms\n```\n\n### Tools Used\n\nFoundry, Manual review\n\n### Recommended Mitigation Steps\n\nCheck the token owner as well in the `_withdraw` function:\n\n```solidity\n\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner) ) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[FJ-Riveros (Ethena) confirmed via duplicate issue \\#666](https://github.com/code-423n4/2023-10-ethena-findings/issues/666#issuecomment-1802065692)**\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1810441530)**\n\n**[josephdara (warden) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1811883453):**\n > Hi @0xDjango,  I do believe this is a high severity bug. It does break a major protocol functionality, compromising assets directly. \n> According to the severity categorization:\n> > 3 — High: Assets can be stolen/lost/compromised directly\n>\n> Thanks!\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1815670715):**\n > @josephdara - I have conversed with the project team, and we have agreed that breaking rules due to legal compliance is medium severity as no funds are at risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a loophole in the `StakedUSDe` contract that allows blacklisted users to redeem their funds fully. The issue is that the overridden `_withdraw` and `_beforeTokenTransfer` functions do not check the token owner for restriction. Foundry and manual review were used to identify this issue.\n\nThe recommended mitigation steps are to check the token owner as well in the `_withdraw` function:\n\n```solidity\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner) ) {\n      revert OperationNotAllowed();\n    }\n```\n\nThe severity of the issue was initially categorized as High but was later decreased to Medium by the project team after a discussion as no funds are at risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ethena Labs",
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/499",
      "tags": [
        "Approve",
        "Access Control"
      ],
      "finders": [
        "josephdara",
        "0xAadi",
        "castle\\_chain",
        "HChang26",
        "KIntern\\_NA",
        "Beosin",
        "RamenPeople",
        "degensec",
        "ge6a",
        "SpicyMeatball",
        "J4X",
        "0xpiken",
        "Yanchuan",
        "sorrynotsorry",
        "Arz",
        "tnquanghuy0512",
        "Limbooo",
        "1",
        "2",
        "0xmystery",
        "mert\\_eren",
        "lanrebayode77",
        "Team\\_Rocket"
      ]
    },
    {
      "id": "60290",
      "title": "System Only Support 2642^{64} Nonces",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Acknowledged\" by the client. The client provided the following explanation:\n\n> Won't pose a problem\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:** Currently, the nonce implementation in `_deduplicateOrder()` implies that we can only have 2642^{64} different slots for a user, where each slot allows 256256 bits. However, in the `_orderBitmaps` mapping, the key and value types are of `uint256`, which means different nonces might collide even when they shouldn't (e.g. 264+12^{64}+1 and 11).\n\n**Recommendation:** While it is unlikely for nonces to be this large, we recommend the team consider this issue, document the expected behavior in this scenario, and make appropriate fixes if necessary.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60289",
      "title": "Defining Custom Cryptographic Operations Introduces Unnecessary Risks",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `f6517e6f906e3c8ebda26b308c8bad8524a9748c`. The client provided the following explanation:\n\n> use OZ ECDSA module\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:**`getRsv()` is defined in `EthenaMinting.sol` to help unpack `r,s,v` from the signature bytes. It is recommended to use existing battle-tested libraries (e.g. OpenZepplin's ECDSA library) for cryptographic operations due to the high risk of introducing unintended vulnerabilities.\n\n**Recommendation:** Consider using OpenZepplin's ECDSA library instead of having a custom implementation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60288",
      "title": "Potential Collateral Sent to Non-Team Controlled Addresses",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `9f9527a537cd0b0e80f9c5a88cbeae5892d2d570`. The client provided the following explanation:\n\n> Minters can only transfer assets to whitelisted custodian addresses.\n\n**Description:** There is the potential for collateral to be transferred to addresses that are not controlled by the team as there is no storage in the contract state that contains a set of these addresses that are valid. As a result, there is the potential for USDe-Buy-Orders to be processed that do not transfer the collateral to a team-controlled address. While it is understood that Ethena servers perform validation before sending transactions to the smart contract, we would still like to highlight this possibility.\n\n**Recommendation:** Consider adding a role specifically for custody and only allowing transfers out to go to addresses with this role. This will both improve security and give users peace-of-mind when funds are moved out of the contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60287",
      "title": "Manual Liquidity Control Could Delay USDe Redemptions",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Acknowledged\" by the client. The client provided the following explanation:\n\n> Internally team will maintain ~$200k worth of collateral available for hot redemptions. However team and our custodian does have liquidity control for redemptions\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:** Documentation and the code suggest that the `EthenaMinting` contract doesn't hold any underlying LST assets, but rather custodial wallets do. This is evident in the documentation and the `_transferCollateral` function where collateral is transferred elsewhere. As funds are not stored in the contract itself, the team controls the liquidity that is managed in this contract. As a result, there is the potential that there could be friction for USDe redemptions if there is insufficient liquidity in the Ethena Minting contract.\n\n**Recommendation:** Make clear to the user the schedule for funding the minting smart contract from custodian wallets.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60286",
      "title": "Potential Index Out of Bounds on Mint Orders",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `f6517e6f906e3c8ebda26b308c8bad8524a9748c`. The client provided the following explanation:\n\n> check order type\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:**`EthenaMinting.mint()` does not confirm that the order type being processed is indeed of `OrderType.MINT`. In the case where an Order with `OrderType.REDEEM` is passed to this function, `verifyRoute()` will not validate matching lengths of the `route.addresses` and `route.ratios`, which will result in index out of bounds when transferring collateral. This will lead to a failing transaction without adequate failure logging.\n\n**Recommendation:** In `mint()`, ensure `order.order_type == OrderType.MINT`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60285",
      "title": "The Return Value of `ecrecover()` Should Be Validated For the Zero Address",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `f6517e6f906e3c8ebda26b308c8bad8524a9748c`. The client provided the following explanation:\n\n> use OZ ECDSA module\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:**`ecrecover()` is used to recover the signer of a message. If the recovery fails, `ecrecover()` will return the zero address. This can lead to unintended consequences and therefore, the call should revert if the zero address is returned.\n\n**Recommendation:** Consider adding a check after the call to `ecrecover()` that reverts if `signer == address(0)`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60284",
      "title": "Ownership Can Be Renounced",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `eb4baeec5159d4a174c03f9f617a7ddb40a102ae`. The client provided the following explanation:\n\n> Remove ownership from EthenaMinting and StakedUSDe, and Access Control from USDe, such that each contract only uses one or the other. Extend upon AccessControl and Ownable to prevent renouncing and make ownership transfers 2 step\n\n**Description:** If the owner renounces their ownership, all ownable contracts will be left without an owner. Consequently, any function guarded by the `onlyOwner` modifier will no longer be able to be executed.\n\nAdditionally, the DEFAULT_ADMIN_ROLE can be renounced/revoked from `EthenaMinting` and `StakeUSDe.sol`.\n\n**Recommendation:** Confirm that this is the intended behavior. If not, override and disable the `renounceOwnership()` and `revokeRole()` functions in the affected contracts. For extra security, consider using a two-step process when transferring the ownership of the contract (e.g. `Ownable2Step` from OpenZeppelin).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60283",
      "title": "Input Validation",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `e1e57d7a42cafd3add8b98560da668dab44e7f44`. The client provided the following explanation:\n\n> 1.   setUSDe removed, unnecessary. 2. deterministically set in StakedUSDeV2 constructor, 3a. fixed, 3b. will fail due to address(0) check in OZ ERC20 implementation on transfer\n\n**File(s) affected:**`EthenaMinting.sol`, `USDeSilo.sol`, `StakeUSDeV2.sol`\n\n**Description:** Consider the following input validation checks:\n\n1.   `EthenaMinting.sol`\n    1.   `setUSDe()`\n        1.   Check that `_usde` is not the same as `usde`.\n\n2.   `StakeUSDeV2.sol`\n    1.   `setCooldownDuration()`\n        1.   `duration` should not exceed the specified 90-day maximum cooldown.\n\n    2.   `unstake()`\n        1.   `receiver` should not be the zero address.\n\n**Recommendation:** Consider adding the recommended checks.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60282",
      "title": "Vesting Rate Can Be Slowed by the Rewarder",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `4db61cc26152af219e97811c89224c6407bdc96e`. The client provided the following explanation:\n\n> Previous vesting must complete before new rewards can be transferred in\n\n**File(s) affected:**`StakingUSDe.sol`\n\n**Description:** The rewarder can artificially reduce the vesting rate by transferring in rewards with `transferInRewards()` while previous rewards are still vesting. For example, let's assume `VESTING PERIOD = 1 hour` and the initial reward is `600`, so the current rate of vesting is `10` tokens per minute. Then, after 30 minutes pass, the rewarder transfers in another `60` token as a reward. This means the unvested amount is now `360`, which leads to a vesting rate of `6` tokens per minute. However, users should be entitled to the `10` tokens per minute rate for the remaining `300` tokens reward from the initial transfer.\n\n**Recommendation:** Consider modifing the logic to account for the case even when the rewarder transfers rewards in between vesting periods. At the very least, document this behavior to the users.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60281",
      "title": "The `SOFT_RESTRICTED_STAKER_ROLE` Can Be Bypassed",
      "impact": "MEDIUM",
      "content": "**Update**\nMarked as \"Acknowledged\" by the client. The client provided the following explanation:\n\n> It is by design that the SOFT_RESTRICTED_STAKER_ROLE can interact with the contract and earn yield by acquiring and selling stUSDe on the open market\n\n**File(s) affected:**`StakedUSDe.sol`, `StakedUSDeV2.sol`\n\n**Description:** The `SOFT_RESTRICTED_STAKER_ROLE` is given to addresses that are partially blacklisted from the contract. They are not permited to deposit funds but can still perform all other operations. Therefore, an address with the `SOFT_RESTRICTED_STAKER_ROLE` could transfer their USDe tokens to another address they own and deposit them.\n\n**Recommendation:** Sybil attacks are difficult to avoid. Consider removing the `SOFT_RESTRICTED_STAKER_ROLE` or further restricting the role.",
      "summary": "\nThe client has acknowledged that the `SOFT_RESTRICTED_STAKER_ROLE` is able to interact with the contract and earn yield by acquiring and selling stUSDe on the open market. This role is given to addresses that are partially blacklisted and are not allowed to deposit funds, but can still perform other operations. This means that an address with this role can transfer their USDe tokens to another address they own and deposit them. The recommendation is to consider removing this role or further restricting it to prevent potential Sybil attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60280",
      "title": "System Supports Withdrawal but Does Not Support Deposit of Native Token",
      "impact": "MEDIUM",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `40fcdb40ba46889c6bc4ddcd554637e98bde2f8b`. The client provided the following explanation:\n\n> Added receive()\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:** The system does not support using native ETH as collateral to mint new USDe, as shown in `_transferCollateral()`. However, it seems possible for users to redeem native tokens since `_transferToBeneficiary()` supports it. Furthermore, there is no direct way (other than `selfdestruct()`) for the contract to receive native tokens as `fallback()` and `receive()` are not implemented and there is no payable function.\n\n**Recommendation:** Consider implementing the `receive()` function as a means to deposit the native token into the contract.",
      "summary": "\nThe client has marked a bug as \"Fixed\" and provided an explanation for the fix. The bug was found in the `EthenaMinting.sol` file and it caused issues with using native ETH as collateral to mint new USDe. Although users were able to redeem native tokens, there was no direct way for the contract to receive them. The recommendation is to implement the `receive()` function to allow for the deposit of native tokens into the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60279",
      "title": "Malicious Users Can Perform Dos Attack by Setting Delegated Signer to Self",
      "impact": "MEDIUM",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `e4282dcf1471841f71dd5cb6efe303b104481f92`. The client provided the following explanation:\n\n> Nested mapping structure for delegatedSigner, plus added function to undelegate\n\n**File(s) affected:**`EthenaMinting.sol`\n\n**Description:** When `order.benefector` is a smart contract, it can delegate an EOA to be the signer for the contract, by calling `setDelegatedSigner()`. When `mint()` and `redeem()` are called, they first check that the order is valid by calling `validateOrder()`, which in turn checks that the signer of the order is either `msg.sender` or a delegated signer for `msg.sender` (i.e. `delegatedSigner[signer] == order.benefactor`). Suppose contract A delegates Alice to be the signer by calling `delegateSigner(Alice)`, this would result in `delegatedSigner[Alice] = A`. However, since `setDelegatedSigner()` can be called by anyone, this allows a malicious actor, Bob, to block any `mint()` or `redeem()` calls for contract A (signed by Alice) by front-running it with a call `delegateSigner(Alice)`, which would set `delegatedSigner[Alice] = Bob`, causing `verifyOrder()` to fail.\n\n**Recommendation:** Consider reversing the order of the mapping so that the order benefactor sets the signer. If this goes against the design philosophy, consider creating a nested mapping from the delegated signer to the order benefactor to a boolean. This would prevent a DoS as a single user could have multiple valid delegated signers.",
      "summary": "\nThe client has marked a bug in the `EthenaMinting.sol` file as fixed. The issue was related to a nested mapping structure for delegated signers and a new function to undelegate. When a smart contract called `setDelegatedSigner()`, it could delegate an EOA to be the signer for the contract. However, a malicious actor could exploit this by blocking `mint()` or `redeem()` calls for the contract by front-running it with a call to `delegateSigner()`. The recommendation is to reverse the order of the mapping or create a nested mapping to prevent this exploit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    },
    {
      "id": "60278",
      "title": "Privileged Roles and Ownership",
      "impact": "MEDIUM",
      "content": "**Update**\nMarked as \"Acknowledged\" by the client. The client provided the following explanation:\n\n> By design, Ethena has admin privileges. However more detailed documentation will be\n\n**File(s) affected:**`EthenaMinting.sol`, `StakedUSDeV2.sol`\n\n**Description:** The proper functioning of the protocol heavily depends on the protocol's hedging strategy. In case of market turmoil, it is possible that the protocol cannot liquidate funds from centralized exchanges, so users might not be able to redeem their full balance. Furthermore, to facilitate users redeeming tokens for their USDe, the protocol admin must first transfer enough funds from the custody back into the Ethena Minting contract. There is no on-chain guarantee that USDe will be redeemable as the team can simply choose not to return the funds. Below we list all the privileged roles in the system.\n\n1.   `EthenaMinting`\n    1.   `DEFAULT_ADMIN_ROLE`\n        1.   Can set the `maxMintPerBlock`.\n        2.   Can set the `maxRedeemPerBlock`.\n        3.   Can add and remove addresses from other roles (excluding `owner`).\n\n    2.   `owner`\n        1.   Can set the USDe token address.\n        2.   Can add and remove supported assets.\n\n    3.   `MINTER_ROLE`\n        1.   Can mint stablecoins from assets.\n        2.   **Can transfer any asset in the contract to any address.**\n\n    4.   `REDEEMER_ROLE`\n        1.   Can redeem stablecoins for assets.\n\n    5.   `GATEKEEPER_ROLE`\n        1.   Can disable minting and redeeming.\n        2.   Can remove the `MINTER_ROLE` from an address.\n\n2.   `StakedUSDeV2.sol`\n    1.   `owner/DEFAULT_ADMIN_ROLE`\n        1.   **Can add and remove addresses from other roles. This should be the role of the Gatekeeper according to documentation.**\n        2.   **Can redistribute stUSDe from wallets with the `FULL_RESTRICTED_STAKER_ROLE` to any unrestricted address.**\n\n    2.   `REWARDER_ROLE`\n        1.   Can add vested USDe tokens to the contract via `transferInRewards()`.\n\nIn the current state of the system, privileged roles can perform various actions that would be detrimental to the health of USDe. Most notably, the following capabilities could be problematic:\n\n1.   The price of an order is not considered on-chain, which means that Ethena Labs could mint any amount of USDe without providing an equal amount of underlying tokens or redeem a small amount of USDe for all of the underlying assets.\n2.   The underlying assets backing USDe can be withdrawn from the minting contract to any address.\n3.   stUSDe tokens can be seized at any time by the admin role of the staking contract. There should be a separation of roles between assigning the fully restricted role and redistributing their tokens.\n4.   Profits from the underlying assets intended for stUSDe holders need to be manually deposited.\n\n**Recommendation:** Consider taking steps to make each part of the process more transparent and traceable for users. This would include extensive user-facing documentation, dashboards showing the value of the underlying assets along with their associated centralized positions, greater separation of roles, and whitelisted addresses that are approved to custody the underlying assets.",
      "summary": "\nThis bug report highlights concerns with the functionality and security of the Ethena protocol. The report mentions that the protocol's hedging strategy may not function properly during market turmoil, which could prevent users from redeeming their full balance. Additionally, the report identifies several privileged roles within the system that have the ability to manipulate or misuse funds. For example, the owner role can transfer assets to any address and the Gatekeeper role can remove the Minter role from an address. The report recommends implementing measures to increase transparency and separation of roles to improve the safety of user funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Ethena Labs",
      "source_link": "https://certificate.quantstamp.com/full/ethena-labs/307f3777-9f03-4b08-8b92-b6c243388ebc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Michael Boyle",
        "Jeffrey Kam",
        "Jonathan Mevs"
      ]
    }
  ]
}